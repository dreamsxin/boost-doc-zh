<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Comparison with Associative Containers</title>

<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../unordered.html" title="Chapter&nbsp;24.&nbsp;Boost.Unordered">
<link rel="prev" href="hash_equality.html" title="Equality Predicates and Hash Functions">
<link rel="next" href="rationale.html" title="Implementation Rationale"></head>
<body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="hash_equality.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="rationale.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="unordered.comparison"></a><a class="link" href="comparison.html" title="Comparison with Associative Containers"> Comparison
with Associative Containers 与关联式容器的比较</a>
</h2>
</div>
</div>
</div>
<div class="table">
<a name="id3750273"></a>
<p class="title"><b>Table&nbsp;25.4.&nbsp;Interface
differences.<br>
表&nbsp;25.4. 接口的差异。</b></p>
<div class="table-contents">
<table class="table" summary="Interface differences.">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Associative Containers 关联式容器 </p>
</th>
<th>
<p> Unordered Associative Containers 无序关联式容器 </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> Parameterized by an ordering relation <code class="computeroutput"><span class="identifier">Compare<br>
</span></code>以一个排序关系 <code class="computeroutput"><span class="identifier">Compare</span></code> 来参数化<code class="computeroutput"><span class="identifier"></span></code>
</p>
</td>
<td>
<p> Parameterized by a function object <code class="computeroutput"><span class="identifier">Hash</span></code>
and an equivalence relation <code class="computeroutput"><span class="identifier">Pred</span></code></p>
<p><code class="computeroutput">以一个函数对象</code>
<code class="computeroutput"><span class="identifier">Hash</span></code> 和一个等同性关系 <code class="computeroutput"><span class="identifier">Pred</span></code>
来参数化<code class="computeroutput"><span class="identifier"></span></code> </p>
</td>
</tr>
<tr>
<td>
<p> Keys can be compared using <code class="computeroutput"><span class="identifier">key_compare</span></code>
which is accessed by member function <code class="computeroutput"><span class="identifier">key_comp</span><span class="special">()</span></code>, values can be
compared using <code class="computeroutput"><span class="identifier">value_compare</span></code>
which is accessed by member function <code class="computeroutput"><span class="identifier">value_comp</span><span class="special">()</span></code>.</p>
<p>键值可以使用 <code class="computeroutput"><span class="identifier">key_compare</span></code>
来比较，后者通过成员函数 <code class="computeroutput"><span class="identifier">key_comp</span><span class="special">()</span></code> 来访问，值可以使用 <code class="computeroutput"><span class="identifier">value_compare</span></code>
来比较，后者通过成员函数 <code class="computeroutput"><span class="identifier">value_comp</span><span class="special">()</span></code> 来访问。 </p>
</td>
<td>
<p> Keys can be hashed using <code class="computeroutput"><span class="identifier">hasher</span></code>
which is accessed by member function <code class="computeroutput"><span class="identifier">hash_function</span><span class="special">()</span></code>, and checked
for equality using <code class="computeroutput"><span class="identifier">key_equal</span></code> which
is accessed by member function <code class="computeroutput"><span class="identifier">key_eq</span><span class="special">()</span></code>. There is no
function object for compared or hashing values.</p>
<p>键值可以用 <code class="computeroutput"><span class="identifier">hasher</span></code>
来散列，它通过成员函数 <code class="computeroutput"><span class="identifier">hash_function</span><span class="special">()</span></code> 访问，并且键值使用 <code class="computeroutput"><span class="identifier">key_equal</span></code>
来检查等同性，它通过成员函数 <code class="computeroutput"><span class="identifier">key_eq</span><span class="special">()</span></code>
访问。没有函数对象用于对值进行比较或散列。 </p>
</td>
</tr>
<tr>
<td>
<p> Constructors have optional extra parameters for the
comparison object.</p>
<p>构造函数有可选的额外参数用于比较用的函数对象。 </p>
</td>
<td>
<p> Constructors have optional extra parameters for the
initial minimum number of buckets, a hash function and an equality
object.</p>
<p>构造函数有可选的额外参数，用于初始化最小的桶数量、散列函数和等同性函数对象。 </p>
</td>
</tr>
<tr>
<td>
<p> Keys <code class="computeroutput"><span class="identifier">k1</span></code>, <code class="computeroutput"><span class="identifier">k2</span></code>
are considered equivalent if <code class="computeroutput"><span class="special">!</span><span class="identifier">Compare</span><span class="special">(</span><span class="identifier">k1</span><span class="special">,</span> <span class="identifier">k2</span><span class="special">)</span> <span class="special">&amp;&amp;</span>
<span class="special">!</span><span class="identifier">Compare</span><span class="special">(</span><span class="identifier">k2</span><span class="special">,</span> <span class="identifier">k1</span><span class="special">)</span></code></p>
<p><code class="computeroutput"><span class="special"></span></code> 键值 <code class="computeroutput"><span class="identifier">k1</span></code>,
<code class="computeroutput"><span class="identifier">k2</span></code> 被认为是相等的，如果 <code class="computeroutput"><span class="special">!</span><span class="identifier">Compare</span><span class="special">(</span><span class="identifier">k1</span><span class="special">,</span> <span class="identifier">k2</span><span class="special">)</span> <span class="special">&amp;&amp;</span>
<span class="special">!</span><span class="identifier">Compare</span><span class="special">(</span><span class="identifier">k2</span><span class="special">,</span> <span class="identifier">k1</span><span class="special">)</span></code> </p>
</td>
<td>
<p> Keys <code class="computeroutput"><span class="identifier">k1</span></code>, <code class="computeroutput"><span class="identifier">k2</span></code>
are considered equivalent if <code class="computeroutput"><span class="identifier">Pred</span><span class="special">(</span><span class="identifier">k1</span><span class="special">,</span>
<span class="identifier">k2</span><span class="special">)</span></code>&nbsp;</p>
<p>键值 <code class="computeroutput"><span class="identifier">k1</span></code>, <code class="computeroutput"><span class="identifier">k2</span></code>
被认为是相等的，如果 <code class="computeroutput"><span class="identifier">Pred</span><span class="special">(</span><span class="identifier">k1</span><span class="special">,</span>
<span class="identifier">k2</span><span class="special">)</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> Member function <code class="computeroutput"><span class="identifier">lower_bound</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">upper_bound</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>&nbsp;</p>
<p>成员函数 <code class="computeroutput"><span class="identifier">lower_bound</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code> 和 <code class="computeroutput"><span class="identifier">upper_bound</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code> </p>
</td>
<td>
<p> No equivalent. Since the elements aren't ordered <code class="computeroutput"><span class="identifier">lower_bound</span></code>
and <code class="computeroutput"><span class="identifier">upper_bound</span></code>
would be meaningless.<br>
没有相应的成员函数。因为元素不是有序的，<code class="computeroutput"><span class="identifier">lower_bound</span></code> 和 <code class="computeroutput"><span class="identifier">upper_bound</span></code>
没有意义。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">equal_range</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code> returns an empty
range at the position that k would be inserted if k isn't present in
the container.</p>
<p>如果 k 不在容器中，<code class="computeroutput"><span class="identifier">equal_range</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code> 返回一个空区间，位于 k
可以被插入的位置。 </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">equal_range</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code> returns a range
at the end of the container if k isn't present in the container. It
can't return a positioned range as k could be inserted into multiple
place. To find out the bucket that k would be inserted into use <code class="computeroutput"><span class="identifier">bucket</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>. But remember
that an insert can cause the container to rehash - meaning that the
element can be inserted into a different bucket.</p>
<p>如果 k 不在容器中，<code class="computeroutput"><span class="identifier">equal_range</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>
返回位于容器末尾的区间。它不能返回一个定位的区间，因为 k 可能被插入以多个地方。要找出 k 将被插入的桶，要用 <code class="computeroutput"><span class="identifier">bucket</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>。不过请记住，插入操作可能引起容器的
重散列 - 这意味着该元素可能被插入到另一个桶中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">iterator</span></code>, <code class="computeroutput"><span class="identifier">const_iterator</span></code>
are of the bidirectional category.</p>
<p><code class="computeroutput"><span class="identifier">iterator</span></code>, <code class="computeroutput"><span class="identifier">const_iterator</span></code>
为双向迭代器类别。 </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">iterator</span></code>, <code class="computeroutput"><span class="identifier">const_iterator</span></code>
are of at least the forward category.</p>
<p><code class="computeroutput"><span class="identifier">iterator</span></code>, <code class="computeroutput"><span class="identifier">const_iterator</span></code>
至少为前向迭代器类型。 </p>
</td>
</tr>
<tr>
<td>
<p> Iterators, pointers and references to the container's
elements are never invalidated.<br>
指向容器元素的迭代器、指针和引用都不会失效。 </p>
</td>
<td>
<p> <a class="link" href="buckets.html#unordered.buckets.iterator_invalidation">Iterators
can be invalidated by calls to insert or rehash</a>. Pointers and
references to the container's elements are never invalidated.</p>
<p><a class="link" href="buckets.html#unordered.buckets.iterator_invalidation">调
用 insert 或 rehash 可能引起迭代器失效</a>。而指向容器元素的指针和引用则不会失效。 </p>
</td>
</tr>
<tr>
<td>
<p> Iterators iterate through the container in the order
defined by the comparison object.</p>
<p> 迭代器按照由比较函数对象所定义的顺序遍历容器。 </p>
</td>
<td>
<p> Iterators iterate through the container in an arbitrary
order, that can change as elements are inserted. Although, equivalent
elements are always adjacent.</p>
<p> 迭代器按任意顺序遍历容器，由元素被插入时还可能改变。不过，相等的元素总是保持连续的。 </p>
</td>
</tr>
<tr>
<td>
<p> No equivalent</p>
<p>无对应物 </p>
</td>
<td>
<p> Local iterators can be used to iterate through
individual buckets. (I don't think that the order of local iterators
and iterators are required to have any correspondence.)</p>
<p> 局部迭代器可以用于遍历单个桶。(我不认为局部迭代器和迭代器的顺序有任何对应物) </p>
</td>
</tr>
<tr>
<td>
<p> Can be compared using the <code class="computeroutput"><span class="special">==</span></code>,
<code class="computeroutput"><span class="special">!=</span></code>,
<code class="computeroutput"><span class="special">&lt;</span></code>,
<code class="computeroutput"><span class="special">&lt;=</span></code>,
<code class="computeroutput"><span class="special">&gt;</span></code>,
<code class="computeroutput"><span class="special">&gt;=</span></code>
operators.</p>
<p> 可以用 <code class="computeroutput"><span class="special">==</span></code>, <code class="computeroutput"><span class="special">!=</span></code>,
<code class="computeroutput"><span class="special">&lt;</span></code>,
<code class="computeroutput"><span class="special">&lt;=</span></code>,
<code class="computeroutput"><span class="special">&gt;</span></code>,
<code class="computeroutput"><span class="special">&gt;=</span></code>
操作符进行比较。 </p>
</td>
<td>
<p> No comparison operators are defined in the standard,
although <a class="link" href="rationale.html#unordered.rationale.equality_operators">implementations
might extend the containers to support <code class="computeroutput"><span class="special">==</span></code> and <code class="computeroutput"><span class="special">!=</span></code></a>.</p>
<p>在标准中没有定义比较操作符，不过 <a class="link" href="rationale.html#unordered.rationale.equality_operators">实
现对容器进行扩展以支持 <code class="computeroutput"><span class="special">==</span></code> 和 <code class="computeroutput"><span class="special">!=</span></code></a>。
</p>
</td>
</tr>
<tr>
<td>
<p> </p>
</td>
<td>
<p> When inserting with a hint, implementations are
permitted to ignore the hint.</p>
<p>在带提示的插入操作时，实现被允许可以忽略提示。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">erase</span></code> never
throws an exception</p>
<p><code class="computeroutput"><span class="identifier">erase</span></code> 不会抛出异常 </p>
</td>
<td>
<p> The containers' hash or predicate function can throw
exceptions from <code class="computeroutput"><span class="identifier">erase</span></code></p>
<p>容器的散列函数和谓词函数可以从 <code class="computeroutput"><span class="identifier">erase</span></code> 抛出异常<code class="computeroutput"><span class="identifier"></span></code>
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3751096"></a>
<p class="title"><b>Table&nbsp;25.5.&nbsp;Complexity
Guarantees<br>
表&nbsp;25.5. 复杂度保证</b></p>
<div class="table-contents">
<table class="table" summary="Complexity Guarantees">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> Operation 操作 </p>
</th>
<th>
<p> Associative Containers 关联式容器 </p>
</th>
<th>
<p> Unordered Associative Containers 无序关联式容器 </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> Construction of empty container</p>
<p>空容器的构造 </p>
</td>
<td>
<p> constant</p>
<p>常数 </p>
</td>
<td>
<p> O(<span class="emphasis"><em>n</em></span>)
where <span class="emphasis"><em>n</em></span>
is the minimum number of buckets.</p>
<p> O(<span class="emphasis"><em>n</em></span>)
其中 <span class="emphasis"><em>n</em></span>
为桶的最小数量。 </p>
</td>
</tr>
<tr>
<td>
<p> Construction of container from a range of <span class="emphasis"><em>N</em></span> elements</p>
<p>从带有 <span class="emphasis"><em>N</em></span>
个元素的区间构造容器 </p>
</td>
<td>
<p> O(<span class="emphasis"><em>N</em></span>
log <span class="emphasis"><em>N</em></span>),
O(<span class="emphasis"><em>N</em></span>)
if the range is sorted with <code class="computeroutput"><span class="identifier">value_comp</span><span class="special">()</span></code>&nbsp;</p>
<p>O(<span class="emphasis"><em>N</em></span>
log <span class="emphasis"><em>N</em></span>),
O(<span class="emphasis"><em>N</em></span>)
如果区间已按 <code class="computeroutput"><span class="identifier">value_comp</span><span class="special">()</span></code> 排序<code class="computeroutput"><span class="special"></span></code>
</p>
</td>
<td>
<p> Average case O(<span class="emphasis"><em>N</em></span>),
worst case O(<span class="emphasis"><em>N</em></span><sup>2</sup>)</p>
<p>平均情况 O(<span class="emphasis"><em>N</em></span>),
最坏情况 O(<span class="emphasis"><em>N</em></span><sup>2</sup>)
</p>
</td>
</tr>
<tr>
<td>
<p> Insert a single element</p>
<p>插入单个元素 </p>
</td>
<td>
<p> logarithmic</p>
<p>对数 </p>
</td>
<td>
<p> Average case constant, worst case linear</p>
<p>平均情况为常数时间，最坏情况为线性时间 </p>
</td>
</tr>
<tr>
<td>
<p> Insert a single element with a hint</p>
<p>带提示插入单个元素 </p>
</td>
<td>
<p> Amortized constant if t elements inserted right after
hint, logarithmic otherwise</p>
<p>如果插入的元素恰好在提示位置之后，则为分期常数时间，否则为对数时间 </p>
</td>
<td>
<p> Average case constant, worst case linear (ie. the same
as a normal insert).</p>
<p>平均情况为常数时间，最坏情况为线性时间(即与普通插入一样) </p>
</td>
</tr>
<tr>
<td>
<p> Inserting a range of <span class="emphasis"><em>N</em></span>
elements</p>
<p>插入 <span class="emphasis"><em>N</em></span>
个元素的区间 </p>
</td>
<td>
<p> <span class="emphasis"><em>N</em></span>
log(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>+<span class="emphasis"><em>N</em></span>) </p>
</td>
<td>
<p> Average case O(<span class="emphasis"><em>N</em></span>),
worst case O(<span class="emphasis"><em>N</em></span>
* <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)</p>
<p>平均情况为 O(<span class="emphasis"><em>N</em></span>)，
最坏情况为 O(<span class="emphasis"><em>N</em></span>
* <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>) </p>
</td>
</tr>
<tr>
<td>
<p> Erase by key, <code class="computeroutput"><span class="identifier">k</span></code></p>
<p><code class="computeroutput"><span class="identifier"></span></code> 通过键值 <code class="computeroutput"><span class="identifier">k</span></code>
删除元素<code class="computeroutput"><span class="identifier"></span></code> </p>
</td>
<td>
<p> O(log(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
+ <code class="computeroutput"><span class="identifier">count</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>) </p>
</td>
<td>
<p> Average case: O(<code class="computeroutput"><span class="identifier">count</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>),
Worst case: O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)</p>
<p>平均情况：O(<code class="computeroutput"><span class="identifier">count</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>)，
最坏情况：O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
</p>
</td>
</tr>
<tr>
<td>
<p> Erase a single element by iterator</p>
<p>通过迭代器删除单个元素 </p>
</td>
<td>
<p> Amortized constant</p>
<p>分期常数时间 </p>
</td>
<td>
<p> Average case: O(1), Worst case: O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)</p>
<p>平均情况：O(1)，最坏情况：O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
</p>
</td>
</tr>
<tr>
<td>
<p> Erase a range of <span class="emphasis"><em>N</em></span>
elements</p>
<p>删除 <span class="emphasis"><em>N</em></span>
个元素的区间 </p>
</td>
<td>
<p> O(log(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
+ <span class="emphasis"><em>N</em></span>)
</p>
</td>
<td>
<p> Average case: O(<span class="emphasis"><em>N</em></span>),
Worst case: O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)</p>
<p> 平均情况：O(<span class="emphasis"><em>N</em></span>)，
最坏情况： O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
</p>
</td>
</tr>
<tr>
<td>
<p> Clearing the container</p>
<p>清空容器 </p>
</td>
<td>
<p> O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
</p>
</td>
<td>
<p> O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
</p>
</td>
</tr>
<tr>
<td>
<p> Find</p>
<p>查找 </p>
</td>
<td>
<p> logarithmic</p>
<p>对数时间 </p>
</td>
<td>
<p> Average case: O(1), Worst case: O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)</p>
<p> 平均情况：O(<span style="font-style: italic;">1</span><span class="emphasis"><em></em></span>)，最坏情况： O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>) </p>
</td>
</tr>
<tr>
<td>
<p> Count</p>
<p>计数 </p>
</td>
<td>
<p> O(log(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
+ <code class="computeroutput"><span class="identifier">count</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>) </p>
</td>
<td>
<p> Average case: O(1), Worst case: O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)</p>
<p> 平均情况：O(<span style="font-style: italic;">1</span><span class="emphasis"><em></em></span>)，最坏情况： O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>) </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">equal_range</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code> </p>
</td>
<td>
<p> logarithmic</p>
<p>对数时间 </p>
</td>
<td>
<p> Average case: O(<code class="computeroutput"><span class="identifier">count</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>),
Worst case: O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)</p>
<p>平均情况：O(<code class="computeroutput"><span class="identifier">count</span><span class="special">(</span><span class="identifier">k</span><span class="special">)</span></code>)，
最坏情况：O(<code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">lower_bound</span></code>,<code class="computeroutput"><span class="identifier">upper_bound</span></code>
</p>
</td>
<td>
<p> logarithmic</p>
<p>对数时间 </p>
</td>
<td>
<p> n/a</p>
<p>无 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%">
<tbody>
<tr>
<td align="left"></td>
<td align="right">
<div class="copyright-footer">Copyright © 2003, 2004
Jeremy B. Maitin-Shepard<br>
Copyright © 2005-2008 Daniel James
<p> Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>
</p>
</div>
</td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="hash_equality.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="rationale.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
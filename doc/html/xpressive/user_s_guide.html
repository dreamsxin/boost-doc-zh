<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>User's Guide</title>

<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../xpressive.html" title="Chapter&nbsp;27.&nbsp;Boost.Xpressive">
<link rel="prev" href="../xpressive.html" title="Chapter&nbsp;27.&nbsp;Boost.Xpressive">
<link rel="next" href="reference.html" title="Reference"></head>
<body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="../xpressive.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="xpressive.user_s_guide"></a><a class="link" href="user_s_guide.html" title="User's Guide">User's
Guide 用户指南</a>
</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.introduction">Introduction
简介</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.installing_xpressive">Installing
xpressive 安装xpressive</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start">Quick
Start 快速入门</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#xpressive.user_s_guide.creating_a_regex_object">Creating
a Regex Object 创建一个Regex对象</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.matching_and_searching">Matching
and Searching 匹配与查找</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.accessing_results">Accessing
Results 访问结果</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions">String
Substitutions 字符串替代</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization">String
Splitting and Tokenization 字符串分拆和记号化</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches">Grammars
and Nested Matches 语法和嵌套匹配</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions">Semantic
Actions and User-Defined Assertions 语义动作和用户自定义断言</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.symbol_tables_and_attributes">Symbol
Tables and Attributes 符号表和属性</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits">Localization
and Regex Traits 本地化和 Regex Traits</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks">
Tips 'N Tricks 提示和技巧</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.concepts">Concepts
概念</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.examples">Examples
示例</a></span></dt>
</dl>
</div>
<p> This section describes how to use xpressive to accomplish
text manipulation and parsing tasks. If you are looking for detailed
information regarding specific components in xpressive, check the <a class="link" href="reference.html" title="Reference">Reference</a>
section.<br>
本节描述如何使用 xpressive 来完成文本处理和分析任务。如果你要查找与 xpressive 中特定组件相关的详细信息，请看 <a class="link" href="reference.html" title="Reference">参
考手册</a> 一节。 </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.introduction"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.introduction" title="Introduction">Introduction 简介</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.introduction.what_is_xpressive_"></a>
<h3><a name="id4016430"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.introduction.what_is_xpressive_">What
is xpressive? &nbsp;xpressive是什么？</a> </h3>
<p> xpressive is a regular expression template library. Regular
expressions (regexes) can be written as strings that are parsed
dynamically at runtime (dynamic regexes), or as <span class="emphasis"><em>expression templates</em></span>
<sup>[<a name="id4016454" href="user_s_guide.html#ftn.id4016454" class="footnote">4</a>]</sup>
that are parsed at compile-time (static regexes). Dynamic regexes have
the advantage that they can be accepted from the user as input at
runtime or read from an initialization file. Static regexes have
several advantages. Since they are C++ expressions instead of strings,
they can be syntax-checked at compile-time. Also, they can naturally
refer to code and data elsewhere in your program, giving you the
ability to call back into your code from within a regex match. Finally,
since they are statically bound, the compiler can generate faster code
for static regexes.<br>
xpressive
是一个正则表达式模板库。正则表达式(regexes)可以以字符串方式编写并在运行期进行动态的分析(动态regexes)，又或者作为 <span class="emphasis"><em>表达式模板</em></span> <sup>[<a name="id4016454" href="#ftn.id4016454" class="footnote">4</a>]</sup>
方式编写并在编译期进行分析(静态regexes)。动态regexes的优点在于，它们可以在运行期从用户的输入中获得，或者是从一个初始化文件中读
取。静态regexes也有多个好处。由于它们是C++表达式而不是字符串，所以它们可以在编译期进行语法检查。同时，它们可以很自然地引用你的程序中任
意地方的代码和数据，让你可以在正则表达式匹配时回调你的代码。最后，由于它们是静态绑定的，所以编译器可以为静态regexes生成更快速的代码。 </p>
<p> xpressive's dual nature is unique and powerful. Static
xpressive is a bit like the <a href="http://spirit.sourceforge.net/" target="_top">Spirit Parser Framework</a>. Like <a href="http://spirit.sourceforge.net/" target="_top">Spirit</a>,
you can build grammars with static regexes using expression templates.
(Unlike <a href="http://spirit.sourceforge.net/" target="_top">Spirit</a>, xpressive does exhaustive
backtracking, trying every possibility to find a match for your
pattern.) Dynamic xpressive is a bit like <a href="../../../libs/regex" target="_top">Boost.Regex</a>.
In fact, xpressive's interface should be familiar to anyone who has
used <a href="../../../libs/regex" target="_top">Boost.Regex</a>.
xpressive's innovation comes from allowing you to mix and match static
and dynamic regexes in the same program, and even in the same
expression! You can embed a dynamic regex in a static regex, or <span class="emphasis"><em>vice versa</em></span>,
and the embedded regex will participate fully in the search,
back-tracking as needed to make the match succeed.<br>
xpressive的双重特点是独特且强大的。静态xpressive有点象 <a href="http://spirit.sourceforge.net" target="_top">Spirit
语法分析器框架</a>。和 <a href="http://spirit.sourceforge.net" target="_top">Spirit</a> 一样，你可以用表达式模板为静态regexes构建语法。(和
<a href="http://spirit.sourceforge.net" target="_top">Spirit</a>
不同的的，xpressive进行完全的回溯，尝试每一种可能性以找到与你的模式相匹配的地方)。动态xpressive则有点象 <a href="../../../libs/regex" target="_top">Boost.Regex</a>。
实际上，xpressive的接口对于使用过 <a href="../../../libs/regex" target="_top">Boost.Regex</a>
的任何人都会很熟悉。xpressive的创新在于，它可以让你在同一个程序中混用和匹配静态和动态regexes，甚至是在同一个表达式中！你可以在一
个静态regex中嵌入一个动态regex，或反之，而且嵌入的regex也会完全参与到为了匹配成功而所需的查找和回溯之中。 </p>
<a name="boost_xpressive.user_s_guide.introduction.hello__world_"></a>
<h3><a name="id4016527"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.introduction.hello__world_">Hello,
world!</a> </h3>
<p> Enough theory. Let's have a look at <span class="emphasis"><em>Hello
World</em></span>, xpressive style:<br>
理论知识已经够了。下面我们来看一个xpressive风格的 <span class="emphasis"><em>Hello
World</em></span>： </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">hello</span><span class="special">(</span> <span class="string">"hello world!"</span> <span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\w+) (\\w+)!"</span> <span class="special">);</span><br><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">hello</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">rex</span> <span class="special">)</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// whole match 完整的匹配<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// first capture 第一项匹配<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// second capture 第二项匹配<br></span> <span class="special">}</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program outputs the following:<br>
该程序的输出如下： </p>
<pre class="programlisting">hello world!<br>hello<br>world<br></pre>
<p> The first thing you'll notice about the code is that all the
types in xpressive live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span></code>
namespace.<br>
关于这段代码，你应该留意到的第一件事是，xpressive中的所有类型均位于 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span></code>
名字空间中。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> Most of the rest of the examples in this document will
leave off the <code class="computeroutput"><span class="keyword">using</span> <span class="keyword">namespace</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span></code> directive. Just
pretend it's there.</p>
<p>本文档中的其它例子中，多数时候会省略 <code class="computeroutput"><span class="keyword">using</span> <span class="keyword">namespace</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span></code> 指令。你只要当它存在就行了。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> Next, you'll notice the type of the regular expression object
is <code class="computeroutput"><span class="identifier">sregex</span></code>. If you
are familiar with <a href="../../../libs/regex" target="_top">Boost.Regex</a>,
this is different than what you are used to. The "<code class="computeroutput"><span class="identifier">s</span></code>"
in "<code class="computeroutput"><span class="identifier">sregex</span></code>" stands
for "<code class="computeroutput"><span class="identifier">string</span></code>",
indicating that this regex can be used to find patterns in <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
objects. I'll discuss this difference and its implications in detail
later.<br>
接着，你应该留意到，正则表达式对象的类型是 <code class="computeroutput"><span class="identifier">sregex</span></code>。如果你熟悉 <a href="../../../libs/regex" target="_top">Boost.Regex</a>，
就会发现这和以前用过的有所不同。"<code class="computeroutput"><span class="identifier">sregex</span></code>" 中的 "<code class="computeroutput"><span class="identifier">s</span></code>"
是代表 "<code class="computeroutput"><span class="identifier">string</span></code>"，表示这个
regex可被用于在 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
对象中查找模式。稍后我会详细讨论这些差别和它的含义。 </p>
<p> Notice how the regex object is initialized:<br>
注意regex对象是如何初始化的： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\w+) (\\w+)!"</span> <span class="special">);</span>
</pre>
<p> To create a regular expression object from a string, you must
call a factory method such as <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>.
This is another area in which xpressive differs from other
object-oriented regular expression libraries. Other libraries encourage
you to think of a regular expression as a kind of string on steroids.
In xpressive, regular expressions are not strings; they are little
programs in a domain-specific language. Strings are only one <span class="emphasis"><em>representation</em></span>
of that language. Another representation is an expression template. For
example, the above line of code is equivalent to the following:<br>
要从一个字符串创建正则表达式对象，你必须调用一个工厂方法，如 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>。
这是xpressive不同于其它面向对象的正则表达式库的另一个地方。其它的库鼓励你将正则表达式想象为一种带类固醇的字符串。而在xpressive
中，正则表达式不是字符串；它们是一些用领域专用语言编写的小程序。字符串只是这种语言的一种<span class="emphasis"><em>表
示法</em></span>。另一种表示法是表达式模板。例如，以上那行代码等同于： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">' '</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s2</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span><span class="special">;</span>
</pre>
<p> This describes the same regular expression, except it uses
the domain-specific embedded language defined by static xpressive.<br>
这种写法定义了一个相同的正则表达式，除了它是用领域专用嵌入式语言来定义静态xpressive。 </p>
<p> As you can see, static regexes have a syntax that is
noticeably different than standard Perl syntax. That is because we are
constrained by C++'s syntax. The biggest difference is the use of <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
to mean "followed by". For instance, in Perl you can just put
sub-expressions next to each other:<br>
正如你所见到的，静态regexes具有与标准的Perl语法明显不同的语法。这是因为我们受到C++语法的约束。最大的不同是，使用 <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
来表示"后随"。例如，在Perl中你只需把子表达式一个接一个地写出来： </p>
<pre class="programlisting"><span class="identifier">abc</span>
</pre>
<p> But in C++, there must be an operator separating
sub-expressions:<br>
但是在C++中，就必须要用一个操作符来分隔各个子表达式： </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">&gt;&gt;</span> <span class="identifier">b</span> <span class="special">&gt;&gt;</span> <span class="identifier">c</span>
</pre>
<p> In Perl, parentheses <code class="computeroutput"><span class="special">()</span></code> have special
meaning. They group, but as a side-effect they also create
back-references like <code class="literal">$1</code>
and <code class="literal">$2</code>. In C++, there
is no way to overload parentheses to give them side-effects. To get the
same effect, we use the special <code class="computeroutput"><span class="identifier">s1</span></code>, <code class="computeroutput"><span class="identifier">s2</span></code>,
etc. tokens. Assign to one to create a back-reference (known as a
sub-match in xpressive).<br>
在Perl中，括号<code class="computeroutput"><span class="special">()</span></code>具有特殊的意义。它们负责分组，但是
有一个副作用，它们会同时创建一些反向引用，如 <code class="literal">$1</code>
和 <code class="literal">$2</code>。在C++中，没有办法对括号操作符进行
重载以给予它们这些副作用。为了得到相同的效果，我们使用专用的记号，<code class="computeroutput"><span class="identifier">s1</span></code>, <code class="computeroutput"><span class="identifier">s2</span></code>,
等等。赋值给这样的记号就可以创建一个反向引用(在xpressive中称为子匹配)。 </p>
<p> You'll also notice that the one-or-more repetition operator <code class="computeroutput"><span class="special">+</span></code>
has moved from postfix to prefix position. That's because C++ doesn't
have a postfix <code class="computeroutput"><span class="special">+</span></code> operator. So:<br>
你还应该留意到，一次或多次重复的操作符 <code class="computeroutput"><span class="special">+</span></code>&nbsp;从后缀变为前缀
了。这是因为C++没有后缀的 <code class="computeroutput"><span class="special">+</span></code> 操作符。所以： </p>
<pre class="programlisting"><span class="string">"\\w+"</span>
</pre>
<p> is the same as:<br>
等同于： </p>
<pre class="programlisting"><span class="special">+</span><span class="identifier">_w</span>
</pre>
<p> We'll cover all the other differences <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes" title="Static Regexes">later</a>.<br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes" title="Static Regexes">稍后</a>我们将讨论其它的差异。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.installing_xpressive"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.installing_xpressive" title="Installing xpressive">Installing xpressive 安装
xpressive</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.installing_xpressive.getting_xpressive"></a>
<h3><a name="id4017583"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.installing_xpressive.getting_xpressive">Getting
xpressive 获得 xpressive</a> </h3>
<p> There are three ways to get xpressive. The first and simplest
is to download the latest version of Boost. Just go to <a href="http://sf.net/projects/boost" target="_top">http://sf.net/projects/boost</a>
and follow the “<span class="quote">Download</span>”
link.<br>
有三种方法获得xpressive。第一种也是最简单的方法是，下载最新版本的Boost。访问 <a href="http://sf.net/projects/boost" target="_top">http://sf.net/projects/boost</a>
并点击“<span class="quote">Download</span>”链接。 </p>
<p> The second way is by downloading xpressive.zip at the <a href="http://www.boost-consulting.com/vault/index.php?directory=Strings%20-%20Text%20Processing" target="_top">Boost File Vault</a> in the “<span class="quote">Strings - Text Processing</span>”
directory. In addition to the source code and the Boost license, this
archive contains a copy of this documentation in PDF format. This
version will always be stable and at least as current as the version in
the latest Boost release. It may be more recent. The version in the
File Vault is always guaranteed to work with the latest official Boost
release.<br>
第二种方法是，在“<span class="quote">Strings - Text Processing</span>”
目录中下载位于 <a href="http://www.boost-consulting.com/vault/index.php?directory=Strings%20-%20Text%20Processing" target="_top">Boost File Vault</a>
的
xpressive.zip。除了源代码和Boost许可证外，这个存档中还包含了本文档的一份PDF格式的拷贝。这个版本是稳定的，至少与最新的
Boost发布包中的版本一致。它有可能是更加新一点的版本。在 File Vault 中的版本保证可以与最新的官方Boost发布包一起使用。 </p>
<p> The third way is by directly accessing the Boost Subversion
repository. Just go to <a href="http://svn.boost.org/trac/boost/" target="_top">http://svn.boost.org/trac/boost/</a> and
follow the instructions there for anonymous Subversion access. The
version in Boost Subversion is unstable.<br>
第三种方法是，直接访问Boost Subversion库。只要去到 <a href="http://svn.boost.org/trac/boost/" target="_top">http://svn.boost.org/trac/boost/</a>
并按照其中关于匿名访问 Subversion 的指令去做就可以了。Boost Subversion 中的版本是不稳定的。 </p>
<a name="boost_xpressive.user_s_guide.installing_xpressive.building_with_xpressive"></a>
<h3><a name="id4017658"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.installing_xpressive.building_with_xpressive">Building
with xpressive 用 xpressive 来构建</a> </h3>
<p> Xpressive is a header-only template library, which means you
don't need to alter your build scripts or link to any separate lib file
to use it. All you need to do is <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>. If you
are only using static regexes, you can improve compile times by only
including <code class="computeroutput"><span class="identifier">xpressive_static</span><span class="special">.</span><span class="identifier">hpp</span></code>.
Likewise, you can include <code class="computeroutput"><span class="identifier">xpressive_dynamic</span><span class="special">.</span><span class="identifier">hpp</span></code>
if you only plan on using dynamic regexes.<br>
Xpressive 是一个只含头文件的模板库，这意味着你不需要修改你的构建脚本或链接任何独立的lib文件就可以使用它。你所要做的就是 <code class="computeroutput"><span class="preprocessor">#include</span>
<span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>。如果你只使用静态
regexes，你可以只包含 <code class="computeroutput"><span class="identifier">xpressive_static</span><span class="special">.</span><span class="identifier">hpp</span></code>
以提高编译速度。同样，如果你计划只使用动态regexes，则可以只包含 <code class="computeroutput"><span class="identifier">xpressive_dynamic</span><span class="special">.</span><span class="identifier">hpp</span></code>。
</p>
<p> If you would also like to use semantic actions or custom
assertions with your static regexes, you will need to additionally
include <code class="computeroutput"><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span></code>.<br>
如果你还想在你的静态regexes中使用语义动作或定制化断言，你就需要另外包含 <code class="computeroutput"><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span></code>。
</p>
<a name="boost_xpressive.user_s_guide.installing_xpressive.requirements"></a>
<h3><a name="id4017665"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.installing_xpressive.requirements">Requirements
要求</a> </h3>
<p> Xpressive requires Boost version 1.34.1 or higher.<br>
Xpressive 要求 Boost 1.34.1 或更高版本。 </p>
<a name="boost_xpressive.user_s_guide.installing_xpressive.supported_compilers"></a>
<h3><a name="id4017825"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.installing_xpressive.supported_compilers">Supported
Compilers 支持的编译器</a> </h3>
<p> Currently, Boost.Xpressive is known to work on the following
compilers:<br>
当前，Boost.Xpressive 已知可在以下编译器中使用： </p>
<div class="itemizedlist">
<ul type="disc">
<li> Visual C++ 7.1 and higher </li>
<li> GNU C++ 3.4 and higher </li>
<li> Intel for Linux 8.1 and higher </li>
<li> Intel for Windows 10 and higher </li>
<li> tru64cxx 71 and higher </li>
<li> MinGW 3.4 and higher </li>
<li> HP C/aC++ A.06.14 </li>
</ul>
</div>
<p> Check the latest tests results at Boost's <a href="http://beta.boost.org/development/tests/trunk/developer/xpressive.html" target="_top">Regression Results Page</a>.<br>
最新的测试结果请查阅 Boost 的 <a href="http://beta.boost.org/development/tests/trunk/developer/xpressive.html" target="_top">回归测试结果页</a>。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> Please send any questions, comments and bug reports to
eric &lt;at&gt; boost-consulting &lt;dot&gt; com.<br>
有任何问题、注解和缺陷报告，请发至 eric@boost-consulting.com。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.quick_start"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start" title="Quick Start">Quick Start 快速入门</a>
</h3>
</div>
</div>
</div>
<p> You don't need to know much to start being productive with
xpressive. Let's begin with the nickel tour of the types and algorithms
xpressive provides.<br>
要开始使用xpressive，你并不需要知道得太多。让我们来从xpressive所提供的类型和算法开始来一次简易的浏览。 </p>
<div class="table">
<a name="id4017921"></a>
<p class="title"><b>Table&nbsp;27.1.&nbsp;xpressive's
Tool-Box<br>
表&nbsp;27.1.&nbsp;xpressive的工具箱</b></p>
<div class="table-contents">
<table class="table" summary="xpressive's Tool-Box">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Tool 工具 </p>
</th>
<th>
<p> Description 说明 </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> Contains a compiled regular expression. <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
is the most important type in xpressive. Everything you do with
xpressive will begin with creating an object of type <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>.</p>
<p>含有一个已编译的正则表达式。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
是xpressive之中最重要的类型。你用xpressive做的任何事情都要从创建一个类型为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
的对象开始。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>,
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
contains the results of a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
or <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
operation. It acts like a vector of <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
objects. A <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
object contains a marked sub-expression (also known as a back-reference
in Perl). It is basically just a pair of iterators representing the
begin and end of the marked sub-expression.</p>
<p><code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
含有 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
或 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
操作的结果。它就象一个存有 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象的向量。一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象含有一个已标记的子表达式(在Perl中又称为后向引用)。基本上，它只是一个迭代器对，代表了已标记子表达式的开始和结束。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
</p>
</td>
<td>
<p> Checks to see if a string matches a regex. For <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
to succeed, the <span class="emphasis"><em>whole
string</em></span> must match the regex, from beginning to
end. If you give <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>,
it will write into it any marked sub-expressions it finds.<br>
检查一个字符串是否匹配一个regex。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
要成功，必须是<span class="emphasis"><em>整个字符串</em></span>从
头到尾匹配regex。如果你给了 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>，
那么它会将所有找到的带标记子表达式写入其中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
</p>
</td>
<td>
<p> Searches a string to find a sub-string that matches the
regex. <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
will try to find a match at every position in the string, starting at
the beginning, and stopping when it finds a match or when the string is
exhausted. As with <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>,
if you give <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>,
it will write into it any marked sub-expressions it finds.<br>
查找一个字符串，以发现其中匹配regex的子字符串。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
将尝试在字符串的每个位置查找匹配，从头部开始，当找到一个匹配或者整个字符串找完时停止。使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
时，如果你给了 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>，
那么它会将所有找到的带标记子表达式写入其中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
</p>
</td>
<td>
<p> Given an input string, a regex, and a substitution
string, <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
builds a new string by replacing those parts of the input string that
match the regex with the substitution string. The substitution string
can contain references to marked sub-expressions.<br>
给定一个输入字符串，一个regex和一个替代字符串，<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
通过将输入字符串中与regex相匹配的部分替换为替代字符串来构建一个新的字符串。替代字符串可以含有对带标记子表达式的引用。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> An STL-compatible iterator that makes it easy to find
all the places in a string that match a regex. Dereferencing a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
returns a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>.
Incrementing a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
finds the next match.<br>
一个与STL兼容的迭代器，可以很方便地找到在一个字符串中与某个regex匹配的所有地方。解引用一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
会返回一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>。
递增一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
可以找出下一个匹配。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> Like <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>,
except dereferencing a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
returns a string. By default, it will return the whole sub-string that
the regex matched, but it can be configured to return any or all of the
marked sub-expressions one at a time, or even the parts of the string
that <span class="emphasis"><em>didn't</em></span>
match the regex.<br>
类似于 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>，
除了一点，解引用一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
会返回一个字符串。缺省地，它返回与regex匹配的整个子字符串，不过它也可以被配置为每次返回任一个或整个带标记子表达式，或者甚至是不匹配
regex的部分字符串。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> A factory for <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
objects. It "compiles" a string into a regular expression. You will not
usually have to deal directly with <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
because the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
class has a factory method that uses <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
internally. But if you need to do anything fancy like create a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
object with a different <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>, you
will need to use a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
explicitly.<br>
一个用于 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象的工厂。它将一个字符串"编译"为正则表达式。通常，你不需要直接关心 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>，
因为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
类有一个工厂方法，其内部使用了 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>。
不过，如果你需要做一些花哨的东西，如创建一个带有不同 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code> 的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象，你就需要显式使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
了。&nbsp; </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> Now that you know a bit about the tools xpressive provides,
you can pick the right tool for you by answering the following two
questions:<br>
现在你应该对xpressive所提供的工具有了一些了解，你可以通过回答以下两个问题来找到合适的工具： </p>
<div class="orderedlist">
<ol type="1">
<li> What <span class="emphasis"><em>iterator</em></span>
type will you use to traverse your data?<br>
你要用哪种类型的迭代器来遍历你的数据？ </li>
<li> What do you want to <span class="emphasis"><em>do</em></span>
to your data?<br>
你要对你的数据做什么操作？ </li>
</ol>
</div>
<a name="boost_xpressive.user_s_guide.quick_start.know_your_iterator_type"></a>
<h3><a name="id4018684"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start.know_your_iterator_type">Know
Your Iterator Type 弄明白你的迭代器类型</a> </h3>
<p> Most of the classes in xpressive are templates that are
parameterized on the iterator type. xpressive defines some common
typedefs to make the job of choosing the right types easier. You can
use the table below to find the right types based on the type of your
iterator.<br>
在xpressive中的多数类都是根据迭代器类型参数化的模板类。xpressive定义了一些常用的typedefs来让你可以更容易地选择合适的类
型。你可以用下表基于你的迭代器类型来找到正确的类型。 </p>
<div class="table">
<a name="id4018708"></a>
<p class="title"><b>Table&nbsp;27.2.&nbsp;xpressive
Typedefs vs. Iterator Types<br>
表&nbsp;27.2.&nbsp;xpressive Typedefs 与迭代器类型</b></p>
<div class="table-contents">
<table class="table" summary="xpressive Typedefs vs. Iterator Types">
<colgroup><col><col><col><col><col></colgroup>
<thead><tr>
<th>
<p> </p>
</th>
<th>
<p> std::string::const_iterator </p>
</th>
<th>
<p> char const * </p>
</th>
<th>
<p> std::wstring::const_iterator </p>
</th>
<th>
<p> wchar_t const * </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">sregex</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">cregex</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wsregex</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wcregex</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">smatch</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">cmatch</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wsmatch</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wcmatch</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">sregex_compiler</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">cregex_compiler</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wsregex_compiler</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wcregex_compiler</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">sregex_iterator</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">cregex_iterator</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wsregex_iterator</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wcregex_iterator</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">sregex_token_iterator</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">cregex_token_iterator</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wsregex_token_iterator</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">wcregex_token_iterator</span></code>
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> You should notice the systematic naming convention. Many of
these types are used together, so the naming convention helps you to
use them consistently. For instance, if you have a <code class="computeroutput"><span class="identifier">sregex</span></code>,
you should also be using a <code class="computeroutput"><span class="identifier">smatch</span></code>.<br>
你要留意系统的命名习惯。这些类型经常要一起使用，所以命名习惯可以帮助你一致地使用它们。例如，如果你有一个 <code class="computeroutput"><span class="identifier">sregex</span></code>，
你就应该使用 <code class="computeroutput"><span class="identifier">smatch</span></code>。 </p>
<p> If you are not using one of those four iterator types, then
you can use the templates directly and specify your iterator type.<br>
如果你用的不是以上四种迭代器类型之一，那么你可以直接用模板并指定你的迭代器类型。 </p>
<a name="boost_xpressive.user_s_guide.quick_start.know_your_task"></a>
<h3><a name="id4019204"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start.know_your_task">Know
Your Task 弄明白你的任务</a> </h3>
<p> Do you want to find a pattern once? Many times? Search and
replace? xpressive has tools for all that and more. Below is a quick
reference:<br>
你是不是只想找到一个模式一次？还是多次？是查找还是替换？xpressive 具有所有这些工具，而且更多。以下是一个快速参考： </p>
<div class="table">
<a name="id4019225"></a>
<p class="title"><b>Table&nbsp;27.3.&nbsp;Tasks
and Tools<br>
表&nbsp;27.3. 任务和工具</b></p>
<div class="table-contents">
<table class="table" summary="Tasks and Tools">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> To do this ... 要做... </p>
</th>
<th>
<p> Use this ... 就用... </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex">See
if a whole string matches a regex 判断整个字符串是否匹配一个regex</a> </p>
</td>
<td>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
algorithm </p>
</td>
</tr>
<tr>
<td>
<p> <span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">See
if a string contains a sub-string that matches a regex
判断一个字符串是否包含匹配某个regex的子串</a> </p>
</td>
<td>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
algorithm </p>
</td>
</tr>
<tr>
<td>
<p> <span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">Replace
all sub-strings that match a regex 替换所有匹配regex的子串</a> </p>
</td>
<td>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
algorithm </p>
</td>
</tr>
<tr>
<td>
<p> <span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.find_all_the_sub_strings_that_match_a_regex_and_step_through_them_one_at_a_time">Find
all the sub-strings that match a regex and step through them one at a
time 找到所有匹配regex的子串并逐个处理</a> </p>
</td>
<td>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
class </p>
</td>
</tr>
<tr>
<td>
<p> <span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.split_a_string_into_tokens_that_each_match_a_regex">Split
a string into tokens that each match a regex 将字符串分拆为记号，每个匹配一个regex</a>
</p>
</td>
<td>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
class </p>
</td>
</tr>
<tr>
<td>
<p> <span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.split_a_string_using_a_regex_as_a_delimiter">Split
a string using a regex as a delimiter 用regex作为分隔符分拆一个字符串</a> </p>
</td>
<td>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
class </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> These algorithms and classes are described in excruciating
detail in the Reference section.<br>
在参考手册一节中有这些算法和类的详细说明。 </p>
<div class="tip">
<table summary="Tip" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr>
<td align="left" valign="top">
<p> Try clicking on a task in the table above to see a
complete example program that uses xpressive to solve that particular
task.<br>
点击上表中的某个任务，可以看到一个完整的示例程序，使用xpressive来完成特定任务。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="xpressive.user_s_guide.creating_a_regex_object"></a><a class="link" href="user_s_guide.html#xpressive.user_s_guide.creating_a_regex_object" title="Creating a Regex Object">Creating a Regex Object
创建一个Regex对象</a>
</h3>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes">Static
Regexes 静态Regexes</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes">Dynamic
Regexes 动态Regexes</a></span></dt>
</dl>
</div>
<p> When using xpressive, the first thing you'll do is create a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
object. This section goes over the nuts and bolts of building a regular
expression in the two dialects xpressive supports: static and dynamic.<br>
使用xpressive时，你要做的第一件事就是，创建一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象。本节将详细介绍在静态和动态两种xpressive支持下正则表达式的构建。 </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes" title="Static Regexes">Static Regexes 静态Regexes</a>
</h4>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.overview"></a>
<h3><a name="id4037153"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.overview">Overview
概述</a> </h3>
<p> The feature that really sets xpressive apart from other C/C++
regular expression libraries is the ability to author a regular
expression using C++ expressions. xpressive achieves this through
operator overloading, using a technique called <span class="emphasis"><em>expression templates</em></span>
to embed a mini-language dedicated to pattern matching within C++.
These "static regexes" have many advantages over their string-based
brethren. In particular, static regexes:<br>
真正使得xpressive不同于其它的C/C++正则表达式库的特性是，它可以用C++表达式来编写一个正则表达式。xpressive通过操作符重载
来实现这一功能，它使用一种被称为 <span class="emphasis"><em>表达式模板</em></span>
的技术来将一个专用于模式匹配的小型语言嵌入到C++中。这些"静态regexes"与基于字符串的正则表达式相比，具有多种优点。尤其是，静态
regexes： </p>
<div class="itemizedlist">
<ul type="disc">
<li> are syntax-checked at compile-time; they will never fail
at run-time due to a syntax error.<br>
编译期进行语法检查；它们不会在运行期因为语法错误了失败。 </li>
<li> can naturally refer to other C++ data and code, including
other regexes, making it simple to build grammars out of regular
expressions and bind user-defined actions that execute when parts of
your regex match.<br>
可以自然地引用其它C++数据和代码，包括其它regexes，可以很简单地构建正则表达式之外的语法和绑定一些用户自定义的动作，在你的regex部分
匹配时去执行。 </li>
<li> are statically bound for better inlining and optimization.
Static regexes require no state tables, virtual functions, byte-code or
calls through function pointers that cannot be resolved at compile time.<br>
它们是静态绑定的，可以更好地内联和优化。静态regexes不需要状态表、虚函数、字节编码或通过不能在编译期进行决议的函数指针进行调用。 </li>
<li> are not limited to searching for patterns in strings. You
can declare a static regex that finds patterns in an array of integers,
for instance.<br>
它们不限于仅在字符串中进行模式查找。比如，你可以声明一个静态regex来在一个整数数组中进行模式查找。 </li>
</ul>
</div>
<p> Since we compose static regexes using C++ expressions, we are
constrained by the rules for legal C++ expressions. Unfortunately, that
means that "classic" regular expression syntax cannot always be mapped
cleanly into C++. Rather, we map the regex <span class="emphasis"><em>constructs</em></span>,
picking new syntax that is legal C++.<br>
因为我们是用C++表达式来构成静态regexes的，所以我们受制于合法C++表达式的规则。很不幸，这意味着"传统的"正则表达式语法并不总是能清晰
地映射到C++中。在一定程度上，我们映射regex <span class="emphasis"><em>结
构</em></span>，选择新的语法以符合C++。 </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.construction_and_assignment"></a>
<h3><a name="id4037235"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.construction_and_assignment">Construction
and Assignment 构造和赋值</a> </h3>
<p> You create a static regex by assigning one to an object of
type <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>.
For instance, the following defines a regex that can be used to find
patterns in objects of type <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>:<br>
你要通过将某个东西赋值给一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象来创建一个静态regex。例如，以下定义了一个可以用于在 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
对象中进行模式查找的regex： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="char">'$'</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="char">'.'</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">;</span>
</pre>
<p> Assignment works similarly.<br>
赋值操作与之相似。 </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.character_and_string_literals"></a>
<h3><a name="id4037382"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.character_and_string_literals">Character
and String Literals 字符和字符串文字常量</a> </h3>
<p> In static regexes, character and string literals match
themselves. For instance, in the regex above, <code class="computeroutput"><span class="char">'$'</span></code>
and <code class="computeroutput"><span class="char">'.'</span></code>
match the characters <code class="computeroutput"><span class="char">'$'</span></code> and <code class="computeroutput"><span class="char">'.'</span></code>
respectively. Don't be confused by the fact that <code class="literal">$</code> and <code class="literal">.</code>
are meta-characters in Perl. In xpressive, literals always represent
themselves.<br>
在静态regexes中，字符和字符串文字常量匹配它们自身。例如，上述regex中，<code class="computeroutput"><span class="char">'$'</span></code> 和 <code class="computeroutput"><span class="char">'.'</span></code>
分别匹配字符 <code class="computeroutput"><span class="char">'$'</span></code>
和 <code class="computeroutput"><span class="char">'.'</span></code>。
不要将这与Perl中的元字符 <code class="literal">$</code> 和 <code class="literal">.</code> 相混淆。在xpressive中，文字常量总是表示它们自身。
</p>
<p> When using literals in static regexes, you must take care
that at least one operand is not a literal. For instance, the following
are <span class="emphasis"><em>not</em></span>
valid regexes:<br>
在静态regexes中使用文字常量时，你必须要小心，至少要有一个操作数不是文字常量。例如，以下就不是有效的regexes： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re1</span> <span class="special">=</span> <span class="char">'a'</span> <span class="special">&gt;&gt;</span> <span class="char">'b'</span><span class="special">;</span> <span class="comment">// ERROR!<br></span><span class="identifier">sregex</span> <span class="identifier">re2</span> <span class="special">=</span> <span class="special">+</span><span class="char">'a'</span><span class="special">;</span> <span class="comment">// ERROR!<br></span></pre>
<p> The two operands to the binary <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
operator are both literals, and the operand of the unary <code class="computeroutput"><span class="special">+</span></code>
operator is also a literal, so these statements will call the native
C++ binary right-shift and unary plus operators, respectively. That's
not what we want. To get operator overloading to kick in, at least one
operand must be a user-defined type. We can use xpressive's <code class="computeroutput"><span class="identifier">as_xpr</span><span class="special">()</span></code> helper function
to "taint" an expression with regex-ness, forcing operator overloading
to find the correct operators. The two regexes above should be written
as:<br>
二元 <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
操作符的两个操作数都是文字常量，而一元 <code class="computeroutput"><span class="special">+</span></code>
操作符的操作数也是一个文字常量，所以这两个语句会分别调用C++原本的二元右移操作符和一元加操作符。那不是我们想要的。要触发操作符的重载，必须至少
有一个操作数是用户自定义类型。我们可以使用xpressive和 <code class="computeroutput"><span class="identifier">as_xpr</span><span class="special">()</span></code>
辅助函数来将一个表达式"变为"regex-化，迫使操作符重载去查找正确的操作符。以上两个regexes应写为： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re1</span> <span class="special">=</span> <span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'b'</span><span class="special">;</span> <span class="comment">// OK<br></span><span class="identifier">sregex</span> <span class="identifier">re2</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">);</span> <span class="comment">// OK<br></span></pre>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.sequencing_and_alternation"></a>
<h3><a name="id4037699"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.sequencing_and_alternation">Sequencing
and Alternation 序列和选择</a> </h3>
<p> As you've probably already noticed, sub-expressions in static
regexes must be separated by the sequencing operator, <code class="computeroutput"><span class="special">&gt;&gt;</span></code>.
You can read this operator as "followed by".<br>
你可能已经留意到，静态regexes中的子表达式必须用序列操作符 <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
来分隔。你可以将这个操作符念成"后随"。 </p>
<pre class="programlisting"><span class="comment">// Match an 'a' followed by a digit 匹配一个'a'后随一个数字<br></span><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="char">'a'</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">;</span>
</pre>
<p> Alternation works just as it does in Perl with the <code class="computeroutput"><span class="special">|</span></code>
operator. You can read this operator as "or". For example:<br>
选择操作则和Perl中一样，使用 <code class="computeroutput"><span class="special">|</span></code>
操作符。你可以将这个操作符念成"或"。例如： </p>
<pre class="programlisting"><span class="comment">// match a digit character or a word character one or more times 匹配一个数字或单词字符一次或多次<br></span><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">|</span> <span class="identifier">_w</span> <span class="special">);</span>
</pre>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.grouping_and_captures"></a>
<h3><a name="id4037853"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.grouping_and_captures">Grouping
and Captures 分组和捕获</a> </h3>
<p> In Perl, parentheses <code class="computeroutput"><span class="special">()</span></code> have special
meaning. They group, but as a side-effect they also create
back-references like <code class="literal">$1</code>
and <code class="literal">$2</code>. In C++,
parentheses only group -- there is no way to give them side-effects. To
get the same effect, we use the special <code class="computeroutput"><span class="identifier">s1</span></code>, <code class="computeroutput"><span class="identifier">s2</span></code>,
etc. tokens. Assigning to one creates a back-reference. You can then
use the back-reference later in your expression, like using <code class="literal">\1</code> and <code class="literal">\2</code>
in Perl. For example, consider the following regex, which finds
matching HTML tags:<br>
在Perl中，括号 <code class="computeroutput"><span class="special">()</span></code>
具有特别的意义。它们进行分组，但是有一个副作用，它们同时创建后向引用，如 <code class="literal">$1</code>
和 <code class="literal">$2</code>。在C++中，括号只能进行分组 --
无法产生相应的副作用。要得到相同的效果，我们要使用特殊的记号，如 <code class="computeroutput"><span class="identifier">s1</span></code>, <code class="computeroutput"><span class="identifier">s2</span></code>,
等等。每赋值一个就创建一个后向引用。然后你就可以在你的表达式中使用这些后向引用，和在Perl中使用 <code class="literal">\1</code> 和 <code class="literal">\2</code>
一样。例如，以下regex可以查找成对的HTML标签： </p>
<pre class="programlisting"><span class="string">"&lt;(\\w+)&gt;.*?&lt;/\\1&gt;"</span>
</pre>
<p> In static xpressive, this would be:<br>
在静态xpressive中，它们可以这样写： </p>
<pre class="programlisting"><span class="char">'&lt;'</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span> <span class="special">&gt;&gt;</span> <span class="special">-*</span><span class="identifier">_</span> <span class="special">&gt;&gt;</span> <span class="string">"&lt;/"</span> <span class="special">&gt;&gt;</span> <span class="identifier">s1</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span>
</pre>
<p> Notice how you capture a back-reference by assigning to <code class="computeroutput"><span class="identifier">s1</span></code>,
and then you use <code class="computeroutput"><span class="identifier">s1</span></code> later in the
pattern to find the matching end tag.<br>
留意你要如何通过赋值给 <code class="computeroutput"><span class="identifier">s1</span></code>
来捕获一个后向引用，以及如何在模式中使用 <code class="computeroutput"><span class="identifier">s1</span></code> 来匹配结束标签。 </p>
<div class="tip">
<table summary="Tip" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr>
<td align="left" valign="top">
<p> <span class="bold"><strong>Grouping
without capturing a back-reference 分组但不捕获后向引用</strong></span>
&nbsp;<br>
<br>
In xpressive, if you just want grouping without capturing a
back-reference, you can just use <code class="computeroutput"><span class="special">()</span></code> without <code class="computeroutput"><span class="identifier">s1</span></code>.
That is the equivalent of Perl's <code class="literal">(?:)</code>
non-capturing grouping construct.</p>
<p>在xpressive中，如果你只是想分组而不捕获后向引用，你可以使用不带 <code class="computeroutput"><span class="identifier">s1</span></code>
的 <code class="computeroutput"><span class="special">()</span></code>。
这等价于Perl的 <code class="literal">(?:)</code>
非捕获分组结构。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.case_insensitivity_and_internationalization"></a>
<h3><a name="id4038124"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.case_insensitivity_and_internationalization">Case-Insensitivity
and Internationalization 大小写不敏感和国际化</a> </h3>
<p> Perl lets you make part of your regular expression
case-insensitive by using the <code class="literal">(?i:)</code>
pattern modifier. xpressive also has a case-insensitivity pattern
modifier, called <code class="computeroutput"><span class="identifier">icase</span></code>. You can
use it as follows:<br>
Perl可以让你通过使用 <code class="literal">(?i:)</code>
模式修改符来将部分正则表达式变为大小写不敏感。xpressive也有一个大小写不敏感的模式修改符，称为 <code class="computeroutput"><span class="identifier">icase</span></code>。
你可以象以下这样使用它： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="string">"this"</span> <span class="special">&gt;&gt;</span> <span class="identifier">icase</span><span class="special">(</span> <span class="string">"that"</span> <span class="special">);</span>
</pre>
<p>在这个正则表达式中，<code class="computeroutput"><span class="string">"this"</span></code> 将被精确匹配，而 <code class="computeroutput"><span class="string">"that"</span></code>
则在匹配时不考虑大小写。 </p>
<p> Case-insensitive regular expressions raise the issue of
internationalization: how should case-insensitive character comparisons
be evaluated? Also, many character classes are locale-specific. Which
characters are matched by <code class="computeroutput"><span class="identifier">digit</span></code> and which
are matched by <code class="computeroutput"><span class="identifier">alpha</span></code>? The
answer depends on the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code> object
the regular expression object is using. By default, all regular
expression objects use the global locale. You can override the default
by using the <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
pattern modifier, as follows:<br>
大小写不敏感的正则表达式引起了一个国际化的问题：大小写不敏感的字符应该如何比较其相等性？而且，许多字符类都是指定locale的。哪些字符匹配 <code class="computeroutput"><span class="identifier">digit</span></code>
而哪些字符匹配 <code class="computeroutput"><span class="identifier">alpha</span></code>
呢？答案取决于正则表达式对象所使用的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>
对象。缺省地，所有正则表达式对象使用全局locale。你可以用 <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
模式修改符来覆盖这一缺省值，如下： </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">my_locale</span> <span class="special">=</span> <span class="comment">/* initialize a std::locale object */</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span> <span class="identifier">my_locale</span> <span class="special">)(</span> <span class="special">+</span><span class="identifier">alpha</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">digit</span> <span class="special">);</span>
</pre>
<p> This regular expression will evaluate <code class="computeroutput"><span class="identifier">alpha</span></code>
and <code class="computeroutput"><span class="identifier">digit</span></code> according
to <code class="computeroutput"><span class="identifier">my_locale</span></code>. See
the section on <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits" title="Localization and Regex Traits">Localization and Regex
Traits</a> for more information about how to customize the
behavior of your regexes.<br>
这个正则表达式将依据 <code class="computeroutput"><span class="identifier">my_locale</span></code> 来求值 <code class="computeroutput"><span class="identifier">alpha</span></code>
和 <code class="computeroutput"><span class="identifier">digit</span></code>。
有关如何定制你的regexes的行为的更多信息，请看 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits" title="Localization and Regex Traits">本地化和Regex Traits</a>
一节。 </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.static_xpressive_syntax_cheat_sheet"></a>
<h3><a name="id4038460"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.static_xpressive_syntax_cheat_sheet">Static
xpressive Syntax Cheat Sheet 静态 xpressive 语法对照表</a> </h3>
<p> The table below lists the familiar regex constructs and their
equivalents in static xpressive.<br>
下表列出了常见的regex结构以及在静态xpressive中的等价物。 </p>
<div class="table">
<a name="id4038482"></a>
<p class="title"><b>Table&nbsp;27.4.&nbsp;Perl
syntax vs. Static xpressive syntax<br>
表&nbsp;27.4.&nbsp;Perl语法 vs. 静态xpressive语法</b></p>
<div class="table-contents">
<table class="table" summary="Perl syntax vs. Static xpressive syntax">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> Perl </p>
</th>
<th>
<p> Static xpressive 静态xpressive </p>
</th>
<th>
<p> Meaning 含义 </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="literal">.</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/_.html" title="Global _">_</a></code> </p>
</td>
<td>
<p> any character (assuming Perl's /s modifier).</p>
<p>任意字符(假定有Perl的/s修改符)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">ab</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">a</span> <span class="special">&gt;&gt;</span>
<span class="identifier">b</span></code>
</p>
</td>
<td>
<p> sequencing of <code class="literal">a</code>
and <code class="literal">b</code> sub-expressions.</p>
<p><code class="literal">a</code> 和 <code class="literal">b</code> 子表达式的顺序序列。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a|b</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">a</span> <span class="special">|</span>
<span class="identifier">b</span></code>
</p>
</td>
<td>
<p> alternation of <code class="literal">a</code>
and <code class="literal">b</code> sub-expressions.</p>
<p><code class="literal">a</code> 和 <code class="literal">b</code> 子表达式的二选一。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(a)</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">(</span><a class="link" href="../boost/xpressive/s1.html" title="Global s1">s1</a><span class="special">=</span> <span class="identifier">a</span><span class="special">)</span></code> </p>
</td>
<td>
<p> group and capture a back-reference.</p>
<p>分组并捕获一个后向引用。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(?:a)</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">(</span><span class="identifier">a</span><span class="special">)</span></code> </p>
</td>
<td>
<p> group and do not capture a back-reference.</p>
<p>分组但不捕获后向引用。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\1</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/s1.html" title="Global s1">s1</a></code> </p>
</td>
<td>
<p> a previously captured back-reference.</p>
<p>之前捕获的一个后向引用。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a*</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">*</span><span class="identifier">a</span></code>
</p>
</td>
<td>
<p> zero or more times, greedy.</p>
<p>零次或多次，贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a+</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">+</span><span class="identifier">a</span></code>
</p>
</td>
<td>
<p> one or more times, greedy.</p>
<p>一次或多次，贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a?</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">!</span><span class="identifier">a</span></code>
</p>
</td>
<td>
<p> zero or one time, greedy.</p>
<p>零次或一次，贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a{n,m}</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/repeat.html" title="Function repeat">repeat</a><span class="special">&lt;</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">&gt;(</span><span class="identifier">a</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> between <code class="literal">n</code>
and <code class="literal">m</code> times, greedy.</p>
<p><code class="literal">n</code> 至 <code class="literal">m</code> 次，贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a*?</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">-*</span><span class="identifier">a</span></code>
</p>
</td>
<td>
<p> zero or more times, non-greedy.</p>
<p>零次或多次，非贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a+?</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">-+</span><span class="identifier">a</span></code>
</p>
</td>
<td>
<p> one or more times, non-greedy.</p>
<p>一次或多次，非贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a??</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">-!</span><span class="identifier">a</span></code>
</p>
</td>
<td>
<p> zero or one time, non-greedy.</p>
<p>零次或一次，非贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">a{n,m}?</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">-</span><a class="link" href="../boost/xpressive/repeat.html" title="Function repeat">repeat</a><span class="special">&lt;</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">&gt;(</span><span class="identifier">a</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> between <code class="literal">n</code>
and <code class="literal">m</code> times,
non-greedy.</p>
<p><code class="literal">n</code> 至 <code class="literal">m</code> 次，非贪心式。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">^</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/bos.html" title="Global bos">bos</a></code> </p>
</td>
<td>
<p> beginning of sequence assertion.</p>
<p>序列起点断言。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/eos.html" title="Global eos">eos</a></code> </p>
</td>
<td>
<p> end of sequence assertion.</p>
<p>序列末点断言。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\b</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/_b.html" title="Global _b">_b</a></code> </p>
</td>
<td>
<p> word boundary assertion.</p>
<p>单词边界断言。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\B</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/_b.html" title="Global _b">_b</a></code>
</p>
</td>
<td>
<p> not word boundary assertion.</p>
<p>非单词边界断言。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\n</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/_n.html" title="Global _n">_n</a></code> </p>
</td>
<td>
<p> literal newline.</p>
<p>字面换行。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">.</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/_n.html" title="Global _n">_n</a></code>
</p>
</td>
<td>
<p> any character except a literal newline (without Perl's
/s modifier).</p>
<p>除字面换行外的任意字符(不带Perl的/s修改符)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\r?\n|\r</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/_ln.html" title="Global _ln">_ln</a></code> </p>
</td>
<td>
<p> logical newline.</p>
<p>逻辑换行。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[^\r\n]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/_ln.html" title="Global _ln">_ln</a></code>
</p>
</td>
<td>
<p> any single character not a logical newline.</p>
<p>非逻辑换行外的任意字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\w</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/_w.html" title="Global _w">_w</a></code> </p>
</td>
<td>
<p> a word character, equivalent to set[alnum | '_'].</p>
<p>一个单词字符，等价于 set[alnum | '_']. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\W</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/_w.html" title="Global _w">_w</a></code>
</p>
</td>
<td>
<p> not a word character, equivalent to ~set[alnum | '_'].</p>
<p>不是一个单词字符，等价于 ~set[alnum | '_']. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\d</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/_d.html" title="Global _d">_d</a></code> </p>
</td>
<td>
<p> a digit character.</p>
<p>数字字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\D</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/_d.html" title="Global _d">_d</a></code>
</p>
</td>
<td>
<p> not a digit character.</p>
<p>非数字字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\s</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/_s.html" title="Global _s">_s</a></code> </p>
</td>
<td>
<p> a space character.</p>
<p>空白字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\S</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/_s.html" title="Global _s">_s</a></code>
</p>
</td>
<td>
<p> not a space character.</p>
<p>非空白字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:alnum:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/alnum.html" title="Global alnum">alnum</a></code> </p>
</td>
<td>
<p> an alpha-numeric character.</p>
<p>字母-数字字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:alpha:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/alpha.html" title="Global alpha">alpha</a></code> </p>
</td>
<td>
<p> an alphabetic character.</p>
<p>字母字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:blank:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/blank.html" title="Global blank">blank</a></code> </p>
</td>
<td>
<p> a horizontal white-space character.</p>
<p>水平空白字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:cntrl:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/cntrl.html" title="Global cntrl">cntrl</a></code> </p>
</td>
<td>
<p> a control character.</p>
<p>控制字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:digit:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/digit.html" title="Global digit">digit</a></code> </p>
</td>
<td>
<p> a digit character.</p>
<p>数字字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:graph:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/graph.html" title="Global graph">graph</a></code> </p>
</td>
<td>
<p> a graphable character.</p>
<p>图形字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:lower:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/lower.html" title="Global lower">lower</a></code> </p>
</td>
<td>
<p> a lower-case character.</p>
<p>小写字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:print:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/print.html" title="Global print">print</a></code> </p>
</td>
<td>
<p> a printing character.</p>
<p>打印字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:punct:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/punct.html" title="Global punct">punct</a></code> </p>
</td>
<td>
<p> a punctuation character.</p>
<p>标点字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:space:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/space.html" title="Global space">space</a></code> </p>
</td>
<td>
<p> a white-space character.</p>
<p>空白字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:upper:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/upper.html" title="Global upper">upper</a></code> </p>
</td>
<td>
<p> an upper-case character.</p>
<p>大写字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[:xdigit:]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/xdigit.html" title="Global xdigit">xdigit</a></code> </p>
</td>
<td>
<p> a hexadecimal digit character.</p>
<p>十六进制数字字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[0-9]</code> </p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/range.html" title="Function template range">range</a><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span></code> </p>
</td>
<td>
<p> characters in range <code class="computeroutput"><span class="char">'0'</span></code> through <code class="computeroutput"><span class="char">'9'</span></code>.</p>
<p>从&nbsp;<code class="computeroutput"><span class="char">'0'</span></code> 至 <code class="computeroutput"><span class="char">'9'</span></code>
间的字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[abc]</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">|</span>
<span class="char">'b'</span> <span class="special">|</span><span class="char">'c'</span></code>
</p>
</td>
<td>
<p> characters <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
or <code class="computeroutput"><span class="char">'c'</span></code>.</p>
<p>字符&nbsp;<code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
或 <code class="computeroutput"><span class="char">'c'</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[abc]</code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">(</span><a class="link" href="../boost/xpressive/set.html" title="Global set">set</a><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <span class="emphasis"><em>same as
above</em></span></p>
<p><span class="emphasis"><em>同上</em></span>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[0-9abc]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/set.html" title="Global set">set</a><span class="special">[</span>
<a class="link" href="../boost/xpressive/range.html" title="Function template range">range</a><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span> <span class="special">|</span>
<span class="char">'a'</span> <span class="special">|</span> <span class="char">'b'</span>
<span class="special">|</span> <span class="char">'c'</span> <span class="special">]</span></code>
</p>
</td>
<td>
<p> characters <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
<code class="computeroutput"><span class="char">'c'</span></code>
or in range <code class="computeroutput"><span class="char">'0'</span></code> through <code class="computeroutput"><span class="char">'9'</span></code>.</p>
<p><code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
<code class="computeroutput"><span class="char">'c'</span></code>
或 <code class="computeroutput"><span class="char">'0'</span></code>
至 <code class="computeroutput"><span class="char">'9'</span></code>
间的字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[0-9abc]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/set.html" title="Global set">set</a><span class="special">[</span>
<a class="link" href="../boost/xpressive/range.html" title="Function template range">range</a><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span> <span class="special">|</span>
<span class="special">(</span><a class="link" href="../boost/xpressive/set.html" title="Global set">set</a><span class="special">=</span>
<span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span> <span class="special">]</span></code>
</p>
</td>
<td>
<p> <span class="emphasis"><em>same as
above</em></span></p>
<p><span class="emphasis"><em>同上</em></span>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">[^abc]</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~(</span><a class="link" href="../boost/xpressive/set.html" title="Global set">set</a><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span></code> </p>
</td>
<td>
<p> not characters <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
or <code class="computeroutput"><span class="char">'c'</span></code>.</p>
<p>非 <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
或 <code class="computeroutput"><span class="char">'c'</span></code>
的字符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(?i:<span class="emphasis"><em>stuff</em></span>)</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/icase.html" title="Function template icase">icase</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</p>
</td>
<td>
<p> match <span class="emphasis"><em>stuff</em></span>
disregarding case.</p>
<p>忽略大小写匹配 <span class="emphasis"><em>stuff</em></span>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(?&gt;<span class="emphasis"><em>stuff</em></span>)</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/keep.html" title="Function template keep">keep</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</p>
</td>
<td>
<p> independent sub-expression, match <span class="emphasis"><em>stuff</em></span> and
turn off backtracking.</p>
<p>独立子表达式，匹配 <span class="emphasis"><em>stuff</em></span>
并关闭反向跟踪。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(?=<span class="emphasis"><em>stuff</em></span>)</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/before.html" title="Function template before">before</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</p>
</td>
<td>
<p> positive look-ahead assertion, match if before <span class="emphasis"><em>stuff</em></span> but
don't include <span class="emphasis"><em>stuff</em></span>
in the match.</p>
<p>正顺序环视断言，如果在 <span class="emphasis"><em>stuff</em></span>
之前但不含 <span class="emphasis"><em>stuff</em></span>
时匹配。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(?!<span class="emphasis"><em>stuff</em></span>)</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/before.html" title="Function template before">before</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</p>
</td>
<td>
<p>negative look-ahead assertion, match if not before <span class="emphasis"><em>stuff</em></span>.</p>
<p>负顺序环视断言，不在 <span class="emphasis"><em>stuff</em></span>
之前时匹配。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(?&lt;=<span class="emphasis"><em>stuff</em></span>)</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><a class="link" href="../boost/xpressive/after.html" title="Function template after">after</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</p>
</td>
<td>
<p> positive look-behind assertion, match if after <span class="emphasis"><em>stuff</em></span> but
don't include <span class="emphasis"><em>stuff</em></span>
in the match. (<span class="emphasis"><em>stuff</em></span>
must be constant-width.)</p>
<p>正逆序环视断言，如果在 <span class="emphasis"><em>stuff</em></span>
之后但不含 <span class="emphasis"><em>stuff</em></span>
时匹配。(<span class="emphasis"><em>stuff</em></span>
必须是常数宽度) </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">(?&lt;!<span class="emphasis"><em>stuff</em></span>)</code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">~</span><a class="link" href="../boost/xpressive/after.html" title="Function template after">after</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</p>
</td>
<td>
<p> negative look-behind assertion, match if not after <span class="emphasis"><em>stuff</em></span>. (<span class="emphasis"><em>stuff</em></span>
must be constant-width.)</p>
<p>负逆序环视，不在 <span class="emphasis"><em>stuff</em></span>
之后时匹配。(<span class="emphasis"><em>stuff</em></span>
必须是常数宽度) </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> <br>
</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes" title="Dynamic Regexes">Dynamic Regexes 动态Regexes</a>
</h4>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.overview"></a>
<h3><a name="id4041310"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.overview">Overview
概述</a> </h3>
<p> Static regexes are dandy, but sometimes you need something a
bit more ... dynamic. Imagine you are developing a text editor with a
regex search/replace feature. You need to accept a regular expression
from the end user as input at run-time. There should be a way to parse
a string into a regular expression. That's what xpressive's dynamic
regexes are for. They are built from the same core components as their
static counterparts, but they are late-bound so you can specify them at
run-time.<br>
静
态regexes非常漂亮，但有时你还需要更多的 ...
动态。想象你正在开发一个带有regex查找/替换功能的文本编辑器。你需要在运行期从最终用户处输入正则表达式。需要一种方法来将字符串解析为正则表达
式。这正是xpressive的动态regexes要做的。它们构建于和静态regex相同核心组件之上，只是它们是后期绑定的，所以你可以在运行期来指
定它们。 </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.construction_and_assignment"></a>
<h3><a name="id4041338"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.construction_and_assignment">Construction
and Assignment 构造与赋值</a> </h3>
<p> There are two ways to create a dynamic regex: with the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>
function or with the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
class template. Use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>
if you want the default locale. Use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
if you need to specify a different locale. In the section on <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches" title="Grammars and Nested Matches">regex grammars</a>,
we'll see another use for <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>.<br>
有两种方法创建一个动态regex：用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>
函数或者用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
类模板。如果你想用缺省locale，则使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>。
如果你需要指定不同的locale，就使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>。
在 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches" title="Grammars and Nested Matches">regex 语法</a>一节中，我们将
看到 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
的另一种用法。 </p>
<p> Here is an example of using <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">compile</span><span class="special">()</span></code>:<br>
以下是一个使用 <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">compile</span><span class="special">()</span></code> 的例子： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"this|that"</span><span class="special">,</span> <span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">icase</span> <span class="special">);</span>
</pre>
<p> Here is the same example using <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>:<br>
以下是同一个例子，不过用的是 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>：
</p>
<pre class="programlisting"><span class="identifier">sregex_compiler</span> <span class="identifier">compiler</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"this|that"</span><span class="special">,</span> <span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">icase</span> <span class="special">);</span>
</pre>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>
is implemented in terms of <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>.<br>
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html#id2999345-bb">basic_regex&lt;&gt;::compile()</a></code></code>
是依据 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
实现的。 </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.dynamic_xpressive_syntax"></a>
<h3><a name="id4041680"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.dynamic_xpressive_syntax">Dynamic
xpressive Syntax 动态xpressive语法</a> </h3>
<p> Since the dynamic syntax is not constrained by the rules for
valid C++ expressions, we are free to use familiar syntax for dynamic
regexes. For this reason, the syntax used by xpressive for dynamic
regexes follows the lead set by John Maddock's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm" target="_top">proposal</a> to add regular expressions
to the Standard Library. It is essentially the syntax standardized by <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_top">ECMAScript</a>, with minor changes in
support of internationalization.<br>
由于动态语法不受有效C++表达式的限制，所以我们可以随意对动态regexes使用我们所熟悉的语法。为此，xpressive对于动态regexes
所使用的语法是遵照 John Maddock 的关于为标准库增加正则表达式的 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm" target="_top">建议书</a> 的。基本上，它是 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_top">ECMAScript</a> 所标准化的语法，有一点点变化以支持国际化。 </p>
<p> Since the syntax is documented exhaustively elsewhere, I will
simply refer you to the existing standards, rather than duplicate the
specification here.<br>
由于这种语法在很多地方都有记载，所以我只会向你指出一些已有的标准，而不再在此重复这些规范了。 </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.internationalization"></a>
<h3><a name="id4041735"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.internationalization">Internationalization
国际化</a> </h3>
<p> As with static regexes, dynamic regexes support
internationalization by allowing you to specify a different <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>.
To do this, you must use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>.
The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
class has an <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
function. After you have imbued a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
object with a custom <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>, all
regex objects compiled by that <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
will use that locale. For example:<br>
和静态regexes相似，动态regexes也是通过让你指定一个不同的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>
来支持国际化。为此，你必须使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>。
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
类有一个 <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
函数。在你向一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
对象注入一个定制的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code> 后，所有由该 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
编译的regex对象都将使用该locale。例如： </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">my_locale</span> <span class="special">=</span> <span class="comment">/* initialize your locale object here 在此初始化你的locale对象 */</span><span class="special">;</span><br><span class="identifier">sregex_compiler</span> <span class="identifier">compiler</span><span class="special">;</span><br><span class="identifier">compiler</span><span class="special">.</span><span class="identifier">imbue</span><span class="special">(</span> <span class="identifier">my_locale</span> <span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"\\w+|\\d+"</span> <span class="special">);</span>
</pre>
<p> This regex will use <code class="computeroutput"><span class="identifier">my_locale</span></code> when
evaluating the intrinsic character sets <code class="computeroutput"><span class="string">"\\w"</span></code> and <code class="computeroutput"><span class="string">"\\d"</span></code>.<br>
这个regex在对基础字符集 <code class="computeroutput"><span class="string">"\\w"</span></code> 和 <code class="computeroutput"><span class="string">"\\d"</span></code>
求值时将使用 <code class="computeroutput"><span class="identifier">my_locale</span></code>。 </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.matching_and_searching"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.matching_and_searching" title="Matching and Searching">Matching and Searching 匹配与查找</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.matching_and_searching.overview"></a>
<h3><a name="id4042053"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.matching_and_searching.overview">Overview
概述</a> </h3>
<p> Once you have created a regex object, you can use the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
and <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
algorithms to find patterns in strings. This page covers the basics of
regex matching and searching. In all cases, if you are familiar with
how <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
and <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
in the <a href="../../../libs/regex" target="_top">Boost.Regex</a>
library work, xpressive's versions work the same way.<br>
一旦你创建了一个regex对象，你就可以用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
和 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
算法来在字符串中查找该模式。本节包括了regex匹配与查找的基础。在所有情况下，如果你对于在 <a href="../../../libs/regex" target="_top">Boost.Regex</a>
库中如何使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
和 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
是熟悉的，那么xpressive也是一样的用法。 </p>
<a name="boost_xpressive.user_s_guide.matching_and_searching.seeing_if_a_string_matches_a_regex"></a>
<h3><a name="id4042148"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.matching_and_searching.seeing_if_a_string_matches_a_regex">Seeing
if a String Matches a Regex 查看一个字符串是否匹配一个Regex</a> </h3>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
algorithm checks to see if a regex matches a given input.<br>
算法&nbsp;<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
检查一个regex是否匹配一个给定的输入。 </p>
<div class="warning">
<table summary="Warning" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/html/images/warning.png"></td>
<th align="left">Warning 警告</th>
</tr>
<tr>
<td align="left" valign="top">
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
algorithm will only report success if the regex matches the <span class="emphasis"><em>whole input</em></span>,
from beginning to end. If the regex matches only a part of the input, <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
will return false. If you want to search through the string looking for
sub-strings that the regex matches, use the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
algorithm.</p>
<p>算法&nbsp;<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
只报告一个regex是否匹配<span class="emphasis"><em>整个输入</em></span>，
从头到尾。如果regex只匹配部分输入，则 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
将返回false。如果你要在字符串中查找与regex相匹配的子串，请用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
算法。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> The input can be a bidirectional range such as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
a C-style null-terminated string or a pair of iterators. In all cases,
the type of the iterator used to traverse the input sequence must match
the iterator type used to declare the regex object. (You can use the
table in the <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start.know_your_iterator_type">Quick
Start</a> to find the correct regex type for your iterator.)<br>
输入可能是一个双向区间，如 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>，或是一个C-风格的
以空字符结束的字符串，或是一对迭代器。在所有情况下，用于对输入序列进行遍历的迭代器类型必须与用于声明regex对象的迭代器类型相匹配。(你可以用
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start.know_your_iterator_type">快
速入门</a> 一节中的表格来查找与你的迭代器相对应的正确regex类型)。 </p>
<pre class="programlisting"><span class="identifier">cregex</span> <span class="identifier">cre</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span> <span class="comment">// this regex can match C-style strings 该regex可以匹配C-风格的字符串<br></span><span class="identifier">sregex</span> <span class="identifier">sre</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span> <span class="comment">// this regex can match std::strings 该regex可以匹配std::string<br></span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="string">"hello"</span><span class="special">,</span> <span class="identifier">cre</span> <span class="special">)</span> <span class="special">)</span> <span class="comment">// OK<br></span> <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">}</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"hello"</span><span class="special">),</span> <span class="identifier">sre</span> <span class="special">)</span> <span class="special">)</span> <span class="comment">// OK<br></span> <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">}</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="string">"hello"</span><span class="special">,</span> <span class="identifier">sre</span> <span class="special">)</span> <span class="special">)</span> <span class="comment">// ERROR! iterator mis-match! 错误！迭代器不匹配！<br></span> <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">}</span>
</pre>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
algorithm optionally accepts a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
struct as an out parameter. If given, the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
algorithm fills in the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
struct with information about which parts of the regex matched which
parts of the input.<br>
算法 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
选择性地接受一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
结构作为输出参数。如果给出该参数，则 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
算法将与哪部分regex匹配哪部分输入的信息填入 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
结构。 </p>
<pre class="programlisting"><span class="identifier">cmatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="identifier">cregex</span> <span class="identifier">cre</span> <span class="special">=</span> <span class="special">+(</span><span class="identifier">s1</span><span class="special">=</span> <span class="identifier">_w</span><span class="special">);</span><br><span class="comment">// store the results of the regex_match in "what" 保存regex_match的结果到"what"中<br></span><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="string">"hello"</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">cre</span> <span class="special">)</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// prints "o"<br></span><span class="special">}</span>
</pre>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
algorithm also optionally accepts a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
bitmask. With <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>,
you can control certain aspects of how the match is evaluated. See the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
reference for a complete list of the flags and their meanings.<br>
算法 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
还选择性地接受一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
位掩码。通过 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>，
你可以控制匹配如何执行的各个方面。相关标志位的完整列表及其含义，请看 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
参考。 </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"hello"</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">sre</span> <span class="special">=</span> <span class="identifier">bol</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span><br><span class="comment">// match_not_bol means that "bol" should not match at [begin,begin)<br>// match_not_bol 表示 "bol" 并不匹配于 [begin,begin)<br></span><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">sre</span><span class="special">,</span> <span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">match_not_bol</span> <span class="special">)</span> <span class="special">)</span><br><span class="special">{</span><br><span class="comment">// should never get here!!! 不会运行至此！！！<br></span><span class="special">}</span>
</pre>
<p> Click <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex">here</a>
to see a complete example program that shows how to use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>.
And check the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
reference to see a complete list of the available overloads.<br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex">这
里</a> 有一个完整的示例程序，示范如何使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>。
查看 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
参考可以看到其它重载的完整列表。 </p>
<a name="boost_xpressive.user_s_guide.matching_and_searching.searching_for_matching_sub_strings"></a>
<h3><a name="id4043130"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.matching_and_searching.searching_for_matching_sub_strings">Searching
for Matching Sub-Strings 匹配子串的查找</a> </h3>
<p> Use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
when you want to know if an input sequence contains a sub-sequence that
a regex matches. <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
will try to match the regex at the beginning of the input sequence and
scan forward in the sequence until it either finds a match or exhausts
the sequence.<br>
当你想知道一个输入序列是否包含一个匹配regex的子序列时，使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
将尝试在输入序列的开始匹配regex，并向前扫描，直至找到一个匹配或扫描完整个序列。 </p>
<p> In all other regards, <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
behaves like <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
<span class="emphasis"><em>(see above)</em></span>.
In particular, it can operate on a bidirectional range such as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
C-style null-terminated strings or iterator ranges. The same care must
be taken to ensure that the iterator type of your regex matches the
iterator type of your input sequence. As with <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>,
you can optionally provide a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
struct to receive the results of the search, and a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
bitmask to control how the match is evaluated.<br>
在所有其它方面，<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
的行为类似于 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
<span class="emphasis"><em>(见上)</em></span>。
特别地，它可以在一个双向区间，如 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>，或是一个C-风格的
以空字符结束的字符串，或是一对迭代器上操作。同样也是注意确保你的regex的迭代器类型与输入序列的迭代器类型相匹配。和 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
一样，你可以选择性地提供一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
结构来接收查找结果，以及提供一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
位掩码来控制如何进行匹配。 </p>
<p> Click <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">here</a>
to see a complete example program that shows how to use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>.
And check the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
reference to see a complete list of the available overloads.<br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">这
里</a>&nbsp;有一个完整的示例程序，示范如何使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>。&amp;
nbsp;查看 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
参考可以看到其它重载的完整列表。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.accessing_results"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.accessing_results" title="Accessing Results">Accessing Results 访问结果</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.accessing_results.overview"></a>
<h3><a name="id4043350"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.accessing_results.overview">Overview
概述</a> </h3>
<p> Sometimes, it is not enough to know simply whether a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
or <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
was successful or not. If you pass an object of type <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
to <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
or <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>,
then after the algorithm has completed successfully the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
will contain extra information about which parts of the regex matched
which parts of the sequence. In Perl, these sub-sequences are called <span class="emphasis"><em>back-references</em></span>,
and they are stored in the variables <code class="literal">$1</code>,
<code class="literal">$2</code>, etc. In xpressive,
they are objects of type <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>,
and they are stored in the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
structure, which acts as a vector of <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
objects.<br>
有时，只知道一次 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
或 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
是否成功是不够的。如果你将一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象传给 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
或 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>，
那么在算法成功完成后，这个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象将含有额外的关于哪部分regex匹配到哪部分序列的信息。在Perl中，这些子序列被称为<span class="emphasis"><em>后
向引用</em></span>，它们被保存在变量 <code class="literal">$1</code>,
<code class="literal">$2</code>,
等等之中。在xpressive中，它们是类型为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
的对象，被保存在 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
结构中，该结构起到一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象向量的作用。 </p>
<a name="boost_xpressive.user_s_guide.accessing_results.match_results"></a>
<h3><a name="id4043525"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.accessing_results.match_results">match_results</a>
</h3>
<p> So, you've passed a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object to a regex algorithm, and the algorithm has succeeded. Now you
want to examine the results. Most of what you'll be doing with the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object is indexing into it to access its internally stored <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
objects, but there are a few other things you can do with a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object besides.<br>
好的，你已经传入一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象给一个regex算法，并且该算法已经完成了。现在你想检查一下结果。你要对 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象所做的事情，主要就是按索引来访问它内部所保存的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象，不过你还可以对 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象做一些其它事情。 </p>
<p> The table below shows how to access the information stored in
a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object named <code class="computeroutput"><span class="identifier">what</span></code>.<br>
下表列出了如何访问保存在一个名为 <code class="computeroutput"><span class="identifier">what</span></code> 的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象中的信息的方法。 </p>
<div class="table">
<a name="id4043632"></a>
<p class="title"><b>Table&nbsp;27.5.&nbsp;match_results&lt;&gt;
Accessors<br>
表&nbsp;27.5.&nbsp;match_results&lt;&gt; 访问器</b></p>
<div class="table-contents">
<table class="table" summary="match_results&lt;&gt; Accessors">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Accessor </p>
</th>
<th>
<p> Effects </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span></code>
</p>
</td>
<td>
<p> Returns the number of sub-matches, which is always
greater than zero after a successful match because the full match is
stored in the zero-th sub-match.<br>
返回子匹配的数量，匹配成功后该值总是大于零，因为全匹配会被保存在第零个子匹配中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">]</span></code>
</p>
</td>
<td>
<p> Returns the <span class="emphasis"><em>n</em></span>-th
sub-match.<br>
返回第<span class="emphasis"><em>n</em></span>-
个子匹配。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">length</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></code> </p>
</td>
<td>
<p> Returns the length of the <span class="emphasis"><em>n</em></span>-th
sub-match. Same as <code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">length</span><span class="special">()</span></code>.<br>
返回第<span class="emphasis"><em>n</em></span>-
个子匹配的长度。与 <code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">length</span><span class="special">()</span></code> 相同。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">position</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></code> </p>
</td>
<td>
<p> Returns the offset into the input sequence at which the
<span class="emphasis"><em>n</em></span>-th
sub-match begins.<br>
返回第<span class="emphasis"><em>n</em></span>-
个子匹配的始端在输入序列中的偏移量。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">str</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> Returns a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>
constructed from the <span class="emphasis"><em>n</em></span>-th
sub-match. Same as <code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">str</span><span class="special">()</span></code>.<br>
返回一个由第<span class="emphasis"><em>n</em></span>-
个子匹配构造的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>。与
<code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">str</span><span class="special">()</span></code>
相同。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">prefix</span><span class="special">()</span></code> </p>
</td>
<td>
<p> Returns a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
object which represents the sub-sequence from the beginning of the
input sequence to the start of the full match.<br>
返回一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象，表示从输入序列的始端到全匹配的始端的一个子序列。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">suffix</span><span class="special">()</span></code> </p>
</td>
<td>
<p> Returns a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
object which represents the sub-sequence from the end of the full match
to the end of the input sequence.<br>
返回一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象，表示从全匹配的末端到输入序列的末端的一个子序列。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">regex_id</span><span class="special">()</span></code> </p>
</td>
<td>
<p> Returns the <code class="computeroutput"><span class="identifier">regex_id</span></code> of the
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
object that was last used with this <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object.<br>
返回该 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>&nbsp;
对象最后使用的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象的 <code class="computeroutput"><span class="identifier">regex_id</span></code>。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> There is more you can do with the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object, but that will be covered when we talk about <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches" title="Grammars and Nested Matches">Grammars and Nested
Matches</a>.<br>
对于 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象，你还可以做更多的事情，我们讨论 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches" title="Grammars and Nested Matches">语法和嵌套匹配</a>
的时候会提及。 </p>
<a name="boost_xpressive.user_s_guide.accessing_results.sub_match"></a>
<h3><a name="id4044204"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.accessing_results.sub_match">sub_match</a>
</h3>
<p> When you index into a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object, you get back a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
object. A <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
is basically a pair of iterators. It is defined like this:<br>
当你对 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象求索引时，你会得到一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象。本质上一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
是一对迭代器。其定义类似于： </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span> <span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">sub_match</span><br><span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">BidirectionalIterator</span> <span class="special">&gt;</span><br><span class="special">{</span><br><span class="keyword">bool</span> <span class="identifier">matched</span><span class="special">;</span><br><span class="comment">// ...<br></span><span class="special">};</span>
</pre>
<p> Since it inherits publicaly from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;&gt;</span></code>, <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
has <code class="computeroutput"><span class="identifier">first</span></code> and <code class="computeroutput"><span class="identifier">second</span></code>
data members of type <code class="computeroutput"><span class="identifier">BidirectionalIterator</span></code>.
These are the beginning and end of the sub-sequence this <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
represents. <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
also has a Boolean <code class="computeroutput"><span class="identifier">matched</span></code> data
member, which is true if this <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
participated in the full match.&nbsp;<br>
由于它公有地继承自 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;&gt;</span></code>，
所以 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
有两个类型为 <code class="computeroutput"><span class="identifier">BidirectionalIterator</span></code>
的 <code class="computeroutput"><span class="identifier">first</span></code>
和 <code class="computeroutput"><span class="identifier">second</span></code>
数据成员。它们是这个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
所表示的子序列的始端和末端。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
还有一个布尔型的 <code class="computeroutput"><span class="identifier">matched</span></code>
数据成员，如果该 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
参与了全匹配，则为 true。 </p>
<p> The following table shows how you might access the
information stored in a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
object called <code class="computeroutput"><span class="identifier">sub</span></code>.<br>
表示列出了如何访问保存在一个名为 <code class="computeroutput"><span class="identifier">sub</span></code> 的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
对象中的信息的方法。 </p>
<div class="table">
<a name="id4044535"></a>
<p class="title"><b>Table&nbsp;27.6.&nbsp;sub_match&lt;&gt;
Accessors<br>
表&nbsp;27.6.&nbsp;sub_match&lt;&gt; 访问器</b></p>
<div class="table-contents">
<table class="table" summary="sub_match&lt;&gt; Accessors">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Accessor </p>
</th>
<th>
<p> Effects </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">length</span><span class="special">()</span></code> </p>
</td>
<td>
<p> Returns the length of the sub-match. Same as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">distance</span><span class="special">(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span></code>.<br>
返回子匹配的长度。与 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">distance</span><span class="special">(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span></code> 相同。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span></code>
</p>
</td>
<td>
<p> Returns a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>
constructed from the sub-match. Same as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">&gt;(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span></code>.<br>
返回一个由子匹配构造的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>。与
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">&gt;(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span></code> 相同。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">compare</span><span class="special">(</span><span class="identifier">str</span><span class="special">)</span></code> </p>
</td>
<td>
<p> Performs a string comparison between the sub-match and <code class="computeroutput"><span class="identifier">str</span></code>,
where <code class="computeroutput"><span class="identifier">str</span></code> can be a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>,
C-style null-terminated string, or another sub-match. Same as <code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">str</span><span class="special">().</span><span class="identifier">compare</span><span class="special">(</span><span class="identifier">str</span><span class="special">)</span></code>.<br>
执行子匹配与 <code class="computeroutput"><span class="identifier">str</span></code>
之间的一次字符串比较，其中 <code class="computeroutput"><span class="identifier">str</span></code> 可以是 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>,
C-风格的以空字符结尾的字符串，或是另一个子匹配。与 <code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">str</span><span class="special">().</span><span class="identifier">compare</span><span class="special">(</span><span class="identifier">str</span><span class="special">)</span></code> 相同。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<a name="boost_xpressive.user_s_guide.accessing_results._inlinemediaobject__imageobject__imagedata__fileref__images_caution_png____imagedata___imageobject__textobject__phrase_caution__phrase___textobject___inlinemediaobject__results_invalidation__inlinemediaobject__imageobject__imagedata__fileref__images_caution_png____imagedata___imageobject__textobject__phrase_caution__phrase___textobject___inlinemediaobject_"></a>
<h3><a name="id4044929"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.accessing_results._inlinemediaobject__imageobject__imagedata__fileref__images_caution_png____imagedata___imageobject__textobject__phrase_caution__phrase___textobject___inlinemediaobject__results_invalidation__inlinemediaobject__imageobject__imagedata__fileref__images_caution_png____imagedata___imageobject__textobject__phrase_caution__phrase___textobject___inlinemediaobject_"><span class="inlinemediaobject"><img src="../images/caution.png" alt="caution"></span> Results Invalidation 结果失效 <span class="inlinemediaobject"><img src="../images/caution.png" alt="caution"></span></a> </h3>
<p> Results are stored as iterators into the input sequence.
Anything which invalidates the input sequence will invalidate the match
results. For instance, if you match a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> object,
the results are only valid until your next call to a non-const member
function of that <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> object.
After that, the results held by the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object are invalid. Don't use them!<br>
匹配的结果是保存为输入序列的迭代器的。任何使输入序列失效的事件都会使匹配结果失效。例如，如果你匹配一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
对象，匹配的结果仅在你下一次调用该 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
对象的非常量成员函数之前是有效的。之后，由 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象所保存的结果就会失效。不要再使用它们！ </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.string_substitutions"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions" title="String Substitutions">String Substitutions 字符串替代</a>
</h3>
</div>
</div>
</div>
<p> Regular expressions are not only good for searching text;
they're good at <span class="emphasis"><em>manipulating</em></span>
it. And one of the most common text manipulation tasks is
search-and-replace. xpressive provides the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
algorithm for searching and replacing.<br>
正则表达式并不只是擅长查找文本；它们也擅于<span class="emphasis"><em>操作</em></span>文
本。而最常见的一种文本操作任务就是查找并替换。xpressive提供了 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
算法来查找和替换。 </p>
<a name="boost_xpressive.user_s_guide.string_substitutions.regex_replace__"></a>
<h3><a name="id4045103"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.regex_replace__">regex_replace()</a>
</h3>
<p> Performing search-and-replace using <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
is simple. All you need is an input sequence, a regex object, and a
format string or a formatter object. There are several versions of the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
algorithm. Some accept the input sequence as a bidirectional container
such as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> and
returns the result in a new container of the same type. Others accept
the input as a null terminated string and return a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>.
Still others accept the input sequence as a pair of iterators and
writes the result into an output iterator. The substitution may be
specified as a string with format sequences or as a formatter object.
Below are some simple examples of using string-based substitutions.<br>
用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
执行查找和替换非常简单。你所需要的就是一个输入序列、一个regex对象、一个格式化字符串或一个格式化器对象。存在多个版本的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
算法。有些以双向容器，如 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>，的方式接受输入序列
并在一个相同类型的新容器中返回结果。其它的一些版本则以空字符结尾的字符串方式接受输入并返回一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>。
还有一些版本以迭代器对的方式接受输入序列并将结果写出到输出迭代器。替代方式可以由一个带格式化序列的字符串或一个格式化器对象来指定。以下是一些例
子，使用了基于字符串的替代。 </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"This is his face"</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">as_xpr</span><span class="special">(</span><span class="string">"his"</span><span class="special">);</span> <span class="comment">// find all occurrences of "his" ... 找出所有"his" ...<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">format</span><span class="special">(</span><span class="string">"her"</span><span class="special">);</span> <span class="comment">// ... and replace them with "her" ... 并替换为"her"<br></span><br><span class="comment">// use the version of regex_replace() that operates on strings 使用操作字符串的regex_replace()版本<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">input</span><span class="special">,</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="comment">// use the version of regex_replace() that operates on iterators 使用操作迭代器的regex_replace()版本<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">);</span><br><span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">out_iter</span><span class="special">,</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span>
</pre>
<p> The above program prints out the following:<br>
以上程序的输出如下： </p>
<pre class="programlisting">Ther is her face<br>Ther is her face<br></pre>
<p> Notice that <span class="emphasis"><em>all</em></span>
the occurrences of <code class="computeroutput"><span class="string">"his"</span></code> have been
replaced with <code class="computeroutput"><span class="string">"her"</span></code>.<br>
注意，所有的<code class="computeroutput"><span class="string">"his"</span></code>
都已替换为<code class="computeroutput"><span class="string">"her"</span></code>。
</p>
<p> Click <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">here</a>
to see a complete example program that shows how to use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>.
And check the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
reference to see a complete list of the available overloads.<br>
在 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">这
里</a> 有一个完整的示例程序示范如何使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>。
在 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
参考手册中有所有可用重载的完整列表。 </p>
<a name="boost_xpressive.user_s_guide.string_substitutions.replace_options"></a>
<h3><a name="id4045654"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.replace_options">Replace
Options 替换的选项</a> </h3>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
algorithm takes an optional bitmask parameter to control the
formatting. The possible values of the bitmask are:<br>
算法 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
接受一个可选的位掩码参数来控制格式化。该掩码的可用值如下： </p>
<div class="table">
<a name="id4045688"></a>
<p class="title"><b>Table&nbsp;27.7.&nbsp;Format
Flags<br>
表&nbsp;27.7. 格式化标志</b></p>
<div class="table-contents">
<table class="table" summary="Format Flags">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Flag </p>
</th>
<th>
<p> Meaning </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">format_default</span></code> </p>
</td>
<td>
<p> Recognize the ECMA-262 format sequences (see below).<br>
使用ECMA-262格式化序列(见后)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">format_first_only</span></code>
</p>
</td>
<td>
<p> Only replace the first match, not all of them.<br>
只替换第一个匹配而不是所有。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">format_no_copy</span></code> </p>
</td>
<td>
<p> Don't copy the parts of the input sequence that didn't
match the regex to the output sequence.<br>
不将输入序列中不匹配regex的部分复制至输出序列。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">format_literal</span></code> </p>
</td>
<td>
<p> Treat the format string as a literal; that is, don't
recognize any escape sequences.<br>
将格式化字符串视为文字值；即不使用任何转义序列。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">format_perl</span></code> </p>
</td>
<td>
<p> Recognize the Perl format sequences (see below).<br>
使用Perl格式化序列(见后)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">format_sed</span></code> </p>
</td>
<td>
<p> Recognize the sed format sequences (see below).<br>
使用sed格式化序列(见后)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">format_all</span></code> </p>
</td>
<td>
<p> In addition to the Perl format sequences, recognize
some Boost-specific format sequences.<br>
除了Perl格式化序列以外，还使用一些Boost特有的格式化序列。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> These flags live in the <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">regex_constants</span></code>
namespace. If the substitution parameter is a function object instead
of a string, the flags <code class="computeroutput"><span class="identifier">format_literal</span></code>,
<code class="computeroutput"><span class="identifier">format_perl</span></code>,
<code class="computeroutput"><span class="identifier">format_sed</span></code>,
and <code class="computeroutput"><span class="identifier">format_all</span></code> are
ignored.<br>
这些标志位于 <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">regex_constants</span></code>
名字空间。如果替代参数是一个函数对象而不是字符串，则忽略标志 <code class="computeroutput"><span class="identifier">format_literal</span></code>,
<code class="computeroutput"><span class="identifier">format_perl</span></code>,
<code class="computeroutput"><span class="identifier">format_sed</span></code>,
和 <code class="computeroutput"><span class="identifier">format_all</span></code>。
</p>
<a name="boost_xpressive.user_s_guide.string_substitutions.the_ecma_262_format_sequences"></a>
<h3><a name="id4045972"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.the_ecma_262_format_sequences">The
ECMA-262 Format Sequences &nbsp;ECMA-262格式化序列</a> </h3>
<p> When you haven't specified a substitution string dialect with
one of the format flags above, you get the dialect defined by ECMA-262,
the standard for ECMAScript. The table below shows the escape sequences
recognized in ECMA-262 mode.<br>
如果你没有指定带有以上任一格式化标志的替换串方言，那么你就是使用由ECMA-262定义的方言，这是ECMAScript的标准。下表列出了在
ECMA-262模式中使用的转义序列。 </p>
<div class="table">
<a name="id4045995"></a>
<p class="title"><b>Table&nbsp;27.8.&nbsp;Format
Escape Sequences<br>
表&nbsp;27.8. 格式化转义序列</b></p>
<div class="table-contents">
<table class="table" summary="Format Escape Sequences">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Escape Sequence </p>
</th>
<th>
<p> Meaning </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="literal">$1</code>, <code class="literal">$2</code>, etc. </p>
</td>
<td>
<p> the corresponding sub-match<br>
对应的子匹配 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$&amp;</code>
</p>
</td>
<td>
<p> the full match<br>
全匹配 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$`</code> </p>
</td>
<td>
<p> the match prefix<br>
匹配前缀 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$'</code> </p>
</td>
<td>
<p> the match suffix<br>
匹配后缀 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$$</code> </p>
</td>
<td>
<p> a literal <code class="computeroutput"><span class="char">'$'</span></code> character<br>
<code class="computeroutput"><span class="char">'$'</span></code>
字符 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> Any other sequence beginning with <code class="computeroutput"><span class="char">'$'</span></code>
simply represents itself. For example, if the format string were <code class="computeroutput"><span class="string">"$a"</span></code>
then <code class="computeroutput"><span class="string">"$a"</span></code>
would be inserted into the output sequence.<br>
任何其它以 <code class="computeroutput"><span class="char">'$'</span></code>
开头的序列都只是表示它本身。例如，如果格式化串为 <code class="computeroutput"><span class="string">"$a"</span></code> 则 <code class="computeroutput"><span class="string">"$a"</span></code>
将被插入到输出序列中。 </p>
<a name="boost_xpressive.user_s_guide.string_substitutions.the_sed_format_sequences"></a>
<h3><a name="id4046195"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.the_sed_format_sequences">The
Sed Format Sequences &nbsp;Sed格式化序列</a> </h3>
<p> When specifying the <code class="computeroutput"><span class="identifier">format_sed</span></code> flag
to <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>,
the following escape sequences are recognized:<br>
当指定 <code class="computeroutput"><span class="identifier">format_sed</span></code> 标志给 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
时，将使用以下转义序列： </p>
<div class="table">
<a name="id4046237"></a>
<p class="title"><b>Table&nbsp;27.9.&nbsp;Sed
Format Escape Sequences<br>
表&nbsp;27.9.&nbsp;Sed 格式化转义序列</b></p>
<div class="table-contents">
<table class="table" summary="Sed Format Escape Sequences">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Escape Sequence </p>
</th>
<th>
<p> Meaning </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="literal">\1</code>, <code class="literal">\2</code>, etc. </p>
</td>
<td>
<p> The corresponding sub-match<br>
对应的子匹配 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">&amp;</code>
</p>
</td>
<td>
<p> the full match<br>
全匹配 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\a</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\a'<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\a'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\e</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">27</span><span class="special">)<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">27</span><span class="special">)</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\f</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\f'<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\f'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\n</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\n'<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\n'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\r</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\r'<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\r'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\t</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\t'<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\t'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\v</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\v'<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\v'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\xFF</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
is any hex digit<br>
文字&nbsp;<code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFF</span><span class="special">)</span></code>, 其中 <code class="literal"><span class="emphasis"><em>F</em></span></code>
是任意的十六进制数字 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\x{FFFF}</code>
</p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFFFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
is any hex digit<br>
文字&nbsp;<code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFFFF</span><span class="special">)</span></code>, 其中 <code class="literal"><span class="emphasis"><em>F</em></span></code>
是任意的十六进制数字 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\cX</code> </p>
</td>
<td>
<p> The control character <code class="literal"><span class="emphasis"><em>X<br>
</em></span></code>控制字符 <code class="literal"><span class="emphasis"><em>X</em></span></code>
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<a name="boost_xpressive.user_s_guide.string_substitutions.the_perl_format_sequences"></a>
<h3><a name="id4046684"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.the_perl_format_sequences">The
Perl Format Sequences &nbsp;Perl格式化序列</a> </h3>
<p> When specifying the <code class="computeroutput"><span class="identifier">format_perl</span></code>
flag to <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>,
the following escape sequences are recognized:<br>
当指定 <code class="computeroutput"><span class="identifier">format_perl</span></code> 标志给
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
时，使用以下转义序列： </p>
<div class="table">
<a name="id4046726"></a>
<p class="title"><b>Table&nbsp;27.10.&nbsp;Perl
Format Escape Sequences<br>
表&nbsp;27.10.&nbsp;Perl 格式化转义序列</b></p>
<div class="table-contents">
<table class="table" summary="Perl Format Escape Sequences">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> Escape Sequence </p>
</th>
<th>
<p> Meaning </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="literal">$1</code>, <code class="literal">$2</code>, etc. </p>
</td>
<td>
<p> the corresponding sub-match<br>
对应的子匹配 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$&amp;</code>
</p>
</td>
<td>
<p> the full match<br>
全匹配 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$`</code> </p>
</td>
<td>
<p> the match prefix<br>
匹配前缀 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$'</code> </p>
</td>
<td>
<p> the match suffix<br>
匹配后缀 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">$$</code> </p>
</td>
<td>
<p> a literal <code class="computeroutput"><span class="char">'$'</span></code> character<br>
文字&nbsp;<code class="computeroutput"><span class="char">'$'</span></code> 字符</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\a</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\a'<br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\a'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\e</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">27</span><span class="special">)</span></code><code class="computeroutput"><span class="special"><br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">27</span><span class="special">)</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\f</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\f'</span></code><code class="computeroutput"><span class="char"><br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\f'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\n</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\n'</span></code><code class="computeroutput"><span class="char"><br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\n'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\r</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\r'</span></code><code class="computeroutput"><span class="char"><br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\r'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\t</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\t'</span></code><code class="computeroutput"><span class="char"><br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\t'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\v</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="char">'\v'</span></code><code class="computeroutput"><span class="char"><br>
</span></code>文字&nbsp;<code class="computeroutput"><span class="char">'\v'</span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\xFF</code> </p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
is any hex digit<br>
文字&nbsp;<code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFF</span><span class="special">)</span></code>, 其中 <code class="literal"><span class="emphasis"><em>F</em></span></code>
是任意的十六进制数字 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\x{FFFF}</code>
</p>
</td>
<td>
<p> A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFFFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
is any hex digit<br>
文字&nbsp;<code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFFFF</span><span class="special">)</span></code>, 其中 <code class="literal"><span class="emphasis"><em>F</em></span></code>
是任意的十六进制数字 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\cX</code> </p>
</td>
<td>
<p> The control character <code class="literal"><span class="emphasis"><em>X</em></span></code><code class="literal"><span class="emphasis"><em><br>
</em></span></code>控制字符 <code class="literal"><span class="emphasis"><em>X</em></span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\l</code> </p>
</td>
<td>
<p> Make the next character lowercase<br>
将下一个字符变为小写 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\L</code> </p>
</td>
<td>
<p> Make the rest of the substitution lowercase until the
next <code class="literal">\E<br>
</code>将剩余替代变为小写，直至下一个 <code class="literal">\E</code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\u</code> </p>
</td>
<td>
<p> Make the next character uppercase<br>
将下一个字符变为大写 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\U</code> </p>
</td>
<td>
<p> Make the rest of the substitution uppercase until the
next <code class="literal">\E</code><code class="literal"><br>
</code>将剩余替代变为大写，直至下一个 <code class="literal">\E</code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\E</code> </p>
</td>
<td>
<p> Terminate <code class="literal">\L</code>
or <code class="literal">\U<br>
</code>结束 <code class="literal">\L</code>
或 <code class="literal">\U</code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\1</code>, <code class="literal">\2</code>, etc. </p>
</td>
<td>
<p> The corresponding sub-match<br>
对应的子匹配 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="literal">\g&lt;name&gt;</code>
</p>
</td>
<td>
<p> The named backref <span class="emphasis"><em>name<br>
</em></span>命名的后向引用 <span class="emphasis"><em>name</em></span>
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<a name="boost_xpressive.user_s_guide.string_substitutions.the_boost_specific_format_sequences"></a>
<h3><a name="id4047425"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.the_boost_specific_format_sequences">The
Boost-Specific Format Sequences &nbsp;Boost特有的格式化序列</a> </h3>
<p> When specifying the <code class="computeroutput"><span class="identifier">format_all</span></code> flag
to <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>,
the escape sequences recognized are the same as those above for <code class="computeroutput"><span class="identifier">format_perl</span></code>.
In addition, conditional expressions of the following form are
recognized:<br>
当指定 <code class="computeroutput"><span class="identifier">format_all</span></code> 标志给 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
时，使用的转义序列与前面的 <code class="computeroutput"><span class="identifier">format_perl</span></code>
相同。另外还可以使用以下形式的条件表达式： </p>
<pre class="programlisting">?Ntrue-expression:false-expression<br></pre>
<p> where <span class="emphasis"><em>N</em></span>
is a decimal digit representing a sub-match. If the corresponding
sub-match participated in the full match, then the substitution is <span class="emphasis"><em>true-expression</em></span>.
Otherwise, it is <span class="emphasis"><em>false-expression</em></span>.
In this mode, you can use parens <code class="literal">()</code>
for grouping. If you want a literal paren, you must escape it as <code class="literal">\(</code>.<br>
其中 <span class="emphasis"><em>N</em></span>
是一个十进制数字，表示某个子匹配。如果对应的子匹配参与了全匹配，则该替换为 <span class="emphasis"><em>true-expression</em></span>。
否则为 <span class="emphasis"><em>false-expression</em></span>。
在这个模式下，你可以使用括号 <code class="literal">()</code>
来分组。如果你要一个文字上的括号，你必须用转义序列 <code class="literal">\(</code>。
</p>
<a name="boost_xpressive.user_s_guide.string_substitutions.formatter_objects"></a>
<h3><a name="id4047525"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.formatter_objects">Formatter
Objects 格式化器对象</a> </h3>
<p> Format strings are not always expressive enough for all your
text substitution needs. Consider the simple example of wanting to map
input strings to output strings, as you may want to do with environment
variables. Rather than a format <span class="emphasis"><em>string</em></span>,
for this you would use a formatter <span class="emphasis"><em>object</em></span>.
Consider the following code, which finds embedded environment variables
of the form <code class="computeroutput"><span class="string">"$(XYZ)"</span></code> and
computes the substitution string by looking up the environment variable
in a map.<br>
格式化串并不总能足够应付你所有的文本替换需要。想象这样一个简单的例子，你想将输入字符串映射至输出字符串，正如你可能想用环境变量所做的。这时不要用
格式化串，你要用一个格式化器对象。考虑以下代码，它找出内嵌的形如 <code class="computeroutput"><span class="string">"$(XYZ)"</span></code>
的环境变量，并通过在一个map中查找该环境变量来计算替换的字符串。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">xpressive</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">env</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">format_fun</span><span class="special">(</span><span class="identifier">smatch</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span><span class="special">)</span><br><span class="special">{</span><br><span class="keyword">return</span> <span class="identifier">env</span><span class="special">[</span><span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">].</span><span class="identifier">str</span><span class="special">()];</span><br><span class="special">}</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">env</span><span class="special">[</span><span class="string">"X"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"this"</span><span class="special">;</span><br><span class="identifier">env</span><span class="special">[</span><span class="string">"Y"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"that"</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"\"$(X)\" has the value \"$(Y)\""</span><span class="special">);</span><br><span class="comment">// replace strings like "$(XYZ)" with the result of env["XYZ"]<br> // 将形如 "$(XYZ)" 的字符串替换为 env["XYZ"]<br></span> <span class="identifier">sregex</span> <span class="identifier">envar</span> <span class="special">=</span> <span class="string">"$("</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">envar</span><span class="special">,</span> <span class="identifier">format_fun</span><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> In this case, we use a function, <code class="computeroutput"><span class="identifier">format_fun</span><span class="special">()</span></code> to compute the
substitution string on the fly. It accepts a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object which contains the results of the current match. <code class="computeroutput"><span class="identifier">format_fun</span><span class="special">()</span></code> uses the first
submatch as a key into the global <code class="computeroutput"><span class="identifier">env</span></code> map. The
above code displays:<br>
在这种情况下，我们使用函数 <code class="computeroutput"><span class="identifier">format_fun</span><span class="special">()</span></code>
来就地计算替换字符串。它接受一个含有当前匹配结果的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象。<code class="computeroutput"><span class="identifier">format_fun</span><span class="special">()</span></code> 使用第一个子匹配作为全局 <code class="computeroutput"><span class="identifier">env</span></code>
map的键值。以上代码输出： </p>
<pre class="programlisting">"this" has the value "that"<br></pre>
<p> The formatter need not be an ordinary function. It may be an
object of class type. And rather than return a string, it may accept an
output iterator into which it writes the substitution. Consider the
following, which is functionally equivalent to the above.<br>
格式化器不必是一个普通函数。它可以是一个类类型对象。它也不必返回一个字符串，可以接受一个输出迭代器用以写出替代串。参考以下代码，其功能与前面的代
码一样。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">struct</span> <span class="identifier">formatter</span><br><span class="special">{</span><br><span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">env_map</span><span class="special">;</span><br><span class="identifier">env_map</span> <span class="identifier">env</span><span class="special">;</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Out</span><span class="special">&gt;</span><br><span class="identifier">Out</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">smatch</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span><span class="special">,</span> <span class="identifier">Out</span> <span class="identifier">out</span><span class="special">)</span> <span class="keyword">const</span><br><span class="special">{</span><br><span class="identifier">env_map</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">where</span> <span class="special">=</span> <span class="identifier">env</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]);</span><br><span class="keyword">if</span><span class="special">(</span><span class="identifier">where</span> <span class="special">!=</span> <span class="identifier">env</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">sub</span> <span class="special">=</span> <span class="identifier">where</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">;</span><br><span class="identifier">out</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">sub</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">out</span><span class="special">);</span><br><span class="special">}</span><br><span class="keyword">return</span> <span class="identifier">out</span><span class="special">;</span><br><span class="special">}</span><br><span class="special">};</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">formatter</span> <span class="identifier">fmt</span><span class="special">;</span><br><span class="identifier">fmt</span><span class="special">.</span><span class="identifier">env</span><span class="special">[</span><span class="string">"X"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"this"</span><span class="special">;</span><br><span class="identifier">fmt</span><span class="special">.</span><span class="identifier">env</span><span class="special">[</span><span class="string">"Y"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"that"</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"\"$(X)\" has the value \"$(Y)\""</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">envar</span> <span class="special">=</span> <span class="string">"$("</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">envar</span><span class="special">,</span> <span class="identifier">fmt</span><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> The formatter must be a callable object -- a function or a
function object -- that has one of three possible signatures, detailed
in the table below. For the table, <code class="computeroutput"><span class="identifier">fmt</span></code> is a
function pointer or function object, <code class="computeroutput"><span class="identifier">what</span></code> is a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object, <code class="computeroutput"><span class="identifier">out</span></code> is an
OutputIterator, and <code class="computeroutput"><span class="identifier">flags</span></code> is a
value of <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">match_flag_type</span></code>:<br>
格式化器必须是一个可调用的对象 -- 函数或函数对象 -- 可以是三个可能的签名之一，详见下表。在下表中，<code class="computeroutput"><span class="identifier">fmt</span></code>
是一个函数指针或函数对象，<code class="computeroutput"><span class="identifier">what</span></code> 是一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象，<code class="computeroutput"><span class="identifier">out</span></code>
是一个输出迭代器，<code class="computeroutput"><span class="identifier">flags</span></code> 是一个类型为 <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">match_flag_type</span></code>
的值： </p>
<div class="table">
<a name="id4049311"></a>
<p class="title"><b>Table&nbsp;27.11.&nbsp;Formatter
Signatures<br>
表&nbsp;27.11. 格式化器签名</b></p>
<div class="table-contents">
<table class="table" summary="Formatter Signatures">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> Formatter Invocation </p>
</th>
<th>
<p> Return Type </p>
</th>
<th>
<p> Semantics </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">fmt</span><span class="special">(</span><span class="identifier">what</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> Range of characters (e.g. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>)
or null-terminated string<br>
字符区间(如 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>)或空字符结尾的字符
串 </p>
</td>
<td>
<p> The string matched by the regex is replaced with the
string returned by the formatter.<br>
匹配regex的字符串被替换为由格式化器返回的字符串。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">fmt</span><span class="special">(</span><span class="identifier">what</span><span class="special">,</span>
<span class="identifier">out</span><span class="special">)</span></code> </p>
</td>
<td>
<p> OutputIterator<br>
输出迭代器 </p>
</td>
<td>
<p> The formatter writes the replacement string into <code class="computeroutput"><span class="identifier">out</span></code>
and returns <code class="computeroutput"><span class="identifier">out</span></code>.<br>
格式化器将替换串写出至 <code class="computeroutput"><span class="identifier">out</span></code> 并返回 <code class="computeroutput"><span class="identifier">out</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">fmt</span><span class="special">(</span><span class="identifier">what</span><span class="special">,</span>
<span class="identifier">out</span><span class="special">,</span> <span class="identifier">flags</span><span class="special">)</span></code> </p>
</td>
<td>
<p> OutputIterator<br>
输出迭代器 </p>
</td>
<td>
<p> The formatter writes the replacement string into <code class="computeroutput"><span class="identifier">out</span></code>
and returns <code class="computeroutput"><span class="identifier">out</span></code>. The <code class="computeroutput"><span class="identifier">flags</span></code>
parameter is the value of the match flags passed to the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
algorithm.<br>
格式化器将替换串写出至 <code class="computeroutput"><span class="identifier">out</span></code> 并返回 <code class="computeroutput"><span class="identifier">out</span></code>。
参数 <code class="computeroutput"><span class="identifier">flags</span></code> 为传给 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
算法的匹配标志值。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<a name="boost_xpressive.user_s_guide.string_substitutions.formatter_expressions"></a>
<h3><a name="id4049605"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions.formatter_expressions">Formatter
Expressions 格式化器表达式</a> </h3>
<p> In addition to format <span class="emphasis"><em>strings</em></span>
and formatter <span class="emphasis"><em>objects</em></span>,
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
also accepts formatter <span class="emphasis"><em>expressions</em></span>.
A formatter expression is a lambda expression that generates a string.
It uses the same syntax as that for <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions" title="Semantic Actions and User-Defined Assertions">Semantic
Actions</a>, which are covered later. The above example, which
uses <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
to substitute strings for environment variables, is repeated here using
a formatter expression.<br>
除了格式化<span class="emphasis"><em>串</em></span>和
格式化器<span class="emphasis"><em>对象</em></span>以
外，<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
还接受格式化器<span class="emphasis"><em>表达式</em></span>。
格式化器表达式是一个生成字符串的lambda表达式。它所使用的语法与用于<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions" title="Semantic Actions and User-Defined Assertions">语义动作</a>的
语法相同，稍后我们会提及。前面那个用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
来把环境变量替换为字符串的例子，可以用格式化器表达式实现如下。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">env</span><span class="special">;</span><br><span class="identifier">env</span><span class="special">[</span><span class="string">"X"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"this"</span><span class="special">;</span><br><span class="identifier">env</span><span class="special">[</span><span class="string">"Y"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"that"</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"\"$(X)\" has the value \"$(Y)\""</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">envar</span> <span class="special">=</span> <span class="string">"$("</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">envar</span><span class="special">,</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">env</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> In the above, the formatter expression is <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">env</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span></code>. This means to
use the value of the first submatch, <code class="computeroutput"><span class="identifier">s1</span></code>, as a key
into the <code class="computeroutput"><span class="identifier">env</span></code> map. The
purpose of <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> here is to make
the reference to the <code class="computeroutput"><span class="identifier">env</span></code> local
variable <span class="emphasis"><em>lazy</em></span>
so that the index operation is deferred until we know what to replace <code class="computeroutput"><span class="identifier">s1</span></code>
with.<br>
这里的格式化器表达式是 <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">env</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span></code>。
它表示的是，使用第一个子匹配的值 <code class="computeroutput"><span class="identifier">s1</span></code> 作为 <code class="computeroutput"><span class="identifier">env</span></code>
map 的键值来求值。这里的 <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> 的目的是令局部变量 <code class="computeroutput"><span class="identifier">env</span></code>
的引用变为<span class="emphasis"><em>惰性的</em></span>，
使得下标操作可以到我们得知 <code class="computeroutput"><span class="identifier">s1</span></code>
要替换为什么的时候再进行解引用。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization" title="String Splitting and Tokenization">String Splitting
and Tokenization 字符串分拆和记号化</a>
</h3>
</div>
</div>
</div>
<p> <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
is the Ginsu knife of the text manipulation world. It slices! It dices!
This section describes how to use the highly-configurable <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
to chop up input sequences.<br>
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
是文本处理世界中的Ginsu刀。它可以切片！也可以切块！本节将描述如何使用高可配置的 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
来将输入序列剁碎。 </p>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.overview"></a>
<h3><a name="id4050419"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization.overview">Overview
概述</a> </h3>
<p> You initialize a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
with an input sequence, a regex, and some optional configuration
parameters. The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
will use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
to find the first place in the sequence that the regex matches. When
dereferenced, the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
returns a <span class="emphasis"><em>token</em></span>
in the form of a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>.
Which string it returns depends on the configuration parameters. By
default it returns a string corresponding to the full match, but it
could also return a string corresponding to a particular marked
sub-expression, or even the part of the sequence that <span class="emphasis"><em>didn't</em></span>
match. When you increment the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>,
it will move to the next token. Which token is next depends on the
configuration parameters. It could simply be a different marked
sub-expression in the current match, or it could be part or all of the
next match. Or it could be the part that <span class="emphasis"><em>didn't</em></span>
match.<br>
你要用一个输入序列、一个regex和一些可选的配置参数来初始化 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
会用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
在输入序列中找到匹配regex的第一个地方。当你对它解引用时，<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
以 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>
的形式返回一个记号。它返回哪个字符串取决于那些配置参数。缺省下，它返回一个与全匹配相对应的字符串，不过它也可以返回一个与某个特定子表达式相对应的
字符串，甚至是不被匹配的那部分串。当你以 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
进行递增时，它将移至下一个记号。哪个记号是下一个，也取决于配置参数。它可以只是当前匹配中的另一个子表达式，也可以是下一个匹配的部分或全部。或者可
以是不被匹配的部分。 </p>
<p> As you can see, <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
can do a lot. That makes it hard to describe, but some examples should
make it clear.<br>
如你所见，<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
可以做很多事情。这使得它很难被说得明白，不过来些例子可以清楚一点。 </p>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_1__simple_tokenization"></a>
<h3><a name="id4050587"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_1__simple_tokenization">Example
1: Simple Tokenization 示例1：简单的记号化</a> </h3>
<p> This example uses <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
to chop a sequence into a series of tokens consisting of words.<br>
这个例子用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
来将一个序列分成一系列由单词组成的记号。 </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"This is his face"</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span> <span class="comment">// find a word 查找一个单词<br></span><br><span class="comment">// iterate over all the words in the input 对输入中的所有单词进行迭代<br></span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span><br><span class="comment">// write all the words to std::cout 将所有单词写出到std::cout<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p> This program displays the following:<br>
程序输出如下： </p>
<pre class="programlisting">This<br>is<br>his<br>face<br></pre>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_2__simple_tokenization__reloaded"></a>
<h3><a name="id4050925"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_2__simple_tokenization__reloaded">Example
2: Simple Tokenization, Reloaded 示例2：简单的记号化，再来</a> </h3>
<p> This example also uses <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
to chop a sequence into a series of tokens consisting of words, but it
uses the regex as a delimiter. When we pass a <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code> as the last
parameter to the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
constructor, it instructs the token iterator to consider as tokens
those parts of the input that <span class="emphasis"><em>didn't</em></span>
match the regex.<br>
这个例子也是用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
来将一个序列分为一系列由单词组成的记号，不过它是用regex来作为分隔符。当我们传入一个 <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code> 作为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
构造函数的最后一个参数时，它会令该记号迭代器将输入中不被regex匹配的部分视为记号。 </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"This is his face"</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_s</span><span class="special">;</span> <span class="comment">// find white space 查找空格<br></span><br><span class="comment">// iterate over all non-white space in the input. Note the -1 below:<br>// 对输入中的所有非空白符进行迭代。注意下面的 -1：<br></span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="special">-</span><span class="number">1</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span><br><span class="comment">// write all the words to std::cout 将所有单词写出至std::cout<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p> This program displays the following:<br>
程序输出如下： </p>
<pre class="programlisting">This<br>is<br>his<br>face<br></pre>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_3__simple_tokenization__revolutions"></a>
<h3><a name="id4051314"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_3__simple_tokenization__revolutions">Example
3: Simple Tokenization, Revolutions 示例3：简单的记号化，革命</a> </h3>
<p> This example also uses <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
to chop a sequence containing a bunch of dates into a series of tokens
consisting of just the years. When we pass a positive integer <code class="literal"><span class="emphasis"><em>N</em></span></code>
as the last parameter to the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
constructor, it instructs the token iterator to consider as tokens only
the <code class="literal"><span class="emphasis"><em>N</em></span></code>-th
marked sub-expression of each match.<br>
这个例子还是用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
来将一个含有多个日期的序列分成一系列仅由年份组成的记号。当我们把一个正整数 <code class="literal"><span class="emphasis"><em>N</em></span></code>
作为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
构造函数的最后一个参数传入时，它会令该记号迭代器仅将每次匹配中的第<code class="literal"><span class="emphasis"><em>N</em></span></code>-
个子表达式视为记号。 </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981"</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(\\d{2})/(\\d{2})/(\\d{4})"</span><span class="special">);</span> <span class="comment">// find a date 查找一个日期<br></span><br><span class="comment">// iterate over all the years in the input. Note the 3 below, corresponding to the 3rd sub-expression:<br>// 对输入中的所有年份进行迭代。注意下面的 3，它对应于第3个子表达式：<br></span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="number">3</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span><br><span class="comment">// write all the words to std::cout 将所有单词写出至std::cout<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p> This program displays the following:<br>
程序输出如下： </p>
<pre class="programlisting">2003<br>1999<br>1981<br></pre>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_4__not_so_simple_tokenization"></a>
<h3><a name="id4051710"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_4__not_so_simple_tokenization">Example
4: Not-So-Simple Tokenization 不太简单的记号化</a> </h3>
<p> This example is like the previous one, except that instead of
tokenizing just the years, this program turns the days, months and
years into tokens. When we pass an array of integers <code class="literal"><span class="emphasis"><em>{I,J,...}</em></span></code>
as the last parameter to the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
constructor, it instructs the token iterator to consider as tokens the <code class="literal"><span class="emphasis"><em>I</em></span></code>-th,
<code class="literal"><span class="emphasis"><em>J</em></span></code>-th,
etc. marked sub-expression of each match.<br>
这个例子与上一个相似，不过它不是仅将年份记号化，它把日、月、年全部放入记号中。当我们传入一个整数数组 <code class="literal"><span class="emphasis"><em>{I,J,...}</em></span></code>
作为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
构造函数的最后一个参数时，它会令该记号迭代器将每次匹配中的第<code class="literal"><span class="emphasis"><em>I</em></span></code>-
个，第<code class="literal"><span class="emphasis"><em>J</em></span></code>-
个子表达式等等，视为记号。 </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981"</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(\\d{2})/(\\d{2})/(\\d{4})"</span><span class="special">);</span> <span class="comment">// find a date 查找一个日期<br></span><br><span class="comment">// iterate over the days, months and years in the input 对输入中的日、月、年进行迭代<br></span><span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">sub_matches</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">2</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">3</span> <span class="special">};</span> <span class="comment">// day, month, year<br></span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">sub_matches</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span><br><span class="comment">// write all the words to std::cout 将所有单词写出至std::cout<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p> This program displays the following:<br>
程序输出如下： </p>
<pre class="programlisting">02<br>01<br>2003<br>23<br>04<br>1999<br>13<br>11<br>1981<br></pre>
<p> The <code class="computeroutput"><span class="identifier">sub_matches</span></code>
array instructs the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
to first take the value of the 2nd sub-match, then the 1st sub-match,
and finally the 3rd. Incrementing the iterator again instructs it to
use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
again to find the next match. At that point, the process repeats -- the
token iterator takes the value of the 2nd sub-match, then the 1st, et
cetera.<br>
这个 <code class="computeroutput"><span class="identifier">sub_matches</span></code>
数据使得 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
首先取出第2个子匹配的值，然后是第1个子匹配，最后是第3个。再次递增该迭代器将使它再次调用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
来查找下一个匹配。然后重复以上过程 -- 该记号迭代器取出第2个子匹配的值，然后是第1个，依此类推。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.grammars_and_nested_matches"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches" title="Grammars and Nested Matches">Grammars and Nested
Matches 语法和嵌套匹配</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.overview"></a>
<h3><a name="id4052227"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.overview">Overview
概述</a> </h3>
<p> One of the key benefits of representing regexes as C++
expressions is the ability to easily refer to other C++ code and data
from within the regex. This enables programming idioms that are not
possible with other regular expression libraries. Of particular note is
the ability for one regex to refer to another regex, allowing you to
build grammars out of regular expressions. This section describes how
to embed one regex in another by value and by reference, how regex
objects behave when they refer to other regexes, and how to access the
tree of results after a successful parse.<br>
用C
++表达式来表示regex的一个关键优点是，可以很容易地在regex内引用其它C++代码和数据。这样就可以使用一些其它正则表达式库所不能实现的编
程技巧。尤其值得注意的是，可以在一个regex中引用另一个regex，你可以从正则表达式来构建语法。本节将介绍如何将一个regex以值方式或引用
方式嵌入到另一个regex中，当regex对象引用其它regex时其行为如何，以及在一次成功的语法分析后如何访问结果树。 </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_value"></a>
<h3><a name="id4052254"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_value">Embedding
a Regex by Value 以值方式嵌入一个Regex</a> </h3>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
object has value semantics. When a regex object appears on the
right-hand side in the definition of another regex, it is as if the
regex were embedded by value; that is, a copy of the nested regex is
stored by the enclosing regex. The inner regex is invoked by the outer
regex during pattern matching. The inner regex participates fully in
the match, back-tracking as needed to make the match succeed.<br>
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象是具有值语义的。当一个regex对象出现在另一个regex的定义中的右侧时，其作用就象是该regex以值方式被嵌入一样；即，内嵌的regex
的一份拷贝被外面的regex所保存。在模式匹配时，里面的regex将被外面的regex调用。里面的regex在匹配中要完全参与，视乎成功匹配的需
要进行后向跟踪。 </p>
<p> Consider a text editor that has a regex-find feature with a
whole-word option. You can implement this with xpressive as follows:<br>
来看一个文本编辑器，它具有regex-查找的功能，并带有一个"完整单词"的选项。你可以用xpressive实现如下： </p>
<pre class="programlisting"><span class="identifier">find_dialog</span> <span class="identifier">dlg</span><span class="special">;</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">dialog_ok</span> <span class="special">==</span> <span class="identifier">dlg</span><span class="special">.</span><span class="identifier">do_modal</span><span class="special">()</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">pattern</span> <span class="special">=</span> <span class="identifier">dlg</span><span class="special">.</span><span class="identifier">get_text</span><span class="special">();</span> <span class="comment">// the pattern the user entered 用户输入的模式<br></span> <span class="keyword">bool</span> <span class="identifier">whole_word</span> <span class="special">=</span> <span class="identifier">dlg</span><span class="special">.</span><span class="identifier">whole_word</span><span class="special">.</span><span class="identifier">is_checked</span><span class="special">();</span> <span class="comment">// did the user select the whole-word option? 用户是否选中"完整单词"<br></span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="identifier">pattern</span> <span class="special">);</span> <span class="comment">// try to compile the pattern 尝试编译该匹配模式<br></span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">whole_word</span> <span class="special">)</span><br><span class="special">{</span><br><span class="comment">// wrap the regex in begin-word / end-word assertions 将该regex用单词开始/单词结尾断言包裹起来<br></span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="identifier">re</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span><span class="special">;</span><br><span class="special">}</span><br><span class="comment">// ... use re ... 使用re<br></span><span class="special">}</span>
</pre>
<p> Look closely at this line:<br>
我们来仔细看看这一行： </p>
<pre class="programlisting"><span class="comment">// wrap the regex in begin-word / end-word assertions </span><span class="comment">将该regex用单词开始/单词结尾断言包裹起来</span><span class="comment"> <br></span><span class="identifier">re</span> <span class="special">=</span> <span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="identifier">re</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span><span class="special">;</span>
</pre>
<p> This line creates a new regex that embeds the old regex by
value. Then, the new regex is assigned back to the original regex.
Since a copy of the old regex was made on the right-hand side, this
works as you might expect: the new regex has the behavior of the old
regex wrapped in begin- and end-word assertions.<br>
这一行创建了一个新的regex，它以值方式嵌入了旧的regex。然后，这个新的regex被赋值回给原来的regex。由于在右侧创建了旧regex
的一份拷贝，所以其结果正如你所想：新的regex的行为就是旧regex被包在 begin- 和 end-word 断言中。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> Note that <code class="computeroutput"><span class="identifier">re</span> <span class="special">=</span>
<span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="identifier">re</span> <span class="special">&gt;&gt;</span>
<span class="identifier">eow</span></code>
does <span class="emphasis"><em>not</em></span>
define a recursive regular expression, since regex objects embed by
value by default. The next section shows how to define a recursive
regular expression by embedding a regex by reference.<br>
注意，<code class="computeroutput"><span class="identifier">re</span>
<span class="special">=</span> <span class="identifier">bow</span> <span class="special">&gt;&gt;</span>
<span class="identifier">re</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span></code>
并没有定义一个递归的正则表达式，因为缺省情况下，regex对象是以值方式嵌入的。下一节将示范如何通过以引用方式嵌入regex来定义一个递归的正则
表达式。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_reference"></a>
<h3><a name="id4052742"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_reference">Embedding
a Regex by Reference 以引用方式嵌入一个Regex</a> </h3>
<p> If you want to be able to build recursive regular expressions
and context-free grammars, embedding a regex by value is not enough.
You need to be able to make your regular expressions self-referential.
Most regular expression engines don't give you that power, but
xpressive does.<br>
如果你想构建递归的正则表达式和上下文无关的语法，以值方式嵌入regex是不够的。你要能让你的正则表达式自引用。多数正则表达式引擎没有这个能力，但
xpressive可以。 </p>
<div class="tip">
<table summary="Tip" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr>
<td align="left" valign="top">
<p> The theoretical computer scientists out there will
correctly point out that a self-referential regular expression is not
"regular", so in the strict sense, xpressive isn't really a <span class="emphasis"><em>regular</em></span>
expression engine at all. But as Larry Wall once said, "the term
[regular expression] has grown with the capabilities of our pattern
matching engines, so I'm not going to try to fight linguistic necessity
here."<br>
计
算机理论科学家会正确地指出，一个自引用的正则表达式并不“正规”，所以在严格意义上，xpressive实际上并不是一个正则表达式引擎。不过正如
Larry Wall 曾说过的，"这个术语[正则表达式]已随着我们的模式匹配引擎能力的发展而发展，所以我不打算在这里尝试和语言规律相争。" </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> Consider the following code, which uses the <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code> helper to
define a recursive regular expression that matches balanced, nested
parentheses:<br>
来看以下代码，它用 <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code>
辅助函数定义了一个递归的正则表达式，来匹配成对的嵌套的括号： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">parentheses</span><span class="special">;</span><br><span class="identifier">parentheses</span> <span class="comment">// A balanced set of parentheses ... 一对成对的括号<br></span> <span class="special">=</span> <span class="char">'('</span> <span class="comment">// is an opening parenthesis ... 是一个左括号<br></span> <span class="special">&gt;&gt;</span> <span class="comment">// followed by ... 加<br></span> <span class="special">*(</span> <span class="comment">// zero or more ... 零个或多个<br></span> <span class="identifier">keep</span><span class="special">(</span> <span class="special">+~(</span><span class="identifier">set</span><span class="special">=</span><span class="char">'('</span><span class="special">,</span><span class="char">')'</span><span class="special">)</span> <span class="special">)</span> <span class="comment">// of a bunch of things that are not parentheses ... 不是括号的东西<br></span> <span class="special">|</span> <span class="comment">// or ... 或者<br></span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">parentheses</span><span class="special">)</span> <span class="comment">// a balanced set of parentheses 一对成对的括号<br></span> <span class="special">)</span> <span class="comment">// (ooh, recursion!) ... (噢，递归！)<br></span> <span class="special">&gt;&gt;</span> <span class="comment">// followed by ... 再加<br></span> <span class="char">')'</span> <span class="comment">// a closing parenthesis 一个右括号<br></span> <span class="special">;</span>
</pre>
<p> Matching balanced, nested tags is an important text
processing task, and it is one that "classic" regular expressions
cannot do. The <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code> helper makes it
possible. It allows one regex object to be embedded in another <span class="emphasis"><em>by reference</em></span>.
Since the right-hand side holds <code class="computeroutput"><span class="identifier">parentheses</span></code> by
reference, assigning the right-hand side back to <code class="computeroutput"><span class="identifier">parentheses</span></code>
creates a cycle, which will execute recursively.<br>
匹配成对的、嵌套的标签是一项重要的文本处理任务，它也是"经典的"正则表达式所不能完成的任务。辅助函数 <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code>
使得它可以实现了。它允许一个regex对象以引用方式嵌入到另一个之中。由于赋值操作的右侧以引用方式持有 <code class="computeroutput"><span class="identifier">parentheses</span></code>，
所以将右侧部分赋值回 <code class="computeroutput"><span class="identifier">parentheses</span></code>
将创建一个循环，它将递归执行。 </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.building_a_grammar"></a>
<h3><a name="id4053056"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.building_a_grammar">Building
a Grammar 构建一种语法</a> </h3>
<p> Once we allow self-reference in our regular expressions, the
genie is out of the bottle and all manner of fun things are possible.
In particular, we can now build grammars out of regular expressions.
Let's have a look at the text-book grammar example: the humble
calculator.<br>
一旦我们可以在正则表达式中使用自引用，就象魔鬼出了瓶子，各种有趣的事情都可能发生了。尤其是，我们现在可以从正则表达式来构建语法。我们来看一个文本
图书的语法例子：一个简陋的计算器。 </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">group</span><span class="special">,</span> <span class="identifier">factor</span><span class="special">,</span> <span class="identifier">term</span><span class="special">,</span> <span class="identifier">expression</span><span class="special">;</span><br><span class="identifier">group</span> <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">expression</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span><br><span class="identifier">factor</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span> <span class="special">|</span> <span class="identifier">group</span><span class="special">;</span><br><span class="identifier">term</span> <span class="special">=</span> <span class="identifier">factor</span> <span class="special">&gt;&gt;</span> <span class="special">*((</span><span class="char">'*'</span> <span class="special">&gt;&gt;</span> <span class="identifier">factor</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="char">'/'</span> <span class="special">&gt;&gt;</span> <span class="identifier">factor</span><span class="special">));</span><br><span class="identifier">expression</span> <span class="special">=</span> <span class="identifier">term</span> <span class="special">&gt;&gt;</span> <span class="special">*((</span><span class="char">'+'</span> <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="char">'-'</span> <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">));</span>
</pre>
<p> The regex <code class="computeroutput"><span class="identifier">expression</span></code>
defined above does something rather remarkable for a regular
expression: it matches mathematical expressions. For example, if the
input string were <code class="computeroutput"><span class="string">"foo 9*(10+3) bar"</span></code>,
this pattern would match <code class="computeroutput"><span class="string">"9*(10+3)"</span></code>. It only
matches well-formed mathematical expressions, where the parentheses are
balanced and the infix operators have two arguments each. Don't try
this with just any regular expression engine!<br>
以上定义的regex <code class="computeroutput"><span class="identifier">expression</span></code>&nbsp;
做的事情对于一个正则表达式来说是不寻常的：它匹配数学表达式。例如，如果输入的字符串是 <code class="computeroutput"><span class="string">"foo
9*(10+3) bar"</span></code>，那么这个模式会匹配 <code class="computeroutput"><span class="string">"9*(10+3)"</span></code>。
它只匹配正确的数学表达式，即括号是成对的，且各个中缀操作符都有两个操作数。不要用其它任意的正则表达式引擎来尝试它！ </p>
<p> Let's take a closer look at this regular expression grammar.
Notice that it is cyclic: <code class="computeroutput"><span class="identifier">expression</span></code> is
implemented in terms of <code class="computeroutput"><span class="identifier">term</span></code>, which is
implemented in terms of <code class="computeroutput"><span class="identifier">factor</span></code>, which
is implemented in terms of <code class="computeroutput"><span class="identifier">group</span></code>, which is
implemented in terms of <code class="computeroutput"><span class="identifier">expression</span></code>,
closing the loop. In general, the way to define a cyclic grammar is to
forward-declare the regex objects and embed by reference those regular
expressions that have not yet been initialized. In the above grammar,
there is only one place where we need to reference a regex object that
has not yet been initialized: the definition of <code class="computeroutput"><span class="identifier">group</span></code>.
In that place, we use <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code> to embed <code class="computeroutput"><span class="identifier">expression</span></code>
by reference. In all other places, it is sufficient to embed the other
regex objects by value, since they have already been initialized and
their values will not change.<br>
我们来仔细看一下这个正则表达式语法。注意，它是循环的：<code class="computeroutput"><span class="identifier">expression</span></code> 要依据 <code class="computeroutput"><span class="identifier">term</span></code>
实现，后者要依据 <code class="computeroutput"><span class="identifier">factor</span></code> 实现，后者再依据
<code class="computeroutput"><span class="identifier">group</span></code>
实现，后者再依据 <code class="computeroutput"><span class="identifier">expression</span></code>
来实现，完成一个循环。通常，定义一个循环语法的方法是，前向声明regex对象并以引用方式将尚未初始化的它们嵌入到正则表达式中。在以上这个语法中，
只有一个地方需要引用尚未初始化的regex对象：在 <code class="computeroutput"><span class="identifier">group</span></code>
的定义中。在此，我们使用 <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code> 来以引用方式嵌入 <code class="computeroutput"><span class="identifier">expression</span></code>。
在所有其它的地方，以值方式嵌入其它regex对象就够了，因为它们都已经完成了初始化，而且值不会再变了。 </p>
<div class="tip">
<table summary="Tip" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr>
<td align="left" valign="top">
<p> <span class="bold"><strong>Embed by
value if possible 只要可能就以值方式嵌入</strong></span> <br>
<br>
In general, prefer embedding regular expressions by value rather than
by reference. It involves one less indirection, making your patterns
match a little faster. Besides, value semantics are simpler and will
make your grammars easier to reason about. Don't worry about the
expense of "copying" a regex. Each regex object shares its
implementation with all of its copies.<br>
通常，应该优先以值的方式而不是引用的方式嵌入正则表达式。这样可以少一层间接层，使你的模式匹配更快一点。此外，值语义更为简单，可以让你的语法更易
懂。不要担心"复制"一个regex的开销。每个regex对象在其所有拷贝间共享其实现。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.dynamic_regex_grammars"></a>
<h3><a name="id4053543"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.dynamic_regex_grammars">Dynamic
Regex Grammars 动态Regex语法</a> </h3>
<p> Using <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>,
you can also build grammars out of dynamic regular expressions. You do
that by creating named regexes, and referring to other regexes by name.
Each <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
instance keeps a mapping from names to regexes that have been created
with it.<br>
使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>，
你可以从动态正则表达式来构建语法。为此，你要通过创建命名regexes，然后以名字来引用至其它regexes。每个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
实例会持有一份从名字到它所创建的regexes的映射。 </p>
<p> You can create a named dynamic regex by prefacing your regex
with <code class="computeroutput"><span class="string">"(?$name=)"</span></code>,
where <span class="emphasis"><em>name</em></span>
is the name of the regex. You can refer to a named regex from another
regex with <code class="computeroutput"><span class="string">"(?$name)"</span></code>. The
named regex does not need to exist yet at the time it is referenced in
another regex, but it must exist by the time you use the regex.<br>
你可以通过在regex前加上 <code class="computeroutput"><span class="string">"(?$name=)"</span></code>
来创建一个命名的动态regex，其中 <span class="emphasis"><em>name</em></span>
是这个regex的名字。你可以用 <code class="computeroutput"><span class="string">"(?$name)"</span></code>
来从其它regex引用已命名的regex。在被引用至其它regex之时，命名的regex并不需要已经存在，但是在使用该regex时，它必须是存在
的。 </p>
<p> Below is a code fragment that uses dynamic regex grammars to
implement the calculator example from above.<br>
以下是一段使用动态regex语法来实现以上计算器例子的代码片断。 </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">regex_constants</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">expr</span><span class="special">;</span><br><span class="special">{</span><br><span class="identifier">sregex_compiler</span> <span class="identifier">compiler</span><span class="special">;</span><br><span class="identifier">syntax_option_type</span> <span class="identifier">x</span> <span class="special">=</span> <span class="identifier">ignore_white_space</span><span class="special">;</span><br><span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(? $group = ) \\( (? $expr ) \\) "</span><span class="special">,</span> <span class="identifier">x</span><span class="special">);</span><br><span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(? $factor = ) \\d+ | (? $group ) "</span><span class="special">,</span> <span class="identifier">x</span><span class="special">);</span><br><span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(? $term = ) (? $factor )"</span><br><span class="string">" ( \\* (? $factor ) | / (? $factor ) )* "</span><span class="special">,</span> <span class="identifier">x</span><span class="special">);</span><br><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(? $expr = ) (? $term )"</span><br><span class="string">" ( \\+ (? $term ) | - (? $term ) )* "</span><span class="special">,</span> <span class="identifier">x</span><span class="special">);</span><br><span class="special">}</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"foo 9*(10+3) bar"</span><span class="special">);</span><br><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="keyword">if</span><span class="special">(</span><span class="identifier">regex_search</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">expr</span><span class="special">))</span><br><span class="special">{</span><br><span class="comment">// This prints "9*(10+3)":<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> As with static regex grammars, nested regex invocations
create nested match results (see <span class="emphasis"><em>Nested
Results</em></span> below). The result is a complete parse
tree for string that matched. Unlike static regexes, dynamic regexes
are always embedded by reference, not by value.<br>
和静态regex语法一样，嵌套的regex调用创建嵌套的匹配结果(见后文的 <span class="emphasis"><em>嵌
套结果</em></span>)。该结果是一个针对被匹配字符串的完整的语法分析树。和静态regexes不同，动态
regexes总是以引用方式嵌入，不使用值方式。 </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.cyclic_patterns__copying_and_memory_management__oh_my_"></a>
<h3><a name="id4054122"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.cyclic_patterns__copying_and_memory_management__oh_my_">Cyclic
Patterns, Copying and Memory Management, Oh My! 循环的模式，复制和内存管理，哦！</a>
</h3>
<p> The calculator examples above raises a number of very
complicated memory-management issues. Each of the four regex objects
refer to each other, some directly and some indirectly, some by value
and some by reference. What if we were to return one of them from a
function and let the others go out of scope? What becomes of the
references? The answer is that the regex objects are internally
reference counted, such that they keep their referenced regex objects
alive as long as they need them. So passing a regex object by value is
never a problem, even if it refers to other regex objects that have
gone out of scope.<br>
以
上的计算器例子引起了许多非常复杂的内存管理问题。上面这四个regex对象中的每一个都引用了另外的regex，有直接的也有间接的，有值方式的也有引
用方式的。如果我们从一个函数返回了一个这样的regex，又让另一个被引用的regex离开了作用域，会怎么样呢？答案是，regex对象在内部采用了
引用计数，这样它们可以按需要保持它们所引用的regex对象的生存期。因此，以值方式传递一个regex对象不会有问题，即使它所引用的其它regex
对象已经超出了作用域。 </p>
<p> Those of you who have dealt with reference counting are
probably familiar with its Achilles Heel: cyclic references. If regex
objects are reference counted, what happens to cycles like the one
created in the calculator examples? Are they leaked? The answer is no,
they are not leaked. The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
object has some tricky reference tracking code that ensures that even
cyclic regex grammars are cleaned up when the last external reference
goes away. So don't worry about it. Create cyclic grammars, pass your
regex objects around and copy them all you want. It is fast and
efficient and guaranteed not to leak or result in dangling references.<br>
你们当中曾经用过引用计数的人，可能会很熟悉它的致命弱点：循环引用。如果regex对象是引用计数的，对于前面的计算器例子中所创建的循环regex会
发生什么？它们会泄露吗？答案是不会的，它们不会泄露。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象有一些特殊的引用跟踪代码来确保当最后一个外部引用消失时，即使是循环的regex语法也会清理干净。所以不需要担心它。放心地按你所想的创建循环语
法，传递regex对象和复制它们吧。这些是快速和高效的，并且保证不会泄露或引起悬空的引用。 </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.nested_regexes_and_sub_match_scoping"></a>
<h3><a name="id4054179"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.nested_regexes_and_sub_match_scoping">Nested
Regexes and Sub-Match Scoping 嵌套Regex和子匹配域</a> </h3>
<p> Nested regular expressions raise the issue of sub-match
scoping. If both the inner and outer regex write to and read from the
same sub-match vector, chaos would ensue. The inner regex would stomp
on the sub-matches written by the outer regex. For example, what does
this do?<br>
嵌套的正则表达式带来了子匹配域的问题。如果内层的regex和外层的regex都要写出到或读入自同一个子匹配向量，混乱就会发生。内层的regex将
破坏由外层regex写出的子匹配。例如，以下例子会做些什么？ </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">inner</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(.)\\1"</span> <span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">outer</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="identifier">_</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="identifier">inner</span> <span class="special">&gt;&gt;</span> <span class="identifier">s1</span><span class="special">;</span>
</pre>
<p> The author probably didn't intend for the inner regex to
overwrite the sub-match written by the outer regex. The problem is
particularly acute when the inner regex is accepted from the user as
input. The author has no way of knowing whether the inner regex will
stomp the sub-match vector or not. This is clearly not acceptable.<br>
作者可能并不是想要内层的regex覆写由外层regex所写出的子匹配。当内层的regex是由用户输入时，这个问题尤其严重。作者没有办法知道内层的
regex是否会破坏子匹配向量。这显然是不可接受的。 </p>
<p> Instead, what actually happens is that each invocation of a
nested regex gets its own scope. Sub-matches belong to that scope. That
is, each nested regex invocation gets its own copy of the sub-match
vector to play with, so there is no way for an inner regex to stomp on
the sub-matches of an outer regex. So, for example, the regex <code class="computeroutput"><span class="identifier">outer</span></code>
defined above would match <code class="computeroutput"><span class="string">"ABBA"</span></code>, as it
should.<br>
相反，实际情况是，嵌套regex的每次调用会得到它自己的作用域。子匹配属于该作用域。即，每次嵌套regex的调用会得到它自己的子匹配向量拷贝用以
操作，所以内层regex是没有办法破坏外层regex的子匹配的。例如，以上所定义的regex <code class="computeroutput"><span class="identifier">outer</span></code>
会匹配 <code class="computeroutput"><span class="string">"ABBA"</span></code>，
如其所愿。 </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.nested_results"></a>
<h3><a name="id4054366"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.nested_results">Nested
Results 嵌套结果</a> </h3>
<p> If nested regexes have their own sub-matches, there should be
a way to access them after a successful match. In fact, there is. After
a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
or <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>,
the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
struct behaves like the head of a tree of nested results. The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
class provides a <code class="computeroutput"><span class="identifier">nested_results</span><span class="special">()</span></code> member function
that returns an ordered sequence of <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
structures, representing the results of the nested regexes. The order
of the nested results is the same as the order in which the nested
regex objects matched.<br>
如果嵌套regexes具有它们自己的子匹配，那么就应试有方法在成功匹配后访问它们。事实上，确实有。在 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
或 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
之后，结构 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
的行为类似于嵌套结果树的头部。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
类提供了一个 <code class="computeroutput"><span class="identifier">nested_results</span><span class="special">()</span></code> 成员函数，它返回一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
结构的已排序序列，表示嵌套regexes的结果。嵌套结果的顺序与嵌套regex对象匹配的顺序相同。 </p>
<p> Take as an example the regex for balanced, nested parentheses
we saw earlier:<br>
以我们前面看到过的匹配成对的、嵌套的括号的regex为例： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">parentheses</span><span class="special">;</span><br><span class="identifier">parentheses</span> <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span> <span class="identifier">keep</span><span class="special">(</span> <span class="special">+~(</span><span class="identifier">set</span><span class="special">=</span><span class="char">'('</span><span class="special">,</span><span class="char">')'</span><span class="special">)</span> <span class="special">)</span> <span class="special">|</span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">parentheses</span><span class="special">)</span> <span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span><br><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"blah blah( a(b)c (c(e)f (g)h )i (j)6 )blah"</span> <span class="special">);</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_search</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">parentheses</span> <span class="special">)</span> <span class="special">)</span><br><span class="special">{</span><br><span class="comment">// display the whole match 显示整个匹配<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="comment">// display the nested results 显示嵌套结果<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><br><span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">begin</span><span class="special">(),</span><br><span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">end</span><span class="special">(),</span><br><span class="identifier">output_nested_results</span><span class="special">()</span> <span class="special">);</span><br><span class="special">}</span>
</pre>
<p> This program displays the following:<br>
程序输出如下： </p>
<pre class="programlisting">( a(b)c (c(e)f (g)h )i (j)6 )<br> (b)<br> (c(e)f (g)h )<br> (e)<br> (g)<br> (j)<br></pre>
<p> Here you can see how the results are nested and that they are
stored in the order in which they are found.<br>
这里你可以看到这个结果是如何嵌套的，以及它们是按查找的顺序保存的。 </p>
<div class="tip">
<table summary="Tip" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr>
<td align="left" valign="top">
<p> See the definition of <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.display_a_tree_of_nested_results">output_nested_results</a>
in the <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">Examples</a> section.<br>
请见在 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">示例</a> 一节中的 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.display_a_tree_of_nested_results">output_nested_results</a>
定义。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.filtering_nested_results"></a>
<h3><a name="id4072418"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches.filtering_nested_results">Filtering
Nested Results 过滤嵌套结果</a> </h3>
<p> Sometimes a regex will have several nested regex objects, and
you want to know which result corresponds to which regex object. That's
where <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">match_results</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code> come in handy.
When iterating over the nested results, you can compare the regex id
from the results to the id of the regex object you're interested in.<br>
有时一个regex有多个嵌套的regex对象，而且你想知道哪个结果对应哪个regex对象。这时 <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code> 和 <code class="computeroutput"><span class="identifier">match_results</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code>
可以帮上忙。在对嵌套结果进行迭代时，你可以将结果中的regex id与你所关心的regex对象的id进行比较。 </p>
<p> To make this a bit easier, xpressive provides a predicate to
make it simple to iterate over just the results that correspond to a
certain nested regex. It is called <code class="computeroutput"><span class="identifier">regex_id_filter_predicate</span></code>,
and it is intended to be used with <a href="../../../libs/iterator/doc/index.html" target="_top">Boost.Iterator</a>.
You can use it as follows:<br>
为了让这容易一些，xpressive提供了一个谓词，可以很简单地对与特定的嵌套regex相对应的结果进行迭代。这个谓词名为 <code class="computeroutput"><span class="identifier">regex_id_filter_predicate</span></code>，
其目的是要被用于 <a href="../../../libs/iterator/doc/index.html" target="_top">Boost.Iterator</a>。你可以这样来使用它： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">name</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">alpha</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">integer</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">*(</span> <span class="special">*</span><span class="identifier">_s</span> <span class="special">&gt;&gt;</span> <span class="special">(</span> <span class="identifier">name</span> <span class="special">|</span> <span class="identifier">integer</span> <span class="special">)</span> <span class="special">);</span><br><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"marsha 123 jan 456 cindy 789"</span> <span class="special">);</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">re</span> <span class="special">)</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">smatch</span><span class="special">::</span><span class="identifier">nested_results_type</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">begin</span> <span class="special">=</span> <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">begin</span><span class="special">();</span><br><span class="identifier">smatch</span><span class="special">::</span><span class="identifier">nested_results_type</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">end</span> <span class="special">=</span> <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">end</span><span class="special">();</span><br><span class="comment">// declare filter predicates to select just the names or the integers<br> // 声明过滤谓词，只选出名字或整数<br></span> <span class="identifier">sregex_id_filter_predicate</span> <span class="identifier">name_id</span><span class="special">(</span> <span class="identifier">name</span><span class="special">.</span><span class="identifier">regex_id</span><span class="special">()</span> <span class="special">);</span><br><span class="identifier">sregex_id_filter_predicate</span> <span class="identifier">integer_id</span><span class="special">(</span> <span class="identifier">integer</span><span class="special">.</span><span class="identifier">regex_id</span><span class="special">()</span> <span class="special">);</span><br><span class="comment">// iterate over only the results from the name regex 只迭代来自于name regex的结果<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">name_id</span><span class="special">,</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">name_id</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span><br><span class="identifier">output_result</span><br><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="comment">// iterate over only the results from the integer regex 只迭代来自于整数regex的结果<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">integer_id</span><span class="special">,</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">integer_id</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span><br><span class="identifier">output_result</span><br><span class="special">);</span><br><span class="special">}</span>
</pre>
<p> where <code class="computeroutput"><span class="identifier">output_results</span></code>
is a simple function that takes a <code class="computeroutput"><span class="identifier">smatch</span></code> and
displays the full match. Notice how we use the <code class="computeroutput"><span class="identifier">regex_id_filter_predicate</span></code>
together with <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">()</span></code> from the <a href="../../../libs/iterator/doc/index.html" target="_top">Boost.Iterator</a>
to select only those results corresponding to a particular nested
regex. This program displays the following:<br>
其中 <code class="computeroutput"><span class="identifier">output_results</span></code>
是一个简单的函数，它接受一个 <code class="computeroutput"><span class="identifier">smatch</span></code>
并打印全匹配。留意我们是如何将 <code class="computeroutput"><span class="identifier">regex_id_filter_predicate</span></code>
和 <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code> 以及 <a href="../../../libs/iterator/doc/index.html" target="_top">Boost.Iterator</a>
的 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">()</span></code>
一起使用，来选出仅与特定的嵌套regex相对应的结果。程序的输出如下： </p>
<pre class="programlisting">marsha<br>jan<br>cindy<br>123<br>456<br>789<br></pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions" title="Semantic Actions and User-Defined Assertions">Semantic
Actions and User-Defined Assertions 语义动作与用户自定义断言</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.overview"></a>
<h3><a name="id4073389"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.overview">Overview
概述</a> </h3>
<p> Imagine you want to parse an input string and build a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>
from it. For something like that, matching a regular expression isn't
enough. You want to <span class="emphasis"><em>do
something</em></span> when parts of your regular expression
match. Xpressive lets you attach semantic actions to parts of your
static regular expressions. This section shows you how.<br>
想象你想分析一个输入串并从中构建一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>。
对于这种事情，仅仅匹配一个正则表达式是不够的。你想要在你的正则表达式部分匹配时<span class="emphasis"><em>做
些事情</em></span>。Xpressive让你可以为你的静态正则表达式的某个部分添加语义动作。本节将向你展示怎么
做。 </p>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.semantic_actions"></a>
<h3><a name="id4073448"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.semantic_actions">Semantic
Actions 语义动作</a> </h3>
<p> Consider the following code, which uses xpressive's semantic
actions to parse a string of word/integer pairs and stuffs them into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>.
It is described below.<br>
我们来看以下代码，它使用xpressive的语义动作来分析一个由单词/整数对组成的串，并将它们存入一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>。后文
有说明。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">result</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"aaa=&gt;1 bbb=&gt;23 ccc=&gt;456"</span><span class="special">);</span><br><span class="comment">// Match a word and an integer, separated by =&gt;,<br></span> <span class="comment">// and then stuff the result into a std::map&lt;&gt;<br> // 匹配一个单词和一个整数，以=&gt;分隔，然后将结果存入一个std::map&lt;&gt;<br></span> <span class="identifier">sregex</span> <span class="identifier">pair</span> <span class="special">=</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="string">"=&gt;"</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s2</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span><span class="special">)</span> <span class="special">)</span><br><span class="special">[</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">)</span> <span class="special">];</span><br><span class="comment">// Match one or more word/integer pairs, separated<br></span> <span class="comment">// by whitespace.<br> //匹配一个或多个单词/整数对，以空格分隔<br></span> <span class="identifier">sregex</span> <span class="identifier">rx</span> <span class="special">=</span> <span class="identifier">pair</span> <span class="special">&gt;&gt;</span> <span class="special">*(+</span><span class="identifier">_s</span> <span class="special">&gt;&gt;</span> <span class="identifier">pair</span><span class="special">);</span><br><span class="keyword">if</span><span class="special">(</span><span class="identifier">regex_match</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">rx</span><span class="special">))</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"aaa"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"bbb"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"ccc"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="special">}</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program prints the following:<br>
程序输出如下： </p>
<pre class="programlisting">1<br>23<br>456<br></pre>
<p> The regular expression <code class="computeroutput"><span class="identifier">pair</span></code> has two
parts: the pattern and the action. The pattern says to match a word,
capturing it in sub-match 1, and an integer, capturing it in sub-match
2, separated by <code class="computeroutput"><span class="string">"=&gt;"</span></code>. The
action is the part in square brackets: <code class="computeroutput"><span class="special">[</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span> <span class="special">=</span>
<span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">)</span>
<span class="special">]</span></code>. It says
to take sub-match one and use it to index into the <code class="computeroutput"><span class="identifier">results</span></code>
map, and assign to it the result of converting sub-match 2 to an
integer.<br>
正则表达式 <code class="computeroutput"><span class="identifier">pair</span></code>
有两部分：模式和动作。其模式部分指出，匹配一个单词并把它放入子匹配1，然后是一个整数并放入子匹配2，它们之间由 <code class="computeroutput"><span class="string">"=&gt;"</span></code>
分隔。动作部分是由方括号括起来的部分：<code class="computeroutput"><span class="special">[</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span> <span class="special">=</span>
<span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">)</span>
<span class="special">]</span></code>。它表示，取出子匹配
1并用它作为 <code class="computeroutput"><span class="identifier">results</span></code>
map的索引，然后将由子匹配2转换为整数的结果赋给它。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> To use semantic actions with your static regexes, you
must <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;<br>
</span></code>要对你的静态regex使用语义动作，你必须 <code class="computeroutput"><span class="preprocessor">#include</span>
<span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> How does this work? Just as the rest of the static regular
expression, the part between brackets is an expression template. It
encodes the action and executes it later. The expression <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)</span></code> creates a lazy
reference to the <code class="computeroutput"><span class="identifier">result</span></code> object.
The larger expression <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span></code> is a lazy map
index operation. Later, when this action is getting executed, <code class="computeroutput"><span class="identifier">s1</span></code>
gets replaced with the first <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>.
Likewise, when <code class="computeroutput"><span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">)</span></code>
gets executed, <code class="computeroutput"><span class="identifier">s2</span></code> is replaced
with the second <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>.
The <code class="computeroutput"><span class="identifier">as</span><span class="special">&lt;&gt;</span></code>
action converts its argument to the requested type using
Boost.Lexical_cast. The effect of the whole action is to insert a new
word/integer pair into the map.<br>
这是如何工作的呢？正如这个静态正则表达式后一部分那样，在方括号中的是一个表达式模板。它对动作编码并延后执行它。表达式 <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)</span></code> 创建了一个 <code class="computeroutput"><span class="identifier">result</span></code>
对象的延迟引用。较大一些的表达式 <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span></code>
则是一个延迟的map索引操作。当这个动作稍后被执行时，<code class="computeroutput"><span class="identifier">s1</span></code> 会被第一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
所替代。同样，当 <code class="computeroutput"><span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">)</span></code>
被执行时，<code class="computeroutput"><span class="identifier">s2</span></code> 会替换为第二个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>。
动作 <code class="computeroutput"><span class="identifier">as</span><span class="special">&lt;&gt;</span></code>
使用Boost.Lexical_cast将它的参数转换为所要求的类型。整个动作的效果就是，插入一个新的单词/整数对到map中。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> There is an important difference between the function <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> in <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">ref</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> in <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>. The
first returns a plain <code class="computeroutput"><span class="identifier">reference_wrapper</span><span class="special">&lt;&gt;</span></code>
which behaves in many respects like an ordinary reference. By contrast,
<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> returns a <span class="emphasis"><em>lazy</em></span>
reference that you can use in expressions that are executed lazily.
That is why we can say <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span></code>, even though <code class="computeroutput"><span class="identifier">result</span></code>
doesn't have an <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>
that would accept <code class="computeroutput"><span class="identifier">s1</span></code>.<br>
<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">ref</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
中的函数 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code>
与 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> 中的 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code>
有很大的差别。前者返回一个简单的 <code class="computeroutput"><span class="identifier">reference_wrapper</span><span class="special">&lt;&gt;</span></code>，其行
为在许多方面都与普通的引用相似。相比之下，<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> 返回一个<span class="emphasis"><em>延迟</em></span>的引用，你可以把
它用于延后执行的表达式之中。这正是我们可以写 <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span></code> 的原因，即使 <code class="computeroutput"><span class="identifier">result</span></code>
并没有一个接受 <code class="computeroutput"><span class="identifier">s1</span></code> 的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> In addition to the sub-match placeholders <code class="computeroutput"><span class="identifier">s1</span></code>,
<code class="computeroutput"><span class="identifier">s2</span></code>,
etc., you can also use the placeholder <code class="computeroutput"><span class="identifier">_</span></code> within an
action to refer back to the string matched by the sub-expression to
which the action is attached. For instance, you can use the following
regex to match a bunch of digits, interpret them as an integer and
assign the result to a local variable:<br>
除了子匹配占位符 <code class="computeroutput"><span class="identifier">s1</span></code>, <code class="computeroutput"><span class="identifier">s2</span></code>
等，你还可以在动作中使用占位符 <code class="computeroutput"><span class="identifier">_</span></code>
来反向引用至附加该动作的子表达式所匹配的字符串。例如，你可以用以下regex来匹配一串数字，把它们解释为整数并把结果赋值给一个局部变量： </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="comment">// Here, _ refers back to all the<br></span><span class="comment">// characters matched by (+_d)<br>// 这里，_ 反向引用至被 (+_d) 匹配的所有字符<br></span><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">(+</span><span class="identifier">_d</span><span class="special">)[</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">)</span> <span class="special">];</span>
</pre>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.lazy_action_execution"></a>
<h4><a name="id4075014"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.lazy_action_execution">Lazy
Action Execution 延迟的动作执行</a> </h4>
<p> What does it mean, exactly, to attach an action to part of a
regular expression and perform a match? When does the action execute?
If the action is part of a repeated sub-expression, does the action
execute once or many times? And if the sub-expression initially
matches, but ultimately fails because the rest of the regular
expression fails to match, is the action executed at all?<br>
把
一个动作附加至一个正则表达式的某个部分并执行匹配，其正确的意义是什么？该动作何时被执行？如果这个动作是一个重复的子表达式的一部分，它会被执行一次
还是多次？还有，如果这个子表达式开始的时候是被匹配的，但是最终却因为正则表达式的其它部分匹配失败而失败，这个动作还会被执行吗？ </p>
<p> The answer is that by default, actions are executed <span class="emphasis"><em>lazily</em></span>.
When a sub-expression matches a string, its action is placed on a
queue, along with the current values of any sub-matches to which the
action refers. If the match algorithm must backtrack, actions are
popped off the queue as necessary. Only after the entire regex has
matched successfully are the actions actually exeucted. They are
executed all at once, in the order in which they were added to the
queue, as the last step before <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
returns.<br>
答
案是，缺省地，动作是被延迟执行的。当一个子表达式匹配一个字符串时，它的动作和该动作所引用的所有子匹配的值一起，会被放入一个队列中。如果匹配算法必
须回溯，该动作会视需要从队列中弹出。只有当整个regex被成功地匹配，这些动作才会被执行。它们会按照它们加入到队列中的顺序，作为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
返回之前的最后一个步骤，被一次性地执行。 </p>
<p> For example, consider the following regex that increments a
counter whenever it finds a digit.<br>
例如，考虑以下regex，它在发现一个数字时递增一个计数器。 </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"1!2!3?"</span><span class="special">);</span><br><span class="comment">// count the exciting digits, but not the<br></span><span class="comment">// questionable ones.<br>// 计算带感叹号的数字，但带问号的不计。<br></span><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span><br><span class="identifier">regex_search</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">rex</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(</span> <span class="identifier">i</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>
</pre>
<p> The action <code class="computeroutput"><span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span></code> is queued three
times: once for each found digit. But it is only <span class="emphasis"><em>executed</em></span>
twice: once for each digit that precedes a <code class="computeroutput"><span class="char">'!'</span></code>
character. When the <code class="computeroutput"><span class="char">'?'</span></code> character is
encountered, the match algorithm backtracks, removing the final action
from the queue.<br>
动作 <code class="computeroutput"><span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span></code>
将被三次加入队列：每发现一个数字一次。但它仅被执行两次：每个带 <code class="computeroutput"><span class="char">'!'</span></code> 字符的数字一次。当遇到 <code class="computeroutput"><span class="char">'?'</span></code>
字符时，匹配算法会回溯，把最后一个动作移出队列。 </p>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.immediate_action_execution"></a>
<h4><a name="id4075349"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.immediate_action_execution">Immediate
Action Execution 即时的动作执行</a> </h4>
<p> When you want semantic actions to execute immediately, you
can wrap the sub-expression containing the action in a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/keep.html" title="Function template keep">keep()</a></code></code>.
<code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code> turns off
back-tracking for its sub-expression, but it also causes any actions
queued by the sub-expression to execute at the end of the <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>. It is as if
the sub-expression in the <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>
were compiled into an independent regex object, and matching the <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code> is like a
separate invocation of <code class="computeroutput"><span class="identifier">regex_search</span><span class="special">()</span></code>. It matches
characters and executes actions but never backtracks or unwinds. For
example, imagine the above example had been written as follows:<br>
如果你想让一个语义动作立即执行，你可以把含有该动作的子表达式包入一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/keep.html" title="Function template keep">keep()</a></code></code>
中。<code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>
关闭了对此子表达式的回溯，不过它也会引起由该子表达式放入队列的所有动作在 <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>
之后执行。它就象在 <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>
中的子表达式被编译为一个独立的regex对象，匹配该 <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>
就象一次 <code class="computeroutput"><span class="identifier">regex_search</span><span class="special">()</span></code>
的单独调用。它匹配字符并执行动作，但不会回溯或展开。例如，想象上述例子被改为如下： </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"1!2!3?"</span><span class="special">);</span><br><span class="comment">// count all the digits. 对所有数字计数<br></span><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">keep</span><span class="special">(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">]</span> <span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span><br><span class="identifier">regex_search</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">rex</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(</span> <span class="identifier">i</span> <span class="special">==</span> <span class="number">3</span> <span class="special">);</span>
</pre>
<p> We have wrapped the sub-expression <code class="computeroutput"><span class="identifier">_d</span>
<span class="special">[</span> <span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">]</span></code>
in <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>.
Now, whenever this regex matches a digit, the action will be queued and
then immediately executed before we try to match a <code class="computeroutput"><span class="char">'!'</span></code>
character. In this case, the action executes three times.<br>
我们把子表达式 <code class="computeroutput"><span class="identifier">_d</span> <span class="special">[</span>
<span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span>
<span class="special">]</span></code> 包入 <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>
中。现在，当这个regex匹配到一个数字时，该动作就会被加入队列，然后在我们试图匹配 <code class="computeroutput"><span class="char">'!'</span></code>
字符之前立即执行。在此情况下，该动作被执行三次。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> Like <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code>,
actions within <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/before.html" title="Function template before">before()</a></code></code>
and <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/after.html" title="Function template after">after()</a></code></code>
are also executed early when their sub-expressions have matched.<br>
和 <code class="computeroutput"><span class="identifier">keep</span><span class="special">()</span></code> 相似，在 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/before.html" title="Function template before">before()</a></code></code>
和 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/after.html" title="Function template after">after()</a></code></code>
中的动作也会在它们的子表达式被匹配时提前执行。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.lazy_functions"></a>
<h4><a name="id4075806"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.lazy_functions">Lazy
Functions 延迟函数</a> </h4>
<p> So far, we've seen how to write semantic actions consisting
of variables and operators. But what if you want to be able to call a
function from a semantic action? Xpressive provides a mechanism to do
this.<br>
到目前为止，我们已经看过如何编写一个由变量和操作符组成的语义动作。但是如果你想在一个语义动作中调用某个函数，那要怎么做呢？Xpressive提供
了一个机制来实现它。 </p>
<p> The first step is to define a function object type. Here, for
instance, is a function object type that calls <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code> on its argument:<br>
第一步是定义一个函数对象类型。例如，以下是一个对其参数调用 <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>
的函数对象类型： </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">push_impl</span><br><span class="special">{</span><br><span class="comment">// Result type, needed for tr1::result_of 结果类型，这是 tr1::result_of 要求的<br></span> <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">result_type</span><span class="special">;</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sequence</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span><br><span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Sequence</span> <span class="special">&amp;</span><span class="identifier">seq</span><span class="special">,</span> <span class="identifier">Value</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">val</span><span class="special">)</span> <span class="keyword">const</span><br><span class="special">{</span><br><span class="identifier">seq</span><span class="special">.</span><span class="identifier">push</span><span class="special">(</span><span class="identifier">val</span><span class="special">);</span><br><span class="special">}</span><br><span class="special">};</span>
</pre>
<p> The next step is to use xpressive's <code class="computeroutput"><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>
template to define a function object named <code class="computeroutput"><span class="identifier">push</span></code>:<br>
下一步是用xpressive的 <code class="computeroutput"><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>
模板来定义一个名为 <code class="computeroutput"><span class="identifier">push</span></code> 的函数对象： </p>
<pre class="programlisting"><span class="comment">// Global "push" function object. 全局的 "push" 函数对象。<br></span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">push_impl</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">push</span> <span class="special">=</span> <span class="special">{{}};</span>
</pre>
<p> The initialization looks a bit odd, but this is because <code class="computeroutput"><span class="identifier">push</span></code>
is being statically initialized. That means it doesn't need to be
constructed at runtime. We can use <code class="computeroutput"><span class="identifier">push</span></code> in
semantic actions as follows:<br>
这里的初始化看起来有点奇怪，这是因为 <code class="computeroutput"><span class="identifier">push</span></code>
是被静态初始化的。这意味着它不需要在运行期进行构造。我们可以在语义动作中使用 <code class="computeroutput"><span class="identifier">push</span></code>，如下： </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">stack</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">ints</span><span class="special">;</span><br><span class="comment">// Match digits, cast them to an int<br></span><span class="comment">// and push it on the stack.<br>// 匹配数字，将它们转换为一个int并压入栈中。<br></span><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">(+</span><span class="identifier">_d</span><span class="special">)[</span><span class="identifier">push</span><span class="special">(</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">ints</span><span class="special">),</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">))];</span>
</pre>
<p> You'll notice that doing it this way causes member function
invocations to look like ordinary function invocations. You can choose
to write your semantic action in a different way that makes it look a
bit more like a member function call:<br>
你会留意到，用这种方法来做会使得成员函数的调用看起来象一个普通函数的调用。你可以选择以其它方式来编写你的语义动作，令它看起来更象成员函数调用一
点： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">(+</span><span class="identifier">_d</span><span class="special">)[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">ints</span><span class="special">)-&gt;*</span><span class="identifier">push</span><span class="special">(</span><span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">))];</span>
</pre>
<p> Xpressive recognizes the use of the <code class="computeroutput"><span class="special">-&gt;*</span></code>
and treats this expression exactly the same as the one above.<br>
Xpressive会认得 <code class="computeroutput"><span class="special">-&gt;*</span></code>
并把这个表达式视为与上一个完全一样。 </p>
<p> When your function object must return a type that depends on
its arguments, you can use a <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
member template instead of the <code class="computeroutput"><span class="identifier">result_type</span></code>
typedef. Here, for example, is a <code class="computeroutput"><span class="identifier">first</span></code> function
object that returns the <code class="computeroutput"><span class="identifier">first</span></code> member of
a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;&gt;</span></code>
or <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>:<br>
如果你的函数对象必须根据其参数决定返回的类型，那么你可以使用 <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
成员模板来替代 <code class="computeroutput"><span class="identifier">result_type</span></code>
typedef。例如，以下是一个 <code class="computeroutput"><span class="identifier">first</span></code>
函数对象，它返回一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;&gt;</span></code>
或 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
的 <code class="computeroutput"><span class="identifier">first</span></code>
成员： </p>
<pre class="programlisting"><span class="comment">// Function object that returns the<br></span><span class="comment">// first element of a pair.<br>// 函数对象返回一个 pair 的 first 成员。<br></span><span class="keyword">struct</span> <span class="identifier">first_impl</span><br><span class="special">{</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sig</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">result</span> <span class="special">{};</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">This</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pair</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">This</span><span class="special">(</span><span class="identifier">Pair</span><span class="special">)&gt;</span><br><span class="special">{</span><br><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Pair</span><span class="special">&gt;</span><br><span class="special">::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">first_type</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">};</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Pair</span><span class="special">&gt;</span><br><span class="keyword">typename</span> <span class="identifier">Pair</span><span class="special">::</span><span class="identifier">first_type</span><br><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Pair</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">p</span><span class="special">)</span> <span class="keyword">const</span><br><span class="special">{</span><br><span class="keyword">return</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">first</span><span class="special">;</span><br><span class="special">}</span><br><span class="special">};</span><br><span class="comment">// OK, use as first(s1) to get the begin iterator<br></span><span class="comment">// of the sub-match referred to by s1.<br>// 好的，使用 first(s1) 来获取通过 s1 引用的子匹配的 begin 迭代器。<br></span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">first_impl</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">first</span> <span class="special">=</span> <span class="special">{{}};</span>
</pre>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_local_variables"></a>
<h4><a name="id4076886"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_local_variables">Referring
to Local Variables 引用局部变量</a> </h4>
<p> As we've seen in the examples above, we can refer to local
variables within an actions using <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code>. Any such
variables are held by reference by the regular expression, and care
should be taken to avoid letting those references dangle. For instance,
in the following code, the reference to <code class="computeroutput"><span class="identifier">i</span></code> is left to
dangle when <code class="computeroutput"><span class="identifier">bad_voodoo</span><span class="special">()</span></code> returns:<br>
正如我们在上例中所看到的，我们可以用 <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code>
在一个动作内引用某个局部变量。所有这样的变量都会被正则表达式以引用方式保存，并要小心避免让它们变为悬空的引用。例如，在以下代码中，到 <code class="computeroutput"><span class="identifier">i</span></code>
的引用会在 <code class="computeroutput"><span class="identifier">bad_voodoo</span><span class="special">()</span></code> 返回时悬空： </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">bad_voodoo</span><span class="special">()</span><br><span class="special">{</span><br><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span><br><span class="comment">// ERROR! rex refers by reference to a local<br></span> <span class="comment">// variable, which will dangle after bad_voodoo()<br></span> <span class="comment">// returns.<br> // 错误！rex 以引用方式引向一个局部变量，它会在 bad_voodoo() 返回后悬空。<br></span> <span class="keyword">return</span> <span class="identifier">rex</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> When writing semantic actions, it is your responsibility to
make sure that all the references do not dangle. One way to do that
would be to make the variables shared pointers that are held by the
regex by value.<br>
在编写语义动作时，你要负责确保所有引用不会悬空。一种解决方法是，把变量变为由regex以值方式持有的共享指针。 </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">good_voodoo</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pi</span><span class="special">)</span><br><span class="special">{</span><br><span class="comment">// Use val() to hold the shared_ptr by value: 使用 val() 来以值方式持有 shared_ptr：<br></span> <span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++*</span><span class="identifier">val</span><span class="special">(</span><span class="identifier">pi</span><span class="special">)</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span><br><span class="comment">// OK, rex holds a reference count to the integer. 好的，rex持有一个对integer的引用计数。<br></span> <span class="keyword">return</span> <span class="identifier">rex</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> In the above code, we use <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">val</span><span class="special">()</span></code> to hold the
shared pointer by value. That's not normally necessary because local
variables appearing in actions are held by value by default, but in
this case, it is necessary. Had we written the action as <code class="computeroutput"><span class="special">++*</span><span class="identifier">pi</span></code>, it would
have executed immediately. That's because <code class="computeroutput"><span class="special">++*</span><span class="identifier">pi</span></code> is not an
expression template, but <code class="computeroutput"><span class="special">++*</span><span class="identifier">val</span><span class="special">(</span><span class="identifier">pi</span><span class="special">)</span></code> is.<br>
在以上代码中，我们用 <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">val</span><span class="special">()</span></code>
来以值方式持有该共享指针。通常这是不需要的，因为在动作中出现的局部变量缺省是以值方式持有的，不过在这个例子中，这样做是必须的。如果我们把这个动作
写为 <code class="computeroutput"><span class="special">++*</span><span class="identifier">pi</span></code>，它就会立即执行。这是因为
<code class="computeroutput"><span class="special">++*</span><span class="identifier">pi</span></code> 不是一个表达式模板，而 <code class="computeroutput"><span class="special">++*</span><span class="identifier">val</span><span class="special">(</span><span class="identifier">pi</span><span class="special">)</span></code>
是。 </p>
<p> It can be tedious to wrap all your variables in <code class="computeroutput"><span class="identifier">ref</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">val</span><span class="special">()</span></code> in your
semantic actions. Xpressive provides the <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code>
and <code class="computeroutput"><span class="identifier">value</span><span class="special">&lt;&gt;</span></code>
templates to make things easier. The following table shows the
equivalencies:<br>
在语义动作中把所有变量都用 <code class="computeroutput"><span class="identifier">ref</span><span class="special">()</span></code>
和 <code class="computeroutput"><span class="identifier">val</span><span class="special">()</span></code>
包起来是很乏味的。Xpressive提供了 <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code> 和
<code class="computeroutput"><span class="identifier">value</span><span class="special">&lt;&gt;</span></code>
模板，可以使得这件事情容易些。下表列出这两个模板： </p>
<div class="table">
<a name="id4077441"></a>
<p class="title"><b>Table&nbsp;27.12.&nbsp;reference&lt;&gt;
and value&lt;&gt;<br>
表&nbsp;27.12.&nbsp;reference&lt;&gt; 和
value&lt;&gt;</b></p>
<div class="table-contents">
<table class="table" summary="reference&lt;&gt; and value&lt;&gt;">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> This ... 这个... </p>
</th>
<th>
<p> ... is equivalent to this ... 等同于这个... </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span></pre>
<p> </p>
</td>
<td>
<p> </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="identifier">reference</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">ri</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">ri</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span></pre>
<p> </p>
</td>
</tr>
<tr>
<td>
<p> </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pi</span><span class="special">(</span><span class="keyword">new</span> <span class="keyword">int</span><span class="special">(</span><span class="number">0</span><span class="special">));</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++*</span><span class="identifier">val</span><span class="special">(</span><span class="identifier">pi</span><span class="special">)</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span></pre>
<p> </p>
</td>
<td>
<p> </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pi</span><span class="special">(</span><span class="keyword">new</span> <span class="keyword">int</span><span class="special">(</span><span class="number">0</span><span class="special">));</span><br><span class="identifier">value</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">vpi</span><span class="special">(</span><span class="identifier">pi</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++*</span><span class="identifier">vpi</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span></pre>
<p> </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> As you can see, when using <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code>,
you need to first declare a local variable and then declare a <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code>
to it. These two steps can be combined into one using <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;</span></code>.<br>
如你所见，使用 <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code>
的时候，你要首先声明一个局部变量，然后声明对它一个 <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code>。这两
个步骤可以用 <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;</span></code>
合并为一步。 </p>
<div class="table">
<a name="id4078116"></a>
<p class="title"><b>Table&nbsp;27.13.&nbsp;local&lt;&gt;
vs. reference&lt;&gt;<br>
表&nbsp;27.13.&nbsp;local&lt;&gt; vs.
reference&lt;&gt;</b></p>
<div class="table-contents">
<table class="table" summary="local&lt;&gt; vs. reference&lt;&gt;">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p> This ... 这个... </p>
</th>
<th>
<p> ... is equivalent to this ... 等同于这个... </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> </p>
<pre class="programlisting"><span class="identifier">local</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">i</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span></pre>
<p> </p>
</td>
<td>
<p> </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="identifier">reference</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">ri</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">ri</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span></pre>
<p> </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> We can use <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;</span></code>
to rewrite the above example as follows:<br>
我们可以用 <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;</span></code>
重写前面的例子，如下： </p>
<pre class="programlisting"><span class="identifier">local</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"1!2!3?"</span><span class="special">);</span><br><span class="comment">// count the exciting digits, but not the<br></span><span class="comment">// questionable ones.<br>// 对带感叹号的数字计数，但不计带问号的。<br></span><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">[</span> <span class="special">++</span><span class="identifier">i</span> <span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span> <span class="special">);</span><br><span class="identifier">regex_search</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">rex</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(</span> <span class="identifier">i</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>
</pre>
<p> Notice that we use <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>
to access the value of the local variable. Also, beware that <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;</span></code>
can be used to create a dangling reference, just as <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code>
can.<br>
注意，我们用了 <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>
来访问这个局部变量的值。还有，要小心 <code class="computeroutput"><span class="identifier">local</span><span class="special">&lt;&gt;</span></code>
也可能被用于创建一个悬空的引用，象 <code class="computeroutput"><span class="identifier">reference</span><span class="special">&lt;&gt;</span></code>
那样。 </p>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_non_local_variables"></a>
<h4><a name="id4078705"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_non_local_variables">Referring
to Non-Local Variables 引用非局部变量</a> </h4>
<p> In the beginning of this section, we used a regex with a
semantic action to parse a string of word/integer pairs and stuff them
into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>.
That required that the map and the regex be defined together and used
before either could go out of scope. What if we wanted to define the
regex once and use it to fill lots of different maps? We would rather
pass the map into the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
algorithm rather than embed a reference to it directly in the regex
object. What we can do instead is define a placeholder and use that in
the semantic action instead of the map itself. Later, when we call one
of the regex algorithms, we can bind the reference to an actual map
object. The following code shows how.<br>
在本节的开始，我们用一个带语义动作的regex来分析一个由单词/整数对组成的串，并将它们存入一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>
中。这就要求这个map和这个regex要一起定义，并且在它们的任何一个超出作用域之前使用。如果我们想定义regex一次并用它来填充多个不同的
map，应该怎么办呢？我们应该把这个map传入 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
算法，而不是直接在regex对象中嵌入一个引用。我们可以做的是，定义一个占位符并在语义动作当中用它来替换map本身。然后，当我们调用某个
regex算法时，我们就可以将这个引用绑定到一个实际的map对象。以下代码示范了要怎么做。 </p>
<pre class="programlisting"><span class="comment">// Define a placeholder for a map object: 为map对象定义一个占位符：<br></span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">_map</span><span class="special">;</span><br><span class="comment">// Match a word and an integer, separated by =&gt;,<br></span><span class="comment">// and then stuff the result into a std::map&lt;&gt;<br>// 匹配一个单词和一个整数，由 =&gt; 分隔，然后将结果填入一个 std::map&lt;&gt;<br></span><span class="identifier">sregex</span> <span class="identifier">pair</span> <span class="special">=</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="string">"=&gt;"</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s2</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span><span class="special">)</span> <span class="special">)</span><br><span class="special">[</span> <span class="identifier">_map</span><span class="special">[</span><span class="identifier">s1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">)</span> <span class="special">];</span><br><span class="comment">// Match one or more word/integer pairs, separated<br></span><span class="comment">// by whitespace.<br>// 匹配一个或多个单词/整数对，以空格间隔。<br></span><span class="identifier">sregex</span> <span class="identifier">rx</span> <span class="special">=</span> <span class="identifier">pair</span> <span class="special">&gt;&gt;</span> <span class="special">*(+</span><span class="identifier">_s</span> <span class="special">&gt;&gt;</span> <span class="identifier">pair</span><span class="special">);</span><br><span class="comment">// The string to parse 要分析的字符串<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"aaa=&gt;1 bbb=&gt;23 ccc=&gt;456"</span><span class="special">);</span><br><span class="comment">// Here is the actual map to fill in: 实际填入的map：<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">result</span><span class="special">;</span><br><span class="comment">// Bind the _map placeholder to the actual map 将_map占位符绑定至实际的map<br></span><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="identifier">what</span><span class="special">.</span><span class="identifier">let</span><span class="special">(</span> <span class="identifier">_map</span> <span class="special">=</span> <span class="identifier">result</span> <span class="special">);</span><br><span class="comment">// Execute the match and fill in result map 执行匹配并填入结果map<br></span><span class="keyword">if</span><span class="special">(</span><span class="identifier">regex_match</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">rx</span><span class="special">))</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"aaa"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"bbb"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"ccc"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program displays:<br>
程序输出： </p>
<pre class="programlisting">1<br>23<br>456<br></pre>
<p> We use <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;&gt;</span></code>
here to define <code class="computeroutput"><span class="identifier">_map</span></code>, which
stands in for a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>
variable. We can use the placeholder in the semantic action as if it
were a map. Then, we define a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
struct and bind an actual map to the placeholder with "<code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">let</span><span class="special">(</span> <span class="identifier">_map</span>
<span class="special">=</span> <span class="identifier">result</span> <span class="special">);</span></code>". The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
call behaves as if the placeholder in the semantic action had been
replaced with a reference to <code class="computeroutput"><span class="identifier">result</span></code>.<br>
这里我们用 <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;&gt;</span></code>
来定义 <code class="computeroutput"><span class="identifier">_map</span></code>，用于代替 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>
变量。我们在语义动作中可以象用一个map那样使用这个占位符。然后，我们定义一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
结构并用 "<code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">let</span><span class="special">(</span>
<span class="identifier">_map</span> <span class="special">=</span> <span class="identifier">result</span>
<span class="special">);</span></code>"
把一个实际的map绑定至这个占位符。<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>&amp;
nbsp;调用的行为就象语义动作中的占位符被替换为 <code class="computeroutput"><span class="identifier">result</span></code> 的一个引用一样。
</p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> Placeholders in semantic actions are not <span class="emphasis"><em>actually</em></span>
replaced at runtime with references to variables. The regex object is
never mutated in any way during any of the regex algorithms, so they
are safe to use in multiple threads.<br>
语义动作中的占位符并不是在运行期真的被替换为某个变量的引用。在任何regex算法执行期间，regex对象都不会被修改，所以它们可以在多线程环境中
安全地使用。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> The syntax for late-bound action arguments is a little
different if you are using <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
or <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>.
The regex iterators accept an extra constructor parameter for
specifying the argument bindings. There is a <code class="computeroutput"><span class="identifier">let</span><span class="special">()</span></code> function that
you can use to bind variables to their placeholders. The following code
demonstrates how.<br>
如果你要用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
或 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>，
那么动作参数的延迟绑定语法要有一点不同。regex迭代器接受一个额外的构造函数参数，以指定要绑定的参数。你可以用一个 <code class="computeroutput"><span class="identifier">let</span><span class="special">()</span></code>
函数来将变量绑定至它们的占位符。以下代码示范了要怎么做。 </p>
<pre class="programlisting"><span class="comment">// Define a placeholder for a map object: 为map定义一个占位符：<br></span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">_map</span><span class="special">;</span><br><span class="comment">// Match a word and an integer, separated by =&gt;,<br></span><span class="comment">// and then stuff the result into a std::map&lt;&gt;<br></span><span class="comment">// 匹配一个或多个单词/整数对，以空格间隔。</span><br><span class="identifier">sregex</span> <span class="identifier">pair</span> <span class="special">=</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="string">"=&gt;"</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s2</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span><span class="special">)</span> <span class="special">)</span><br><span class="special">[</span> <span class="identifier">_map</span><span class="special">[</span><span class="identifier">s1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">)</span> <span class="special">];</span><br><span class="comment">// The string to parse 要分析的字符串<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"aaa=&gt;1 bbb=&gt;23 ccc=&gt;456"</span><span class="special">);</span><br><span class="comment">// Here is the actual map to fill in:</span><span class="comment"> 实际填入的map：</span><span class="comment"> <br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">result</span><span class="special">;</span><br><span class="comment">// Create a regex_iterator to find all the matches 创建一个regex_iterator来查找所有匹配<br></span><span class="identifier">sregex_iterator</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">pair</span><span class="special">,</span> <span class="identifier">let</span><span class="special">(</span><span class="identifier">_map</span><span class="special">=</span><span class="identifier">result</span><span class="special">));</span><br><span class="identifier">sregex_iterator</span> <span class="identifier">end</span><span class="special">;</span><br><span class="comment">// step through all the matches, and fill in<br></span><span class="comment">// the result map<br>// 分步进行所有匹配，并填入结果map<br></span><span class="keyword">while</span><span class="special">(</span><span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">)</span><br><span class="special">++</span><span class="identifier">it</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"aaa"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"bbb"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span><span class="special">[</span><span class="string">"ccc"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
</pre>
<p> This program displays:<br>
程序输出： </p>
<pre class="programlisting">1<br>23<br>456<br></pre>
<a name="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.user_defined_assertions"></a>
<h3><a name="id4080374"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.user_defined_assertions">User-Defined
Assertions 用户自定义断言</a> </h3>
<p> You are probably already familiar with regular expression <span class="emphasis"><em>assertions</em></span>.
In Perl, some examples are the <code class="literal">^</code>
and <code class="literal">$</code> assertions,
which you can use to match the beginning and end of a string,
respectively. Xpressive lets you define your own assertions. A custom
assertion is a contition which must be true at a point in the match in
order for the match to succeed. You can check a custom assertion with
xpressive's <code class="literal"><code class="computeroutput">check()</code></code>
function.<br>
可能你对正则表达式<span class="emphasis"><em>断言</em></span>已
经非常熟悉。在Perl中，可以以 <code class="literal">^</code> 和 <code class="literal">$</code>
断言为例，你可以用它们来分别匹配字符串的开始与结尾。Xpressive可以让你定义自己的断言。客户化断言是指为了令匹配成功而在匹配点上必须为真的
一个条件。你可以用xpressive的 <code class="literal"><code class="computeroutput">check()</code></code>
函数来检查一个客户化断言。 </p>
<p> There are a couple of ways to define a custom assertion. The
simplest is to use a function object. Let's say that you want to ensure
that a sub-expression matches a sub-string that is either 3 or 6
characters long. The following struct defines such a predicate:<br>
有多种方法来下定义一个客户化断言。最简单的方法是用一个函数对象。我们假定你要确认某个子表达式匹配一个长度为3或6的子串。以下结构定义了这样的一个
谓词： </p>
<pre class="programlisting"><span class="comment">// A predicate that is true IFF a sub-match is<br></span><span class="comment">// either 3 or 6 characters long.<br>// 一个谓词，当且仅当一个子匹配的长度为3或6时为真。<br></span><span class="keyword">struct</span> <span class="identifier">three_or_six</span><br><span class="special">{</span><br><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">ssub_match</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">sub</span><span class="special">)</span> <span class="keyword">const</span><br><span class="special">{</span><br><span class="keyword">return</span> <span class="identifier">sub</span><span class="special">.</span><span class="identifier">length</span><span class="special">()</span> <span class="special">==</span> <span class="number">3</span> <span class="special">||</span> <span class="identifier">sub</span><span class="special">.</span><span class="identifier">length</span><span class="special">()</span> <span class="special">==</span> <span class="number">6</span><span class="special">;</span><br><span class="special">}</span><br><span class="special">};</span>
</pre>
<p> You can use this predicate within a regular expression as
follows:<br>
你可以在一个正则表达式中用这个谓词，如下： </p>
<pre class="programlisting"><span class="comment">// match words of 3 characters or 6 characters. 匹配3个字符或6个字符的单词。<br></span><span class="identifier">sregex</span> <span class="identifier">rx</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span><span class="special">)[</span> <span class="identifier">check</span><span class="special">(</span><span class="identifier">three_or_six</span><span class="special">())</span> <span class="special">]</span> <span class="special">;</span>
</pre>
<p> The above regular expression will find whole words that are
either 3 or 6 characters long. The <code class="computeroutput"><span class="identifier">three_or_six</span></code>
predicate accepts a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
that refers back to the part of the string matched by the
sub-expression to which the custom assertion is attached.<br>
以上正则表达式将找出长度为3或6个字符的完整单词。谓词 <code class="computeroutput"><span class="identifier">three_or_six</span></code>
接受一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>，
它引向由该客户化断言所附着的子表达式所匹配的部分字符串。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> The custom assertion participates in determining
whether the match succeeds or fails. Unlike actions, which execute
lazily, custom assertions execute immediately while the regex engine is
searching for a match.<br>
客户化断言参与了对当前匹配是否成功的判断。与延迟执行的动作不同，客户化断言是在regex引擎查找到一个匹配时立即执行的。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> Custom assertions can also be defined inline using the same
syntax as for semantic actions. Below is the same custom assertion
written inline:<br>
客户化断言还可以使用与语义动作相同的语法来内联定义。以下是以内联方式编写的同一个客户化断言： </p>
<pre class="programlisting"><span class="comment">// match words of 3 characters or 6 characters. 匹配3个字符或6个字符的单词。<br></span><span class="identifier">sregex</span> <span class="identifier">rx</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span><span class="special">)[</span> <span class="identifier">check</span><span class="special">(</span><span class="identifier">length</span><span class="special">(</span><span class="identifier">_</span><span class="special">)==</span><span class="number">3</span> <span class="special">||</span> <span class="identifier">length</span><span class="special">(</span><span class="identifier">_</span><span class="special">)==</span><span class="number">6</span><span class="special">)</span> <span class="special">]</span> <span class="special">;</span>
</pre>
<p> In the above, <code class="computeroutput"><span class="identifier">length</span><span class="special">()</span></code> is a lazy
function that calls the <code class="computeroutput"><span class="identifier">length</span><span class="special">()</span></code> member function
of its argument, and <code class="computeroutput"><span class="identifier">_</span></code> is a
placeholder that receives the <code class="computeroutput"><span class="identifier">sub_match</span></code>.<br>
在上例中，<code class="computeroutput"><span class="identifier">length</span><span class="special">()</span></code> 是一个延迟函数，它调用其参数的
<code class="computeroutput"><span class="identifier">length</span><span class="special">()</span></code> 成员函数，而 <code class="computeroutput"><span class="identifier">_</span></code>
是接收 <code class="computeroutput"><span class="identifier">sub_match</span></code> 的占位符。
</p>
<p> Once you get the hang of writing custom assertions inline,
they can be very powerful. For example, you can write a regular
expression that only matches valid dates (for some suitably liberal
definition of the term “<span class="quote">valid</span>”).<br>
一旦学会编写内联式的客户化断言，它们可以非常强大。例如，你可以写一个只匹配有效日期的正则表达式(对术语"有效"的定义适当宽松了一些)。 </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">days_per_month</span><span class="special">[]</span> <span class="special">=</span><br><span class="special">{</span><span class="number">31</span><span class="special">,</span> <span class="number">29</span><span class="special">,</span> <span class="number">31</span><span class="special">,</span> <span class="number">30</span><span class="special">,</span> <span class="number">31</span><span class="special">,</span> <span class="number">30</span><span class="special">,</span> <span class="number">31</span><span class="special">,</span> <span class="number">31</span><span class="special">,</span> <span class="number">30</span><span class="special">,</span> <span class="number">31</span><span class="special">,</span> <span class="number">31</span><span class="special">,</span> <span class="number">31</span><span class="special">};</span><br><span class="identifier">mark_tag</span> <span class="identifier">month</span><span class="special">(</span><span class="number">1</span><span class="special">),</span> <span class="identifier">day</span><span class="special">(</span><span class="number">2</span><span class="special">);</span><br><span class="comment">// find a valid date of the form month/day/year. 找出形如月/日/年的有效日期。<br></span><span class="identifier">sregex</span> <span class="identifier">date</span> <span class="special">=</span><br><span class="special">(</span><br><span class="comment">// Month must be between 1 and 12 inclusive 月份必须在1到12之间<br></span> <span class="special">(</span><span class="identifier">month</span><span class="special">=</span> <span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="special">!</span><span class="identifier">_d</span><span class="special">)</span> <span class="special">[</span> <span class="identifier">check</span><span class="special">(</span><span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">)</span> <span class="special">&gt;=</span> <span class="number">1</span><br><span class="special">&amp;&amp;</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">)</span> <span class="special">&lt;=</span> <span class="number">12</span><span class="special">)</span> <span class="special">]</span><br><span class="special">&gt;&gt;</span> <span class="char">'/'</span><br><span class="comment">// Day must be between 1 and 31 inclusive 日期必须在1到31之间<br></span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">day</span><span class="special">=</span> <span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="special">!</span><span class="identifier">_d</span><span class="special">)</span> <span class="special">[</span> <span class="identifier">check</span><span class="special">(</span><span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">)</span> <span class="special">&gt;=</span> <span class="number">1</span><br><span class="special">&amp;&amp;</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">)</span> <span class="special">&lt;=</span> <span class="number">31</span><span class="special">)</span> <span class="special">]</span><br><span class="special">&gt;&gt;</span> <span class="char">'/'</span><br><span class="comment">// Only consider years between 1970 and 2038 只考虑1970至2038之间的年份<br></span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">)</span> <span class="special">[</span> <span class="identifier">check</span><span class="special">(</span><span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">)</span> <span class="special">&gt;=</span> <span class="number">1970</span><br><span class="special">&amp;&amp;</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_</span><span class="special">)</span> <span class="special">&lt;=</span> <span class="number">2038</span><span class="special">)</span> <span class="special">]</span><br><span class="special">)</span><br><span class="comment">// Ensure the month actually has that many days! 确保当月真的有这么多天！<br></span> <span class="special">[</span> <span class="identifier">check</span><span class="special">(</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">days_per_month</span><span class="special">)[</span><span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">month</span><span class="special">)-</span><span class="number">1</span><span class="special">]</span> <span class="special">&gt;=</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">day</span><span class="special">)</span> <span class="special">)</span> <span class="special">]</span><br><span class="special">;</span><br><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"99/99/9999 2/30/2006 2/28/2006"</span><span class="special">);</span><br><span class="keyword">if</span><span class="special">(</span><span class="identifier">regex_search</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">date</span><span class="special">))</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> The above program prints out the following:<br>
以上程序输出如下： </p>
<pre class="programlisting">2/28/2006<br></pre>
<p> Notice how the inline custom assertions are used to
range-check the values for the month, day and year. The regular
expression doesn't match <code class="computeroutput"><span class="string">"99/99/9999"</span></code> or <code class="computeroutput"><span class="string">"2/30/2006"</span></code>
because they are not valid dates. (There is no 99th month, and February
doesn't have 30 days.)<br>
留意这里的内联式客户化断言如何用来对月、日、年的值进行范围检查。该正则表达式不匹配 <code class="computeroutput"><span class="string">"99/99/9999"</span></code>
或 <code class="computeroutput"><span class="string">"2/30/2006"</span></code>，
因为它们不是有效的日期。(没有第99个月，二月份也没有30天)。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.symbol_tables_and_attributes"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.symbol_tables_and_attributes" title="Symbol Tables and Attributes">Symbol Tables and
Attributes 符号表和属性</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.symbol_tables_and_attributes.overview"></a>
<h3><a name="id4082021"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.symbol_tables_and_attributes.overview">Overview
概述</a> </h3>
<p> Symbol tables can be built into xpressive regular expressions
with just a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>.
The map keys are the strings to be matched and the map values are the
data to be returned to your semantic action. Xpressive attributes,
named <code class="computeroutput"><span class="identifier">a1</span></code>, <code class="computeroutput"><span class="identifier">a2</span></code>,
through <code class="computeroutput"><span class="identifier">a9</span></code>, hold the
value corresponding to a matching key so that it can be used in a
semantic action. A default value can be specified for an attribute if a
symbol is not found.<br>
可以用 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>
在xpressive正则表达式中构建符号表。map的键值是匹配到的字符串，而map的值则是被返回到你的语义动作的数据。Xpressive属性，其
命名为 <code class="computeroutput"><span class="identifier">a1</span></code>, <code class="computeroutput"><span class="identifier">a2</span></code>,
... <code class="computeroutput"><span class="identifier">a9</span></code>,
分别存有与匹配键相对应的值，可以被用于某个语义动作中。如果某个符号找不到，可以为属性指定一个缺省值。 </p>
<a name="boost_xpressive.user_s_guide.symbol_tables_and_attributes.symbol_tables"></a>
<h3><a name="id4082103"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.symbol_tables_and_attributes.symbol_tables">Symbol
Tables 符号表</a> </h3>
<p> An xpressive symbol table is just a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>,
where the key is a string type and the value can be anything. For
example, the following regular expression matches a key from map1 and
assigns the corresponding value to the attribute <code class="computeroutput"><span class="identifier">a1</span></code>.
Then, in the semantic action, it assigns the value stored in attribute <code class="computeroutput"><span class="identifier">a1</span></code>
to an integer result.<br>
一个xpressive符号表就是一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>，
其键类型为字符串，值类型可以是任意类型。例如，以下正则表达式从map1匹配一个键值，并且将对应的值赋给属性 <code class="computeroutput"><span class="identifier">a1</span></code>。
然后，在语义动作中，再将保存在属性 <code class="computeroutput"><span class="identifier">a1</span></code> 中的值赋给一个整数结果。
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">result</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">map1</span><span class="special">;</span><br><span class="comment">// ... (fill the map) (填充该map)<br></span><span class="identifier">sregex</span> <span class="identifier">rx</span> <span class="special">=</span> <span class="special">(</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="identifier">map1</span> <span class="special">)</span> <span class="special">[</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">a1</span> <span class="special">];</span>
</pre>
<p> Consider the following example code, which translates number
names into integers. It is described below.<br>
看以下代码示例，它将数字名翻译为整数。说明见后。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">number_map</span><span class="special">;</span><br><span class="identifier">number_map</span><span class="special">[</span><span class="string">"one"</span><span class="special">]</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span><br><span class="identifier">number_map</span><span class="special">[</span><span class="string">"two"</span><span class="special">]</span> <span class="special">=</span> <span class="number">2</span><span class="special">;</span><br><span class="identifier">number_map</span><span class="special">[</span><span class="string">"three"</span><span class="special">]</span> <span class="special">=</span> <span class="number">3</span><span class="special">;</span><br><span class="comment">// Match a string from number_map<br></span> <span class="comment">// and store the integer value in 'result'<br></span> <span class="comment">// if not found, store -1 in 'result'<br> // 从number_map匹配一个字符并将整数值保存入'result'，如果找不到，则存入-1<br></span> <span class="keyword">int</span> <span class="identifier">result</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><br><span class="identifier">cregex</span> <span class="identifier">rx</span> <span class="special">=</span> <span class="special">((</span><span class="identifier">a1</span> <span class="special">=</span> <span class="identifier">number_map</span> <span class="special">)</span> <span class="special">|</span> <span class="special">*</span><span class="identifier">_</span><span class="special">)</span><br><span class="special">[</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">a1</span> <span class="special">|</span> <span class="special">-</span><span class="number">1</span><span class="special">)];</span><br><span class="identifier">regex_match</span><span class="special">(</span><span class="string">"three"</span><span class="special">,</span> <span class="identifier">rx</span><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">regex_match</span><span class="special">(</span><span class="string">"two"</span><span class="special">,</span> <span class="identifier">rx</span><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="identifier">regex_match</span><span class="special">(</span><span class="string">"stuff"</span><span class="special">,</span> <span class="identifier">rx</span><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program prints the following:<br>
该程序输出如下： </p>
<pre class="programlisting">3<br>2<br>-1<br></pre>
<p> First the program builds a number map, with number names as
string keys and the corresponding integers as values. Then it
constructs a static regular expression using an attribute <code class="computeroutput"><span class="identifier">a1</span></code>
to represent the result of the symbol table lookup. In the semantic
action, the attribute is assigned to an integer variable <code class="computeroutput"><span class="identifier">result</span></code>.
If the symbol was not found, a default value of <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code> is assigned to <code class="computeroutput"><span class="identifier">result</span></code>.
A wildcard, <code class="computeroutput"><span class="special">*</span><span class="identifier">_</span></code>,
makes sure the regex matches even if the symbol is not found.<br>
首先，该程序建立一个数字map，以数字名作为字符串键值，以对应的整数为值。然后它构造一个静态正则表达式，用一个属性 <code class="computeroutput"><span class="identifier">a1</span></code>
来表示从符号表中查找得到的结果。在语义动作中，该属性被赋给一个整数变量 <code class="computeroutput"><span class="identifier">result</span></code>。如果没有找到相应符
号，则将缺省值 <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>
赋给 <code class="computeroutput"><span class="identifier">result</span></code>。通配符 <code class="computeroutput"><span class="special">*</span><span class="identifier">_</span></code>
确保即使找不到相应符号，regex也可以匹配成功。 </p>
<p> A more complete version of this example can be found in <code class="literal">libs/xpressive/example/numbers.cpp</code>
<sup>[<a name="id4083153" href="user_s_guide.html#ftn.id4083153" class="footnote">5</a>]</sup>
. It translates number names up to "nine hundred ninety nine million
nine hundred ninety nine thousand nine hundred ninety nine" along with
some special number names like "dozen".<br>
在 <code class="literal">libs/xpressive/example/numbers.cpp</code>
<sup>[<a name="id4083153" href="#ftn.id4083153" class="footnote">5</a>]</sup>
中可以找到这个例子的一个更完整的版本。它可以翻译最大至"nine hundred ninety nine million nine
hundred ninety nine thousand nine hundred ninety nine"的数字名以及一些特殊的数字名，如
"dozen"。 </p>
<p> Symbol table matches are case sensitive by default, but they
can be made case-insensitive by enclosing the expression in <code class="computeroutput"><span class="identifier">icase</span><span class="special">()</span></code>.<br>
符号表匹配缺省是大小写敏感的，不过可以通过将表达式放入 <code class="computeroutput"><span class="identifier">icase</span><span class="special">()</span></code>
中来使它们变为大小写不敏感。 </p>
<a name="boost_xpressive.user_s_guide.symbol_tables_and_attributes.attributes"></a>
<h3><a name="id4083195"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.symbol_tables_and_attributes.attributes">Attributes
属性</a> </h3>
<p> Up to nine attributes can be used in a regular expression.
They are named <code class="computeroutput"><span class="identifier">a1</span></code>, <code class="computeroutput"><span class="identifier">a2</span></code>,
..., <code class="computeroutput"><span class="identifier">a9</span></code> in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span></code>
namespace. The attribute type is the same as the second component of
the map that is assigned to it. A default value for an attribute can be
specified in a semantic action with the syntax <code class="computeroutput"><span class="special">(</span><span class="identifier">a1</span> <span class="special">|</span>
<em class="replaceable"><code>default-value</code></em><span class="special">)</span></code>.<br>
在一个正则表达式中，最多可以使用九个属性。它们分别命名为 <code class="computeroutput"><span class="identifier">a1</span></code>, <code class="computeroutput"><span class="identifier">a2</span></code>,
..., <code class="computeroutput"><span class="identifier">a9</span></code>，位于 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span></code>
名字空间中。属性的类型与赋值给它的map的第二个元素相同。属性的缺省值可以在语义动作中用语法 <code class="computeroutput"><span class="special">(</span><span class="identifier">a1</span> <span class="special">|</span>
<em class="replaceable"><code>default-value</code></em><span class="special">)</span></code> 来指定。 </p>
<p> Attributes are properly scoped, so you can do crazy things
like: <code class="computeroutput"><span class="special">(</span> <span class="special">(</span><span class="identifier">a1</span><span class="special">=</span><span class="identifier">sym1</span><span class="special">)</span>
<span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">a1</span><span class="special">=</span><span class="identifier">sym2</span><span class="special">)[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">x</span><span class="special">)=</span><span class="identifier">a1</span><span class="special">]</span> <span class="special">)[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">y</span><span class="special">)=</span><span class="identifier">a1</span><span class="special">]</span></code>.
The inner semantic action sees the inner <code class="computeroutput"><span class="identifier">a1</span></code>,
and the outer semantic action sees the outer one. They can even have
different types.<br>
属性是被正确地定域的，所以你可以做出象以下这样的疯狂事情：<code class="computeroutput"><span class="special">(</span> <span class="special">(</span><span class="identifier">a1</span><span class="special">=</span><span class="identifier">sym1</span><span class="special">)</span>
<span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">a1</span><span class="special">=</span><span class="identifier">sym2</span><span class="special">)[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">x</span><span class="special">)=</span><span class="identifier">a1</span><span class="special">]</span> <span class="special">)[</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">y</span><span class="special">)=</span><span class="identifier">a1</span><span class="special">]</span></code>。
内层的语义动作可以看到内层的 <code class="computeroutput"><span class="identifier">a1</span></code>，而外层的语义动作则看到外层
的那个。它们甚至可以具有不同的类型。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr>
<td align="left" valign="top">
<p> Xpressive builds a hidden ternary search trie from the
map so it can search quickly. If BOOST_DISABLE_THREADS is defined, the
hidden ternary search trie "self adjusts", so after each search it
restructures itself to improve the efficiency of future searches based
on the frequency of previous searches.<br>
Xpressive会从map中构建一个隐藏的三元搜索树，以便可以快速地查找。如果定义了
BOOST_DISABLE_THREADS，则隐藏的三元搜索树会"自我调整"，在每次搜索后它会基于之前的搜索频率进行重组，以提高后面的搜索效率。
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.localization_and_regex_traits"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits" title="Localization and Regex Traits">Localization and Regex
Traits 本地化和Regex Traits</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.overview"></a>
<h3><a name="id4083460"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits.overview">Overview
概述</a> </h3>
<p> Matching a regular expression against a string often requires
locale-dependent information. For example, how are case-insensitive
comparisons performed? The locale-sensitive behavior is captured in a
traits class. xpressive provides three traits class templates: <code class="computeroutput"><span class="identifier">cpp_regex_traits</span><span class="special">&lt;&gt;</span></code>, <code class="computeroutput"><span class="identifier">c_regex_traits</span><span class="special">&lt;&gt;</span></code>
and <code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>.
The first wraps a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>, the
second wraps the global C locale, and the third is a stub traits type
for use when searching non-character data. All traits templates conform
to the <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.traits_requirements">Regex
Traits Concept</a>.<br>
将一个正则表达式与一个字符串进行匹配，通常需要与locale有关的信息。例如，如何执行大小写不敏感的比较？与locale有关的行为被收集到一个
traits类中。xpressive提供了三个traits类模板：<code class="computeroutput"><span class="identifier">cpp_regex_traits</span><span class="special">&lt;&gt;</span></code>, <code class="computeroutput"><span class="identifier">c_regex_traits</span><span class="special">&lt;&gt;</span></code> 和
<code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>。第一
个包装了一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>，第二个包装了全部
C locale，第三个则是在进行非字符数据搜索时使用的stub traits类型。所有traits模板都符合 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.traits_requirements">Regex
Traits 概念</a>。 </p>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.setting_the_default_regex_trait"></a>
<h3><a name="id4083564"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits.setting_the_default_regex_trait">Setting
the Default Regex Trait 设置缺省的Regex Trait</a> </h3>
<p> By default, xpressive uses <code class="computeroutput"><span class="identifier">cpp_regex_traits</span><span class="special">&lt;&gt;</span></code>
for all patterns. This causes all regex objects to use the global <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>.
If you compile with <code class="computeroutput"><span class="identifier">BOOST_XPRESSIVE_USE_C_TRAITS</span></code>
defined, then xpressive will use <code class="computeroutput"><span class="identifier">c_regex_traits</span><span class="special">&lt;&gt;</span></code>
by default.<br>
缺省地，xpressive对所有模式使用 <code class="computeroutput"><span class="identifier">cpp_regex_traits</span><span class="special">&lt;&gt;</span></code>。这使
得所有regex对象都使用全局的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>。如果你在编译时定义
了 <code class="computeroutput"><span class="identifier">BOOST_XPRESSIVE_USE_C_TRAITS</span></code>，
则xpressive将缺省使用 <code class="computeroutput"><span class="identifier">c_regex_traits</span><span class="special">&lt;&gt;</span></code>。 </p>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.using_custom_traits_with_dynamic_regexes"></a>
<h3><a name="id4083650"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits.using_custom_traits_with_dynamic_regexes">Using
Custom Traits with Dynamic Regexes 对动态Regex使用定制的Traits</a> </h3>
<p> To create a dynamic regex that uses a custom traits object,
you must use <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>.
The basic steps are shown in the following example:<br>
要创建一个使用定制的traits对象的动态regex，你必须使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>。
以下例子示范了基本的步骤： </p>
<pre class="programlisting"><span class="comment">// Declare a regex_compiler that uses the global C locale 声明一个使用全局 C locale 的 regex_compiler<br></span><span class="identifier">regex_compiler</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*,</span> <span class="identifier">c_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">crxcomp</span><span class="special">;</span><br><span class="identifier">cregex</span> <span class="identifier">crx</span> <span class="special">=</span> <span class="identifier">crxcomp</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"\\w+"</span> <span class="special">);</span><br><span class="comment">// Declare a regex_compiler that uses a custom std::locale 声明一个使用定制的 std::locale 的 regex_compiler<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">loc</span> <span class="special">=</span> <span class="comment">/* ... create a locale here ... */</span><span class="special">;</span><br><span class="identifier">regex_compiler</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*,</span> <span class="identifier">cpp_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">cpprxcomp</span><span class="special">(</span><span class="identifier">loc</span><span class="special">);</span><br><span class="identifier">cregex</span> <span class="identifier">cpprx</span> <span class="special">=</span> <span class="identifier">cpprxcomp</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"\\w+"</span> <span class="special">);</span>
</pre>
<p> The <code class="computeroutput"><span class="identifier">regex_compiler</span></code>
objects act as regex factories. Once they have been imbued with a
locale, every regex object they create will use that locale.<br>
<code class="computeroutput"><span class="identifier">regex_compiler</span></code>
对象就象一个regex工厂。一旦它们被注入一个locale，那么他们所创建的每一个regex对象都将使用那个locale。 </p>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.using_custom_traits_with_static_regexes"></a>
<h3><a name="id4083982"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits.using_custom_traits_with_static_regexes">Using
Custom Traits with Static Regexes 对静态Regex使用定制的Traits</a> </h3>
<p> If you want a particular static regex to use a different set
of traits, you can use the special <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
pattern modifier. For instance:<br>
如果你想某个特定的静态regex使用一个不同的traits集，你可以使用特定的 <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
模式修饰符。例如： </p>
<pre class="programlisting"><span class="comment">// Define a regex that uses the global C locale 定义一个使用全局 C locale 的 regex<br></span><span class="identifier">c_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">ctraits</span><span class="special">;</span><br><span class="identifier">sregex</span> <span class="identifier">crx</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">ctraits</span><span class="special">)(</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">);</span><br><span class="comment">// Define a regex that uses a customized std::locale 定义一个使用定制的 std::locale 的 regex<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">loc</span> <span class="special">=</span> <span class="comment">/* ... create a locale here ... 在此创建一个 locale */</span><span class="special">;</span><br><span class="identifier">cpp_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">cpptraits</span><span class="special">(</span><span class="identifier">loc</span><span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">cpprx1</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">cpptraits</span><span class="special">)(</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">);</span><br><span class="comment">// A shorthand for above 以上的缩写<br></span><span class="identifier">sregex</span> <span class="identifier">cpprx2</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">loc</span><span class="special">)(</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">);</span>
</pre>
<p> The <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
pattern modifier must wrap the entire pattern. It is an error to <code class="computeroutput"><span class="identifier">imbue</span></code>
only part of a static regex. For example:<br>
<code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
模式修饰符必须将整个模式包起来。只用 <code class="computeroutput"><span class="identifier">imbue</span></code>
包裹一个静态regex的部分是错误的。例如： </p>
<pre class="programlisting"><span class="comment">// ERROR! Cannot imbue() only part of a regex 错误！不能只 imbue() 部分 regex<br></span><span class="identifier">sregex</span> <span class="identifier">error</span> <span class="special">=</span> <span class="identifier">_w</span> <span class="special">&gt;&gt;</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">loc</span><span class="special">)(</span> <span class="identifier">_w</span> <span class="special">);</span>
</pre>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.searching_non_character_data_with__literal_null_regex_traits__literal_"></a>
<h3><a name="id4084395"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits.searching_non_character_data_with__literal_null_regex_traits__literal_">Searching
Non-Character Data With <code class="literal">null_regex_traits</code></a></h3>
<h3><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits.searching_non_character_data_with__literal_null_regex_traits__literal_">搜
索带&nbsp;<code class="literal">null_regex_traits</code>
的非字符数据<code class="literal"></code></a></h3>
<p> With xpressive static regexes, you are not limitted to
searching for patterns in character sequences. You can search for
patterns in raw bytes, integers, or anything that conforms to the <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.chart_requirements">Char
Concept</a>. The <code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>
makes it simple. It is a stub implementation of the <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.traits_requirements">Regex
Traits Concept</a>. It recognizes no character classes and does
no case-sensitive mappings.<br>
对于xpressive静态regexes，你并没有被限于只能对字符序列进行模式搜索。你可以对裸字节、整数或其它任意符合 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.chart_requirements">Char
概念</a> 的东西进行模式搜索。<code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>
令此非常简单。它是 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.traits_requirements">Regex
Traits 概念</a>的一个stub实现。它不识别任何字符类，也没有大小写映射。 </p>
<p> For example, with <code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>,
you can write a static regex to find a pattern in a sequence of
integers as follows:<br>
例如，使用 <code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>，你可
以写一个如下的静态regex来在一个整数序列中查找模式： </p>
<pre class="programlisting"><span class="comment">// some integral data to search 要查找的整型数据<br></span><span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">data</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">0</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="number">3</span><span class="special">,</span> <span class="number">4</span><span class="special">,</span> <span class="number">5</span><span class="special">,</span> <span class="number">6</span><span class="special">};</span><br><span class="comment">// create a null_regex_traits&lt;&gt; object for searching integers ...<br>// 创建一个 null_regex_traits&lt;&gt; 对象用于整数查找 ...<br></span><span class="identifier">null_regex_traits</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">nul</span><span class="special">;</span><br><span class="comment">// imbue a regex object with the null_regex_traits ...<br>// 把 null_regex_traits 注入 regex 对象 ...<br></span><span class="identifier">basic_regex</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="special">*&gt;</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">nul</span><span class="special">)(</span><span class="number">1</span> <span class="special">&gt;&gt;</span> <span class="special">+((</span><span class="identifier">set</span><span class="special">=</span> <span class="number">2</span><span class="special">,</span><span class="number">3</span><span class="special">)</span> <span class="special">|</span> <span class="number">4</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="number">5</span><span class="special">);</span><br><span class="identifier">match_results</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="special">*&gt;</span> <span class="identifier">what</span><span class="special">;</span><br><span class="comment">// search for the pattern in the array of integers ...<br>// 在整数数组中查找模式 ...<br></span><span class="identifier">regex_search</span><span class="special">(</span><span class="identifier">data</span><span class="special">,</span> <span class="identifier">data</span> <span class="special">+</span> <span class="number">7</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">rex</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">matched</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(*</span><span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">first</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(*</span><span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">second</span> <span class="special">==</span> <span class="number">6</span><span class="special">);</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.tips_n_tricks"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks" title="Tips 'N Tricks"> Tips 'N Tricks 提示与技巧</a>
</h3>
</div>
</div>
</div>
<p> Squeeze the most performance out of xpressive with these tips
and tricks.<br>
以下这些提示和技巧可以将xpressive的最大性能挤压出来。</p><p> 
<a name="boost_xpressive.user_s_guide.tips_n_tricks.compile_patterns_once_and_reuse_them"></a>
</p><h3><a name="id4085340"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.compile_patterns_once_and_reuse_them">Compile
Patterns Once And Reuse Them 对模式编译一次并重用它们</a> </h3>
<p> Compiling a regex (dynamic or static) is more expensive than
executing a match or search. If you have the option, prefer to compile
a pattern into a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
object once and reuse it rather than recreating it over and over.<br>
编译一个regex (动态或静态的)要比执行一次匹配或查找更为昂贵。如果你可以选择，就应该一次性将模式编译到一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
对象中，然后重用它，而不是反复创建它。</p>
<p>Since <code class="literal"><code class="computeroutput"><a class="link" title="Struct template basic_regex" href="../boost/xpressive/basic_regex.html">basic_regex&lt;&gt;</a></code></code> 
objects are not mutated by any of the regex algorithms, they are completely 
thread-safe once their initialization (and that of any grammars of which they 
are members) completes. The easiest way to reuse your patterns is to simply make 
your <code class="literal"><code class="computeroutput"><a class="link" title="Struct template basic_regex" href="../boost/xpressive/basic_regex.html">basic_regex&lt;&gt;</a></code></code> 
objects "static const".<br>由于 <code class="literal"><code class="computeroutput"><a class="link" title="Struct template basic_regex" href="../boost/xpressive/basic_regex.html">basic_regex&lt;&gt;</a></code></code> 对象不会被任何 regex 算法改写，所以一旦这些对象的初始化(以及它们所含的语法元素)完成，它们就是线程安全的。重用你的模式的最容易的方法是，令你的 <code class="literal"><code class="computeroutput"><a class="link" title="Struct template basic_regex" href="../boost/xpressive/basic_regex.html">basic_regex&lt;&gt;</a></code></code> 对象为"static const"。</p><a name="boost_xpressive.user_s_guide.tips_n_tricks.reuse__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__objects"></a>
<h3><a name="id4085047"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.reuse__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__objects">Reuse
<code class="literal"><code class="computeroutput"></code></code></a><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a>
Objects 重用&nbsp;<a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a>&amp;
nbsp;对象 </h3>
<p> The <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object caches dynamically allocated memory. For this reason, it is far
better to reuse the same <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object if you have to do many regex searches.<br>
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象缓存了动态分配的内存。为此，如果你要进行多个regex搜索，重用同一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象要好得多。 </p>
<p> Caveat: <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
objects are not thread-safe, so don't go wild reusing them across
threads.<br>
警告：<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象不是线程安全的，所以不要跨线程重用它们。 </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_take_a__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__object"></a>
<h3><a name="id4085145"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_take_a__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__object">Prefer
Algorithms That Take A <code class="literal"><code class="computeroutput"></code></code></a><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a>
Object&nbsp;</h3>
<h3>优先选用带 <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_take_a__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__object"><code class="literal"><code class="computeroutput"></code></code></a><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a>&amp;
nbsp;对象的算法 </h3>
<p> This is a corollary to the previous tip. If you are doing
multiple searches, you should prefer the regex algorithms that accept a
<code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object over the ones that don't, and you should reuse the same <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object each time. If you don't provide a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
object, a temporary one will be created for you and discarded when the
algorithm returns. Any memory cached in the object will be deallocated
and will have to be reallocated the next time.<br>
这是前一个提示的必然推论。如果你要进行多次查找，你应该优先选择使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象的regex算法，而且应该重用同一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象。如果你不提供一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
对象，则会为你创建一个临时的对象并在算法返回时丢弃。所有缓存在该对象中的内存将被释放，在下一次使用时将不得不重新分配。 </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_accept_iterator_ranges_over_null_terminated_strings"></a>
<h3><a name="id4085241"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_accept_iterator_ranges_over_null_terminated_strings">Prefer
Algorithms That Accept Iterator Ranges Over Null-Terminated
Strings&nbsp;</a></h3>
<h3><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_accept_iterator_ranges_over_null_terminated_strings">处
理空字符结束的字符串时，优先选用接受迭代器区间的算法</a> </h3>
<p> xpressive provides overloads of the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
and <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
algorithms that operate on C-style null-terminated strings. You should
prefer the overloads that take iterator ranges. When you pass a
null-terminated string to a regex algorithm, the end iterator is
calculated immediately by calling <code class="computeroutput"><span class="identifier">strlen</span></code>. If you
already know the length of the string, you can avoid this overhead by
calling the regex algorithms with a <code class="computeroutput"><span class="special">[</span><span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">)</span></code> pair.<br>
xpressive为 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
和 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
算法提供了处理C-风格的空字符结束字符串的多个重载。你应该优先选用其中接受迭代器区间的那些重载。如果你传递一个空字符结束的字符串给一个regex
算法，会即时通过调用 <code class="computeroutput"><span class="identifier">strlen</span></code>
来计算出结尾迭代器。如果你已经知道该字符串的长度，就可以通过以一个 <code class="computeroutput"><span class="special">[</span><span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">)</span></code>
对来调用这个regex算法，避免这种开销。</p><p> 
<a name="boost_xpressive.user_s_guide.tips_n_tricks.use_static_regexes"></a>
</p><h3><a name="id4085012"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.use_static_regexes">Use
Static Regexes 使用静态Regexes</a> </h3>
<p> On average, static regexes execute about 10 to 15% faster
than their dynamic counterparts. It's worth familiarizing yourself with
the static regex dialect.<br>
平均来说，静态regex执行起来比同等的动态regex快10%到15%。熟悉静态regex的写法非常值得。 </p><a name="boost_xpressive.user_s_guide.tips_n_tricks.understand__literal_syntax_option_type__optimize__literal_"></a>
<h3> <a name="id4085387"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.understand__literal_syntax_option_type__optimize__literal_">Understand
<code class="literal">syntax_option_type::optimize</code>&nbsp;</a></h3><h3><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.understand__literal_syntax_option_type__optimize__literal_">理解
<code class="literal">syntax_option_type::optimize</code>
</a>
</h3>
<p> The <code class="computeroutput"><span class="identifier">optimize</span></code> flag
tells the regex compiler to spend some extra time analyzing the
pattern. It can cause some patterns to execute faster, but it increases
the time to compile the pattern, and often increases the amount of
memory consumed by the pattern. If you plan to reuse your pattern, <code class="computeroutput"><span class="identifier">optimize</span></code>
is usually a win. If you will only use the pattern once, don't use <code class="computeroutput"><span class="identifier">optimize</span></code>.<br>这个 <code class="computeroutput"><span class="identifier">optimize</span></code> 标志告知regex编译器，使用更多的时间去分析这个模式。这样可以使得某些模式执行得更快一些，不过它会增加模式编译的时间，而且通常也会增加该模式所占用的内存。如果你计划重用你的模式，通常使用 <code class="computeroutput"><span class="identifier">optimize</span></code>
会更好。如果你只使用该模式一次，就不要使用 <code class="computeroutput"><span class="identifier">optimize</span></code>.
</p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.common_pitfalls"></a>
<h2><a name="id4085394"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.common_pitfalls">Common
Pitfalls 常见错误</a> </h2>
<p> Keep the following tips in mind to avoid stepping in potholes
with xpressive.<br>留意以下提示，以避免陷入xpressive的泥沼。 </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.create_grammars_on_a_single_thread"></a>
<h3><a name="id4085478"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.create_grammars_on_a_single_thread">Create
Grammars On A Single Thread 在单个线程中创建语法</a> </h3>
<p> With static regexes, you can create grammars by nesting
regexes inside one another. When compiling the outer regex, both the
outer and inner regex objects, and all the regex objects to which they
refer either directly or indirectly, are modified. For this reason,
it's dangerous for global regex objects to participate in grammars.
It's best to build regex grammars from a single thread. Once built, the
resulting regex grammar can be executed from multiple threads without
problems.<br>对
于静态regex，你可以通过把regex嵌入另一个regex中来创建语法。在编译外层的regex时，外层和内层的regex对象，以及所有它们直接
或间接引用到的regex对象，都会被修改。因此，这对于参与到语法中的全局regex对象而言是很危险的。最好是从单个线程中构建regex语法。一旦
构建完成，所得到的regex语法就可以在多线程下执行，没有问题。 </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.beware_nested_quantifiers"></a>
<h3><a name="id4085504"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks.beware_nested_quantifiers">Beware
Nested Quantifiers 小心嵌套的数量词</a> </h3>
<p> This is a pitfall common to many regular expression engines.
Some patterns can cause exponentially bad performance. Often these
patterns involve one quantified term nested withing another quantifier,
such as <code class="computeroutput"><span class="string">"(a*)*"</span></code>, although
in many cases, the problem is harder to spot. Beware of patterns that
have nested quantifiers.<br>这是一个很多正则表达式都会犯的错误。有些模式会引起指数级的低性能。通常，这些模式含有一个嵌套在另一个数量词中的数量词，如 <code class="computeroutput"><span class="string">"(a*)*"</span></code>，在多数情况下，这个问题很难被指出。要当心那些带有嵌套数量词的模式。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.concepts"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts" title="Concepts">Concepts 概念</a>
</h3>
</div>
</div>
</div>
<a name="boost_xpressive.user_s_guide.concepts.chart_requirements"></a>
<h3><a name="id4085562"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.chart_requirements">CharT
requirements &nbsp; CharT的要求</a> </h3>
<p> If type <code class="computeroutput"><span class="identifier">BidiIterT</span></code> is
used as a template argument to <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>,
then <code class="computeroutput"><span class="identifier">CharT</span></code> is <code class="computeroutput"><span class="identifier">iterator_traits</span><span class="special">&lt;</span><span class="identifier">BidiIterT</span><span class="special">&gt;::</span><span class="identifier">value_type</span></code>.
Type <code class="computeroutput"><span class="identifier">CharT</span></code> must have
a trivial default constructor, copy constructor, assignment operator,
and destructor. In addition the following requirements must be met for
objects; <code class="computeroutput"><span class="identifier">c</span></code> of type <code class="computeroutput"><span class="identifier">CharT</span></code>,
<code class="computeroutput"><span class="identifier">c1</span></code>
and <code class="computeroutput"><span class="identifier">c2</span></code> of type <code class="computeroutput"><span class="identifier">CharT</span>
<span class="keyword">const</span></code>, and
<code class="computeroutput"><span class="identifier">i</span></code>
of type <code class="computeroutput"><span class="keyword">int</span></code>:<br>如果类型 <code class="computeroutput"><span class="identifier">BidiIterT</span></code> 被用作 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code> 的一个模板参数，则 <code class="computeroutput"><span class="identifier">CharT</span></code> 为 <code class="computeroutput"><span class="identifier">iterator_traits</span><span class="special">&lt;</span><span class="identifier">BidiIterT</span><span class="special">&gt;::</span><span class="identifier">value_type</span></code>。类型 <code class="computeroutput"><span class="identifier">CharT</span></code> 必须带有一个平凡的缺省构造函数、复制构造函数、赋值操作符和析构函数。另外，还必须符合以下要求；其中 <code class="computeroutput"><span class="identifier">c</span></code> 的类型为 <code class="computeroutput"><span class="identifier">CharT</span></code>,
<code class="computeroutput"><span class="identifier">c1</span></code> 和 <code class="computeroutput"><span class="identifier">c2</span></code> 的类型为 <code class="computeroutput"><span class="identifier">CharT</span>
<span class="keyword">const</span></code>, 而
<code class="computeroutput"><span class="identifier">i</span></code>
的类型为 <code class="computeroutput"><span class="keyword">int</span></code>: </p>
<div class="table">
<a name="id4085719"></a>
<p class="title"><b>Table&nbsp;27.14.&nbsp;CharT
Requirements<br>表&nbsp;27.14.&nbsp;CharT
的要求</b></p>
<div class="table-contents">
<table class="table" summary="CharT Requirements">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> <span class="bold"><strong>Expression 表达式</strong></span>
</p>
</th>
<th>
<p> <span class="bold"><strong>Return type 返回类型</strong></span>
</p>
</th>
<th>
<p> <span class="bold"><strong>Assertion
/ Note / Pre- / Post-condition 断言/说明/先验/后验条件</strong></span> </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span> <span class="identifier">c</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> </p>
</td>
<td>
<p> Default constructor (must be trivial).&nbsp;<br>缺省构造函数(必须是平凡的)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span> <span class="identifier">c</span><span class="special">(</span><span class="identifier">c1</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> </p>
</td>
<td>
<p> Copy constructor (must be trivial).<br>复制构造函数(必须是平凡的)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">c1</span> <span class="special">=</span>
<span class="identifier">c2</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> </p>
</td>
<td>
<p> Assignment operator (must be trivial).<br>赋值操作符(必须是平凡的)。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">c1</span> <span class="special">==</span>
<span class="identifier">c2</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
has the same value as <code class="computeroutput"><span class="identifier">c2</span></code>.<br><code class="computeroutput"><span class="keyword">true</span></code> 如果 <code class="computeroutput"><span class="identifier">c1</span></code>
的值与 <code class="computeroutput"><span class="identifier">c2</span></code> 相同。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">c1</span> <span class="special">!=</span>
<span class="identifier">c2</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
and <code class="computeroutput"><span class="identifier">c2</span></code> are not
equal.<br><code class="computeroutput"><span class="keyword">true</span></code> 如果 <code class="computeroutput"><span class="identifier">c1</span></code>
的值与 <code class="computeroutput"><span class="identifier">c2</span></code> 不同。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">c1</span> <span class="special">&lt;</span>
<span class="identifier">c2</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">true</span></code> if the value
of <code class="computeroutput"><span class="identifier">c1</span></code> is less than
<code class="computeroutput"><span class="identifier">c2</span></code>.<br><code class="computeroutput"><span class="keyword">true</span></code> 如果 <code class="computeroutput"><span class="identifier">c1</span></code> 的值小于 <code class="computeroutput"><span class="identifier">c2</span></code>。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">c1</span> <span class="special">&gt;</span>
<span class="identifier">c2</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">true</span></code> if the value
of <code class="computeroutput"><span class="identifier">c1</span></code> is greater
than <code class="computeroutput"><span class="identifier">c2</span></code>.<br><code class="computeroutput"><span class="keyword">true</span></code> 如果 <code class="computeroutput"><span class="identifier">c1</span></code>
的值大于 <code class="computeroutput"><span class="identifier">c2</span></code>。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">c1</span> <span class="special">&lt;=</span>
<span class="identifier">c2</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
is less than or equal to <code class="computeroutput"><span class="identifier">c2</span></code>.<br><code class="computeroutput"><span class="keyword">true</span></code> 如果 <code class="computeroutput"><span class="identifier">c1</span></code>
的值小于等于 <code class="computeroutput"><span class="identifier">c2</span></code>。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">c1</span> <span class="special">&gt;=</span>
<span class="identifier">c2</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
is greater than or equal to <code class="computeroutput"><span class="identifier">c2</span></code>.<br><code class="computeroutput"><span class="keyword">true</span></code> 如果 <code class="computeroutput"><span class="identifier">c1</span></code>
的值大于等于 <code class="computeroutput"><span class="identifier">c2</span></code>。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">intmax_t</span> <span class="identifier">i</span> <span class="special">=</span>
<span class="identifier">c1</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">int</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> must be
convertible to an integral type.<br><code class="computeroutput"><span class="identifier">CharT</span></code> 必须可以转换为一个整数类型。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span> <span class="identifier">c</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> must be
constructable from an integral type.<br><code class="computeroutput"><span class="identifier">CharT</span></code> 必须可以从一个整数类型构造。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<a name="boost_xpressive.user_s_guide.concepts.traits_requirements"></a>
<h3><a name="id4086518"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.traits_requirements">Traits
Requirements &nbsp; Traits的要求</a> </h3>
<p> In the following table <code class="computeroutput"><span class="identifier">X</span></code> denotes a
traits class defining types and functions for the character container
type <code class="computeroutput"><span class="identifier">CharT</span></code>; <code class="computeroutput"><span class="identifier">u</span></code>
is an object of type <code class="computeroutput"><span class="identifier">X</span></code>; <code class="computeroutput"><span class="identifier">v</span></code>
is an object of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">X</span></code>; <code class="computeroutput"><span class="identifier">p</span></code>
is a value of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span><span class="special">*</span></code>;
<code class="computeroutput"><span class="identifier">I1</span></code>
and <code class="computeroutput"><span class="identifier">I2</span></code> are <code class="computeroutput"><span class="identifier">Input</span>
<span class="identifier">Iterators</span></code>;
<code class="computeroutput"><span class="identifier">c</span></code>
is a value of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span></code>; <code class="computeroutput"><span class="identifier">s</span></code>
is an object of type <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code>; <code class="computeroutput"><span class="identifier">cs</span></code>
is an object of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code>; <code class="computeroutput"><span class="identifier">b</span></code>
is a value of type <code class="computeroutput"><span class="keyword">bool</span></code>; <code class="computeroutput"><span class="identifier">i</span></code>
is a value of type <code class="computeroutput"><span class="keyword">int</span></code>; <code class="computeroutput"><span class="identifier">F1</span></code>
and <code class="computeroutput"><span class="identifier">F2</span></code> are values
of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span><span class="special">*</span></code>;
<code class="computeroutput"><span class="identifier">loc</span></code>
is an object of type <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code>;
and <code class="computeroutput"><span class="identifier">ch</span></code> is an object
of <code class="computeroutput"><span class="keyword">const</span>
<span class="keyword">char</span></code>.<br>在下表中，<code class="computeroutput"><span class="identifier">X</span></code> 表示一个traits类，为字符容器类型 <code class="computeroutput"><span class="identifier">CharT</span></code> 定义了相关类型和函数；<code class="computeroutput"><span class="identifier">u</span></code>
是一个类型为 <code class="computeroutput"><span class="identifier">X</span></code> 的对象；<code class="computeroutput"><span class="identifier">v</span></code>
是一个类型为 <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">X</span></code> 的对象；<code class="computeroutput"><span class="identifier">p</span></code>
是类型为 <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span><span class="special">*</span></code> 的值；<code class="computeroutput"><span class="identifier">I1</span></code> 和 <code class="computeroutput"><span class="identifier">I2</span></code> 为 <code class="computeroutput"><span class="identifier">Input</span>
<span class="identifier">Iterators</span></code>；<code class="computeroutput"><span class="identifier">c</span></code>
是类型为 <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span></code> 的值；<code class="computeroutput"><span class="identifier">s</span></code>
是一个类型为 <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> 的对象；<code class="computeroutput"><span class="identifier">cs</span></code>
是一个类型为 <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> 的对象；<code class="computeroutput"><span class="identifier">b</span></code>
是类型为 <code class="computeroutput"><span class="keyword">bool</span></code> 的值；<code class="computeroutput"><span class="identifier">i</span></code>
是类型为 <code class="computeroutput"><span class="keyword">int</span></code> 的值；<code class="computeroutput"><span class="identifier">F1</span></code> 和 <code class="computeroutput"><span class="identifier">F2</span></code> 是类型为 <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span><span class="special">*</span></code> 的值；
<code class="computeroutput"><span class="identifier">loc</span></code>
是一个类型为 <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code> 的对象；<code class="computeroutput"><span class="identifier">ch</span></code> 是一个类型为 <code class="computeroutput"><span class="keyword">const</span>
<span class="keyword">char</span></code> 的对象。 </p>
<div class="table">
<a name="id4086864"></a>
<p class="title"><b>Table&nbsp;27.15.&nbsp;Traits
Requirements<br>表&nbsp;27.15.&nbsp;Traits
的要求</b></p>
<div class="table-contents">
<table class="table" summary="Traits Requirements">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> <span class="bold"><strong>Expression 表达式</strong></span>
</p>
</th>
<th>
<p> <span class="bold"><strong>Return type 返回类型</strong></span>
</p>
</th>
<th>
<p> <span class="bold"><strong>Assertion
/ Note 断言/说明<br>
Pre / Post condition 先验/后验条件</strong></span> </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_type</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> </p>
</td>
<td>
<p> The character container type used in the implementation
of class template <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>.<br>在类模板 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code> 的实现中所使用的字符容器类型。
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span></code>
or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span></code>
</p>
</td>
<td>
<p> </p>
<p> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code> </p>
</td>
<td>
<p> <span class="emphasis"><em>Implementation
defined</em></span> </p>
</td>
<td>
<p> A copy constructible type that represents the locale
used by the traits class.<br>一个表示该traits类所使用的locale的可复制构造类型。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_class_type</span></code>
</p>
</td>
<td>
<p> <span class="emphasis"><em>Implementation
defined</em></span> </p>
</td>
<td>
<p> A bitmask type representing a particular character
classification. Multiple values of this type can be bitwise-or'ed
together to obtain a new valid value.<br>一个表示特定字符分类的掩码类型。可以对该类型的多个值进行位或操作以得到一个新的有效值。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">hash</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">char</span></code> </p>
</td>
<td>
<p> Yields a value between <code class="computeroutput"><span class="number">0</span></code> and <code class="computeroutput"><span class="identifier">UCHAR_MAX</span></code>
inclusive.<br>生成一个在 <code class="computeroutput"><span class="number">0</span></code> 到 <code class="computeroutput"><span class="identifier">UCHAR_MAX</span></code>(含)之间的值。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">widen</span><span class="special">(</span><span class="identifier">ch</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">CharT</span></code> </p>
</td>
<td>
<p> Widens the specified <code class="computeroutput"><span class="keyword">char</span></code> and returns
the resulting <code class="computeroutput"><span class="identifier">CharT</span></code>.<br>对指定的 <code class="computeroutput"><span class="keyword">char</span></code> 加宽并返回得到的 <code class="computeroutput"><span class="identifier">CharT</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">in_range</span><span class="special">(</span><span class="identifier">r1</span><span class="special">,</span> <span class="identifier">r2</span><span class="special">,</span> <span class="identifier">c</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> For any characters <code class="computeroutput"><span class="identifier">r1</span></code> and <code class="computeroutput"><span class="identifier">r2</span></code>,
returns <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">r1</span>
<span class="special">&lt;=</span> <span class="identifier">c</span> <span class="special">&amp;&amp;</span>
<span class="identifier">c</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>. Requires
that <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span>
<span class="identifier">r2</span></code>.<br>对于任意字符 <code class="computeroutput"><span class="identifier">r1</span></code> 和 <code class="computeroutput"><span class="identifier">r2</span></code>，返回 <code class="computeroutput"><span class="keyword">true</span></code> 如果 <code class="computeroutput"><span class="identifier">r1</span>
<span class="special">&lt;=</span> <span class="identifier">c</span> <span class="special">&amp;&amp;</span>
<span class="identifier">c</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>。要求 <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span>
<span class="identifier">r2</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">in_range_nocase</span><span class="special">(</span><span class="identifier">r1</span><span class="special">,</span> <span class="identifier">r2</span><span class="special">,</span> <span class="identifier">c</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> For characters <code class="computeroutput"><span class="identifier">r1</span></code> and <code class="computeroutput"><span class="identifier">r2</span></code>,
returns <code class="computeroutput"><span class="keyword">true</span></code> if there is
some character <code class="computeroutput"><span class="identifier">d</span></code> for which <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">d</span><span class="special">)</span> <span class="special">==</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">r1</span>
<span class="special">&lt;=</span> <span class="identifier">d</span> <span class="special">&amp;&amp;</span>
<span class="identifier">d</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>. Requires
that <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span>
<span class="identifier">r2</span></code>.<br>对于任意字符 <code class="computeroutput"><span class="identifier">r1</span></code> 和 <code class="computeroutput"><span class="identifier">r2</span></code>，返回 <code class="computeroutput"><span class="keyword">true</span></code> 如果存在某个字符 <code class="computeroutput"><span class="identifier">d</span></code> 满足 <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">d</span><span class="special">)</span> <span class="special">==</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code> 且 <code class="computeroutput"><span class="identifier">r1</span>
<span class="special">&lt;=</span> <span class="identifier">d</span> <span class="special">&amp;&amp;</span>
<span class="identifier">d</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>。要求 <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span>
<span class="identifier">r2</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_type</span></code> </p>
</td>
<td>
<p> Returns a character such that for any character <code class="computeroutput"><span class="identifier">d</span></code>
that is to be considered equivalent to <code class="computeroutput"><span class="identifier">c</span></code> then <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span> <span class="special">==</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">d</span><span class="special">)</span></code>.<br>返回一个字符，满足对于任意被认为等同于 <code class="computeroutput"><span class="identifier">c</span></code> 的字符 <code class="computeroutput"><span class="identifier">d</span></code>
有 <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span> <span class="special">==</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">d</span><span class="special">)</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_type</span></code> </p>
</td>
<td>
<p> For all characters <code class="computeroutput"><span class="identifier">C</span></code> that are to
be considered equivalent to <code class="computeroutput"><span class="identifier">c</span></code> when
comparisons are to be performed without regard to case, then <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span> <span class="special">==</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">C</span><span class="special">)</span></code>.<br>对于所有被认为等同于 <code class="computeroutput"><span class="identifier">c</span></code> 的字符 <code class="computeroutput"><span class="identifier">C</span></code>，如果比较操作不考虑大小写，则 <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span> <span class="special">==</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">C</span><span class="special">)</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </p>
</td>
<td>
<p> Returns a sort key for the character sequence
designated by the iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> such that if the
character sequence <code class="computeroutput"><span class="special">[</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span></code> sorts before the
character sequence <code class="computeroutput"><span class="special">[</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code> then <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span> <span class="special">&lt;</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code>.<br>对于由迭代器区间 <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> 所指定的字符序列，返回一个分类键，满足如果字符序列 <code class="computeroutput"><span class="special">[</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span></code> 排在字符序列 <code class="computeroutput"><span class="special">[</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code> 之前，则 <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span> <span class="special">&lt;</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </p>
</td>
<td>
<p> Returns a sort key for the character sequence
designated by the iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> such that if the
character sequence <code class="computeroutput"><span class="special">[</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span></code> sorts before the
character sequence <code class="computeroutput"><span class="special">[</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code> when character
case is not considered then <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span> <span class="special">&lt;</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code>.<br>对于由迭代器区间 <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> 所指定的字符序列，返回一个分类键，满足如果字符序列 <code class="computeroutput"><span class="special">[</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span></code> 在不考虑大小写时，排在字符序列 <code class="computeroutput"><span class="special">[</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code> 之前，则 <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span> <span class="special">&lt;</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">lookup_classname</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_class_type</span></code>
</p>
</td>
<td>
<p> Converts the character sequence designated by the
iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">)</span></code> into a bitmask
type that can subsequently be passed to <code class="computeroutput"><span class="identifier">isctype</span></code>. Values
returned from <code class="computeroutput"><span class="identifier">lookup_classname</span></code>
can be safely bitwise or'ed together. Returns <code class="computeroutput"><span class="number">0</span></code>
if the character sequence is not the name of a character class
recognized by <code class="computeroutput"><span class="identifier">X</span></code>. The value
returned shall be independent of the case of the characters in the
sequence.<br>将由迭代器区间 <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">)</span></code> 所指定的字符序列转换为一个可以传递给 <code class="computeroutput"><span class="identifier">isctype</span></code> 的掩码类型。由 <code class="computeroutput"><span class="identifier">lookup_classname</span></code>
返回值可以安全地进行位或操作。如果该字符序列不是由 <code class="computeroutput"><span class="identifier">X</span></code> 所承认的字符类的名字，则返回 <code class="computeroutput"><span class="number">0</span></code>。返回值应该与序列中的字符大小写无关。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">lookup_collatename</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </p>
</td>
<td>
<p> Returns a sequence of characters that represents the
collating element consisting of the character sequence designated by
the iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code>. Returns an
empty string if the character sequence is not a valid collating
element.<br>返回一个字符序列，表示包含由迭代器区间 <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> 所指定的字符序列的校对元素。如果该字符序列不是一个有效的校对元素，则返回一个空串。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">isctype</span><span class="special">(</span><span class="identifier">c</span><span class="special">,</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">lookup_classname</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">))</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">bool</span></code> </p>
</td>
<td>
<p> Returns <code class="computeroutput"><span class="keyword">true</span></code> if character <code class="computeroutput"><span class="identifier">c</span></code>
is a member of the character class designated by the iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span>
<span class="identifier">F2</span><span class="special">)</span></code>, <code class="computeroutput"><span class="keyword">false</span></code>
otherwise.<br>如果字符 <code class="computeroutput"><span class="identifier">c</span></code> 是由迭代器区间 <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> 所指定的字符类的成员，则返回 <code class="computeroutput"><span class="keyword">true</span></code><code class="computeroutput"><span class="identifier"></span></code>，否则返回 <code class="computeroutput"><span class="keyword">false</span></code>。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">value</span><span class="special">(</span><span class="identifier">c</span><span class="special">,</span>
<span class="identifier">i</span><span class="special">)</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="keyword">int</span></code> </p>
</td>
<td>
<p> Returns the value represented by the digit <code class="computeroutput"><span class="identifier">c</span></code>
in base <code class="computeroutput"><span class="identifier">i</span></code> if the
character <code class="computeroutput"><span class="identifier">c</span></code> is a valid
digit in base <code class="computeroutput"><span class="identifier">i</span></code>; otherwise
returns <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>.<br>
[Note: the value of <code class="computeroutput"><span class="identifier">i</span></code> will only be <code class="computeroutput"><span class="number">8</span></code>,
<code class="computeroutput"><span class="number">10</span></code>,
or <code class="computeroutput"><span class="number">16</span></code>.
-end note]<br>如果字符 <code class="computeroutput"><span class="identifier">c</span></code> 是 <code class="computeroutput"><span class="identifier">i</span></code> 进制的有效数字，返回由数字 <code class="computeroutput"><span class="identifier">c</span></code>
在 <code class="computeroutput"><span class="identifier">i</span></code> 进制中所表示的数值；否则返回 <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>.<br>
[注：<code class="computeroutput"><span class="identifier">i</span></code> 的值只能为 <code class="computeroutput"><span class="number">8</span></code>,
<code class="computeroutput"><span class="number">10</span></code>, 或 <code class="computeroutput"><span class="number">16</span></code>.
-注完] </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">u</span><span class="special">.</span><span class="identifier">imbue</span><span class="special">(</span><span class="identifier">loc</span><span class="special">)</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code> </p>
</td>
<td>
<p> Imbues <code class="computeroutput"><span class="identifier">u</span></code> with the
locale <code class="computeroutput"><span class="identifier">loc</span></code>, returns
the previous locale used by <code class="computeroutput"><span class="identifier">u</span></code>.<br>将
locale <code class="computeroutput"><span class="identifier">loc</span></code> 注入 <code class="computeroutput"><span class="identifier">u</span></code>，返回 <code class="computeroutput"><span class="identifier">u</span></code> 原来所使用的locale。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">getloc</span><span class="special">()</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code> </p>
</td>
<td>
<p> Returns the current locale used by <code class="computeroutput"><span class="identifier">v</span></code>.<br>返回 <code class="computeroutput"><span class="identifier">v</span></code> 当前所使用的locale。
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<a name="boost_xpressive.user_s_guide.concepts.acknowledgements"></a>
<h3><a name="id4089283"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.acknowledgements">Acknowledgements 鸣谢</a>
</h3>
<p> This section is adapted from the equivalent page in the <a href="../../../libs/regex" target="_top">Boost.Regex</a>
documentation and from the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm" target="_top">proposal</a> to add regular expressions
to the Standard Library.<br>本节改编自 <a href="../../../libs/regex" target="_top">Boost.Regex</a>
文档中的相同部分以及关于为标准库增加正则表达式的 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm" target="_top">建议书</a>。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_xpressive.user_s_guide.examples"></a><a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">Examples 示例</a>
</h3>
</div>
</div>
</div>

<p> Below you can find six complete sample programs.<br>以下你将看到六个完整的示例程序。 </p>
<a name="boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex"></a>&nbsp;
<h5><a name="id4089351"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex">See
if a whole string matches a regex 检查整个字符串是否匹配一个regex</a> </h5>
<p> This is the example from the Introduction. It is reproduced
here for your convenience.<br>这是来自于"简介"一节中的示例。为便于查看，在此重复。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">hello</span><span class="special">(</span> <span class="string">"hello world!"</span> <span class="special">);</span><br><span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\w+) (\\w+)!"</span> <span class="special">);</span><br><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">hello</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">rex</span> <span class="special">)</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// whole match 整个匹配 <br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// first capture 第一次捕获<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// second capture 第二次捕获<br></span> <span class="special">}</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program outputs the following:<br>程序输出如下： </p>
<pre class="programlisting">hello world!<br>hello<br>world<br></pre>
<p> <br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top 回到顶部</a> </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex"></a>
<h5><a name="id4107363"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">See
if a string contains a sub-string that matches a regex 检查一个字符串是否包含匹配某个regex的子串</a> </h5>
<p> Notice in this example how we use custom <code class="computeroutput"><span class="identifier">mark_tag</span></code>s
to make the pattern more readable. We can use the <code class="computeroutput"><span class="identifier">mark_tag</span></code>s
later to index into the <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>.<br>请留意在这个例子中，我们是如何使用定制的 <code class="computeroutput"><span class="identifier">mark_tag</span></code>s
来使得匹配的模式更可读。我们可以在稍后使用 <code class="computeroutput"><span class="identifier">mark_tag</span></code>s
来对 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code> 进行索引访问。
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span><span class="identifier">str</span> <span class="special">=</span> <span class="string">"I was born on 5/30/1973 at 7am."</span><span class="special">;</span><br><span class="comment">// define some custom mark_tags with names more meaningful than s1, s2, etc.<br>// 以名字定义一些定制的 mark_tags，比 s1, s2 等更有意义。<br></span> <span class="identifier">mark_tag</span> <span class="identifier">day</span><span class="special">(</span><span class="number">1</span><span class="special">),</span> <span class="identifier">month</span><span class="special">(</span><span class="number">2</span><span class="special">),</span> <span class="identifier">year</span><span class="special">(</span><span class="number">3</span><span class="special">),</span> <span class="identifier">delim</span><span class="special">(</span><span class="number">4</span><span class="special">);</span><br><span class="comment">// this regex finds a date 该regex查找一个日期<br></span> <span class="identifier">cregex</span> <span class="identifier">date</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">month</span><span class="special">=</span> <span class="identifier">repeat</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">_d</span><span class="special">))</span> <span class="comment">// find the month ... 查找月份...<br></span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">delim</span><span class="special">=</span> <span class="special">(</span><span class="identifier">set</span><span class="special">=</span> <span class="char">'/'</span><span class="special">,</span><span class="char">'-'</span><span class="special">))</span> <span class="comment">// followed by a delimiter ... 后跟一个分隔符...<br></span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">day</span><span class="special">=</span> <span class="identifier">repeat</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">_d</span><span class="special">))</span> <span class="special">&gt;&gt;</span> <span class="identifier">delim</span> <span class="comment">// and a day followed by the same delimiter ... 和一个日期再跟一个分隔符...<br></span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">year</span><span class="special">=</span> <span class="identifier">repeat</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">));</span> <span class="comment">// and the year. 和年份。<br></span><br><span class="identifier">cmatch</span> <span class="identifier">what</span><span class="special">;</span><br><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_search</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">date</span> <span class="special">)</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// whole match 全匹配<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">day</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the day 日期<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">month</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the month 月份<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">year</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the year 年份<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">delim</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the delimiter 分隔符<br></span> <span class="special">}</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program outputs the following:<br>程序输出如下： </p>
<pre class="programlisting">5/30/1973<br>30<br>5<br>1973<br>/<br></pre>
<p> <br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top 回到顶部</a> </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex"></a>
<h5><a name="id4108374"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">Replace
all sub-strings that match a regex 替换匹配某个regex的所有子串</a> </h5>
<p> The following program finds dates in a string and marks them
up with pseudo-HTML.<br>以下程序在一个字符串中查找日期并用伪-HTML标记它们。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"I was born on 5/30/1973 at 7am."</span> <span class="special">);</span><br><span class="comment">// essentially the same regex as in the previous example, but using a dynamic regex<br>// 基本上与上一个例子中的regex相同，但用的是动态regex<br></span> <span class="identifier">sregex</span> <span class="identifier">date</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\d{1,2})([/-])(\\d{1,2})\\2((?:\\d{2}){1,2})"</span> <span class="special">);</span><br><span class="comment">// As in Perl, $&amp; is a reference to the sub-string that matched the regex<br>// 和在Perl中一样，$&amp; 是指向匹配该regex的子串的引用<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">format</span><span class="special">(</span> <span class="string">"&lt;date&gt;$&amp;&lt;/date&gt;"</span> <span class="special">);</span><br><span class="identifier">str</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">date</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program outputs the following:<br>程序输出如下： </p>
<pre class="programlisting">I was born on &lt;date&gt;5/30/1973&lt;/date&gt; at 7am.<br></pre>
<p> <br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top 回到顶部</a> </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.find_all_the_sub_strings_that_match_a_regex_and_step_through_them_one_at_a_time"></a>
<h5><a name="id4108796"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.find_all_the_sub_strings_that_match_a_regex_and_step_through_them_one_at_a_time">Find
all the sub-strings that match a regex and step through them one at a
time 查找匹配某个regex的所有子串并每次一个地分步处理它们</a> </h5>
<p> The following program finds the words in a wide-character
string. It uses <code class="computeroutput"><span class="identifier">wsregex_iterator</span></code>.
Notice that dereferencing a <code class="computeroutput"><span class="identifier">wsregex_iterator</span></code>
yields a <code class="computeroutput"><span class="identifier">wsmatch</span></code> object.<br>以下程序在一个宽字符串中查找单词。它使用 <code class="computeroutput"><span class="identifier">wsregex_iterator</span></code>。注意，对 <code class="computeroutput"><span class="identifier">wsregex_iterator</span></code>
的解引用将产生一个 <code class="computeroutput"><span class="identifier">wsmatch</span></code> 对象。
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span> <span class="identifier">str</span><span class="special">(</span> <span class="identifier">L</span><span class="string">"This is his face."</span> <span class="special">);</span><br><span class="comment">// find a whole word 查找一个完整的单词<br></span> <span class="identifier">wsregex</span> <span class="identifier">token</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">alnum</span><span class="special">;</span><br><span class="identifier">wsregex_iterator</span> <span class="identifier">cur</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">token</span> <span class="special">);</span><br><span class="identifier">wsregex_iterator</span> <span class="identifier">end</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span> <span class="special">;</span> <span class="identifier">cur</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">cur</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">wsmatch</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">cur</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">wcout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">L</span><span class="char">'\n'</span><span class="special">;</span><br><span class="special">}</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program outputs the following:<br>程序输出如下： </p>
<pre class="programlisting">This<br>is<br>his<br>face<br></pre>
<p> <br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top 回到顶部</a> </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.split_a_string_into_tokens_that_each_match_a_regex"></a>
<h5><a name="id4109334"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.split_a_string_into_tokens_that_each_match_a_regex">Split
a string into tokens that each match a regex 将字符串分拆为匹配某个regex的记号</a> </h5>
<p> The following program finds race times in a string and
displays first the minutes and then the seconds. It uses <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>.<br>以下程序在字符串中查找比赛时间，并且先显示分钟数再显示秒数。它使用 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>.
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"Eric: 4:40, Karl: 3:35, Francesca: 2:32"</span> <span class="special">);</span><br><span class="comment">// find a race time 查找比赛时间<br></span> <span class="identifier">sregex</span> <span class="identifier">time</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\d):(\\d\\d)"</span> <span class="special">);</span><br><span class="comment">// for each match, the token iterator should first take the value of<br></span> <span class="comment">// the first marked sub-expression followed by the value of the second<br></span> <span class="comment">// marked sub-expression<br>// 对于每个匹配，记号迭代器首先取出第一个被标记的子表达式的值，然后是第二个子表达式的值<br></span> <span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">subs</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span> <span class="special">};</span><br><span class="identifier">sregex_token_iterator</span> <span class="identifier">cur</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">time</span><span class="special">,</span> <span class="identifier">subs</span> <span class="special">);</span><br><span class="identifier">sregex_token_iterator</span> <span class="identifier">end</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span> <span class="special">;</span> <span class="identifier">cur</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">cur</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">cur</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="special">}</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program outputs the following:<br>程序输出如下： </p>
<pre class="programlisting">4<br>40<br>3<br>35<br>2<br>32<br></pre>
<p> <br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top 回到顶部</a> </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.split_a_string_using_a_regex_as_a_delimiter"></a>
<h5><a name="id4109898"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.split_a_string_using_a_regex_as_a_delimiter">Split
a string using a regex as a delimiter 用一个regex作为分隔符分拆字符串</a> </h5>
<p> The following program takes some text that has been marked up
with html and strips out the mark-up. It uses a regex that matches an
HTML tag and a <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
that returns the parts of the string that do <span class="emphasis"><em>not</em></span>
match the regex.<br>以下程序接受一些带有html标记的文本，去掉其中的标记。它使用一个regex来匹配HTML标签，并用一个 <code class="literal"><code class="computeroutput"><a class="link" href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
返回字符串中不匹配该regex的其余部分。 </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"Now &lt;bold&gt;is the time &lt;i&gt;for all good men&lt;/i&gt; to come to the aid of their&lt;/bold&gt; country."</span> <span class="special">);</span><br><span class="comment">// find a HTML tag 查找一个HTML标签<br></span> <span class="identifier">sregex</span> <span class="identifier">html</span> <span class="special">=</span> <span class="char">'&lt;'</span> <span class="special">&gt;&gt;</span> <span class="identifier">optional</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span><span class="special">;</span><br><span class="comment">// the -1 below directs the token iterator to display the parts of<br></span> <span class="comment">// the string that did NOT match the regular expression.<br>// 以下的 -1 指示记号迭代器显示字符串中不匹配正则表达式的部分。<br></span> <span class="identifier">sregex_token_iterator</span> <span class="identifier">cur</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">html</span><span class="special">,</span> <span class="special">-</span><span class="number">1</span> <span class="special">);</span><br><span class="identifier">sregex_token_iterator</span> <span class="identifier">end</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span> <span class="special">;</span> <span class="identifier">cur</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">cur</span> <span class="special">)</span><br><span class="special">{</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'{'</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">cur</span> <span class="special">&lt;&lt;</span> <span class="char">'}'</span><span class="special">;</span><br><span class="special">}</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="keyword">return</span> <span class="number">0</span><span class="special">;</span><br><span class="special">}</span>
</pre>
<p> This program outputs the following:<br>程序输出如下： </p>
<pre class="programlisting">{Now }{is the time }{for all good men}{ to come to the aid of their}{ country.}<br></pre>
<p> <br>
<a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top 回到顶部</a> </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.display_a_tree_of_nested_results"></a>
<h5><a name="id4110485"></a> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples.display_a_tree_of_nested_results">Display
a tree of nested results 显示嵌套结果组成的树</a> </h5>
<p> Here is a helper class to demonstrate how you might display a
tree of nested results:<br>以下是一个辅助类，示范了如何显示由嵌套结果组成的树： </p>
<pre class="programlisting"><span class="comment">// Displays nested results to std::cout with indenting 以缩入方式将嵌套结果输出至 std::cout<br></span><span class="keyword">struct</span> <span class="identifier">output_nested_results</span><br><span class="special">{</span><br><span class="keyword">int</span> <span class="identifier">tabs_</span><span class="special">;</span><br><span class="identifier">output_nested_results</span><span class="special">(</span> <span class="keyword">int</span> <span class="identifier">tabs</span> <span class="special">=</span> <span class="number">0</span> <span class="special">)</span><br><span class="special">:</span> <span class="identifier">tabs_</span><span class="special">(</span> <span class="identifier">tabs</span> <span class="special">)</span><br><span class="special">{</span><br><span class="special">}</span><br><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">BidiIterT</span> <span class="special">&gt;</span><br><span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span> <span class="identifier">match_results</span><span class="special">&lt;</span> <span class="identifier">BidiIterT</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span> <span class="special">)</span> <span class="keyword">const</span><br><span class="special">{</span><br><span class="comment">// first, do some indenting 首先进行缩入<br></span> <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator_traits</span><span class="special">&lt;</span> <span class="identifier">BidiIterT</span> <span class="special">&gt;::</span><span class="identifier">value_type</span> <span class="identifier">char_type</span><span class="special">;</span><br><span class="identifier">char_type</span> <span class="identifier">space_ch</span> <span class="special">=</span> <span class="identifier">char_type</span><span class="special">(</span><span class="char">' '</span><span class="special">);</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">fill_n</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">&gt;(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">),</span> <span class="identifier">tabs_</span> <span class="special">*</span> <span class="number">4</span><span class="special">,</span> <span class="identifier">space_ch</span> <span class="special">);</span><br><span class="comment">// output the match 输出匹配结果<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span><br><span class="comment">// output any nested matches 输出嵌套的匹配<br></span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><br><span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">begin</span><span class="special">(),</span><br><span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">end</span><span class="special">(),</span><br><span class="identifier">output_nested_results</span><span class="special">(</span> <span class="identifier">tabs_</span> <span class="special">+</span> <span class="number">1</span> <span class="special">)</span> <span class="special">);</span><br><span class="special">}</span><br><span class="special">};</span>
</pre>
<p> <a class="link" href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top 回到顶部</a> </p>
</div>
<div class="footnotes">
<br>
<hr align="left" width="100">
<div class="footnote">
<p><sup>[<a name="ftn.id4016454" href="#id4016454" class="para">4</a>] </sup> See <a href="http://www.osl.iu.edu/%7Etveldhui/papers/Expression-Templates/exprtmpl.html" target="_top">Expression Templates</a> 参见 <a href="http://www.osl.iu.edu/%7Etveldhui/papers/Expression-Templates/exprtmpl.html" target="_top">表达式模板</a> </p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id4083153" href="#id4083153" class="para">5</a>] </sup> Many thanks to David
Jenkins, who contributed this example. 非常感谢 David Jenkins 贡献了这个例子。 </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%">
<tbody>
<tr>
<td align="left"></td>
<td align="right">
<div class="copyright-footer">Copyright © 2007 Eric
Niebler
<p> Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>
</div>
</td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="../xpressive.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
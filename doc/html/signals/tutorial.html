<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Tutorial</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../signals.html" title="Chapter 16. Boost.Signals">
<link rel="prev" href="../signals.html" title="Chapter 16. Boost.Signals">
<link rel="next" href="reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../signals.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../signals.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="signals.tutorial"></a>Tutorial</h2></div></div></div>

<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="signals.tutorial"></a>教程</h2></div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id1276917">How to Read this Tutorial</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1276980">Compatibility Note</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277113">Hello, World! (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277267">Calling multiple slots</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277683">Passing values to and from slots</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278652">Connection Management</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279460">Example: Document-View</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279626">Linking against the Signals library</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#terms20080627">术语表</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1276917">如何阅读本教程</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1276980">对兼容性的注释</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277113">Hello, World! （初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277267">调用多个插槽</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277683">传值到插槽及回传</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278652">连接管理</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279460">例子：文档-视图</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279626">链接信号库</a></span></dt>
</dl></div>


<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="terms20080627"></a>术语表</h3>
</div></div></div>

<table cellpadding="2" border="1">
<tr><th>英文</th> <th>中文</th> <th>注释</th></tr>

<tr><td>block</td><td>阻塞</td><td>&nbsp;</td></tr>
<tr><td>combiner</td><td>合并器</td><td>&nbsp;</td></tr>
<tr><td>compatibility form</td><td>兼容形式</td><td>&nbsp;</td></tr>
<tr><td>connect</td><td>连接</td><td>&nbsp;</td></tr>
<tr><td>connection</td><td>连接</td><td>&nbsp;</td></tr>
<tr><td>disconnect</td><td>断开</td><td>&nbsp;</td></tr>
<tr><td>first-in first-out (FIFO)</td><td>先进先出（FIFO）</td><td>&nbsp;</td></tr>
<tr><td>preferred form</td><td>首选形式</td><td>&nbsp;</td></tr>
<tr><td>scoped</td><td>域内的</td><td>作用域内的</td></tr>
<tr><td>signal</td><td>信号</td><td>&nbsp;</td></tr>
<tr><td>Signals library</td><td>信号库</td><td>&nbsp;</td></tr>
<tr><td>slot</td><td>插槽</td><td>&nbsp;</td></tr>

</table>
</div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1276917"></a>How to Read this Tutorial</h3>

<h3 class="title">
<a name="id1276917"></a>如何阅读本教程</h3>

</div></div></div>

<p>This tutorial is not meant to be read linearly. Its top-level
structure roughly separates different concepts in the library
(e.g., handling calling multiple slots, passing values to and from
slots) and in each of these concepts the basic ideas are presented
first and then more complex uses of the library are described
later. Each of the sections is marked <span class="emphasis"><em>Beginner</em></span>,
<span class="emphasis"><em>Intermediate</em></span>, or <span class="emphasis"><em>Advanced</em></span> to help guide the
reader. The <span class="emphasis"><em>Beginner</em></span> sections include information that all
library users should know; one can make good use of the Signals
library after having read only the <span class="emphasis"><em>Beginner</em></span> sections. The
<span class="emphasis"><em>Intermediate</em></span> sections build on the <span class="emphasis"><em>Beginner</em></span>
sections with slightly more complex uses of the library. Finally,
the <span class="emphasis"><em>Advanced</em></span> sections detail very advanced uses of the
Signals library, that often require a solid working knowledge of
the <span class="emphasis"><em>Beginner</em></span> and <span class="emphasis"><em>Intermediate</em></span> topics; most users
will not need to read the <span class="emphasis"><em>Advanced</em></span> sections.</p>

<p>
本教程不是用来线性阅读的。

其顶层结构大致按库中不同的概念划分，（如处理多个插槽的调用、传值到插槽及回传），并且在每一个概念中，首先介绍其基本思想，然后说明库较复杂的使用。

每个部分都标注了<span class="emphasis"><em>初级</em></span>、
<span class="emphasis"><em>中级</em></span>，或<span class="emphasis"><em>高级</em></span>，以帮助指导读者。

<span class="emphasis"><em>初级</em></span>部分包括库的所有使用者都该了解的信息；只要阅读了<span class="emphasis"><em>初级</em></span>部分，就可以很好地使用信号库。

<span class="emphasis"><em>中级</em></span>部分建立在<span class="emphasis"><em>初级</em></span>
部分之上，是库的稍复杂的使用。

最后，<span class="emphasis"><em>高级</em></span>部分详述了信号库很高级的应用，这往往需要对<span class="emphasis"><em>初级</em></span>和<span class="emphasis"><em>中级</em></span>内容扎实的实践经验；
大多数用户无需阅读<span class="emphasis"><em>高级</em></span>部分。
</p>

</div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1276980"></a>Compatibility Note</h3>

<h3 class="title">
<a name="id1276980"></a>对兼容性的注释</h3>

</div></div></div>

<p>Boost.Signals has two syntactical forms: the preferred form and
the compatibility form. The preferred form fits more closely with the
C++ language and reduces the number of separate template parameters
that need to be considered, often improving readability; however, the
preferred form is not supported on all platforms due to compiler
bugs. The compatible form will work on all compilers supported by
Boost.Signals. Consult the table below to determine which syntactic
form to use for your compiler. Users of Boost.Function, please note
that the preferred syntactic form in Signals is equivalent to that of
Function's preferred syntactic form.</p>

<p>Boost.Signals 有两种句法形式：首选形式（preferred form）和兼容形式（compatibility form）。

首选形式能更紧密地适合C++语言，
并减少需要考虑的独立模板参数的个数，
往往能提高可读性；
然而，由于编译器的错误，首选形式并非所有平台都支持。

兼容形式可工作于 Boost.Signals 支持的所有编译器。

参考下表，以确定为你的编译器使用哪种句法形式。

Boost.Function 的用户请注意，Signals 中的首选句法形式等效于 Function 的首选句法形式。
</p>

<p>If your compiler does not appear in this list, please try the
preferred syntax and report your results to the Boost list so that
we can keep this table up-to-date.</p>

<p>如果你的编译器不在这个清单上，请试用首选句法并向Boost列表报告你的结果，以使我们能保持更新该表。
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax
<br>
首选句法
</th>
<th align="left">Portable syntax
<br>兼容句法
</th>
</tr></thead>
<tbody><tr>
<td align="left">
            <div class="itemizedlist"><ul type="disc">
<li><p>GNU C++ 2.95.x, 3.0.x, 3.1.x</p></li>
<li><p>Comeau C++ 4.2.45.2</p></li>
<li><p>SGI MIPSpro 7.3.0</p></li>
<li><p>Intel C++ 5.0, 6.0</p></li>
<li><p>Compaq's cxx 6.2</p></li>
<li><p>Microsoft Visual C++ 7.1</p></li>
</ul></div>
          </td>
<td align="left">
            <div class="itemizedlist"><ul type="disc">
<li><p><span class="emphasis"><em>Any compiler supporting the preferred syntax
<br>
支持首选句法的任意编译器
</em></span></p></li>
<li><p>Microsoft Visual C++ 6.0, 7.0</p></li>
<li><p>Borland C++ 5.5.1</p></li>
<li><p>Sun WorkShop 6 update 2 C++ 5.3</p></li>
<li><p>Metrowerks CodeWarrior 8.1</p></li>
</ul></div>
          </td>
</tr></tbody>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1277113"></a>Hello, World! (Beginner)</h3>

<h3 class="title">
<a name="id1277113"></a>Hello, World! （初级）</h3>

</div></div></div>

<p>The following example writes "Hello, World!" using signals and
slots. First, we create a signal <code class="computeroutput">sig</code>, a signal that
takes no arguments and has a void return value. Next, we connect
the <code class="computeroutput">hello</code> function object to the signal using the
<code class="computeroutput">connect</code> method. Finally, use the signal
<code class="computeroutput">sig</code> like a function to call the slots, which in turns
invokes <code class="computeroutput">HelloWorld::operator()</code> to print "Hello,
World!".</p>

<p>下例将使用信号和插槽写出“Hello, World!”。

首先，我们创建信号 <code class="computeroutput">sig</code>，该信号无参数并且返回值为空。

接着，我们使用 <code class="computeroutput">connect</code> 
方法将 <code class="computeroutput">hello</code>
函数对象连接到信号。

最后，像函数一样使用信号
<code class="computeroutput">sig</code>
来调用插槽，
它将转而调用 <code class="computeroutput">HelloWorld::operator()</code>
打印“Hello, World!”。
</p>


<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
struct HelloWorld 
{
  void operator()() const 
  { 
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
  } 
};

// ...

// Signal with no arguments and a void return value
<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>&lt;void ()&gt; sig;

// Connect a HelloWorld slot
HelloWorld hello;
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(hello);

// Call all of the slots
sig();
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
struct HelloWorld 
{
  void operator()() const 
  { 
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
  } 
};

// ...

// Signal with no arguments and a void return value
<code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal0</a></code>&lt;void&gt; sig;

// Connect a HelloWorld slot
HelloWorld hello;
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(hello);

// Call all of the slots
sig();
</pre>
</td>
</tr></tbody>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1277267"></a>Calling multiple slots</h3>

<h3 class="title">
<a name="id1277267"></a>调用多个插槽</h3>

</div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id1277272">Connecting multiple slots (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277459">Ordering slot call groups (Intermediate)</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id1277272">连接多个插槽（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277459">插槽调用组排序（中级）</a></span></dt>
</dl></div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1277272"></a>Connecting multiple slots (Beginner)</h4>

<h4 class="title">
<a name="id1277272"></a>连接多个插槽（初级）</h4>

</div></div></div>

<p>Calling a single slot from a signal isn't very interesting, so
we can make the Hello, World program more interesting by splitting
the work of printing "Hello, World!" into two completely separate
slots. The first slot will print "Hello" and may look like
this:</p>

<p>从信号调用单个插槽不是很有意思，
因此我们将打印“Hello, World!”的工作拆分到两个完全独立的插槽，
让 Hello, World 程序更有趣点。

第一个插槽将打印“Hello”，可能看起来像这样：</p>

<pre class="programlisting">
struct Hello 
{
  void operator()() const
  {
    std::cout &lt;&lt; "Hello";
  }
};
</pre>
<p>The second slot will print ", World!" and a newline, to complete
the program. The second slot may look like this:</p>

<p>第二个插槽将打印“, World!”和换行，以完成该程序。
第二个插槽可能看起来像这样：</p>

<pre class="programlisting">
struct World
{
  void operator()() const
  {
    std::cout &lt;&lt; ", World!" &lt;&lt; std::endl;
  }
};
</pre>
<p>Like in our previous example, we can create a signal
<code class="computeroutput">sig</code> that takes no arguments and has a
<code class="computeroutput">void</code> return value. This time, we connect both a
<code class="computeroutput">hello</code> and a <code class="computeroutput">world</code> slot to the same
signal, and when we call the signal both slots will be called.</p>

<p>和上个例子一样，我们创建信号
<code class="computeroutput">sig</code>，
它没有参数并且返回值为
<code class="computeroutput">void</code>。

这次，我们将
<code class="computeroutput">hello</code>
和 <code class="computeroutput">world</code>
插槽都连接到同一个信号，
当我们调用该信号，两个插槽都将会被调用。
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>&lt;void ()&gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(Hello());
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(World());

sig();
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal0</a></code>&lt;void&gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(Hello());
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(World());

sig();
</pre>
</td>
</tr></tbody>
</table></div>
<p>By default, slots are called in first-in first-out (FIFO) order,
so the output of this program will be as expected:</p>

<p>默认情况下，插槽以先进先出（FIFO）的次序被调用，
因此该程序的输出应该是：
</p>

<pre class="programlisting">
Hello, World!
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1277459"></a>Ordering slot call groups (Intermediate)</h4>

<h4 class="title">
<a name="id1277459"></a>插槽调用组排序（中级）</h4>

</div></div></div>

<p>Slots are free to have side effects, and that can mean that some
slots will have to be called before others even if they are not connected in that order. The Boost.Signals
library allows slots to be placed into groups that are ordered in
some way. For our Hello, World program, we want "Hello" to be
printed before ", World!", so we put "Hello" into a group that must
be executed before the group that ", World!" is in. To do this, we
can supply an extra parameter at the beginning of the
<code class="computeroutput">connect</code> call that specifies the group. Group values
are, by default, <code class="computeroutput">int</code>s, and are ordered by the integer
&lt; relation. Here's how we construct Hello, World:</p>

<p>插槽可以有副作用，这意味着某些插槽必须在另一些之前调用，即使它们不是按那个次序连接的。

Boost.Signals 库允许插槽进行分组，并按某种方式排序编组。

对于我们的 Hello, World 程序，我们要“Hello”在“, World!”之前打印，
所以我们将“Hello”放入一个组，该组将在“, World!”所在组之前执行。

为了做到这一点，我们可以在
<code class="computeroutput">connect</code>
调用的头部提供一个额外的参数，以指定编组。

编组值默认为
<code class="computeroutput">int</code>，
并按整型的 &lt; 关系排序。

我们这样构造 Hello, World：
</p>


<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>&lt;void ()&gt; sig;
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(1, World());
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(0, Hello());
sig();
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal0</a></code>&lt;void&gt; sig;
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(1, World());
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(0, Hello());
sig();
</pre>
</td>
</tr></tbody>
</table></div>
<p>This program will correctly print "Hello, World!", because the
<code class="computeroutput">Hello</code> object is in group 0, which precedes group 1 where
the <code class="computeroutput">World</code> object resides. The group
parameter is, in fact, optional. We omitted it in the first Hello,
World example because it was unnecessary when all of the slots are
independent. So what happens if we mix calls to connect that use the
group parameter and those that don't? The "unnamed" slots (i.e., those
that have been connected without specifying a group name) can be
placed at the front or back of the slot list (by passing
<code class="computeroutput">boost::signals::at_front</code> or <code class="computeroutput">boost::signals::at_back</code>
as the last parameter to <code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>, respectively), and defaults to the end of the list. When
a group is specified, the final parameter describes where the slot
will be placed within the group ordering. If we add a new slot
to our example like this:</p>

<p>该程序将正确打印出“Hello, World!”，因为
<code class="computeroutput">Hello</code> 对象在组 0，它在
<code class="computeroutput">World</code> 对象所在的组 1 之前。

编组参数实际上是可选的。
在第一个 Hello World 例子中我们省略了它，
因为当所有的插槽都独立时，编组是不必要的。

那么，如果我们混合调用使用和不使用编组参数的连接会怎样？
“未命名”插槽（即那些连接时未指定组名的插槽）可置于插槽链表的头部或尾部
（通过向
<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>
分别传入
<code class="computeroutput">boost::signals::at_front</code> 或
<code class="computeroutput">boost::signals::at_back</code>
作为最后的参数），
而默认为链表的结尾。

当指定了编组时，最后的参数描述的是插槽在组内的次序。
如果在我们的例子中添加新的插槽，如下：
</p>

<pre class="programlisting">
struct GoodMorning
{
  void operator()() const
  {
    std::cout &lt;&lt; "... and good morning!" &lt;&lt; std::endl;
  }
};

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(GoodMorning());
</pre>
<p>... we will get the result we wanted:</p>

<p>……我们会得到想要的结果：</p>

<pre class="programlisting">
Hello, World!
... and good morning!
</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1277683"></a>Passing values to and from slots</h3>

<h3 class="title">
<a name="id1277683"></a>传值到插槽及回传</h3>

</div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id1277689">Slot Arguments (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277949">Signal Return Values (Advanced)</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id1277689">插槽的参数（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1277949">信号的返回值（高级）</a></span></dt>
</dl></div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1277689"></a>Slot Arguments (Beginner)</h4>

<h4 class="title">
<a name="id1277689"></a>插槽的参数（初级）</h4>

</div></div></div>

<p>Signals can propagate arguments to each of the slots they call.
For instance, a signal that propagates mouse motion events might
want to pass along the new mouse coordinates and whether the mouse
buttons are pressed.</p>

<p>信号可以向它们调用的每个插槽传递参数。

例如，一个传递鼠标移动事件的信号可能要传入新的鼠标坐标以及是否按了鼠标键。
</p>

<p>As an example, we'll create a signal that passes two
<code class="computeroutput">float</code> arguments to its slots. Then we'll create a few
slots that print the results of various arithmetic operations on
these values.</p>

<p>例如，我们创建一个信号，它将传入两个
<code class="computeroutput">float</code> 参数到它的插槽。

然后我们再创建几个插槽，打印对这两个参数进行算术运算的各种结果。
</p>

<pre class="programlisting">
void print_sum(float x, float y)
{
  std::cout &lt;&lt; "The sum is " &lt;&lt; x+y &lt;&lt; std::endl;
}

void print_product(float x, float y)
{
  std::cout &lt;&lt; "The product is " &lt;&lt; x*y &lt;&lt; std::endl;
}

void print_difference(float x, float y)
{
  std::cout &lt;&lt; "The difference is " &lt;&lt; x-y &lt;&lt; std::endl;
}

void print_quotient(float x, float y)
{
  std::cout &lt;&lt; "The quotient is " &lt;&lt; x/y &lt;&lt; std::endl;
}
</pre>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>&lt;void (float, float)&gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_sum);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_product);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_difference);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_quotient);

sig(5, 3);
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal2</a></code>&lt;void, float, float&gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_sum);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_product);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_difference);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;print_quotient);

sig(5, 3);
</pre>
</td>
</tr></tbody>
</table></div>
<p>This program will print out the following:</p>

<p>该程序将打印输出如下：</p>

<pre class="programlisting">
The sum is 8
The product is 15
The difference is 2
The quotient is 1.66667
</pre>
<p>So any values that are given to <code class="computeroutput">sig</code> when it is
called like a function are passed to each of the slots. We have to
declare the types of these values up front when we create the
signal. The type <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a>&lt;void (float,
float)&gt;</code> means that the signal has a <code class="computeroutput">void</code>
return value and takes two <code class="computeroutput">float</code> values. Any slot
connected to <code class="computeroutput">sig</code> must therefore be able to take two
<code class="computeroutput">float</code> values.</p>

<p>
当像函数一样调用 <code class="computeroutput">sig</code> 时，
输入它的任何值都传给了每一个插槽。

创建信号时，我们必须预先声明这些值的类型。

类型 <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a>&lt;void (float,
float)&gt;</code> 表明信号具有 <code class="computeroutput">void</code>
返回值并接受两个 <code class="computeroutput">float</code> 值。

因此任何连接到
<code class="computeroutput">sig</code>
的插槽都必须能够接受两个
<code class="computeroutput">float</code> 值。
</p>

</div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1277949"></a>Signal Return Values (Advanced)</h4>

<h4 class="title">
<a name="id1277949"></a>信号返回值（高级）</h4>

</div></div></div>

<p>Just as slots can receive arguments, they can also return
values. These values can then be returned back to the caller of the
signal through a <em class="firstterm">combiner</em>. The combiner is a mechanism
that can take the results of calling slots (there many be no
results or a hundred; we don't know until the program runs) and
coalesces them into a single result to be returned to the caller.
The single result is often a simple function of the results of the
slot calls: the result of the last slot call, the maximum value
returned by any slot, or a container of all of the results are some
possibilities.</p>

<p>正如插槽可以接收参数，它们也可以返回值。

然后这些值可以通过
<em class="firstterm">合并器（combiner）</em>
返回给信号的调用者。

合并器是这样一种工具，它接收插槽调用的结果（可能没有结果，也可能有100个结果；程序运行时才知道），并且把它们合并成单一的结果返回给调用者。

该单一的结果往往是插槽调用结果的一个简单函数，可能是：最后的插槽调用的结果、所有插槽返回值的最大值，或包含所有结果的容器。
</p>

<p>We can modify our previous arithmetic operations example
slightly so that the slots all return the results of computing the
product, quotient, sum, or difference. Then the signal itself can
return a value based on these results to be printed:</p>

<p>
我们可以稍微修改前面的算术运算的例子，
使插槽分别返回加减乘除的计算结果。

然后信号本身就可以根据这些结果返回一个值，并打印出来。
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
float product(float x, float y) { return x*y; }
float quotient(float x, float y) { return x/y; }
float sum(float x, float y) { return x+y; }
float difference(float x, float y) { return x-y; }

<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>&lt;float (float x, float y)&gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;product);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;quotient);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;sum);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
float product(float x, float y) { return x*y; }
float quotient(float x, float y) { return x/y; }
float sum(float x, float y) { return x+y; }
float difference(float x, float y) { return x-y; }

<code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal2</a></code>&lt;float, float, float&gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;product);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;quotient);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;sum);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</pre>
</td>
</tr></tbody>
</table></div>
<p>This example program will output <code class="computeroutput">2</code>. This is because the
default behavior of a signal that has a return type
(<code class="computeroutput">float</code>, the first template argument given to the
<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code> class template) is to call all slots and
then return the result returned by the last slot called. This
behavior is admittedly silly for this example, because slots have
no side effects and the result is the last slot connect.</p>

<p>该例程将输出 <code class="computeroutput">2</code>。
这是因为具有返回类型（<code class="computeroutput">float</code>，
即输入 <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>
类模板的第一个模板参数）的信号的默认行为是，
调用所有的插槽，然后返回最后一个被调用插槽的结果。

对本例来说，该行为确实有点傻，因为这些插槽没有副作用，所以结果就是最后连接的插槽。
</p>

<p>A more interesting signal result would be the maximum of the
values returned by any slot. To do this, we create a custom
combiner that looks like this:</p>

<p>求所有插槽返回值的最大值，这样的信号结果才有点意思。
为些，我们创建一个自定义合并器如下：
</p>

<pre class="programlisting">
template&lt;typename T&gt;
struct maximum
{
  typedef T result_type;

  template&lt;typename InputIterator&gt;
  T operator()(InputIterator first, InputIterator last) const
  {
    // If there are no slots to call, just return the
    // default-constructed value
    if (first == last)
      return T();

    T max_value = *first++;
    while (first != last) {
      if (max_value &lt; *first)
        max_value = *first;
      ++first;
    }
  
    return max_value;
  }
};
</pre>

<p>The <code class="computeroutput">maximum</code> class template acts as a function
object. Its result type is given by its template parameter, and
this is the type it expects to be computing the maximum based on
(e.g., <code class="computeroutput">maximum&lt;float&gt;</code> would find the maximum
<code class="computeroutput">float</code> in a sequence of <code class="computeroutput">float</code>s). When a
<code class="computeroutput">maximum</code> object is invoked, it is given an input
iterator sequence <code class="computeroutput">[first, last)</code> that includes the
results of calling all of the slots. <code class="computeroutput">maximum</code> uses this
input iterator sequence to calculate the maximum element, and
returns that maximum value.</p>

<p>
<code class="computeroutput">maximum</code> 类模板就像一个函数对象。

它的结果类型由其模板参数给出，
并且它正是基于该类型计算最大值
（例如，<code class="computeroutput">maximum&lt;float&gt;</code>
将在一系列 <code class="computeroutput">float</code>
中查找最大的 <code class="computeroutput">float</code>）。

当调用
<code class="computeroutput">maximum</code> 对象时，
将给出一个输入迭代器序列
<code class="computeroutput">[first, last)</code>，
其中包含了所有插槽调用的结果。

<code class="computeroutput">maximum</code>
利用该输入迭代器序列来计算最大元素，
并返回那个最大值。
</p>

<p>We actually use this new function object type by installing it
as a combiner for our signal. The combiner template argument
follows the signal's calling signature:</p>

<p>
我们要把这个新的函数对象作为合并器安装到我们的信号，才能实际使用它。
合并器模板参数跟在信号的调用签名式之后。
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>&lt;float (float x, float y), 
              maximum&lt;float&gt; &gt; sig;
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal2</a></code>&lt;float, float, float, 
               maximum&lt;float&gt; &gt; sig;
</pre>
</td>
</tr></tbody>
</table></div>
<p>Now we can connect slots that perform arithmetic functions and
use the signal:</p>

<p>现在我们可以连接执行算术功能的插槽并使用信号了：
</p>

<pre class="programlisting">
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;quotient);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;product);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;sum);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</pre>
<p>The output of this program will be <code class="computeroutput">15</code>, because
regardless of the order in which the slots are connected, the product
of 5 and 3 will be larger than the quotient, sum, or
difference.</p>

<p>该程序的输出为 <code class="computeroutput">15</code>，
因为不管插槽的连接次序如何，
5 和 3 的乘积将大于商、和，或差。
</p>

<p>In other cases we might want to return all of the values
computed by the slots together, in one large data structure. This
is easily done with a different combiner:</p>

<p>在其他情况下，我们可能需要同时返回插槽计算的所有值，
如保存在一个大型的数据结构中。
用一个不同的合并器就可以轻松做到：
</p>

<pre class="programlisting">
template&lt;typename Container&gt;
struct aggregate_values
{
  typedef Container result_type;

  template&lt;typename InputIterator&gt;
  Container operator()(InputIterator first, InputIterator last) const
  {
    return Container(first, last);
  }
};
</pre>
<p>
Again, we can create a signal with this new combiner: 
</p>

<p>
我们再次用这个新的合并器创建信号：
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">boost::signal</a></code>&lt;float (float, float), 
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;quotient);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;product);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;sum);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;difference);

std::vector&lt;float&gt; results = sig(5, 3);
std::copy(results.begin(), results.end(), 
    std::ostream_iterator&lt;float&gt;(cout, " "));
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
<code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal2</a></code>&lt;float, float, float,
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;

sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;quotient);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;product);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;sum);
sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(&amp;difference);

std::vector&lt;float&gt; results = sig(5, 3);
std::copy(results.begin(), results.end(), 
    std::ostream_iterator&lt;float&gt;(cout, " "));
</pre>
</td>
</tr></tbody>
</table></div>
<p>The output of this program will contain 15, 8, 1.6667, and 2. It
is interesting here that
the first template argument for the <code class="computeroutput">signal</code> class,
<code class="computeroutput">float</code>, is not actually the return type of the signal.
Instead, it is the return type used by the connected slots and will
also be the <code class="computeroutput">value_type</code> of the input iterators passed
to the combiner. The combiner itself is a function object and its
<code class="computeroutput">result_type</code> member type becomes the return type of the
signal.</p>

<p>该程序的输出将包含 15、8、1.6667，和 2。
有趣的是，
<code class="computeroutput">signal</code>
类的第一个模板参数，
<code class="computeroutput">float</code>，
竟然不是信号的返回类型。

相反，该参数是所连接插槽的返回类型，
并且它也是传入合并器的输入迭代器的
<code class="computeroutput">value_type</code>。

合并器本身是个函数对象，并且它的
<code class="computeroutput">result_type</code>
成员类型将成为信号的返回类型。
</p>

<p>The input iterators passed to the combiner transform dereference
operations into slot calls. Combiners therefore have the option to
invoke only some slots until some particular criterion is met. For
instance, in a distributed computing system, the combiner may ask
each remote system whether it will handle the request. Only one
remote system needs to handle a particular request, so after a
remote system accepts the work we do not want to ask any other
remote systems to perform the same task. Such a combiner need only
check the value returned when dereferencing the iterator, and
return when the value is acceptable. The following combiner returns
the first non-NULL pointer to a <code class="computeroutput">FulfilledRequest</code> data
structure, without asking any later slots to fulfill the
request:</p>

<p>
传给合并器的输入迭代器会将解引用操作转换为插槽调用。

因此合并器可选择仅调用某些符合特定条件的插槽。

例如，在分布计算系统中，合并器可能会询问每个远程系统能否处理请求。

对于一个特定请求，仅需一个远程系统进行处理，
因此当一个远程系统接受该工作后，
我们将不再要求任何其他远程系统来做同一个任务。

这样一个合并器只需检查迭代器解引用的返回值，
并当该值可以接受时就返回。

以下的合并器返回第一个指向
<code class="computeroutput">FulfilledRequest</code>
数据结构的非空指针，
而不必要求任何以后的插槽来完成请求：
</p>

<pre class="programlisting">
struct DistributeRequest {
  typedef FulfilledRequest* result_type;

  template&lt;typename InputIterator&gt;
  result_type operator()(InputIterator first, InputIterator last) const
  {
    while (first != last) {
      if (result_type fulfilled = *first)
        return fulfilled;
      ++first;
    }
    return 0;
  }
};
</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1278652"></a>Connection Management</h3>

<h3 class="title">
<a name="id1278652"></a>连接管理</h3>

</div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id1278657">Disconnecting Slots (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278779">Blocking Slots (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278859">Scoped connections (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278910">Disconnecting equivalent slots (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278998">Automatic connection management (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279224">When can disconnections occur? (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279298">Passing slots (Intermediate)</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id1278657">断开插槽（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278779">阻塞插槽（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278859">域内连接（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278910">断开等价的插槽（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1278998">自动连接管理（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279224">何时断开？（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id1279298">传递插槽（中级）</a></span></dt>
</dl></div>


<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1278657"></a>Disconnecting Slots (Beginner)</h4>

<h4 class="title">
<a name="id1278657"></a>断开插槽（初级）</h4>

</div></div></div>

<p>Slots aren't expected to exist indefinately after they are
connected. Often slots are only used to receive a few events and
are then disconnected, and the programmer needs control to decide
when a slot should no longer be connected.</p>

<p>插槽在连接之后不必无限期地存在。
插槽往往只是用来接收一些事件然后断开，
当插槽不再需要保持连接时，
程序员可以做出决定并控制。
</p>

<p>The entry point for managing connections explicitly is the
<code class="computeroutput"><a class="link" href="../boost/signals/connection.html" title="Class connection">boost::signals::connection</a></code> class. The
<code class="computeroutput"><a class="link" href="../boost/signals/connection.html" title="Class connection">connection</a></code> class uniquely represents the connection
between a particular signal and a particular slot. The
<code class="computeroutput"><a class="link" href="../boost/signals/connection.html#id722201-bb">connected</a>()</code> method checks if the signal and slot are
still connected, and the <code class="computeroutput"><a class="link" href="../boost/signals/connection.html#id457846-bb">disconnect()</a></code> method
disconnects the signal and slot if they are connected before it is
called. Each call to the signal's <code class="computeroutput">connect()</code> method
returns a connection object, which can be used to determine if the
connection still exists or to disconnect the signal and slot.</p>

<p>
显式管理连接的入口点是
<code class="computeroutput"><a class="link" href="../boost/signals/connection.html" title="Class connection">boost::signals::connection</a></code> 类。

<code class="computeroutput"><a class="link" href="../boost/signals/connection.html" title="Class connection">connection</a></code> 
类唯一代表了特定信号与特定插槽之间的连接。

<code class="computeroutput"><a class="link" href="../boost/signals/connection.html#id722201-bb">connected</a>()</code> 
方法检查信号与插槽是否仍保持连接，

如果信号与插槽是连接着的，
<code class="computeroutput"><a class="link" href="../boost/signals/connection.html#id457846-bb">disconnect()</a></code> 
方法断开它们的连接。

每次调用信号的 <code class="computeroutput">connect()</code> 
方法，就返回一个连接对象，
该对象用于确定连接是否仍然存在，
或者用于断开信号和插槽。
</p>

<pre class="programlisting">
boost::signals::connection c = sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(HelloWorld());
if (c.<code class="computeroutput">connected</code>()) {
<span class="emphasis"><em>// c is still connected to the signal</em></span>
  sig(); <span class="emphasis"><em>// Prints "Hello, World!"</em></span>
}

c.disconnect(); <span class="emphasis"><em>// Disconnect the HelloWorld object</em></span>
assert(!c.<code class="computeroutput">connected</code>()); <span class="emphasis"><em>c isn't connected any more</em></span>

sig(); <span class="emphasis"><em>// Does nothing: there are no connected slots</em></span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1278779"></a>Blocking Slots (Beginner)</h4>

<h4 class="title">
<a name="id1278779"></a>阻塞插槽（初级）</h4>

</div></div></div>

<p>Slots can be temporarily "blocked", meaning that they will be
ignored when the signal is invoked but have not been disconnected. The
<code class="computeroutput">block</code> member function
temporarily blocks a slot, which can be unblocked via
<code class="computeroutput">unblock</code>. Here is an example of
blocking/unblocking slots:</p>

<p>
插槽可以被临时“阻塞”，即当信号被调用时，这些插槽将被忽略，但并没有被断开。

<code class="computeroutput">block</code> 
成员函数临时地阻塞一个插槽，
可通过 <code class="computeroutput">unblock</code>
解除阻塞。

这是一个阻塞/开启插槽的例子：
</p>

<pre class="programlisting">
boost::signals::connection c = sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(HelloWorld());
sig(); <span class="emphasis"><em>// Prints "Hello, World!"</em></span>

c.<code class="computeroutput">block</code>(); <span class="emphasis"><em>// block the slot</em></span>
assert(c.<code class="computeroutput">blocked</code>());
sig(); <span class="emphasis"><em>// No output: the slot is blocked</em></span>

c.<code class="computeroutput">unblock</code>(); <span class="emphasis"><em>// unblock the slot</em></span>
sig(); <span class="emphasis"><em>// Prints "Hello, World!"</em></span>
</pre>
</div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1278859"></a>Scoped connections (Intermediate)</h4>

<h4 class="title">
<a name="id1278859"></a>域内连接（中级）</h4>

</div></div></div>

<p>The <code class="computeroutput">boost::signals::scoped_connection</code> class
references a signal/slot connection that will be disconnected when
the <code class="computeroutput">scoped_connection</code> class goes out of scope. This
ability is useful when a connection need only be temporary,
e.g.,</p>

<p>
<code class="computeroutput">boost::signals::scoped_connection</code> 类引用了一个信号/插槽的连接，当
<code class="computeroutput">scoped_connection</code>
类出作用域时，该连接将会被断开。

当仅需临时连接时，该功能很有用，如：
</p>

<pre class="programlisting">
{
  boost::signals::scoped_connection c = sig.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(ShortLived());
  sig(); <span class="emphasis"><em>// will call ShortLived function object</em></span>
}
sig(); <span class="emphasis"><em>// ShortLived function object no longer connected to sig</em></span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1278910"></a>Disconnecting equivalent slots (Intermediate)</h4>

<h4 class="title">
<a name="id1278910"></a>断开等价的插槽（中级）</h4>

</div></div></div>

<p>One can disconnect slots that are equivalent to a given function
object using a form of the
<code class="computeroutput"><a class="link" href="../boost/signalN.html#id481008-bb">disconnect</a></code> method, so long as
the type of the function object has an accessible <code class="computeroutput">==</code>
operator. For instance:

</p>

<p>你可以使用
<code class="computeroutput"><a class="link" href="../boost/signalN.html#id481008-bb">disconnect</a></code>
方法断开与给定函数对象等价的多个插槽，
只要该函数对象的类型具有可访问的
<code class="computeroutput">==</code>
运算符。例如：
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
void foo();
void bar();

signal&lt;void()&gt; sig;

sig.connect(&amp;foo);
sig.connect(&amp;bar);

// disconnects foo, but not bar
sig.disconnect(&amp;foo);
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
void foo();
void bar();

signal0&lt;void&gt; sig;

sig.connect(&amp;foo);
sig.connect(&amp;bar);

// disconnects foo, but not bar
sig.disconnect(&amp;foo);
</pre>
</td>
</tr></tbody>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1278998"></a>Automatic connection management (Intermediate)</h4>

<h4 class="title">
<a name="id1278998"></a>自动连接管理（中级）</h4>

</div></div></div>

<p>Boost.Signals can automatically track the lifetime of objects
involved in signal/slot connections, including automatic
disconnection of slots when objects involved in the slot call are
destroyed. For instance, consider a simple news delivery service,
where clients connect to a news provider that then sends news to
all connected clients as information arrives. The news delivery
service may be constructed like this: </p>

<p>
Boost.Signals 能自动跟踪信号/插槽连接中所涉及对象的生命期，
包括当插槽调用中涉及的对象销毁时自动断开插槽。

例如，考虑一个简单的新闻发送服务，
其中客户会连接到新闻提供者，
而新闻提供者一有信息到达，就发送新闻到所有连接的客户。
该新闻发送服务可能像这样构造：
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
class NewsItem { /* ... */ };

boost::signal&lt;void (const NewsItem&amp;)&gt; deliverNews;
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
class NewsItem { /* ... */ };

boost::signal1&lt;void, const NewsItem&amp;&gt; deliverNews;
</pre>
</td>
</tr></tbody>
</table></div>
<p>Clients that wish to receive news updates need only connect a
function object that can receive news items to the
<code class="computeroutput">deliverNews</code> signal. For instance, we may have a
special message area in our application specifically for news,
e.g.,:</p>

<p>
希望接收新闻更新的客户只需连接一个函数对象，
该对象可以接收传给
<code class="computeroutput">deliverNews</code>
信号的新闻条目，例如：
</p>

<pre class="programlisting">
struct NewsMessageArea : public MessageArea
{
public:
  // ...

  void displayNews(const NewsItem&amp; news) const
  {
    messageText = news.text();
    update();
  }
};

// ...
NewsMessageArea newsMessageArea = new NewsMessageArea(/* ... */);
// ...
deliverNews.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(boost::bind(&amp;NewsMessageArea::displayNews, 
                                newsMessageArea, _1));
</pre>
<p>However, what if the user closes the news message area,
destroying the <code class="computeroutput">newsMessageArea</code> object that
<code class="computeroutput">deliverNews</code> knows about? Most likely, a segmentation
fault will occur. However, with Boost.Signals one need only make
<code class="computeroutput">NewsMessageArea</code> <span class="emphasis"><em>trackable</em></span>, and the slot
involving <code class="computeroutput">newsMessageArea</code> will be disconnected when
<code class="computeroutput">newsMessageArea</code> is destroyed. The
<code class="computeroutput">NewsMessageArea</code> class is made trackable by deriving
publicly from the <code class="computeroutput">boost::signals::trackable</code> class,
e.g.:</p>

<p>不过，如果用户关闭新闻讯息区，
销毁了 <code class="computeroutput">deliverNews</code>
所知的 <code class="computeroutput">newsMessageArea</code> 对象，
那会怎么样？

最有可能的是产生段错误。

然而，你只需在使用 Boost.Signals 时，让
<code class="computeroutput">NewsMessageArea</code> <span class="emphasis"><em>可跟踪（trackable）</em></span>，
那么当 <code class="computeroutput">newsMessageArea</code> 被销毁时，
调用 <code class="computeroutput">newsMessageArea</code> 
的插槽就会被断开。

通过公有继承自
<code class="computeroutput">boost::signals::trackable</code> 类，
<code class="computeroutput">NewsMessageArea</code> 
类就会变成可跟踪的，例如：
</p>

<pre class="programlisting">
struct NewsMessageArea : public MessageArea, public boost::signals::trackable
{
  // ...
};
</pre>
<p>At this time there is a significant limitation to the use of
<code class="computeroutput">trackable</code> objects in making slot connections: function
objects built using Boost.Bind are understood, such that pointers
or references to <code class="computeroutput">trackable</code> objects passed to
<code class="computeroutput">boost::bind</code> will be found and tracked.</p>

<p>
目前，用 <code class="computeroutput">trackable</code> 
对象制作插槽连接有个重要的限制：

它理解使用 Boost.Bind 构建的函数对象，如传入
<code class="computeroutput">boost::bind</code>
的 <code class="computeroutput">trackable</code> 
对象指针或引用将会被发现和跟踪。
</p>

<p><span class="bold"><strong>Warning</strong></span>: User-defined function objects and function
objects from other libraries (e.g., Boost.Function or Boost.Lambda)
do not implement the required interfaces for <code class="computeroutput">trackable</code>
object detection, and <span class="emphasis"><em>will silently ignore any bound trackable
objects</em></span>. Future versions of the Boost libraries will address
this limitation.</p>

<p><span class="bold"><strong>警告</strong></span>：
用户自定义函数对象和来自其他库的函数对象
（例如来自 Boost.Function 或 Boost.Lambda），

没有实现所要求的
<code class="computeroutput">trackable</code> 
对象检测接口，
<span class="emphasis"><em>将会默默地忽略任何绑定的可跟踪对象</em></span>。
Boost库的未来版本将会解除该限制。
</p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1279224"></a>When can disconnections occur? (Intermediate)</h4>

<h4 class="title">
<a name="id1279224"></a>何时断开？（中级）</h4>

</div></div></div>

<p>Signal/slot disconnections occur when any of these conditions
occur:</p>

<p>
以下任一条件发生时，信号/插槽将断开：
</p>

<div class="itemizedlist"><ul type="disc">
<li><p>The connection is explicitly disconnected via the connection's
<code class="computeroutput">disconnect</code> method directly, or indirectly via the
signal's <code class="computeroutput">disconnect</code> method or
<code class="computeroutput">scoped_connection</code>'s destructor.</p>

<p>连接被显式地断开：
直接通过连接的
<code class="computeroutput">disconnect</code> 方法， 
或间接地通过信号的
<code class="computeroutput">disconnect</code> 方法或
<code class="computeroutput">scoped_connection</code>
的析构函数。
</p>

</li>

<li><p>A <code class="computeroutput">trackable</code> object bound to the slot is
destroyed.</p>

<p>
绑定于插槽的 <code class="computeroutput">trackable</code> 对象被销毁。
</p>

</li>

<li><p>The signal is destroyed.</p>

<p>信号被销毁。</p>

</li>
</ul></div>

<p>These events can occur at any time without disrupting a signal's
calling sequence. If a signal/slot connection is disconnected at
any time during a signal's calling sequence, the calling sequence
will still continue but will not invoke the disconnected slot.
Additionally, a signal may be destroyed while it is in a calling
sequence, and which case it will complete its slot call sequence
but may not be accessed directly.</p>

<p>这些事件可以发生于任何时间，而不会破坏信号的调用序列。

如果信号/插槽的连接在信号调用序列的任意时刻被断开，
调用序列仍将继续，只是不会调用被断开的插槽。

此外，信号可以在调用序列中间被销毁，这时，它将完成其插槽调用序列，
只是不可以被直接访问。
</p>

<p>Signals may be invoked recursively (e.g., a signal A calls a
slot B that invokes signal A...). The disconnection behavior does
not change in the recursive case, except that the slot calling
sequence includes slot calls for all nested invocations of the
signal.</p>

<p>信号可以被递归调用（例如，信号A调用插槽B，而插槽B又调用信号A……）。

递归情况下，断开的行为不会改变，
只是插槽调用序列包括所有嵌套的信号调用。
</p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id1279298"></a>Passing slots (Intermediate)</h4>

<h4 class="title">
<a name="id1279298"></a>传递插槽（中级）</h4>

</div></div></div>

<p>Slots in the Boost.Signals library are created from arbitrary
function objects, and therefore have no fixed type. However, it is
commonplace to require that slots be passed through interfaces that
cannot be templates. Slots can be passed via the
<code class="computeroutput">slot_type</code> for each particular signal type and any
function object compatible with the signature of the signal can be
passed to a <code class="computeroutput">slot_type</code> parameter. For instance:</p>

<p>Boost.Signals 库中的插槽可以从任意的函数对象创建，因此没有固定的类型。

不过通常要求通过不可模板化的接口传递插槽。

对于每个特定的信号类型，
都可以通过
<code class="computeroutput">slot_type</code>
传递插槽，

而与信号的签名式兼容的任意函数对象，
都可以传给 <code class="computeroutput">slot_type</code> 参数。

例如：
</p>

<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Preferred syntax</th>
<th align="left">Portable syntax</th>
</tr></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
class Button 
{
  typedef boost::signal&lt;void (int x, int y)&gt; OnClick;

public:
  void doOnClick(const OnClick::slot_type&amp; slot);

private:
  OnClick onClick;
};

void Button::doOnClick(
      const OnClick::slot_type&amp; slot
    )
{
  onClick.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(slot);
}

void printCoordinates(long x, long y)
{
  std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")\n";
}

void f(Button&amp; button)
{
  button.doOnClick(&amp;printCoordinates);
}
</pre>
</td>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">
class Button 
{
  typedef <code class="computeroutput"><a class="link" href="../boost/signalN.html" title="Class template signalN">boost::signal2</a></code>&lt;void,int,int&gt; OnClick;

public:
  void doOnClick(const OnClick::slot_type&amp; slot);

private:
  OnClick onClick;
};

void Button::doOnClick(
      const OnClick::slot_type&amp; slot
    )
{
  onClick.<code class="computeroutput"><a class="link" href="../boost/signalN.html#id417694-bb">connect</a></code>(slot);
}

void printCoordinates(long x, long y)
{
  std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")\n";
}

void f(Button&amp; button)
{
  button.doOnClick(&amp;printCoordinates);
}
</pre>
</td>
</tr></tbody>
</table></div>
<p>The <code class="computeroutput">doOnClick</code> method is now functionally equivalent
to the <code class="computeroutput">connect</code> method of the <code class="computeroutput">onClick</code>
signal, but the details of the <code class="computeroutput">doOnClick</code> method can be
hidden in an implementation detail file.</p>

<p><code class="computeroutput">doOnClick</code> 方法现在功能上等效于
<code class="computeroutput">onClick</code> 信号的
<code class="computeroutput">connect</code> 方法，
但是 <code class="computeroutput">doOnClick</code> 
方法的细节可以隐藏于细节实现文件中。
</p>

</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1279460"></a>Example: Document-View</h3>

<h3 class="title">
<a name="id1279460"></a>例子：文档-视图</h3>

</div></div></div>

<p>Signals can be used to implement flexible Document-View
  architectures. The document will contain a signal to which each of
  the views can connect. The following <code class="computeroutput">Document</code> class
  defines a simple text document that supports mulitple views. Note
  that it stores a single signal to which all of the views will be
  connected.</p>
  
<p>信号可用于实现灵活的文档-视图（Document-View）架构。
  
  文档包含一个信号，而每个视图连接该信号。
  
  下面的 <code class="computeroutput">Document</code> 
  类定义了一个简单的支持多视图的文本文档。
  
  注意它保存了一个单一的信号，所有视图都连接到该信号。
  </p>
  
<pre class="programlisting">class Document
{
public:
    typedef boost::signal&lt;void (bool)&gt;  signal_t;
    typedef boost::signals::connection  connection_t;

public:
    Document()
    {}

    connection_t connect(signal_t::slot_function_type subscriber)
    {
        return m_sig.connect(subscriber);
    }

    void disconnect(connection_t subscriber)
    {
        subscriber.disconnect();
    }

    void append(const char* s)
    {
        m_text += s;
        m_sig(true);
    }

    const std::string&amp; getText() const
    {
        return m_text;
    }

private:
    signal_t    m_sig;
    std::string m_text;
};</pre>
<p>Next, we can define a <code class="computeroutput">View</code> base class from which
  views can derive. This isn't strictly required, but it keeps the
  Document-View logic separate from the logic itself. Note that the
  constructor just connects the view to the document and the
  destructor disconnects the view.</p>

<p>接下来，我们可以定义视图的基类
  <code class="computeroutput">View</code>。

  这并非严格需要，但它能让文档-视图的逻辑与逻辑本身分离。
  
  注意构造函数仅仅连接视图到文档，而析构函数断开视图。
  </p>

<pre class="programlisting">
class View
{
public:
    View(Document&amp; m)
        : m_document(m)
    {
        m_connection = m_document.connect(boost::bind(&amp;View::refresh, this, _1));
    }

    virtual ~View()
    {
        m_document.disconnect(m_connection);
    }

    virtual void refresh(bool bExtended) const = 0;

protected:
    Document&amp;               m_document;

private:
    Document::connection_t  m_connection;
};
  </pre>
<p>Finally, we can begin to define views. The
  following <code class="computeroutput">TextView</code> class provides a simple view of the
    document text.</p>
    
<p>最后，我们可以开始定义视图。
  
  下面的 <code class="computeroutput">TextView</code>
  类提供了文档文本的一个简单视图。
  </p>
    
<pre class="programlisting">class TextView : public View
{
public:
    TextView(Document&amp; doc)
        : View(doc)
    {}

    virtual void refresh(bool bExtended) const
    {
        std::cout &lt;&lt; "TextView: " &lt;&lt; m_document.getText() &lt;&lt; std::endl;
    }
};</pre>
<p>Alternatively, we can provide a view of the document
    translated into hex values using the <code class="computeroutput">HexView</code>
    view:</p>
    
<p>此外，我们可以提供文档翻译成16进制后的视图，
    如 <code class="computeroutput">HexView</code> 视图：
    </p>
    
<pre class="programlisting">class HexView : public View
{
public:
    HexView(Document&amp; doc)
        : View(doc)
    {}

    virtual void refresh(bool bExtended) const
    {
        const std::string&amp;  s = m_document.getText();

        std::cout &lt;&lt; "HexView:";

        for (std::string::const_iterator it = s.begin(); it != s.end(); ++it)
            std::cout &lt;&lt; ' ' &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(*it);

        std::cout &lt;&lt; std::endl;
    }
};</pre>
<p>To tie the example together, here is a
  simple <code class="computeroutput">main</code> function that sets up two views and then
    modifies the document:</p>
    
<p>为了把例子串起来，有个简单的
  <code class="computeroutput">main</code> 
  函数，它建立了两个视图，然后更改文档：
    </p>
    
<pre class="programlisting">int main(int argc, char* argv[])
{
    Document    doc;
    TextView    v1(doc);
    HexView     v2(doc);

    doc.append(argc == 2 ? argv[1] : "Hello world!");
    return 0;
}</pre>
<p>The complete example source, contributed by Keith MacDonald,
    is available in <a href="../../../libs/signals/example/doc_view.cpp" target="_top"><code class="computeroutput">libs/signals/example/doc_view.cpp</code></a>.</p>

<p>完整的例程源码，由 Keith MacDonald 提供，在
    <a href="../../../libs/signals/example/doc_view.cpp" target="_top"><code class="computeroutput">libs/signals/example/doc_view.cpp</code></a>。
    </p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id1279626"></a>Linking against the Signals library</h3>

<h3 class="title">
<a name="id1279626"></a>链接信号库</h3>

</div></div></div>

<p>Part of the Boost.Signals library is compiled into a binary
  library that must be linked into your application to use
  Signals. Please refer to
    the <a href="../../../more/getting_started.html" target="_top">Getting Started</a>
  guide. You will need to link against the <code class="computeroutput">boost_signals</code>
  library.</p>

<p>Boost.Signals 库要编译成二进制库，
  为使用信号库，应用程序必须链接该二进制库。
  请参考
    <a href="../../../more/getting_started.html" target="_top">Getting Started</a>
  指导。
  你将需要链接 <code class="computeroutput">boost_signals</code> 库。
  </p>

</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"><p><small>Last revised: January 29, 2007 at 15:05:29 -0500</small></p></td>
<td align="right"><div class="copyright-footer">Copyright &copy; 2001-2004 Douglas Gregor<p>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <code class="filename">LICENSE_1_0.txt</code> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)</p>

      <p>翻译：<a href="http://blog.csdn.net/jq0123">金庆</a></p>
      <p>译文更新：2009.6.5</p>
    
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../signals.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../signals.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

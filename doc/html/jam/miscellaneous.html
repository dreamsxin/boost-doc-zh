<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Miscellaneous</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../jam.html" title="Chapter&nbsp;27.&nbsp;Boost.Jam : 3.1.16">
<link rel="prev" href="language.html" title="Language">
<link rel="next" href="history.html" title="History"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="language.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../jam.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="history.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="jam.miscellaneous"></a><a class="link" href="miscellaneous.html" title="Miscellaneous">Miscellaneous 杂项</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="miscellaneous.html#jam.miscellaneous.diagnostics">Diagnostics 诊断</a></span></dt>
<dt><span class="section"><a href="miscellaneous.html#jam.miscellaneous.bugs__limitations">Bugs, Limitations 缺陷和限制</a></span></dt>
<dt><span class="section"><a href="miscellaneous.html#jam.miscellaneous.fundamentals">Fundamentals 基本原理</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="jam.miscellaneous.diagnostics"></a><a class="link" href="miscellaneous.html#jam.miscellaneous.diagnostics" title="Diagnostics">Diagnostics 诊断</a>
</h3></div></div></div>
<p>
        In addition to generic error messages, <code class="literal">bjam</code> may emit one
        of the following:<br>除了通常的错误信息，<code class="literal">bjam</code> 可能还会发出以下信息：
      </p>
<pre class="programlisting">warning: unknown rule X</pre>
<p>
        A rule was invoked that has not been defined with an "<code class="literal">actions</code>"
        or "<code class="literal">rule</code>" statement.<br>表示被调用的规则没有用 "<code class="literal">actions</code>" 或 "<code class="literal">rule</code>" 语句定义。
      </p>
<pre class="programlisting">using N temp target(s)</pre>
<p>
        Targets marked as being temporary (but nonetheless present) have been found.<br>找到标记为临时的(但却是存在的)目标。
      </p>
<pre class="programlisting">updating N target(s)</pre>
<p>
        Targets are out-of-date and will be updated.<br>目标过期，将被更新。
      </p>
<pre class="programlisting">can't find N target(s)</pre>
<p>
        Source files can't be found and there are no actions to create them.<br>不能找到源文件，且没有动作创建它们。
      </p>
<pre class="programlisting">can't make N target(s)</pre>
<p>
        Due to sources not being found, other targets cannot be made.<br>由于源文件未找到，其它目标不能构建。
      </p>
<pre class="programlisting">warning: X depends on itself</pre>
<p>
        A target depends on itself either directly or through its sources.<br>目标直接或通过它的源依赖于它自己本身。
      </p>
<pre class="programlisting">don't know how to make X</pre>
<p>
        A target is not present and no actions have been defined to create it.<br>目标不存在且没有定义动作来创建它。
      </p>
<pre class="programlisting">X skipped for lack of Y</pre>
<p>
        A source failed to build, and thus a target cannot be built.<br>源文件构建失败，因此目标不能构建。
      </p>
<pre class="programlisting">warning: using independent target X</pre>
<p>
        A target that is not a dependency of any other target is being referenced
        with <code class="literal">$(&lt;)</code> or <code class="literal">$(&gt;)</code>.<br>某个被 <code class="literal">$(&lt;)</code> 或 <code class="literal">$(&gt;)</code> 引用的目标不是其它目标的依赖物。
      </p>
<pre class="programlisting">X removed</pre>
<p>
        <code class="literal">BJam</code> removed a partially built target after being interrupted.<br><code class="literal">BJam</code> 在中断后删除了一部分构建目标。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="jam.miscellaneous.bugs__limitations"></a><a class="link" href="miscellaneous.html#jam.miscellaneous.bugs__limitations" title="Bugs, Limitations">Bugs, Limitations 缺陷和限制</a>
</h3></div></div></div>
<p>
        For parallel building to be successful, the dependencies among files must
        be properly spelled out, as targets tend to get built in a quickest-first
        ordering. Also, beware of un-parallelizable commands that drop fixed-named
        files into the current directory, like <code class="literal">yacc(1)</code> does.<br>为了成功进行并发构建，文件的依赖关系必须正确说明，以使目标以尽可能快的顺序进行构建。另外，小心留意不可并发的命令，它们会删除当前目录中的固定名字的文件，象 <code class="literal">yacc(1)</code> 所做的。
      </p>
<p>
        A poorly set <code class="literal">$(JAMSHELL)</code> is likely to result in silent
        failure.<br>对 <code class="literal">$(JAMSHELL)</code> 设置得不好很可能会导致无声无息的失败。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="jam.miscellaneous.fundamentals"></a><a class="link" href="miscellaneous.html#jam.miscellaneous.fundamentals" title="Fundamentals">Fundamentals 基本原理</a>
</h3></div></div></div>
<p>
        This section is derived from the official Jam documentation and from experience
        using it and reading the Jambase rules. We repeat the information here mostly
        because it is essential to understanding and using Jam, but is not consolidated
        in a single place. Some of it is missing from the official documentation
        altogether. We hope it will be useful to anyone wishing to become familiar
        with Jam and the Boost build system.<br>本
章源自于 Jam 的官方文档和使用它的经验以及对 Jambase 规则的阅读。我们在此重复这些信息，主要是因为它们对于理解和使用 Jam
是必需的，但它们并未被整理到一起。其中有些还是官方文档中没有的。我们希望它们对那些希望熟练掌握 Jam 和 Boost build
系统的用户有所帮助。 </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Jam "<code class="literal">rules</code>" are actually simple procedural
          entities. Think of them as functions. Arguments are separated by colons.<br>
          Jam "<code class="literal">rules</code>" 实际上是简单的程序实体。将它们视为函数。参数以冒号分隔。
        </li>
<li>
          A Jam <span class="bold"><strong>target</strong></span> is an abstract entity identified
          by an arbitrary string. The build-in <code class="literal">DEPENDS</code> rule creates
          a link in the dependency graph between the named targets.<br>Jam <span class="bold"><strong>目标</strong></span> 是一个由任意字符串标识的抽象实体。内建的 <code class="literal">DEPENDS</code> 规则在依赖关系图中创建命名目标之间的链接。
        </li>
<li>
          Note that the original Jam documentation for the built-in <code class="literal">INCLUDES</code>
          rule is incorrect: <code class="literal">INCLUDES <span class="emphasis"><em>targets1</em></span> : <span class="emphasis"><em>targets2</em></span></code>
          causes everything that depends on a member of <span class="emphasis"><em>targets1</em></span>
          to depend on all members of <span class="emphasis"><em>targets2</em></span>. It does this
          in an odd way, by tacking <span class="emphasis"><em>targets2</em></span> onto a special
          tail section in the dependency list of everything in <span class="emphasis"><em>targets1</em></span>.
          It seems to be OK to create circular dependencies this way; in fact, it
          appears to be the "right thing to do" when a single build action
          produces both <span class="emphasis"><em>targets1</em></span> and <span class="emphasis"><em>targets2</em></span>.<br>注意，旧的 Jam 文档对于内建的 <code class="literal">INCLUDES</code>
          规则的描述是不正确的：<code class="literal">INCLUDES <span class="emphasis"><em>targets1</em></span> : <span class="emphasis"><em>targets2</em></span></code> 会导致依赖于 <span class="emphasis"><em>targets1</em></span> 某一成员的任何东西依赖于 <span class="emphasis"><em>targets2</em></span> 的所有成员。它是以一种奇特的方式来实现的，通过将 <span class="emphasis"><em>targets2</em></span> 作为一个特殊尾节增加到 <span class="emphasis"><em>targets1</em></span> 各个成员的依赖关系列表中。以这种方法创建循环依赖关系似乎是OK的；事实上，当单个构建动作同时生成 <span class="emphasis"><em>targets1</em></span> 和 <span class="emphasis"><em>targets2</em></span> 时，它看来是"做了正确的事情"。
        </li>
<li>
          When a rule is invoked, if there are <code class="literal">actions</code> declared
          with the same name as the rule, the actions are added to the updating actions
          for the target identified by the rule's first argument. It is actually
          possible to invoke an undeclared rule if corresponding actions are declared:
          the rule is treated as empty.<br>在一个规则被调用时，如果存在与该规则同名的 <code class="literal">actions</code>，则该动作会被增加到由规则的第一个参数所标识的目标的更新动作中。如果相应的动作被声明，实际上就有可能会调用一个未声明的规则：该规则被视为空规则。
        </li>
<li>
          Targets (other than <code class="literal">NOTFILE</code> targets) are associated
          with paths in the file system through a process called binding. Binding
          is a process of searching for a file with the same name as the target (sans
          grist), based on the settings of the target-specific <code class="literal">SEARCH</code>
          and <code class="literal">LOCATE</code> variables.<br>目标(除了 <code class="literal">NOTFILE</code> 目标以外)被通过一个称为绑定的过程关联至文件系统中的路径。绑定是查找一个与目标具有相同名字的文件(无 grist)的过程，它基于特定目标的 <code class="literal">SEARCH</code> 和 <code class="literal">LOCATE</code> 变量。
        </li>
<li>
          In addition to local and global variables, jam allows you to set a variable
          <code class="literal">on</code> a target. Target-specific variable values can usually
          not be read, and take effect only in the following contexts:<br>除了局部变量和全局变量，jam 还允许你在一个目标上设置变量。特定目标变量的值通常不能被读出，仅在以下上下文中生效：
          <div class="itemizedlist"><ul type="circle">
<li>
              In updating actions, variable values are first looked up <code class="literal">on</code>
              the target named by the first argument (the target being updated).
              Because Jam builds its entire dependency tree before executing actions,
              Jam rules make target-specific variable settings as a way of supplying
              parameters to the corresponding actions.<br>在更新动作中，变量的值首先在由第一个参数所给出的名字的目标(被更新的目标)上进行查找。因为 Jam 在执行动作之前构建完整的依赖关系树，Jam 的规则将特定目标变量作为为相应动作提供参数的方法。
            </li>
<li>
              Binding is controlled <span class="emphasis"><em>entirely</em></span> by the target-specific
              setting of the <code class="literal">SEARCH</code> and <code class="literal">LOCATE</code>
              variables, as described here.<br>绑定完全是由特定目标所设置的 <code class="literal">SEARCH</code> 和 <code class="literal">LOCATE</code>
              变量所控制的，如上所述。
            </li>
<li>
              In the special rule used for header file scanning, variable values
              are first looked up <code class="literal">on</code> the target named by the rule's
              first argument (the source file being scanned).<br>在用于头文件扫描的特殊规则中，变量的值首先在由规则的第一个参数所给出的名字的目标(被扫描的源文件)上进行查找。
            </li>
</ul></div>
</li>
<li>
          The "bound value" of a variable is the path associated with the
          target named by the variable. In build actions, the first two arguments
          are automatically replaced with their bound values. Target-specific variables
          can be selectively replaced by their bound values using the <code class="literal">bind</code>
          action modifier.<br>一个变量的"绑定值"即与该变量所命名的目标相关联的路径。在构建动作中，头两个参数会自动替换为它们的绑定值。特定目标变量可以用&nbsp;<code class="literal">bind</code>
 动作修改符可选择地替换为它们的绑定值。
        </li>
<li>
          Note that the term "binding" as used in the Jam documentation
          indicates a phase of processing that includes three sub-phases: <span class="emphasis"><em>binding</em></span>
          (yes!), update determination, and header file scanning. The repetition
          of the term "binding" can lead to some confusion. In particular,
          the Modifying Binding section in the Jam documentation should probably
          be titled "Modifying Update Determination".<br>注意，术语"绑定"和在 Jam 文档中所使用的一样，表示一个包含三个子阶段的处理阶段，这三个子阶段是：<span class="emphasis"><em>绑定</em></span>(没错!)、更新决定和头文件扫描。重复使用术语"绑定"可能会引起一些混乱。特别地，Jam 文档中的"修改绑定"一节的标题可以改为"修改更新决定"。
        </li>
<li>
          "Grist" is just a string prefix of the form &lt;<span class="emphasis"><em>characters</em></span>&gt;.
          It is used in Jam to create unique target names based on simpler names.
          For example, the file name "<code class="literal">test.exe</code>" may
          be used by targets in separate subprojects, or for the debug and release
          variants of the "same" abstract target. Each distinct target
          bound to a file called "test.exe" has its own unique grist prefix.
          The Boost build system also takes full advantage of Jam's ability to divide
          strings on grist boundaries, sometimes concatenating multiple gristed elements
          at the beginning of a string. Grist is used instead of identifying targets
          with absolute paths for two reasons:<br>
          "Grist" 只是一个形如 &lt;<span class="emphasis"><em>characters</em></span>&gt; 的字符串前缀。在 Jam 中它被用来基于简单的名字创建唯一的目标名。例如，文件名 "<code class="literal">test.exe</code>"
可能在单独的子项目中被用作目标，或者用作"同一个"抽象目标的调试版和发布版。每一个绑定到 "test.exe" 文件的特定目标都有唯一的
grist 前缀以。Boost build 系统还充分利用了 Jam 的功能，将字符串按 grist 边界划分，有时则将多个 gristed
元素连接在字符串的开始。Grist 被用于替代绝对路径标识目标有两个原因：
          <div class="orderedlist"><ol type="1">
<li>
              The location of targets cannot always be derived solely from what the
              user puts in a Jamfile, but sometimes depends also on the binding process.
              Some mechanism to distinctly identify targets with the same name is
              still needed.<br>目标的位置并不总是可以从用户在 Jamfile 中输入的字符串单独获得，不过有时也依赖于绑定过程。还是需要一些机制来用相同的名字清楚地标识目标。
            </li>
<li>
              Grist allows us to use a uniform abstract identifier for each built
              target, regardless of target file location (as allowed by setting ALL_LOCATE_TARGET).<br>
              Grist 允许我们对每个构建目标使用统一的抽象标识符，而不管目标文件的位置(就象通过设置 ALL_LOCATE_TARGET 那样)。
            </li>
</ol></div>
</li>
<li>
          When grist is extracted from a name with $(var:G), the result includes
          the leading and trailing angle brackets. When grist is added to a name
          with $(var:G=expr), existing grist is first stripped. Then, if expr is
          non-empty, leading &lt;s and trailing &gt;s are added if necessary to form
          an expression of the form &lt;expr2&gt;; &lt;expr2&gt; is then prepended.<br>当
从一个带有 $(var:G) 的名字中取出 grist 时，结果将包含开始和结尾的尖括号。当 grist 被增加到一个带有
$(var:G=expr) 的名字中时，首先去掉已有的 grist。然后，如果 expr 为非空，则当需要时将开始的 &lt;s 和结尾的
&gt;s&nbsp;加入，形成一个形如 &lt;expr2&gt; 的表达式；&lt;expr2&gt; 就是所要的。
        </li>
<li>
          When Jam is invoked it imports all environment variable settings into corresponding
          Jam variables, followed by all command-line (-s...) variable settings.
          Variables whose name ends in PATH, Path, or path are split into string
          lists on OS-specific path-list separator boundaries (e.g. ":"
          for UNIX and ";" for Windows). All other variables are split
          on space (" ") boundaries. Boost Jam modifies that behavior by
          allowing variables to be quoted.<br>当 Jam 被调用时，它导入所有环境变量并设置到相应的
          Jam 变量中，然后是所有的命令行(-s...)变量设置。那些名字以 PATH, Path, 或 path 结尾的变量被按照OS的路径列表分隔符(如 UNIX 为 ":"，而 Windows
          为 ";")分解为字符串列表。所有其它变量被按照空格(" ")分解。Boost Jam 修改了这一行为，允许变量用引号引起来。
        </li>
<li>
          A variable whose value is an empty list or which consists entirely of empty
          strings has a negative logical value. Thus, for example, code like the
          following allows a sensible non-empty default which can easily be overridden
          by the user:<br>一个值为空列表或由多个空串组成的变量具有否定的逻辑值。例如，以下代码使得一个非空的缺省值可以很容易地被用户覆写： 
<pre class="programlisting"><span class="identifier">MESSAGE</span> <span class="special">?\=</span> <span class="identifier">starting</span> <span class="identifier">jam</span><span class="special">...</span> <span class="special">;</span>
<span class="keyword">if</span> #<span class="special">(</span><span class="identifier">MESSAGE</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">ECHO</span> <span class="identifier">The</span> <span class="identifier">message</span> <span class="identifier">is</span><span class="special">:</span> #<span class="special">(</span><span class="identifier">MESSAGE</span><span class="special">)</span> <span class="special">;</span> <span class="special">}</span>
</pre>
          If the user wants a specific message, he invokes jam with <code class="literal">"-sMESSAGE=message
          text"</code>. If he wants no message, he invokes jam with <code class="literal">-sMESSAGE=</code>
          and nothing at all is printed.<br>如果用户想要一个特殊的信息，可以用 <code class="literal">"-sMESSAGE=message
          text"</code> 来调用 jam。如果想不要信息，则以 <code class="literal">-sMESSAGE=</code>
          调用 jam，这样就没有东西打印出来了。
        </li>
<li>
          The parsing of command line options in Jam can be rather unintuitive, with
          regards to how other Unix programs accept options. There are two variants
          accepted as valid for an option:<br>在 Jam 中的命令行选项分析可能有点违反直觉，与其它的 Unix 程序接受选项的方式相比。对于一个选项，以下两种变体都是有效的：
          <div class="orderedlist"><ol type="1">
<li>
<code class="literal">-xvalue</code>, 和
            </li>
<li>
<code class="literal">-x value</code>.
            </li>
</ol></div>
</li>
</ul></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2003-2007 Rene Rivera, David Abrahams, Vladimir Prus<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="language.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../jam.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="history.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Reference（参考）</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../typeof.html" title="Chapter 19. Boost.Typeof">
<link rel="prev" href="tuto.html" title=" Tutorial">
<link rel="next" href="other.html" title=" Other considerations and tips">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tuto.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../typeof.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="other.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="typeof.refe"></a>Reference（参考）</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="refe.html#typeof.auto">AUTO, AUTO_TPL</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.compl">COMPLIANT</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.incr">INCREMENT_REGISTRATION_GROUP</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.inte">INTEGRAL</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.limit_func">LIMIT_FUNCTION_ARITY</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.limit_size">LIMIT_SIZE</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.regtype">REGISTER_TYPE</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.regtemp">REGISTER_TEMPLATE</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.temp">TEMPLATE</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.typo">TYPEOF, TYPEOF_TPL</a></span></dt>
<dt><span class="section"><a href="refe.html#typeof.typn">TYPEOF_NESTED_TYPEDEF, TYPEOF_NESTED_TYPEDEF_TPL</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.auto"></a>AUTO, AUTO_TPL</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_AUTO</span></code> 宏模仿 C++ 中被提议的 <code class="computeroutput"><span class="keyword">auto</span></code> 关键字。</p>
<a name="auto.usage"></a><h4><a name="id1917263"></a>用法</h4>
<pre class="programlisting">
<span class="identifier">BOOST_AUTO</span><span class="special">(</span><span class="identifier">var</span><span class="special">,</span><span class="identifier">expr</span><span class="special">)</span>
<span class="identifier">BOOST_AUTO_TPL</span><span class="special">(</span><span class="identifier">var</span><span class="special">,</span><span class="identifier">expr</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b>参数</b></p>
<dl>
<dt><span class="term">var</span></dt>
<dd>一个被表达式初始化的变量</dd>
<dt><span class="term">expr</span></dt>
<dd>一个合法的 C++ 表达式</dd>
</dl>
</div>
<a name="auto.remarks"></a><h4><a name="id1917360"></a>备注</h4>
<p>如果你要在模板上下文中使用 <code class="computeroutput"><span class="keyword">auto</span></code>，请使用 <code class="computeroutput"><span class="identifier">BOOST_AUTO_TPL</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span></code>，它可以处理 <code class="computeroutput"><span class="keyword">auto</span></code> 表达式中的 <code class="computeroutput"><span class="keyword">typename</span></code> 关键字。</p>
<a name="auto.sample_code"></a><h4><a name="id1917428"></a>示例代码</h4>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> 
<span class="special">{</span>
    <span class="identifier">length</span><span class="special">::</span><span class="identifier">meter</span> <span class="identifier">a</span><span class="special">(</span><span class="number">5</span><span class="special">);</span>
    <span class="identifier">force</span><span class="special">::</span><span class="identifier">newton</span> <span class="identifier">b</span><span class="special">(</span><span class="number">6</span><span class="special">);</span>
    <span class="identifier">BOOST_AUTO</span><span class="special">(</span><span class="identifier">c</span><span class="special">,</span> <span class="identifier">a</span> <span class="special">*</span> <span class="identifier">b</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.compl"></a>COMPLIANT</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF_COMPLIANT</span></code> 宏可以用于强加仿真方式。如果你的编译器在缺省情况下使用其它方式（诸如原生 <code class="computeroutput"><span class="identifier">typeof</span></code> 或微软特有的诀窍），但是你有需要使用仿真方式，比如为了可移植性的原因，你就可以定义它。</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.incr"></a>INCREMENT_REGISTRATION_GROUP</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP</span></code> 宏确保在不同的头文件中的类型注册接受唯一的标识符。</p>
<a name="incr.usage"></a><h4><a name="id1917636"></a>用法</h4>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="identifier">BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP</span><span class="special">()</span>
</pre>
<a name="incr.remarks"></a><h4><a name="id1917669"></a>备注</h4>
<p>在每一个执行注册的 cpp/hpp 文件中，在任何注册之前，指定一次。</p>
<a name="incr.sample_code"></a><h4><a name="id1917687"></a>示例代码</h4>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="identifier">BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP</span><span class="special">()</span>

<span class="keyword">class</span> <span class="identifier">X</span><span class="special">;</span> 
<span class="identifier">BOOST_TYPEOF_REGISTER_TYPE</span><span class="special">(</span><span class="identifier">X</span><span class="special">)</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.inte"></a>INTEGRAL</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF_INTEGRAL</span></code> 宏用于使用 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span></code> 注册整模板参数的时候。</p>
<p>对于<code class="computeroutput"><span class="keyword">enum</span></code>s 和附属的整模板参数是很有用的。</p>
<a name="inte.usage"></a><h4><a name="id1917800"></a>用法</h4>
<pre class="programlisting">
<span class="identifier">BOOST_TYPEOF_INTEGRAL</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b>参数</b></p>
<dl>
<dt><span class="term">x</span></dt>
<dd>一个全修饰的整类型或枚举</dd>
</dl>
</div>
<a name="inte.remarks"></a><h4><a name="id1917852"></a>备注</h4>
<p>对于内建类型（int, bool, long, unsigned long, 等）实现了一个简短的语法，不支持其它非类型模板参数（譬如指向成员的指针）。</p>
<a name="inte.sample_code"></a><h4><a name="id1917871"></a>示例代码</h4>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="identifier">BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP</span><span class="special">()</span>

<span class="keyword">namespace</span> <span class="identifier">foo</span> 
<span class="special">{</span>
    <span class="keyword">enum</span> <span class="identifier">color</span> <span class="special">{</span><span class="identifier">red</span><span class="special">,</span> <span class="identifier">green</span><span class="special">,</span> <span class="identifier">blue</span><span class="special">};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="identifier">color</span> <span class="identifier">C0</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">class_with_enum</span> <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">,</span><span class="identifier">T0</span> <span class="identifier">I1</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">class_with_dependent_non_type</span> <span class="special">{};</span>
<span class="special">}</span>

<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">class_with_enum</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">BOOST_TYPEOF_INTEGRAL</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">color</span><span class="special">))</span>
    <span class="special">(</span><span class="keyword">typename</span><span class="special">)</span>
    <span class="special">)</span>
    
<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">class_with_dependent_non_type</span><span class="special">,</span>
    <span class="special">(</span><span class="keyword">typename</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">BOOST_TYPEOF_INTEGRAL</span><span class="special">(</span><span class="identifier">P0</span><span class="special">))</span>
    <span class="special">)</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.limit_func"></a>LIMIT_FUNCTION_ARITY</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF_LIMIT_FUNCTION_ARITY</span></code> 宏定义了可以支持的函数参数的个数，适用于函数，函数指针，函数引用，以及成员函数指针。缺省值为 10，如果你想要 Typeof 库处理更多参数的函数，就要重新定义。</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.limit_size"></a>LIMIT_SIZE</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF_LIMIT_SIZE</span></code> 宏定义了用于编码一个类型的编译期序列的大小。缺省值为 50。如果你想要 Typeof 库处理更复杂的类型，可以增加这个数值，但是这可能是你的编译器支持的模板参数的最大数量。另一方面，如果你只是使用很简单的类型，减少这个数值可以帮助你提升 boost 的编译期性能。</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.regtype"></a>REGISTER_TYPE</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF_REGISTER_TYPE</span></code> 宏将一个类型的存在通知 Typeof 库。</p>
<a name="regtype.usage"></a><h4><a name="id1918314"></a>用法</h4>
<pre class="programlisting">
<span class="identifier">BOOST_TYPEOF_REGISTER_TYPE</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b>参数</b></p>
<dl>
<dt><span class="term">x</span></dt>
<dd>一个全修饰的类型</dd>
</dl>
</div>
<a name="regtype.remarks"></a><h4><a name="id1918366"></a>备注</h4>
<p>必须用于全局名字空间</p>
<a name="regtype.sample_code"></a><h4><a name="id1918383"></a>示例代码</h4>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="identifier">BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP</span><span class="special">()</span>

<span class="keyword">namespace</span> <span class="identifier">foo</span> 
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">bar</span> <span class="special">{};</span>
    <span class="keyword">enum</span> <span class="identifier">color</span> <span class="special">{</span><span class="identifier">red</span><span class="special">,</span> <span class="identifier">green</span><span class="special">,</span> <span class="identifier">blue</span><span class="special">};</span>
<span class="special">}</span>

<span class="identifier">BOOST_TYPEOF_REGISTER_TYPE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">bar</span><span class="special">)</span>
<span class="identifier">BOOST_TYPEOF_REGISTER_TYPE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">color</span><span class="special">)</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.regtemp"></a>REGISTER_TEMPLATE</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span></code> 宏将一个模板的存在通知 Typeof 库，并描述它的参数。</p>
<a name="regtemp.usage"></a><h4><a name="id1918578"></a>用法</h4>
<pre class="programlisting">
<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">x</span><span class="special">,</span> <span class="identifier">n</span><span class="special">)</span>
<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">x</span><span class="special">,</span> <span class="identifier">seq</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b>参数</b></p>
<dl>
<dt><span class="term">x</span></dt>
<dd>一个全修饰的模板</dd>
<dt><span class="term">n</span></dt>
<dd>模板参数的数量。只有所有的模板参数都是 typenames 时，才是合法的</dd>
<dt><span class="term">seq</span></dt>
<dd>一个模板参数的序列。在提供整类型或 template template parameters（模板模板参数）时必须使用</dd>
</dl>
</div>
<a name="regtemp.remarks"></a><h4><a name="id1918689"></a>备注</h4>
<p>必须用于全局名字空间。</p>
<p>库允许带有类型，整类型，以及模板模板参数的模板注册：</p>
<div class="itemizedlist"><ul type="disc">
<li>一个 type template parameter（类型模板参数）是用 <code class="computeroutput"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span></code> 或 <code class="computeroutput"><span class="special">(</span><span class="keyword">typename</span><span class="special">)</span></code> 描述的序列中元素</li>
<li>一个显而易见的整类型模板参数可以通过简单地提供它的类型来描述，比如 <code class="computeroutput"><span class="special">(</span><span class="keyword">unsigned</span><span class="keyword">int</span><span class="special">)</span></code>。以下是被支持的显而易见的整类型：
          <div class="itemizedlist"><ul type="circle">
<li><code class="computeroutput"><span class="special">[</span><span class="keyword">signed</span><span class="special">/</span><span class="keyword">unsigned</span><span class="special">]</span><span class="keyword">char</span></code></li>
<li><code class="computeroutput"><span class="special">[</span><span class="keyword">unsigned</span><span class="special">]</span><span class="keyword">short</span></code></li>
<li><code class="computeroutput"><span class="special">[</span><span class="keyword">unsigned</span><span class="special">]</span><span class="keyword">int</span></code></li>
<li><code class="computeroutput"><span class="special">[</span><span class="keyword">unsigned</span><span class="special">]</span><span class="keyword">long</span></code></li>
<li><code class="computeroutput"><span class="keyword">unsigned</span></code></li>
<li><code class="computeroutput"><span class="keyword">bool</span></code></li>
<li><code class="computeroutput"><span class="identifier">size_t</span></code></li>
</ul></div>
</li>
<li>整类型的枚举和 typedefs 需要用 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_INTEGRAL</span></code> 宏显式描述，比如 <code class="computeroutput"><span class="special">(</span><span class="identifier">BOOST_TYPEOF_INTEGRAL</span><span class="special">(</span><span class="identifier">MyEnum</span><span class="special">))</span></code></li>
<li>template template parameters（模板模板参数）使用 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_TEMPLATE</span></code> 宏描述，比如：<code class="computeroutput"><span class="special">(</span><span class="identifier">BOOST_TYPEOF_TEMPLATE</span><span class="special">((</span><span class="keyword">class</span><span class="special">)(</span><span class="keyword">unsigned</span><span class="keyword">int</span><span class="special">)))</span></code>。在全部为类型参数的情况下，这可以简化为形如 <code class="computeroutput"><span class="special">(</span><span class="identifier">BOOST_TYPEOF_TEMPLATE</span><span class="special">(</span><span class="number">2</span><span class="special">))</span></code> 的样子。不支持嵌套的模板模板参数。</li>
</ul></div>
<a name="regtemp.sample_code"></a><h4><a name="id1919061"></a>示例代码</h4>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="identifier">BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP</span><span class="special">()</span>

<span class="keyword">namespace</span> <span class="identifier">foo</span> 
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">simple_template</span> <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T0</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">I1</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">class_with_integral_constant</span> <span class="special">{};</span>
<span class="special">}</span>

<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">simple_template</span><span class="special">,</span> <span class="number">2</span><span class="special">)</span>
<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">class_with_integral_constant</span><span class="special">,</span> <span class="special">(</span><span class="keyword">typename</span><span class="special">)(</span><span class="keyword">int</span><span class="special">))</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.temp"></a>TEMPLATE</h3></div></div></div>
<p>当注册 template template parameters（模板模板参数）时使用了 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span></code>，就需要使用 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_TEMPLATE</span></code> 宏。</p>
<a name="temp.usage"></a><h4><a name="id1919349"></a>用法</h4>
<pre class="programlisting">
<span class="identifier">BOOST_TYPEOF_TEMPLATE</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span>
<span class="identifier">BOOST_TYPEOF_TEMPLATE</span><span class="special">(</span><span class="identifier">seq</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b>参数</b></p>
<dl>
<dt><span class="term">n</span></dt>
<dd>模板参数的数量。只有所有的模板参数都是 typenames 时，才是合法的</dd>
<dt><span class="term">seq</span></dt>
<dd>一个模板参数的序列。当嵌套模板中有整常类型时必须使用</dd>
</dl>
</div>
<a name="temp.remarks"></a><h4><a name="id1919432"></a>备注</h4>
<p>不能用于注册嵌套 template template parameters（模板模板参数）。</p>
<a name="temp.sample_code"></a><h4><a name="id1919449"></a>示例代码</h4>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="identifier">BOOST_TYPEOF_INCREMENT_REGISTRATION_GROUP</span><span class="special">()</span>

<span class="keyword">namespace</span> <span class="identifier">foo</span> 
<span class="special">{</span>
    <span class="keyword">enum</span> <span class="identifier">color</span> <span class="special">{</span><span class="identifier">red</span><span class="special">,</span> <span class="identifier">green</span><span class="special">,</span> <span class="identifier">blue</span><span class="special">};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="identifier">color</span> <span class="identifier">C0</span><span class="special">,</span> <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">T1</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">nested_template_class</span> <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">char</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">T1</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">nested_with_integral</span> <span class="special">{};</span>
<span class="special">}</span>

<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">nested_template_class</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">color</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">BOOST_TYPEOF_TEMPLATE</span><span class="special">(</span><span class="number">1</span><span class="special">))</span> 
    <span class="special">)</span>
    
<span class="identifier">BOOST_TYPEOF_REGISTER_TEMPLATE</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">nested_with_integral</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">BOOST_TYPEOF_TEMPLATE</span><span class="special">((</span><span class="keyword">typename</span><span class="special">)(</span><span class="keyword">unsigned</span> <span class="keyword">char</span><span class="special">)))</span> 
    <span class="special">)</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.typo"></a>TYPEOF, TYPEOF_TPL</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">BOOST_TYPEOF</span></code> 宏推测一个表达式的类型，但是移除顶层修饰符，<code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code></p>
<a name="typo.usage"></a><h4><a name="id1919888"></a>用法</h4>
<pre class="programlisting">
<span class="identifier">BOOST_TYPEOF</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
<span class="identifier">BOOST_TYPEOF_TPL</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b>参数</b></p>
<dl>
<dt><span class="term">expr</span></dt>
<dd>一个可以绑定到 const T&amp; 的合法的 C++ 表达式</dd>
</dl>
</div>
<a name="typo.remarks"></a><h4><a name="id1919960"></a>备注</h4>
<p>如果你想要则模板上下文中使用 <code class="computeroutput"><span class="identifier">typeof</span></code>，请使用 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_TPL</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span></code>，它可以处理 <code class="computeroutput"><span class="identifier">typeof</span></code> 表达式中的 <code class="computeroutput"><span class="keyword">typename</span></code>。</p>
<a name="typo.sample_code"></a><h4><a name="id1920027"></a>示例代码</h4>
<pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">B</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">result_of_conditional</span> 
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">BOOST_TYPEOF_TPL</span><span class="special">(</span><span class="keyword">true</span><span class="special">?</span><span class="identifier">A</span><span class="special">():</span><span class="identifier">B</span><span class="special">())</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">B</span><span class="special">&gt;</span>
<span class="identifier">result_of_conditional</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">min</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="identifier">a</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">B</span><span class="special">&amp;</span> <span class="identifier">b</span><span class="special">)</span> 
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">a</span> <span class="special">&lt;</span> <span class="identifier">b</span> <span class="special">?</span> <span class="identifier">a</span> <span class="special">:</span> <span class="identifier">b</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="typeof.typn"></a> TYPEOF_NESTED_TYPEDEF, TYPEOF_NESTED_TYPEDEF_TPL</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">TYPEOF_NESTED_TYPEDEF</span></code> 宏的工作方法和 'TYPEOF' 宏大体相同，但是弥补了几个编译器的缺陷。</p>
<a name="typn.usage"></a><h4><a name="id1920372"></a>用法</h4>
<pre class="programlisting">
<span class="identifier">BOOST_TYPEOF_NESTED_TYPEDEF</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span><span class="identifier">expr</span><span class="special">)</span>
<span class="identifier">BOOST_TYPEOF_NESTED_TYPEDEF_TPL</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span><span class="identifier">expr</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b>参数</b></p>
<dl>
<dt><span class="term">name</span></dt>
<dd>一个嵌套在 typeof 操作中内部的合法标识符</dd>
<dt><span class="term">expr</span></dt>
<dd>一个可以绑定到 const T&amp; 的合法的 C++ 表达式</dd>
</dl>
</div>
<a name="typn.remarks"></a><h4><a name="id1920470"></a>备注</h4>
<p>'typeof_nested_typedef' 将 'typeof' 操作嵌套在一个结构内。通过这样做，'typeof' 操作可以分为两步，这种方法可以避免编译器误解（特别是 VC7.1 和 VC8.0）。这样也可以移除由 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_LIMIT_SIZE</span></code> 强加的限制，并允许你在更大的表达式中使用 'typeof'。</p>
<p>如果你要在模板上下文中使用 <code class="computeroutput"><span class="identifier">typeof_nested_typedef</span></code>，请使用 <code class="computeroutput"><span class="identifier">BOOST_TYPEOF_NESTED_TYPEDEF_TPL</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span><span class="identifier">expr</span><span class="special">)</span></code>，它可以处理 <code class="computeroutput"><span class="identifier">typeof</span></code> 表达式中的 <code class="computeroutput"><span class="keyword">typename</span></code>。</p>
<p>'typeof_nested_typedef' 不能在函数/块范围内使用。</p>
<a name="typn.sample_code"></a><h4><a name="id1920569"></a>示例代码</h4>
<pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">B</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">result_of_conditional</span> 
<span class="special">{</span>
    <span class="identifier">BOOST_TYPEOF_NESTED_TYPEDEF_TPL</span><span class="special">(</span><span class="identifier">nested</span><span class="special">,</span><span class="keyword">true</span><span class="special">?</span><span class="identifier">A</span><span class="special">():</span><span class="identifier">B</span><span class="special">())</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">nested</span><span class="special">::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">B</span><span class="special">&gt;</span>
<span class="identifier">result_of_conditional</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">min</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="identifier">a</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">B</span><span class="special">&amp;</span> <span class="identifier">b</span><span class="special">)</span> 
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">a</span> <span class="special">&lt;</span> <span class="identifier">b</span> <span class="special">?</span> <span class="identifier">a</span> <span class="special">:</span> <span class="identifier">b</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
</div>
<table width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright  2004, 2005 Arkadiy Vertleyb, Peder Holt</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tuto.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../typeof.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="other.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>

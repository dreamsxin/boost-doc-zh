<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Overview</title>

<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../bbv2.html" title="Chapter&nbsp;28.&nbsp;Boost.Build V2 User Manual">
<link rel="prev" href="tutorial.html" title="Tutorial">
<link rel="next" href="tasks.html" title="Common tasks">
</head>
<body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="tutorial.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bbv2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="tasks.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="bbv2.advanced"></a>Overview 概览</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.jam_language">Boost.Jam
Language &nbsp;Boost.Jam语言</a></span></dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.configuration">Configuration
配置</a></span></dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.invocation">Invocation 调用</a></span></dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.targets">Declaring Targets
声明目标</a></span></dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.projects">Projects 工程</a></span></dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.build_process">The Build
Process 构建过程</a></span></dt>
</dl>
</div>
<p>This section will provide the information necessary to create
your own projects using Boost.Build. The information provided here is
relatively high-level, and <a class="xref" href="reference.html" title="Detailed reference">the
section called “Detailed reference”</a> as well as the on-line
help system must be used to obtain low-level documentation (see <a class="xref" href="advanced.html#bbv2.reference.init.options.help"><code class="option">--help</code></a>).<br>
这个章节为你提供了使用 Boost.Build 创建工程所需的信息。这里所提供的信息相对比较高层次，要获得底层的信息，则必须使用<a class="xref" href="reference.html" title="Detailed reference"> “详细参考”一节</a> 以及在线帮助系统。(请见 <a class="xref" href="advanced.html#bbv2.reference.init.options.help"><code class="option">--help</code></a>)。</p>
<p>Boost.Build actually consists of two parts - Boost.Jam, a
build engine with its own interpreted language, and Boost.Build itself,
implemented in Boost.Jam's language. The chain of events when you type <span class="command"><strong>bjam</strong></span>
on the command line is:<br>
Boost.Build 实际上包含两部分 - Boost.Jam，一个带有解释性语言的构建引擎，和用&nbsp;Boost.Jam
的语言实现的 Boost.Build 本身。当你在命令行敲入 <span class="command"><strong>bjam</strong></span>
时，发生的事件如下： </p>
<div class="orderedlist">
<ol type="1">
<li>
<p>Boost.Jam tries to find Boost.Build and loads the
top-level module. The exact process is described in <a class="xref" href="reference.html#bbv2.reference.init" title="Initialization">the
section called “Initialization”</a><br>
Boost.Jam 尝试查找 Boost.Build 并装入顶层模块。精确的过程在 <a class="xref" href="reference.html#bbv2.reference.init" title="Initialization">“初
始化”一节</a> 中描述。</p>
</li>
<li>
<p>The top-level module loads user-defined configuration
files, <code class="filename">user-config.jam</code>
and <code class="filename">site-config.jam</code>,
which define available toolsets.<br>
顶层模块装入用户自定义配置文件，<code class="filename">user-config.jam</code>
和 <code class="filename">site-config.jam</code>，它们定义
了可用的工具集。 </p>
</li>
<li>
<p>The Jamfile in the current directory is read. That in turn
might cause reading of further Jamfiles. As a result, a tree of
projects is created, with targets inside projects.<br>
读入当前目录中的 Jamfile。然后可能会读入更多的 Jamfiles。结果，一棵由工程中各个目标所组成的工程树被创建。</p>
</li>
<li>
<p>Finally, using the build request specified on the command
line, Boost.Build decides which targets should be built, and how. That
information is passed back to Boost.Jam, which takes care of actually
running commands.<br>
最后，使用在命令行中指定的构建请求，Boost.Build 决定要构建哪些目标以及如何构建。这些信息被回传给
Boost.Jam，后者负责实际运行命令。</p>
</li>
</ol>
</div>
<p> So, to be able to successfully use Boost.Build, you need to
know only four things:<br>
所以，要成功地使用 Boost.Build，你只需要知道以下四件事情： </p>
<div class="itemizedlist">
<ul type="disc">
<li>
<p><a class="link" href="advanced.html#bbv2.advanced.configuration" title="Configuration"> How to configure Boost.Build <br>
如何配置 Boost.Build</a></p>
</li>
<li>
<p><a class="link" href="advanced.html#bbv2.advanced.targets" title="Declaring Targets"> How to write declares targets in
Jamfiles <br>
如何在 Jamfiles 中声明目标</a></p>
</li>
<li>
<p><a class="link" href="advanced.html#bbv2.advanced.build_process" title="The Build Process"> How the build process works <br>
构建过程是如何工作的<br>
</a></p>
</li>
<li>
<p>Some Basics about the Boost.Jam language. See <a class="xref" href="advanced.html#bbv2.advanced.jam_language" title="Boost.Jam Language">the section called “Boost.Jam
Language”</a>.<br>
有关 Boost.Jam 语言的一些基础知识。参见 <a class="xref" href="advanced.html#bbv2.advanced.jam_language" title="Boost.Jam Language">“Boost.Jam 语言”一节</a>。 </p>
</li>
</ul>
</div>
<p> </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="bbv2.advanced.jam_language"></a>Boost.Jam
Language &nbsp;Boost.Jam语言</h3>
</div>
</div>
</div>
<p>This section will describe the basics of the Boost.Jam
language—just enough for writing Jamfiles. For more information, please
see the <a class="link" href="../">Boost.Jam</a>
documentation.<br>
本节描述 Boost.Jam 语言的基础—仅够用于编写 Jamfiles。更多的信息，请参见 <a class="link" href="../">Boost.Jam</a> 文档。 </p>
<p><a class="link" href="../">Boost.Jam</a>
has an interpreted, procedural language. On the lowest level, a <a class="link" href="../"> Boost.Jam</a> program
consists of variables and <a class="indexterm" name="id3902263"></a> <em class="firstterm">rules</em>
(the Jam term for function). They are grouped in modules—there's one
global module and a number of named modules. Besides that, a <a class="link" href="../">Boost.Jam</a> program
contains classes and class instances.<br>
<a class="link" href="../">Boost.Jam</a>
有一个解释性的过程语言。在最底层，<a class="link" href="../">Boost.Jam</a>
程序由变量和 <a class="indexterm" name="id3902263"></a>
<em class="firstterm">规则</em> ("函数"一词在 Jam
中的术语)组成。它们组成各个模块—有一个全局模块和多个命名模块。此外，<a class="link" href="../">Boost.Jam</a>
程序还包含类和类实例。</p>
<p>Syntantically, a <a class="link" href="../">Boost.Jam</a>
program consists of two kind of elements—keywords (which have a special
meaning to <a class="link" href="../">Boost.Jam</a>)
and literals. Consider this code:<br>
在语法上，<a class="link" href="../">Boost.Jam</a>
程序由两类元素组成—关键字(对于 <a class="link" href="../">Boost.Jam</a>
来说具有特殊的意义) 和普通文字。考虑以下代码： </p>
<pre class="programlisting">a = b ;</pre>
<p> which assigns the value <code class="literal">b</code>
to the variable <code class="literal">a</code>.
Here, <code class="literal">=</code> and <code class="literal">;</code> are keywords, while <code class="literal">a</code> and <code class="literal">b</code>
are literals.<br>
它将值 <code class="literal">b</code> 赋给变量 <code class="literal">a</code>。这里，<code class="literal">=</code>
和 <code class="literal">;</code> 是关键字，而 <code class="literal">a</code> 和 <code class="literal">b</code>
是普通文字。 </p>
<div class="warning">
<table summary="Warning" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/html/images/warning.png"></td>
<th align="left">Warning 警告</th>
</tr>
<tr>
<td align="left" valign="top">
<p>All syntax elements, even keywords, must be separated by
spaces. For example, omitting the space character before <code class="literal">;</code> will lead to a syntax error.</p>
<p>所有语法元素，包括关键字，都必须用空格分隔。例如，省略 <code class="literal">;</code>
前面的空格将导致语法错误。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> If you want to use a literal value that is the same as some
keyword, the value can be quoted:<br>
如果你想使用一个与某个关键字相同的文字，就要把它用引号引起来： </p>
<pre class="programlisting">a = "=" ;</pre>
<p> All variables in <a class="link" href="../">Boost.Jam</a>
have the same type—list of strings. To define a variable one assigns a
value to it, like in the previous example. An undefined variable is the
same as a variable with an empty value. Variables can be accessed using
the <code class="computeroutput">$(<em class="replaceable"><code>variable</code></em>)</code>
syntax. For example:<br>
在 <a class="link" href="../">Boost.Jam</a>
中的所有变量都具有相同的类型—字符串列表。要定义一个变量同时赋值给它，就象前面的例子那样。一个未定义的变量和一个具有空值的变量一样。变量可以用
<code class="computeroutput">$(<em class="replaceable"><code>variable</code></em>)</code>
语法来访问。例如： </p>
<pre class="programlisting">a = $(b) $(c) ;</pre>
<p> Rules are defined by specifying the rule name, the parameter
names, and the allowed size of the list value for each parameter.<br>
规则通过指定规则名、参数名及各个参数所允许的列表值大小来定义。 </p>
<pre class="programlisting">rule <em class="replaceable"><code>example</code></em><br>(<br><em class="replaceable"><code>parameter1</code></em> :<br> <em class="replaceable"><code>parameter2 ?</code></em> :<br> <em class="replaceable"><code>parameter3 +</code></em> :<br> <em class="replaceable"><code>parameter4 *</code></em><br>)<br>{<br>// body<br>}</pre>
<p> When this rule is called, the list passed as the first
argument must have exactly one value. The list passed as the second
argument can either have one value of be empty. The two remaining
arguments can be arbitrarily long, but the third argument may not be
empty.<br>
在调用这个规则时，传入的第一个参数的列表必须刚好包含一个值。第二个参数的列表则可以有一个值或者为空。其余两个参数可以是变长的，但第三个参数不能为
空。 </p>
<p>The overview of <a class="link" href="../">Boost.Jam</a>
language statements is given below:<br>
以下是 <a class="link" href="../">Boost.Jam</a>
语言的语句的一个概览： </p>
<pre class="programlisting">helper 1 : 2 : 3 ;<br>x = [ helper 1 : 2 : 3 ] ;</pre>
<p> This code calls the named rule with the specified arguments.
When the result of the call must be used inside some expression, you
need to add brackets around the call, like shown on the second line.<br>
这段代码以给定的参数调用命名规则。当调用的结果要在某个表达式中使用时，你必须用方括号把调用括起来，就象前面第二行语句那样。 </p>
<pre class="programlisting">if cond { statements } [ else { statements } ]</pre>
<p> This is a regular if-statement. The condition is composed of:<br>
这是一个普通的 if-语句。条件由以下组成： </p>
<div class="itemizedlist">
<ul type="disc">
<li>
<p>Literals (true if at least one string is not empty)<br>
普通文字(当至少一个字符串非空时为真)</p>
</li>
<li>
<p>Comparisons: <code class="computeroutput">a <em class="replaceable"><code>operator</code></em>
b</code> where <em class="replaceable"><code>operator</code></em>
is one of <code class="computeroutput">=</code>, <code class="computeroutput">!=</code>, <code class="computeroutput">&lt;</code>, <code class="computeroutput">&gt;</code>, <code class="computeroutput">&lt;=</code>, <code class="computeroutput">&gt;=</code>. The
comparison is done pairwise between each string in the left and the
right arguments.<br>
比较操作：<code class="computeroutput">a <em class="replaceable"><code>operator</code></em>
b</code> ，其中 <em class="replaceable"><code>operator</code></em>
为 <code class="computeroutput">=</code>, <code class="computeroutput">!=</code>, <code class="computeroutput">&lt;</code>, <code class="computeroutput">&gt;</code>, <code class="computeroutput">&lt;=</code>, <code class="computeroutput">&gt;=</code>
之一。比较操作是在左参数和右参数的各个字符串之间成对地进行的。 </p>
</li>
<li>
<p>Logical operations: <code class="computeroutput">!
a</code>, <code class="computeroutput">a
&amp;&amp; b</code>, <code class="computeroutput">a
|| b</code><br>
逻辑操作：<code class="computeroutput">! a</code>, <code class="computeroutput">a &amp;&amp; b</code>, <code class="computeroutput">a || b</code></p>
</li>
<li>
<p>Grouping: <code class="computeroutput">(
cond )</code><br>
分组操作：<code class="computeroutput">( cond )</code></p>
</li>
</ul>
</div>
<p> </p>
<pre class="programlisting">for var in list { statements }</pre>
<p> Executes statements for each element in list, setting the
variable <code class="varname">var</code> to the
element value.<br>
对 list 中的各个元素执行 statements，将变量 <code class="varname">var</code>
设为各个元素的值。 </p>
<pre class="programlisting">while cond { statements }</pre>
<p> Repeatedly execute statements while cond remains true upon
entry.<br>
当 cond 在每次进入时保持为真时重复执行 statements。 </p>
<pre class="programlisting">return values ;<br> </pre>
<p>This statement should be used only inside a rule and assigns <code class="computeroutput">values</code> to the return
value of the rule.<br>
这个语句只应在某个规则的内部使用，它将 <code class="computeroutput">values</code>
赋为该规则的返回值。 </p>
<div class="warning">
<table summary="Warning" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/html/images/warning.png"></td>
<th align="left">Warning 警告</th>
</tr>
<tr>
<td align="left" valign="top">
<p> The <code class="computeroutput">return</code>
statement does not exit the rule. For example:</p>
<p><code class="computeroutput">return</code>
语句不会退出规则。例如： </p>
<pre class="programlisting">rule test ( )<br>{<br> if 1 = 1 {<br> return "reasonable" ;<br> }<br> return "strange" ;<br>}</pre>
<p> will return <code class="literal">strange</code>,
not
<code class="literal">reasonable</code>.<br>
将返回 <code class="literal">strange</code>, 而不是
<code class="literal">reasonable</code>. </p>
</td>
</tr>
</tbody>
</table>
</div>
<p> </p>
<pre class="programlisting">import <em class="replaceable"><code>module</code></em> ;<br>import <em class="replaceable"><code>module</code></em> : <em class="replaceable"><code>rule</code></em> ;</pre>
<p> The first form imports the specified bjam module. All rules
from that module are made available using the qualified name: <code class="computeroutput"><em class="replaceable"><code>module</code></em>.<em class="replaceable"><code>rule</code></em></code>.
The second form imports the specified rules only, and they can be
called using unqualified names.<br>
第一种形式导入指定的 bjam 模块。该模块的所有规则都可以通过限定名称 <code class="computeroutput"><em class="replaceable"><code>module</code></em>.<em class="replaceable"><code>rule</code></em></code>
使用。第二种形式仅导入指定的规则，该规则可以通过非限定名称调用。 </p>
<p><a name="bbv2.advanced.jam_language.actions"></a>
Sometimes, you'd need to specify the actual command lines to be used
when creating targets. In jam language, you use named actions to do
this.&nbsp;For example:<br>
有时候，你需要在构建目标时指定真实的命令行。在 jam 语言中，你可以用命名动作来实现。例如：
</p>
<pre class="programlisting">actions create-file-from-another<br>{<br> create-file-from-another $(&lt;) $(&gt;)<br>}<br></pre>
<p> This specifies a named action called <code class="literal">create-file-from-another</code>.
The text inside braces is the command to invoke. The <code class="literal">$(&lt;)</code> variable will be
expanded to a list of generated files, and the <code class="literal">$(&gt;)</code>
variable will be expanded to a list of source files.<br>
它指定了一个名为 <code class="literal">create-file-from-another</code>
的命名动作。在大括号中的文本是要调用的命令。变量 <code class="literal">$(&lt;)</code>
将被展开为被生成文件的列表，而变量 <code class="literal">$(&gt;)</code>
则被展开为源文件的列表。 </p>
<p>To flexibly adjust command line, you can define a rule with
the same name as the action, and taking three parameters -- targets,
sources and properties. For example:<br>
为了灵活调整命令行，你可以定义一个和该动作同名的规则，它接受三个参数 -- 目标、源和属性。例如：
</p>
<pre class="programlisting">rule create-file-from-another ( targets * : sources * : properties * )<br>{<br> if &lt;variant&gt;debug in $(properties)<br> {<br> OPTIONS on $(targets) = --debug ;<br> }<br>}<br>actions create-file-from-another<br>{<br> create-file-from-another $(OPTIONS) $(&lt;) $(&gt;)<br>}<br></pre>
<p> In this example, the rule checks if certain build property is
specified. If so, it sets variable <code class="varname">OPIONS</code>
that is then used inside the action. Note that the variables set "on a
target" will be visible only inside actions building that target, not
globally. Were they set globally, using variable named <code class="varname">OPTIONS</code> in two unrelated
actions would be impossible.<br>
在这个例子中，规则会检查是否指定了特定的构建属性。如果有，则设置变量 <code class="varname">OPIONS</code>
然后在动作中使用它。注意，被设置"在特定目标上"的变量仅在构建该目标的动作内可见，而不是全局的。如果它被设为全局的，那么在两个无关的动作中使用名
为 <code class="varname">OPTIONS</code> 的变量就不可能了。</p>
<p>More details can be found in Jam reference, <a class="xref" href="../jam/language.html#jam.language.rules" title="Rules">the
section called “ Rules”</a><br>
更多细节可以在 Jam 参考手册的 <a class="xref" href="../jam/language.html#jam.language.rules" title="Rules">“规
则”一节</a> 中找到
</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="bbv2.advanced.configuration"></a>Configuration
配置</h3>
</div>
</div>
</div>
<p>On startup, Boost.Build searches and reads two configuration
files: <code class="filename">site-config.jam</code>
and <code class="filename">user-config.jam</code>.
The first one is usually installed and maintained by system
administrator, and the second is for user to modify. You can edit the
one in the top-level directory of Boost.Build installation or create a
copy in your home directory and edit the copy. The following table
explains where both files are searched.<br>
在启动时，Boost.Build 查找并读入两个配置文件：<code class="filename">site-config.jam</code>
和 <code class="filename">user-config.jam</code>。第一个文
件通常由系统管理员安装并维护，而第二个文件则由用户来修改。你可以在 Boost.Build
安装的顶级目录中编辑一个，或者在你的主目录中创建一份拷贝并编辑它。下表解释了在哪里搜索这两个文件。 </p>
<div class="table"><a name="bbv2.reference.init.config"></a>
<p class="title"><b>Table&nbsp;30.1.&nbsp;Search
paths for configuration files<br>
表&nbsp;30.1. 配置文件的搜索路径</b></p>
<div class="table-contents">
<table class="table" summary="Search paths for configuration files">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>&nbsp;</th>
<th>site-config.jam</th>
<th>user-config.jam</th>
</tr>
</thead><tbody>
<tr>
<td>Linux</td>
<td>
<p><code class="computeroutput">/etc</code></p>
<p><code class="computeroutput">$HOME</code></p>
<p><code class="computeroutput">$BOOST_BUILD_PATH</code></p>
</td>
<td>
<p><code class="computeroutput">$HOME</code></p>
<p><code class="computeroutput">$BOOST_BUILD_PATH</code></p>
</td>
</tr>
<tr>
<td>Windows</td>
<td>
<p><code class="computeroutput">%SystemRoot%</code></p>
<p><code class="computeroutput">%HOMEDRIVE%%HOMEPATH%</code></p>
<p><code class="computeroutput">%HOME%</code></p>
<p><code class="computeroutput">%BOOST_BUILD_PATH%</code></p>
</td>
<td>
<p><code class="computeroutput">%HOMEDRIVE%%HOMEPATH%</code></p>
<p><code class="computeroutput">%HOME%</code></p>
<p><code class="computeroutput">%BOOST_BUILD_PATH%</code></p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="tip">
<table summary="Tip" border="0">
<tbody>
<tr>
<td rowspan="2" align="middle" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr>
<td align="left" valign="top">
<p>You can use the <span class="command"><strong>--debug-configuration</strong></span>
option to find which configuration files are actually loaded.<br>
你可以用 <span class="command"><strong>--debug-configuration</strong></span>
选项来查找实际导入的是哪个配置议论的。 </p>
</td>
</tr>
</tbody>
</table>
</div>
<p>Usually, <code class="filename">user-config.jam</code>
just defines available compilers and other tools (see <a class="xref" title="Targets in site-config.jam" href="faq.html#bbv2.recipies.site-config">the section called
“Targets in site-config.jam”</a> for more advanced usage). A tool
is configured using the following syntax:<br>
通常，<code class="filename">user-config.jam</code>
只定义可用的编译器和其它工具(更深入的用法请见 <a class="xref" title="Targets in site-config.jam" href="faq.html#bbv2.recipies.site-config">“site-config.jam中的目
标”一节</a>)。使用以下语法来配置一个工具：</p>
<pre class="programlisting">using <em class="replaceable"><code>tool-name</code></em> : ... ;<br></pre>
<p>The <code class="computeroutput">using</code>
rule is given a name of tool, and will make that tool available to
Boost.Build. For example,<br>
规则 <code class="computeroutput">using</code>
给定工具的名字，并使得该工具对 Boost.Build 可用。例如， </p>
<pre class="programlisting">using gcc ;<br></pre>
<p>will make the <a href="http://gcc.gnu.org/" target="_top">GCC</a> compiler available.<br>
将使得 <a href="http://gcc.gnu.org/" target="_top">GCC</a>
编译器可用。</p>
<p>All the supported tools are documented in <a class="xref" title="Builtin tools" href="reference.html#bbv2.reference.tools">the
section called “Builtin tools”</a>, including the specific
options they take. Some general notes that apply to most C++ compilers
are below.<br>
所有可支持的工具在 <a class="xref" title="Builtin tools" href="reference.html#bbv2.reference.tools">“内建工具”一节</a>
中介绍，包括它们所带的特殊选项。以下是关于多数C++编译器的通用说明。 </p>
<p>For all the C++ compiler toolsets Boost.Build supports
out-of-the-box, the list of parameters to <code class="computeroutput">using</code> is the same: <em class="parameter"><code>toolset-name</code></em>,
<em class="parameter"><code>version</code></em>,
<em class="parameter"><code>invocation-command</code></em>,
and <em class="parameter"><code>options</code></em>.<br>
对于 Boost.Build 缺省配置就支持的所有编译器工具集，给 <code class="computeroutput">using</code>
的参数列表都是一样的：<em class="parameter"><code>toolset-name</code></em>,
<em class="parameter"><code>version</code></em>,
<em class="parameter"><code>invocation-command</code></em>,
和 <em class="parameter"><code>options</code></em>.
</p>
<p>If you have a single compiler, and the compiler executable<br>
如果你只有一个编译器，且编译器的可执行文件 </p>
<div class="itemizedlist">
<ul type="disc">
<li>
<p>has its “usual name” and is in the <code class="envar">PATH</code>,
or<br>
具有"正常名字"且位于&nbsp;<code class="envar">PATH</code>
中，或者</p>
</li>
<li>
<p>was installed in a standard “installation directory”, or<br>
被安装在标准的"安装目录"下，或者</p>
</li>
<li>
<p>can be found using a global system like the Windows
registry.<br>
可以用全局系统，如 Windows 注册表，查找得到。</p>
</li>
</ul>
</div>
<p>it can be configured by simply:<br>
它只需如下配置：</p>
<pre class="programlisting">using <em class="replaceable"><code>tool-name</code></em> ;<br></pre>
<p>If the compiler is installed in a custom directory, you should
provide the command that invokes the compiler, for example:<br>
如果该编译器安装在一个定制的目录，你就要提供调用该编译器的命令，例如：</p>
<pre class="programlisting">using gcc : : g++-3.2 ;<br>using msvc : : "Z:/Programs/Microsoft Visual Studio/vc98/bin/cl" ;</pre>
<p>Some Boost.Build toolsets will use that path to take
additional
actions required before invoking the compiler, such as calling
vendor-supplied scripts to set up its required environment variables.
When compiler executables for C and C++ are different, path to the C++
compiler executable must be specified. The “invocation command”
can be any command allowed by the operating system. For example:<br>
有些 Boost.Build 工具集要在调用编译器之前用这个路径来进行其它必要的动作，如调用一个厂家提供的脚本来设置所需的环境变量。如果用于
C 和 C++ 的编译程序是不同的，那么必须指定 C++
编译程序的路径。“invocation command”可以是操作系统允许的任何命令。例如：
</p>
<pre class="programlisting">using msvc : : echo Compiling &amp;&amp; foo/bar/baz/cl ;<br></pre>
<p>
will work.<br>
也可以工作。 </p>
<p>To configure several versions of a toolset, simply invoke the <code class="computeroutput">using</code> rule multiple
times:<br>
要配置一个工具集的多个版本，只要多次调用 <code class="computeroutput">using</code>
规则即可。
</p>
<pre class="programlisting">using gcc : 3.3 ;<br>using gcc : 3.4 : g++-3.4 ;<br>using gcc : 3.2 : g++-3.2 ;<br></pre>
<p> Note that in the first call to <code class="computeroutput">using</code>, the compiler
found in the <code class="envar">PATH</code> will
be used, and there's no need to explicitly specify the command.<br>
注意，在调用第一个 <code class="computeroutput">using</code>
时，会使用在 <code class="envar">PATH</code>
中找到的编译器，无需明确指定相关命令。 </p>
<p>Many of toolsets have an <em class="parameter"><code>options</code></em>
parameter to fine-tune the configuration. All of Boost.Build's standard
compiler toolsets accept four options <code class="varname">cflags</code>,
<code class="varname">cxxflags</code>, <code class="varname">compileflags</code> and <code class="varname">linkflags</code> as <em class="parameter"><code>options</code></em>
specifying flags that will be always passed to the corresponding tools.
Values of the <code class="varname">cflags</code>
feature are passed directly to the C compiler, values of the <code class="varname">cxxflags</code> feature are passed
directly to the C++ compiler, and values of the <code class="varname">compileflags</code> feature are passed
to both. For example, to configure a <span class="command"><strong>gcc</strong></span>
toolset so that it always generates 64-bit code you could write:<br>
许多工具集有一个参数 <em class="parameter"><code>options</code></em>
用于对配置进行调整。所有 Boost.Build 的标准编译器工具集都用&nbsp;<em class="parameter"><code>options</code></em>
接受四个内建选项 <code class="varname">cflags</code>, <code class="varname">cxxflags</code>, <code class="varname">compileflags</code> 和 <code class="varname">linkflags</code> 的属性，以指定传递给对应工具的选项。<code class="varname">cflags</code> 特性的值会直接传递给 C 编译器，<code class="varname">cxxflags</code> 特性的值则直接传递给 C++ 编译器，而 <code class="varname">compileflags</code> 特性的值则传给两者。例如，要将 <span class="command"><strong>gcc</strong></span>
工具集进行配置以使之一直生成64位代码，你可以写：
</p>
<pre class="programlisting">using gcc : 3.4 : : &lt;compileflags&gt;-m64 &lt;linkflags&gt;-m64 ;<br></pre>
<div class="warning">
<table summary="Warning" border="0">
<tbody>
<tr>
<td rowspan="2" align="middle" valign="top" width="25"><img alt="[Warning]" src="../../../doc/html/images/warning.png"></td>
<th align="left">Warning 警告</th>
</tr>
<tr>
<td align="left" valign="top">
<p>Although the syntax used to specify toolset options is
very similar to syntax used to specify requirements in Jamfiles, the
toolset options are not the same as features. Don't try to specify a
feature value in toolset initialization.<br>
虽然用于指定工具集选项的语法与用于指定 Jamfile
中的需求的语法非常相似，但是工具集选项不同于需求的特性。不要试图在工具集初始化中指定一个特性值。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="bbv2.advanced.invocation"></a>Invocation
调用</h3>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.invocation.examples">Examples
示例</a></span> </dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.invocation.options">Options
选项</a></span> </dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.invocation.properties">Properties
属性</a></span> </dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.invocation.targets">Targets
目标</a></span> </dt>
</dl>
</div>
<p>To invoke Boost.Build, type <span class="command"><strong>bjam</strong></span>
on the command line. Three kinds of command-line tokens are accepted,
in any order:<br>
要调用 Boost.Build，在命令行中打入 <span class="command"><strong>bjam</strong></span>。
可以接受三种命令行记号，顺序任意：</p>
<div class="variablelist">
<dl>
<dt><span class="term">options 选项</span> </dt>
<dd>
<p>Options start with either dash, or two dashes. The
standard options are listed below, and each project may add additional
options<br>
选项以一个或两个减号开始。下面会列出所有标准的选项，每个工程可以增加额外的选项</p>
</dd>
<dt><span class="term">properties 属性</span> </dt>
<dd>
<p>Properties specify details of what you want to build (e.g.
debug or release variant). Syntactically, all command line tokens with
equal sign in them are considered to specify properties. In the
simplest form, property looks like <span class="command"><strong><em class="replaceable"><code>feature</code></em>=<em class="replaceable"><code>value</code></em></strong></span><br>
属性指定了你想要构建的细节(如调试版还是发布版)。语法上，所有带等号的命令行记号都会被视为指定了属性。最简单的形式是 <span class="command"><strong><em class="replaceable"><code>feature</code></em>=<em class="replaceable"><code>value</code></em></strong></span>
</p>
</dd>
<dt><span class="term">target 目标</span> </dt>
<dd>
<p>All tokens that are neither options nor properties specify
what targets to build. The available targets entirely depend on the
project you are building.<br>
所有既不是选项也不是属性的记号指定了要构建哪些目标。有效的目标完全依赖于你要构建的工程。</p>
</dd>
</dl>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="bbv2.advanced.invocation.examples"></a>Examples
示例</h4>
</div>
</div>
</div>
</div>
<p>To build all targets defined in Jamfile in the current
directory with default properties, run:<br>
要以缺省属性构建当前目录的&nbsp;Jamfile 中的所有目标，运行：
</p>
<pre class="screen">bjam<br></pre>
<p>To build specific targets, specify them on the command line:<br>
要构建特定目标，则在命令行中指定它们：
</p>
<pre class="screen">bjam lib1 subproject//lib2<br></pre>
<p> To request a certain value for some property, add <code class="literal"> <em class="replaceable"><code>property</code></em>=<em class="replaceable"><code>value</code></em></code>
to the command line:<br>
要为某些属性指定特定值，则在命令行中加入 <code class="literal"> <em class="replaceable"><code>property</code></em>=<em class="replaceable"><code>value</code></em></code>
：
</p>
<pre class="screen">bjam toolset=gcc variant=debug optimization=space<br></pre>
<h4 class="title"><a name="bbv2.advanced.invocation.options"></a>Options 选项</h4>
<p> Boost.Build recognizes the following command line options.<br>
Boost.Build 使用以下命令行选项：</p>
<div class="variablelist">
<dl>
<dt></dt><dt><a name="bbv2.reference.init.options.help"></a><span class="term"><code class="option">--help</code></span>
</dt>

<dd>
<p>Invokes the online help system. This prints general
information on how to use the help system with additional --help*
options.<br>
调用在线帮助系统。要输出如何使用帮助系统的信息，请使用额外的 --help* 选项。</p>
</dd>
<dt><span class="term"><code class="option">--clean</code></span></dt>
<dd>
<p>Cleans all targets in the current directory and in any
subprojects. Note that unlike the <code class="literal">clean</code>
target in make, you can use <code class="literal">--clean</code>
together with target names to clean specific targets.<br>
清除当前目录及所有子工程中的目标。注意，与 make 中的&nbsp;<code class="literal">clean</code>
目标不同，你可以将 <code class="literal">--clean</code>
和目标名一起使用以清除指定目标。</p>
</dd>
<dt><span class="term"><code class="option">--clean-all</code></span></dt>
<dd>
<p>Cleans all targets, no matter where they are defined. In
particular, it will clean targets in parent Jamfiles, and targets
defined under other project roots.<br>
清除所有目标，不管它们在哪里定义。特定地，它将清除在父 Jamfiles 中的目标以及定义在其它工程根下的目标。 </p>
</dd>
<dt><span class="term"><code class="option">--build-dir</code></span></dt>
<dd>
<p>Changes build directories for all project roots being
built. When this option is specified, all Jamroot files should declare
project name. The build directory for the project root will be computed
by concatanating the value of the <code class="option">--build-dir</code>
option, the project name specified in Jamroot, and the build dir
specified in Jamroot (or <code class="literal">bin</code>,
if none is specified).<br>
为被构建的所有工程根修改构建目录。如果指定了这一选项，所有 Jamroot 文件都应声明工程名。工程根的构建目录通过将 <code class="option">--build-dir</code> 选项的值与在 Jamroot
中指定的工程名以及在 Jamroot 中指定的构建目录(如果没有指定则为 <code class="literal">bin</code>)
相联接得到， </p>
<p>The option is primarily useful when building from
read-only media, when you can't modify Jamroot.<br>
该选项主要在从只读介质进行构建时使用，这时你不能修改 Jamroot。 </p>
</dd>
<dt><span class="term"><code class="option">--version</code></span></dt>
<dd>
<p>Prints information on Boost.Build and Boost.Jam versions.<br>
打印 Boost.Build 和 Boost.Jam 的版本信息。</p>
</dd>
<dt></dt><dt><span class="term"><code class="option">-a</code></span> </dt>

<dd>
<p>Causes all files to be rebuilt.<br>
重建所有文件。</p>
</dd>
<dt><span class="term"><code class="option">-n</code></span>
</dt>
<dd>
<p>Do no execute the commands, only print them.<br>
不执行命令，仅输出命令。</p>
</dd>
<dt><span class="term"><code class="option">-d+2</code></span>
</dt>
<dd>
<p>Show commands as they are executed.<br>
显示命令，就象它们被执行一样。</p>
</dd>
<dt><span class="term"><code class="option">-d0</code></span>
</dt>
<dd>
<p>Supress all informational messages.<br>
禁止所有信息。</p>
</dd>
<dt><span class="term"><code class="option">-q</code></span>
</dt>
<dd>
<p>Stop at first error, as opposed to continuing to build
targets that don't depend on the failed ones.<br>
在第一个错误处停止，不再继续构建那些不依赖该错误的目标。</p>
</dd>
<dt><span class="term"><code class="option">-j
<em class="replaceable"><code>N</code></em></code></span>
</dt>
<dd>
<p>Run up to <em class="replaceable"><code>N</code></em>
commands in parallel.<br>
并发运行至多 <em class="replaceable"><code>N</code></em>
个命令。</p>
</dd>
<dt><span class="term"><code class="option">--debug-configuration</code></span></dt>
<dd>
<p>Produces debug information about loading of Boost.Build
and toolset files.<br>
产生关于 Boost.Build 和工具集文件装入的调试信息。</p>
</dd>
<dt><span class="term"><code class="option">--debug-building</code></span></dt>
<dd>
<p>Prints what targets are being built and with what
properties.<br>
打印正在构建的目标和所带的属性。 </p>
</dd>
<dt><span class="term"><code class="option">--debug-generators</code></span></dt>
<dd>
<p>Produces debug output from generator search process.
Useful for debugging custom generators.<br>
从生成器查找过程产生调试输出。用于调试客户化的生成器。 </p>
</dd>
<dt><span class="term"><code class="option">--ignore-config</code></span></dt>
<dd>
<p>Do not load <code class="literal">site-config.jam</code>
and <code class="literal">user-config.jam</code>
configuration files.<br>
不要装入 <code class="literal">site-config.jam</code> 和
<code class="literal">user-config.jam</code>
配置文件。</p>
</dd>
</dl>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="bbv2.advanced.invocation.properties"></a>Properties
属性</h4>
</div>
</div>
</div>
<p>In the simplest case, the build is performed with a single set
of properties, that you specify on the command line with elements in
the form <span class="command"><strong><em class="replaceable"><code>feature</code></em>=<em class="replaceable"><code>value</code></em></strong></span>.
The complete list of features can be found in <a class="xref" title="Builtin features" href="reference.html#bbv2.advanced.builtins.features">the
section called “Builtin features”</a>. The most common features
are summarized below.<br>
在最简单的情况下，构建是以单个属性集执行的，即你在命令行中以形如 <span class="command"><strong><em class="replaceable"><code>feature</code></em>=<em class="replaceable"><code>value</code></em></strong></span>
的元素所指定的属性集。特性的完整列表可以在 <a class="xref" title="Builtin features" href="reference.html#bbv2.advanced.builtins.features">“内建特性”一
节</a> 中找到。以下是最常用的特性。</p>
<div class="table"><a name="id4453899"></a>
<p class="title"><b>Table&nbsp;30.2.&nbsp;<br>
表&nbsp;30.2.&nbsp;</b></p>
<div class="table-contents">
<table class="table">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>Feature 特性</th>
<th>Allowed values 可用值</th>
<th>Notes 说明</th>
</tr>
</thead><tbody>
<tr>
<td>variant</td>
<td>debug,release</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>link</td>
<td>shared,static</td>
<td>Determines if Boost.Build creates shared or static
libraries<br>
决定 Boost.Build 是否创建共享或静态库</td>
</tr>
<tr>
<td>threading</td>
<td>single,multi</td>
<td>Cause the produced binaries to be thread-safe. This
requires proper support in the source code itself.<br>
生成的二进制文件是线程安全的。这一要求应在源码本身上正确支持。</td>
</tr>
<tr>
<td>toolset</td>
<td>(Depends on configuration)</td>
<td>The C++ compiler to use. See <a class="xref" title="C++ Compilers" href="reference.html#bbv2.reference.tools.compilers">the
section called “C++ Compilers”</a> for a detailed list.<br>
使用的 C++ 编译器。详细列表请见 <a class="xref" title="C++ Compilers" href="reference.html#bbv2.reference.tools.compilers">“C++编译器”
一节</a>。</td>
</tr>
<tr>
<td>cxxflags</td>
<td>(Arbitrary string)</td>
<td>Custom options to pass to the C++ compiler.<br>
定制传递给C++编译器的选项。</td>
</tr>
<tr>
<td>cflags</td>
<td>(Arbitrary string)</td>
<td>Custom options to pass to the C compiler.<br>
定制传递给C编译器的选项。</td>
</tr>
<tr>
<td>includes</td>
<td>(Arbitrary string)</td>
<td>Additional include paths for C and C++ compilers.<br>
用于C和C++编译器的额外包含路径。</td>
</tr>
<tr>
<td>define</td>
<td>(Arbitrary string)</td>
<td>Additional macro definitions for C and C++ compilers.<br>
用于C和C++编译器的额外宏定义。</td>
</tr>
<tr>
<td>runtime-link</td>
<td>shared,static</td>
<td>Determines if shared or static version of C and C++
runtimes should be used.<br>
决定使用C和C++运行时库的共享版本还是静态版本。</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p>If you have more than one version of a given C++ toolset (e.g.
configured in <code class="filename">user-config.jam</code>,
or autodetected, as happens with msvc), you can request the specific
version by passing <code class="computeroutput"><em class="replaceable"><code>toolset</code></em>-<em class="replaceable"><code>version</code></em></code>
as the value of the <code class="computeroutput">toolset</code>
feature, for example <code class="computeroutput">toolset=msvc-8.0</code>.<br>如果你的C++工具集有超过一个版本(如：在 <code class="filename">user-config.jam</code> 中配置的，或者象 msvc 那样自动检测到的)，你可以将 <code class="computeroutput"><em class="replaceable"><code>toolset</code></em>-<em class="replaceable"><code>version</code></em></code> 作为 <code class="computeroutput">toolset</code>
特性的值传递，以指定版本，例如 <code class="computeroutput">toolset=msvc-8.0</code>.</p>
<p>If a feature has a fixed set of values it can be specified
more than once on the command line. In which case, everything will be
built several times -- once for each specified value of a feature. For
example, if you use<br>如果一个特性有一个固定的值集合，它就可以在命令行中多次指定。这种情况下，每样东西都会多次构建 -- 该特性的每个指定值构建一次。例如，如果你用 </p>
<pre class="screen">bjam link=static link=shared threading=single threading=multi<br></pre>
<p>Then a total of 4 builds will be performed. For convenience,
instead of specifying all requested values of a feature in separate
command line elements, you can separate the values with commands, for
example:<br>则总共执行4次构建。为方便起见，无需在独立的命令行元素中指定所请求的值，你可以用逗号分离各个值，例如： </p>
<pre class="screen">bjam link=static,shared threading=single,multi<br></pre>
<p>The comma has special meaning only if the feature has a fixed
set of values, so<br>仅当特性具有固定的值集合时，逗号才有特定意义，因此 </p>
<pre class="screen">bjam include=static,shared<br></pre>
<p>is not treated specially.<br>不会被特别对待。</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="bbv2.advanced.invocation.targets"></a>Targets 目标</h4>
</div>
</div>
</div>
<p>All command line elements that are neither options nor
properties are the names of the targets to build. See <a class="xref" title="Target identifiers and references" href="reference.html#bbv2.reference.ids">the section called
“Target identifiers and references”</a>. If no target is
specified, the project in the current directory is built.<br>所有既不是选项也不是属性的命令行元素就是要构建的目标名。请见 <a class="xref" title="Target identifiers and references" href="reference.html#bbv2.reference.ids">“目标标识符和引用”一节</a>。如果未指定目标，则构建当前目录中的工程。</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="bbv2.advanced.targets"></a>Declaring
Targets 声明目标</h3>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="advanced.html#id3903658">Name 名称</a></span></dt>
<dt><span class="section"><a href="advanced.html#id3903714">Sources 源</a></span></dt>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.targets.requirements">Requirements
要求</a></span></dt>
<dt><span class="section"><a href="advanced.html#id3904049">Default Build 缺省构建</a></span></dt>
<dt><span class="section"><a href="advanced.html#id3904077">Additional Information 额外信息</a></span></dt>
</dl>
</div>
<p><a name="bbv2.advanced.targets.main"></a> A
<em class="firstterm">Main target</em> is a
user-defined named entity that can be built, for example an executable
file. Declaring a main target is usually done using one of the main
target rules described in <a class="xref" href="reference.html#bbv2.reference.rules" title="Builtin rules">the
section called “Builtin rules”</a>. The user can also declare
custom main target rules as shown in <a class="xref" href="extender.html#bbv2.extending.rules" title="Main target rules">the section called “Main target
rules”</a>.<br>
<em class="firstterm">主目标</em>
是指用户定义的一个可构建的命名实体，例如一个可执行文件。主目标通常是通过使用在 <a class="xref" href="reference.html#bbv2.reference.rules" title="Builtin rules">“内
建规则”一节</a> 中描述的主目标规则之一来声明的。用户也可以象在 <a class="xref" href="extender.html#bbv2.extending.rules" title="Main target rules">“主目标规则”一节</a>&nbsp;中所说的那样
声明定制的主目标规则。 </p>
<a class="indexterm" name="id3903504"></a>
<p>Most main target rules in Boost.Build have the same common
signature:<br>
Boost.Build 中多数主目标规则都具有相同的公用签名：</p>
<a class="indexterm" name="id3903518"></a><a name="bbv2.main-target-rule-syntax"></a>
<pre class="programlisting">rule <em class="replaceable"><code>rule-name</code></em> (<br> main-target-name :<br> sources + :<br> requirements * :<br> default-build * :<br> usage-requirements * )<br></pre>
<div class="itemizedlist">
<ul type="disc">
<li> <em class="parameter"><code>main-target-name</code></em>
is the name used to request the target on command line and to use it
from other main targets. A main target name may contain alphanumeric
characters, dashes (‘<code class="computeroutput">-</code>’),
and underscores (‘<code class="computeroutput">_</code>’).<br>
<em class="parameter"><code>main-target-name</code></em>
是用于在命令行请求该目标以及从其它主目标使用的名字。主目标名可以包含字母、连字符 (‘<code class="computeroutput">-</code>’) 和下划线 (‘<code class="computeroutput">_</code>’)。 </li>
<li> <em class="parameter"><code>sources</code></em>
is the list of source files and other main targets that must be
combined.<br>
<em class="parameter"><code>sources</code></em>
是源文件列表以及其它必须组合的主目标。 </li>
<li> <em class="parameter"><code>requirements</code></em>
is the list of properties that must always be present when this main
target is built.<br>
<em class="parameter"><code>requirements</code></em>
是在构建主目标时必须一直使用的属性的列表。 </li>
<li> <em class="parameter"><code>default-build</code></em>
is the list of properties that will be used unless some other value of
the same feature is already specified, e.g. on the command line or by
propagation from a dependent target.<br>
<em class="parameter"><code>default-build</code></em>
也是将被使用的属性的列表，除非这些特性的值被通过命令行指定或从依赖目标传播得到。 </li>
<li> <em class="parameter"><code>usage-requirements</code></em>
is the list of properties that will be propagated to all main targets
that use this one, i.e. to all its dependents.<br>
<em class="parameter"><code>usage-requirements</code></em>
是一些属性的列表，这些属性将被传播至所有依赖于该目标的主目标。 </li>
</ul>
</div>
<p> Some main target rules have a different list of parameters as
explicitly stated in their documentation.<br>
有些主目标规则具有不同的参数列表，将在它们的文档中明确说明。</p>
<p>The actual requirements for a target are obtained by refining
requirements of the project where a target is declared with the
explicitly specified requirements. The same is true for
usage-requirements. More details can be found in <a class="xref" href="reference.html#bbv2.reference.variants.proprefine" title="Property refinement">the section called “Property
refinement”</a><br>
一个目标的实际要求是通过对声明该目标的工程的要求和显式指定的要求一起精化而得到的。对于 usage-requirements
也一样。更多细节可以在 <a class="xref" href="reference.html#bbv2.reference.variants.proprefine" title="Property refinement">“属性精化”一节</a> 中找到。 </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="id3903658"></a>Name
名称</h4>
</div>
</div>
</div>
<p>The name of main target has two purposes. First, it's used to
refer to this target from other targets and from command line. Second,
it's used to compute the names of the generated files. Typically,
filenames are obtained from main target name by appending
system-dependent suffixes and prefixes.<br>
主目标的名称有两个目的。首先，它用于在其它目标或命令行中指称该目标。其次，它用于计算生成文件的名字。通常，文件名由主目标名字加上系统相关的前缀和
后缀而成。 </p>
<p>The name of a main target can contain alphanumeric characters,
dashes, undescores and dots. The entire name is significant when
resolving references from other targets. For determining filenames,
only the part before the first dot is taken. For example:<br>
主目标名称可以包含字母、连字符、下划线和点符。在从其它目标进行引用解释时使用完整的名称。而在生成文件名时，则只使用第一个点符之前的部分。例如：</p>
<pre class="programlisting">obj test.release : test.cpp : &lt;variant&gt;release ;<br>obj test.debug : test.cpp : &lt;variant&gt;debug ;<br></pre>
<p>will generate two files named <code class="filename">test.obj</code>
(in two different directories), not two files named <code class="filename">test.release.obj</code> and <code class="filename">test.debug.obj</code>.<br>
将生成两个名为 <code class="filename">test.obj</code>
的文件(在不同的目录下)，而不是两个分别名为 <code class="filename">test.release.obj</code>
和 <code class="filename">test.debug.obj</code> 的文件。
</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="id3903714"></a>Sources
源</h4>
</div>
</div>
</div>
<p>The list of sources specifies what should be processed to get
the resulting targets. Most of the time, it's just a list of files.
Sometimes, you'll want to automatically construct the list of source
files rather than having to spell it out manually, in which case you
can use the <code class="computeroutput">glob</code>
rule. Here are two examples:<br>
源列表指明了要得到结果目标应处理些什么。多数时候，它只是一个文件列表。有时，你可能想自动构造源文件的列表，而不是手工将它拼写出来，这时你可以使用
<code class="computeroutput">glob</code> 规则。以下是两个例子：</p>
<pre class="programlisting">exe a : a.cpp ; # a.cpp is the only source file a.cpp 是唯一的源文件<br>exe b : [ glob *.cpp ] ; # all .cpp files in this directory are sources 目录中所有 .cpp 文件都是源<br></pre>
<p> Unless you specify a file with an absolute path, the name is
considered relative to the source directory — which is typically the
directory where the Jamfile is located, but can be changed as described
in <a class="xref" href="advanced.html#bbv2.advanced.projects.attributes.projectrule">the
section called “Projects”</a>.<br>
除非你以绝对路径来指明文件，否则文件名被认为是相对于源目录的 — 通常是 Jamfile 所在的目录，但是也可以被修改，见 <a class="xref" href="advanced.html#bbv2.advanced.projects.attributes.projectrule">“工
程”一节</a>。 </p>
<p> The list of sources can also refer to other main targets.
Targets in the same project can be referred to by name, while targets
in other projects must be qualified with a directory or a symbolic
project name. The directory/project name is separated from the target
name by a double forward slash. There's no special syntax to
distinguish the directory name from the project name—the part before
the double slash is first looked up as project name, and then as
directory name. For example:&nbsp;<br>
源列表也可以引向其它主目标。在同一个工程中的目标可以用名字来引用，而在其它工程中的目标则必须用一个目录或工程符号名来限定。目录/工程名与目标名之
间以一个双重斜杠分隔。没有特殊的语法来区分目录名和工程名—双斜杠前的部分先按工程名查找，再按目录名查找。例如： </p>
<pre class="programlisting">lib helper : helper.cpp ;<br>exe a : a.cpp helper ;<br># Since all project ids start with slash, ".." is directory name.<br>exe b : b.cpp ..//utils ;<br>exe c : c.cpp /boost/program_options//program_options ;<br></pre>
<p> The first exe uses the library defined in the same project.
The second one uses some target (most likely library) defined by
Jamfile one level higher. Finally, the third target uses some <a href="http://boost.org/" target="_top">C++ Boost</a>
library, referring to it by absolute symbolic name. More information
about target references can be found in <a class="xref" href="tutorial.html#bbv2.tutorial.libs" title="Dependent Targets">the section called “Dependent
Targets”</a> and <a class="xref" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">the section called
“Target identifiers and references”</a>.<br>
第一个 exe 使用在本工程中定义的库。第二个则使用在上一级 Jamfile 定义的某个目标(很可能是库)。最后，第三个目标使用了某个 <a href="http://boost.org" target="_top">C++ Boost</a>
库，以绝对符号名称来引用。有关目标引用的更多信息，可以在 <a class="xref" href="tutorial.html#bbv2.tutorial.libs" title="Dependent Targets">“依赖目标”一节</a> 和 <a class="xref" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">“目标标识符和引用”一节</a>
中找到。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="bbv2.advanced.targets.requirements"></a>Requirements
要求</h4>
</div>
</div>
</div>
<p>Requirements are the properties that should always be present
when building a target. Typically, they are includes and defines:<br>
要求是指在构建一个目标时要一直使用的属性。典型地，它们是一些包含和定义：
</p>
<pre class="programlisting">exe hello : hello.cpp : &lt;include&gt;/opt/boost &lt;define&gt;MY_DEBUG ;<br></pre>
<p> There is a number of other features, listed in <a class="xref" href="reference.html#bbv2.advanced.builtins.features" title="Builtin features">the section called “Builtin
features”</a>. For example if a library can only be built
statically, or a file can't be compiled with optimization due to a
compiler bug, one can use<br>
还有多个其它的特性，列在 <a class="xref" href="reference.html#bbv2.advanced.builtins.features" title="Builtin features">“内建特性”一节</a>
中。例如，如果一个库只能静态构建，或者一个文件由于编译器缺陷而不能以优化方式编译，你可以使用：
</p>
<pre class="programlisting">lib util : util.cpp : &lt;link&gt;static ;<br>obj main : main.cpp : &lt;optimization&gt;off ;<br></pre>
<p> </p>
<p><a name="bbv2.advanced.targets.requirements.conditional"></a>Sometimes,
particular relationships need to be maintained among a target's build
properties. This can be achieved with <em class="firstterm">conditional
requirements</em>. For example, you might want to set specific <code class="computeroutput">#defines</code> when a library
is built as shared, or when a target's <code class="computeroutput">release</code>
variant is built in release mode.<br>
有时，有些特定的关系也需要在目标的构建属性中维护。这时可以使用 <em class="firstterm">条件要求</em>。
例如，你可能想在某个库以动态方式构建时设置特定的 <code class="computeroutput">#defines</code>，
或者在某个目标的 <code class="computeroutput">release</code>
版本按发布模式构建时。
</p>
<pre class="programlisting">lib network : network.cpp<br> : <span class="bold"><strong>&lt;link&gt;shared:&lt;define&gt;NEWORK_LIB_SHARED</strong></span><br>&lt;variant&gt;release:&lt;define&gt;EXTRA_FAST<br>;<br></pre>
<p> In the example above, whenever <code class="filename">network</code>
is built with <code class="computeroutput">&lt;link&gt;shared</code>,
<code class="computeroutput">&lt;define&gt;NEWORK_LIB_SHARED</code>
will be in its properties, too.<br>
在上例中，当 <code class="filename">network</code> 以 <code class="computeroutput">&lt;link&gt;shared</code>
构建时，<code class="computeroutput">&lt;define&gt;NEWORK_LIB_SHARED</code>
将成为它的属性之一。 </p>
<p>You can use several properties in the condition, for example:<br>
你可以在条件中使用多个属性，例如：
</p>
<pre class="programlisting">lib network : network.cpp<br> : &lt;toolset&gt;gcc,&lt;optimization&gt;speed:&lt;define&gt;USE_INLINE_ASSEMBLER<br> ;<br></pre>
<p> </p>
<p><a name="bbv2.advanced.targets.requirements.indirect"></a>
A more powerful variant of conditional requirements is <em class="firstterm">indirect conditional requirements</em>.
You can provide a rule that will be called with the current build
properties and can compute additional properties to be added. For
example:<br>
条件要求的一个更为强大的变体是 <em class="firstterm">间接条件要求</em>。你可
以提供一个规则，以当前的构建属性来调用它，计算得到要增加的其它属性。例如：
</p>
<pre class="programlisting">lib network : network.cpp<br> : &lt;conditional&gt;@my-rule<br> ;<br>rule my-rule ( properties * )<br>{<br> local result ;<br> if &lt;toolset&gt;gcc &lt;optimization&gt;speed in $(properties)<br> {<br> result += &lt;define&gt;USE_INLINE_ASSEMBLER ;<br> }<br> return $(result) ;<br>}<br></pre>
<p> This example is equivalent to the previous one, but for
complex cases, indirect conditional requirements can be easier to write
and understand.<br>
这个例子和上一个效果一样，但是对于复杂的情形，间接条件要求更易于编写，也更易懂。 </p>
<p>Requirements explicitly specified for a target are usually
combined with the requirements specified for the containing project.
You can cause a target to completely ignore specific project's
requirement using the syntax by adding a minus sign before a property,
for example:<br>
为一个目标显式指定的要求通常要与其所在工程所指定的要求相合并。你可以在某个属性之前加上一个减号，让目标完全忽略工程所指定的要求，例如：
</p>
<pre class="programlisting">exe main : main.cpp : <span class="bold"><strong>-&lt;define&gt;UNNECESSARY_DEFINE</strong></span> ;<br></pre>
<p> This syntax is the only way to ignore free properties from a
parent, such as defines. It can be also useful for ordinary properties.
Consider this example:<br>
这种语法是忽略来自于父工程的自由属性(如定义)的唯一方法。它也可以用于普通属性。考虑以下例子：
</p>
<pre class="programlisting">project test : requirements &lt;threading&gt;multi ;<br>exe test1 : test1.cpp ;<br>exe test2 : test2.cpp : &lt;threading&gt;single ;<br>exe test3 : test3.cpp : -&lt;threading&gt;multi ;<br></pre>
<p> Here, <code class="computeroutput">test1</code>
inherits project requirements and will always be built in
multi-threaded mode. The <code class="computeroutput">test2</code>
target <span class="emphasis"><em>overrides</em></span>
project's requirements and will always be built in single-threaded
mode. In contrast, the <code class="computeroutput">test3</code>
target <span class="emphasis"><em>removes</em></span>
a property from project requirements and will be built either in
single-threaded or multi-threaded mode depending on which variant is
requested by the user.<br>
这里，<code class="computeroutput">test1</code>
继承了工程要求，将总是按多线程模式构建。而目标 <code class="computeroutput">test2</code>
则 <span class="emphasis"><em>覆写</em></span>
了工程的要求，将总是按单线程模式构建。相比之下，目标 <code class="computeroutput">test3</code>
<span class="emphasis"><em>去除</em></span>
了工程要求的一个属性，它根据用户的请求来按单线程或多线程模式构建。</p>
<p>Note that the removal of requirements is completely textual:
you need to specify exactly the same property to remove it.<br>
注意，要求的去除需要完整的文字：你必须正确地给出要去除的相同属性。</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="id3904049"></a>Default
Build 缺省构建</h4>
</div>
</div>
</div>
<p>The <code class="varname">default-build</code>
parameter is a set of properties to be used if the build request does
not otherwise specify a value for features in the set. For example:<br>
参数 <code class="varname">default-build</code>
是一组这样的属性，如果构建请求中没有指定该组中某个特性的值，就使用这个属性。例如：
</p>
<pre class="programlisting">exe hello : hello.cpp : : &lt;threading&gt;multi ;<br></pre>
<p> would build a multi-threaded target unless the user
explicitly requests a single-threaded version. The difference between
requirements and default-build is that requirements cannot be
overridden in any way.<br>
将构建一个多线程的目标，除非用户明确指定要一个单线程版本。要求和缺省构建之间的区别在于，要求是不能被覆写的。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="id3904077"></a>Additional
Information 额外信息</h4>
</div>
</div>
</div>
<p> The ways a target is built can be so different that
describing them using conditional requirements would be hard. For
example, imagine that a library actually uses different source files
depending on the toolset used to build it. We can express this
situation using <em class="firstterm">target alternatives</em>:<br>
构建目标的方式可以很不一样，用条件要求来描述可能会有困难。例如，想象一个库，它根据构建时所用的工具集来实际选用不同的源文件。我们可以用 <em class="firstterm">目标选择</em> 来表示这种情形：</p>
<pre class="programlisting">lib demangler : dummy_demangler.cpp ; # alternative 1<br>lib demangler : demangler_gcc.cpp : &lt;toolset&gt;gcc ; # alternative 2<br>lib demangler : demangler_msvc.cpp : &lt;toolset&gt;msvc ; # alternative 3<br></pre>
<p> In the example above, when built with <code class="literal">gcc</code> or <code class="literal">msvc</code>,
<code class="filename">demangler</code> will use a
source file specific to the toolset. Otherwise, it will use a generic
source file, <code class="filename">dummy_demangler.cpp</code>.<br>
在上例中，如果用 <code class="literal">gcc</code> 或 <code class="literal">msvc</code> 来构建，则 <code class="filename">demangler</code>
将使用指定给相应工具集的源文件。否则，它使用通用的源文件 <code class="filename">dummy_demangler.cpp</code>.
</p>
<p>It is possible to declare a target inline, i.e. the "sources"
parameter may include calls to other main rules. For example:<br>
可以内联地声明一个目标，即参数 "sources" 可以包含对其它主规则的调用。例如：</p>
<pre class="programlisting">exe hello : hello.cpp<br> [ obj helpers : helpers.cpp : &lt;optimization&gt;off ] ;</pre>
<p> Will cause "helpers.cpp" to be always compiled without
optimization. When referring to an inline main target, its declared
name must be prefixed by its parent target's name and two dots. In the
example above, to build only helpers, one should run <code class="computeroutput">bjam hello..helpers</code>.<br>
将使得 "helpers.cpp"
总是非优化地编译。在引用一个内联的主目标时，它的声明名称必须用它的父目标名称和两个点符作为前缀。在上例中，如果要只构建
helpers，你应该运行 <code class="computeroutput">bjam
hello..helpers</code>. </p>
<p>When no target is requested on the command line, all targets
in the current project will be built. If a target should be built only
by explicit request, this can be expressed by the <code class="computeroutput">explicit</code> rule:<br>
如果在命令行中没有指定目标，则当前工程中的所有目标都将被构建。如果某个目标只能通过显式请求构建，则可以用 <code class="computeroutput">explicit</code> 规则实现： </p>
<pre class="programlisting">explicit install_programs ;</pre>
<p> </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="bbv2.advanced.projects"></a>Projects
工程</h3>
</div>
</div>
</div>
<p>As mentioned before, targets are grouped into projects, and
each Jamfile is a separate project. Projects are useful because they
allow us to group related targets together, define properties common to
all those targets, and assign a symbolic name to the project that can
be used in referring to its targets.<br>
如前所述，目标是被组织到工程中的，每一个 Jamfile
是一个独立的工程。工程是非常有用的，因为它允许我们将相关联的目标组织在一起，定义对所有目标通用的属性，并赋予目标一个符号名称，以便用于对其目标的
引用。 </p>
<p>Projects are named using the <code class="computeroutput">project</code>
rule, which has the following syntax:<br>
工程是用 <code class="computeroutput">project</code>
规则来命名的，具有以下语法：
</p>
<pre class="programlisting">project <em class="replaceable"><code>id</code></em> : <em class="replaceable"><code>attributes</code></em> ;<br></pre>
<p> Here, <em class="replaceable"><code>attributes</code></em>
is a sequence of rule arguments, each of which begins with an
attribute-name and is followed by any number of build properties. The
list of attribute names along with its handling is also shown in the
table below. For example, it is possible to write:<br>
这里的 <em class="replaceable"><code>attributes</code></em>
是一个规则参数列表，其中每一个都是以属性名开头，后跟任意数量的构建属性。属性名列表及其处理在后文的表中列出。例如，你可以写：
</p>
<pre class="programlisting">project tennis<br> : requirements &lt;threading&gt;multi<br> : default-build release<br> ;<br></pre>
<p> The possible attributes are listed below.<br>
可用的属性列出如下：</p>
<p><span class="emphasis"><em>Project id</em></span>
is a short way to denote a project, as opposed to the Jamfile's
pathname. It is a hierarchical path, unrelated to filesystem, such as
"boost/thread". <a class="link" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">Target references</a>
make use of project ids to specify a target.<br>
<span class="emphasis"><em>Project id</em></span>
是表示工程的一个缩写，与 Jamfile 的路径名相反。它是一个分级路径，与文件系统无关，例如 "boost/thread"。<a class="link" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">目标引用</a> 使用
project id 来指定一个目标。</p>
<p><span class="emphasis"><em>Source location</em></span>
specifies the directory where sources for the project are located.<br>
<span class="emphasis"><em>Source location</em></span>
指定该工程的源文件所在的目录。</p>
<p><span class="emphasis"><em>Project
requirements</em></span> are requirements that apply to all
the targets in the projects as well as all subprojects.<br>
<span class="emphasis"><em>Project requirements</em></span>
是应用于该工程及所有子工程的所有目标的要求。</p>
<p><span class="emphasis"><em>Default build</em></span>
is the build request that should be used when no build request is
specified explicitly.<br>
<span class="emphasis"><em>Default build</em></span>
是在未明确指定构建请求时使用的构建请求。</p>
<p><a name="bbv2.advanced.projects.attributes.projectrule"></a>
The default values for those attributes are given in the table below.<br>
这些属性的缺省值在下表中给出。 </p>
<div class="table">
<a name="id3904292"></a>
<p class="title"><b>Table 30.3.&nbsp;<br>
表 30.3.</b></p>
<div class="table-contents">
<table class="table" summary="">
<colgroup><col><col><col><col></colgroup>
<thead><tr>
<th>Attribute<br>
属性</th>
<th>Name<br>
名字</th>
<th>Default value<br>
缺省值</th>
<th>Handling by the <code class="computeroutput">project</code>
rule<br>
<code class="computeroutput">project</code> 规则的处理</th>
</tr>
</thead><tbody>
<tr>
<td>Project id</td>
<td>none<br>
无</td>
<td>none<br>
无</td>
<td>Assigned from the first parameter of the 'project'
rule. It is assumed to denote absolute project id.<br>
从 'project' 规则的第一个参数赋值。它被假定为表示绝对的 project id。</td>
</tr>
<tr>
<td>Source location</td>
<td><code class="literal">source-location</code></td>
<td>The location of jamfile for the project<br>
本工程的 jamfile 的位置</td>
<td>Sets to the passed value<br>
设置为传入的值。</td>
</tr>
<tr>
<td>Requirements</td>
<td><code class="literal">requirements</code></td>
<td>The parent's requirements<br>
父工程的要求</td>
<td>The parent's requirements are refined with the passed
requirement and the result is used as the project requirements.<br>
将父工程的要求和传入的要求精化，结果作为工程要求。</td>
</tr>
<tr>
<td>Default build</td>
<td><code class="literal">default-build</code></td>
<td>none<br>
无</td>
<td>Sets to the passed value<br>
设置为传入的值。</td>
</tr>
<tr>
<td>Build directory</td>
<td><code class="literal">build-dir</code></td>
<td>Empty if the parent has no build directory set.
Otherwise, the parent's build directory with the relative path from
parent to the current project appended to it.<br>
如果父工程没有 build directory 设置则为空。否则，为父工程的构建目录加上从父工程到本工程的相对路径。 </td>
<td>Sets to the passed value, interpreted as relative to
the project's location.<br>
设置为传入的值，按相对于工程位置进行解释。</td>
</tr>
</tbody>
</table>
</div>
</div>
<p><br class="table-break">
</p>
<p>Besides defining projects and main targets, Jamfiles often
invoke various utility rules. For the full list of rules that can be
directly used in Jamfile see <a class="xref" href="reference.html#bbv2.reference.rules" title="Builtin rules">the
section called “Builtin rules”</a>.<br>
除了定义工程和主目标之外，Jamfiles 通常还调用一些工具规则。有关可以在 Jamfile 中直接使用的规则的完整列表，请见 <a class="xref" href="reference.html#bbv2.reference.rules" title="Builtin rules">“内建规则”一节</a>。 </p>
<p>Each subproject inherits attributes, constants and rules from
its parent project, which is defined by the nearest Jamfile in an
ancestor directory above the subproject. The top-level project is
declared in a file called <code class="filename">Jamroot</code>
rather than <code class="filename">Jamfile</code>.
When loading a project, Boost.Build looks for either <code class="filename">Jamroot</code> or <code class="computeroutput">Jamfile</code>. They are
handled identically, except that if the file is called <code class="filename">Jamroot</code>, the search for a
parent project is not performed.<br>
各子工程会继承来自于父工程的属性、常量和规则，它们是由子工程的一个最近的父目录的 Jamfile 所定义的。顶层的工程由一个名为 <code class="filename">Jamroot</code> 的文件声明，而不是 <code class="filename">Jamfile</code>。在装入一个工程时，Boost.Build
查找 <code class="filename">Jamroot</code> 或 <code class="computeroutput">Jamfile</code>。它们的处理方式是一样的，除了一点，
如果文件名为 <code class="filename">Jamroot</code>，则不再查找父工
程。 </p>
<p>Even when building in a subproject directory, parent project
files are always loaded before those of their subprojects, so that
every definition made in a parent project is always available to its
children. The loading order of any other projects is unspecified. Even
if one project refers to another via the <code class="computeroutput">use-project</code> or a target
reference, no specific order should be assumed.<br>
即使是在一个子工程目录中进行构建，父工程的文件也会在装入子工程文件之前被装入，这样在父工程中的每个定义对于子工程来说都是可用的。而其它工程的装入
顺序则是未指定的。即便一个工程通过 <code class="computeroutput">use-project</code>
或目标引用来引用了另一个工程，也不能假定某个特定顺序。 </p>
<div class="note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 说明</th>
</tr>
<tr>
<td align="left" valign="top">
<p>Giving the root project the special name “<code class="filename">Jamroot</code>” ensures that
Boost.Build won't misinterpret a directory above it as the project root
just because the directory contains a Jamfile.</p>
<p>为根工程给定一个特殊的名称 “<code class="filename">Jamroot</code>”，
可以确保 Boost.Build 不会由于更上一层的目录中含有 Jamfile 而误以为上层的目录才是工程的根。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="bbv2.advanced.build_process"></a>The
Build Process 构建过程</h3>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="advanced.html#bbv2.advanced.build_request">Build
Request 构建请求</a></span></dt>
<dt><span class="section"><a href="advanced.html#id3904629">Building a main target 构建一个主目标</a></span></dt>
<dt><span class="section"><a href="advanced.html#id3904755">Building a Project 构建一个工程</a></span></dt>
</dl>
</div>
<p>When you've described your targets, you want Boost.Build to
run the right tools and create the needed targets. This section will
describe two things: how you specify what to build, and how the main
targets are actually constructed.<br>
当你完成了对目标的描述，你就会希望 Boost.Build
可以运行正确的工具来创建所需的目标。这一节将讲述两件事：你如何指定要构建什么，以及主目标实际上是如何被构造的。 </p>
<p>The most important thing to note is that in Boost.Build,
unlike other build tools, the targets you declare do not correspond to
specific files. What you declare in a Jamfile is more like a
“metatarget.” Depending on the properties you specify on the command
line, each metatarget will produce a set of real targets corresponding
to the requested properties. It is quite possible that the same
metatarget is built several times with different properties, producing
different files.<br>
要
留意的最重要的事情是，在 Boost.Build 中，和其它构建工具不同，你所声明的目标并不对应于特定的文件。你在&nbsp;
Jamfile
中所声明的东西类似于一个“元目标”。根据你在命令行中指定的属性，各元目标会生成一组与请求属性相对应的真实目标。同一个元目标很有可能被按不同的属性
多次构建，生成不同的文件。 </p>
<div class="tip">
<table summary="Tip" border="0">
<tbody>
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr>
<td align="left" valign="top">
<p> This means that for Boost.Build, you cannot directly
obtain a build variant from a Jamfile. There could be several variants
requested by the user, and each target can be built with different
properties.<br>
这意味着，对于 Boost.Build，你不能从一个 Jamfile 直接得到一个构建体。用户可以请示多个构建体，各个目标可以按不同属性构建。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="bbv2.advanced.build_request"></a>Build
Request 构建请求</h4>
</div>
</div>
</div>
<p> The command line specifies which targets to build and with
which properties. For example:<br>
命令行指定了构建哪一个目标和按哪些属性构建。例如：
</p>
<pre class="programlisting">bjam app1 lib1//lib1 toolset=gcc variant=debug optimization=full<br></pre>
<p> would build two targets, "app1" and "lib1//lib1" with the
specified properties. You can refer to any targets, using <a class="link" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">target id</a>
and specify arbitrary properties. Some of the properties are very
common, and for them the name of the property can be omitted. For
example, the above can be written as:<br>
将按指定属性构建两个目标，"app1" 和 "lib1//lib1"。你可以用 <a class="link" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">target id</a>
指定任何目标，并指定不同的属性。有些属性很常用，这些属性的名字可以省略。例如，上一个例子可以写为：
</p>
<pre class="programlisting">bjam app1 lib1//lib1 gcc debug optimization=full<br></pre>
<p> The complete syntax, which has some additional shortcuts, is
described in <a class="xref" href="reference.html#bbv2.reference.commandline" title="Command line">the section called “Command line”</a>.<br>
完整的语法以及一些其它缩写，在 <a class="xref" href="reference.html#bbv2.reference.commandline" title="Command line">“命令行”一节</a> 中讲述。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="id3904629"></a>Building
a main target 构建一个主目标</h4>
</div>
</div>
</div>
<p>When you request, directly or indirectly, a build of a main
target with specific requirements, the following steps are done. Some
brief explanation is provided, and more details are given in <a class="xref" href="reference.html#bbv2.reference.buildprocess" title="Build process">the section called “Build process”</a>.<br>
当你直接或间接地请求按指定要求构建一个主目标时，将执行以下步骤。这里给出一些简要的解释，更多细节请见 <a class="xref" href="reference.html#bbv2.reference.buildprocess" title="Build process">“构建过程”一节</a>。 </p>
<div class="orderedlist">
<ol type="1">
<li>
<p>Applying default build. If the default-build property of a
target specifies a value of a feature that is not present in the build
request, that value is added.<br>
应用缺省构建。如果一个目标的 default-build 属性中所指定的某个特性值没有在构建请求中出现，则加上该值。</p>
</li>
<li>
<p>Selecting the main target alternative to use. For each
alternative we look how many properties are present both in
alternative's requirements, and in build request. The alternative with
large number of matching properties is selected.<br>
进行主目标选择。对于每一种选择，我们查看有多少属性在选择要求和构建请求中都出现。具有最多匹配属性的选择将被选中。 </p>
</li>
<li>
<p>Determining "common" properties. The build request is <a class="link" href="reference.html#bbv2.reference.variants.proprefine" title="Property refinement">refined</a> with target's
requirements. The conditional properties in requirements are handled as
well. Finally, default values of features are added.<br>
确定"通用"属性。构建请求要按目标要求 <a class="link" href="reference.html#bbv2.reference.variants.proprefine" title="Property refinement">精化</a>。在要求中的条件属性也同样被处理。最后，加
上特性的缺省值。 </p>
</li>
<li>
<p>Building targets referred by the sources list and
dependency properties. The list of sources and the properties can refer
to other target using <a class="link" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">target references</a>.
For each reference, we take all <a class="link" href="reference.html#bbv2.reference.features.attributes.propagated">propagated</a>
properties, refine them by explicit properties specified in the target
reference, and pass the resulting properties as build request to the
other target.<br>
构建由源列表和依赖关系属性所涉及的目标。源列表和属性可以通过 <a class="link" href="reference.html#bbv2.reference.ids" title="Target identifiers and references">目标引用</a>
引向其它目标。对于每一个引用，我们接受所有 <a class="link" href="reference.html#bbv2.reference.features.attributes.propagated">传
播进来的</a> 属性，将它们与在目标引用中指定的显式属性进行精化，并将所得到的结果属性作为构建请求传递给另一个目标。 </p>
</li>
<li>
<p>Adding the usage requirements produced when building
dependencies to the "common" properties. When dependencies are built in
the previous step, they return both the set of created "real" targets,
and usage requirements. The usage requirements are added to the common
properties and the resulting property set will be used for building the
current target.<br>
将在构建依赖关系过程中生成的使用要求加入到"通用"属性中。当上一步的依赖关系构建完成后，将返回要创建的"真实"目标集，以及使用要求。使用要求被加
入到通用属性中，得到的结果属性集将被用于构建当前目标。 </p>
</li>
<li>
<p>Building the target using generators. To convert the
sources to the desired type, Boost.Build uses "generators" --- objects
that correspond to tools like compilers and linkers. Each generator
declares what type of targets it can produce and what type of sources
it requires. Using this information, Boost.Build determines which
generators must be run to produce a specific target from specific
sources. When generators are run, they return the "real" targets.<br>
用
生成器构建目标。为了将源文件转换为所期望的类型，Boost.Build 使用了"生成器" ---
与工具相对应的对象，如编译器和链接器。每个生成器声明了它可以生成的目标类型以及它所要求的源类型。通过使用这些信息，Boost.Build
决定要运行哪些生成器来从指定源生成指定目标。当生成器运行完成，它将返回"真实"的目标。 </p>
</li>
<li>
<p>Computing the usage requirements to be returned. The
conditional properties in usage requirements are expanded and the
result is returned.<br>
计算被返回的使用要求。在使用要求中的条件属性被展开并返回结果。</p>
</li>
</ol>
</div>
<p> </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="id3904755"></a>Building
a Project 构建一个工程</h4>
</div>
</div>
</div>
<p>Often, a user builds a complete project, not just one main
target. In fact, invoking <span class="command"><strong>bjam</strong></span>
without arguments builds the project defined in the current directory.<br>
通常，用户会构建一个完整的工程，而不仅仅是某个主目标。实际上，不带参数调用 <span class="command"><strong>bjam</strong></span>
将构建在当前目标中所定义的工程。</p>
<p>When a project is built, the build request is passed without
modification to all main targets in that project. It's is possible to
prevent implicit building of a target in a project with the <code class="computeroutput">explicit</code> rule:<br>
在构建一个工程时，构建请求将不作修改地传递给工程中的所有目标。你可以用 <code class="computeroutput">explicit</code>
规则阻止工程中的的某个目标被隐式构建：
</p>
<pre class="programlisting">explicit hello_test ;<br></pre>
<p> would cause the <code class="computeroutput">hello_test</code>
target to be built only if explicitly requested by the user or by some
other target.<br>
这将使得目标 <code class="computeroutput">hello_test</code>
只有在用户或其它目标明确要求时才被构建。 </p>
<p>The Jamfile for a project can include a number of <code class="computeroutput">build-project</code> rule calls
that specify additional projects to be built.<br>
一个工程的 Jamfile 可以包含多个 <code class="computeroutput">build-project</code>
规则来调用其它特定工程的构建。 </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%">
<tbody>
<tr>
<td align="left"></td>
<td align="right">
<div class="copyright-footer"></div>
</td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="tutorial.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bbv2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="tasks.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
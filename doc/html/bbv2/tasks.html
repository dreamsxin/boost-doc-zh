<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Common tasks</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../bbv2.html" title="Chapter&nbsp;28.&nbsp;Boost.Build V2 User Manual">
<link rel="prev" href="advanced.html" title="Overview">
<link rel="next" href="extender.html" title="Extender Manual"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="advanced.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bbv2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="extender.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="bbv2.tasks"></a>Common tasks 常见任务</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tasks.html#bbv2.tasks.programs">Programs 程序</a></span></dt>
<dt><span class="section"><a href="tasks.html#bbv2.tasks.libraries">Libraries 库</a></span></dt>
<dt><span class="section"><a href="tasks.html#bbv2.tasks.alias">Alias 别名</a></span></dt>
<dt><span class="section"><a href="tasks.html#bbv2.tasks.installing">Installing 安装</a></span></dt>
<dt><span class="section"><a href="tasks.html#bbv2.builtins.testing">Testing 测试</a></span></dt>
<dt><span class="section"><a href="tasks.html#bbv2.builtins.raw">Custom commands 定制命令</a></span></dt>
<dt><span class="section"><a href="tasks.html#bbv2.reference.precompiled_headers">Precompiled Headers 预编译头文件</a></span></dt>
<dt><span class="section"><a href="tasks.html#bbv2.reference.generated_headers">Generated headers 生成头文件</a></span></dt>
</dl></div>
<p>This section describes main targets types that Boost.Build supports
  out-of-the-box. Unless otherwise noted, all mentioned main target rules have
  the common signature, described in <a class="xref" href="advanced.html#bbv2.advanced.targets" title="Declaring Targets">the section called “Declaring Targets”</a>.<br>这一章讲述 Boost.Build 缺省支持的主目标类型。除非另有说明，否则所有提到的主目标规则都具有公用签名，如&nbsp;<a class="xref" href="advanced.html#bbv2.advanced.targets" title="Declaring Targets">“声明目标”一节</a> 所述。
  </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tasks.programs"></a>Programs 程序</h3></div></div></div>
<a class="indexterm" name="id3904844"></a><p>Programs are created using the <code class="computeroutput">exe</code> rule, which follows
        the <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">common syntax</a>.
        For example:<br>程序通过 <code class="computeroutput">exe</code> 规则来创建，它遵守 <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">公用语法</a>。例如：
</p>
<pre class="programlisting">exe hello : hello.cpp some_library.lib /some_project//library<br>          : &lt;threading&gt;multi<br>          ;<br></pre>
<p>
        This will create an executable file from the sources -- in this case,
        one C++ file, one library file present in the same directory, and
        another library that is created by Boost.Build. Generally, sources
        can include C and C++ files, object files and libraries. Boost.Build
        will automatically try to convert targets of other types.<br>这将从源文件构建一个可执行文件 -- 在此例中，源文件是一个 C++ 文件，一个在同一目录下的库文件，和另外一个由 Boost.Build 创建的库文件。通常，源文件可以包括 C 和 C++ 文件，目标文件和库文件。Boost.Build
        会自动尝试转换其它类型的目标。
      </p>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top"><p>
          On Windows, if an application uses dynamic libraries, and both
          the application and the libraries are built by Boost.Build, its not
          possible to immediately run the application, because the
          <code class="literal">PATH</code> environment variable should include the path
          to the libraries. It means you have to either add the paths
          manually, or place the application and the libraries to the same
          directory. See <a class="xref" href="tasks.html#bbv2.tasks.installing" title="Installing">the section called “Installing”</a>.</p><p>在 Windows 上，如果一个应用程序使用了动态库，而且这个应用程序和库都是用 Boost.Build 构建的，那么就不能马上运行该应用程序，因为
          <code class="literal">PATH</code> 环境变量要包含这个库的路径。这意味着你必须要么手工添加这个路径，要么将应用程序和库放在同一个目录中。请见&nbsp;<a class="xref" href="tasks.html#bbv2.tasks.installing" title="Installing">“安装”一节</a>。
        </p></td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tasks.libraries"></a>Libraries 库</h3></div></div></div>
<p>Libraries are created using the <code class="computeroutput">lib</code> rule, which
        follows the <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">common
        syntax</a>. For example:<br>库通过 <code class="computeroutput">lib</code> 规则来创建，它遵守 <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">公用语法</a>。例如：
</p>
<pre class="programlisting">lib helpers : helpers.cpp : &lt;include&gt;boost : : &lt;include&gt;. ;<br></pre>

<p>
      
        In the most common case, the <code class="computeroutput">lib</code> creates a library from the
        specified sources. Depending on the value of &lt;link&gt; feature the
        library will be either static or shared. There are two other cases.
        First is when the library is installed somewhere in compiler's search
        paths, and should be searched by the compiler (typically, using the
        <code class="option">-l</code> option). The second case is where the library is
        available as a prebuilt file and the full path is known.<br>在多数情况下，<code class="computeroutput">lib</code> 从指定的源创建一个库。根据 &lt;link&gt; 特性的值，库被创建为静态或共享的。有两种例外的情形。第一个是，库被安装在编译器的查找路径中的某个位置，并且可被编译器查找到(通常是使用
        <code class="option">-l</code> 选项)。第二个情形是，库是作为预构建文件已经存在，并且知道完整的路径。
        
      </p>
<p>
        The syntax for these case is given below:<br>这种情形下的语法给出如下：
</p>
<pre class="programlisting">lib z : : &lt;name&gt;z &lt;search&gt;/home/ghost ;<br>lib compress : : &lt;file&gt;/opt/libs/compress.a ;<br></pre>
<p>
        The <code class="computeroutput">name</code> property specifies the name that should be
        passed to the <code class="option">-l</code> option, and the <code class="computeroutput">file</code>
        property specifies the file location. The <code class="varname">search</code> feature
        specifies paths in which to search for the library. That feature can
        be specified several times, or it can be omitted, in which case only
        default compiler paths will be searched.<br>属性 <code class="computeroutput">name</code> 指明传递给 <code class="option">-l</code> 选项的名字，而属性 <code class="computeroutput">file</code>
        则指明文件位置。属性 <code class="varname">search</code> 指明在哪些路径查找该库。这个特性可以多次指定，或者省略，省略的话则只查找缺省的编译器路径。
      </p>
<p>The difference between using the <code class="varname">file</code> feature as
        opposed to the <code class="varname">name</code> feature together with the
        <code class="varname">search</code> feature is that <code class="varname">file</code> is more
        precise. A specific file will be used. On the other hand, the
        <code class="varname">search</code> feature only adds a library path, and the
        <code class="varname">name</code> feature gives the basic name of the library. The
        search rules are specific to the linker. For example, given these
        definition:<br>使用 <code class="varname">file</code> 特性和使用 <code class="varname">name</code> 特性加
        <code class="varname">search</code> 特性的差别在于，<code class="varname">file</code> 更加精确。它会使用一个指定的文件。另一方面，<code class="varname">search</code> 特性只是增加一个库路径，而
        <code class="varname">name</code> 特性则给出库的基本名。查找的规则由链接器来定。例如，给出以下定义：
</p>
<pre class="programlisting">lib a : : &lt;variant&gt;release &lt;file&gt;/pool/release/a.so ;<br>lib a : : &lt;variant&gt;debug &lt;file&gt;/pool/debug/a.so ;<br>lib b : : &lt;variant&gt;release &lt;file&gt;/pool/release/b.so ;<br>lib b : : &lt;variant&gt;debug &lt;file&gt;/pool/debug/b.so ;<br></pre>
<p>
        It's possible to use release version of <code class="computeroutput">a</code> and debug
        version of <code class="computeroutput">b</code>. Had we used the <code class="varname">name</code> and
        <code class="varname">search</code> features, the linker would always pick either
        release or debug versions.<br>这样可以同时使用 <code class="computeroutput">a</code> 的发布版本和 <code class="computeroutput">b</code> 的调试版本。如果我们使用 <code class="varname">name</code> 和
        <code class="varname">search</code> 特性，则链接器总是使用发布版本或总是使用调试版本。
        
      </p>
<p>
        For convenience, the following syntax is allowed:<br>为方便起见，以下语法是允许的：
</p>
<pre class="programlisting">lib z ;<br>lib gui db aux ;<br></pre>
<p>
          and is does exactly the same as:<br>它们与下面的写法是完全一样的：
</p>
<pre class="programlisting">lib z : : &lt;name&gt;z ;<br>lib gui : : &lt;name&gt;gui ;<br>lib db : : &lt;name&gt;db ;<br>lib aux : : &lt;name&gt;aux ;<br></pre>

<p>
      
        When a library uses another library you should put that other library in
        the list of sources. This will do the right thing in all cases. For
        portability, you should specify library dependencies even for searched
        and prebuilt libraries, othewise, static linking on Unix will not work.
        For example:<br>当一个库使用了另一个库时，你应该将另一个库列入源列表中。这在任何情况下都是正确的。为了移植性，你应该对查找的库和预构建的库都指明库的依赖关系，否则 在 Unix 上静态链接将不能工作。例如：
</p>
<pre class="programlisting">lib z ;<br>lib png : z : &lt;name&gt;png ;<br></pre>
<p>
        </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 说明</th>
</tr>
<tr><td align="left" valign="top"><p>
          When a library (say, <code class="computeroutput">a</code>), that has another library, (say,
          <code class="computeroutput">b</code>)
          
          is linked dynamically, the <code class="computeroutput">b</code>
          library will be incorporated
          
          in <code class="computeroutput">a</code>. (If <code class="computeroutput">b</code>
          is dynamic library as well, then <code class="computeroutput">a</code> will only refer to it,
          and not include any extra code.)
          
          When the <code class="computeroutput">a</code>
          library is linked statically, Boost.Build will assure that all
          executables that link to <code class="computeroutput">a</code> will also link to
          <code class="computeroutput">b</code>.</p><p>当一个库(称为 <code class="computeroutput">a</code>)，它带有另一个库(称为
          <code class="computeroutput">b</code>)
          
         ，被动态链接时，库 <code class="computeroutput">b</code>
          将与 <code class="computeroutput">a</code> 合成一体。(如果 <code class="computeroutput">b</code>
          也是动态链接的，则 <code class="computeroutput">a</code> 只是引用它而不包含任何额外代码)。当库 <code class="computeroutput">a</code>
          被静态链接时，Boost.Build 将保证所有链接 <code class="computeroutput">a</code> 的可执行文件都链接了
          <code class="computeroutput">b</code>。
        </p></td></tr>
</tbody></table></div>
<p>
        One feature of Boost.Build that is very important for libraries is usage
        requirements.
        
        For example, if you write:<br>Boost.Build 中一个对于库而言非常重要的特性就是使用要求。例如，如果你写了：
</p>
<pre class="programlisting">lib helpers : helpers.cpp : : : &lt;include&gt;. ;<br></pre>
<p>
        then the compiler include path for all targets that use
        <code class="computeroutput">helpers</code> will contain the directory
        
        where the target is defined.path to "helpers.cpp". The user
        only needs to add <code class="computeroutput">helpers</code> to the list of sources,
        and needn't consider the requirements its use imposes on a
        dependent target. This feature greatly simplifies Jamfiles.<br>那么对于所有使用了
        <code class="computeroutput">helpers</code> 的目标来说，编译器包含路径将包含该目标的定义目录和 "helpers.cpp" 的路径。用户只需要将 <code class="computeroutput">helpers</code> 加到源列表中即可，无需考虑由被依赖目标所施加的要求。这一特性极大地简化了 Jamfiles.
        
      </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 说明</th>
</tr>
<tr><td align="left" valign="top">
<p>If you don't want shared libraries to include all libraries
          that are specified in sources (especially statically linked ones),
          you'd need to use the following:</p><p>如果你不希望共享库包含在源中指定的所有库(尤其是静态链接的库)，你需要使用以下方法：
</p>
<pre class="programlisting">lib b : a.cpp ;<br>lib a : a.cpp : &lt;use&gt;b : : &lt;library&gt;b ;<br></pre>
<p>
          This specifies that <code class="computeroutput">a</code> uses <code class="computeroutput">b</code>, and causes
          all executables that link to <code class="computeroutput">a</code> also link to
          <code class="computeroutput">b</code>. In this case, even for shared linking, the
          <code class="computeroutput">a</code> library won't even refer to <code class="computeroutput">b</code>.<br>这指明 <code class="computeroutput">a</code> 使用 <code class="computeroutput">b</code>，导致链接 <code class="computeroutput">a</code> 的所有可执行文件也链接
          <code class="computeroutput">b</code>。在这种情况下，即使是共享链接，库 <code class="computeroutput">a</code> 也不会引向 <code class="computeroutput">b</code>.
        </p>
</td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tasks.alias"></a>Alias 别名</h3></div></div></div>
<p>
        The <code class="computeroutput">alias</code> rule gives an alternative name to
        a group of targets. For example, to give the name
        <code class="filename">core</code> to a group of three other targets with the
        following code:<br>规则 <code class="computeroutput">alias</code> 为一组目标给定一个别名。例如，以下代码为由三个目标组成的组给定名字
        <code class="filename">core</code>：
        </p>
<pre class="programlisting">alias core : im reader writer ;</pre>
<p>
        Using <code class="filename">core</code> on the command line, or in the source
        list of any other target is the same as explicitly using
        <code class="filename">im</code>, <code class="filename">reader</code>, and
        <code class="filename">writer</code>, but it is just more convenient.<br>在命令行或其它目标的源列表中使用 <code class="filename">core</code>，和使用
        <code class="filename">im</code>, <code class="filename">reader</code>, 及
        <code class="filename">writer</code> 是一样的，只不过更方便些。
      </p>
<p>
        Another use of the <code class="computeroutput">alias</code> rule is to change build
        properties. For example, if you always want static linking for a
        specific C++ Boost library, you can write the following:<br><code class="computeroutput">alias</code> 规则的另一个用途是改变构建属性。例如，如果你希望对某个特定的 C++ Boost 库总是采用静态链接，你可以这样写：
</p>
<pre class="programlisting">alias threads : /boost/thread//boost_thread : &lt;link&gt;static ;<br></pre>
<p>
        and use only the <code class="computeroutput">threads</code> alias in your Jamfiles.<br>然后在你的 Jamfiles 中只需要用 <code class="computeroutput">threads</code> 别名就行了。
      </p>
<p>
        You can also specify usage requirements for the
        <code class="computeroutput">alias</code> target. If you write the following:<br>你也可以为
        <code class="computeroutput">alias</code> 目标指定使用要求。如果你这样写：
</p>
<pre class="programlisting">alias header_only_library : : : :  &lt;include&gt;/usr/include/header_only_library ;<br></pre>
<p>
        then using <code class="computeroutput">header_only_library</code> in sources will only add an
        include path. Also note that when an alias has sources, their usage
        requirements are propagated as well. For example:<br>那么在源文件中使用 <code class="computeroutput">header_only_library</code> 只需要加一个包含路径。还要注意，如果一个别名也具有源，则源的使用要求也会被传播。例如：
</p>
<pre class="programlisting">lib library1 : library1.cpp : : : &lt;include&gt;/library/include1 ;<br>lib library2 : library2.cpp : : : &lt;include&gt;/library/include2 ;<br>alias static_libraries : library1 library2 : &lt;link&gt;static ;<br>exe main : main.cpp static_libraries ;<br></pre>
<p>
        will compile <code class="filename">main.cpp</code> with additional includes
        required for using the specified static libraries.<br>将以额外的包含要求并使用指定的静态库来编译 <code class="filename">main.cpp</code>。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tasks.installing"></a>Installing 安装</h3></div></div></div>
<p>This section describes various ways to install built target
      and arbitrary files.<br>本节讲述安装构建目标及任意文件的几种方法。</p>
<h4>
<a name="id3905416"></a>Basic install 基本安装</h4>
<p>For installing a built target you should use the
        <code class="computeroutput">install</code> rule, which follows the <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">common syntax</a>. For
        example:<br>要安装一个构建目标，你要使用 <code class="computeroutput">install</code> 规则，它遵守 <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">公用语法</a>。例如：
</p>
<pre class="programlisting">install dist : hello helpers ;<br></pre>
<p>
        will cause the targets <code class="computeroutput">hello</code> and <code class="computeroutput">helpers</code> to
        be moved to the <code class="filename">dist</code> directory, relative to
        Jamfile's directory. The directory can
        be changed with the <code class="computeroutput">location</code> property:<br>将导致目标 <code class="computeroutput">hello</code> 和 <code class="computeroutput">helpers</code> 被移动至相对于 Jamfile&nbsp;目录的 <code class="filename">dist</code> 目录中。该目录可以用 <code class="computeroutput">location</code> 属性来修改：
</p>
<pre class="programlisting">install dist : hello helpers : &lt;location&gt;/usr/bin ;<br></pre>
<p>
        While you can achieve the same effect by changing the target name to
        <code class="filename">/usr/bin</code>, using the <code class="computeroutput">location</code>
        property is better, because it allows you to use a mnemonic target
        name.<br>虽然你也可以通过将目标名改为 <code class="filename">/usr/bin</code> 来得到相同效果，但是使用 <code class="computeroutput">location</code>
        属性更好一些，因为它允许你使用更易记的目标名。
      </p>
<p>The <code class="computeroutput">location</code> property is especially handy when the location
        is not fixed, but depends on build variant or environment variables:<br>当位置不是固定的而是由构建体或环境变量决定时，属性 <code class="computeroutput">location</code> 尤其方便：
</p>
<pre class="programlisting">install dist : hello helpers : &lt;variant&gt;release:&lt;location&gt;dist/release<br>                             &lt;variant&gt;debug:&lt;location&gt;dist/debug ;<br>install dist2 : hello helpers : &lt;location&gt;$(DIST) ;</pre><p>
        See also <a class="link" href="reference.html#bbv2.reference.variants.propcond" title="Conditional properties">conditional
          properties</a> and <a class="link" href="faq.html#bbv2.faq.envar" title="Accessing environment variables">environment variables</a><br>请参见 <a class="link" href="reference.html#bbv2.reference.variants.propcond" title="Conditional properties">条件属性</a> 和 <a class="link" href="faq.html#bbv2.faq.envar" title="Accessing environment variables">环境变量</a>
      </p>
<h4>
<a name="id3905531"></a>Installing with all dependencies 安装所有依赖物</h4>
<p>
        Specifying the names of all libraries to install can be boring. The
        <code class="computeroutput">install</code> allows you to specify only the top-level executable
        targets to install, and automatically install all dependencies:<br>指定要安装的所有库的名字会很令人厌烦。<code class="computeroutput">install</code> 允许你只指定要安装的顶层可执行目标，并自动安装所有依赖物：
</p>
<pre class="programlisting">install dist : hello<br>           : &lt;install-dependencies&gt;on &lt;install-type&gt;EXE<br>             &lt;install-type&gt;LIB<br>           ;<br></pre>
<p>
        will find all targets that <code class="computeroutput">hello</code> depends on, and install
        all of those which are either executables or libraries. More
        specifically, for each target, other targets that were specified as
        sources or as dependency properties, will be recursively found.  One
        exception is that targets referred with the <a class="link" href="reference.html#bbv2.builtin.features.use"><code class="computeroutput">use</code></a> feature
        are not considered, because that feature is typically used to refer to
        header-only libraries.
        If the set of target types is specified, only targets of that type
        will be installed, otherwise, all found target will be installed.<br>这将查找 <code class="computeroutput">hello</code> 所依赖的所有目标，并安装所有目标的可执行文件或库文件。具体地说，对于每一个目标，被指定为源或依赖属性的其它目标都会被递归查找。一个例外是，那些以 <a class="link" href="reference.html#bbv2.builtin.features.use"><code class="computeroutput">use</code></a> 特性指定的目标不被考虑，因为这个特性是专门用于指定只含头文件的库的。如果指定了目标类型集，则只有该类型的目标被安装，否则，所有目标都被安装。
      </p>
<h4>
<a name="id3905583"></a>Preserving Directory Hierarchy 保留目录层次</h4>
<a class="indexterm" name="id3905587"></a><p>By default, the <code class="computeroutput">install</code> rules will stip paths from
      it's sources. So, if sources include <code class="filename">a/b/c.hpp</code>,
      the <code class="filename">a/b</code> part will be ignored. To make the
      <code class="computeroutput">install</code> rule preserve the directory hierarchy you need
      to use the <code class="computeroutput">install-source-root</code> feature to specify the
      root of the hierarchy you are installing. Relative paths from that
      root will be preserved. For example, if you write:<br>缺省地，<code class="computeroutput">install</code> 规则会修改来源的路径。即，如果源中包含有 <code class="filename">a/b/c.hpp</code>，则 <code class="filename">a/b</code> 部分将被忽略。如果要让
      <code class="computeroutput">install</code> 规则保留目录的层次，你就需要使用 <code class="computeroutput">install-source-root</code> 特性来指定你要安装的目录层次的根。从根起的相对路径将被保留。例如，如果你写：

</p>
<pre class="programlisting">install headers<br>    : a/b/c.h<br>    : &lt;location&gt;/tmp &lt;install-source-root&gt;a<br>    ;<br></pre>
<p>

      the a file named <code class="filename">/tmp/b/c.h</code> will be created.<br>那么将创建一个名为 <code class="filename">/tmp/b/c.h</code> 的文件。
      </p>
<p>The <a class="link" href="reference.html#bbv2.reference.glob-tree">glob-tree</a> rule
      can be used to find all files below a given directory, making
      it easy to install entire directory tree.<br>规则 <a class="link" href="reference.html#bbv2.reference.glob-tree">glob-tree</a> 可以用于查找位于给定目录之下的所有文件，这使得安装整个目录树变得容易。</p>
<h4>
<a name="id3905663"></a>Installing into Several Directories 安装到多个目录</h4>
<p>The <a class="link" href="tasks.html#bbv2.tasks.alias" title="Alias"><code class="computeroutput">alias</code></a>
      rule can be used when targets must be installed into several
      directories:<br><a class="link" href="tasks.html#bbv2.tasks.alias" title="Alias"><code class="computeroutput">alias</code></a>
      规则可用于将目标安装到多个目录中：
</p>
<pre class="programlisting">alias install : install-bin install-lib ;<br>install install-bin : applications : /usr/bin ;<br>install install-lib : helper : /usr/lib ;<br></pre>

<p>
    
      Because the <code class="computeroutput">install</code> rule just copies targets, most free
      features <sup>[<a name="id3905699" href="tasks.html#ftn.id3905699" class="footnote">8</a>]</sup>
      have no effect when used in requirements of the <code class="computeroutput">install</code> rule.
      The only two which matter are <a class="link" href="reference.html#bbv2.builtin.features.dependency"><code class="varname">dependency</code>
      </a> and, on Unix, <a class="link" href="reference.html#bbv2.reference.features.dll-path">
      <code class="varname">dll-path</code></a>.<br>因为 <code class="computeroutput">install</code> 规则只是复制目标，在&nbsp;<code class="computeroutput">install</code> 规则的要求中使用的多数自由特性<sup>[<a name="id3905699" href="#ftn.id3905699" class="footnote">8</a>]</sup>都是没有作用的。有用的只有两个，<a class="link" href="reference.html#bbv2.builtin.features.dependency"><code class="varname">dependency</code>
      </a> 和 Unix 上的 <a class="link" href="reference.html#bbv2.reference.features.dll-path">
      <code class="varname">dll-path</code></a>.
    </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 说明</th>
</tr>
<tr><td align="left" valign="top"><p>
        (Unix specific). On Unix, executables built with Boost.Build typically
        contain the list of paths to all used dynamic libraries. For installing,
        this is not desired, so Boost.Build relinks the executable with an empty
        list of paths. You can also specify additional paths for installed
        executables with the <code class="varname">dll-path</code> feature.<br>(专用于Unix)。在 Unix 上，用 Boost.Build 构建的可执行文件通常包含有所有被使用的动态库的路径列表。对于安装而言，这些不是想要的，所以 Boost.Build 重新用空的路径列表来链接可执行文件。你也可以用 <code class="varname">dll-path</code> 特性来为安装的可执行文件指定其它路径。
      </p></td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.builtins.testing"></a>Testing 测试</h3></div></div></div>
<p>
        Boost.Build has convenient support for running unit tests. The simplest
        way is the <code class="computeroutput">unit-test</code> rule, which follows the <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">common syntax</a>. For
        example:<br>Boost.Build 对于单元测试的运行有很方便的支持。最简单的方法是 <code class="computeroutput">unit-test</code> 规则，它遵守 <a class="link" href="advanced.html#bbv2.main-target-rule-syntax">公用语法</a>。例如：
</p>
<pre class="programlisting">unit-test helpers_test : helpers_test.cpp helpers ;<br></pre>

<p>
      The <code class="computeroutput">unit-test</code> rule behaves like the
        <code class="computeroutput">exe</code> rule, but after the executable is created it is
        run. If the executable returns an error code, the build system will also
        return an error and will try running the executable on the next
        invocation until it runs successfully. This behaviour ensures that you
        can't miss a unit test failure.<br><code class="computeroutput">unit-test</code> 规则很象
        <code class="computeroutput">exe</code> 规则，不过在可执行文件创建之后将运行它。如果可执行文件返回一个错误代码，构建系统也将返回一个错误，并且在下一次调用时再尝试运行这个可执行文件，直至运行成功。这一行为确保了你不可能遗漏任一个单元测试失败。
      </p>
<p>By default, the executable is run directly. Sometimes, it's
      desirable to run the executable using some helper command. You should use the
      <code class="literal">testing.launcher</code> property to specify the name of the
      helper command. For example, if you write:<br>缺省地，可执行文件是直接运行的。有时，你会想要用一些辅助命令来运行这个可执行文件。你可以使用
      <code class="literal">testing.launcher</code> 属性来指定辅助命令的名称。例如，如果你这样写：
      </p>
<pre class="programlisting">unit-test helpers_test<br>   : helpers_test.cpp helpers<br>   : <span class="bold"><strong>&lt;testing.launcher&gt;valgrind</strong></span>
   ;
</pre>
<p>The command used to run the executable will be:<br>则用于运行可执行文件的命令将是：</p>
<pre class="screen"><span class="bold"><strong>valgrind</strong></span> bin/$toolset/debug/helpers_test<br></pre>
<p>There are few specialized testing rules, listed below:<br>有几个特殊的测试规则，列出如下：
      </p>
<pre class="programlisting">rule compile ( sources : requirements * : target-name ? )<br>rule compile-fail ( sources : requirements * : target-name ? )<br>rule link ( sources + : requirements * : target-name ? )<br>rule link-fail ( sources + : requirements * : target-name ? )<br>      </pre>
<p>
      They are are given a list of sources and requirements.
      If the target name is not provided, the name of the first
      source file is used instead. The <code class="literal">compile*</code>
      tests try to compile the passed source. The <code class="literal">link*</code>
      rules try to compile and link an application from all the passed sources.
      The <code class="literal">compile</code> and <code class="literal">link</code> rules expect
      that compilation/linking succeeds. The <code class="literal">compile-fail</code>
      and <code class="literal">link-fail</code> rules, on the opposite, expect that
      the compilation/linking fails.<br>它们被给定一个源列表和要求列表。如果目标名未提供，则用第一个源文件的名字代替。<code class="literal">compile*</code>
      测试会尝试编译传入的源文件。而 <code class="literal">link*</code>
      规则则尝试从所有传入的源文件编译并链接一个应用程序。<code class="literal">compile</code> 规则和 <code class="literal">link</code> 规则预期编译/链接可以成功。而 <code class="literal">compile-fail</code> 规则和 <code class="literal">link-fail</code> 规则则相反，它们预期编译/链接将失败。
      </p>
<p>There are two specialized rules for running applications, which
      are more powerful than the <code class="computeroutput">unit-test</code> rule. The
      <code class="computeroutput">run</code> rule has the following signature:<br>还有两个运行应用程序的特殊规则，比 <code class="computeroutput">unit-test</code> 规则更强大。<code class="computeroutput">run</code> 规则具有以下签名：
      </p>
<pre class="programlisting">rule run ( sources + : args * : input-files * : requirements * : target-name ?<br>    : default-build * )<br>      </pre>
<p>
      The rule builds application from the provided sources and runs it,
      passing <code class="varname">args</code> and <code class="varname">input-files</code>
      as command-line arguments. The <code class="varname">args</code> parameter
      is passed verbatim and the values of the <code class="varname">input-files</code>
      parameter are treated as paths relative to containing Jamfile, and are
      adjusted if <span class="command"><strong>bjam</strong></span> is invoked from a different
      directory. The <code class="computeroutput">run-fail</code> rule is identical to the
      <code class="computeroutput">run</code> rule, except that it expects that the run fails.<br>这个规则从给定的源文件构建应用程序并运行它，传入 <code class="varname">args</code> 和 <code class="varname">input-files</code>
      作为命令行参数。参数 <code class="varname">args</code> 是逐个字传递的，而 <code class="varname">input-files</code>
      参数的值则被视为相对于包含 Jamfile 的目录的路径，如果你是从另一个目录调用 <span class="command"><strong>bjam</strong></span> 的，则该路径还将被调整。<code class="computeroutput">run-fail</code> 规则和
      <code class="computeroutput">run</code> 规则相同，除了它预期运行将失败以外。
      </p>
<p>All rules described in this section, if executed successfully,
      create a special manifest file to indicate that the test passed.
      For the <code class="computeroutput">unit-test</code> rule the files is named
      <code class="filename"><em class="replaceable"><code>target-name</code></em>.passed</code> and
      for the other rules it is called
      <code class="filename"><em class="replaceable"><code>target-name</code></em>.test</code>.
      The <code class="computeroutput">run*</code> rules also capture all output from the program,
      and store it in a file named
      <code class="filename"><em class="replaceable"><code>target-name</code></em>.output</code>.<br>在本节所讲述的所有规则，如果执行成功，则创建一个特定的证明文件来表示测试通过。对于 <code class="computeroutput">unit-test</code> 规则，证明文件被命名为
      <code class="filename"><em class="replaceable"><code>target-name</code></em>.passed</code>，而对于其它规则，则名为
      <code class="filename"><em class="replaceable"><code>target-name</code></em>.test</code>。<code class="computeroutput">run*</code> 规则还会从程序捕获所有输出，并将它保存在一个名为 <code class="filename"><em class="replaceable"><code>target-name</code></em>.output</code> 的文件中。</p>
<p>The <code class="computeroutput">run</code> and the <code class="computeroutput">run-fail</code> rules, if
      the test passes, automatically delete the linked executable, to
      save space. This behaviour can be suppressed by passing the
      <code class="literal">--preserve-test-targets</code> command line option.<br>如果测试通过，<code class="computeroutput">run</code> 规则和 <code class="computeroutput">run-fail</code> 规则将自动删除链接的可执行文件，以节省空间。这一行为可以通过传入
      <code class="literal">--preserve-test-targets</code> 命令行选项来禁止。</p>
<p>It is possible to print the list of all test targets (except for
      <code class="computeroutput">unit-test</code>) declared in your project, by passing
      the <code class="literal">--dump-tests</code> command-line option. The output
      will consist of lines of the form:<br>你可以通过传入 <code class="literal">--dump-tests</code> 命令行选项来打印在你的工程中声明的所有测试目标的列表(除了
      <code class="computeroutput">unit-test</code>)。输出将由以下格式的行组成：
      </p>
<pre class="screen">boost-test(<em class="replaceable"><code>test-type</code></em>) <em class="replaceable"><code>path</code></em> : <em class="replaceable"><code>sources</code></em>
      </pre>

<p>
      It is possible to process the list of tests, the output of
      bjam during command run, and the presense / absense of the
      <code class="filename">*.test</code> files created when test passes into
      human-readable status table of tests. Such processing utilities
      are not included in Boost.Build.<br>你可以对测试列表、命令运行期间的 bjam 输出，以及 <code class="filename">*.test</code> 文件的存在与否进行处理，形成人工可读的测试状态表。这些处理工具并不包含在 Boost.Build 中。</p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.builtins.raw"></a>Custom commands 定制命令</h3></div></div></div>
<p>
        When you use most of main target rules, Boost.Build automatically
        figures what commands to run and it what order. As soon as you want to
        use new file types, or support new tools, one approach is to extend
        Boost.Build to smoothly support them, as documented in
        <a class="xref" href="extender.html" title="Extender Manual">the section called “Extender Manual”</a>. However, if there's a single place
        where the new tool is used, it might be easier to just explicitly
        specify the commands to run.<br>当你使用多数主目标规则时，Boost.Build 会自动推算出运行哪些命令以及以命令的顺序。一旦你想使用新的文件类型，或者支持新的工具，一个方法就是，扩展
        Boost.Build 以平滑地支持它们，正如在
        <a class="xref" href="extender.html" title="Extender Manual">“扩展手册”一节</a> 中所介绍的。但是，如果新工具只在一个地方使用，就可以更容易解决，你只要明确指出运行的命令即可。
      </p>
<p>
        
        Three main target rules can be used for that. The <code class="computeroutput">make
        </code> rule allows you to construct a single file from any
        number of source file, by running a command you specify. The
        <code class="computeroutput">notfile</code> rule allows you to run an arbitrary
        command, without creating any files. And finaly, the <code class="computeroutput">
        generate</code> rule allows you to describe transformation using
        Boost.Build's virtual targets. This is higher-level than file names that
        the <code class="computeroutput">make</code> rule operates with and allows you
        to create more than one target, create differently named targets
        depending on properties or use more than one tool.<br>有三个主目标规则可以用于此。<code class="computeroutput">make
        </code> 规则允许你从任意数量的源文件，通过运行你指定的命令，来构造一个文件。<code class="computeroutput">notfile</code> 规则允许你运行一个任意命令，而不创建任何文件。最后，<code class="computeroutput">generate</code> 规则允许你使用
        Boost.Build 的虚拟目标来描述转换。<code class="computeroutput">make</code> 规则所操作的对象比文件名更高级，你可以创建一个以上的目标，可以根据属性或使用更多工具来创建不同的命名目标。
      </p>
<p>
        The <code class="computeroutput">make</code> rule is used when you want to
        create one file from a number of sources using some specific command.
        The <code class="computeroutput">notfile</code> is used to unconditionally run
        a command.<br><code class="computeroutput">make</code> 规则在你要使用特定命令从多个源文件创建一个文件时使用。<code class="computeroutput">notfile</code>&nbsp;则用于无条件运行一个命令。
      </p>
<p>
        Suppose you want to create file <code class="filename">file.out</code> from file
        <code class="filename">file.in</code> by running command
        <span class="command"><strong>in2out</strong></span>. Here is how you would do this in Boost.Build:<br>假设你想运行命令
        <span class="command"><strong>in2out</strong></span> 从文件
        <code class="filename">file.in</code> 创建文件 <code class="filename">file.out</code>。以下是你在 Boost.Build 中要做的：
</p>
<pre class="programlisting">make file.out : file.in : @in2out ;<br>actions in2out<br>{<br>    in2out $(&lt;) $(&gt;)<br>}<br></pre>
<p>
        If you run <span class="command"><strong>bjam</strong></span> and <code class="filename">file.out</code>
        does not exist, Boost.Build will run the <span class="command"><strong>in2out</strong></span>
        command to create that file. For more details on specifying actions, see
        <a class="xref" href="advanced.html#bbv2.advanced.jam_language.actions">the section called “Boost.Jam Language”</a>.<br>如果你运行 <span class="command"><strong>bjam</strong></span> 而 <code class="filename">file.out</code>
        不存在，则 Boost.Build 会运行 <span class="command"><strong>in2out</strong></span>
        命令来创建这一文件。有关特定动作的细节，请见<a class="xref" href="advanced.html#bbv2.advanced.jam_language.actions"> “Boost.Jam 语言”一节</a>。
      </p>
<p>
        It could be that you just want to run some command unconditionally, and
        that command does not create any specific files. For that you can use
        the <code class="computeroutput">notfile</code> rule. For example:<br>有可能你只是想无条件地运行一些命令，而这些命令并不创建任何特定的文件。你可以使用 <code class="computeroutput">notfile</code> 规则。例如：
</p>
<pre class="programlisting">notfile echo_something : @echo ;<br>actions echo<br>{<br>    echo "something"<br>}<br></pre>

<p>
        The only difference from the <code class="computeroutput">make</code> rule is
        that the name of the target is not considered a name of a file, so
        Boost.Build will unconditionally run the action.<br>它与 <code class="computeroutput">make</code> 规则的差别只在于目标的名字不被认为是一个文件名，所以 Boost.Build 将无条件运行该动作。
      </p><p>
        
        The <code class="computeroutput">generate</code> rule is used when you want to
        express transformations using Boost.Build's virtual targets, as opposed
        to just filenames. The <code class="computeroutput">generate</code> rule has
        the standard main target rule signature, but you are required to specify
        the <code class="literal">generating-rule</code> property. The value of the
        property should be in the form
        <code class="literal">@<em class="replaceable"><code>rule-name</code></em></code>, the named rule
        should have the following signature:<br>规则 <code class="computeroutput">generate</code> 在你想用 Boost.Build 虚拟目标来表示一种转换时使用。<code class="computeroutput">generate</code> 规则具有标准的主目标规则签名，不过你要指定 <code class="literal">generating-rule</code> 属性。该属性的值应该形如
        <code class="literal">@<em class="replaceable"><code>rule-name</code></em></code>，这个命名规则应具有以下签名：
</p>
<pre class="programlisting">rule generating-rule ( project name : property-set : sources * )<br></pre>
<p>
        and will be called with an instance of the <code class="computeroutput">project-target</code>
        class, the name of the main target, an instance of the
        <code class="computeroutput">property-set</code> class containing build properties, and the
        list of instances of the <code class="computeroutput">virtual-target</code> class corresponding
        to sources. The rule must return a list of <code class="computeroutput">virtual-target</code>
        instances. The interface of the <code class="computeroutput">virtual-target</code> class can be
        learned by looking at the <code class="filename">build/virtual-target.jam</code>
        file. The <code class="filename">generate</code> example contained in the
        Boost.Build distribution illustrates how the <code class="literal">generate</code>
        rule can be used.<br>而且该规则将被以一个 <code class="computeroutput">project-target</code>
        类的实例、主目标名、一个包含构建属性的
        <code class="computeroutput">property-set</code> 类的实例，以及与源目标相对应的 <code class="computeroutput">virtual-target</code> 类实例的列表来调用。该规则必须返回一个 <code class="computeroutput">virtual-target</code>
        实例列表。<code class="computeroutput">virtual-target</code> 类的接口可以从 <code class="filename">build/virtual-target.jam</code>
        文件中看到。包含在 Boost.Build 分发包中的 <code class="filename">generate</code> 例子示范了如何使用 <code class="literal">generate</code>
        规则。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.reference.precompiled_headers"></a>Precompiled Headers 预编译头文件</h3></div></div></div>
<p>
        Precompiled headers is a mechanism to speed up compilation by creating a
        partially processed version of some header files, and then using that
        version during compilations rather then repeatedly parsing the original
        headers. Boost.Build supports precompiled headers with gcc and msvc
        toolsets.<br>预编译头文件是一种加快编译速度的机制，它创建一些头文件的部分处理版本，然后在编译期间使用这些版本，而不用对原始的头文件进行重复分析。Boost.Build 支持 gcc 和 msvc
        工具集的预编译头文件。
      </p>
<p>
        To use precompiled headers, follow the following steps:<br>要使用预编译头文件，请按以下步骤：
      </p>
<div class="orderedlist"><ol type="1">
<li><p>
          Create a header that includes headers used by your project that you
          want precompiled. It is better to include only headers that are
          sufficiently stable — like headers from the compiler and
          external libraries. Please wrap the header in <code class="computeroutput">#ifdef
          BOOST_BUILD_PCH_ENABLED</code>, so that the potentially expensive
          inclusion of headers is not done when PCH is not enabled. Include the
          new header at the top of your source files.<br>创建一个头文件，其中包含你在工程中想要预编译的头文件。最好只包含那些足够稳定的头文件 — 如来自于编译器和外部库的头文件。将这个新建的头文件用 <code class="computeroutput">#ifdef
          BOOST_BUILD_PCH_ENABLED</code> 包围起来，这样在 PCH 未打开时就不会有头文件包含的潜在代价。然后，在你的源文件的顶部包含这个新的头文件。
        </p></li>
<li>
<p>
          Declare a new Boost.Build target for the precompiled header and add
          that precompiled header to the sources of the target whose compilation
          you want to speed up:<br>为预编译头文件声明一个新的 Boost.Build 目标，并将预编译头文件增加到你想要加速编译的目标的源中：
</p>
<pre class="programlisting">cpp-pch pch : pch.hpp ;<br>exe main : main.cpp pch ;<br></pre>
<p>
          You can use the <code class="computeroutput">c-pch</code> rule if you want to
          use the precompiled header in C programs.<br>如果你想在 C 程序中使用预编译头文件，可以使用 <code class="computeroutput">c-pch</code> 规则。
        </p>
</li>
</ol></div>
<p>
        The <code class="filename">pch</code> example in Boost.Build distribution can be
        used as reference.<br>在 Boost.Build 分发包中的 <code class="filename">pch</code> 例子可以作为参考。
      </p>
<p>
        Please note the following:<br>请注意以下事项：
      </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
          The inclusion of the precompiled header must be the first thing in a
          source file, before any code or preprocessor directives.<br>预编译头文件的包含必须是源文件中的第一件事，在任何代码或预处理指令之前。
        </p></li>
<li><p>
          The build properties used to compile the source files and the
          precompiled header must be the same. Consider using project
          requirements to assure this.<br>用于编译源文件和预编译头文件的构建属性必须一致。可以考虑使用工程要求来确保这一点。
        </p></li>
<li><p>
          Precompiled headers must be used purely as a way to improve
          compilation time, not to save the number of <code class="computeroutput">#include</code>
          statements. If a source file needs to include some header, explicitly
          include it in the source file, even if the same header is included
          from the precompiled header. This makes sure that your project will
          build even if precompiled headers are not supported.<br>预编译头文件必须纯粹用作一种减少编译时间的方法，而不是为了节约 <code class="computeroutput">#include</code> 语句的数量。如果一个源文件需要包含某些头文件，就明确地在源文件中包含它，即使这些头文件已经在预编译头文件中包含。这样可以确保即使在不支持预编译头文件的情况下，你的工程也可以正确构建。
        </p></li>
<li><p>
          On the gcc compiler, the name of the header being precompiled must be
          equal to the name of the <code class="computeroutput">cpp-pch</code> target. This is a gcc
          requirement.<br>在 gcc 编译器上，被预编译的头文件名必须与 <code class="computeroutput">cpp-pch</code> 目标的名称相同。这是 gcc 的一个要求。
        </p></li>
<li><p>
          Prior to version 4.2, the gcc compiler did not allow anonymous
          namespaces in precompiled headers, which limits their utility. See the
          <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29085" target="_top">bug
          report</a> for details.<br>在版本 4.2 之前，gcc 编译器不允许在预编译头文件中有匿名名字空间，这限制了它的工具。详细请见 <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29085" target="_top">缺陷报告</a>。
        </p></li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.reference.generated_headers"></a>Generated headers 生成头文件</h3></div></div></div>
<p>Usually, Boost.Build handles implicit dependendies completely
        automatically. For example, for C++ files, all <code class="literal">#include</code>
        statements are found and handled. The only aspect where user help
        might be needed is implicit dependency on generated files.<br>通常，Boost.Build 完全自动地处理隐式的依赖关系。例如，对于 C++ 文件，所有 <code class="literal">#include</code>
        语句将被查找和处理。唯一可能需要用户帮助的是，在生成头文件上的隐式依赖关系。</p>
<p>By default, Boost.Build handles such dependencies within one
        main target. For example, assume that main target "app" has two
        sources, "app.cpp" and "parser.y". The latter source is converted
        into "parser.c" and "parser.h". Then, if "app.cpp" includes
        "parser.h", Boost.Build will detect this dependency. Moreover,
        since "parser.h" will be generated into a build directory, the
        path to that directory will automatically added to include
        path.<br>缺
省情况下，Boost.Build 在一个主目标的内部处理这类依赖关系。例如，假设主目标 "app" 有两个源："app.cpp" 和
"parser.y"。后一个源被转化为 "parser.c" 和 "parser.h"。那么，如果 "app.cpp" 包含了
"parser.h"，则 Boost.Build 将检测到这个依赖关系。此外，因为 "parser.h"
将被生成到一个构建目录中，所以该目录的路径将被自动加入到包含路径中。</p>
<p>Making this mechanism work across main target boundaries is
        possible, but imposes certain overhead. For that reason, if
        there's implicit dependency on files from other main targets, the
        <code class="literal">&lt;implicit-dependency&gt;</code> [ link ] feature must
        be used, for example:<br>让这种机制跨主目标工作也是可以的，不过需要很大的代价。为此，如果一个文件存在对其它主目标的隐式依赖关系，必须使用
        <code class="literal">&lt;implicit-dependency&gt;</code> [ link ] 特性，例如：</p>
<pre class="programlisting">lib parser : parser.y ;<br>exe app : app.cpp : &lt;implicit-dependency&gt;parser ;<br></pre>
<p>
        The above example tells the build system that when scanning
        all sources of "app" for implicit-dependencies, it should consider
        targets from "parser" as potential dependencies.<br>上述例子告诉构建系统，在扫描 "app" 的所有源文件的隐式依赖关系时，应该将来自 "parser" 的目标也作为潜在的依赖关系考虑。
      </p>
</div>
<div class="footnotes">
<br><hr align="left" width="100">
<div class="footnote"><p><sup>[<a name="ftn.id3905699" href="#id3905699" class="para">8</a>] </sup>see the definition of "free" in
      <a class="xref" href="reference.html#bbv2.reference.features.attributes" title="Feature Attributes">the section called “Feature Attributes”</a>.<br>请见
      <a class="xref" href="reference.html#bbv2.reference.features.attributes" title="Feature Attributes">“特性的属性”一节</a> 中关于"自由"的定义。</p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer"></div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="advanced.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bbv2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="extender.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">






  
  
  
  
  
  
  
  
  <title>Class template variant</title>
  <link rel="stylesheet" href="../boostbook.css" type="text/css">





  
  
  
  
  <meta name="generator" content="DocBook XSL Stylesheets V1.68.1">





  
  
  
  
  <link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">





  
  
  
  
  <link rel="up" href="../variant/reference.html#header.boost.variant.variant.hpp" title="Header &lt;boost/variant/variant.hpp&gt;">





  
  
  
  
  <link rel="prev" href="../BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html" title="Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT">





  
  
  
  
  <link rel="next" href="../id1599586-bb.html" title="Function template swap">
</head>


<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">





<table cellpadding="2" width="100%">





  <tbody>




    <tr>




      <td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>





      <td align="center"><a href="../../../index.htm">Home</a></td>





      <td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>





      <td align="center"><a href="../../../people/people.htm">People</a></td>





      <td align="center"><a href="../../../more/faq.htm">FAQ</a></td>





      <td align="center"><a href="../../../more/index.htm">More</a></td>





    </tr>




  
  
  
  
  </tbody>
</table>





<hr>
<div class="spirit-nav">
<a accesskey="p" href="../BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../variant/reference.html#header.boost.variant.variant.hpp"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="swap_id932962.html"><img style="border: 0px solid ; width: 19px; height: 19px;" src="../images/next.png" alt="Next"></a>
</div>





<div class="refentry" lang="en">
<a name="boost.variant"></a>
<div class="titlepage"></div>





<div class="refnamediv">
<h2><span class="refentrytitle">类模板 variant</span></h2>





<p>boost::variant &mdash; 安全、泛型、基于栈的可识别联合容器。</p>





</div>





<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">摘要</h2>





<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv">
<pre class="synopsis"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T1, <span class="bold"><strong>typename</strong></span> T2 = <span class="emphasis"><em>unspecified</em></span>, ..., <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="bold"><strong>typename</strong></span> TN = <span class="emphasis"><em>unspecified</em></span>&gt; <br><span class="bold"><strong>class</strong></span> variant {<br><span class="bold"><strong>public</strong></span>:<br>&nbsp;&nbsp;<span class="emphasis"><em>// types</em></span>
&nbsp;&nbsp;<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span> types;<br><br>&nbsp;&nbsp;<span class="emphasis"><em>// <a href="variant.html#boost.variantconstruct-copy-destruct">construct/copy/destruct</a></em></span>
&nbsp;&nbsp;<a href="variant.html#id1602028-bb">variant</a>();<br>&nbsp;&nbsp;<a href="variant.html#id1599613-bb">variant</a>(<span class="bold"><strong>const</strong></span> variant &amp;);<br>&nbsp;&nbsp;<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a href="variant.html#id1254269-bb">variant</a>(T &amp;);<br>&nbsp;&nbsp;<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a href="variant.html#id1636459-bb">variant</a>(<span class="bold"><strong>const</strong></span> T &amp;);<br>&nbsp;&nbsp;<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="variant.html#id1604404-bb">variant</a>(variant&lt;U1, U2, ..., UN&gt; &amp;);<br>&nbsp;&nbsp;<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="variant.html#id1630438-bb">variant</a>(<span class="bold"><strong>const</strong></span> variant&lt;U1, U2, ..., UN&gt; &amp;);<br>&nbsp;&nbsp;<a href="variant.html#id1601741-bb">~variant</a>();<br><br>&nbsp;&nbsp;<span class="emphasis"><em>// <a href="variant.html#id790460-bb">modifiers</a></em></span>
&nbsp;&nbsp;<span class="type"><span class="bold"><strong>void</strong></span></span> <a href="variant.html#id790464-bb">swap</a>(variant &amp;);<br>&nbsp;&nbsp;<span class="type">variant &amp;</span> <a href="variant.html#id1669309-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> variant &amp;);<br>&nbsp;&nbsp;<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type">variant &amp;</span> <a href="variant.html#id1634032-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> T &amp;);<br><br>&nbsp;&nbsp;<span class="emphasis"><em>// <a href="variant.html#id1572706-bb">queries</a></em></span>
&nbsp;&nbsp;<span class="type"><span class="bold"><strong>int</strong></span></span> <a href="variant.html#id1572710-bb">which</a>() <span class="bold"><strong>const</strong></span>;<br>&nbsp;&nbsp;<span class="type"><span class="bold"><strong>bool</strong></span></span> <a href="variant.html#id1631554-bb">empty</a>() <span class="bold"><strong>const</strong></span>;<br>&nbsp;&nbsp;<span class="type"><span class="bold"><strong>const</strong></span> std::type_info &amp;</span> <a href="variant.html#id1005344-bb">type</a>() <span class="bold"><strong>const</strong></span>;<br><br>&nbsp;&nbsp;<span class="emphasis"><em>// <a href="variant.html#id1636712-bb">relational</a></em></span>
&nbsp;&nbsp;<span class="type"><span class="bold"><strong>bool</strong></span></span> <a href="variant.html#id1011694-bb"><span class="bold"><strong>operator</strong></span>==</a>(<span class="bold"><strong>const</strong></span> variant &amp;) <span class="bold"><strong>const</strong></span>;<br>&nbsp;&nbsp;<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a href="variant.html#id1673222-bb"><span class="bold"><strong>operator</strong></span>==</a>(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;<br>&nbsp;&nbsp;<span class="type"><span class="bold"><strong>bool</strong></span></span> <a href="variant.html#id1638199-bb"><span class="bold"><strong>operator</strong></span>&lt;</a>(<span class="bold"><strong>const</strong></span> variant &amp;) <span class="bold"><strong>const</strong></span>;<br>&nbsp;&nbsp;<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a href="variant.html#id1638215-bb"><span class="bold"><strong>operator</strong></span>&lt;</a>(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;<br>};</pre>




</div>





<div class="refsect1" lang="en">
<a name="id1944701"></a>
<h2>说明</h2>





<p><code class="computeroutput">variant</code> 类模板(灵感来自于 Andrei
        Alexandrescu 的同名类[<a href="../variant/refs.html#variant.refs.ale01a">Ale01A</a>])是一个高效的、<a href="../variant/tutorial.html#variant.tutorial.recursive" title="Recursive variant types">可递归的</a>、可保存任意值类型(POD 或 非-POD)的有界可识别值类型。它可以构造自任意可转换为其任一有界类型的类型，或者构造自一个源
        <code class="computeroutput">variant</code>，只要源
        <code class="computeroutput">variant</code> 的每个有界类型可以转换为目标 <code class="computeroutput">variant</code> 的某个有界类型。通过使用 <code class="computeroutput"><a href="apply_visitor.html" title="Function apply_visitor">apply_visitor</a></code>,
        <code class="computeroutput">variant</code> 可以支持编译期检查的、类型安全的访问；而通过 <code class="computeroutput"><a href="get.html" title="Function get">get</a></code>,
        <code class="computeroutput">variant</code> 可以支持运行期检查的、类型安全的值取出。</p>





<p><span class="bold"><strong>说明：</strong></span></p>





<div class="itemizedlist">
<ul type="disc">





  <li><code class="computeroutput">variant</code> 的有界类型通过内嵌的 typedef <code class="computeroutput">types</code> 获得，它是一个 <a href="../../../libs/mpl/index.html" target="_top">MPL</a>-兼容的序列，其中包含一组类型，这些类型必须被访问该 <code class="computeroutput">variant</code> 的
            <a href="../variant/reference.html#variant.concepts.static-visitor" title="StaticVisitor">visitor</a> 所处理。</li>





  <li><code class="computeroutput">variant</code> 的所有成员至少要满足基本的异常安全保证。即，<code class="computeroutput">variant</code> 的所有操作即使失败了也必须保持数据的一致性。</li>





  <li>每个被指定为
            <code class="computeroutput">variant</code> 的模板参数的类型必须满足
            <span class="emphasis"><em><a href="../variant/reference.html#variant.concepts.bounded-type" title="BoundedType">BoundedType</a></em></span>
            概念的要求。</li>





  <li>每个被指定为
            <code class="computeroutput">variant</code> 的模板参数的类型必须在去除限定符后是唯一的。因此，象 <code class="computeroutput">variant&lt;int, int&gt;</code> 和
            <code class="computeroutput">variant&lt;int, const int&gt;</code> 这样的类型的行为是未定义的。</li>





  <li>符合规范的 <code class="computeroutput">variant</code> 实现必须至少允许10个类型作为模板参数。实际所允许的参数数量由预处理器宏 <code class="computeroutput"><a href="../BOOST_VARIANT_LIMIT_TYPES.html" title="Macro BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</a></code> 获得。(以 <a href="../../../libs/mpl/index.html" target="_top">MPL</a> 或兼容序列的元素来指定 <code class="computeroutput">variant</code> 的有界类型，则可以超过这个限制，相关说明请见 <code class="computeroutput"><a href="make_variant_over.html" title="Class template make_variant_over">make_variant_over</a></code>)</li>





</ul>




</div>





<div class="refsect2" lang="en">
<a name="id1944944"></a>
<h3>
<a name="boost.variantconstruct-copy-destruct"></a><code class="computeroutput">variant</code> 的构造/复制/析构</h3>





<div class="orderedlist">
<ol type="1">





  <li>
    
    
    
    
    <pre class="literallayout"><a name="id1602028-bb"></a>variant();</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td><code class="computeroutput">variant</code> 的第一个有界类型(即
            <code class="computeroutput">T1</code>)必须符合&nbsp;<span class="emphasis"><em>可缺省构造</em></span> [20.1.4] 概念的要求。</td>





        </tr>





        <tr>





          <td>
          <span class="term">后续条件：</span></td>





          <td><code class="computeroutput">*this</code> 的内容为第一个有界类型(即 <code class="computeroutput">T1</code>)的缺省值。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>可能因 <code class="computeroutput">T1</code> 的缺省构造函数所引起的任何异常而失败。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><a name="id1599613-bb"></a>variant(<span class="bold"><strong>const</strong></span> variant &amp; other);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">后续条件：</span></td>





          <td><code class="computeroutput">*this</code> 的内容为
            <code class="computeroutput">other</code>&nbsp;内容的一份拷贝。</td>





        </tr>





        <tr>





          <td><span style="font-weight: bold;">抛出：</span><span class="term"></span></td>





          <td>可能因 <code class="computeroutput">other</code> 所含类型的复制构造函数所引起的任何异常而失败。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a name="id1254269-bb"></a>variant(T &amp; operand);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td>
          <code class="computeroutput">T</code> 必须明确地可转换为某个有界类型(如 <code class="computeroutput">T1</code>, <code class="computeroutput">T2</code>, 等)。</td>





        </tr>





        <tr>





          <td>
          <span class="term">后续条件：</span></td>





          <td><code class="computeroutput">*this</code> 的内容为
            <code class="computeroutput">operand</code> 到某个有界类型的最佳转换，取决于标准的重载决议规则。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>可能因
            <code class="computeroutput">operand</code> 至某个有界类型的转换所引起的任何异常而失败。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <a name="id1636459-bb"></a>variant(<span class="bold"><strong>const</strong></span> T &amp; operand);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>




        <tr>





          <td>
          <span class="term">说明：</span></td>





          <td>与前一构造函数语义相同，但允许构造自临时对象。</td>





        </tr>




      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; <br>&nbsp;&nbsp;<a name="id1604404-bb"></a>variant(variant&lt;U1, U2, ..., UN&gt; &amp; operand);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td>
          <span class="emphasis"><em></em></span>每一个 <code class="computeroutput">U1</code>,
            <code class="computeroutput">U2</code>, ..., <code class="computeroutput">UN</code> 都必须明确可转换为某个有界类型(如 <code class="computeroutput">T1</code>,
            <code class="computeroutput">T2</code>, ..., <code class="computeroutput">TN</code>)。</td>





        </tr>





        <tr>





          <td>
          <span class="term">后续条件：</span></td>





          <td>如果 <code class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</code> 本身是其中一个有界类型，则 <code class="computeroutput">*this</code> 的内容为 <code class="computeroutput">operand</code> 的拷贝。否则，<code class="computeroutput">*this</code> 的内容为
            <code class="computeroutput">operand</code> 到某个有界类型的最佳转换，取决于标准的重载决议规则。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>如果 <code class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</code> 本身是其中一个有界类型，则可能因
          <code class="computeroutput">variant&lt;U1, U2, ..., UN&gt;</code> 的复制构造函数所引起的任何异常而失败。否则，可能因
            <code class="computeroutput">operand</code> 至某个有界类型的转换所引起的任何异常而失败。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U1, <span class="bold"><strong>typename</strong></span> U2, ..., <span class="bold"><strong>typename</strong></span> UN&gt; <br>&nbsp;&nbsp;<a name="id1630438-bb"></a>variant(<span class="bold"><strong>const</strong></span> variant&lt;U1, U2, ..., UN&gt; &amp; operand);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>




        <tr>





          <td>
          <span class="term">说明：</span></td>





          <td>与前一构造函数语义相同，但允许构造自临时对象。</td>





        </tr>




      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><a name="id1601741-bb"></a>~variant();</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">作用：</span></td>





          <td>销毁 <code class="computeroutput">*this</code> 的内容。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>不会抛出。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





</ol>




</div>





</div>





<div class="refsect2" lang="en">
<a name="id1945483"></a>
<h3>
<a name="id790460-bb"></a><code class="computeroutput">variant</code> 的修改操作</h3>





<div class="orderedlist">
<ol type="1">





  <li>
    
    
    
    
    <pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id790464-bb"></a>swap(variant &amp; other);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td>每个有界类型都必须满足 <a href="../Assignable.html" title="Concept Assignable">可赋值</a>
              概念的要求。</td>





        </tr>





        <tr>





          <td>
          <span class="term">作用：</span></td>





          <td>交换 <code class="computeroutput">*this</code> 和
              <code class="computeroutput">other</code> 的内容。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>如果 <code class="computeroutput">other</code> 所含类型与 <code class="computeroutput">*this</code> 所含类型相同，则可能因
              <code class="computeroutput">*this</code> 和 <code class="computeroutput">other</code> 的内容的 <code class="computeroutput">swap</code> 操作所引起的异常而失败。否则，可能因某个所含类型的复制构造函数所引起的异常而失败。也可能由于内存不足而抛出 <code class="computeroutput">std::bad_alloc</code>
              (<a href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">为什么？</a>).</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="type">variant &amp;</span> <a name="id1669309-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> variant &amp; rhs);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td>每个有界类型都必须满足 <a href="../Assignable.html" title="Concept Assignable">可赋值</a>
              概念的要求。</td>





        </tr>





        <tr>





          <td>
          <span class="term">作用：</span></td>





          <td>如果 <code class="computeroutput">rhs</code> 所含类型与 <code class="computeroutput">*this</code> 所含类型相同，则将 <code class="computeroutput">rhs</code> 的内容赋值到
              <code class="computeroutput">*this</code> 的内容中。否则，将
              <code class="computeroutput">*this</code> 的内容变为 <code class="computeroutput">rhs</code> 内容的一份拷贝，并销毁 <code class="computeroutput">*this</code> 原来的内容。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>如果 <code class="computeroutput">rhs</code> 所含类型与 <code class="computeroutput">*this</code> 所含类型相同，则可能因将
              <code class="computeroutput">rhs</code> 的内容赋值到 <code class="computeroutput">*this</code> 中而引起的异常而失败。否则，可能因 <code class="computeroutput">rhs</code> 所含类型的复制构造函数所引起的异常而失败。也可能由于内存不足而抛出 <code class="computeroutput">std::bad_alloc</code>
              (<a href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">为什么？</a>).</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T&gt; <span class="type">variant &amp;</span> <a name="id1634032-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> T &amp; rhs);</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td>
          
          
          
          
          <div class="itemizedlist">
          
          
          
          
          <ul type="disc">





            <li>
              <code class="computeroutput">T</code> 必须明确可转换为某个有界类型(即 <code class="computeroutput">T1</code>,
                <code class="computeroutput">T2</code>, 等)。</li>





            <li>每个有界类型都必须满足 <a href="../Assignable.html" title="Concept Assignable">可赋值</a>
              概念的要求。</li>





          
          
          
          
          </ul>




          </div>




          </td>





        </tr>





        <tr>





          <td>
          <span class="term">作用：</span></td>





          <td>如果 <code class="computeroutput">*this</code> 所含类型为
              <code class="computeroutput">T</code>, 则将 <code class="computeroutput">rhs</code> 赋为 <code class="computeroutput">*this</code> 的内容。否则，将
              <code class="computeroutput">*this</code> 的内容变为从 <code class="computeroutput">rhs</code> 到某个有界类型的最佳转换，取决于标准的重载决议规则，并销毁
              <code class="computeroutput">*this</code> 原来的内容。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>如果 <code class="computeroutput">*this</code> 所含类型为
              <code class="computeroutput">T</code>, 则可能因将 <code class="computeroutput">rhs</code> 赋为 <code class="computeroutput">*this</code> 的内容所引起的异常而失败。否则，可能因从 <code class="computeroutput">rhs</code> 到某个有界类型的转换所引起的异常而失败。还可能由于内存不足而抛出 <code class="computeroutput">std::bad_alloc</code>
              (<a href="../variant/design.html#variant.design.never-empty.problem" title="The Implementation Problem">为什么？</a>).</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





</ol>




</div>





</div>





<div class="refsect2" lang="en">
<a name="id1945960"></a>
<h3>
<a name="id1572706-bb"></a><code class="computeroutput">variant</code> 的查询操作</h3>





<div class="orderedlist">
<ol type="1">





  <li>
    
    
    
    
    <pre class="literallayout"><span class="type"><span class="bold"><strong>int</strong></span></span> <a name="id1572710-bb"></a>which() <span class="bold"><strong>const</strong></span>;</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">返回：</span></td>





          <td><code class="computeroutput">*this</code> 所含类型在有界类型集合中的索引值，从零起计。(例如，如果从一个包含 <code class="computeroutput">std::string</code> 的 <code class="computeroutput">variant&lt;int, std::string&gt;</code>&nbsp;<code class="computeroutput"></code>调用，<code class="computeroutput">which()</code>
              将返回 <code class="computeroutput">1</code>.)</td>





        </tr>





        <tr>





          <td><span style="font-weight: bold;">抛出：</span><span class="term"></span></td>





          <td>不会抛出异常。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id1631554-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">返回：</span></td>





          <td>
          <code class="computeroutput">false</code>: <code class="computeroutput">variant</code> 总是刚好包含某一个有界类型。(更多信息请见
              <a href="../variant/design.html#variant.design.never-empty" title="&quot;Never-Empty&quot; Guarantee">&ldquo;"非空" 保证&rdquo; 一节</a>)</td>





        </tr>





        <tr>





          <td><span style="font-weight: bold;">原理：</span><span class="term"></span></td>





          <td>便于与
              <a href="any.html" title="Class any">boost::any</a> 的泛型兼容。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>不会抛出异常。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> std::type_info &amp;</span> <a name="id1005344-bb"></a>type() <span class="bold"><strong>const</strong></span>;</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">返回：</span></td>





          <td>
          <code class="computeroutput">typeid(x)</code>, 其中 <code class="computeroutput">x</code> 为 <code class="computeroutput">*this</code> 的内容。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>不会抛出异常。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





</ol>




</div>





</div>





<div class="refsect2" lang="en">
<a name="id1946192"></a>
<h3>
<a name="id1636712-bb"></a><code class="computeroutput">variant</code> 的关系操作</h3>





<div class="orderedlist">
<ol type="1">





  <li>
    
    
    
    
    <p><a name="id1636716-bb"></a></p>





    
    
    
    
    <pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id1011694-bb"></a><span class="bold"><strong>operator</strong></span>==(<span class="bold"><strong>const</strong></span> variant &amp; rhs) <span class="bold"><strong>const</strong></span>;<br><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1673222-bb"></a><span class="bold"><strong>operator</strong></span>==(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">说明：</span></td>





          <td>存在一个返回 <code class="computeroutput">void</code> 的重载只是为了防止右操作数隐式转换为 <code class="computeroutput">variant</code>; 这样的用法将(被有意地)引发一个编译错误。</td>





        </tr>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td><code class="computeroutput">variant</code> 的每一个有界类型都必须满足
              <a href="../EqualityComparable.html" title="Concept EqualityComparable">相等性可比较</a>
              概念的要求。</td>





        </tr>





        <tr>





          <td>
          <span class="term">返回：</span></td>





          <td>
          <code class="computeroutput">true</code> 当且仅当 <code class="computeroutput">which() == rhs.which()</code> <span class="emphasis"><em>且</em></span>
              <code class="computeroutput">content_this == content_rhs</code>, 其中
              <code class="computeroutput">content_this</code> 为 <code class="computeroutput">*this</code>
              的内容而 <code class="computeroutput">content_rhs</code> 为
              <code class="computeroutput">rhs</code> 的内容。</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>如果 <code class="computeroutput">which() == rhs.which()</code> 则可能因 <code class="computeroutput">operator==(T,T)</code> 所引起的异常而失败，其中
              <code class="computeroutput">T</code> 为
              <code class="computeroutput">*this</code> 所含类型。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





  <li>
    
    
    
    
    <p><a name="id1638192-bb"></a></p>





    
    
    
    
    <pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id1638199-bb"></a><span class="bold"><strong>operator</strong></span>&lt;(<span class="bold"><strong>const</strong></span> variant &amp; rhs) <span class="bold"><strong>const</strong></span>;<br><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id1638215-bb"></a><span class="bold"><strong>operator</strong></span>&lt;(<span class="bold"><strong>const</strong></span> U &amp;) <span class="bold"><strong>const</strong></span>;</pre>





    
    
    
    
    <div class="variablelist">
    
    
    
    
    <table border="0">





      <col align="left" valign="top">
      <tbody>





        <tr>





          <td>
          <span class="term">说明：</span></td>





          <td>存在一个返回 <code class="computeroutput">void</code> 的重载只是为了防止右操作数隐式转换为 <code class="computeroutput">variant</code>; 这样的用法将(被有意地)引发一个编译错误。</td>





        </tr>





        <tr>





          <td>
          <span class="term">要求：</span></td>





          <td><code class="computeroutput">variant</code> 的每一个有界类型都必须满足
              <a href="../LessThanComparable.html" title="Concept LessThanComparable">小于关系可比较</a>
              概念的要求。</td>





        </tr>





        <tr>





          <td>
          <span class="term">返回：</span></td>





          <td>如果 <code class="computeroutput">which() == rhs.which()</code> 则返回：<code class="computeroutput">content_this &lt; content_rhs</code>, 其中 <code class="computeroutput">content_this</code> 为 <code class="computeroutput">*this</code>
              的内容而 <code class="computeroutput">content_rhs</code> 为 <code class="computeroutput">rhs</code> 的内容。否则返回：<code class="computeroutput">which() &lt; rhs.which()</code>.</td>





        </tr>





        <tr>





          <td>
          <span class="term">抛出：</span></td>





          <td>如果 <code class="computeroutput">which() == rhs.which()</code> 则可能因 <code class="computeroutput">operator&lt;(T,T)</code> 所引起的异常而失败，其中 <code class="computeroutput">T</code> 为
              <code class="computeroutput">*this</code> 所含类型。</td>





        </tr>





      
      
      
      
      </tbody>
    
    
    
    
    </table>




    </div>





  </li>





</ol>




</div>





</div>





</div>





</div>





<table width="100%">




  <tbody>




    <tr>





      <td align="left"></td>





      <td align="right"><small>Copyright &copy; 2002, 2003 Eric Friedman, Itay Maman</small></td>





    </tr>




  
  
  
  
  </tbody>
</table>





<hr>
<div class="spirit-nav">
<a accesskey="p" href="../BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../variant/reference.html#header.boost.variant.variant.hpp"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="swap_id932962.html"><img style="border: 0px solid ; width: 19px; height: 19px;" src="../images/next.png" alt="Next"></a>
</div>





</body>
</html>

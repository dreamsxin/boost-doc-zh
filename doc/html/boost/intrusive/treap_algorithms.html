<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Class template treap_algorithms</title><link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../intrusive/reference.html#header.boost.intrusive.treap_algorithms_hpp" title="Header &lt;boost/intrusive/treap_algorithms.hpp&gt;">
<link rel="prev" href="make_trie.html" title="Struct template make_trie">
<link rel="next" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="make_trie.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../intrusive/reference.html#header.boost.intrusive.treap_algorithms_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="treap_algorithms/insert_commit_data.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.intrusive.treap_algorithms"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template treap_algorithms</span></h2>
<p>boost::intrusive::treap_algorithms</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../../intrusive/reference.html#header.boost.intrusive.treap_algorithms_hpp" title="Header &lt;boost/intrusive/treap_algorithms.hpp&gt;">boost/intrusive/treap_algorithms.hpp</a>&gt;<br><br></em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodeTraits&gt; <br><span class="bold"><strong>class</strong></span> <a class="link" href="treap_algorithms.html" title="Class template treap_algorithms">treap_algorithms</a> {<br><span class="bold"><strong>public</strong></span>:<br>  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> NodeTraits                 <a name="boost.intrusive.treap_algorithms.node_traits"></a>node_traits;   <br>  <span class="bold"><strong>typedef</strong></span> NodeTraits::node           <a name="boost.intrusive.treap_algorithms.node"></a>node;          <br>  <span class="bold"><strong>typedef</strong></span> NodeTraits::node_ptr       <a name="boost.intrusive.treap_algorithms.node_ptr"></a>node_ptr;      <br>  <span class="bold"><strong>typedef</strong></span> NodeTraits::const_node_ptr <a name="boost.intrusive.treap_algorithms.const_node_ptr"></a>const_node_ptr;<br><br>  <span class="bold"><strong>struct</strong></span> <a class="link" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data">insert_commit_data</a> {<br>  };<br><br>  <span class="emphasis"><em>// <a class="link" href="treap_algorithms.html#id3486325-bb">public static functions</a></em></span>
  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3486328-bb">begin_node</a>(const_node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3486342-bb">end_node</a>(const_node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3486356-bb">swap_tree</a>(node_ptr, node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3486408-bb">swap_nodes</a>(node_ptr, node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3486472-bb">swap_nodes</a>(node_ptr, node_ptr, node_ptr, node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3486549-bb">replace_node</a>(node_ptr, node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3486615-bb">replace_node</a>(node_ptr, node_ptr, node_ptr) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3486687-bb">unlink</a>(node_ptr, NodePriorityCompare) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3486744-bb">unlink_leftmost_without_rebalance</a>(node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>bool</strong></span></span> <a class="link" href="treap_algorithms.html#id3486801-bb">unique</a>(const_node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a class="link" href="treap_algorithms.html#id3486846-bb">count</a>(const_node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a class="link" href="treap_algorithms.html#id3486891-bb">size</a>(const_node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3486936-bb">next_node</a>(node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3486980-bb">prev_node</a>(node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3487025-bb">init</a>(node_ptr) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3487077-bb">init_header</a>(node_ptr) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3487130-bb">erase</a>(node_ptr, node_ptr, NodePriorityCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Cloner, <span class="bold"><strong>typename</strong></span> Disposer&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3487194-bb">clone</a>(const_node_ptr, node_ptr, Cloner, Disposer) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3487291-bb">clear_and_dispose</a>(node_ptr, Disposer) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>    <a class="link" href="treap_algorithms.html#id3487356-bb">lower_bound</a>(const_node_ptr, <span class="bold"><strong>const</strong></span> KeyType &amp;, KeyNodePtrCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>    <a class="link" href="treap_algorithms.html#id3487430-bb">upper_bound</a>(const_node_ptr, <span class="bold"><strong>const</strong></span> KeyType &amp;, KeyNodePtrCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3487503-bb">find</a>(const_node_ptr, <span class="bold"><strong>const</strong></span> KeyType &amp;, KeyNodePtrCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> std::pair&lt; node_ptr, node_ptr &gt;</span> <br>    <a class="link" href="treap_algorithms.html#id3487577-bb">equal_range</a>(const_node_ptr, <span class="bold"><strong>const</strong></span> KeyType &amp;, KeyNodePtrCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePtrCompare, <span class="bold"><strong>typename</strong></span> PriorityNodeCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>    <a class="link" href="treap_algorithms.html#id3487652-bb">insert_equal_upper_bound</a>(node_ptr, node_ptr, NodePtrCompare, <br>                             PriorityNodeCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePtrCompare, <span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>    <a class="link" href="treap_algorithms.html#id3487731-bb">insert_equal_lower_bound</a>(node_ptr, node_ptr, NodePtrCompare, <br>                             NodePriorityCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePtrCompare, <span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>    <a class="link" href="treap_algorithms.html#id3487810-bb">insert_equal</a>(node_ptr, node_ptr, node_ptr, NodePtrCompare, <br>                 NodePriorityCompare) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare, <br>           <span class="bold"><strong>typename</strong></span> KeyNodePtrPrioCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> std::pair&lt; node_ptr, <span class="bold"><strong>bool</strong></span> &gt;</span> <br>    <a class="link" href="treap_algorithms.html#id3487898-bb">insert_unique_check</a>(const_node_ptr, <span class="bold"><strong>const</strong></span> KeyType &amp;, KeyNodePtrCompare, <br>                        KeyNodePtrPrioCompare, <a class="link" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data">insert_commit_data</a> &amp;) ;<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare, <br>           <span class="bold"><strong>typename</strong></span> KeyNodePtrPrioCompare&gt; <br>    <span class="type"><span class="bold"><strong>static</strong></span> std::pair&lt; node_ptr, <span class="bold"><strong>bool</strong></span> &gt;</span> <br>    <a class="link" href="treap_algorithms.html#id3488029-bb">insert_unique_check</a>(const_node_ptr, node_ptr, <span class="bold"><strong>const</strong></span> KeyType &amp;, <br>                        KeyNodePtrCompare, KeyNodePtrPrioCompare, <br>                        <a class="link" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data">insert_commit_data</a> &amp;) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a class="link" href="treap_algorithms.html#id3488171-bb">insert_unique_commit</a>(node_ptr, node_ptr, <br>                                   <span class="bold"><strong>const</strong></span> <a class="link" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data">insert_commit_data</a> &amp;) ;<br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a class="link" href="treap_algorithms.html#id3488246-bb">get_header</a>(node_ptr) ;<br>};</pre></div>
<div class="refsect1" lang="en">
<a name="id3667720"></a><h2>Description</h2>
<p>treap_algorithms provides basic algorithms to manipulate nodes forming a treap.<br>treap_algorithms 提供了对组成一棵 treap 的节点进行操纵的基本算法。</p>
<p>(1) the header node is maintained with links not only to the root but also to 
the leftmost node of the tree, to enable constant time begin(), and to the 
rightmost node of the tree, to enable linear time performance when used with the 
generic set algorithms (set_union, etc.);<br>(1) 
头部节点不仅维护了到根的链接，还维护了到树的最左节点的链接，以提供常量时间的&nbsp; begin()，还有到树的最右节点的链接，以便在使用泛型 set 
算法(set_union, 等等)时提供线性时间的性能；</p>
<p>(2) when a node being deleted has two children its successor node is relinked 
into its place, rather than copied, so that the only pointers invalidated are 
those referring to the deleted node.<br>(2) 
当被删除的节点有两个子节点时，它的后续节点将被重链接到它的位置，而不是被复制，所以只有指向被删除节点的指针会失效。</p>
<p>treap_algorithms is configured with a NodeTraits class, which encapsulates 
the information about the node to be manipulated. NodeTraits must support the 
following interface:<br>treap_algorithms 用一个 NodeTraits 
类来配置，它封装了被操作的节点的信息。NodeTraits 必须支持以下接口：</p><p><span class="bold"><strong>Typedefs</strong></span>:</p>
<p><code class="computeroutput">node</code>: The type of the node that forms the 
circular list 形成循环链表的节点的类型</p>
<p><code class="computeroutput">node_ptr</code>: A pointer to a node 节点指针</p>
<p><code class="computeroutput">const_node_ptr</code>: A pointer to a const node 
常量节点指针</p><p><span class="bold"><strong>Static functions</strong></span>:</p>
<p><code class="computeroutput">static node_ptr get_parent(const_node_ptr n);</code></p>
<p><code class="computeroutput">static void set_parent(node_ptr n, node_ptr parent);</code></p>
<p><code class="computeroutput">static node_ptr get_left(const_node_ptr n);</code></p>
<p><code class="computeroutput">static void set_left(node_ptr n, node_ptr left);</code></p>
<p><code class="computeroutput">static node_ptr get_right(const_node_ptr n);</code></p>
<p><code class="computeroutput">static void set_right(node_ptr n, node_ptr right);</code> </p>
<div class="refsect2" lang="en">
<a name="id3667820"></a><h3>
<a name="id3486325-bb"></a><code class="computeroutput">treap_algorithms</code> public static functions</h3>
<div class="orderedlist"><ol type="1">
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a name="id3486328-bb"></a>begin_node(const_node_ptr header) ;</pre></li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a name="id3486342-bb"></a>end_node(const_node_ptr header) ;</pre></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3486356-bb"></a>swap_tree(node_ptr header1, node_ptr header2) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: header1 and header2 must 
be the header nodes of two trees.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>header1 和 header2 必须是两棵树的头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Swaps two trees. After the 
function header1 will contain links to the second tree and header2 will have 
links to the first tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:&nbsp;</span>交换两棵树。在函数调用后，header1 将含有到第二棵树的链接，而 
header2 将含有到第一棵树的链接。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
常量。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3486408-bb"></a>swap_nodes(node_ptr node1, node_ptr node2) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node1 and node2 can't be 
header nodes of two trees.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node1 和 node2<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"></span> 
不能是两棵树的头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Swaps two nodes. After the 
function node1 will be inserted in the position node2 before the function. node2 
will be inserted in the position node1 had before the function.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:&nbsp;</span>交换两个节点。在函数调用后，node1 
将被插入到函数调用前&nbsp;node2 的位置，而&nbsp;node2 则被插入到函数调用前&nbsp;node1 的位置。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Note</strong></span>: This function will break 
container ordering invariants if node1 and node2 are not equivalent according to 
the ordering rules.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 如果</span> node1 和 node2<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"> 
按照排序规则是不相等的，那么该函数将破坏容器的排序不变式。</span></p>
<p>Experimental function 试验性函数</p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3486472-bb"></a>swap_nodes(node_ptr node1, node_ptr header1, node_ptr node2, <br>                       node_ptr header2) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node1 and node2 can't be 
header nodes of two trees with header header1 and header2.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node1 和 node2<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"></span> 
不能是以 header1 和 header2 为头节点的两棵树的头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Swaps two nodes. After the 
function node1 will be inserted in the position node2 before the function. node2 
will be inserted in the position node1 had before the function.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:&nbsp;</span>交换两个节点。在函数调用后，node1 
将被插入到函数调用前&nbsp;node2 的位置，而&nbsp;node2 则被插入到函数调用前&nbsp;node1 的位置。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
常量。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Note</strong></span>: This function will break 
container ordering invariants if node1 and node2 are not equivalent according to 
the ordering rules.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 如果</span> node1 和 node2<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"> 
按照排序规则是不相等的，那么该函数将破坏容器的排序不变式。</span></p>
<p>Experimental function 试验性函数</p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3486549-bb"></a>replace_node(node_ptr node_to_be_replaced, node_ptr new_node) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node_to_be_replaced must 
be inserted in a tree and new_node must not be inserted in a tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node_to_be_replaced 必须已插入到树中而 
new_node 必须未插入到树中。</p>
<p><span class="bold"><strong>Effects</strong></span>: Replaces 
node_to_be_replaced in its position in the tree with new_node. The tree does not 
need to be rebalanced<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 在树中就地将</span> node_to_be_replaced 替换为 
new_node。树不需要重新平衡。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Note</strong></span>: This function will break 
container ordering invariants if new_node is not equivalent to 
node_to_be_replaced according to the ordering rules. This function is faster 
than erasing and inserting the node, since no rebalancing and comparison is 
needed.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 如果</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">按照排序规则</span>&nbsp;new_node 
不等于 node_to_be_replaced<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">，那么该函数将破坏容器的排序不变式。</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">由于不需要重平衡或比较，所以该函数要比删除后再插入节点快</span></span>。</span></p>
<p>Experimental function 试验性函数</p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3486615-bb"></a>replace_node(node_ptr node_to_be_replaced, node_ptr header, <br>                         node_ptr new_node) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node_to_be_replaced must 
be inserted in a tree with header "header" and new_node must not be inserted in 
a tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node_to_be_replaced 
必须已插入到以&nbsp;"header" 为头节点的树中而 new_node 必须未插入到树中。</p>
<p><span class="bold"><strong>Effects</strong></span>: Replaces 
node_to_be_replaced in its position in the tree with new_node. The tree does not 
need to be rebalanced<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 在树中就地将</span> node_to_be_replaced 替换为 
new_node。树不需要重新平衡。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
常量。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Note</strong></span>: This function will break 
container ordering invariants if new_node is not equivalent to 
node_to_be_replaced according to the ordering rules. This function is faster 
than erasing and inserting the node, since no rebalancing or comparison is 
needed.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 如果</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">按照排序规则</span>&nbsp;new_node 
不等于 node_to_be_replaced<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">，那么该函数将破坏容器的排序不变式。</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">由于不需要重平衡或比较，所以该函数要比删除后再插入节点快</span></span>。</span></p>
<p>Experimental function 试验性函数</p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3486687-bb"></a>unlink(node_ptr node, NodePriorityCompare prio) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node is a tree node but 
not the header.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node 为树的节点但不是头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Unlinks the node and 
rebalances the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 断开</span> node 的链接并将树重新平衡。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average complexity is 
constant time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
平均复杂度为常量时间。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a name="id3486744-bb"></a>unlink_leftmost_without_rebalance(node_ptr header) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: header is the header of a 
tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>header 为树的头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Unlinks the leftmost node 
from the tree, and updates the header link to the new leftmost node.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 断开树的最左节点</span>的链接并将头节点链接到新的最左节点。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average complexity is 
constant time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
平均复杂度为常量时间。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Notes</strong></span>: This function breaks the tree 
and the tree can only be used for more unlink_leftmost_without_rebalance calls. 
This function is normally used to achieve a step by step controlled destruction 
of the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 该函数会对树造成破坏，树只能被用于更多的</span></span><span class="Apple-converted-space">&nbsp;</span>unlink_leftmost_without_rebalance 
调用。该函数通常用于对树实现逐步控制的析构。</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"></span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>bool</strong></span></span> <a name="id3486801-bb"></a>unique(const_node_ptr node) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node is a node of the tree 
or an node initialized by init(...).<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node 为树的节点或为一个由 init(...) 
初始化的节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns true if the node is 
initialized by init().<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 如果节点是由</span> init(...) 初始化的，返回 true。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
常量。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a name="id3486846-bb"></a>count(const_node_ptr node) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node is a node of the tree 
but it's not the header.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node 为树的节点但不是头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns the number of nodes 
of the subtree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 返回子树的节点数量</span>。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
线性时间。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> std::size_t</span> <a name="id3486891-bb"></a>size(const_node_ptr header) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: header is the header node 
of the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>header 为树的头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns the number of nodes 
above the header.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 返回&nbsp;</span>header 之上<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">的节点数量</span>。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
线性时间。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a name="id3486936-bb"></a>next_node(node_ptr p) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p is a node from the tree 
except the header.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>p 为树的节点但不是头节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns the next node of 
the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 返回树的下一个节点</span>。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average constant 
time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
平均常量时间。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a name="id3486980-bb"></a>prev_node(node_ptr p) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: p is a node from the tree 
except the leftmost node.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>p 为树的节点但不是最左节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns the previous node 
of the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 返回树的前一个节点</span>。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average constant 
time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
平均常量时间。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3487025-bb"></a>init(node_ptr node) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node must not be part of 
any tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>node 必须不是任何一棵树的部分。</p>
<p><span class="bold"><strong>Effects</strong></span>: After the function 
unique(node) == true.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 函数返回后 </span>unique(node) == true。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
常量。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Nodes</strong></span>: If node is inserted in a 
tree, this function corrupts the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 如果 </span></span></span>node 
已被插入到树中，则该函数会破坏这棵树。</p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3487077-bb"></a>init_header(node_ptr header) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: node must not be part of 
any tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>header 必须不是任何一棵树的部分。</p>
<p><span class="bold"><strong>Effects</strong></span>: Initializes the header to 
represent an empty tree. unique(header) == true.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 初始化&nbsp;</span>header<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"> 
为表示一棵空树。</span>unique(header) == true。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
常量。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Nodes</strong></span>: If node is inserted in a 
tree, this function corrupts the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 如果&nbsp;</span></span></span>header 
已被插入到树中，则该函数会破坏这棵树。</p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>  <a name="id3487130-bb"></a>erase(node_ptr header, node_ptr z, NodePriorityCompare pcomp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: header must be the header 
of a tree, z a node of that tree and z != header.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>header 必须是一棵树的头节点，而 z 为该树的一个节点且 z 
!= header.。</p>
<p><span class="bold"><strong>Effects</strong></span>: Erases node "z" from the 
tree with header "header".<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: 从</span>以 "header" 为头节点的<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">树中移除节点</span> 
"z"。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Amortized constant 
time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
分期常量时间。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Cloner, <span class="bold"><strong>typename</strong></span> Disposer&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3487194-bb"></a>clone(const_node_ptr source_header, node_ptr target_header, <br>                    Cloner cloner, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "cloner" must be a 
function object taking a node_ptr and returning a new cloned node of it. 
"disposer" must take a node_ptr and shouldn't throw.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"cloner" 必须是一个接受一个 node_ptr 
且返回其克隆节点的函数对象。"disposer" 必须接受一个 node_ptr 且不会抛出。</p>
<p><span class="bold"><strong>Effects</strong></span>: First empties target tree 
calling <code class="computeroutput">void disposer::operator()(node_ptr)</code> 
for every node of the tree except the header.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>首先对树中除头节点外的每个节点调用 <code class="computeroutput">void disposer::operator()(node_ptr)</code> 清空目标树。</p>
<p>Then, duplicates the entire tree pointed by "source_header" cloning each 
source node with <code class="computeroutput">node_ptr 
Cloner::operator()(node_ptr)</code> to obtain the nodes of the target tree. If 
"cloner" throws, the cloned target nodes are disposed using <code class="computeroutput">void disposer(node_ptr)</code>.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong></strong></span></span>然后复制由 "source_header" 所指向的整棵树，对每个源节点调用 
<code class="computeroutput">node_ptr Cloner::operator()(node_ptr)</code> 
以获得目标树的节点。如果 "cloner" 抛出，则使用 <code class="computeroutput">void 
disposer(node_ptr)</code> 处置已克隆的目标节点。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of 
element of the source tree plus the. number of elements of tree target tree when 
calling this function.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
与源树的元素数量加上调用该函数时目标树的元素数量成线性比例。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If cloner functor throws. If 
this happens target nodes are disposed.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>cloner<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"> 
函数对象抛出。如果这一事件发生，目标节点被处置。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Disposer&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3487291-bb"></a>clear_and_dispose(node_ptr header, Disposer disposer) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "disposer" must be an 
object function taking a node_ptr parameter and shouldn't throw.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"disposer" 必须是接受一个 node_ptr 
且不会抛出的函数对象。</p>
<p><span class="bold"><strong>Effects</strong></span>: Empties the target tree 
calling <code class="computeroutput">void disposer::operator()(node_ptr)</code> 
for every node of the tree except the header.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:&nbsp;</span>对树中除头节点外的每个节点调用 <code class="computeroutput">void disposer::operator()(node_ptr)</code> 清空目标树。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the number of 
element of the source tree plus the. number of elements of tree target tree when 
calling this function.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
与源树的元素数量加上调用该函数时目标树的元素数量成线性比例。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If cloner functor throws. If 
this happens target nodes are disposed.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>cloner<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"> 
函数对象抛出。如果这一事件发生，目标节点被处置。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>  <a name="id3487356-bb"></a>lower_bound(const_node_ptr header, <span class="bold"><strong>const</strong></span> KeyType &amp; key, <br>              KeyNodePtrCompare comp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. KeyNodePtrCompare is a function object that induces a 
strict weak ordering compatible with the strict weak ordering used to create the 
the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 
必须是一棵树的头节点。KeyNodePtrCompare 是一个与创建该树时使用的严格弱序相兼容的函数对象。KeyNodePtrCompare 可以对 
KeyType 和树的 node_ptrs 进行比较。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns an node_ptr to the 
first element that is not less than "key" according to "comp" or "header" if 
that element does not exist.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>返回一个 node_ptr，指向按照 "comp" 不小于 
"key" 的第一个元素，如果这样的元素不存在，返回 "header"。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>  <a name="id3487430-bb"></a>upper_bound(const_node_ptr header, <span class="bold"><strong>const</strong></span> KeyType &amp; key, <br>              KeyNodePtrCompare comp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. KeyNodePtrCompare is a function object that induces a 
strict weak ordering compatible with the strict weak ordering used to create the 
the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 
必须是一棵树的头节点。KeyNodePtrCompare 是一个与创建该树时使用的严格弱序相兼容的函数对象。KeyNodePtrCompare 可以对 
KeyType 和树的 node_ptrs 进行比较。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns an node_ptr to the 
first element that is greater than "key" according to "comp" or "header" if that 
element does not exist.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>返回一个 node_ptr，指向按照 "comp" 大于 "key" 
的第一个元素，如果这样的元素不存在，返回 "header"。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>  <a name="id3487503-bb"></a>find(const_node_ptr header, <span class="bold"><strong>const</strong></span> KeyType &amp; key, KeyNodePtrCompare comp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. KeyNodePtrCompare is a function object that induces a 
strict weak ordering compatible with the strict weak ordering used to create the 
the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 
必须是一棵树的头节点。KeyNodePtrCompare 是一个与创建该树时使用的严格弱序相兼容的函数对象。KeyNodePtrCompare 可以对 
KeyType 和树的 node_ptrs 进行比较。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns an node_ptr to the 
element that is equivalent to "key" according to "comp" or "header" if that 
element does not exist.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>返回一个 node_ptr，指向按照 "comp" 等于 "key" 
的元素，如果这样的元素不存在，返回 "header"。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> std::pair&lt; node_ptr, node_ptr &gt;</span> <br>  <a name="id3487577-bb"></a>equal_range(const_node_ptr header, <span class="bold"><strong>const</strong></span> KeyType &amp; key, <br>              KeyNodePtrCompare comp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. KeyNodePtrCompare is a function object that induces a 
strict weak ordering compatible with the strict weak ordering used to create the 
the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 
必须是一棵树的头节点。KeyNodePtrCompare 是一个与创建该树时使用的严格弱序相兼容的函数对象。KeyNodePtrCompare 可以对 
KeyType 和树的 node_ptrs 进行比较。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns an a pair of 
node_ptr delimiting a range containing all elements that are equivalent to "key" 
according to "comp" or an empty range that indicates the position where those 
elements would be if they there are no equivalent elements.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>返回一对 node_ptr，界定包含按照 "comp" 等于 
"key" 的所有元素，如果这样的元素不存在，则返回一个空区间，表示这样的元素应处的位置。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePtrCompare, <span class="bold"><strong>typename</strong></span> PriorityNodeCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>  <a name="id3487652-bb"></a>insert_equal_upper_bound(node_ptr h, node_ptr new_node, NodePtrCompare comp, <br>                           PriorityNodeCompare pcomp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "h" must be the header 
node of a tree. NodePtrCompare is a function object that induces a strict weak 
ordering compatible with the strict weak ordering used to create the the tree. 
NodePtrCompare compares two node_ptrs.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"h" 必须是一棵树的头节点。NodePtrCompare 
是一个与创建该树时使用的严格弱序相兼容的函数对象。NodePtrCompare&nbsp;对两个 node_ptrs 进行比较。</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts new_node into the 
tree before the upper bound according to "comp".<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>将 new_node into 插入到树中，位于按照 "comp" 
得到的上界之前。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average complexity for 
insert element is at most logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
插入元素的平均复杂度最多为对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePtrCompare, <span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>  <a name="id3487731-bb"></a>insert_equal_lower_bound(node_ptr h, node_ptr new_node, NodePtrCompare comp, <br>                           NodePriorityCompare pcomp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "h" must be the header 
node of a tree. NodePtrCompare is a function object that induces a strict weak 
ordering compatible with the strict weak ordering used to create the the tree. 
NodePtrCompare compares two node_ptrs.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"h" 必须是一棵树的头节点。NodePtrCompare 
是一个与创建该树时使用的严格弱序相兼容的函数对象。NodePtrCompare&nbsp;对两个 node_ptrs 进行比较。</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts new_node into the 
tree before the lower bound according to "comp".<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>将 new_node into 插入到树中，位于按照 "comp" 
得到的下界之前。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average complexity for 
insert element is at most logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
插入元素的平均复杂度最多为对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NodePtrCompare, <span class="bold"><strong>typename</strong></span> NodePriorityCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <br>  <a name="id3487810-bb"></a>insert_equal(node_ptr h, node_ptr hint, node_ptr new_node, <br>               NodePtrCompare comp, NodePriorityCompare pcomp) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. NodePtrCompare is a function object that induces a strict 
weak ordering compatible with the strict weak ordering used to create the the 
tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s 
tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 必须是一棵树的头节点。NodePtrCompare 
是一个与创建该树时使用的严格弱序相兼容的函数对象。NodePtrCompare&nbsp;对两个 node_ptrs 进行比较。"hint" 是 "header" 
的树的一个节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts new_node into the 
tree, using "hint" as a hint to where it will be inserted. If "hint" is the 
upper_bound the insertion takes constant time (two comparisons in the worst 
case).<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>: </span>将 new_node into 插入到树中，以 "hint" 
作为插入位置的提示。如果 "hint" 恰好是上界，则插入操作为常量时间(最坏情况下为两次比较)。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic in general, 
but it is amortized constant time if new_node is inserted immediately before 
"hint".<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
通常为对数，但如果</span> new_node <span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">恰好在 
hint 之前插入，则为分期常量时间。</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"></span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare, <br>         <span class="bold"><strong>typename</strong></span> KeyNodePtrPrioCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> std::pair&lt; node_ptr, <span class="bold"><strong>bool</strong></span> &gt;</span> <br>  <a name="id3487898-bb"></a>insert_unique_check(const_node_ptr header, <span class="bold"><strong>const</strong></span> KeyType &amp; key, <br>                      KeyNodePtrCompare comp, KeyNodePtrPrioCompare pcomp, <br>                      <a class="link" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data">insert_commit_data</a> &amp; commit_data) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. KeyNodePtrCompare is a function object that induces a 
strict weak ordering compatible with the strict weak ordering used to create the 
the tree. NodePtrCompare compares KeyType with a node_ptr.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 
必须是一棵树的头节点。KeyNodePtrCompare 是一个与创建该树时使用的严格弱序相兼容的函数对象。KeyNodePtrCompare&nbsp;对 
KeyType 和 node_ptr 进行比较。</p>
<p><span class="bold"><strong>Effects</strong></span>: Checks if there is an 
equivalent node to "key" in the tree according to "comp" and obtains the needed 
information to realize a constant-time node insertion if there is no equivalent 
node.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:<span class="Apple-converted-space">&nbsp;</span></span>检查</span>在树中是否有一个按照 "comp" 与 "key" 
相等的节点，并取得所需信息，以实现当没有相等节点时进行常量时间的节点插入。<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"></span></p>
<p><span class="bold"><strong>Returns</strong></span>: If there is an equivalent 
value returns a pair containing a node_ptr to the already present node and 
false. If there is not equivalent key can be inserted returns true in the 
returned pair's boolean and fills "commit_data" that is meant to be used with 
the "insert_commit" function to achieve a constant-time insertion function.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>返回</strong></span>:&nbsp;</span>如果容器中已有一个相等的值，则返回一个含有指向已有值的 
node_ptr 与 false 的 pair。如果没有相等键值，该值可以插入，则在 pair 中返回 true 并且填充 "commit_data" 以用于 
"insert_commit" 函数进行常量时间的插入。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average complexity is at 
most logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
平均复杂度最多为对数复杂度。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p>
<p><span class="bold"><strong>Notes</strong></span>: This function is used to 
improve performance when constructing a node is expensive and the user does not 
want to have two equivalent nodes in the tree: if there is an equivalent value 
the constructed object must be discarded. Many times, the part of the node that 
is used to impose the order is much cheaper to construct than the node and this 
function offers the possibility to use that part to check if the insertion will 
be successful.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 该函数在节点</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">的构造非常昂贵且用户不希望在树中有相等节点时用于提升性能：如果容器中已经有一个相等的值，那么已构造好的对象必须被销毁。多数时候，节点中只有一部分是用于排序的，这部分的构造代价要比整个节点</span>的构造代价低得多，这个函数提供了用部分对象来检查插入操作是否成功的可能性。</p>
<p>If the check is successful, the user can construct the node and use 
"insert_commit" to insert the node in constant-time. This gives a total 
logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong></strong></span>如果检查是成功的，则用户可以构造节点</span>并使用 "insert_commit" 
来以常量时间插入节点。这种插入给出了一个总的对数复杂度：检查(O(log(N)) + 提交(O(1))。 </p>
<p>"commit_data" remains valid for a subsequent "insert_unique_commit" only if 
no more objects are inserted or erased from the set.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong></strong></span></span>"commit_data" 对于后续的 "insert_commit" 
保持有效当且仅当&nbsp;set 中没有插入或删除元素。</p></li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> KeyType, <span class="bold"><strong>typename</strong></span> KeyNodePtrCompare, <br>         <span class="bold"><strong>typename</strong></span> KeyNodePtrPrioCompare&gt; <br>  <span class="type"><span class="bold"><strong>static</strong></span> std::pair&lt; node_ptr, <span class="bold"><strong>bool</strong></span> &gt;</span> <br>  <a name="id3488029-bb"></a>insert_unique_check(const_node_ptr header, node_ptr hint, <br>                      <span class="bold"><strong>const</strong></span> KeyType &amp; key, KeyNodePtrCompare comp, <br>                      KeyNodePtrPrioCompare pcomp, <br>                      <a class="link" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data">insert_commit_data</a> &amp; commit_data) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. KeyNodePtrCompare is a function object that induces a 
strict weak ordering compatible with the strict weak ordering used to create the 
the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from 
the "header"'s tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 
必须是一棵树的头节点。KeyNodePtrCompare 是一个与创建该树时使用的严格弱序相兼容的函数对象。KeyNodePtrCompare&nbsp;对 
KeyType 和 node_ptr 进行比较。"hint" 是 "header" 的树的一个节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Checks if there is an 
equivalent node to "key" in the tree according to "comp" using "hint" as a hint 
to where it should be inserted and obtains the needed information to realize a 
constant-time node insertion if there is no equivalent node. If "hint" is the 
upper_bound the function has constant time complexity (two comparisons in the 
worst case).<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:<span class="Apple-converted-space">&nbsp;</span></span>检查</span>在树中是否有一个按照 "comp" 与 "key" 
相等的节点，并取得所需信息，以实现当没有相等节点时进行常量时间的节点插入。如果 "hint" 恰好是上界，则插入操作为常量时间(最坏情况下为两次比较)。</p>
<p><span class="bold"><strong>Returns</strong></span>: If there is an equivalent 
value returns a pair containing a node_ptr to the already present node and 
false. If there is not equivalent key can be inserted returns true in the 
returned pair's boolean and fills "commit_data" that is meant to be used with 
the "insert_commit" function to achieve a constant-time insertion function.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>返回</strong></span>:&nbsp;</span>如果容器中已有一个相等的值，则返回一个含有指向已有值的 
node_ptr 与 false 的 pair。如果没有相等键值，该值可以插入，则在 pair 中返回 true 并且填充 "commit_data" 以用于 
"insert_commit" 函数进行常量时间的插入。</p>
<p><span class="bold"><strong>Complexity</strong></span>: Average complexity is at 
most logarithmic, but it is amortized constant time if new_node should be 
inserted immediately before "hint".<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
平均复杂度最多为对数复杂度，</span>但如果 new_node 恰好在 hint 之前插入，则为分期常量时间<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: If "comp" throws.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 如果&nbsp;</span>"comp" 抛出<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">。</span></p>
<p><span class="bold"><strong>Notes</strong></span>: This function is used to 
improve performance when constructing a node is expensive and the user does not 
want to have two equivalent nodes in the tree: if there is an equivalent value 
the constructed object must be discarded. Many times, the part of the node that 
is used to impose the order is much cheaper to construct than the node and this 
function offers the possibility to use that part to check if the insertion will 
be successful.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 该函数在节点</span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">的构造非常昂贵且用户不希望在树中有相等节点时用于提升性能：如果容器中已经有一个相等的值，那么已构造好的对象必须被销毁。多数时候，节点中只有一部分是用于排序的，这部分的构造代价要比整个节点</span>的构造代价低得多，这个函数提供了用部分对象来检查插入操作是否成功的可能性。</p>
<p>If the check is successful, the user can construct the node and use 
"insert_commit" to insert the node in constant-time. This gives a total 
logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong></strong></span>如果检查是成功的，则用户可以构造节点</span>并使用 "insert_commit" 
来以常量时间插入节点。这种插入给出了一个总的对数复杂度：检查(O(log(N)) + 提交(O(1))。 </p>
<p>"commit_data" remains valid for a subsequent "insert_unique_commit" only if 
no more objects are inserted or erased from the set.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong></strong></span></span>"commit_data" 对于后续的 "insert_commit" 
保持有效当且仅当&nbsp;set 中没有插入或删除元素。</p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> <span class="bold"><strong>void</strong></span></span> <a name="id3488171-bb"></a>insert_unique_commit(node_ptr header, node_ptr new_node, <br>                                 <span class="bold"><strong>const</strong></span> <a class="link" href="treap_algorithms/insert_commit_data.html" title="Struct insert_commit_data">insert_commit_data</a> &amp; commit_data) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "header" must be the 
header node of a tree. "commit_data" must have been obtained from a previous 
call to "insert_unique_check". No objects should have been inserted or erased 
from the set between the "insert_unique_check" that filled "commit_data" and the 
call to "insert_commit".<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"header" 必须是一棵树的头节点。"commit_data" 
必须从上一个 "insert_unique_check" 调用取得。在 "insert_unique_check" 填充 "commit_data" 和调用 
"insert_commit" 之间不应有对象插入到 set 中或从 set 中移除对象。</p>
<p><span class="bold"><strong>Effects</strong></span>: Inserts new_node in the set 
using the information obtained from the "commit_data" that a previous 
"insert_check" filled.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:<span class="Apple-converted-space"> 
利用前一个</span></span></span> "insert_check" 所填充的 "commit_data" 中的信息，<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;">将</span> 
new_node<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"> 
插入到&nbsp;</span>set<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"> 
中。</span></p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant time.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
常量。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p>
<p><span class="bold"><strong>Notes</strong></span>: This function has only sense 
if a "insert_unique_check" has been previously executed to fill "commit_data". 
No value should be inserted or erased between the "insert_check" and 
"insert_commit" calls.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>备注</strong></span>: 该</span></span>函数仅当前面已经调用了 "insert_check" 
来填充 "commit_data" 时才有意义。在 "insert_check" 和 "insert_commit" 的调用之间不能插入或删除任何元素。</p></li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>static</strong></span> node_ptr</span> <a name="id3488246-bb"></a>get_header(node_ptr n) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: "n" must be a node 
inserted in a tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>要求</strong></span>:&nbsp;</span>"n" 必须是一个已插入到树中的节点。</p>
<p><span class="bold"><strong>Effects</strong></span>: Returns a pointer to the 
header node of the tree.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><span class="Apple-style-span" style="word-spacing: 0px; font-family: '-webkit-sans-serif'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>作用</strong></span>:<span class="Apple-converted-space"> 
返回一个指针，指向树的头节点。</span></span></span><span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"></span></p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>复杂度</strong></span><span class="bold"><strong></strong></span>: 
对数。</span></p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.<span class="Apple-style-span" style="word-spacing: 0px; font-family: -webkit-sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 13px; line-height: 15px; text-transform: none; color: rgb(0, 0, 0); text-indent: 0px; white-space: normal; letter-spacing: normal; border-collapse: separate; text-align: left; font-size-adjust: none; font-stretch: normal; orphans: 2; widows: 2;"><br><span class="bold"><strong>抛出</strong></span>: 无。</span></p></li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 Olaf Krzikalla, 2006-2008 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="make_trie.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../intrusive/reference.html#header.boost.intrusive.treap_algorithms_hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="treap_algorithms/insert_commit_data.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
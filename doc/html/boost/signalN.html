<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Class template signalN</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../signals/reference.html#header.boost.signal.hpp" title="Header &lt;boost/signal.hpp&gt;">
<link rel="prev" href="../signals/reference.html" title="Reference">
<link rel="next" href="signal.html" title="Class template signal">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../signals/reference.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../signals/reference.html#header.boost.signal.hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="signal.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.signalN"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template signalN</span></h2>
<p>boost::signalN &#8212; Set of safe multicast callback types.</p>

<p>boost::signalN &#8212; 可安全地进行一对多回调的一组类型。</p>

</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> R, <span class="bold"><strong>typename</strong></span> T1, <span class="bold"><strong>typename</strong></span> T2, ..., <span class="bold"><strong>typename</strong></span> TN, 
         <span class="bold"><strong>typename</strong></span> Combiner = <a class="link" href="last_value.html" title="Class template last_value">last_value</a>&lt;R&gt;, <span class="bold"><strong>typename</strong></span> Group = <span class="bold"><strong>int</strong></span>, 
         <span class="bold"><strong>typename</strong></span> GroupCompare = std::less&lt;Group&gt;, 
         <span class="bold"><strong>typename</strong></span> SlotFunction = <a class="link" href="functionN.html" title="Class template functionN">functionN</a>&lt;R, T1, T2, ..., TN&gt; &gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="signalN.html" title="Class template signalN">signalN</a> : <span class="bold"><strong>public</strong></span> <a class="link" href="signals/trackable.html" title="Class trackable">signals::trackable</a>,
                <span class="bold"><strong>private</strong></span> noncopyable   <span class="emphasis"><em>// Exposition only</em></span>
{
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> Combiner::result_type <a name="boost.signalN.result_type"></a>result_type;         
  <span class="bold"><strong>typedef</strong></span> Combiner                       <a name="boost.signalN.combiner_type"></a>combiner_type;       
  <span class="bold"><strong>typedef</strong></span> Group                          <a name="boost.signalN.group_type"></a>group_type;          
  <span class="bold"><strong>typedef</strong></span> GroupCompare                   <a name="boost.signalN.group_compare_type"></a>group_compare_type;  
  <span class="bold"><strong>typedef</strong></span> SlotFunction                   <a name="boost.signalN.slot_function_type"></a>slot_function_type;  
  <span class="bold"><strong>typedef</strong></span> <a class="link" href="slot.html" title="Class template slot">slot</a>&lt;SlotFunction&gt;             <a name="boost.signalN.slot_type"></a>slot_type;           
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span>                    <a name="boost.signalN.slot_result_type"></a>slot_result_type;    
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span>                    <a name="boost.signalN.slot_call_iterator"></a>slot_call_iterator;  
  <span class="bold"><strong>typedef</strong></span> T1                             <a name="boost.signalN.argument_type"></a>argument_type;         <span class="emphasis"><em>// If N == 1</em></span>
  <span class="bold"><strong>typedef</strong></span> T1                             <a name="boost.signalN.first_argument_type"></a>first_argument_type;   <span class="emphasis"><em>// If N == 2</em></span>
  <span class="bold"><strong>typedef</strong></span> T2                             <a name="boost.signalN.second_argument_type"></a>second_argument_type;  <span class="emphasis"><em>// If N == 2</em></span>
  <span class="bold"><strong>typedef</strong></span> T1                             <a name="boost.signalN.arg1_type"></a>arg1_type;           
  <span class="bold"><strong>typedef</strong></span> T2                             <a name="boost.signalN.arg2_type"></a>arg2_type;           
     .
     .
     .
  <span class="bold"><strong>typedef</strong></span> TN                             <a name="boost.signalN.argN_type"></a>argN_type;           

  <span class="emphasis"><em>// static constants</em></span>
  <span class="bold"><strong>static</strong></span> <span class="bold"><strong>const</strong></span> <span class="type"><span class="bold"><strong>int</strong></span></span> arity = N;

  <span class="emphasis"><em>// <a class="link" href="signalN.html#boost.signalNconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="signalN.html#id307812-bb">signalN</a>(<span class="bold"><strong>const</strong></span> combiner_type&amp; = combiner_type(), 
          <span class="bold"><strong>const</strong></span> group_compare_type&amp; = group_compare_type());
  <a class="link" href="signalN.html#id748673-bb">~signalN</a>();

  <span class="emphasis"><em>// <a class="link" href="signalN.html#id356138-bb">connection management</a></em></span>
  <span class="type"><a class="link" href="signals/connection.html" title="Class connection">signals::connection</a></span> 
  <a class="link" href="signalN.html#id211160-bb">connect</a>(<span class="bold"><strong>const</strong></span> slot_type&amp;, signals::connect_position = signals::at_back);
  <span class="type"><a class="link" href="signals/connection.html" title="Class connection">signals::connection</a></span> 
  <a class="link" href="signalN.html#id391849-bb">connect</a>(<span class="bold"><strong>const</strong></span> group_type&amp;, <span class="bold"><strong>const</strong></span> slot_type&amp;, 
          signals::connect_position = signals::at_back);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="signalN.html#id708164-bb">disconnect</a>(<span class="bold"><strong>const</strong></span> group_type&amp;);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Slot&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="signalN.html#id394188-bb">disconnect</a>(<span class="bold"><strong>const</strong></span> Slot&amp;);
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="signalN.html#id785804-bb">disconnect_all_slots</a>();
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="signalN.html#id231169-bb">empty</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">std::size_t</span> <a class="link" href="signalN.html#id776400-bb">num_slots</a>() <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="signalN.html#id760286-bb">invocation</a></em></span>
  <span class="type">result_type</span> <a class="link" href="signalN.html#id785271-bb"><span class="bold"><strong>operator</strong></span>()</a>(arg1_type, arg2_type, ..., argN_type);
  <span class="type">result_type</span> <a class="link" href="signalN.html#id411047-bb"><span class="bold"><strong>operator</strong></span>()</a>(arg1_type, arg2_type, ..., argN_type) <span class="bold"><strong>const</strong></span>;

  <span class="emphasis"><em>// <a class="link" href="signalN.html#id776745-bb">combiner access</a></em></span>
  <span class="type">combiner_type&amp;</span> <a class="link" href="signalN.html#id759064-bb">combiner</a>();
  <span class="type"><span class="bold"><strong>const</strong></span> combiner_type&amp;</span> <a class="link" href="signalN.html#id373829-bb">combiner</a>() <span class="bold"><strong>const</strong></span>;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id1280484"></a><h2>Description</h2>
<p>The class template <a class="link" href="signalN.html" title="Class template signalN">signalN</a> covers
         several related classes signal0, signal1, signal2, etc.,
         where the number suffix describes the number of function
         parameters the signal and its connected slots will
         take. Instead of enumerating all classes, a single pattern
         <a class="link" href="signalN.html" title="Class template signalN">signalN</a> will be described, where N
         represents the number of function parameters.</p>

<p>类模板 <a class="link" href="signalN.html" title="Class template signalN">signalN</a> 
         包括几个相关的类：signal0、signal1、signal2，等等，
         其中的数字后缀表示信号及其所连接的插槽接受的函数参数的个数。
         这里不是列举所有的类，而是描述一个单一的模式
         <a class="link" href="signalN.html" title="Class template signalN">signalN</a>，
         其中 N 代表了函数参数的个数。</p>

<div class="refsect2" lang="en">
<a name="id1280510"></a><h3>
<a name="boost.signalNconstruct-copy-destruct"></a><code class="computeroutput">signalN</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id307812-bb"></a>signalN(<span class="bold"><strong>const</strong></span> combiner_type&amp; combiner = combiner_type(), 
        <span class="bold"><strong>const</strong></span> group_compare_type&amp; compare = group_compare_type());</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>Initializes the signal to contain no slots, copies the given combiner into internal storage, and stores the given group comparison function object to compare groups.</td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><code class="computeroutput">this-&gt;<a class="link" href="signalN.html#id231169-bb">empty</a>()</code></td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">效果：</span></p></td>
<td>初始化信号，无插槽，
复制并内部保存输入的合并器，并保存输入的编组比较函数对象，以便比较编组。
</td>
</tr>
<tr>
<td nowrap><p><span class="term">后验条件：</span></p></td>
<td><code class="computeroutput">this-&gt;<a class="link" href="signalN.html#id231169-bb">empty</a>()</code></td>
</tr>
</tbody>
</table></div>

</li>
<li>
<pre class="literallayout"><a name="id748673-bb"></a>~signalN();</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Effects:</span></p></td>
<td>Disconnects all slots connected to <code class="computeroutput">*this</code>.</td>
</tr></tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td nowrap><p><span class="term">效果：</span></p></td>
<td>断开所有连接到 <code class="computeroutput">*this</code> 的插槽。</td>
</tr></tbody>
</table></div>

</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id1280624"></a><h3>
<a name="id356138-bb"></a><code class="computeroutput">signalN</code> connection management</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id417694-bb"></a><span class="type"><a class="link" href="signals/connection.html" title="Class connection">signals::connection</a></span> 
<a name="id211160-bb"></a>connect(<span class="bold"><strong>const</strong></span> slot_type&amp; slot, 
        signals::connect_position at = signals::at_back);
<span class="type"><a class="link" href="signals/connection.html" title="Class connection">signals::connection</a></span> 
<a name="id391849-bb"></a>connect(<span class="bold"><strong>const</strong></span> group_type&amp; group, <span class="bold"><strong>const</strong></span> slot_type&amp; slot, 
        signals::connect_position at = signals::at_back);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>Connects the signal this to the incoming
          slot. If the slot is inactive, i.e., any of the trackable
          objects bound by the slot call have been destroyed, then the
          call to connect is a no-op. If the second version of
          <code class="computeroutput">connect</code> is invoked, the
          slot is associated with the given group. The <code class="computeroutput">at</code>
          parameter specifies where the slot should be connected:
          <code class="computeroutput">at_front</code> indicates that the slot will be
          connected at the front of the list or group of slots and
          <code class="computeroutput">at_back</code> indicates that the slot will be
          connected at the back of the list or group of
          slots.</td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A
          <code class="computeroutput"><a class="link" href="signals/connection.html" title="Class connection">signals::connection</a></code>
          object that references the newly-created connection between
          the signal and the slot; if the slot is inactive, returns a
          disconnected connection.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>This routine meets the strong exception guarantee,
          where any exception thrown will cause the slot to not be
          connected to the signal.</td>
</tr>
<tr>
<td><p><span class="term">Complexity:</span></p></td>
<td>Constant time when connecting a slot
          without a group name or logarithmic in the number of groups
          when connecting to a particular
          group.</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>It is unspecified whether connecting a slot while the
          signal is calling will result in the slot being called
          immediately.</td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">效果：</span></p></td>
<td>连接信号 this 到传进来的插槽．
          如果插槽是非活动的，即插槽绑定的任何可跟踪对象已被销毁，
          那么对连接的调用将是个空操作。
          如果调用第2个版本的
          <code class="computeroutput">connect</code>，
          插槽将与给定的编组相关联。
          <code class="computeroutput">at</code>
          参数指定了插槽所连接的位置：
          <code class="computeroutput">at_front</code>
          表示插槽将连接到链表或插槽组的头部，
          而 <code class="computeroutput">at_back</code>
          表示插槽将连接到链表或插槽组的尾部。</td>
</tr>
<tr>
<td nowrap><p><span class="term">返回：</span></p></td>
<td><code class="computeroutput"><a class="link" href="signals/connection.html" title="Class connection">signals::connection</a></code> 对象，
          即信号和插槽之间新建的连接；
          如果插槽是非活动的，则返回已断开的连接。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">抛异常：</span></p></td>
<td>该函数符合强异常保证，任何异常都将导致该插槽不会连接到信号。
</td>
</tr>
<tr>
<td nowrap><p><span class="term">复杂度：</span></p></td>
<td>
          当没有组名时，插槽连接是常数时间的，
          当连接到特定编组时，与编组个数成对数关系。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">注意：</span></p></td>
<td>当信号正在调用时连接插槽，是否会导致该插槽被立即调用？这一点并未规定。
          </td>
</tr>
</tbody>
</table></div>

</li>
<li>
<pre class="literallayout"><a name="id481008-bb"></a><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id708164-bb"></a>disconnect(<span class="bold"><strong>const</strong></span> group_type&amp; group);
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Slot&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id394188-bb"></a>disconnect(<span class="bold"><strong>const</strong></span> Slot&amp; slot);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>If the parameter is (convertible to) a
          group name, any slots in the given group are
          disconnected. Otherwise, any slots equal to the given slot
          are disconnected.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw unless a user destructor or
          equality operator <code class="computeroutput">==</code> throws. If either throws,
          not all slots may be disconnected.</td>
</tr>
<tr>
<td><p><span class="term">Complexity:</span></p></td>
<td>If a group is given, O(lg g) + k where
          g is the number of groups in the signal and k is the
          number of slots in the group. Otherwise, linear in the
          number of slots connected to the
          signal.</td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">效果：</span></p></td>
<td>如果参数为（或可转换为）一个组名，
          则该编组中的任何插槽都将被断开。
          否则，与输入插槽相等的任何插槽都将被断开。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">抛异常：</span></p></td>
<td>不抛异常，除非用户的析构函数或相等运算符 
          <code class="computeroutput">==</code> 抛异常。
          如果其中之一抛异常，
          则可能不是所有插槽都被断开。</td>
</tr>
<tr>
<td nowrap><p><span class="term">复杂度：</span></p></td>
<td>如果输入的是一个编组，则是 O(lg g) + k，其中
          g 是信号中编组的个数，k 是该组中插槽的个数。
          否则与信号连接的插槽个数成线性关系。
          </td>
</tr>
</tbody>
</table></div>

</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id785804-bb"></a>disconnect_all_slots();</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>Disconnects all slots connected to the signal.</td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td>
<code class="computeroutput">this-&gt;<a class="link" href="signalN.html#id231169-bb">empty</a>()</code>.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If disconnecting a slot causes an exception to be
          thrown, not all slots may be disconnected.</td>
</tr>
<tr>
<td><p><span class="term">Complexity:</span></p></td>
<td>Linear in the number of slots known to the
          signal.</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>May be called at any time within the lifetime of the
          signal, including during calls to the signal's slots.</td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">效果：</span></p></td>
<td>断开所有连接到信号的插槽。</td>
</tr>
<tr>
<td nowrap><p><span class="term">后验条件：</span></p></td>
<td>
<code class="computeroutput">this-&gt;<a class="link" href="signalN.html#id231169-bb">empty</a>()</code>.</td>
</tr>
<tr>
<td nowrap><p><span class="term">抛异常：</span></p></td>
<td>如果断开插槽导致抛出异常，则可能并非所有插槽都被断开。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">复杂度：</span></p></td>
<td>与信号所知的插槽个数成线性关系。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">注意：</span></p></td>
<td>可以在信号生命期的任意时刻调用，包括在调用信号的插槽时。
          </td>
</tr>
</tbody>
</table></div>

</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id231169-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<code class="computeroutput">true</code> if no slots
          are connected to the signal, and
          <code class="computeroutput">false</code> otherwise.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw.</td>
</tr>
<tr>
<td><p><span class="term">Complexity:</span></p></td>
<td>Linear in the number of slots known to the
          signal.</td>
</tr>
<tr>
<td><p><span class="term">Rationale:</span></p></td>
<td>Slots can disconnect at any point in time,
          including while those same slots are being invoked. It is
          therefore possible that the implementation must search
          through a list of disconnected slots to determine if any
          slots are still connected.</td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">返回：</span></p></td>
<td>如果没有插槽连接到信号，返回 <code class="computeroutput">true</code>，
          否则为 <code class="computeroutput">false</code>。</td>
</tr>
<tr>
<td nowrap><p><span class="term">抛异常：</span></p></td>
<td>无。</td>
</tr>
<tr>
<td nowrap><p><span class="term">复杂度：</span></p></td>
<td>与信号所知的插槽个数成线性关系。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">原理：</span></p></td>
<td>插槽可在任意时刻断开，
          包括当那些相同的插槽正在被调用时。
          因此可能实现必须搜索已断开插槽链表来决定是否还有插槽仍在连接中。
          </td>
</tr>
</tbody>
</table></div>

</li>
<li>
<pre class="literallayout"><span class="type">std::size_t</span> <a name="id776400-bb"></a>num_slots() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The number of slots connected to the signal</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw.</td>
</tr>
<tr>
<td><p><span class="term">Complexity:</span></p></td>
<td>Linear in the number of slots known to the
          signal.</td>
</tr>
<tr>
<td><p><span class="term">Rationale:</span></p></td>
<td>Slots can disconnect at any point in time,
          including while those same slots are being invoked. It is
          therefore possible that the implementation must search
          through a list of disconnected slots to determine how many
          slots are still connected.</td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">返回：</span></p></td>
<td>连接到信号的插槽个数</td>
</tr>
<tr>
<td nowrap><p><span class="term">抛异常：</span></p></td>
<td>无。</td>
</tr>
<tr>
<td nowrap><p><span class="term">复杂度：</span></p></td>
<td>与信号所知的插槽个数成线性关系。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">原理：</span></p></td>
<td>插槽可在任意时刻断开，
          包括当那些相同的插槽正在被调用时。
          因此可能实现必须搜索已断开插槽链表来决定有多少插槽仍在连接中。
          </td>
</tr>
</tbody>
</table></div>

</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id1281116"></a><h3>
<a name="id760286-bb"></a><code class="computeroutput">signalN</code> invocation</h3>
<div class="orderedlist"><ol type="1"><li>
<pre class="literallayout"><a name="id717180-bb"></a><span class="type">result_type</span> <a name="id785271-bb"></a><span class="bold"><strong>operator</strong></span>()(arg1_type a1, arg2_type a2, ..., argN_type aN);
<span class="type">result_type</span> <a name="id411047-bb"></a><span class="bold"><strong>operator</strong></span>()(arg1_type a1, arg2_type a2, ..., argN_type aN) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td>Invokes the combiner with a
          <code class="computeroutput">slot_call_iterator</code> range
          [first, last) corresponding to the sequence of calls to the
          slots connected to signal
          <code class="computeroutput">*this</code>. Dereferencing an
          iterator in this range causes a slot call with the given set
          of parameters <code class="computeroutput">(a1, a2, ...,
          aN)</code>, the result of which is returned from
          the iterator dereference operation.</td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The result returned by the combiner.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>If an exception is thrown by a slot call, or if the
          combiner does not dereference any slot past some given slot,
          all slots after that slot in the internal list of connected
          slots will not be invoked.</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Only the slots associated with iterators that are
          actually dereferenced will be invoked. Multiple dereferences
          of the same iterator will not result in multiple slot
          invocations, because the return value of the slot will be
          cached.</p>
<p>The <code class="computeroutput">const</code> version of
          the function call operator will invoke the combiner as
          <code class="computeroutput">const</code>, whereas the
          non-<code class="computeroutput">const</code> version will
          invoke the combiner as
          non-<code class="computeroutput">const</code>.</p>
<p>Calling the function call operator may invoke undefined
          behavior if no slots are connected to the signal, depending
          on the combiner used. The default combiner is well-defined
          for zero slots when the return type is void but is undefined
          when the return type is any other type (because there is no
          way to synthesize a return value).</p>
</td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">效果：</span></p></td>
<td>用一个 <code class="computeroutput">slot_call_iterator</code> 区间
          [first, last) 调用合并器，
          该区间对应于一系列连接到信号
          <code class="computeroutput">*this</code>
          的插槽调用。
          
          解引用该区间内的迭代器会导致插槽调用，
          调用参数为输入的参数
          <code class="computeroutput">(a1, a2, ...,
          aN)</code>，其结果将作为迭代器的解引用运算符的返回值。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">返回：</span></p></td>
<td>合并器返回的结果。</td>
</tr>
<tr>
<td nowrap><p><span class="term">抛异常：</span></p></td>
<td>如果有插槽调用抛异常，或者合并器在某些插槽之后就不再解引用任何插槽，
          则内部已连接插槽链表中，该插槽之后的所有插槽将不会被调用。
          </td>
</tr>
<tr>
<td nowrap><p><span class="term">注意：</span></p></td>
<td>
<p>仅有实际解引用的迭代器所关联的插槽才会被调用。
          同一个迭代器的多次解引用不会导致多次插槽调用，
          因为插槽的返回值会被缓存。
          </p>
<p>函数调用运算符的 <code class="computeroutput">const</code> 
          版将按 <code class="computeroutput">const</code>
          调用合并器，
          而非<code class="computeroutput">const</code> 
          版将按非<code class="computeroutput">const</code>
          调用合并器。</p>
<p>如果没有插槽连接到信号，取决于所用的合并器，
          调用函数调用运算符可引起未定义行为。
          
          默认的合并器当其返回值为void时，对于零插槽是定义完善的，
          但返回值是其他类型时则未定义（因为没法合成一个返回值）。
          </p>
</td>
</tr>
</tbody>
</table></div>

</li></ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id1281283"></a><h3>
<a name="id776745-bb"></a><code class="computeroutput">signalN</code> combiner access</h3>
<div class="orderedlist"><ol type="1"><li>
<pre class="literallayout"><a name="id726948-bb"></a><span class="type">combiner_type&amp;</span> <a name="id759064-bb"></a>combiner();
<span class="type"><span class="bold"><strong>const</strong></span> combiner_type&amp;</span> <a name="id373829-bb"></a>combiner() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A reference to the stored combiner.</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>Will not throw.</td>
</tr>
</tbody>
</table></div>

<br>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td nowrap><p><span class="term">返回：</span></p></td>
<td>所保存合并器的引用。</td>
</tr>
<tr>
<td nowrap><p><span class="term">抛异常：</span></p></td>
<td>无。</td>
</tr>
</tbody>
</table></div>

</li></ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &copy; 2001-2004 Douglas Gregor

      <p>翻译：<a href="http://blog.csdn.net/jq0123">金庆</a></p>
      <p>译文更新：2008.7.8</p>

<p>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <code class="filename">LICENSE_1_0.txt</code> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../signals/reference.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../signals/reference.html#header.boost.signal.hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="signal.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

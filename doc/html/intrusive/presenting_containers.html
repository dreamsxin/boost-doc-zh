<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Presenting Boost.Intrusive containers</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../intrusive.html" title="Chapter&nbsp;10.&nbsp;Boost.Intrusive">
<link rel="prev" href="concepts_summary.html" title="Concept summary">
<link rel="next" href="safe_hook.html" title="Safe hooks"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="concepts_summary.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="safe_hook.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="intrusive.presenting_containers"></a><a class="link" href="presenting_containers.html" title="Presenting Boost.Intrusive containers"> Presenting Boost.Intrusive
    containers 介绍 Boost.Intrusive 容器</a>
</h2></div></div></div>
<p>
      <span class="bold"><strong>Boost.Intrusive</strong></span> offers a wide range of intrusive
      containers:<br><span class="bold"><strong>Boost.Intrusive</strong></span> 提供了大量的介入式容器：
    </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong>slist</strong></span>: An intrusive singly linked list.
        The size overhead is very small for user classes (usually the size of one
        pointer) but many operations have linear time complexity, so the user must
        be careful if he wants to avoid performance problems.<br><span class="bold"><strong>slist</strong></span>: 介入式的单链表。对于用户类的空间开销非常小(通常只有一个指针的大小)，但多数操作具有线性的时间复杂度，因此，如果用户想避免性能问题，就要小心使用。<br><span class="bold"><strong></strong></span>
      </li>
<li>
<span class="bold"><strong>list</strong></span>: A <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>
        like intrusive linked list. The size overhead is quite small for user classes
        (usually the size of two pointers). Many operations have constant time complexity.<br><span class="bold"><strong>list</strong></span>: 一个类似于 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>
        的介入式链表。对于用户类的空间开销非常小(通常只有两个指针的大小)。多数操作具有线性的时间复杂度。
      </li>
<li>
<span class="bold"><strong>set/multiset/rbtree</strong></span>: <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>
        like intrusive associative containers based on red-black trees. The size
        overhead is moderate for user classes (usually the size of three pointers).
        Many operations have logarithmic time complexity.<br><span class="bold"><strong>set/multiset/rbtree</strong></span>: 类似于 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code> 的介入式关联容器，基于红黑树。对于用户类的空间开销适中(通常为三个指针的大小)。多数操作具有对数时间复杂度。
      </li>
<li>
<span class="bold"><strong>avl_set/avl_multiset/avltree</strong></span>: A <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code> like intrusive associative containers
        based on AVL trees. The size overhead is moderate for user classes (usually
        the size of three pointers). Many operations have logarithmic time complexity.<br><span class="bold"><strong>avl_set/avl_multiset/avltree</strong></span>: 类似于 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>&nbsp;的介入式关联容器，基于 AVL 树。对于用户类的空间开销适中(通常为三个指针的大小)。多数操作具有对数时间复杂度。
      </li>
<li>
<span class="bold"><strong>splay_set/splay_multiset/splaytree</strong></span>: <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code> like intrusive associative containers
        based on splay trees. Splay trees have no constant operations, but they have
        some interesting caching properties. The size overhead is moderate for user
        classes (usually the size of three pointers). Many operations have logarithmic
        time complexity.<br><span class="bold"><strong>splay_set/splay_multiset/splaytree</strong></span>: 类似于 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>&nbsp;的介入式关联容器，基于 splay 树。splay 树不具有常量性的操作，不过它有一些有趣的缓存特性。对于用户类的空间开销适中(通常为三个指针的大小)。多数操作具有对数时间复杂度。
      </li>
<li>
<span class="bold"><strong>sg_set/sg_multiset/sgtree</strong></span>: A <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code> like intrusive associative containers
        based on scapegoat trees. Scapegoat can be configured with the desired balance
        factor to achieve the desired rebalancing frequency/search time compromise.
        The size overhead is moderate for user classes (usually the size of three
        pointers). Many operations have logarithmic time complexity.<br><span class="bold"><strong>sg_set/sg_multiset/sgtree</strong></span>: 类似于 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>&nbsp;的介入式关联容器，基于&nbsp;scapegoat 树。scapegoat 树可以按所期望的平衡因子来配置，以达到所希望的重新平衡频度和查找时间之间的折衷。对于用户类的空间开销适中(通常为三个指针的大小)。多数操作具有对数时间复杂度。
      </li>
</ul></div>
<p>
      <span class="bold"><strong>Boost.Intrusive</strong></span> also offers semi-intrusive
      containers:<br><span class="bold"><strong>Boost.Intrusive</strong></span> 还提供了半介入式容器：
    </p>
<div class="itemizedlist"><ul type="disc"><li>
<span class="bold"><strong>unordered_set/unordered_multiset</strong></span>: <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_multiset</span></code>
        like intrusive unordered associative containers. The size overhead is moderate
        for user classes (an average of two pointers per element). Many operations
        have amortized constant time complexity.<br><span class="bold"><strong>unordered_set/unordered_multiset</strong></span>: 类似于 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span><span class="special">/</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_multiset</span></code>&nbsp;的介入式无序关联容器。对于用户类的空间开销适中(平均为每个元素两个指针)。多数操作具有分期常量时间复杂度。
      </li></ul></div>
<p>
      Most of these intrusive containers can be configured with constant or linear
      time size:<br>这些介入式容器中的多数可以被配置为带有常量时间复杂度或线性时间复杂度的 size 函数：
    </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong>Linear time size</strong></span>: The intrusive container
        doesn't hold a size member that is updated with every insertion/erasure.
        This implies that the <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> function doesn't have constant time complexity.
        On the other hand, the container is smaller, and some operations, like <code class="computeroutput"><span class="identifier">splice</span><span class="special">()</span></code>
        taking a range of iterators in linked lists, have constant time complexity
        instead of linear complexity.<br><span class="bold"><strong>线性时间的 size</strong></span>: 此类介入式容器不存在一个在每次插入/删除时更新的 size 成员。这意味着 <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> 函数不具有常量时间复杂度。另一方面，容器可以更小，而且某些操作，如接受一个在链表中的迭代器区间的 <code class="computeroutput"><span class="identifier">splice</span><span class="special">()</span></code>，则具有常量时间复杂度而不是线性复杂度。
      </li>
<li>
<span class="bold"><strong>Constant time size</strong></span>: The intrusive container
        holds a size member that is updated with every insertion/erasure. This implies
        that the <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>
        function has constant time complexity. On the other hand, increases the size
        of the container, and some operations, like <code class="computeroutput"><span class="identifier">splice</span><span class="special">()</span></code> taking a range of iterators, have linear
        time complexity in linked lists.<br><span class="bold"><strong>常量时间的 size</strong></span>: 此类介入式容器保存了一个在每次插入/删除时更新的 size 成员。这意味着 <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> 函数具有常量时间复杂度。另一方面，这增加了容器的大小，而且某些操作，如接受一个在链表中的迭代器区间的 <code class="computeroutput"><span class="identifier">splice</span><span class="special">()</span></code>，则具有线性复杂度。
      </li>
</ul></div>
<p>
      To make user classes compatible with these intrusive containers <span class="bold"><strong>Boost.Intrusive</strong></span>
      offers two types of hooks for each container type:<br>为了让用户类兼容于这些介入式容器，<span class="bold"><strong>Boost.Intrusive</strong></span> 为每种容器类型提供了两类钩子：
    </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong>Base hook</strong></span>: The hook is stored as a public
        base class of the user class.<br><span class="bold"><strong>基类钩子：</strong></span>钩子被保存为用户的一个公有基类。
      </li>
<li>
<span class="bold"><strong>Member hook</strong></span>: The hook is stored as a public
        member of the user class.<br><span class="bold"><strong>成员钩子：</strong></span>钩子被保存为用户的一个公有成员。
      </li>
</ul></div>
<p>
      Apart from that, <span class="bold"><strong>Boost.Intrusive</strong></span> offers additional
      features:<br>除此以外，<span class="bold"><strong>Boost.Intrusive</strong></span> 还提供了以下特性：
    </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong>Safe mode hooks</strong></span>: Hook constructor initializes
        the internal data to a well-known safe state and intrusive containers check
        that state before inserting a value in the container. When erasing an element
        from the container, the container puts the hook in the safe state again.
        This allows a safer use mode and it can be used to detect programming errors.
        It implies a slight performance overhead in some operations and can convert
        some constant time operations to linear time operations.<br><span class="bold"><strong>安全模式钩子：</strong></span>钩
子的构造函数将内部数据初始化为一种可知的安全状态，介入式容器在插入一个值之前检查该状态。从容器中删除一个元素时，容器再次将钩子置回安全状态。这样
就允许了一种安全的使用模式，它可以被用于检测程序的错误。它意味着某些操作会有轻微的性能开销，也可能将一些常量时间的操作变为线性时间。
      </li>
<li>
<span class="bold"><strong>Auto-unlink hooks</strong></span>: The hook destructor removes
        the object from the container automatically and the user can safely unlink
        the object from the container without referring to the container.<br><span class="bold"><strong>自断钩子：</strong></span>钩子的析构函数自动将对象从容器中移除，用户无需知道容器就可以安全地将对象从容器断开。
      </li>
<li>
<span class="bold"><strong>Non-raw pointers</strong></span>: If the user wants to use
        smart pointers instead of raw pointers, <span class="bold"><strong>Boost.Intrusive</strong></span>
        hooks can be configured to use any type of pointer. This configuration information
        is also transmitted to the containers, so all the internal pointers used
        by intrusive containers configured with these hooks will be smart pointers.
        As an example, <span class="bold"><strong>Boost.Interprocess</strong></span> defines
        an mart pointer compatible with shared memory, called <code class="computeroutput"><span class="identifier">offset_ptr</span></code>.
        <span class="bold"><strong>Boost.Intrusive</strong></span> can be configured to use
        this smart pointer to allow shared memory intrusive containers.<br><span class="bold"><strong>非裸指针：</strong></span>如果用户想用智能指针代替裸指针，<span class="bold"><strong>Boost.Intrusive</strong></span> 钩子可以被配置为使用任意类型的指针。这一配置信息也被转送到容器，所以以这些钩子进行配置的介入式容器所使用的所有内部指针都会是智能指针。例如，<span class="bold"><strong>Boost.Interprocess</strong></span> 定义了一个兼容于共享内存的智能指针，名为 <code class="computeroutput"><span class="identifier">offset_ptr</span></code>。
        <span class="bold"><strong>Boost.Intrusive</strong></span> 可以被配置为使用此智能指针，就可以使用共享内存介入式容器。
      </li>
</ul></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 Olaf Krzikalla, 2006-2007 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="concepts_summary.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="safe_hook.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
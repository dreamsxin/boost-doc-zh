<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Performance</title>

<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../intrusive.html" title="Chapter&nbsp;10.&nbsp;Boost.Intrusive">
<link rel="prev" href="design_notes.html" title="Design Notes">
<link rel="next" href="release_notes.html" title="Release Notes"></head>
<body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="design_notes.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="release_notes.html"><img src="../../../doc/html/images/next.png" alt="Next"></a></div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="intrusive.performance"></a><a class="link" href="performance.html" title="Performance">Performance
性能</a>
</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="performance.html#intrusive.performance.performance_results_push_back">
Back insertion and destruction 后端插入和析构</a></span></dt>
<dt><span class="section"><a href="performance.html#intrusive.performance.performance_results_reversing">
Reversing 反序</a></span></dt>
<dt><span class="section"><a href="performance.html#intrusive.performance.performance_results_sorting">
Sorting 排序</a></span></dt>
<dt><span class="section"><a href="performance.html#intrusive.performance.performance_results_write_access">
Write access 写访问</a></span></dt>
<dt><span class="section"><a href="performance.html#intrusive.performance.performance_results_conclusions">
Conclusions&nbsp;结论</a></span></dt>
</dl>
</div>
<p> <span class="bold"><strong>Boost.Intrusive</strong></span>
containers offer speed improvements compared to non-intrusive
containers primarily because:<br>
<span class="bold"><strong>Boost.Intrusive</strong></span>
容器与非介入式容器相比，提高了速度，主要是因为： </p>
<div class="itemizedlist">
<ul type="disc">
<li> They minimize memory allocation/deallocation calls.<br>
它们最小化了对内存分配/释放的调用。 </li>
<li> They obtain better memory locality.<br>
它们有更好的内存局部化。 </li>
</ul>
</div>
<p> This section will show performance tests comparing some
operations on <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">::</span><span class="identifier">list</span></code>
and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>:<br>
这一节将展示在 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">::</span><span class="identifier">list</span></code>
和 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>
之上的一些操作的性能测试比较： </p>
<div class="itemizedlist">
<ul type="disc">
<li> Insertions using <code class="computeroutput"><span class="identifier">push_back</span></code> and
container destruction will show the overhead associated with memory
allocation/deallocation.<br>
用 <code class="computeroutput"><span class="identifier">push_back</span></code>
进行插入，以及析构容器，展示与内存分配/释放相关的开销。 </li>
<li> The <code class="computeroutput"><span class="identifier">reverse</span></code> member
function will show the advantages of the compact memory representation
that can be achieved with intrusive containers.<br>
<code class="computeroutput"><span class="identifier">reverse</span></code>
成员函数将展示由介入式容器所实现的紧凑内存表示的好处。 </li>
<li> The <code class="computeroutput"><span class="identifier">sort</span></code> and <code class="computeroutput"><span class="identifier">write</span>
<span class="identifier">access</span></code>
tests will show the advantage of intrusive containers minimizing memory
accesses compared to containers of pointers.<br>
<code class="computeroutput"><span class="identifier">sort</span></code> 和 <code class="computeroutput"><span class="identifier">write</span>
<span class="identifier">access</span></code>
测试将展示介入式容器与指针容器相比，在最小化内存访问方面的优势。 </li>
</ul>
</div>
<p> Given an object of type <code class="computeroutput"><span class="identifier">T</span></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/list.html" title="Class template list">boost::intrusive::list&lt;T&gt;</a></code>
can replace <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
to avoid memory allocation overhead, or it can replace <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">*&gt;</span></code>
when the user wants containers with polymorphic values or wants to
share values between several containers. Because of this versatility,
the performance tests will be executed for 6 different list types:<br>
给定一个类型为 <code class="computeroutput"><span class="identifier">T</span></code> 的对象，<code class="computeroutput"><a class="link" href="../boost/intrusive/list.html" title="Class template list">boost::intrusive::list&lt;T&gt;</a></code>
可以替代 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>，
以避免内存分配的开销，在用户希望容器保存多态值或者想在多个容器间共享保存的值时，则可以替代 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">*&gt;</span></code>。
因为这种多功能性，以下的性能测试将对6种不同的链表类型进行测试： </p>
<div class="itemizedlist">
<ul type="disc">
<li> 3 intrusive lists holding a class named <code class="computeroutput"><span class="identifier">itest_class</span></code>,
each one with a different linking policy (<code class="computeroutput"><span class="identifier">normal_link</span></code>,
<code class="computeroutput"><span class="identifier">safe_link</span></code>, <code class="computeroutput"><span class="identifier">auto_unlink</span></code>).
The <code class="computeroutput"><span class="identifier">itest_class</span></code>
objects will be tightly packed in a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">itest_class</span><span class="special">&gt;</span></code> object.<br>
3种保存名为 <code class="computeroutput"><span class="identifier">itest_class</span></code>
的类的介入式链表，每种具有不同的链接策略(<code class="computeroutput"><span class="identifier">normal_link</span></code>, <code class="computeroutput"><span class="identifier">safe_link</span></code>,
<code class="computeroutput"><span class="identifier">auto_unlink</span></code>)。所有
<code class="computeroutput"><span class="identifier">itest_class</span></code>
对象被紧密地压缩在一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">itest_class</span><span class="special">&gt;</span></code> 对象中。 </li>
<li>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">&gt;</span></code>, where <code class="computeroutput"><span class="identifier">test_class</span></code>
is exactly the same as <code class="computeroutput"><span class="identifier">itest_class</span></code>,
but without the intrusive hook.<br>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">&gt;</span></code>，其中 <code class="computeroutput"><span class="identifier">test_class</span></code>
与 <code class="computeroutput"><span class="identifier">itest_class</span></code>
相同，但没有介入式钩子。 </li>
<li>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">*&gt;</span></code>. The
list will contain pointers to <code class="computeroutput"><span class="identifier">test_class</span></code>
objects tightly packed in a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">&gt;</span></code> object.
We'll call this configuration <span class="emphasis"><em>compact
pointer list</em></span><br>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">*&gt;</span></code>。该链表将包含有指向
被紧密压缩在一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">&gt;</span></code> 对象中的 <code class="computeroutput"><span class="identifier">test_class</span></code>
对象的指针。我们把这一配置称为 <span class="emphasis"><em>紧凑指针链表</em></span>。
</li>
<li>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">*&gt;</span></code>. The
list will contain pointers to <code class="computeroutput"><span class="identifier">test_class</span></code>
objects owned by a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">&gt;</span></code> object.
We'll call this configuration <span class="emphasis"><em>disperse
pointer list</em></span>.<br>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">*&gt;</span></code>。该链表将包含有指向
被一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">test_class</span><span class="special">&gt;</span></code><code class="computeroutput"><span class="special"></span></code>
对象所拥有的 <code class="computeroutput"><span class="identifier">test_class</span></code>
对象的指针。我们把这一配置称为 <span class="emphasis"><em>松散指针链表</em></span>。
</li>
</ul>
</div>
<p> Both <code class="computeroutput"><span class="identifier">test_class</span></code> and <code class="computeroutput"><span class="identifier">itest_class</span></code>
are templatized classes that can be configured with a boolean to
increase the size of the object. This way, the tests can be executed
with small and big objects. Here is the first part of the testing code,
which shows the definitions of <code class="computeroutput"><span class="identifier">test_class</span></code> and <code class="computeroutput"><span class="identifier">itest_class</span></code>
classes, and some other utilities:<br>
<code class="computeroutput"><span class="identifier">test_class</span></code>
和 <code class="computeroutput"><span class="identifier">itest_class</span></code>
都是模板化类，它们可以用一个布尔值来配置以增加对象的大小。这样，测试可以分别对小对象和大对象执行。以下是测试代码的开始部分，展示了 <code class="computeroutput"><span class="identifier">test_class</span></code>
和 <code class="computeroutput"><span class="identifier">itest_class</span></code>
类的定义，以及一些其它工具：</p>
<pre class="programlisting"><span class="comment">//Iteration and element count defines 循环次数和元素数量定义<br></span><span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">NumIter</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span><br><span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">NumElements</span> <span class="special">=</span> <span class="number">50000</span><span class="special">;</span><br><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">BigSize</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">filler</span> <span class="special">{</span> <span class="keyword">int</span> <span class="identifier">dummy</span><span class="special">[</span><span class="number">10</span><span class="special">];</span> <span class="special">};</span><br><span class="keyword">template</span> <span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">filler</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span> <span class="special">{};</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">BigSize</span><span class="special">&gt;</span> <span class="comment">//The object for non-intrusive containers 用于非介入式容器的对象<br></span><span class="keyword">struct</span> <span class="identifier">test_class</span> <span class="special">:</span> <span class="keyword">private</span> <span class="identifier">filler</span><span class="special">&lt;</span><span class="identifier">BigSize</span><span class="special">&gt;</span><br><span class="special">{</span><br><span class="keyword">int</span> <span class="identifier">i_</span><span class="special">;</span><br><span class="identifier">test_class</span><span class="special">()</span> <span class="special">{}</span><br><span class="identifier">test_class</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">i_</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{}</span><br><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">test_class</span> <span class="special">&amp;</span><span class="identifier">l</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">test_class</span> <span class="special">&amp;</span><span class="identifier">r</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">l</span><span class="special">.</span><span class="identifier">i_</span> <span class="special">&lt;</span> <span class="identifier">r</span><span class="special">.</span><span class="identifier">i_</span><span class="special">;</span> <span class="special">}</span><br><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">&gt;(</span><span class="keyword">const</span> <span class="identifier">test_class</span> <span class="special">&amp;</span><span class="identifier">l</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">test_class</span> <span class="special">&amp;</span><span class="identifier">r</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">l</span><span class="special">.</span><span class="identifier">i_</span> <span class="special">&gt;</span> <span class="identifier">r</span><span class="special">.</span><span class="identifier">i_</span><span class="special">;</span> <span class="special">}</span><br><span class="special">};</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">BigSize</span><span class="special">,</span> <span class="identifier">link_mode_type</span> <span class="identifier">LinkMode</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">itest_class</span> <span class="comment">//The object for intrusive containers 用于介入式容器的对象<br></span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">list_base_hook</span><span class="special">&lt;</span><span class="identifier">link_mode</span><span class="special">&lt;</span><span class="identifier">LinkMode</span><span class="special">&gt;</span> <span class="special">&gt;,</span> <span class="keyword">public</span> <span class="identifier">test_class</span><span class="special">&lt;</span><span class="identifier">BigSize</span><span class="special">&gt;</span><br><span class="special">{</span><br><span class="identifier">itest_class</span><span class="special">()</span> <span class="special">{}</span><br><span class="identifier">itest_class</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">test_class</span><span class="special">&lt;</span><span class="identifier">BigSize</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{}</span><br><span class="special">};</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">FuncObj</span><span class="special">&gt;</span> <span class="comment">//Adapts functors taking values to functors taking pointers 将接受值的仿函数适配为接受指针的仿函数<br></span><span class="keyword">struct</span> <span class="identifier">func_ptr_adaptor</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">FuncObj</span><br><span class="special">{</span><br><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">FuncObj</span><span class="special">::</span><span class="identifier">first_argument_type</span><span class="special">*</span> <span class="identifier">first_argument_type</span><span class="special">;</span><br><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">FuncObj</span><span class="special">::</span><span class="identifier">second_argument_type</span><span class="special">*</span> <span class="identifier">second_argument_type</span><span class="special">;</span><br><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">FuncObj</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">result_type</span><span class="special">;</span><br><span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">first_argument_type</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">second_argument_type</span> <span class="identifier">b</span><span class="special">)</span> <span class="keyword">const</span><br><span class="special">{</span> <span class="keyword">return</span> <span class="identifier">FuncObj</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()(*</span><span class="identifier">a</span><span class="special">,</span> <span class="special">*</span><span class="identifier">b</span><span class="special">);</span> <span class="special">}</span><br><span class="special">};</span>
</pre>
<p> As we can see, <code class="computeroutput"><span class="identifier">test_class</span></code> is a
very simple class holding an <code class="computeroutput"><span class="keyword">int</span></code>. <code class="computeroutput"><span class="identifier">itest_class</span></code>
is just a class that has a base hook (<code class="computeroutput"><a class="link" href="../boost/intrusive/list_base_hook.html" title="Class template list_base_hook">list_base_hook</a></code>)
and also derives from <code class="computeroutput"><span class="identifier">test_class</span></code>.<br>
正如我们看到的，<code class="computeroutput"><span class="identifier">test_class</span></code>
是一个非常简单的类，它持有一个 <code class="computeroutput"><span class="keyword">int</span></code>。<code class="computeroutput"><span class="identifier">itest_class</span></code>
则只是一个带有基类钩子(<code class="computeroutput"><a class="link" href="../boost/intrusive/list_base_hook.html" title="Class template list_base_hook">list_base_hook</a></code>)
且派生自 <code class="computeroutput"><span class="identifier">test_class</span></code> 的类。 </p>
<p> <code class="computeroutput"><span class="identifier">func_ptr_adaptor</span></code>
is just a functor adaptor to convert function objects taking <code class="computeroutput"><span class="identifier">test_list</span></code>
objects to function objects taking pointers to them.<br>
<code class="computeroutput"><span class="identifier">func_ptr_adaptor</span></code>
是一个函数对象适配器，将一个接受 <code class="computeroutput"><span class="identifier">test_list</span></code>
对象的函数对象转换为接受对象指针的函数对象。 </p>
<p> You can find the full test code code in the <a href="../../../libs/intrusive/perf/perf_list.cpp" target="_top">perf_list.cpp</a>
source file.<br>
你可以在 <a href="../../../libs/intrusive/perf/perf_list.cpp" target="_top">perf_list.cpp</a> 源文件中找到完整的测试代码。 </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="intrusive.performance.performance_results_push_back"></a><a class="link" href="performance.html#intrusive.performance.performance_results_push_back" title="Back insertion and destruction"> Back insertion and
destruction 后端插入和析构</a>
</h3>
</div>
</div>
</div>
<p> The first test will measure the benefits we can obtain with
intrusive containers avoiding memory allocations and deallocations. All
the objects to be inserted in intrusive containers are allocated in a
single allocation call, whereas <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code> will need
to allocate memory for each object and deallocate it for every erasure
(or container destruction).<br>
第一个测试将测量由于介入式容器避免了内存分配和释放而获得的优势。所有被插入到介入式容器中的对象都是在一次内存分配调用中分配的，而 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>
则需要为每一个对象分配一次内存，并为每一次删除(或是容器的析构)释放一次内存。 </p>
<p> Let's compare the code to be executed for each container type
for different insertion tests:<br>
我们来比较一下对于各种容器类型、对于各种不同的插入测试所要执行的代码：</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ilist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;</span> <span class="identifier">objects</span><span class="special">(</span><span class="identifier">NumElements</span><span class="special">);</span><br><span class="identifier">ilist</span> <span class="identifier">l</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">NumElements</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">objects</span><span class="special">[</span><span class="identifier">i</span><span class="special">]);</span><br><span class="comment">//Elements are unlinked in ilist's destructor 在 ilist 的析构函数中，元素被断链<br></span><span class="comment">//Elements are destroyed in vector's destructor 在 vector 的析构函数中，元素被销毁<br></span></pre>
<p> For intrusive containers, all the values are created in a
vector and after that inserted in the intrusive list.<br>
对于介入式容器，所有值在一个 vector 中创建，稍后被插入到介入式链表中。</p>
<pre class="programlisting"><span class="identifier">stdlist</span> <span class="identifier">l</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">NumElements</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span><br><span class="comment">//Elements unlinked and destroyed in stdlist's destructor </span><span class="comment">在 stdlist 的析构函数中，元素被断链</span><span class="comment">并销毁 </span></pre>
<p> For a standard list, elements are pushed back using
push_back().<br>
对于标准 list，使用 push_back() 将元素插入到后端。</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;</span> <span class="identifier">objects</span><span class="special">(</span><span class="identifier">NumElements</span><span class="special">);</span><br><span class="identifier">stdptrlist</span> <span class="identifier">l</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">NumElements</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(&amp;</span><span class="identifier">objects</span><span class="special">[</span><span class="identifier">i</span><span class="special">]);</span><br><span class="comment">//Pointers to elements unlinked and destroyed in stdptrlist's destructor<br>//</span><span class="comment">在 stdptrlist 的析构函数中，元素指针被断链</span><span class="comment">并销毁</span><span class="comment"><br></span><span class="comment">//Elements destroyed in vector's destructor </span><span class="comment">在 vector 的析构函数中，元素被销毁</span><span class="comment"><br></span></pre>
<p> For a standard compact pointer list, elements are created in
a vector and pushed back in the pointer list using push_back().<br>
对于标准的紧凑指针链表，元素在一个 vector 中创建，并用 push_back() 插入到指针链表的后端。</p>
<pre class="programlisting"><span class="identifier">stdlist</span> <span class="identifier">objects</span><span class="special">;</span> <span class="identifier">stdptrlist</span> <span class="identifier">l</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">NumElements</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">){</span><br><span class="identifier">objects</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(&amp;</span><span class="identifier">objects</span><span class="special">.</span><span class="identifier">back</span><span class="special">());</span><br><span class="special">}</span><br><span class="comment">//Pointers to elements unlinked and destroyed in stdptrlist's destructor</span><br><span class="comment">//</span><span class="comment">在 stdptrlist 的析构函数中，元素指针被断链</span><span class="comment">并销毁<br></span><span class="comment">//Elements unlinked and destroyed in stdlist's destructor </span><span class="comment"></span><span class="comment">在 stdlist 的析构函数中，元素被断链并销毁</span><span class="comment"><br></span></pre>
<p> For a <span class="emphasis"><em>disperse
pointer list</em></span>, elements are created in a list
and pushed back in the pointer list using push_back().<br>
对于 <span class="emphasis"><em>松散指针链表</em></span>，
元素在一个 list 中创建，并用 push_back() 插入到指针链表的后端。 </p>
<p> These are the times in microseconds for each case, and the
normalized time:<br>
以下是在各种情况下测试得到的毫秒时间，以及规格化时间： </p>
<div class="table">
<a name="id3235144"></a>
<p class="title"><b>Table&nbsp;10.2.&nbsp;Back
insertion + destruction times for Visual C++ 7.1 / Windows XP<br>
表&nbsp;10.2. 后端插入 + 析构的时间，Visual C++ 7.1 / Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Back insertion + destruction times for Visual C++
7.1 / Windows XP">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> Container</p>
<p>容器 </p>
</th>
<th>
<p> Time in us/iteration (small object / big object)</p>
<p>毫秒/次循环 (小对象/大对象) </p>
</th>
<th>
<p> Normalized time (small object / big object)</p>
<p>规格化时间 (小对象/大对象) </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">normal_link</span></code>
介入式链表 </p>
</td>
<td>
<p> 5000 / 22500 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">safe_link</span></code> 介入式链表
</p>
</td>
<td>
<p> 7812 / 32187 </p>
</td>
<td>
<p> 1.56 / 1.43 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">auto_unlink</span></code>
介入式链表 </p>
</td>
<td>
<p> 10156 / 41562 </p>
</td>
<td>
<p> 2.03 / 1.84 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list</p>
<p>标准链表 </p>
</td>
<td>
<p> 76875 / 97500 </p>
</td>
<td>
<p> 5.37 / 4.33 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list</p>
<p>标准的紧凑指针链表 </p>
</td>
<td>
<p> 76406 / 86718 </p>
</td>
<td>
<p> 15.28 / 3.85 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list</p>
<p>标准的松散指针链表 </p>
</td>
<td>
<p> 146562 / 175625 </p>
</td>
<td>
<p> 29.31 / 7.80 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3235353"></a>
<p class="title"><b>Table&nbsp;10.3.&nbsp;Back
insertion + destruction times for GCC 4.1.1 / MinGW over Windows XP<br>
表&nbsp;10.3</b><b>. 后端插入 + 析构的时间，</b><b>GCC
4.1.1 / MinGW 于 Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Back insertion + destruction times for
GCC 4.1.1 / MinGW over Windows XP">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> Container</p>
<p>容器<br>
</p>
</th>
<th>
<p> Time in us/iteration (small object / big object)</p>
<p>毫秒/次循环 (小对象/大对象)</p>
</th>
<th>
<p> Normalized time (small object / big object)</p>
<p>规格化时间 (小对象/大对象)</p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">normal_link</span></code>
介入式链表</p>
</td>
<td>
<p> 4375 / 22187 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">safe_link</span></code>&nbsp;
介
入式链表 </p>
</td>
<td>
<p> 7812 / 32812 </p>
</td>
<td>
<p> 1.78 / 1.47 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">auto_unlink</span></code>&nbsp;
介
入式链表 </p>
</td>
<td>
<p> 10468 / 42031 </p>
</td>
<td>
<p> 2.39 / 1.89 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list</p>
<p>标准链表 </p>
</td>
<td>
<p> 81250 / 98125 </p>
</td>
<td>
<p> 18.57 / 4.42 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list</p>
<p>标准的紧凑指针链表 </p>
</td>
<td>
<p> 83750 / 94218 </p>
</td>
<td>
<p> 19.14 / 4.24 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list</p>
<p>标准的松散指针链表 </p>
</td>
<td>
<p> 155625 / 175625 </p>
</td>
<td>
<p> 35.57 / 7.91 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3235562"></a>
<p class="title"><b>Table&nbsp;10.4.&nbsp;Back
insertion + destruction times for GCC 4.1.2 / Linux Kernel 2.6.18
(OpenSuse 10.2)</b><b><br>
表&nbsp;10.4</b><b>. 后端插入 + 析构的时间，</b><b>GCC
4.1.2 / Linux Kernel 2.6.18
(OpenSuse 10.2)</b></p>
<div class="table-contents">
<table class="table" summary="Back insertion + destruction times for
GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
<p> Container</p>
<p>容器<br>
</p>
</th>
<th>
<p> Time in us/iteration (small object / big object)</p>
<p>毫秒/次循环 (小对象/大对象)</p>
</th>
<th>
<p> Normalized time (small object / big object)</p>
<p>规格化时间 (小对象/大对象)</p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">normal_link</span></code>
介入式链表</p>
</td>
<td>
<p> 4792 / 20495 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">safe_link</span></code>&nbsp;
介
入式链表 </p>
</td>
<td>
<p> 7709 / 30803 </p>
</td>
<td>
<p> 1.60 / 1.5 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list</p>
<p><code class="computeroutput"><span class="identifier">auto_unlink</span></code>&nbsp;
介
入式链表 </p>
</td>
<td>
<p> 10180 / 41183 </p>
</td>
<td>
<p> 2.12 / 2.0 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list</p>
<p>标准链表 </p>
</td>
<td>
<p> 17031 / 32586 </p>
</td>
<td>
<p> 3.55 / 1.58 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list</p>
<p>标准的紧凑指针链表 </p>
</td>
<td>
<p> 27221 / 34823 </p>
</td>
<td>
<p> 5.68 / 1.69 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list</p>
<p>标准的松散指针链表 </p>
</td>
<td>
<p> 102272 / 60056 </p>
</td>
<td>
<p> 21.34 / 2.93 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> The results are logical: intrusive lists just need one
allocation. The destruction time of the <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive container is trivial (complexity: <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code>), whereas <code class="computeroutput"><span class="identifier">safe_link</span></code>
and <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive containers need to put the hooks of erased values in the
default state (complexity: <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">NumElements</span><span class="special">)</span></code>). That's why <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list shines in this test.<br>结果是符合逻辑的：介入式链表只需要一次内存分配。<code class="computeroutput"><span class="identifier">normal_link</span></code> 介入式容器的析构时间是平凡的(复杂度：<code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code>)，而 <code class="computeroutput"><span class="identifier">safe_link</span></code> 和 <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
介入式容器则需要将被移除值的钩子设置为缺省状态(复杂度：<code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">NumElements</span><span class="special">)</span></code>)。这正是 <code class="computeroutput"><span class="identifier">normal_link</span></code>
介入式链表在这个测试中胜出的原因。 </p>
<p> Non-intrusive containers need to make many more allocations
and that's why they lag behind. The <code class="computeroutput"><span class="identifier">disperse</span> <span class="identifier">pointer</span> <span class="identifier">list</span></code> needs to
make <code class="computeroutput"><span class="identifier">NumElements</span><span class="special">*</span><span class="number">2</span></code>
allocations, so the result is not surprising.<br>非介入式容器需要进行多次的内存分配，这正是它们落在后面的原因。<code class="computeroutput"><span class="identifier">disperse</span> <span class="identifier">pointer</span> <span class="identifier">list</span></code> 需要进行 <code class="computeroutput"><span class="identifier">NumElements</span><span class="special">*</span><span class="number">2</span></code>
次分配，所以结果并不意外。 </p>
<p> The Linux test shows that standard containers perform very
well against intrusive containers with big objects. Nearly the same GCC
version in MinGW performs worse, so maybe a good memory allocator is
the reason for these excellent results.<br>Linux 上的测试显示，对于大的对象，标准容器和介入式容器一样好。而在 MinGW 平台上的相近版本的 GCC 则较差，因此也许一个好的内存分配器是这一卓越结果的原因。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="intrusive.performance.performance_results_reversing"></a><a class="link" href="performance.html#intrusive.performance.performance_results_reversing" title="Reversing"> Reversing 反序</a>
</h3>
</div>
</div>
</div>
<p> The next test measures the time needed to complete calls to
the member function <code class="computeroutput"><span class="identifier">reverse</span><span class="special">()</span></code>. Values (<code class="computeroutput"><span class="identifier">test_class</span></code>
and <code class="computeroutput"><span class="identifier">itest_class</span></code>)
and lists are created as explained in the previous section.<br>下一个测试测量完成对成员函数 <code class="computeroutput"><span class="identifier">reverse</span><span class="special">()</span></code> 的调用所需的时间。值(<code class="computeroutput"><span class="identifier">test_class</span></code> 和 <code class="computeroutput"><span class="identifier">itest_class</span></code>)和链表同样是按上一节所说的那样创建。 </p>
<p> Note that for pointer lists, <code class="computeroutput"><span class="identifier">reverse</span></code> <span class="bold"><strong>does not need to access <code class="computeroutput"><span class="identifier">test_class</span></code>
values stored in another list or vector</strong></span>,
since this function just needs to adjust internal pointers, so in
theory all tested lists need to perform the same operations.<br>注意，对于指针链表，<code class="computeroutput"><span class="identifier">reverse</span></code> <span class="bold"><strong>并不需要访问保存在另一个 list 或 vector 中的 <code class="computeroutput"><span class="identifier">test_class</span></code>
值</strong></span>，因为该函数只需调整内部的指针，所以理论上所有被测试的链表都只需完成相同的操作。 </p>
<p> These are the results:<br>结果如下： </p>
<div class="table">
<a name="id3236008"></a>
<p class="title"><b>Table&nbsp;10.5.&nbsp;Reverse
times for Visual C++ 7.1 / Windows XP<br>表&nbsp;10.5. 反序时间，Visual C++ 7.1 / Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Reverse times for Visual C++ 7.1 / Windows XP">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2656 / 10625 </p>
</td>
<td>
<p> 1 / 1.83 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2812 / 10937 </p>
</td>
<td>
<p> 1.05 / 1.89 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 2710 / 10781 </p>
</td>
<td>
<p> 1.02 / 1.86 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 5781 / 14531 </p>
</td>
<td>
<p> 2.17 / 2.51 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 5781 / 5781 </p>
</td>
<td>
<p> 2.17 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 10781 / 15781 </p>
</td>
<td>
<p> 4.05 / 2.72 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3236216"></a>
<p class="title"><b>Table&nbsp;10.6.&nbsp;Reverse
times for GCC 4.1.1 / MinGW over Windows XP</b><b><br>表&nbsp;10.6. 反序时间，</b><b>GCC 4.1.1 / MinGW 于 Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Reverse times for GCC 4.1.1 / MinGW over
Windows XP">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2656 / 10781 </p>
</td>
<td>
<p> 1 / 2.22 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2656 / 10781 </p>
</td>
<td>
<p> 1 / 2.22 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 2812 / 10781 </p>
</td>
<td>
<p> 1.02 / 2.22 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 4843 / 12500 </p>
</td>
<td>
<p> 1.82 / 2.58 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 4843 / 4843 </p>
</td>
<td>
<p> 1.82 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 9218 / 12968 </p>
</td>
<td>
<p> 3.47 / 2.67 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3236425"></a>
<p class="title"><b>Table&nbsp;10.7.&nbsp;Reverse
times for GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)</b><b><br>表&nbsp;10.7. 反序时间，</b><b>GCC 4.1.</b><b>2 / Linux Kernel 2.6.18 (OpenSuse 10.2)</b></p>
<div class="table-contents">
<table class="table" summary="Reverse times for GCC 4.1.2 / Linux Kernel
2.6.18 (OpenSuse 10.2)">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2742 / 10847 </p>
</td>
<td>
<p> 1 / 3.41 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2742 / 10847 </p>
</td>
<td>
<p> 1 / 3.41 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 2742 / 11027 </p>
</td>
<td>
<p> 1 / 3.47 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 3184 / 10942 </p>
</td>
<td>
<p> 1.16 / 3.44 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 3207 / 3176 </p>
</td>
<td>
<p> 1.16 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 5814 / 13381 </p>
</td>
<td>
<p> 2.12 / 4.21 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">

<p> For small objects the results show that the compact storage
of values in intrusive containers improve locality and reversing is
faster than with standard containers, whose values might be dispersed
in memory because each value is independently allocated. Note that the
dispersed pointer list (a list of pointers to values allocated in
another list) suffers more because nodes of the pointer list might be
more dispersed, since allocations from both lists are interleaved in
the code:<br>对
于小对象，介入式容器中的值的紧凑存储提高了局部性，其反序操作比标准容器快一些，标准容器的值可能会松散分布在内存中，因为它的每一个值都是独立分配
的。注意，松散指针链表(其值在另一个 list 中分配的指针链表)更差一些，因为该指针链表的节点可能更加分散，在代码中的两个链表的分配是交错的：</p>
<pre class="programlisting"><span class="comment">//Object list (holding `test_class`) 对象链表(保存 `test_class`)<br></span><span class="identifier">stdlist</span> <span class="identifier">objects</span><span class="special">;</span><br><span class="comment">//Pointer list (holding `test_class` pointers) 指针链表(保存 `test_class` 指针)<br></span><span class="identifier">stdptrlist</span> <span class="identifier">l</span><span class="special">;</span><br><span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">NumElements</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">){</span><br><span class="comment">//Allocation from the object list 从对象链表分配<br></span> <span class="identifier">objects</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span><br><span class="comment">//Allocation from the pointer list 从指针链表分配<br></span> <span class="identifier">l</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(&amp;</span><span class="identifier">objects</span><span class="special">.</span><span class="identifier">back</span><span class="special">());</span><br><span class="special">}</span>
</pre>
<p> For big objects the compact pointer list wins because the
reversal test doesn't need access to values stored in another
container. Since all the allocations for nodes of this pointer list are
likely to be close (since there is no other allocation in the process
until the pointer list is created) locality is better than with
intrusive containers. The dispersed pointer list, as with small values,
has poor locality.<br>对于大对象，紧凑指针链表胜出，因为反序测试无需访问保存在另一个容器中的值。由于这个指针链表的节点的所有分配可能非常靠近(因为在该指针链表创建完成之前没有其它的分配)，其局部性比介入式容器更好。和小对象的情况一样，松散指针链表具有较差的局部性。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="intrusive.performance.performance_results_sorting"></a><a class="link" href="performance.html#intrusive.performance.performance_results_sorting" title="Sorting"> Sorting 排序</a>
</h3>
</div>
</div>
</div>

<p> The next test measures the time needed to complete calls to
the member function <code class="computeroutput"><span class="identifier">sort</span><span class="special">(</span><span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">)</span></code>.
Values (<code class="computeroutput"><span class="identifier">test_class</span></code> and <code class="computeroutput"><span class="identifier">itest_class</span></code>)
and lists are created as explained in the first section. The values
will be sorted in ascending and descenting order each iteration. For
example, if <span class="emphasis"><em>l</em></span>
is a list:<br>下一个测试测量完成对成员函数 <code class="computeroutput"><span class="identifier">sort</span><span class="special">(</span><span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">)</span></code> 的调用所需的时间。值(<code class="computeroutput"><span class="identifier">test_class</span></code> 和 <code class="computeroutput"><span class="identifier">itest_class</span></code>)和链表同样是按第一节所说的那样创建。在每次循环中，这些值将以升序和降序排序。例如，如果 <span class="emphasis"><em>l</em></span>
为一个链表：</p>
<pre class="programlisting"><span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">NumIter</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">){</span><br><span class="keyword">if</span><span class="special">(!(</span><span class="identifier">i</span> <span class="special">%</span> <span class="number">2</span><span class="special">))</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">sort</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;</span><span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;());</span><br><span class="keyword">else</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">sort</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;());</span><br><span class="special">}</span>
</pre>

<p> For a pointer list, the function object will be adapted using
<code class="computeroutput"><span class="identifier">func_ptr_adaptor</span></code>:<br>对于指针链表，将使用
<code class="computeroutput"><span class="identifier">func_ptr_adaptor</span></code> 对函数对象进行适配：</p>
<pre class="programlisting"><span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">NumIter</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">){</span><br><span class="keyword">if</span><span class="special">(!(</span><span class="identifier">i</span> <span class="special">%</span> <span class="number">2</span><span class="special">))</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">sort</span><span class="special">(</span><span class="identifier">func_ptr_adaptor</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;</span><span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;</span> <span class="special">&gt;());</span><br><span class="keyword">else</span><br><span class="identifier">l</span><span class="special">.</span><span class="identifier">sort</span><span class="special">(</span><span class="identifier">func_ptr_adaptor</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;</span> <span class="special">&gt;());</span><br><span class="special">}</span>
</pre>
<p> Note that for pointer lists, <code class="computeroutput"><span class="identifier">sort</span></code> will take
a function object that <span class="bold"><strong>will
access <code class="computeroutput"><span class="identifier">test_class</span></code>
values stored in another list or vector</strong></span>, so
pointer lists will suffer an extra indirection: they will need to
access the <code class="computeroutput"><span class="identifier">test_class</span></code>
values stored in another container to compare two elements.<br>注意，对于指针链表，<code class="computeroutput"><span class="identifier">sort</span></code> 将接受一个<span class="bold"><strong>要访问保存在另一个 list 或 vector 中的 <code class="computeroutput"><span class="identifier">test_class</span></code>
值</strong></span>的函数对象，所以指针链表需要多一个间接层：它们需要访问保存在另一个容器中的 <code class="computeroutput"><span class="identifier">test_class</span></code>
值来比较两个元素。 </p>
<p> These are the results:<br>结果如下： </p>
<div class="table">
<a name="id3237506"></a>
<p class="title"><b>Table&nbsp;10.8.&nbsp;Sort
times for Visual C++ 7.1 / Windows XP</b><b><br>表&nbsp;10.8. 排序时间，Visual C++ 7.1 / Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Sort times for Visual C++ 7.1 / Windows XP">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 16093 / 38906 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 16093 / 39062 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 16093 / 38906 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 32343 / 56406 </p>
</td>
<td>
<p> 2.0 / 1.44 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 33593 / 46093 </p>
</td>
<td>
<p> 2.08 / 1.18 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 46875 / 68593 </p>
</td>
<td>
<p> 2.91 / 1.76 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3237714"></a>
<p class="title"><b>Table&nbsp;10.9.&nbsp;Sort
times for GCC 4.1.1 / MinGW over Windows XP</b><b><br>表&nbsp;10.9. 排序时间，</b><b>GCC 4.1.1 / MinGW 于 Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Sort times for GCC 4.1.1 / MinGW over Windows
XP">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 15000 / 39218 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 15156 / 39531 </p>
</td>
<td>
<p> 1.01 / 1.01 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 15156 / 39531 </p>
</td>
<td>
<p> 1.01 / 1.01 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 34218 / 56875 </p>
</td>
<td>
<p> 2.28 / 1.45 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 35468 / 49218 </p>
</td>
<td>
<p> 2.36 / 1.25 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 47656 / 70156 </p>
</td>
<td>
<p> 3.17 / 1.78 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3237923"></a>
<p class="title"><b>Table&nbsp;10.10.&nbsp;Sort
times for GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)</b><b><br>表&nbsp;10.10. 排序时间，</b><b>GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)</b></p>
<div class="table-contents">
<table class="table" summary="Sort times for GCC 4.1.2 / Linux Kernel
2.6.18 (OpenSuse 10.2)">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 18003 / 40795 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 18003 / 41017 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 18230 / 40941 </p>
</td>
<td>
<p> 1.01 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 26273 / 49643 </p>
</td>
<td>
<p> 1.45 / 1.21 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 28540 / 43172 </p>
</td>
<td>
<p> 1.58 / 1.05 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 35077 / 57638 </p>
</td>
<td>
<p> 1.94 / 1.41 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> The results show that intrusive containers are faster than
standard containers. We can see that the pointer list holding pointers
to values stored in a vector is quite fast, so the extra indirection
that is needed to access the value is minimized because all the values
are tightly stored, improving caching. The disperse list, on the other
hand, is slower because the indirection to access values stored in the
object list is more expensive than accessing values stored in a vector.<br>结
果显示，介入式容器快于标准容器。我们可以看到，持有保存在 vector
的值的指针的指针链表速度很快，访问值时所需的额外间接性是最小的，因为所有的值被紧密保存，这提升了缓存的作用。另一方面，松散链表较慢，因为访问保存
在 list 中的值的间接性要比访问保存在 vector 中值耗费更多。
</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="intrusive.performance.performance_results_write_access"></a><a class="link" href="performance.html#intrusive.performance.performance_results_write_access" title="Write access"> Write access 写访问</a>
</h3>
</div>
</div>
</div>

<p> The next test measures the time needed to iterate through all
the elements of a list, and increment the value of the internal <code class="computeroutput"><span class="identifier">i_</span></code>
member:<br>下一个测试测量遍历一个链表中所有元素所需的时间，并将内部的 <code class="computeroutput"><span class="identifier">i_</span></code>
成员的值加一：</p>
<pre class="programlisting"><span class="identifier">stdlist</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">l</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span> <span class="identifier">end</span><span class="special">(</span><span class="identifier">l</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span><br><span class="keyword">for</span><span class="special">(;</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span><br><span class="special">++(</span><span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">i_</span><span class="special">);</span>
</pre>

<p> Values (<code class="computeroutput"><span class="identifier">test_class</span></code> and <code class="computeroutput"><span class="identifier">itest_class</span></code>)
and lists are created as explained in the first section. Note that for
pointer lists, the iteration will suffer an extra indirection: they
will need to access the <code class="computeroutput"><span class="identifier">test_class</span></code>
values stored in another container:<br>值(<code class="computeroutput"><span class="identifier">test_class</span></code> 和 <code class="computeroutput"><span class="identifier">itest_class</span></code>)和链表同样是按第一节所说的那样创建。注意，对于指针链表，<code class="computeroutput"><span class="identifier"></span></code>遍历操作需要<span class="bold"><strong></strong></span>多一个间接层：它们需要访问保存在另一个容器中的 <code class="computeroutput"><span class="identifier">test_class</span></code>
值：</p>
<pre class="programlisting"><span class="identifier">stdptrlist</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">l</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span> <span class="identifier">end</span><span class="special">(</span><span class="identifier">l</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span><br><span class="keyword">for</span><span class="special">(;</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span><br><span class="special">++((*</span><span class="identifier">it</span><span class="special">)-&gt;</span><span class="identifier">i_</span><span class="special">);</span>
</pre>
<p> These are the results:<br>结果如下： </p>
<div class="table">
<a name="id3238511"></a>
<p class="title"><b>Table&nbsp;10.11.&nbsp;Write
access times for Visual C++ 7.1 / Windows XP</b><b><br>表&nbsp;10.11. 写访问时间，Visual C++ 7.1 / Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Write access times for Visual C++ 7.1 / Windows
XP">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2031 / 8125 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2031 / 8281 </p>
</td>
<td>
<p> 1 / 1.01 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 2031 / 8281 </p>
</td>
<td>
<p> 1 / 1.01 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 4218 / 10000 </p>
</td>
<td>
<p> 2.07 / 1.23 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 4062 / 8437 </p>
</td>
<td>
<p> 2.0 / 1.03 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 8593 / 13125 </p>
</td>
<td>
<p> 4.23 / 1.61 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3238720"></a>
<p class="title"><b>Table&nbsp;10.12.&nbsp;Write
access times for GCC 4.1.1 / MinGW over Windows XP</b><b><br>表&nbsp;10.12. 写访问时间，</b><b>GCC 4.1.1 / MinGW 于 Windows XP</b></p>
<div class="table-contents">
<table class="table" summary="Write access times for GCC 4.1.1 / MinGW
over Windows XP">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2343 / 8281 </p>
</td>
<td>
<p> 1 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2500 / 8281 </p>
</td>
<td>
<p> 1.06 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 2500 / 8281 </p>
</td>
<td>
<p> 1.06 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 4218 / 10781 </p>
</td>
<td>
<p> 1.8 / 1.3 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 3906 / 8281 </p>
</td>
<td>
<p> 1.66 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 8281 / 13750 </p>
</td>
<td>
<p> 3.53 / 1.66 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<div class="table"><a name="id3238928"></a>
<p class="title"><b>Table&nbsp;10.13.&nbsp;Write
access times for GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)</b><b><br>表&nbsp;10.13. 写访问时间，</b><b>GCC 4.1.</b><b>2 / Linux Kernel 2.6.18 (OpenSuse 10.2)</b></p>
<div class="table-contents">
<table class="table" summary="Write access times for GCC 4.1.2 / Linux
Kernel 2.6.18 (OpenSuse 10.2)">
<colgroup><col><col><col></colgroup>
<thead><tr><th>

<p> Container<br>容器<br>
</p>
</th><th>

<p> Time in us/iteration (small object / big object)<br>毫秒/次循环 (小对象/大对象)</p>
</th><th>

<p> Normalized time (small object / big object)<br>规格化时间 (小对象/大对象)</p>
</th></tr>
</thead><tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">normal_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2286 / 8468 </p>
</td>
<td>
<p> 1 / 1.1 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">safe_link</span></code>
intrusive list </p>
</td>
<td>
<p> 2381 / 8412 </p>
</td>
<td>
<p> 1.04 / 1.09 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">auto_unlink</span></code>
intrusive list </p>
</td>
<td>
<p> 2301 / 8437 </p>
</td>
<td>
<p> 1.01 / 1.1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard list </p>
</td>
<td>
<p> 3044 / 9061 </p>
</td>
<td>
<p> 1.33 / 1.18 </p>
</td>
</tr>
<tr>
<td>
<p> Standard compact pointer list </p>
</td>
<td>
<p> 2755 / 7660 </p>
</td>
<td>
<p> 1.20 / 1 </p>
</td>
</tr>
<tr>
<td>
<p> Standard disperse pointer list </p>
</td>
<td>
<p> 6118 / 12453 </p>
</td>
<td>
<p> 2.67 / 1.62 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<br class="table-break">
<p> As with the read access test, the results show that intrusive
containers outperform all other containers if the values are tightly
packed in a vector. The disperse list is again the slowest.<br>和读访问测试一样，结果显示如果元素值是紧密压缩在一个 vector 中的话，介入式容器要比所有其它容器都好。松散链表又一次成为最慢的。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="intrusive.performance.performance_results_conclusions"></a><a class="link" href="performance.html#intrusive.performance.performance_results_conclusions" title="Conclusions"> Conclusions&nbsp;结论</a>
</h3>
</div>
</div>
</div>
<p> Intrusive containers can offer performance benefits that can
not be achieved with equivalent non-intrusive containers. Memory
locality improvements are noticeable when the objects to be inserted
are small. Minimizing memory allocation/deallocation calls is also an
important factor and intrusive containers make this simple if the user
allocates all the objects to be inserted in intrusive containers in
containers like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span></code>.<br>介入式容器可以提供对等的非介入式容器不能实现的性能优势。当插入的对象较小时，内存局部性的提升是显著的。内存分配和释放调用的次数最小化也是一个重要的因素，如果用户将要插入到介入式容器中的所有对象分配到一个象 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> 或 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span></code> 的容器中，那么介入式容器就很简单了。
</p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%">
<tbody>
<tr>
<td align="left"></td>
<td align="right">
<div class="copyright-footer">Copyright © 2005 Olaf
Krzikalla, 2006-2007 Ion Gaztañaga
<p> Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>
</div>
</td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="design_notes.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="release_notes.html"><img src="../../../doc/html/images/next.png" alt="Next"></a></div>
</body></html>
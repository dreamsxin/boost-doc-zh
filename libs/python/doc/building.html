<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Boost C++ Libraries: Boost.Python Build and Test HOWTO</title>
<link rel="stylesheet" href="../../../rst.css" type="text/css" />
</head>
<body>
<div class="document" id="logo-boost-python-build-and-test-howto">
<h1 class="title"><a class="reference external" href="../index.htm"><img alt="Boost C++ Libraries:" class="boost-logo" src="../../../boost.png" /></a> Boost.Python Build and Test HOWTO</h1>
<h1 class="title">Boost.Python构建与测试HOWTO</h1>

<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at -->
<!-- http://www.boost.org/LICENSE_1_0.txt) -->
<div class="contents sidebar small topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#requirements" id="id25">1&nbsp;&nbsp;&nbsp;Requirements</a></li>
<li><a class="reference internal" href="#background" id="id26">2&nbsp;&nbsp;&nbsp;Background</a></li>
<li><a class="reference internal" href="#no-install-quickstart" id="id27">3&nbsp;&nbsp;&nbsp;No-Install Quickstart</a><ul class="auto-toc">
<li><a class="reference internal" href="#basic-procedure" id="id28">3.1&nbsp;&nbsp;&nbsp;Basic Procedure</a></li>
<li><a class="reference internal" href="#in-case-of-trouble" id="id29">3.2&nbsp;&nbsp;&nbsp;In Case of Trouble</a></li>
<li><a class="reference internal" href="#in-case-everything-seemed-to-work" id="id30">3.3&nbsp;&nbsp;&nbsp;In Case Everything Seemed to Work</a></li>
<li><a class="reference internal" href="#modifying-the-example-project" id="id31">3.4&nbsp;&nbsp;&nbsp;Modifying the Example Project</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installing-boost-python-on-your-system" id="id32">4&nbsp;&nbsp;&nbsp;Installing Boost.Python on your System</a></li>
<li><a class="reference internal" href="#configuring-boost-build" id="id33">5&nbsp;&nbsp;&nbsp;Configuring Boost.Build</a><ul class="auto-toc">
<li><a class="reference internal" href="#python-configuration-parameters" id="id34">5.1&nbsp;&nbsp;&nbsp;Python Configuration Parameters</a></li>
<li><a class="reference internal" href="#examples" id="id35">5.2&nbsp;&nbsp;&nbsp;Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#choosing-a-boost-python-library-binary" id="id36">6&nbsp;&nbsp;&nbsp;Choosing a Boost.Python Library Binary</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-dynamic-binary" id="id37">6.1&nbsp;&nbsp;&nbsp;The Dynamic Binary</a></li>
<li><a class="reference internal" href="#the-static-binary" id="id38">6.2&nbsp;&nbsp;&nbsp;The Static Binary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#include-issues" id="id39">7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">#include</span></tt> Issues</a></li>
<li><a class="reference internal" href="#python-debugging-builds" id="id40">8&nbsp;&nbsp;&nbsp;Python Debugging Builds</a></li>
<li><a class="reference internal" href="#testing-boost-python" id="id41">9&nbsp;&nbsp;&nbsp;Testing Boost.Python</a></li>
<li><a class="reference internal" href="#notes-for-mingw-and-cygwin-with-mno-cygwin-gcc-users" id="id42">10&nbsp;&nbsp;&nbsp;Notes for MinGW (and Cygwin with -mno-cygwin) GCC Users</a></li>
</ul>
</div>

<div class="contents sidebar small topic" id="contents">
<p class="topic-title first">目录</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#requirements" id="id25">1&nbsp;&nbsp;&nbsp;要求</a></li>
<li><a class="reference internal" href="#background" id="id26">2&nbsp;&nbsp;&nbsp;背景</a></li>
<li><a class="reference internal" href="#no-install-quickstart" id="id27">3&nbsp;&nbsp;&nbsp;免安装快速入门</a><ul class="auto-toc">
<li><a class="reference internal" href="#basic-procedure" id="id28">3.1&nbsp;&nbsp;&nbsp;基本过程</a></li>
<li><a class="reference internal" href="#in-case-of-trouble" id="id29">3.2&nbsp;&nbsp;&nbsp;如果遇到问题</a></li>
<li><a class="reference internal" href="#in-case-everything-seemed-to-work" id="id30">3.3&nbsp;&nbsp;&nbsp;如果一切都好</a></li>
<li><a class="reference internal" href="#modifying-the-example-project" id="id31">3.4&nbsp;&nbsp;&nbsp;修改示例工程</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installing-boost-python-on-your-system" id="id32">4&nbsp;&nbsp;&nbsp;在系统上安装Boost.Python</a></li>
<li><a class="reference internal" href="#configuring-boost-build" id="id33">5&nbsp;&nbsp;&nbsp;配置Boost.Build</a><ul class="auto-toc">
<li><a class="reference internal" href="#python-configuration-parameters" id="id34">5.1&nbsp;&nbsp;&nbsp;Python配置参数</a></li>
<li><a class="reference internal" href="#examples" id="id35">5.2&nbsp;&nbsp;&nbsp;例子</a></li>
</ul>
</li>
<li><a class="reference internal" href="#choosing-a-boost-python-library-binary" id="id36">6&nbsp;&nbsp;&nbsp;选择Boost.Python二进制库</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-dynamic-binary" id="id37">6.1&nbsp;&nbsp;&nbsp;动态二进制</a></li>
<li><a class="reference internal" href="#the-static-binary" id="id38">6.2&nbsp;&nbsp;&nbsp;静态二进制</a></li>
</ul>
</li>
<li><a class="reference internal" href="#include-issues" id="id39">7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">#include</span></tt>问题</a></li>
<li><a class="reference internal" href="#python-debugging-builds" id="id40">8&nbsp;&nbsp;&nbsp;Python调试版</a></li>
<li><a class="reference internal" href="#testing-boost-python" id="id41">9&nbsp;&nbsp;&nbsp;测试Boost.Python</a></li>
<li><a class="reference internal" href="#notes-for-mingw-and-cygwin-with-mno-cygwin-gcc-users" id="id42">10&nbsp;&nbsp;&nbsp;MinGW（及Cygwin -mno-cygwin）上GCC用户注意事项</a></li>
</ul>
</div>

<div class="section" id="requirements">
<h1><a class="toc-backref" href="#id25">1&nbsp;&nbsp;&nbsp;Requirements</a></h1>

<h1><a class="toc-backref" href="#id25">1&nbsp;&nbsp;&nbsp;要求</a></h1>

<p>Boost.Python requires <a class="reference external" href="http://www.python.org/2.2">Python 2.2</a><a class="footnote-reference" href="#id22" id="id2"><sup>1</sup></a> <em>or</em> <a class="reference external" href="http://www.python.org"><em>newer</em></a>.</p>

<p>Boost.Python要求<a class="reference external" href="http://www.python.org/2.2">Python 2.2</a><a class="footnote-reference" href="#id22" id="id2"><sup>1</sup></a> <em>或</em> <a class="reference external" href="http://www.python.org"><em>更高版</em></a>。</p>

</div>

<div class="section" id="background">
<h1><a class="toc-backref" href="#id26">2&nbsp;&nbsp;&nbsp;Background</a></h1>

<h1><a class="toc-backref" href="#id26">2&nbsp;&nbsp;&nbsp;背景</a></h1>

<p>There are two basic models for combining C++ and Python:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.python.org/doc/current/ext/intro.html">extending</a>, in which the end-user launches the Python interpreter
executable and imports Python "extension modules" written in C++.
Think of taking a library written in C++ and giving it a Python
interface so Python programmers can use it.  From Python, these
modules look just like regular Python modules.</li>
<li><a class="reference external" href="http://www.python.org/doc/current/ext/embedding.html">embedding</a>, in which the end-user launches a program written
in C++ that in turn invokes the Python interpreter as a library
subroutine.  Think of adding scriptability to an existing
application.</li>
</ul>

<p>组合C++和Python有两种基本模式：</p>
<ul class="simple">
<li><a class="reference external" href="http://www.python.org/doc/current/ext/intro.html">扩展</a>：
最终用户运行Python解释器程序，并导入用C++编写的Python“扩展模块”。
想像一个C++写的库，给它一个Python接口，
这样Python程序员就可以使用它。
从Python来看，这些模块就像是常规的Python模块。</li>
<li><a class="reference external" href="http://www.python.org/doc/current/ext/embedding.html">内嵌</a>：
最终用户运行C++写的程序，反过来调用Python解释器，就像调用一个库函数。
想像一下为现有的应用程序加入脚本能力。</li>
</ul>

<p>The key distinction between extending and embedding is the location
of the C++ <tt class="docutils literal"><span class="pre">main()</span></tt> function: in the Python interpreter executable,
or in some other program, respectively.  Note that even when
embedding Python in another program, <a class="reference external" href="http://www.python.org/doc/current/ext/extending-with-embedding.html">extension modules are often
the best way to make C/C++ functionality accessible to Python
code</a>, so the use of extension modules is really at the heart of
both models.</p>

<p>
扩展和内嵌的关键性区别是，C++ 
 <tt class="docutils literal"><span class="pre">main()</span></tt>
函数的位置是在Python解释器程序中，
还是在其他程序中？ 
注意，即使是在程序中内嵌Python，
<a class="reference external" href="http://www.python.org/doc/current/ext/extending-with-embedding.html">扩展模块往往是Python代码利用C/C++功能最好的方式</a>，
所以，这两种模式实际上是以扩展模块的使用为中心的。
</p>

<p>Except in rare cases, extension modules are built as
dynamically-loaded libraries with a single entry point, which means
you can change them without rebuilding either the other extension
modules or the executable containing <tt class="docutils literal"><span class="pre">main()</span></tt>.</p>

<p>
除了极少数情况，
扩展模块是按具有单一入口点的动态库构建的，
这意味着，
你可以修改它们，
而不必重建其他扩展模块
或包含
<tt class="docutils literal"><span class="pre">main()</span></tt>
的执行程序。
</p>

</div>

<div class="section" id="no-install-quickstart">
<span id="quickstart"></span><h1><a class="toc-backref" href="#id27">3&nbsp;&nbsp;&nbsp;No-Install Quickstart</a></h1>

<h1><a class="toc-backref" href="#id27">3&nbsp;&nbsp;&nbsp;免安装快速入门</a></h1>

<p>There is no need to "install Boost" in order to get started using
Boost.Python.  These instructions use <a class="reference external" href="../../../tools/build/index.html">Boost.Build</a> projects,
which will build those binaries as soon as they're needed.  Your
first tests may take a little longer while you wait for
Boost.Python to build, but doing things this way will save you from
worrying about build intricacies like which library binaries to use
for a specific compiler configuration and figuring out the right
compiler options to use yourself.</p>

<p>
使用Boost.Python不需要“安装Boost”。
这里的教程利用了
<a class="reference external" href="../../../tools/build/index.html">Boost.Build</a>
项目，
它会在需要时自动构建那些二进制库。
你的第一个测试，可能需要较长的时间，
你需要等待Boost.Python的构建，
但这样做，让你不必担忧错综复杂的构建，
如，某个特定编译器配置该使用哪个二进制库，
也让你免于自己设置编译器选项。
</p>

<!-- .. raw:: html

<div style="width:50%"> -->
<div class="note">
<p class="first admonition-title">Note</p>

<p class="first admonition-title">注</p>

<p>Of course it's possible to use other build systems to
build Boost.Python and its extensions, but they are not
officially supported by Boost.  Moreover <strong>99% of all "I can't
build Boost.Python" problems come from trying to use another
build system</strong> without first following these instructions.</p>

<p>
当然，也可以使用其他的编译系统，
来构建Boost.Python及其扩展，
但它们不是Boost正式支持的。
所有<strong>“我无法编译Boost.Python”的问题，
99%以上是因为试图使用另一种编译系统</strong>，
而没有先按这个教程做。
</p>

<p>If you want to use another system anyway, we suggest that you
follow these instructions, and then invoke <tt class="docutils literal"><span class="pre">bjam</span></tt> with the</p>

<pre class="literal-block">
<tt class="docutils literal"><span class="pre">-a</span> <span class="pre">-o</span></tt><em>filename</em>
</pre>

<p class="last">options to dump the build commands it executes to a file, so
you can see what your alternate build system needs to do.</p>

<p>
如果你想使用另一个系统，
我们建议你先遵循这些指示，
然后用以下参数调用
<tt class="docutils literal"><span class="pre">bjam</span></tt>，
</p>

<pre class="literal-block">
<tt class="docutils literal"><span class="pre">-a</span> <span class="pre">-o</span></tt><em>filename</em>
</pre>

<p class="last">
来输出它对文件执行的构建命令，
这样你就可以看到你的编译系统需要做些什么。
</p>

</div>
<!-- .. raw:: html

</div> -->
<div class="section" id="basic-procedure">
<h2><a class="toc-backref" href="#id28">3.1&nbsp;&nbsp;&nbsp;Basic Procedure</a></h2>

<h2><a class="toc-backref" href="#id28">3.1&nbsp;&nbsp;&nbsp;基本过程</a></h2>

<ol class="arabic">
<li><p class="first">Get Boost; see sections 1 and 2 [<a class="reference external" href="../../../more/getting_started/unix-variants.html#get-boost">Unix/Linux</a>, <a class="reference external" href="../../../more/getting_started/windows.html#get-boost">Windows</a>] of the
Boost <a class="reference external" href="../../../more/getting_started/index.html">Getting Started Guide</a>.</p>

<p class="first">
获取Boost；
见Boost<a class="reference external" href="../../../more/getting_started/index.html">入门指南</a>
第1和第2节[<a class="reference external" href="../../../more/getting_started/unix-variants.html#get-boost">Unix/Linux</a>，
<a class="reference external" href="../../../more/getting_started/windows.html#get-boost">Windows</a>]。
</p>

</li>
<li><p class="first">Get the <tt class="docutils literal"><span class="pre">bjam</span></tt> build driver.  See section 5 [<a class="reference external" href="../../../more/getting_started/unix-variants.html#prepare-to-use-a-boost-library-binary">Unix/Linux</a>,
<a class="reference external" href="../../../more/getting_started/windows.html#prepare-to-use-a-boost-library-binary">Windows</a>] of the Boost <a class="reference external" href="../../../more/getting_started/index.html">Getting Started Guide</a>.</p>

<p class="first">
获取<tt class="docutils literal"><span class="pre">bjam</span></tt>构建驱动器。
见Boost
<a class="reference external" href="../../../more/getting_started/index.html">入门指门</a>
第5节[<a class="reference external" href="../../../more/getting_started/unix-variants.html#prepare-to-use-a-boost-library-binary">Unix/Linux</a>，
<a class="reference external" href="../../../more/getting_started/windows.html#prepare-to-use-a-boost-library-binary">Windows</a>]。</p>

</li>
<li><p class="first">cd into the <tt class="docutils literal"><span class="pre">libs/python/example/quickstart/</span></tt> directory of your
Boost installation, which contains a small example project.</p>

<p class="first">
cd到Boost安装目录下的<tt class="docutils literal"><span class="pre">libs/python/example/quickstart/</span></tt>，
那里有个小的示例工程。</p>

</li>
<li><p class="first">Invoke <tt class="docutils literal"><span class="pre">bjam</span></tt>.  Replace the "<tt class="docutils literal"><span class="pre">stage</span></tt>" argument from the
example invocation from section 5 of the <a class="reference external" href="../../../more/getting_started/index.html">Getting Started
Guide</a> with "<tt class="docutils literal"><span class="pre">test</span></tt>," to build all the test targets.  Also add
the argument "<tt class="docutils literal"><span class="pre">--verbose-test</span></tt>" to see the output generated by
the tests when they are run.</p>

<p class="first">
调用<tt class="docutils literal"><span class="pre">bjam</span></tt>。
将<a class="reference external" href="../../../more/getting_started/index.html">入门指南</a>
第5节例示的调用命令中的
“<tt class="docutils literal"><span class="pre">stage</span></tt>”参数
替换为“<tt class="docutils literal"><span class="pre">test</span></tt>”，
来构建所有测试目标。  
同时添加参数
“<tt class="docutils literal"><span class="pre">--verbose-test</span></tt>”
来查看测试运行时生成的输出。</p>

<p>On Windows, your <tt class="docutils literal"><span class="pre">bjam</span></tt> invocation might look something like:</p>

<p>
在Windows上，你的
<tt class="docutils literal"><span class="pre">bjam</span></tt>
调用可能像这样：
</p>

<pre class="literal-block">
C:\boost_1_34_0\…\quickstart&gt; <strong>bjam toolset=msvc --verbose-test test</strong>
</pre>
<p>and on Unix variants, perhaps,</p>

<p>而在各种Unix上，可能是：</p>

<pre class="literal-block">
~/boost_1_34_0/…/quickstart$ <strong>bjam toolset=gcc --verbose-test test</strong>
</pre>
</li>
</ol>
<div class="admonition-note-to-windows-users admonition">
<p class="first admonition-title">Note to Windows Users</p>

<p class="first admonition-title">Windows用户注意</p>

<p class="last">For the sake of concision, the rest of this guide will use
unix-style forward slashes in pathnames instead of the
backslashes with which you may be more familiar.  The forward
slashes should work everywhere except in <a class="reference external" href="../../../more/getting_started/windows.html#command-prompt">Command Prompt</a>
windows, where you should use backslashes.</p>

<p class="last"> 
为求简洁，本指南的其余部分将在路径中使用unix风格的斜杠，
而不是你可能更熟悉的反斜杠。
斜杠应该到处可用，除了
<a class="reference external" href="../../../more/getting_started/windows.html#command-prompt">命令提示符</a>
窗口，在那里您应该使用反斜杠。
</p>

</div>

<p>If you followed this procedure successfully, you will have built an
extension module called <tt class="docutils literal"><span class="pre">extending</span></tt> and tested it by running a
Python script called <tt class="docutils literal"><span class="pre">test_extending.py</span></tt>.  You will also have
built and run a simple application called <tt class="docutils literal"><span class="pre">embedding</span></tt> that embeds
python.</p>

<p>
如果你能成功地遵循这个过程，
你将构建出一个扩展模块，
名为<tt class="docutils literal"><span class="pre">extending</span></tt>，
并运行一个名为
<tt class="docutils literal"><span class="pre">test_extending.py</span></tt>
的Python脚本测试它。
你也将构建并运行一个内嵌python的简单应用程序，
名为<tt class="docutils literal"><span class="pre">embedding</span></tt>。
</p>

</div>

<div class="section" id="in-case-of-trouble">
<h2><a class="toc-backref" href="#id29">3.2&nbsp;&nbsp;&nbsp;In Case of Trouble</a></h2>

<h2><a class="toc-backref" href="#id29">3.2&nbsp;&nbsp;&nbsp;如果遇到问题</a></h2>

<p>If you're seeing lots of compiler and/or linker error messages,
it's probably because Boost.Build is having trouble finding your
Python installation.  You might want to pass the
<tt class="docutils literal"><span class="pre">--debug-configuration</span></tt> option to <tt class="docutils literal"><span class="pre">bjam</span></tt> the first few times
you invoke it, to make sure that Boost.Build is correctly locating
all the parts of your Python installation.  If it isn't, consider
<a class="reference internal" href="#configuring-boost-build">Configuring Boost.Build</a> as detailed below.</p>

<p>
如果你见到大量编译或连接的错误信息，
那可能是因为Boost.Build无法找到你的Python安装。
你也许要在最初几次调用<tt class="docutils literal"><span class="pre">bjam</span></tt>时，
传入<tt class="docutils literal"><span class="pre">--debug-configuration</span></tt>参数，
以确保Boost.Build正确定位了所有Python组件。 
如果不是，请考虑
<a class="reference internal" href="#configuring-boost-build">配置Boost.Build</a>。
</p>

<p>If you're still having trouble, Someone on one of the following
mailing lists may be able to help:</p>

<p>
如果仍有问题，请向以下邮件列表寻求帮助：
</p>

<ul class="simple">
<li>The <a class="reference external" href="http://www.boost.org/more/mailing_lists.htm#jamboost">Boost.Build mailing list</a> for issues related to Boost.Build</li>
<li>The Python <a class="reference external" href="http://www.boost.org/more/mailing_lists.htm#cplussig">C++ Sig</a> for issues specifically related to Boost.Python</li>
</ul>

<ul class="simple">
<li>
<a class="reference external" href="../../../more/mailing_lists.htm#jamboost">Boost.Build
邮件列表</a>，Boost.Build相关问题</li>

<li>
Python
<a class="reference external" href="../../../more/mailing_lists.htm#cplussig">C++ Sig</a>，
Boost.Python相关的专门问题</li>
</ul>

</div>
<div class="section" id="in-case-everything-seemed-to-work">
<h2><a class="toc-backref" href="#id30">3.3&nbsp;&nbsp;&nbsp;In Case Everything Seemed to Work</a></h2>

<h2><a class="toc-backref" href="#id30">3.3&nbsp;&nbsp;&nbsp;如果一切都好</a></h2>

<p>Rejoice!  If you're new to Boost.Python, at this point it might be
a good idea to ignore build issues for a while and concentrate on
learning the library by going through the <a class="reference external" href="tutorial/index.html">tutorial</a> and perhaps
some of the <a class="reference external" href="v2/reference.html">reference documentation</a>, trying out what you've
learned about the API by modifying the quickstart project.</p>

<p>
恭喜！
如果您是Boost.Python新手，
此时，最好暂时不理会构建问题，
而是集中精力去学习库，
尽快学完<a class="reference external" href="tutorial/index.html">教程</a>，
然后可能是<a class="reference external" href="v2/reference.html">参考文档</a>，
同时通过修改快速入门工程，
试用你所学到的API。
</p>

</div>

<div class="section" id="modifying-the-example-project">
<h2><a class="toc-backref" href="#id31">3.4&nbsp;&nbsp;&nbsp;Modifying the Example Project</a></h2>

<h2><a class="toc-backref" href="#id31">3.4&nbsp;&nbsp;&nbsp;修改示例工程</a></h2>

<p>If you're content to keep your extension module forever in one
source file called <a class="reference external" href="../example/quickstart/extending.cpp"><tt class="docutils literal"><span class="pre">extending.cpp</span></tt></a>, inside your Boost
distribution, and import it forever as <tt class="docutils literal"><span class="pre">extending</span></tt>, then you can
stop here.  However, it's likely that you will want to make a few
changes.  There are a few things you can do without having to learn
<a class="reference external" href="../../../tools/build/index.html">Boost.Build</a> in depth.</p>

<p>
如果你满足于此，
扩展模块的源文件永远是
<a class="reference external" href="../example/quickstart/extending.cpp"><tt class="docutils literal"><span class="pre">extending.cpp</span></tt></a>，
位于Boost发布目录中，
并永远按<tt class="docutils literal"><span class="pre">extending</span></tt>导入，
那么你就可以到此为止。 
不过很可能是，你会想作一些变动。
有许多事你可以做，而无须深入学习
<a class="reference external" href="../../../tools/build/index.html">Boost.Build</a>。
</p>

<p>The project you just built is specified in two files in the current
directory: <a class="reference external" href="../example/quickstart/boost-build.jam"><tt class="docutils literal"><span class="pre">boost-build.jam</span></tt></a>, which tells <tt class="docutils literal"><span class="pre">bjam</span></tt> where it can
find the interpreted code of the Boost build system, and
<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>, which describes the targets you just built.  These
files are heavily commented, so they should be easy to modify.
Take care, however, to preserve whitespace.  Punctuation such as
<tt class="docutils literal"><span class="pre">;</span></tt> will not be recognized as intended by <tt class="docutils literal"><span class="pre">bjam</span></tt> if it is not
surrounded by whitespace.</p>

<p>
你刚刚构建的工程，
是由当前目录下的两个文件详细说明的：
<a class="reference external" href="../example/quickstart/boost-build.jam"><tt class="docutils literal"><span class="pre">boost-build.jam</span></tt></a>
（它告诉<tt class="docutils literal"><span class="pre">bjam</span></tt>，
哪里可以找到Boost编译系统的解释代码），
和<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>
（它描述了你刚刚构建的目标）。
这些文件具有详细的注释，所以它们应该很容易修改。
不过小心，要保留空白字符。
如<tt class="docutils literal"><span class="pre">;</span></tt>这样的标点符号，
如果周围没有空白字符，
<tt class="docutils literal"><span class="pre">bjam</span></tt>将无法识别。
</p>

<div class="section" id="relocate-the-project">
<h3>Relocate the Project</h3>

<h3>工程移位</h3>

<p>You'll probably want to copy this project elsewhere so you can
change it without modifying your Boost distribution.  To do that,
simply</p>

<p>
你可能想把该工程复制到其他位置，
这样你就可以修改它，
而不必在Boost发布目录中更改。
要做到这一点，只需
</p>

<ol class="loweralpha simple">
<li>copy the entire <tt class="docutils literal"><span class="pre">libs/python/example/quickstart/</span></tt> directory
into a new directory.</li>
<li>In the new copies of <a class="reference external" href="../example/quickstart/boost-build.jam"><tt class="docutils literal"><span class="pre">boost-build.jam</span></tt></a> and <a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>, locate
the relative path near the top of the file that is clearly
marked by a comment, and edit that path so that it refers to the
same directory your Boost distribution as it referred to when
the file was in its original location in the
<tt class="docutils literal"><span class="pre">libs/python/example/quickstart/</span></tt> directory.</li>
</ol>

<ol class="loweralpha simple">
<li>
复制整个<tt class="docutils literal"><span class="pre">libs/python/example/quickstart/</span></tt>
目录到一个新的目录。
</li>
<li>
在新的<a class="reference external" href="../example/quickstart/boost-build.jam"><tt class="docutils literal"><span class="pre">boost-build.jam</span></tt></a>
和<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>
副本中，
靠近文件顶部，
找到由一条注释清楚标注的相对路径，
然后编辑这个路径，
让它指向Boost发布目录，
与它原来（当文件在<tt class="docutils literal"><span class="pre">libs/python/example/quickstart/</span></tt>
目录时）所指目录相同。
</li>
</ol>

<p>For example, if you moved the project from
<tt class="docutils literal"><span class="pre">/home/dave/boost_1_34_0/libs/python/example/quickstart</span></tt> to
<tt class="docutils literal"><span class="pre">/home/dave/my-project</span></tt>, you could change the first path in
<a class="reference external" href="../example/quickstart/boost-build.jam"><tt class="docutils literal"><span class="pre">boost-build.jam</span></tt></a> from</p>

<p>
例如，如果你的工程从
<tt class="docutils literal"><span class="pre">/home/dave/boost_1_34_0/libs/python/example/quickstart</span></tt>
移至<tt class="docutils literal"><span class="pre">/home/dave/my-project</span></tt>，
你可以更改
<a class="reference external" href="../example/quickstart/boost-build.jam"><tt class="docutils literal"><span class="pre">boost-build.jam</span></tt></a>
中的第一个路径，从
</p>

<pre class="literal-block">
<strong>../../../..</strong>/tools/build/v2
</pre>
<p>to</p>

<p>改为</p>

<pre class="literal-block">
<strong>/home/dave/boost_1_34_0</strong>/tools/build/v2
</pre>
<p>and change the first path in <a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a> from</p>

<p>并且，将<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>
中的第一个路径从
</p>

<pre class="literal-block">
<strong>../../../..</strong>
</pre>
<p>to</p>

<p>改为</p>

<pre class="literal-block">
<strong>/home/dave/boost_1_34_0</strong>
</pre>
</div>

<div class="section" id="add-new-or-change-names-of-existing-source-files">
<h3>Add New or Change Names of Existing Source Files</h3>

<h3>添加新的源文件或更改源文件名</h3>

<p>The names of additional source files involved in building your
extension module or embedding application can be listed in
<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a> right alongside <tt class="docutils literal"><span class="pre">extending.cpp</span></tt> or <tt class="docutils literal"><span class="pre">embedding.cpp</span></tt>
respectively.  Just be sure to leave whitespace around each
filename:</p>

<p>
构建扩展模块或内嵌应用程序时，
涉及的其他源文件的名字，
可以在<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>中列出，
分别列于<tt class="docutils literal"><span class="pre">extending.cpp</span></tt>
或<tt class="docutils literal"><span class="pre">embedding.cpp</span></tt>旁边。
只是每个文件名周围，务必留下空白字符：
</p>

<pre class="literal-block">
… file1.cpp file2.cpp file3.cpp …</pre>
<p>Naturally, if you want to change the name of a source file you can
tell Boost.Build about it by editing the name in <a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>.</p>

<p>
当然，如果你想要更改源文件名，
你可以编辑
<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>
中的文件名，来告诉Boost.Build。
</p>

</div>

<div class="section" id="change-the-name-of-your-extension-module">
<h3>Change the Name of your Extension Module</h3>

<h3>更改扩展模块的名字</h3>

<p>The name of the extension module is determined by two things:</p>

<p>扩展模块的名字，由两个地方决定：</p>

<ol class="arabic simple">
<li>the name in <a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a> immediately following <tt class="docutils literal"><span class="pre">python-extension</span></tt>, and</li>
<li>the name passed to <tt class="docutils literal"><span class="pre">BOOST_PYTHON_MODULE</span></tt> in <a class="reference external" href="../example/quickstart/extending.cpp"><tt class="docutils literal"><span class="pre">extending.cpp</span></tt></a>.</li>
</ol>

<ol class="arabic simple">
<li>在<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>
中紧跟<tt class="docutils literal"><span class="pre">python-extension</span></tt>
的名字，
和</li>
<li>在<a class="reference external" href="../example/quickstart/extending.cpp"><tt class="docutils literal"><span class="pre">extending.cpp</span></tt></a>中
传给<tt class="docutils literal"><span class="pre">BOOST_PYTHON_MODULE</span></tt>
的名字。</li>
</ol>

<p>To change the name of the extension module from <tt class="docutils literal"><span class="pre">extending</span></tt> to
<tt class="docutils literal"><span class="pre">hello</span></tt>, you'd edit <a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>, changing</p>

<p>
要将扩展模块名从<tt class="docutils literal"><span class="pre">extending</span></tt>
改为<tt class="docutils literal"><span class="pre">hello</span></tt>，
你需要编辑<a class="reference external" href="../example/quickstart/Jamroot"><tt class="docutils literal"><span class="pre">Jamroot</span></tt></a>，将
</p>

<pre class="literal-block">
python-extension <strong>extending</strong> : extending.cpp ;
</pre>
<p>to</p>

<p>改为</p>

<pre class="literal-block">
python-extension <strong>hello</strong> : extending.cpp ;
</pre>
<p>and you'd edit extending.cpp, changing</p>

<p>还需要编辑extending.cpp，将</p>

<pre class="literal-block">
BOOST_PYTHON_MODULE(<strong>extending</strong>)
</pre>
<p>to</p>

<p>改为</p>

<pre class="literal-block">
BOOST_PYTHON_MODULE(<strong>hello</strong>)
</pre>
</div>
</div>
</div>
<div class="section" id="installing-boost-python-on-your-system">
<h1><a class="toc-backref" href="#id32">4&nbsp;&nbsp;&nbsp;Installing Boost.Python on your System</a></h1>

<h1><a class="toc-backref" href="#id32">4&nbsp;&nbsp;&nbsp;在系统上安装Boost.Python</a></h1>

<p>Since Boost.Python is a separately-compiled (as opposed to
<a class="reference external" href="../../../more/getting_started/windows.html#header-only-libraries">header-only</a>) library, its user relies on the services of a
Boost.Python library binary.</p>

<p>
由于Boost.Python是一个单独编译的库（有别于<a class="reference external" href="../../../more/getting_started/windows.html#header-only-libraries">纯头文件</a>库），
它的用户需要依赖Boost.Python二进制库的服务。
</p>

<p>If you need a regular installation of the Boost.Python library
binaries on your system, the Boost <a class="reference external" href="../../../more/getting_started/index.html">Getting Started Guide</a> will
walk you through the steps of creating one.  If building binaries
from source, you might want to supply the <tt class="docutils literal"><span class="pre">--with-python</span></tt>
argument to <tt class="docutils literal"><span class="pre">bjam</span></tt> (or the <tt class="docutils literal"><span class="pre">--with-libraries=python</span></tt> argument
to <tt class="docutils literal"><span class="pre">configure</span></tt>), so only the Boost.Python binary will be built,
rather than all the Boost binaries.</p>

<p>
如果你需要在系统上安装一个常规的Boost.Python二进制库，
Boost<a class="reference external" href="../../../more/getting_started/index.html">入门指南</a>将带你一步一步创建它。
如果从源文件构建二进制，
你也许要向<tt class="docutils literal"><span class="pre">bjam</span></tt>
提供<tt class="docutils literal"><span class="pre">--with-python</span></tt>
参数（或向<tt class="docutils literal"><span class="pre">configure</span></tt>
提供<tt class="docutils literal"><span class="pre">--with-libraries=python</span></tt>
参数），
这样就会仅仅构建Boost.Python二进制，
而不是所有的Boost二进制。</p>

</div>

<div class="section" id="configuring-boost-build">
<h1><a class="toc-backref" href="#id33">5&nbsp;&nbsp;&nbsp;Configuring Boost.Build</a></h1>

<h1><a class="toc-backref" href="#id33">5&nbsp;&nbsp;&nbsp;配置Boost.Build</a></h1>

<p>As described in the <a class="reference external" href="http://www.boost.orgdoc/html/bbv2/advanced.html#bbv2.advanced.configuration">Boost.Build reference manual</a>, a file called
<tt class="docutils literal"><span class="pre">user-config.jam</span></tt> in your home directory<a class="footnote-reference" href="#home-dir" id="id11"><sup>6</sup></a> is used to
specify the tools and libraries available to the build system. You
may need to create or edit <tt class="docutils literal"><span class="pre">user-config.jam</span></tt> to tell Boost.Build
how to invoke Python, <tt class="docutils literal"><span class="pre">#include</span></tt> its headers, and link with its
libraries.</p>

<p>
正如<a class="reference external" href="http://www.boost.orgdoc/html/bbv2/advanced.html#bbv2.advanced.configuration">Boost.Build参考手册</a>所述，
在你的主目录<a class="footnote-reference" href="#home-dir" id="id11"><sup>6</sup></a>下，
有一个<tt class="docutils literal"><span class="pre">user-config.jam</span></tt>文件，
用来指定编译系统可用的工具和库。
您可能需要创建或编辑<tt class="docutils literal"><span class="pre">user-config.jam</span></tt>，
来告诉Boost.Build如何调用Python，
<tt class="docutils literal"><span class="pre">#include</span></tt>
它的头文件，并链接它的库。
</p>

<div class="admonition-users-of-unix-variant-oses admonition">
<p class="first admonition-title">Users of Unix-Variant OSes</p>

<p class="first admonition-title">类Unix OS用户</p>

<p class="last">If you are using a unix-variant OS and you ran Boost's
<tt class="docutils literal"><span class="pre">configure</span></tt> script, it may have generated a
<tt class="docutils literal"><span class="pre">user-config.jam</span></tt> for you.<a class="footnote-reference" href="#overwrite" id="id13"><sup>4</sup></a> If your <tt class="docutils literal"><span class="pre">configure</span></tt>/<tt class="docutils literal"><span class="pre">make</span></tt> sequence was successful and Boost.Python binaries
were built, your <tt class="docutils literal"><span class="pre">user-config.jam</span></tt> file is probably already
correct.</p>

<p class="last">
如果你使用的是类Unix操作系统，
并且你运行了Boost <tt class="docutils literal"><span class="pre">configure</span></tt>
脚本，
它可能已经为你生成了一个<tt class="docutils literal"><span class="pre">user-config.jam</span></tt><a class="footnote-reference" href="#overwrite" id="id13"><sup>4</sup></a>。
如果你<tt class="docutils literal"><span class="pre">configure</span></tt>/<tt class="docutils literal"><span class="pre">make</span></tt>
就能成功构建Boost.Python，
你的<tt class="docutils literal"><span class="pre">user-config.jam</span></tt>
文件可能已经是正确的了。
</p>

</div>

<p>If you have one fairly "standard" python installation for your
platform, you might not need to do anything special to describe it.  If
you haven't configured python in <tt class="docutils literal"><span class="pre">user-config.jam</span></tt> (and you don't
specify <tt class="docutils literal"><span class="pre">--without-python</span></tt> on the Boost.Build command line),
Boost.Build will automatically execute the equivalent of</p>

<p>
如果你的平台有一个相当“标准”的python安装，
你可能不需要对它做特别描述。
如果你没有在<tt class="docutils literal"><span class="pre">user-config.jam</span></tt>
中配置python（并且没有在Boost.Build命令行中指定
<tt class="docutils literal"><span class="pre">--without-python</span></tt>），
Boost.Build将自动执行以下等效语句
</p>

<pre class="literal-block">
import toolset : using ;
using python ;
</pre>
<p>which automatically looks for Python in the most likely places.
However, that only happens when using the Boost.Python project file
(e.g. when referred to by another project as in the <a class="reference internal" href="#quickstart">quickstart</a>
method).  If instead you are linking against separately-compiled
Boost.Python binaries, you should set up a <tt class="docutils literal"><span class="pre">user-config.jam</span></tt> file
with at least the minimal incantation above.</p>

<p>
这会让它在最有可能的地方自动寻找Python。 
不过，这只会发生在当使用Boost.Python项目文件时
（例如，当被另一个项目引用时，如
<a class="reference internal" href="#quickstart">快速入门</a>所示方法）。
反之，如果你链接单独编译的Boost.Python二进制，
你应该建立一个
<tt class="docutils literal"><span class="pre">user-config.jam</span></tt>文件，
至少包含以上最少量的咒语。
</p>

<div class="section" id="python-configuration-parameters">
<h2><a class="toc-backref" href="#id34">5.1&nbsp;&nbsp;&nbsp;Python Configuration Parameters</a></h2>

<h2><a class="toc-backref" href="#id34">5.1&nbsp;&nbsp;&nbsp;Python配置参数</a></h2>

<p>If you have several versions of Python installed, or Python is
installed in an unusual way, you may want to supply any or all of
the following optional parameters to <tt class="docutils literal"><span class="pre">using</span> <span class="pre">python</span></tt>.</p>

<p>
如果你安装了多个Python，
或Python以一个不寻常的方式安装，
你可能要向<tt class="docutils literal"><span class="pre">using</span> <span class="pre">python</span></tt>
提供下列部分或全部可选参数。
</p>

<dl class="docutils">
<dt>version</dt>
<dd>the version of Python to use.  Should be in Major.Minor
format, for example, <tt class="docutils literal"><span class="pre">2.3</span></tt>.  Do not include the subminor
version (i.e. <em>not</em> <tt class="docutils literal"><span class="pre">2.5.1</span></tt>).  If you have multiple Python
versions installed, the version will usually be the only
configuration argument required.</dd>

<br>
<dd>
使用的Python的版本。
格式为“主要版本号.次要版本号”，
例如<tt class="docutils literal"><span class="pre">2.3</span></tt>。
不包括子次版本号（即<em>不是</em><tt class="docutils literal"><span class="pre">2.5.1</span></tt>）。
如果你安装了多个版本的Python，
版本号通常是唯一要求的配置参数。
</dd>
<br>

<dt>cmd-or-prefix</dt>
<dd>preferably, a command that invokes a Python interpreter.
Alternatively, the installation prefix for Python libraries and
header files.  Only use the alternative formulation if there is
no appropriate Python executable available.</dd>

<br>
<dd>
最好是一个调用Python解释器的命令。
也可以是，Python库和头文件的安装前缀。
仅当没有合适的Python可执行程序时，
才使用第二种方式。
</dd>
<br>

<dt>includes</dt>
<dd>the <tt class="docutils literal"><span class="pre">#include</span></tt> paths for Python headers.  Normally the correct
path(s) will be automatically deduced from <tt class="docutils literal"><span class="pre">version</span></tt> and/or
<tt class="docutils literal"><span class="pre">cmd-or-prefix</span></tt>.</dd>

<br>
<dd>
Python头文件的<tt class="docutils literal"><span class="pre">#include</span></tt>路径。
通常，正确的路径将从
<tt class="docutils literal"><span class="pre">version</span></tt>和
<tt class="docutils literal"><span class="pre">cmd-or-prefix</span></tt>
自动推断。
</dd>
<br>

<dt>libraries</dt>
<dd>the path to Python library binaries.  On MacOS/Darwin,
you can also pass the path of the Python framework.  Normally the
correct path(s) will be automatically deduced from <tt class="docutils literal"><span class="pre">version</span></tt>
and/or <tt class="docutils literal"><span class="pre">cmd-or-prefix</span></tt>.</dd>

<br>
<dd>
Python二进制库的路径。
在MacOS/Darwin上，你还可以传入Python框架的路径。
通常，正确的路径将从
<tt class="docutils literal"><span class="pre">version</span></tt>和
<tt class="docutils literal"><span class="pre">cmd-or-prefix</span></tt>
自动推断。
</dd>
<br>

<dt>condition</dt>
<dd>if specified, should be a set of Boost.Build
properties that are matched against the build configuration when
Boost.Build selects a Python configuration to use.  See examples
below for details.</dd>

<br>
<dd>
如果要指定，应该是一组Boost.Build属性，
当Boost.Build选择使用一个Python配置时，
用于改写默认的构建配置。
详情见下面例子。
</dd>
<br>

<dt>extension-suffix</dt>
<dd>A string to append to the name of extension
modules before the true filename extension.  You almost certainly
don't need to use this.  Usually this suffix is only used when
targeting a Windows debug build of Python, and will be set
automatically for you based on the value of the
<a class="reference internal" href="#python-debugging"><tt class="docutils literal"><span class="pre">&lt;python-debugging&gt;</span></tt></a> feature.  However, at least one Linux
distribution (Ubuntu Feisty Fawn) has a specially configured
<a class="reference external" href="https://wiki.ubuntu.com/PyDbgBuilds">python-dbg</a> package that claims to use such a suffix.</dd>

<br>
<dd>
一个字符串，用来附加到扩展模块名上（在真实的文件扩展名之前）。
你几乎肯定不需要用到这个。
通常这个后缀只用于针对Windows的Python调试版，
并且，它会基于
<a class="reference internal" href="#python-debugging"><tt class="docutils literal"><span class="pre">&lt;python-debugging&gt;</span></tt></a>
特性的值自动设定。
不过，至少有一个Linux发行版（Ubuntu Feisty Fawn），
有一个特别配置的
<a class="reference external" href="https://wiki.ubuntu.com/PyDbgBuilds">python-dbg</a>
包，
声称使用了这样的后缀。
</dd>
<br>

</dl>
</div>

<div class="section" id="examples">
<h2><a class="toc-backref" href="#id35">5.2&nbsp;&nbsp;&nbsp;Examples</a></h2>

<h2><a class="toc-backref" href="#id35">5.2&nbsp;&nbsp;&nbsp;例子</a></h2>

<p>Note that in the examples below, case and <em>especially whitespace</em> are
significant.</p>

<p>
注意，在下面的例子中，大小写，<em>尤其是空白字符</em>是有意义的。
</p>

<ul>
<li><p class="first">If you have both python 2.5 and python 2.4 installed,
<tt class="docutils literal"><span class="pre">user-config.jam</span></tt> might contain:</p>

<p class="first">
如果你同时安装了python 2.5和python 2.4，
<tt class="docutils literal"><span class="pre">user-config.jam</span></tt>可能包含：
</p>

<pre class="literal-block">
using python : 2.5 ;  # Make both versions of Python available

using python : 2.4 ;  # To build with python 2.4, add python=2.4
                      # to your command line.
</pre>
<p>The first version configured (2.5) becomes the default.  To build
against python 2.4, add <tt class="docutils literal"><span class="pre">python=2.4</span></tt> to the <tt class="docutils literal"><span class="pre">bjam</span></tt> command line.</p>

<p>
第一个配置的版本（2.5）将成为默认值。
如果要使用python 2.4构建，
请在<tt class="docutils literal"><span class="pre">bjam</span></tt>命令行中添加
<tt class="docutils literal"><span class="pre">python=2.4</span></tt>。
</p>

</li>
<li><p class="first">If you have python installed in an unusual location, you might
supply the path to the interpreter in the <tt class="docutils literal"><span class="pre">cmd-or-prefix</span></tt>
parameter:</p>

<p class="first">
如果你把python安装在一个不寻常的位置，
你可以在<tt class="docutils literal"><span class="pre">cmd-or-prefix</span></tt>参数中
提供解释器的路径：
</p>

<pre class="literal-block">
using python : : /usr/local/python-2.6-beta/bin/python ;
</pre>
</li>
<li><p class="first">If you have a separate build of Python for use with a particular
toolset, you might supply that toolset in the <tt class="docutils literal"><span class="pre">condition</span></tt>
parameter:</p>

<p class="first">
如果一个特定工具集使用了一个单独构建的Python，
你可以在<tt class="docutils literal"><span class="pre">condition</span></tt>
参数中提供该工具集。
</p>

<pre class="literal-block">
using python ;  # use for most toolsets

# Use with Intel C++ toolset
using python
     : # version
     : c:\\Devel\\Python-2.5-IntelBuild\\PCBuild\\python # cmd-or-prefix
     : # includes
     : # libraries
     : &lt;toolset&gt;intel # condition
     ;
</pre>
</li>
<li><p class="first">If you have downloaded the Python sources and built both the
normal and the "<a class="reference internal" href="#id19">python debugging</a>" builds from source on
Windows, you might see:</p>

<p class="first">
如果你下载了Python源码并且在Windows上自己构建了python和
<a class="reference internal" href="#id19">python调试版</a>，
你可能会看到：
</p>

<pre class="literal-block">
using python : 2.5 : C:\\src\\Python-2.5\\PCBuild\\python ;
using python : 2.5 : C:\\src\\Python-2.5\\PCBuild\\python_d
  : # includes
  : # libs
  : &lt;python-debugging&gt;on ;
</pre>
</li>
<li><p class="first">You can set up your user-config.jam so a bjam built under Windows
can build/test both Windows and <a class="reference external" href="http://cygwin.com">Cygwin</a> python extensions.  Just pass
<tt class="docutils literal"><span class="pre">&lt;target-os&gt;cygwin</span></tt> in the <tt class="docutils literal"><span class="pre">condition</span></tt> parameter
for the cygwin python installation:</p>

<p class="first">
你可以设置user-config.jam，
让Windows上的bjam能够构建和测试两个版本的python扩展，
既有Windows版，
也有<a class="reference external" href="http://cygwin.com">Cygwin</a>版。
只需在<tt class="docutils literal"><span class="pre">condition</span></tt>参数中，
为cygwin的python安装
传入<tt class="docutils literal"><span class="pre">&lt;target-os&gt;cygwin</span></tt>：
</p>

<pre class="literal-block">
# windows installation
using python ;

# cygwin installation
using python : : c:\\cygwin\\bin\\python2.5 : : : &lt;target-os&gt;cygwin ;
</pre>
<p>when you put target-os=cygwin in your build request, it should build
with the cygwin version of python:<a class="footnote-reference" href="#flavor" id="id15"><sup>5</sup></a></p>

<p>
当你在构建请求中加入target-os=cygwin，
它就应该使用cygwin版本的python进行构建：<a class="footnote-reference" href="#flavor" id="id15"><sup>5</sup></a>
</p>

<blockquote>
<p>bjam target-os=cygwin toolset=gcc</p>
</blockquote>
<p>This is supposed to work the other way, too (targeting windows
python with a <a class="reference external" href="http://cygwin.com">Cygwin</a> bjam) but it seems as though the support in
Boost.Build's toolsets for building that way is broken at the
time of this writing.</p>

<p>
另一种方式应该也行
（使用<a class="reference external" href="http://cygwin.com">Cygwin</a>上的bjam，
以windows python为目标），
但在本文写作之时，
Boost.Build的工具集对那种构建方式的支持好像有问题。
</p>

</li>
<li><p class="first">Note that because of <a class="reference external" href="http://zigzag.cs.msu.su/boost.build/wiki/AlternativeSelection">the way Boost.Build currently selects target
alternatives</a>, you might have be very explicit in your build
requests.  For example, given:</p>

<p class="first">
注意，在
<a class="reference external" href="http://zigzag.cs.msu.su/boost.build/wiki/AlternativeSelection">
Boost.Build目前选择不同目标的方式</a>下，
可能你的编译请求必须非常明确。
举例来说，如有：
</p>

<pre class="literal-block">
using python : 2.5 ; # a regular windows build
using python : 2.4 : : : : &lt;target-os&gt;cygwin ;
</pre>
<p>building with</p>

<p>以</p>

<pre class="literal-block">
bjam target-os=cygwin
</pre>
<p>will yield an error.  Instead, you'll need to write:</p>

<p>构建会产生一个错误。你需要这样写才行：</p>

<pre class="literal-block">
bjam target-os=cygwin/python=2.4
</pre>
</li>
</ul>
</div>
</div>

<div class="section" id="choosing-a-boost-python-library-binary">
<h1><a class="toc-backref" href="#id36">6&nbsp;&nbsp;&nbsp;Choosing a Boost.Python Library Binary</a></h1>

<h1><a class="toc-backref" href="#id36">6&nbsp;&nbsp;&nbsp;选择Boost.Python二进制库</a></h1>

<p>If―instead of letting Boost.Build construct and link with the right
libraries automatically―you choose to use a pre-built Boost.Python
library, you'll need to think about which one to link with.  The
Boost.Python binary comes in both static and dynamic flavors.  Take
care to choose the right flavor for your application.<a class="footnote-reference" href="#naming" id="id17"><sup>2</sup></a></p>

<p>
如果不是任由Boost.Build自动构建和链接正确的库，
而是选择使用预建的Boost.Python库，
你需要考虑一下链接哪个库。
Boost.Python二进制库同时具有静态和动态库。
请为您的应用小心选择正确的库。<a class="footnote-reference" href="#naming" id="id17"><sup>2</sup></a>
</p>

<div class="section" id="the-dynamic-binary">
<h2><a class="toc-backref" href="#id37">6.1&nbsp;&nbsp;&nbsp;The Dynamic Binary</a></h2>

<h2><a class="toc-backref" href="#id37">6.1&nbsp;&nbsp;&nbsp;动态二进制</a></h2>

<p>The dynamic library is the safest and most-versatile choice:</p>

<p>动态库是最安全和最通用的选择：</p>

<ul class="simple">
<li>A single copy of the library code is used by all extension
modules built with a given toolset.<a class="footnote-reference" href="#toolset-specific" id="id18"><sup>3</sup></a></li>
<li>The library contains a type conversion registry.  Because one
registry is shared among all extension modules, instances of a
class exposed to Python in one dynamically-loaded extension
module can be passed to functions exposed in another such module.</li>
</ul>

<ul class="simple">
<li>
用特定工具集构建的所有扩展模块，
都使用同一份库代码。<a class="footnote-reference" href="#toolset-specific" id="id18"><sup>3</sup></a>
</li>
<li>
库包含一个类型转换注册表。
因为所有扩展模块共享一个注册表，所以，
在一个动态装载的扩展模块中，
导出到Python的类实例，
可以传给另一个动态模块中导出的函数。
</li>
</ul>

</div>
<div class="section" id="the-static-binary">
<h2><a class="toc-backref" href="#id38">6.2&nbsp;&nbsp;&nbsp;The Static Binary</a></h2>
<h2><a class="toc-backref" href="#id38">6.2&nbsp;&nbsp;&nbsp;静态二进制</a></h2>
<p>It might be appropriate to use the static Boost.Python library in
any of the following cases:</p>

<p>
下列任一情况下，可能适合使用静态的Boost.Python库：
</p>

<ul class="simple">
<li>You are <a class="reference external" href="http://www.python.org/doc/current/ext/intro.html">extending</a> python and the types exposed in your
dynamically-loaded extension module don't need to be used by any
other Boost.Python extension modules, and you don't care if the
core library code is duplicated among them.</li>
<li>You are <a class="reference external" href="http://www.python.org/doc/current/ext/embedding.html">embedding</a> python in your application and either:<ul>
<li>You are targeting a Unix variant OS other than MacOS or AIX,
where the dynamically-loaded extension modules can "see" the
Boost.Python library symbols that are part of the executable.</li>
<li>Or, you have statically linked some Boost.Python extension
modules into your application and you don't care if any
dynamically-loaded Boost.Python extension modules are able to
use the types exposed by your statically-linked extension
modules (and vice-versa).</li>
</ul>
</li>
</ul>

<ul class="simple">
<li>
你是在<a class="reference external" href="http://www.python.org/doc/current/ext/intro.html">扩展</a>Python，
并且，你动态加载的扩展模块中导出的类型，
不需要被其他Boost.Python扩展模块使用，
你也不关心核心库代码是否在它们中间重复。
</li>
<li>
你是在应用程序中<a class="reference external" href="http://www.python.org/doc/current/ext/embedding.html">内嵌</a>
Python，并且：

<ul>
<li>
你的目标是MacOS或AIX以外的类Unix OS，
在那里，动态加载的扩展模块，
可以“看见”可执行文件中Boost.Python库的符号。
</li>
<li>
或者，你已经静态链接了一些Boost.Python扩展模块到你的应用程序，
并且你不关心
动态加载的Boost.Python扩展模块，
是否能够使用你静态链接的扩展模块所导出的类型（反之亦然）。
</li>
</ul>

</li>
</ul>

</div>
</div>
<div class="section" id="include-issues">
<h1><a class="toc-backref" href="#id39">7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">#include</span></tt> Issues</a></h1>

<h1><a class="toc-backref" href="#id39">7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">#include</span></tt>问题</a></h1>

<ol class="arabic simple">
<li>If you should ever have occasion to <tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;python.h&quot;</span></tt>
directly in a translation unit of a program using Boost.Python,
use <tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;boost/python/detail/wrap_python.hpp&quot;</span></tt> instead.
It handles several issues necessary for use with Boost.Python,
one of which is mentioned in the next section.</li>
<li>Be sure not to <tt class="docutils literal"><span class="pre">#include</span></tt> any system headers before
<tt class="docutils literal"><span class="pre">wrap_python.hpp</span></tt>.  This restriction is actually imposed by
Python, or more properly, by Python's interaction with your
operating system.  See
<a class="reference external" href="http://docs.python.org/ext/simpleExample.html">http://docs.python.org/ext/simpleExample.html</a> for details.</li>
</ol>

<ol class="arabic simple">
<li>
在使用Boost.Python的程序中，
如果你需要在某个翻译单元中直接
<tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;python.h&quot;</span></tt>，
请改为使用<tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;boost/python/detail/wrap_python.hpp&quot;</span></tt>。
它处理了Boost.Python使用中几个必要问题，
其中一个将在接下来的一节中提到。
</li>
<li>
在<tt class="docutils literal"><span class="pre">wrap_python.hpp</span></tt>之前，
千万不要<tt class="docutils literal"><span class="pre">#include</span></tt>
任何系统头文件。
这一限制实际上是由Python强加的，
更严格地说，
是由Python与你的操作系统相互作用造成的。
详见<a class="reference external" href="http://docs.python.org/ext/simpleExample.html">http://docs.python.org/ext/simpleExample.html</a>。
</li>
</ol>

</div>
<div class="section" id="python-debugging-builds">
<span id="id19"></span><span id="python-debugging"></span><h1><a class="toc-backref" href="#id40">8&nbsp;&nbsp;&nbsp;Python Debugging Builds</a></h1>

<h1><a class="toc-backref" href="#id40">8&nbsp;&nbsp;&nbsp;Python调试版</a></h1>

<p>Python can be built in a special "python debugging" configuration
that adds extra checks and instrumentation that can be very useful
for developers of extension modules.  The data structures used by
the debugging configuration contain additional members, so <strong>a
Python executable built with python debugging enabled cannot be
used with an extension module or library compiled without it, and
vice-versa.</strong></p>

<p>
Python可以用一个特殊的配置，“python调试”，进行构建，
它增加了额外的检查和测试，
对扩展模块的开发者非常有用。
调试配置所使用的数据结构，
包含了附加的成员，
因此，
<strong>用python调试模式构建的Python可执行程序，
不能使用非调试模式编译的扩展模块或库，
反之亦然。</strong>
</p>

<p>Since pre-built "python debugging" versions of the Python
executable and libraries are not supplied with most distributions
of Python,<a class="footnote-reference" href="#get-debug-build" id="id20"><sup>7</sup></a> and we didn't want to force our users
to build them, Boost.Build does not automatically enable python
debugging in its <tt class="docutils literal"><span class="pre">debug</span></tt> build variant (which is the default).
Instead there is a special build property called
<tt class="docutils literal"><span class="pre">python-debugging</span></tt> that, when used as a build property, will
define the right preprocessor symbols and select the right
libraries to link with.</p>

<p>
由于在大多数Python发行版中，
没有提供预建的“python调试”版的Python可执行程序和库
<a class="footnote-reference" href="#get-debug-build" id="id20"><sup>7</sup></a>，
而且我们不想强迫我们的用户去构建它们，
所以，在Boost.Python的<tt class="docutils literal"><span class="pre">debug</span></tt>版中
（默认是<tt class="docutils literal"><span class="pre">debug</span></tt>版），
没有自动打开python调试模式，
作为替代，有一个特别的构建属性，
称为<tt class="docutils literal"><span class="pre">python-debugging</span></tt>，
使用该构建属性时，
会定义正确的预处理符号，并选择正确的库进行链接。
</p>

<p>On unix-variant platforms, the debugging versions of Python's data
structures will only be used if the symbol <tt class="docutils literal"><span class="pre">Py_DEBUG</span></tt> is defined.
On many windows compilers, when extension modules are built with
the preprocessor symbol <tt class="docutils literal"><span class="pre">_DEBUG</span></tt>, Python defaults to force
linking with a special debugging version of the Python DLL.  Since
that symbol is very commonly used even when Python is not present,
Boost.Python temporarily undefines _DEBUG when Python.h
is #included from <tt class="docutils literal"><span class="pre">boost/python/detail/wrap_python.hpp</span></tt> - unless
<tt class="docutils literal"><span class="pre">BOOST_DEBUG_PYTHON</span></tt> is defined.  The upshot is that if you want
"python debugging" and you aren't using Boost.Build, you should make
sure <tt class="docutils literal"><span class="pre">BOOST_DEBUG_PYTHON</span></tt> is defined, or python debugging will be
suppressed.</p>

<p>
在类Unix平台上，
仅当定义了<tt class="docutils literal"><span class="pre">Py_DEBUG</span></tt>符号时，
才会使用调试版Python的数据结构。
在许多Windows编译器上，
当扩展模块用预处理符号
<tt class="docutils literal"><span class="pre">_DEBUG</span></tt>
构建时，
Python默认会强制链接一个特殊的，调试版本的Python DLL。
由于这个符号很常用（甚至没有Python时），所以，
在<tt class="docutils literal"><span class="pre">boost/python/detail/wrap_python.hpp</span></tt>中包含Python.h时，
Boost.Python暂时取消了_DEBUG定义
――除非定义了<tt class="docutils literal"><span class="pre">BOOST_DEBUG_PYTHON</span></tt>。
其结果是，如果你想要“python调试”，
并且你没有用Boost.Build，
你务必定义<tt class="docutils literal"><span class="pre">BOOST_DEBUG_PYTHON</span></tt>，
不然python调试会被禁用。
</p>

</div>

<div class="section" id="testing-boost-python">
<h1><a class="toc-backref" href="#id41">9&nbsp;&nbsp;&nbsp;Testing Boost.Python</a></h1>

<h1><a class="toc-backref" href="#id41">9&nbsp;&nbsp;&nbsp;测试Boost.Python</a></h1>

<p>To run the full test suite for Boost.Python, invoke <tt class="docutils literal"><span class="pre">bjam</span></tt> in the
<tt class="docutils literal"><span class="pre">libs/python/test</span></tt> subdirectory of your Boost distribution.</p>

<p>
在Boost的<tt class="docutils literal">
<span class="pre">libs/python/test</span></tt>子目录下， 
调用<tt class="docutils literal"><span class="pre">bjam</span></tt>，
以运行Boost.Python完整的测试包。
</p>

</div>

<div class="section" id="notes-for-mingw-and-cygwin-with-mno-cygwin-gcc-users">
<h1><a class="toc-backref" href="#id42">10&nbsp;&nbsp;&nbsp;Notes for MinGW (and Cygwin with -mno-cygwin) GCC Users</a></h1>

<h1><a class="toc-backref" href="#id42">10&nbsp;&nbsp;&nbsp;MinGW（及Cygwin -mno-cygwin）上GCC用户注意事项</a></h1>

<p>If you are using a version of Python prior to 2.4.1 with a MinGW
prior to 3.0.0 (with binutils-2.13.90-20030111-1), you will need to
create a MinGW-compatible version of the Python library; the one
shipped with Python will only work with a Microsoft-compatible
linker. Follow the instructions in the "Non-Microsoft" section of
the "building Extensions: Tips And Tricks" chapter in <a class="reference external" href="http://www.python.org/doc/current/inst/index.html">Installing
Python Modules</a> to create <tt class="docutils literal"><span class="pre">libpythonXX.a</span></tt>, where <tt class="docutils literal"><span class="pre">XX</span></tt>
corresponds to the major and minor version numbers of your Python
installation.</p>

<p>
如果你正在使用Python 2.4.1，
MinGW 3.0.0（和binutils-2.13.90-20030111-1）之前的版本，
您将需要创建一个与MinGW兼容的Python库；
Python发行随带的库只能用于微软兼容的连接器。
请转到<a class="reference external" href="http://www.python.org/doc/current/inst/index.html">安装Python模块</a>，
“构建扩展：提示和技巧”一章，
“非微软”一节，
按照指示来创建<tt class="docutils literal"><span class="pre">libpythonXX.a</span></tt>，
其中<tt class="docutils literal"><span class="pre">XX</span></tt>
为你的Python安装的主要和次要版本号。
</p>

<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Note that although we tested earlier versions of
Boost.Python with Python 2.2, and we don't <em>think</em> we've done
anything to break compatibility, this release of Boost.Python
may not have been tested with versions of Python earlier than
2.4, so we're not 100% sure that python 2.2 and 2.3 are
supported.

<p>
注意，尽管我们在Python 2.2上测试过Boost.Python的早期版本，
并且我们<em>认为</em>我们没有破坏兼容性，
但本次发行的Boost.Python可能没有在Python 2.4以前的版本上测试过，
所以我们不是100%的肯定能支持python 2.2和2.3。
</p>
</td></tr>

</tbody>
</table>
<table class="docutils footnote" frame="void" id="naming" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[2]</a></td><td><p class="first">Information about how to identify the
static and dynamic builds of Boost.Python:</p>

<p class="first">
有关如何确定Boost.Python的静态版和动态版：
</p>

<ul class="simple">
<li><a class="reference external" href="../../../more/getting_started/windows.html#library-naming">on Windows</a></li>
<li><a class="reference external" href="../../../more/getting_started/unix-variants.html#library-naming">on Unix variants</a></li>
</ul>

<ul class="simple">
<li><a class="reference external" href="../../../more/getting_started/windows.html#library-naming">在Windows上</a></li>
<li><a class="reference external" href="../../../more/getting_started/unix-variants.html#library-naming">在各种Unix上</a></li>
</ul>

</td></tr>
</tbody>
</table>

<table class="docutils footnote" frame="void" id="toolset-specific" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[3]</a></td><td>Because of the way most *nix platforms
share symbols among dynamically-loaded objects, I'm not certain
that extension modules built with different compiler toolsets
will always use different copies of the Boost.Python library
when loaded into the same Python instance.  Not using different
libraries could be a good thing if the compilers have compatible
ABIs, because extension modules built with the two libraries
would be interoperable.  Otherwise, it could spell disaster,
since an extension module and the Boost.Python library would
have different ideas of such things as class layout. I would
appreciate someone doing the experiment to find out what
happens.

<p>
在大多数*nix平台上，
在动态装载的对象之间，
由于符号共享方式的关系，
用不同编译工具构建的扩展模块，
当加载到同一Python实例时，
我不能肯定，
是否总是使用不同的Boost.Python库。

如果编译器都具有兼容的ABI，
那么，使用相同的库将是一件好事，
因为用两个库构建的两个扩展模块将可以互操作。 

否则将带来灾难，
因为扩展模块和Boost.Python库，
将对如类布局之类的事情，
有不同的想法。


如果有人做实验，以了解会发生什么，我将不胜感激。
</p>
</td></tr>

</tbody>
</table>
<table class="docutils footnote" frame="void" id="overwrite" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td><tt class="docutils literal"><span class="pre">configure</span></tt> overwrites the existing
<tt class="docutils literal"><span class="pre">user-config.jam</span></tt> in your home directory
(if any) after making a backup of the old version.

<p>
<tt class="docutils literal"><span class="pre">configure</span></tt>会覆盖主目录下现有的
<tt class="docutils literal"><span class="pre">user-config.jam</span></tt>（如果存在旧版本，会先备份它）。
</p>
</td></tr>

</tbody>
</table>
<table class="docutils footnote" frame="void" id="flavor" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[5]</a></td><td>Note that the <tt class="docutils literal"><span class="pre">&lt;target-os&gt;cygwin</span></tt> feature is
different from the <tt class="docutils literal"><span class="pre">&lt;flavor&gt;cygwin</span></tt> subfeature of the <tt class="docutils literal"><span class="pre">gcc</span></tt>
toolset, and you might need handle both explicitly if you also
have a MinGW GCC installed.

<p>
注意，特性<tt class="docutils literal"><span class="pre">&lt;target-os&gt;cygwin</span></tt>
有别于<tt class="docutils literal"><span class="pre">gcc</span></tt>
工具集的子特性
<tt class="docutils literal"><span class="pre">&lt;flavor&gt;cygwin</span></tt>，
如果你同时也安装了MinGW GCC，
你可能需要明确处理这两个特性。
</p>
</td></tr>

</tbody>
</table>
<table class="docutils footnote" frame="void" id="home-dir" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[6]</a></td><td><p class="first">Windows users, your home directory can be
found by typing:</p>

<pre class="literal-block">
ECHO %HOMEDRIVE%%HOMEPATH%
</pre>
<p class="last">into a <a class="reference external" href="../../../more/getting_started/windows.html#command-prompt">command prompt</a> window.</p>

<p>
Windows用户可以在
<a class="reference external" href="../../../more/getting_started/windows.html#command-prompt">命令提示符</a>窗口中，
键入以下命令显示自己的主目录：</p>

<pre class="literal-block">
ECHO %HOMEDRIVE%%HOMEPATH%
</pre>

</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="get-debug-build" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[7]</a></td><td>On Unix and similar platforms, a debugging
python and associated libraries are built by adding
<tt class="docutils literal"><span class="pre">--with-pydebug</span></tt> when configuring the Python build. On
Windows, the debugging version of Python is generated by
the &quot;Win32 Debug&quot; target of the Visual Studio project in the
PCBuild subdirectory of a full Python source code distribution.

<p>
在UNIX和类似平台上，
在配置Python构建时
添加<tt class="docutils literal"><span class="pre">--with-pydebug</span></tt>，
就可以构建调试版Python及相关库。
在Windows上，调试版本的Python，
是在Visual Studio项目中，
由“Win32 Debug”目标产生，
该项目文件位于
Python源代码发行目录的PCBuild子目录。
</p>
</td></tr>

</tbody>
</table>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="./building.rst">View document source</a>.
Generated on: 2007-07-02 13:46 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
<br>
翻译：<a href="http://blog.csdn.net/jq0123">金庆</a>
<br>
译文更新：2008.5.29
</div>
</body>
</html>

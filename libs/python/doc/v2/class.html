<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Cygwin (vers 1st September 2004), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" type="text/css" href="../boost.css">

  <title>Boost.Python - &lt;boost/python/class.hpp&gt;,
  &lt;boost/python/class_fwd.hpp&gt;</title>
</head>

<body link="#0000FF" vlink="#800080">
  <table border="0" cellpadding="7" cellspacing="0" width="100%" summary=
  "header">
    <tr>
      <td valign="top" width="300">
        <h3><a href="../../../../index.htm"><img height="86" width="277" alt=
        "C++ Boost" src="../../../../boost.png" border="0"></a></h3>
      </td>

      <td valign="top">
        <h1 align="center"><a href="../index.html">Boost.Python</a></h1>

        <h2 align="center">Headers &lt;boost/python/class.hpp&gt;,
        &lt;boost/python/class_fwd.hpp&gt;</h2>
      </td>
    </tr>
  </table>
  <hr>

  <h2>Contents</h2>

  <dl class="page-index">
    <dt><a href="#introduction">Introduction</a></dt>

    <dt><a href="#classes">Classes</a></dt>

    <dd>
      <dl class="page-index">
        <dt><a href="#class_-spec">Class template
        <code>class_</code></a></dt>

        <dd>
          <dl class="page-index">
            <dt><a href="#class_-spec-synopsis">Class <code>class_</code>
            synopsis</a></dt>

            <dt><a href="#class_-spec-ctors">Class <code>class_</code>
            constructors</a></dt>

            <dt><a href="#class_-spec-modifiers">Class <code>class_</code>
            modifier functions</a></dt>
          </dl>
        </dd>

        <dt><a href="#bases-spec">Class template <code>bases</code></a></dt>

        <dd>
          <dl class="page-index">
            <dt><a href="#bases-spec-synopsis">Class template
            <code>bases</code> synopsis</a></dt>
          </dl>
        </dd>
      </dl>
    </dd>

    <dt><a href="#examples">Example(s)</a></dt>
  </dl>
  <hr>

  <h2><a name="introduction" id="introduction"></a>Introduction</h2>

  <p><code>&lt;boost/python/class.hpp&gt;</code> defines the interface
  through which users expose their C++ classes to Python. It declares the
  <code>class_</code> class template, which is parameterized on the class
  type being exposed. It also exposes the <code>init</code>,
  <code>optional</code> and <code>bases</code> utility class templates, which
  are used in conjunction with <code>class_</code>.</p>
  
  <p>
  <code>&lt;boost/python/class.hpp&gt;</code>定义了一个接口，
  用户通过该接口向Python导出C++类。
  
  它声明了<code>class_</code>类模板，其参数为待导出的类类型。
  
  它同时导出了<code>init</code>、
  <code>optional</code>和<code>bases</code>工具类模板，
  以结合<code>class_</code>使用。
  </p>

  <p><code>&lt;boost/python/class_fwd.hpp&gt;</code> contains a forward
  declaration of the <code>class_</code> class template.</p>
  
  <p>
  <code>&lt;boost/python/class_fwd.hpp&gt;</code>包含了
  <code>class_</code>类模板的前向声明。
  </p>

  <h2><a name="classes" id="classes"></a>Classes</h2>

  <h3><a name="class_-spec" id="class_-spec"></a>Class template
  <code>class_&lt;T,&nbsp;<font color="#007F00">Bases,&nbsp;HeldType,
  NonCopyable</font>&gt;</code></h3>

  <p>Creates a Python class associated with the C++ type passed as its first
  parameter. Although it has four template parameters, only the first one is
  required. The three optional arguments can actually be supplied
  <font color="#007F00"><b>in any order</b></font>; Boost.Python determines
  the role of the argument from its type.<br>
  <br></p>
  
  <p>
  创建一个Python类，该类与作为第一参数传入的C++类型相关联。
  
  虽然它有四个模板参数，但只有第一个是必需的。
  
  另外三个可选参数实际上可以<font color="#007F00"><b>任意次序</b></font>提供；
  Boost.Python根据参数的类型决定其作用。
  </p>

  <table border="1" summary="class_ template parameters">
    <tr>
      <th>Template Parameter
      
      <p>模板参数</p>
      
      </th>

      <th>Requirements
      
      <p>要求</p>
      
      </th>

      <th>Semantics
      
      <p>语义</p>
      
      </th>

      <th>Default
      
      <p>默认值</p>
      
      </th>
    </tr>

    <tr>
      <td><code>T</code></td>

      <td>A class type.
      
      <p>类类型。</p>
     
      </td>

      <td>The class being wrapped
      
      <p>待封装的类</p>
     
      </td>
    </tr>

    <tr>
      <td><code><font color="#007F00">Bases</font></code></td>

      <td>A specialization of <a href=
      "#bases-spec"><code>bases&lt;</code>...<code>&gt;</code></a> which
      specifies previously-exposed C++ base classes of <code>T</code><a href=
      "#footnote_1">[1]</a>.
      
      <p><a href=
      "#bases-spec"><code>bases&lt;</code>...<code>&gt;</code></a>的特化，
      用于指定<code>T</code>已经导出的C++基类<a href=
      "#footnote_1">[1]</a>。
      </p>
      
      </td>

      <td>Registers <code>from_python</code> conversions from wrapped
      <code>T</code> instances to each of its exposed direct and indirect
      bases. For each polymorphic base <code>B</code>, registers conversions
      from indirectly-held wrapped <code>B</code> instances to
      <code>T</code>.
      
      <p>注册<code>from_python</code>转换：
      从被封装的<code>T</code>实例，
      到它每个已导出的直接和间接的基类。
      
      对于每个多态基类<code>B</code>，注册转换：
      从间接持有的封装的<code>B</code>实例，到<code>T</code>。
      </p>
    
      </td>

      <td><code><a href="#bases-spec">bases&lt;&gt;</a></code></td>
    </tr>

    <tr>
      <td><code><font color="#007F00">HeldType</font></code></td>

      <td>Must be <code>T</code>, a class derived from <code>T</code>, or a
      <a href="Dereferenceable.html">Dereferenceable</a> type for which
      <code><a href=
      "pointee.html#pointee-spec">pointee</a>&lt;HeldType&gt;::type</code> is
      <code>T</code> or a class derived from <code>T</code>.
      
      <p>必须为<code>T</code>，或<code>T</code>的派生类，
      或<a href="Dereferenceable.html">可解引用</a>类型，并且其
      <code><a href=
      "pointee.html#pointee-spec">pointee</a>&lt;HeldType&gt;::type</code>
      是<code>T</code>或<code>T</code>的派生类。
      </p>
      
      </td>

      <td>Specifies the type that is actually embedded in a Python object
      wrapping a <code>T</code> instance when <code>T</code>'s constructor is
      called or when a <code>T</code> or <code>T*</code> is converted to
      Python without the use of <a href=
      "http://www.boost.org/libs/python/doc/v2/callbacks.html#argument_handling">
      <code>ptr</code></a>, <a href=
      "http://www.boost.org/libs/python/doc/v2/callbacks.html#argument_handling">
      <code>ref</code></a>, or <a href="CallPolicies.html">Call Policies</a>
      such as <code><a href=
      "return_internal_reference.html">return_internal_reference</a></code>.
      More details <a href="#HeldType">below</a>.
      
      <p>指定实际内嵌于Python对象的类型，
      当调用<code>T</code>的构造函数时，
      或当<code>T</code>或<code>T*</code>转换到Python，
      并且不使用<a href=
      "http://www.boost.org/libs/python/doc/v2/callbacks.html#argument_handling"
      ><code>ptr</code></a>、<a href=
      "http://www.boost.org/libs/python/doc/v2/callbacks.html#argument_handling"
      ><code>ref</code></a>、或<code><a href=
      "return_internal_reference.html">return_internal_reference</a></code>
      这样的<a href="CallPolicies.html">Call Policies</a>时，
      该类型将封装<code>T</code>的实例。
      </p>
      
      </td>

      <td><code>T</code></td>
    </tr>

    <tr>
      <td><code><font color="#007F00">NonCopyable</font></code></td>

      <td>If supplied, must be <a href=
      "../../../utility/utility.htm#Class_noncopyable">boost::noncopyable</a>.
      
      <p>如果提供，必须为<a href=
      "../../../utility/utility.htm#Class_noncopyable">boost::noncopyable</a>
      </p>
      
      </td>

      <td>Suppresses automatic registration of <code>to_python</code>
      conversions which copy <code>T</code> instances. Required when
      <code>T</code> has no publicly-accessible copy constructor.
      
      <p>抑制复制<code>T</code>实例的<code>to_python</code>转换的自动注册。
      当<code>T</code>没有可公有访问的拷贝构造函数时，它是必需的。
      </p>
      
      </td>

      <td>An unspecified type other than
      <code>boost::noncopyable</code>.
      
      <p>不同于<code>boost::noncopyable</code>的未指定类型。</p>
      
      </td>
    </tr>
  </table>

  <h4><a name="HeldType" id="HeldType">HeldType Semantics</a></h4>

  <ol>
    <li>If <code>HeldType</code> is derived from T, its exposed
    constructor(s) must accept an initial <code>PyObject*</code> argument
    which refers back to the Python object that contains the
    <code>HeldType</code> instance, as shown in <a href=
    "call_method.html#examples">this example</a>. This argument is not
    included in the <em><a href=
    "init.html#init-expressions">init-expression</a></em> passed to <a href=
    "#class_-spec-modifiers"><code>def(init_expr)</code></a>, below, nor is
    it passed explicitly by users when Python instances of <code>T</code> are
    created. This idiom allows C++ virtual functions which will be overridden
    in Python to access the Python object so the Python method can be
    invoked. Boost.Python automatically registers additional converters which
    allow wrapped instances of <code>T</code> to be passed to wrapped C++
    functions expecting <code>HeldType</code> arguments.
    
    <p>
    如果<code>HeldType</code>派生自T，其导出的构造函数必须接受一个初始的
    <code>PyObject*</code>参数，
    该参数反向引用包含该<code>HeldType</code>实例的Python对象，
    如<a href=
    "call_method.html#examples">本例</a>所示。
    
    当<code>T</code>的Python实例创建时，
    该参数没有包含在<em><a href=
    "init.html#init-expressions">init-expression</a></em>中，
    并传递到下面的<a href=
    "#class_-spec-modifiers"><code>def(init_expr)</code></a>中，
    也没有被用户显式传递。
    
    该惯用法允许C++虚函数在Python中覆盖后，
    可以访问该Python对象，
    并因此可以调用该Python方法。
    
    Boost.Python自动注册附加的转换器，它们允许封装的<code>T</code>实例
    传入封装的期待<code>HeldType</code>参数的C++函数。
    </p>
    
    </li>

    <li>Because Boost.Python will always allow wrapped instances of
    <code>T</code> to be passed in place of <code>HeldType</code> arguments,
    specifying a smart pointer for <code>HeldType</code> allows users to pass
    Python <code>T</code> instances where a smart pointer-to-<code>T</code>
    is expected. Smart pointers such as <code>std::auto_ptr&lt;&gt;</code> or
    <code><a href=
    "../../../smart_ptr/shared_ptr.htm">boost::shared_ptr&lt;&gt;</a></code>
    which contain a nested type <code>element_type</code> designating the
    referent type are automatically supported; additional smart pointer types
    can be supported by specializing <a href=
    "pointee.html#pointee-spec">pointee&lt;HeldType&gt;</a>.
    
    <p>
    因为Boost.Python将总是允许封装的<code>T</code>实例
    传给<code>HeldType</code>参数，
    为<code>HeldType</code>指定一个智能指针，允许用户
    在需要<code>T</code>的智能指针的地方
    传入Python <code>T</code>实例。
    
    如<code>std::auto_ptr&lt;&gt;</code>或<code><a href=
    "../../../smart_ptr/shared_ptr.htm">boost::shared_ptr&lt;&gt;</a></code>
    这样，具有嵌套类型<code>element_type</code>作为类型指示的智能指针，
    它们是自动获得支持的。
    
    其他的智能指针类型可以通过指定<a href=
    "pointee.html#pointee-spec">pointee&lt;HeldType&gt;</a>
    来获得支持。
    </p>
    
    </li>

    <li>As in case 1 above, when <code>HeldType</code> is a smart pointer to
    a class derived from <code>T</code>, the initial <code>PyObject*</code>
    argument must be supplied by all of <code>HeldType</code>'s exposed
    constructors.
    
    <p>
    如上情况1，当<code>HeldType</code>是指向<code>T</code>的派生类的智能指针，
    <code>HeldType</code>所有导出的构造函数必须提供
    最初的<code>PyObject*</code>参数。
    </p>
    
    </li>

    <li>Except in cases 1 and 3, users may optionally specify that T itself
    gets initialized with a similar initial <code>PyObject*</code> argument
    by specializing <a href=
    "has_back_reference.html#has_back_reference-spec">has_back_reference&lt;T&gt;</a>.
    
    <p>
    除了情况1和3，用户可选择性地
    通过指定<a href=
    "has_back_reference.html#has_back_reference-spec">has_back_reference&lt;T&gt;</a>，
    来指示T用一个类似的最初的<code>PyObject*</code>参数进行初始化。
    </p>
    
    </li>
  </ol>

  <h4><a name="class_-spec-synopsis" id="class_-spec-synopsis"></a>Class
  template <code>class_</code> synopsis</h4>
  <pre>
namespace boost { namespace python
{
  template &lt;class T
   <font color="#007F00">   , class Bases = bases&lt;&gt;
            , class HeldType = T
            , class NonCopyable = <i>unspecified</i>
           &gt;
</font>  class class_ : public <a href="object.html#object-spec">object</a>
  {
    // Constructors with default __init__
    class_(char const* name);
    class_(char const* name, char const* docstring);

    // Constructors, specifying non-default __init__
    template &lt;class Init&gt;
    class_(char const* name, Init);
    template &lt;class Init&gt;
    class_(char const* name, char const* docstring, Init);

    // Exposing additional __init__ functions
    template &lt;class Init&gt;
    class_&amp; def(Init);

    // defining methods
    template &lt;class F&gt;
    class_&amp; def(char const* name, F f);
    template &lt;class Fn, class A1&gt;
    class_&amp; def(char const* name, Fn fn, A1 const&amp;);
    template &lt;class Fn, class A1, class A2&gt;
    class_&amp; def(char const* name, Fn fn, A1 const&amp;, A2 const&amp;);
    template &lt;class Fn, class A1, class A2, class A3&gt;
    class_&amp; def(char const* name, Fn fn, A1 const&amp;, A2 const&amp;, A3 const&amp;);

    // declaring method as static
    class_&amp; staticmethod(char const* name);
    
    // exposing operators
    template &lt;<i>unspecified</i>&gt;
    class_&amp; def(<a href=
"operators.html#operator_-spec">detail::operator_</a>&lt;unspecified&gt;);

    // Raw attribute modification
    template &lt;class U&gt;
    class_&amp; setattr(char const* name, U const&amp;);

    // exposing data members
    template &lt;class D&gt;
    class_&amp; def_readonly(char const* name, D T::*pm);

    template &lt;class D&gt;
    class_&amp; def_readwrite(char const* name, D T::*pm);

    // exposing static data members
    template &lt;class D&gt;
    class_&amp; def_readonly(char const* name, D const&amp; d);
    template &lt;class D&gt;
    class_&amp; def_readwrite(char const* name, D&amp; d);

    // property creation
    template &lt;class Get&gt;
    void add_property(char const* name, Get const&amp; fget, char const* doc=0);
    template &lt;class Get, class Set&gt;
    void add_property(
        char const* name, Get const&amp; fget, Set const&amp; fset, char const* doc=0);

    template &lt;class Get&gt;
    void add_static_property(char const* name, Get const&amp; fget);
    template &lt;class Get, class Set&gt;
    void add_static_property(char const* name, Get const&amp; fget, Set const&amp; fset);

    // pickle support
    template &lt;typename PickleSuite&gt;
    self&amp; def_pickle(PickleSuite const&amp;);
    self&amp; enable_pickling();
  };
}}
</pre>

  <h4><a name="class_-spec-ctors" id="class_-spec-ctors"></a>Class template
  <code>class_</code> constructors</h4>
  <pre>
class_(char const* name);
class_(char const* name, char const* docstring);
template &lt;class Init&gt;
class_(char const* name, Init init_spec);
template &lt;class Init&gt;
class_(char const* name, char const* docstring, Init init_spec);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>name</code> is an <a href=
    "definitions.html#ntbs">ntbs</a> which conforms to Python's <a href=
    "http://www.python.org/doc/current/ref/identifiers.html">identifier
    naming rules</a>. If <code>docstring</code> is supplied, it must be an
    <a href="definitions.html#ntbs">ntbs</a>. If <code>init_spec</code> is
    supplied, it must be either the special enumeration constant
    <code>no_init</code> or an <a href=
    "init.html#init-expressions">init-expression</a> compatible with
    <code>T</code>.</dt>

    <br>
    
    <dt><b>要求：</b><code>name</code>是一个<a href=
    "definitions.html#ntbs">ntbs</a>，并遵循Python的<a href=
    "http://www.python.org/doc/current/ref/identifiers.html">标识符命名规则</a>。
    
    如果有<code>docstring</code>，它必须是一个
    <a href="definitions.html#ntbs">ntbs</a>。
    
    如果有<code>init_spec</code>，它必须是特殊的枚举常量
    <code>no_init</code>，或是一个与<code>T</code>兼容的<a href=
    "init.html#init-expressions">init-expression</a>。
    </dt>
    
    <br>

    <dt><b>Effects:</b> Constructs a <code>class_</code> object holding a
    Boost.Python extension class named <code>name</code>. The
    <code>name</code>d attribute of the <a href=
    "scope.html#introduction">current scope</a> is bound to the new extension
    class.</dt>
    
    <br>

    <dt><b>效果：</b>构造一个<code>class_</code>对象，它持有一个
    Boost.Python扩展类，名为<code>name</code>。
    <a href=
    "scope.html#introduction">当前域（scope）</a>的
    <code>name</code>属性是绑定于该新扩展类的。
    </dt>

    <br>
    
    <dd>
      <ul>
        <li>If supplied, the value of <code>docstring</code> is bound to the
        <code>__doc__</code> attribute of the extension class.</li>

        <li>If <code>init_spec</code> is <code>no_init</code>, a special
        <code>__init__</code> function is generated which always raises a
        Python exception. Otherwise, <code>this-&gt;def(init_spec)</code> is
        called.</li>

        <li>If <code>init_spec</code> is not supplied,
        <code>this-&gt;def(init&lt;&gt;())</code> is called.</li>
      </ul>
      
      <br>
      
      <ul>
        <li>如果有<code>docstring</code>，它的值绑定于扩展类的
        <code>__doc__</code>属性。</li>

        <li>如果<code>init_spec</code>为<code>no_init</code>，则生成一个特殊的
        <code>__init__</code>函数，该函数总是引发一个Python异常。
        否则就调用<code>this-&gt;def(init_spec)</code>。
        </li>

        <li>如果没有<code>init_spec</code>，则调用
        <code>this-&gt;def(init&lt;&gt;())</code>。</li>
      </ul>
      
    </dd>

    <br>
    
    <dt><b>Rationale:</b>Allowing the user to specify constructor arguments
    in the <code>class_&lt;&gt;</code> constructor helps her to avoid the
    common run-time errors which result from invoking wrapped member
    functions without having exposed an <code>__init__</code> function which
    creates the requisite <code>T</code> instance. Types which are not
    default-constructible will cause a compile-time error unless
    <code>Init</code> is supplied. The user must always supply
    <code>name</code> as there is currently no portable method to derive the
    text of the class name from its type.</dt>

    <br>
        
    <dt><b>原理：</b>允许用户在<code>class_&lt;&gt;</code>构造函数中
    指定构造函数的参数，让它避免了常见的运行时错误；
    如果没有导出<code>__init__</code>函数，
    没有该函数创建必要的<code>T</code>实例，
    调用封装的成员函数将导致这种错误。
    
    除非提供<code>Init</code>，不可缺省构造的类型将会导致一个编译时错误。

    用户必须总是提供<code>name</code>，
    因为目前没有可移植的方法从类的类型得出其类名的文本。
    </dt>
    
  </dl>

  <h4><a name="class_-spec-modifiers" id="class_-spec-modifiers"></a>Class
  template <code>class_</code> modifier functions</h4>
  <pre>
template &lt;class Init&gt;
class_&amp; def(Init init_expr);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>init_expr</code> is the result of an <a href=
    "init.html#init-expressions">init-expression</a> compatible with
    <code>T</code>.</dt>

    <dt><b>Effects:</b> For each <a href="init.html#init-expressions">valid
    prefix</a> <em>P</em> of <code>Init</code>, adds an
    <code>__init__(</code>...<code>)</code> function overload to the
    extension class accepting <em>P</em> as arguments. Each overload
    generated constructs an object of <code>HeldType</code> according to the
    semantics described <a href="#HeldType">above</a>, using a copy of
    <code>init_expr</code>'s <a href="CallPolicies.html">call policies</a>.
    If the longest <a href="init.html#init-expressions">valid prefix</a> of
    <code>Init</code> contains <em>N</em> types and <code>init_expr</code>
    holds <em>M</em> keywords, an initial sequence of the keywords are used
    for all but the first <em>N</em> - <em>M</em> arguments of each
    overload.</dt>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <dt><b>Rationale:</b> Allows users to easily expose a class' constructor
    to Python.</dt>
  </dl>
  
  <dl class="function-semantics">
    <dt><b>要求：</b><code>init_expr</code>是与<code>T</code>兼容的<a href=
    "init.html#init-expressions">init-expression</a>的结果。
    </dt>

    <dt><b>效果：</b>对于<code>Init</code>的每个
    <a href="init.html#init-expressions">valid
    prefix</a> <em>P</em>，
    向接受参数<em>P</em>的扩展类添加
    <code>__init__(</code>...<code>)</code>函数重载。
    
    每个生成的重载，
    对应于<a href="#HeldType">上述</a>的语义，
    使用<code>init_expr</code>的<a href="CallPolicies.html">调用策略</a>，
    构造一个<code>HeldType</code>对象。
    
    如果<code>Init</code>最长的
    <a href="init.html#init-expressions">valid prefix</a>
    包含<em>N</em>个类型，并且<code>init_expr</code>
    持有<em>M</em>个关键字，
    对于每个重载，
    就对所有参数使用一个关键字的初始化序列，
    除了头部 <em>N</em> - <em>M</em> 个参数。
    </dt>

    <dt><b>返回：</b> <code>*this</code></dt>

    <dt><b>原理：</b>允许用户方便地向Python导出类的构造函数。
    </dt>
  </dl><br>
  
  <pre>
template &lt;class F&gt;
class_&amp; def(char const* name, Fn fn);
template &lt;class Fn, class A1&gt;
class_&amp; def(char const* name, Fn fn, A1 const&amp; a1);
template &lt;class Fn, class A1, class A2&gt;
class_&amp; def(char const* name, Fn fn, A1 const&amp; a1, A2 const&amp; a2);
template &lt;class Fn, class A1, class A2, class A3&gt;
class_&amp; def(char const* name, Fn fn, A1 const&amp; a1, A2 const&amp; a2, A3 const&amp; a3);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>name</code> is an <a href=
    "definitions.html#ntbs">ntbs</a> which conforms to Python's <a href=
    "http://www.python.org/doc/current/ref/identifiers.html">identifier
    naming rules</a>.</dt>

    <br>
     
    <dt><b>要求：</b><code>name</code>是一个<a href=
    "definitions.html#ntbs">ntbs</a>，并符合Python<a href=
    "http://www.python.org/doc/current/ref/identifiers.html">标识符命名规则</a>。
    </dt>
    
    <br>

    <dd>
      <ul>
        <li>If <code>a1</code> is the result of an <a href=
        "overloads.html#overload-dispatch-expression"><em>overload-dispatch-expression</em></a>,
        only the second form is allowed and fn must be a pointer to function
        or pointer to member function whose <a href="definitions.html#arity">
          arity</a> is the same as A1's <a href=
          "overloads.html#overload-dispatch-expression"><em>maximum
          arity</em></a>.
          
        <p>如果<code>a1</code>是<a href=
        "overloads.html#overload-dispatch-expression"><em>overload-dispatch-expression</em></a>
        的结果，只有第二个形式是允许的，并且fn必须是函数指针，或成员函数指针，
        该函数的<a href="definitions.html#arity">元数</a>与
        A1的<a href=
          "overloads.html#overload-dispatch-expression"><em>最大元数</em></a>
        相同。
        </p>

          <dl>
            <dt><b>Effects:</b> For each prefix <em>P</em> of
            <code>Fn</code>'s sequence of argument types, beginning with the
            one whose length is <code>A1</code>'s <a href=
            "overloads.html#overload-dispatch-expression"><em>minimum
            arity</em></a>, adds a
            <code><em>name</em>(</code>...<code>)</code> method overload to
            the extension class. Each overload generated invokes
            <code>a1</code>'s call-expression with <em>P</em>, using a copy
            of <code>a1</code>'s <a href="CallPolicies.html">call
            policies</a>. If the longest valid prefix of <code>A1</code>
            contains <em>N</em> types and <code>a1</code> holds <em>M</em>
            keywords, an initial sequence of the keywords are used for all
            but the first <em>N</em> - <em>M</em> arguments of each
            overload.</dt>
          </dl>

          <br>
          
          <dl>
            <dt><b>效果：</b>对于参数类型的
            <code>Fn</code>序列的每个前缀<em>P</em>，
            开始的一个，
            长度为<code>A1</code>的<a href=
            "overloads.html#overload-dispatch-expression"><em>最大元数</em></a>，
            
            向扩展类添加一个
            <code><em>name</em>(</code>...<code>)</code>方法重载。

            每个生成的重载调用<code>a1</code>的call-expression
            与<em>P</em>，
            使用
            <code>a1</code>的<a href="CallPolicies.html">调用策略</a>
            的一个拷贝。
            
            如果<code>A1</code>的最长有效前缀包含
            <em>N</em>个类型，
            并且<code>a1</code>持有<em>M</em>个关键字，
            就为所有参数使用关键字的初始化序列，
            除了每个重载头部的 <em>N</em> - <em>M</em> 个参数。
            <br>
            </dt>
          </dl>
          
          <br>
          
        </li>

        <li>Otherwise, a single method overload is built around fn, which
        must not be null:
        
        <p>
        否则，会围绕fn建立一个单一的方法重载，该重载不能为空。
        </p>

          <ul>
            <li>If fn is a function pointer, its first argument must be of
            the form <code>U</code>, <code>U <em>cv</em>&amp;</code>, <code>U
            <em>cv</em>*</code>, or <code>U <em>cv</em>* const&amp;</code>,
            where <code>T*</code> is convertible to <code>U*</code>, and
            <code>a1</code>-<code>a3</code>, if supplied, may be selected in
            any order from the table below.
            
            <p>
            如果fn是个函数指针，它的第一参数就必须形如
            <code>U</code>、<code>U <em>cv</em>&amp;</code>、<code>U
            <em>cv</em>*</code>，或<code>U <em>cv</em>* const&amp;</code>，
            其中<code>T*</code>可转换成<code>U*</code>，
            并且如果有<code>a1</code>-<code>a3</code>，
            它们可以任意次序从下表中选择。
            </p>
            
            </li>

            <li>Otherwise, if fn is a member function pointer, its target
            must be <code>T</code> or one of its public base classes, and
            <code>a1</code>-<code>a3</code>, if supplied, may be selected in
            any order from the table below.
            
            <p>
            否则，如果fn是个成员函数指针，它的目标必须是<code>T</code>
            或它的公有基类之一，并且如果有<code>a1</code>-<code>a3</code>，
            它们可以任意次序从下表选择。
            </p>
            
            </li>

            <li>Otherwise, <code>Fn</code> must be [derived from]
            <code><a href="object.html#object-spec">object</a></code>, and
            <code>a1-a2</code>, if supplied, may be selcted in any order from
            the first two rows of the table below. To be useful,
            <code>fn</code> should be <a href=
            "http://www.python.org/doc/current/lib/built-in-funcs.html#l2h-6">
            callable</a>.
            
            <p>
            否则，<code>Fn</code>必须是[派生自]
            <code><a href="object.html#object-spec">object</a></code>，
            并且如果有<code>a1-a2</code>，
            它们可以任意次序从下表的前两行中选择。
            
            为了可用，<code>fn</code>应该是<a href=
            "http://www.python.org/doc/current/lib/built-in-funcs.html#l2h-6"
            >可调用的</a>。
            </p>
            
            </li>
          </ul>

          <table border="1" summary="def() optional arguments">
            <tr>
              <th>Memnonic Name
              
              <p>助记名</p>
              
              </th>

              <th>Requirements/Type properties
              
              <p>要求/类型属性</p>
              
              </th>

              <th>Effects
              
              <p>效果</p>
              
              </th>
            </tr>

            <tr>
              <td>docstring</td>

              <td>Any <a href="definitions.html#ntbs">ntbs</a>.</td>

              <td>Value will be bound to the <code>__doc__</code> attribute
              of the resulting method overload. If an earlier overload
              supplied a docstring, two newline characters and the new
              docstring are appended to it.
              
              <p>
              值将绑定为由些产生的方法重载的<code>__doc__</code>属性。
              
              如果较早的重载已有docstring，
              则在它之后附加两个换行符及这个新的docstring。
              </p>
              
              </td>
            </tr>

            <tr>
              <td>policies</td>

              <td>A model of <a href=
              "CallPolicies.html">CallPolicies</a></td>

              <td>A copy will be used as the call policies of the resulting
              method overload.
              
              <p>一个副本将用作结果的方法重载的调用策略。
              </p>
              
              </td>
            </tr>

            <tr>
              <td>keywords</td>

              <td>The result of a <a href=
              "args.html#keyword-expression"><em>keyword-expression</em></a>
              specifying no more arguments than the <a href=
              "definitions.html#arity">arity</a> of <code>fn</code>.
              
              <p><a href=
              "args.html#keyword-expression"><em>keyword-expression</em></a>
              的结果，指定的参数不多于<code>fn</code>的<a href=
              "definitions.html#arity">元数</a>。
              </p>
              
              </td>

              <td>A copy will be used as the call policies of the resulting
              method overload.
              
              <p>一个副本将用作结果的方法重载的调用策略。
              </p>
              
              </td>
            </tr>
          </table>
        </li>
      </ul>
    </dd>

    <dt><b>Returns:</b> <code>*this</code></dt>
  </dl>
  <pre>
class_&amp; staticmethod(char const* name);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>name</code> is an <a href=
    "definitions.html#ntbs">ntbs</a> which conforms to Python's <a href=
    "http://www.python.org/doc/current/ref/identifiers.html">identifier
    naming rules</a>, and corresponds to a method whose overloads have all
    been defined.</dt>

    <br>
    
    <dt><b>要求：</b><code>name</code>是个<a href=
    "definitions.html#ntbs">ntbs</a>，并符合Python的<a href=
    "http://www.python.org/doc/current/ref/identifiers.html">标识符命名规则</a>，
    它对应于一个所有重载都已定义的方法。
    </dt>

    <br>
    
    <dt><b>Effects:</b> Replaces the existing named attribute <i>x</i> with
    the result of invoking <code>staticmethod(</code><i>x</i><code>)</code>
    in Python. Specifies that the corresponding method is static and
    therefore no object instance will be passed to it. This is equivalent to
    the Python statement:</dt>

    <br>
    
    <dt><b>效果：</b>
    用Python调用<code>staticmethod(</code><i>x</i><code>)</code>的结果，
    代替现存已命名的属性<i>x</i>。
    指明对应的方法是静态的，并因此不会向它传递对象实例。
    这等效于Python语句：
    </dt>

    <dd>
      <pre>
setattr(self, name, staticmethod(getattr(self, name)))
</pre>
    </dd>

    <dt><b>Note:</b> Attempting to invoke <code>def(name,...)</code> after
    invoking <code>staticmethod(name)</code> will <a href=
    "definitions.html#raise">raise</a> a RuntimeError.</dt>

    <br>
    
    <dt><b>注意：</b>试图在<code>staticmethod(name)</code>之后
    调用<code>def(name,...)</code>将<a href=
    "definitions.html#raise">引发</a>RuntimeError。</dt>

    <br>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <br>
    
    <dt><b>返回：</b><code>*this</code></dt>
    
  </dl><br>
  <pre>
template &lt;<i>unspecified</i>&gt;
class_&amp; def(<a href=
"operators.html#operator_-spec">detail::operator_</a>&lt;unspecified&gt;);
</pre>

  <dl class="function-semantics">
    <dt><b>Effects:</b> Adds a Python <a href=
    "http://www.python.org/doc/ref/specialnames.html">special method</a> as
    described <a href="operators.html">here</a>.</dt>

    <dt><b>Returns:</b> <code>*this</code></dt>
  </dl>
  
  <dl class="function-semantics">
    <dt><b>效果：</b>添加一个Python<a href=
    "http://www.python.org/doc/ref/specialnames.html">特殊方法</a>，
    <a href="operators.html">如此所述</a>。</dt>

    <dt><b>返回：</b><code>*this</code></dt>
  </dl>
  
  <pre>
template &lt;class U&gt;
class_&amp; setattr(char const* name, U const&amp; u);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>name</code> is an <a href=
    "definitions.html#ntbs">ntbs</a> which conforms to Python's <a href=
    "http://www.python.org/doc/current/ref/identifiers.html">identifier
    naming rules</a>.</dt>
    
    <br>
    
    <dt><b>要求：</b><code>name</code>是个<a href=
    "definitions.html#ntbs">ntbs</a>，并符合Python的<a href=
    "http://www.python.org/doc/current/ref/identifiers.html">标识符命名规则</a>。
    </dt>
    
    <br>

    <dt><b>Effects:</b> Converts u to Python and adds it to the attribute
    dictionary of the extension class:</dt>
    
    <br>
    
    <dt><b>效果：</b>将u转换到Python，并将它添加到扩展类的属性字典：</dt>

    <dd>
      <blockquote>
        <code><a href=
        "http://www.python.org/doc/current/api/object.html#l2h-166">PyObject_SetAttrString</a>(this-&gt;ptr(),
        name, <a href=
        "object.html#object-spec-ctors">object</a>(u).ptr());</code>
      </blockquote>
    </dd>

    <dt><b>Returns:</b> <code>*this</code></dt>
  </dl><br>
  <pre>
template &lt;class Get&gt;
void add_property(char const* name, Get const&amp; fget, char const* doc=0);
template &lt;class Get, class Set&gt;
void add_property(
        char const* name, Get const&amp; fget, Set const&amp; fset, char const* doc=0);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>name</code> is an <a href=
    "definitions.html#ntbs">ntbs</a> which conform to Python's <a href=
    "http://www.python.org/doc/current/ref/identifiers.html">identifier
    naming rules</a>.</dt>

    <dt><b>Effects:</b> Creates a new Python <a href=
    "http://www.python.org/2.2.2/descrintro.html#property"><code>property</code></a>
    class instance, passing <code><a href=
    "object.html#object-spec-ctors">object</a>(fget)</code> (and
    <code><a href="object.html#object-spec-ctors">object</a>(fset)</code> in
    the second form) with an (optional) docstring <code>doc</code> to its
    constructor, then adds that property to the Python class object under
    construction with the given attribute <code>name</code>.</dt>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <dt><b>Rationale:</b> Allows users to easily expose functions that can be
    invoked from Python with attribute access syntax.</dt>
  </dl>

  <dl class="function-semantics">
    <dt><b>要求：</b><code>name</code>是个<a href=
    "definitions.html#ntbs">ntbs</a>，并符合Python的<a href=
    "http://www.python.org/doc/current/ref/identifiers.html">标识符命名规则</a>。
    </dt>

    <dt><b>效果：</b>创建一个新的Python <a href=
    "http://www.python.org/2.2.2/descrintro.html#property"><code>property</code></a>
    类实例，向它的构造函数传入<code><a href=
    "object.html#object-spec-ctors">object</a>(fget)</code>（及
    <code><a href="object.html#object-spec-ctors">object</a>(fset)</code>
    的第二种形式），并附带（可选的）docstring <code>doc</code>，
    然后将此属性以所给定的属性名<code>name</code>，
    加入所构造的Python类对象。</dt>

    <dt><b>返回：</b><code>*this</code></dt>

    <dt><b>原理：</b>允许用户方便地导出可在Python中以属性访问语法调用的函数。
    </dt>
  </dl><br>
  
  <pre>
template &lt;class Get&gt;
void add_static_property(char const* name, Get const&amp; fget);
template &lt;class Get, class Set&gt;
void add_static_property(char const* name, Get const&amp; fget, Set const&amp; fset);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>name</code> is an <a href=
    "definitions.html#ntbs">ntbs</a> which conforms to Python's <a href=
    "http://www.python.org/doc/current/ref/identifiers.html">identifier
    naming rules</a>.</dt>

    <dt><b>Effects:</b> Creates a Boost.Python.StaticProperty object, passing
    <code><a href="object.html#object-spec-ctors">object</a>(fget)</code>
    (and <code><a href=
    "object.html#object-spec-ctors">object</a>(fset)</code> in the second
    form) to its constructor, then adds that property to the Python class
    under construction with the given attribute <code>name</code>.
    StaticProperty is a special subclass of Python's <a href=
    "http://www.python.org/2.2.2/descrintro.html#property"><code>property</code></a>
    class which can be called without an initial <code>self</code>
    argument.</dt>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <dt><b>Rationale:</b> Allows users to easily expose functions that can be
    invoked from Python with static attribute access syntax.</dt>
  </dl>
  
  <dl class="function-semantics">
    <dt><b>要求：</b><code>name</code>是个<a href=
    "definitions.html#ntbs">ntbs</a>，并符合Python的<a href=
    "http://www.python.org/doc/current/ref/identifiers.html">标识符命名规则</a>。
    </dt>

    <dt><b>效果：</b>创建一个Boost.Python.StaticProperty对象，
    向其构造函数传入<code><a href="object.html#object-spec-ctors">object</a>(fget)</code>
    （和<code><a href=
    "object.html#object-spec-ctors">object</a>(fset)</code>的第二种形式），
    然后将此属性以所给定的属性名<code>name</code>，
    加入所构造的Python类。
    
    StaticProperty是Python的<a href=
    "http://www.python.org/2.2.2/descrintro.html#property"><code>property</code></a>
    类的特殊子类，它可不带首部的<code>self</code>参数进行调用。
    </dt>

    <dt><b>返回：</b><code>*this</code></dt>

    <dt><b>原理：</b>允许用户方便地导出可以在Python中以静态属性访问语法调用的函数。
    </dt>
  </dl><br>
  
  <pre>
template &lt;class D&gt;
class_&amp; def_readonly(char const* name, D T::*pm, char const* doc=0);
template &lt;class D&gt;
class_&amp; def_readonly(char const* name, D const&amp; d);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> <code>name</code> is an <a href=
    "definitions.html#ntbs">ntbs</a> which conforms to Python's <a href=
    "http://www.python.org/doc/current/ref/identifiers.html">identifier
    naming rules</a>. <code>doc</code> is also an ntbs.</dt>
    
    <br>

    <dt><b>要求：</b><code>name</code>是个<a href=
    "definitions.html#ntbs">ntbs</a>，并符合Python的<a href=
    "http://www.python.org/doc/current/ref/identifiers.html">标识符命名规则</a>。
    <code>doc</code>也是个ntbs。</dt>

    <br>
    
    <dt><b>Effects:</b></dt>

    <dd>
      <pre>
this-&gt;add_property(name, <a href=
"data_members.html#make_getter-spec">make_getter</a>(pm), doc);
</pre>and
      <pre>
this-&gt;add_static_property(name, <a href=
"data_members.html#make_getter-spec">make_getter</a>(d));
</pre>respectively.<br>
      <br>
    </dd>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <dt><b>Rationale:</b> Allows users to easily expose a class' data member
    or free variable such that it can be inspected from Python with a natural
    syntax.</dt>
    
    <br>
    
    <dt><b>原理：</b>允许用户方便地导出类的数据成员，
    或自由变量，使之可在Python中以自然的语法进行查看。
    </dt>
  </dl>
  <pre>
template &lt;class D&gt;
class_&amp; def_readwrite(char const* name, D T::*pm, char const* doc=0);
template &lt;class D&gt;
class_&amp; def_readwrite(char const* name, D&amp; d);
</pre>

  <dl class="function-semantics">
    <dt><b>Effects:</b></dt>

    <dd>
      <pre>
this-&gt;add_property(name, <a href=
"data_members.html#make_getter-spec">make_getter</a>(pm), <a href=
"data_members.html#make_setter-spec">make_setter</a>(pm), doc);
</pre>and
      <pre>
this-&gt;add_static_property(name, <a href=
"data_members.html#make_getter-spec">make_getter</a>(d), <a href=
"data_members.html#make_setter-spec">make_setter</a>(d));
</pre>respectively.<br>
      <br>
    </dd>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <dt><b>Rationale:</b> Allows users to easily expose a class' data or free
    variable member such that it can be inspected and set from Python with a
    natural syntax.</dt>
    
    <br>
    
    <dt><b>原理：</b>允许用户方便地导出类的数据成员或自由变量，
    使之可在Python中以自然的语法进行查看和设置。
    </dt>
  </dl>
  <pre>
template &lt;typename PickleSuite&gt;
class_&amp; def_pickle(PickleSuite const&amp;);
</pre>

  <dl class="function-semantics">
    <dt><b>Requires:</b> PickleSuite must be publically derived from <a href=
    "pickle.html"><code>pickle_suite</code></a>.</dt>

    <dt><b>Effects:</b> Defines a legal combination of the special attributes
    and methods: <code>__getinitargs__</code>, <code>__getstate__</code>,
    <code>__setstate__</code>, <code>__getstate_manages_dict__</code>,
    <code>__safe_for_unpickling__</code>, <code>__reduce__</code></dt>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <dt><b>Rationale:</b> Provides an <a href="pickle.html">easy to use
    high-level interface</a> for establishing complete pickle support for the
    wrapped class. The user is protected by compile-time consistency
    checks.</dt>
  </dl>

  <dl class="function-semantics">
    <dt><b>要求：</b>PickleSuite必须公有继承自<a href=
    "pickle.html"><code>pickle_suite</code></a>。</dt>

    <dt><b>效果：</b>定义一个合法的特殊属性和方法的组合：
    <code>__getinitargs__</code>、<code>__getstate__</code>、
    <code>__setstate__</code>、<code>__getstate_manages_dict__</code>、
    <code>__safe_for_unpickling__</code>、<code>__reduce__</code></dt>

    <dt><b>返回：</b><code>*this</code></dt>

    <dt><b>原理：</b>提供一个<a href="pickle.html">好用的高级接口</a>，
    用于为封装类建立完全的pickle支持。
    
    通过编译时一致性检查保护用户。
    </dt>
  </dl><br>
  <pre>
class_&amp; enable_pickling();
</pre>

  <dl class="function-semantics">
    <dt><b>Effects:</b> Defines the <code>__reduce__</code> method and the
    <code>__safe_for_unpickling__</code> attribute.</dt>

    <dt><b>Returns:</b> <code>*this</code></dt>

    <dt><b>Rationale:</b> Light-weight alternative to
    <code>def_pickle()</code>. Enables implementation of <a href=
    "pickle.html">pickle support</a> from Python.</dt>
  </dl>

  <dl class="function-semantics">
    <dt><b>效果：</b>定义<code>__reduce__</code>方法
    和<code>__safe_for_unpickling__</code>属性。</dt>

    <dt><b>返回：</b><code>*this</code></dt>

    <dt><b>原理：</b>
    <code>def_pickle()</code>的轻量级方法。
    从Python实现<a href=
    "pickle.html">pickle支持</a>。</dt>
  </dl><br>

  <h3><a name="bases-spec" id="bases-spec"></a>Class template
  <code>bases&lt;T1, T2,</code>...<code>TN&gt;</code></h3>

  <p>An <a href="../../../mpl/doc/refmanual/forward-sequence.html">MPL
  sequence</a> which can be used in
  <code>class_&lt;</code>...<code>&gt;</code> instantiations indicate a list
  of base classes.</p>
  
  <p>
  一个<a href="../../../mpl/doc/refmanual/forward-sequence.html">MPL序列</a>，
  可用于在<code>class_&lt;</code>...<code>&gt;</code>实例化中指示一串基类。
  </p>

  <h4><a name="bases-spec-synopsis" id="bases-spec-synopsis"></a>Class
  template <code>bases</code> synopsis</h4>
  <pre>
namespace boost { namespace python
{
  template &lt;T1 = <i>unspecified</i>,...T<i>n</i> = <i>unspecified</i>&gt;
  struct bases
  {};
}}
</pre>

  <h2><a name="examples" id="examples"></a>Example(s)</h2>

  <p>Given a C++ class declaration:</p>
  
  <p>如有C++类声明：</p>
  
  <pre>
class Foo : public Bar, public Baz
{
 public:
   Foo(int x, char const* y);
   Foo(double);

   std::string const&amp; name() { return m_name; }
   void name(char const*);

   double value; // public data
 private:
   ...
};
</pre>A corresponding Boost.Python extension class can be created with:

<p>
对应的Boost.Python扩展类可如下创建：
</p>

  <pre>
using namespace boost::python;

class_&lt;Foo,bases&lt;Bar,Baz&gt; &gt;("Foo",
          "This is Foo's docstring."
          "It describes our Foo extension class",

          init&lt;int,char const*&gt;(args("x","y"), "__init__ docstring")
          )
   .def(init&lt;double&gt;())
   .def("get_name", &amp;Foo::get_name, return_internal_reference&lt;&gt;())
   .def("set_name", &amp;Foo::set_name)
   .def_readwrite("value", &amp;Foo::value)
   ;
</pre>
  <hr>
  <a name="footnote_1" id="footnote_1">[1]</a> By "previously-exposed" we
  mean that the for each <code>B</code> in <code>bases</code>, an instance of
  <code>class_&lt;B<font color="#007F00">, ...</font>&gt;</code> must have
  already been constructed.
  
  <p>
  <a name="footnote_1" id="footnote_1">[1]</a>“已经导出”的意思是，
  对于<code>bases</code>中每个<code>B</code>，
  <code>class_&lt;B<font color="#007F00">, ...</font>&gt;</code>
  的实例必须是已经构造好的。
  </p>
  
  <pre>
class_&lt;Base&gt;("Base");
class_&lt;Derived, bases&lt;Base&gt; &gt;("Derived");
</pre>Revised 
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
   1 November, 2005 <!--webbot bot="Timestamp" endspan i-checksum="39359" -->

  <p><i>&copy; Copyright <a href="http://www.boost.org/people/dave_abrahams.htm">Dave
  Abrahams</a> 2002.</i></p>
  
  <p>翻译：<a href="http://blog.csdn.net/jq0123">金庆</a></p>
  <p>译文更新: 2008.6.15</p>
  
</body>
</html>

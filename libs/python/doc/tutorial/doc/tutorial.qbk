[library python
    [version 2.0]
    [authors [de Guzman, Joel], [Abrahams, David]]
    [copyright 2002 2003 2004 2005 Joel de Guzman, David Abrahams]
    [category inter-language support]
    [purpose
        Reflects C++ classes and functions into Python
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        <ulink url="http://www.boost.org/LICENSE_1_0.txt">
            http://www.boost.org/LICENSE_1_0.txt
        </ulink>)
    ]
]

[/ QuickBook Document version 0.9 ]

[def __note__       [$images/note.png]]
[def __alert__      [$images/alert.png]]
[def __tip__        [$images/tip.png]]
[def :-)            [$images/smiley.png]]
[def __jam__        [$images/jam.png]]

[section:quickstart QuickStart 快速入门]

The Boost Python Library is a framework for interfacing Python and
C++. It allows you to quickly and seamlessly expose C++ classes
functions and objects to Python, and vice-versa, using no special
tools -- just your C++ compiler. It is designed to wrap C++ interfaces
non-intrusively, so that you should not have to change the C++ code at
all in order to wrap it, making Boost.Python ideal for exposing
3rd-party libraries to Python. The library's use of advanced
metaprogramming techniques simplifies its syntax for users, so that
wrapping code takes on the look of a kind of declarative interface
definition language (IDL).\n
Boost Python库是一个连接Python和C++的框架。
它允许你快速无缝地导出C++类函数和对象到Python，反之亦可，而不必使用特殊工具，只需你的C++编译器。 
Boost.python设计用于非侵入式地封装C++接口，所以你不必为了封装而更改C++代码，这让它成为向Python导出第3方库时理想的方法。
程序库利用了高级元编程技术，为用户简化了它的语法，使封装代码看上去像是一种声明性的接口定义语言(IDL)。

[h2 Hello World]

Following C/C++ tradition, let's start with the "hello, world". A C++
Function:\n
遵循C/C++传统，让我们从"hello, world"开始。一个C++函数： 

    char const* greet()
    {
       return "hello, world";
    }

can be exposed to Python by writing a Boost.Python wrapper:\n
可以通过编写一个Boost.Python封装，导出到Python： 

    #include <boost/python.hpp>

    BOOST_PYTHON_MODULE(hello_ext)
    {
        using namespace boost::python;
        def("greet", greet);
    }

That's it. We're done. We can now build this as a shared library. The
resulting DLL is now visible to Python. Here's a sample Python session:\n
这就好了。就是这么简单。现在，我们可以将它构建为一个共享库。产生的DLL文件，现在对Python是可见的了。这是Python的试用： 

[python]

    >>> import hello_ext
    >>> print hello.greet()
    hello, world

[c++]

[:['[*Next stop... Building your Hello World module from start to finish...\n
下一站...从头到尾构建你的Hello World模块...]]]

[endsect]
[section:hello Building Hello World  构建 Hello World]

[h2 From Start To Finish 从头到尾]

Now the first thing you'd want to do is to build the Hello World module and
try it for yourself in Python. In this section, we will outline the steps
necessary to achieve that. We will use the build tool that comes bundled
with every boost distribution: [*bjam].\n
现在你最想做的事，可能就是构建Hello World模块，并亲自在Python中试用一下。 在本节中，我们将概述实现该目标的必要步骤。 我们将使用boost发行版捆绑的构建工具：[*bjam]。 

[note [*Building without bjam 不用bjam构建]

Besides bjam, there are of course other ways to get your module built.
What's written here should not be taken as "the one and only way".
There are of course other build tools apart from [^bjam].\n
除了bjam，当然还有其他的方法来构建模块。 此处所述不应被视为"唯一方法"。 除了[^bjam]， 当然还有其他构建工具。

Take note however that the preferred build tool for Boost.Python is bjam.
There are so many ways to set up the build incorrectly. Experience shows
that 90% of the "I can't build Boost.Python" problems come from people
who had to use a different tool.\n
不过请注意，Boost.Python的首选构建工具是bjam。 构建方法不正确的可能性太大了。 
经验表明，90%的"我无法编译Boost.Python"的问题，是因为他不得不使用其他工具。
]

We will skip over the details. Our objective will be to simply create
the hello world module and run it in Python. For a complete reference to
building Boost.Python, check out: [@../../../building.html
building.html]. After this brief ['bjam] tutorial, we should have built
the DLLs and run a python program using the extension.\n
我们将略过细节。我们的目标是简单地创建hello world模块，并在Python中运行它。
有关构建Boost.Python的完整参考资料，请查看 [@../../../building.html building.html]。
完成这个简短的 ['bjam] 教程之后，我们应该构建出DLL并能运行python程序使用该扩展：

The tutorial example can be found in the directory:
[^libs/python/example/tutorial]. There, you can find:\n
教程中的例子位于目录：[^libs/python/example/tutorial]。 其中有：

* hello.cpp
* hello.py
* Jamroot

The [^hello.cpp] file is our C++ hello world example. The [^Jamroot] is
a minimalist ['bjam] script that builds the DLLs for us. Finally,
[^hello.py] is our Python program that uses the extension in
[^hello.cpp].\n
[^hello.cpp] 文件，是我们的C++ hello world例程。 [^Jamroot] 是一个最小的 ['bjam] 脚本，它为我们构建DLL。
最后，[^hello.py] 是我们的Python程序，它将使用 [^hello.cpp] 中的扩展。

Before anything else, you should have the bjam executable in your boost
directory or somewhere in your path such that [^bjam] can be executed in
the command line. Pre-built Boost.Jam executables are available for most
platforms. The complete list of Bjam executables can be found
[@http://sourceforge.net/project/showfiles.php?group_id=7586 here].\n
首先，你应该把bjam可执行文件，放在你的boost目录，或在系统路径的其他地方，使 [^bjam] 可以在命令行中执行。
在大多数平台上，都有预建的Boost.Jam可执行文件。 所有bjam可执行文件可以在 
[@http://sourceforge.net/project/showfiles.php?group_id=7586 这里] 找到。

[h2 Let's Jam!  让我们Jam！]
__jam__

[@../../../../example/tutorial/Jamroot Here] is our minimalist Jamroot
file. Simply copy the file and tweak [^use-project boost] to where your
boost root directory is and your OK.\n
[@../../../../example/tutorial/Jamroot 这里] 是我们最小的Jamroot文件。 
只需复制该文件并将 [^use-project boost] 更改为你的boost根目录就行了。 

The comments contained in the Jamrules file above should be sufficient
to get you going.\n
上面Jamrules文件中包含的注释对你应该足够了。 

[h2 Running bjam  运行bjam]

['bjam] is run using your operating system's command line interpreter.\n
['bjam] 通过操作系统的命令行解释器运行。

[:Start it up.]

A file called user-config.jam in your home directory is used to
configure your tools. In Windows, your home directory can be found by
typing:\n
你的主目录下的user-config.jam文件，将用来配置工具。 在Windows上，可以在命令提示窗口中键入：

[pre
ECHO %HOMEDRIVE%%HOMEPATH%
]

into a command prompt window. Your file should at least have the rules
for your compiler and your python installation. A specific example of
this on Windows would be:\n
找到你的主目录。该文件至少应该设置你的编译器和python安装。 Windows上示例如下： 

[pre
#  MSVC configuration
using msvc : 8.0 ;

#  Python configuration
using python : 2.4 : C:/dev/tools/Python/ ;
]

The first rule tells Bjam to use the MSVC 8.0 compiler and associated
tools. The second rule provides information on Python, its version and
where it is located. The above assumes that the Python installation is
in [^C:/dev/tools\/Python/]. If you have one fairly "standard" python
installation for your platform, you might not need to do this.\n
第一条规则告诉Bjam使用MSVC 8.0编译器和相关工具。 第二条规则提供了Python的信息，它的版本和它位于何处。 
上面假定Python安装于 [^C:/dev/tools\/Python/]。 如果在你的平台上具有一个相当"标准的"python安装，你可以不必配置该规则。 

Now we are ready... Be sure to [^cd] to [^libs/python/example/tutorial]
where the tutorial [^"hello.cpp"] and the [^"Jamroot"] is situated.\n
现在我们准备好了... 确保 [^cd] 到 [^libs/python/example/tutorial]， 即教程 [^"hello.cpp"] 和 [^"Jamroot"] 所在位置。

Finally:\n
最后：

    bjam

It should be building now:\n
它现在应该开始构建了： 

[pre
cd C:\dev\boost\libs\python\example\tutorial
bjam
...patience...
...found 1101 targets...
...updating 35 targets...
]

And so on... Finally:\n
等等...最后：

[pre
   Creating library /path-to-boost_python.dll/
   Creating library /path-to-'''hello_ext'''.exp/
'''**passed**''' ... hello.test
...updated 35 targets...
]

Or something similar. If all is well, you should now have built the DLLs and
run the Python program.\n
或类似的东西。如果一切都好，你现在应该已经构建了DLL并运行了Python程序。

[:[*There you go... Have fun! 去吧……玩得开心点！]]

[endsect]
[section:exposing Exposing Classes 导出类]

Now let's expose a C++ class to Python.\n
现在让我们导出C++类到Python。

Consider a C++ class/struct that we want to expose to Python:\n
设想，我们要把一个C++类/结构导出到Python：

    struct World
    {
        void set(std::string msg) { this->msg = msg; }
        std::string greet() { return msg; }
        std::string msg;
    };

We can expose this to Python by writing a corresponding Boost.Python
C++ Wrapper:\n
我们可以编写相应的Boost.Python C++封装，把它导出给Python：

    #include <boost/python.hpp>
    using namespace boost::python;

    BOOST_PYTHON_MODULE(hello)
    {
        class_<World>("World")
            .def("greet", &World::greet)
            .def("set", &World::set)
        ;
    }

Here, we wrote a C++ class wrapper that exposes the member functions
[^greet] and [^set]. Now, after building our module as a shared library, we
may use our class [^World] in Python. Here's a sample Python session:\n
在这里，我们写了一个C++类封装，导出了成员函数 [^greet] 和 [^set]。
现在，把我们的模块构建为共享库之后，我们就可以在Python中使用我们的 [^World] 类了。 Python运行示例如下：

[python]

    >>> import hello
    >>> planet = hello.World()
    >>> planet.set('howdy')
    >>> planet.greet()
    'howdy'

[section:constructors Constructors 构造函数]

Our previous example didn't have any explicit constructors.
Since [^World] is declared as a plain struct, it has an implicit default
constructor. Boost.Python exposes the default constructor by default,
which is why we were able to write\n
这个例子没有任何显式构造函数。但由于 [^World] 声明为一个普通结构，它有一个隐含的默认构造函数。 
Boost.Python默认情况下会导出默认构造函数，这也就是我们为什么能这样写 

    >>> planet = hello.World()

We may wish to wrap a class with a non-default constructor. Let us
build on our previous example:\n
我们可能希望封装一个具有非默认构造函数的类。让我们构建前面的例子：

[c++]

    struct World
    {
        World(std::string msg): msg(msg) {} // added constructor
        void set(std::string msg) { this->msg = msg; }
        std::string greet() { return msg; }
        std::string msg;
    };

This time [^World] has no default constructor; our previous
wrapping code would fail to compile when the library tried to expose
it. We have to tell [^class_<World>] about the constructor we want to
expose instead.\n
这次，[^World] 没有默认的构造函数；当类库试图导出它时，我们前面的封装代码将无法编译。
我们必须告诉 [^class_<World>] 我们想要导出的构造函数。

    #include <boost/python.hpp>
    using namespace boost::python;

    BOOST_PYTHON_MODULE(hello)
    {
        class_<World>("World", init<std::string>())
            .def("greet", &World::greet)
            .def("set", &World::set)
        ;
    }

[^init<std::string>()] exposes the constructor taking in a
[^std::string] (in Python, constructors are spelled
"[^"__init__"]").\n
[^init<std::string>()] 导出了以[^std::string] 为参数的构造函数 （在Python中，构造函数为 "[^"__init__"]"）。 

We can expose additional constructors by passing more [^init<...>]s to
the [^def()] member function. Say for example we have another World
constructor taking in two doubles:\n
我们可以导出另外的构造函数，只要向 [^def()] 成员函数传入更多的 [^init<...>]。
假设我们有另一个World构造函数，它有两个double参数： 

    class_<World>("World", init<std::string>())
        .def(init<double, double>())
        .def("greet", &World::greet)
        .def("set", &World::set)
    ;

On the other hand, if we do not wish to expose any constructors at
all, we may use [^no_init] instead:\n
另一方面，如果我们不想导出任何构造函数，我们可以使用 [^no_init]： 

    class_<Abstract>("Abstract", no_init)

This actually adds an [^__init__] method which always raises a
Python RuntimeError exception.\n
这实际上添加了一个 [^__init__] 方法，但它总是抛出一个Python RuntimeError异常。

[endsect]
[section:class_data_members Class Data Members 类的数据成员]

Data members may also be exposed to Python so that they can be
accessed as attributes of the corresponding Python class. Each data
member that we wish to be exposed may be regarded as [*read-only] or
[*read-write].  Consider this class [^Var]:\n
数据成员也可以导出到Python，按相应Python类的属性进行访问。我们导出的每一个数据成员，都可视为 [*只读] 或 [*读写]。
考虑这个类 [^Var]： 

    struct Var
    {
        Var(std::string name) : name(name), value() {}
        std::string const name;
        float value;
    };

Our C++ [^Var] class and its data members can be exposed to Python:\n
我们的C++ [^Var] 类和它的数据成员可以导出到Python： 

    class_<Var>("Var", init<std::string>())
        .def_readonly("name", &Var::name)
        .def_readwrite("value", &Var::value);

Then, in Python, assuming we have placed our Var class inside the namespace
hello as we did before:\n
然后，在Python中，假设我们已经和前面一样，将我们的Var类放在名字空间hello中：

[python]

    >>> x = hello.Var('pi')
    >>> x.value = 3.14
    >>> print x.name, 'is around', x.value
    pi is around 3.14

Note that [^name] is exposed as [*read-only] while [^value] is exposed
as [*read-write].\n
注意，[^name] 按[*只读]导出，而 [^value] 按[*读写]导出。

    >>> x.name = 'e' # can't change name
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    AttributeError: can't set attribute

[endsect]
[section:class_properties Class Properties 类的属性]

In C++, classes with public data members are usually frowned
upon. Well designed classes that take advantage of encapsulation hide
the class' data members. The only way to access the class' data is
through access (getter/setter) functions. Access functions expose class
properties. Here's an example:\n
在C++中，通常人们不赞成具有公有数据成员的类。设计良好的类会利用封装隐藏类的数据成员。
访问类中数据唯一的方式，是通过访问函数（getter/setter）。访问函数导出了类的属性。下面是一个例子：

[c++]

    struct Num
    {
        Num();
        float get() const;
        void set(float value);
        ...
    };

However, in Python attribute access is fine; it doesn't neccessarily break
encapsulation to let users handle attributes directly, because the
attributes can just be a different syntax for a method call. Wrapping our
[^Num] class using Boost.Python:\n
然而，Python可以访问属性；它让用户直接操作属性，而不必破坏封装，因为属性只是一种不同语法的方法调用。 
Boost.Python这样封装我们的 [^Num] 类：

    class_<Num>("Num")
        .add_property("rovalue", &Num::get)
        .add_property("value", &Num::get, &Num::set);

And at last, in Python:\n
最后，在Python中：

[python]

    >>> x = Num()
    >>> x.value = 3.14
    >>> x.value, x.rovalue
    (3.14, 3.14)
    >>> x.rovalue = 2.17 # error!

Take note that the class property [^rovalue] is exposed as [*read-only]
since the [^rovalue] setter member function is not passed in:\n
注意类属性 [^rovalue] 按[*只读]导出，因为没有传入 [^rovalue] 的成员设置函数：

[c++]

    .add_property("rovalue", &Num::get)

[endsect]
[section:inheritance Inheritance 继承]

In the previous examples, we dealt with classes that are not polymorphic.
This is not often the case. Much of the time, we will be wrapping
polymorphic classes and class hierarchies related by inheritance. We will
often have to write Boost.Python wrappers for classes that are derived from
abstract base classes.\n
上面的例子中，我们的类不具有多态性。实际情况常常不是这样的。多数情况下，我们将封装多态类和具有继承关系的类体系。
我们经常还会不得不为从抽象基类继承的类编写封装。

Consider this trivial inheritance structure:\n
考虑这个简单的继承结构： 

    struct Base { virtual ~Base(); };
    struct Derived : Base {};

And a set of C++ functions operating on [^Base] and [^Derived] object
instances:\n
和一组C++函数，对 [^Base] 和 [^Derived] 对象的实例进行操作：

    void b(Base*);
    void d(Derived*);
    Base* factory() { return new Derived; }

We've seen how we can wrap the base class [^Base]:\n
我们已经见过如何封装基类 [^Base]：

    class_<Base>("Base")
        /*...*/
        ;

Now we can inform Boost.Python of the inheritance relationship between
[^Derived] and its base class [^Base].  Thus:\n
现在，我们可以把 [^Derived] 类和它基类 [^Base] 的继承关系告诉Boost.Python。像这样： 

    class_<Derived, bases<Base> >("Derived")
        /*...*/
        ;

Doing so, we get some things for free:\n
这样做，我们免费得到一些东西：

# Derived automatically inherits all of Base's Python methods
  (wrapped C++ member functions)\n
  Derived 类自动继承所有基类的Python方法（即封装的C++成员函数）
# [*If] Base is polymorphic, [^Derived] objects which have been passed to
  Python via a pointer or reference to [^Base] can be passed where a pointer
  or reference to [^Derived] is expected.\n
  [*如果] Base 类是多态的，按 [^Base] 类的指针或引用传给Python的 [^Derived] 对象，可以在需要 [^Derived] 类指针或引用的地方使用。

Now, we will expose the C++ free functions [^b] and [^d] and [^factory]:\n
现在，我们将导出C++的自由函数 [^b] 和 [^d] 及 [^factory]: 

    def("b", b);
    def("d", d);
    def("factory", factory);

Note that free function [^factory] is being used to generate new
instances of class [^Derived]. In such cases, we use
[^return_value_policy<manage_new_object>] to instruct Python to adopt
the pointer to [^Base] and hold the instance in a new Python [^Base]
object until the the Python object is destroyed. We will see more of
Boost.Python [link python.call_policies call policies] later.\n
注意，自由函数 [^factory] 用于生成新的 [^Derived] 类实例。在这种情况下，我们使用 [^return_value_policy<manage_new_object>]，
指示Python收养指向 [^Base] 类的指针，并在一个新的Python [^Base] 对象中保存，直到该Python对象销毁。
我们以后将会见到更多的Boost.Python [link python.call_policies 调用策略]。

    // Tell Python to take ownership of factory's result
    def("factory", factory,
        return_value_policy<manage_new_object>());

[endsect]

[section:class_virtual_functions Class Virtual Functions 类的虚函数]

In this section, we will learn how to make functions behave polymorphically
through virtual functions. Continuing our example, let us add a virtual function
to our [^Base] class:\n
在本节中，我们将了解如何通过虚函数实现多态的函数行为。继续我们的例子，让我们在 [^Base] 类中添加一个虚函数：

    struct Base
    {
        virtual ~Base() {}
        virtual int f() = 0;
    };

One of the goals of Boost.Python is to be minimally intrusive on an existing C++
design. In principle, it should be possible to expose the interface for a 3rd
party library without changing it. It is not ideal to add anything to our class
`Base`. Yet, when you have a virtual function that's going to be overridden in
Python and called polymorphically *from C++*, we'll need to add some
scaffoldings to make things work properly. What we'll do is write a class
wrapper that derives from `Base` that will unintrusively hook into the virtual
functions so that a Python override may be called:\n
Boost.Python的目标之一是，对现有的C++设计侵扰最小。原则上，它应该可以为第三方库导出接口，而不必更改它。
向我们的 `Base` 类添加任何东西都是不完美的。
然而，当你想在Python中覆盖一个虚函数，并 *从C++* 多态地调用时，我们需要添加一些脚手架，使其正常工作。
我们要做的是，写一个封装类，派生自 `Base` 类，它将非侵入式地挂接到虚函数，这样就可以调用Python中的覆盖函数了：

    struct BaseWrap : Base, wrapper<Base>
    {
        int f()
        {
            return this->get_override("f")();
        }
    };

Notice too that in addition to inheriting from `Base`, we also multiply-
inherited `wrapper<Base>` (See [@../../../v2/wrapper.html Wrapper]). The
`wrapper` template makes the job of wrapping classes that are meant to
overridden in Python, easier.\n
同时注意，除了继承 `Base`，我们还多重继承了 `wrapper<Base>` （见 [@../../../v2/wrapper.html Wrapper]）。
`wrapper` 模板使封装类的工作更轻松，而该封装对于在Python中覆盖是至关重要的。

[blurb __alert__ [*MSVC6/7 Workaround  MSVC6/7变通方法]

If you are using Microsoft Visual C++ 6 or 7, you have to write `f` as:\n
Q如果你用的是Microsoft Visual C++ 6 或 7，`f` 必须这样写：

`return call<int>(this->get_override("f").ptr());`.]

BaseWrap's overridden virtual member function `f` in effect calls the
corresponding method of the Python object through `get_override`.\n
BaseWrap 覆盖了成员虚函数 `f`，使它通过 `get_override` 调用Python对象的相应方法。

Finally, exposing `Base`:\n
最后，导出 `Base` 类：

    class_<BaseWrap, boost::noncopyable>("Base")
        .def("f", pure_virtual(&Base::f))
        ;

`pure_virtual` signals Boost.Python that the function `f` is a pure virtual
function.\n
`pure_virtual` 告诉Boost.Python，函数 `f` 是一个纯虚函数。

[note [*member function and methods 成员函数和方法]

Python, like many object oriented languages uses the term [*methods].
Methods correspond roughly to C++'s [*member functions]\n
Python，与许多面向对象语言一样， 使用术语 [*方法]。方法大致对应于C++的 [*成员函数] 
]

[endsect]

[section:virtual_functions_with_default_implementations Virtual Functions with Default Implementations 具有默认实现的虚函数]

We've seen in the previous section how classes with pure virtual functions are
wrapped using Boost.Python's [@../../../v2/wrapper.html class wrapper]
facilities. If we wish to wrap [*non]-pure-virtual functions instead, the
mechanism is a bit different.\n
在上一节我们看到，如何使用Boost.Python的 [@../../../v2/wrapper.html 类封装器] 工具，封装具有纯虚函数的类。
如果我们要封装 [*非]纯虚函数，机制有点不同。

Recall that in the [link python.class_virtual_functions previous section], we
wrapped a class with a pure virtual function that we then implemented in C++, or
Python classes derived from it. Our base class:\n
记得在 [link python.class_virtual_functions 上一节] 中，我们封装了一个具有纯虚函数的类，
然后，我们在C++，或Python的派生类中实现它。我们的基类如下：

    struct Base
    {
        virtual int f() = 0;
    };

had a pure virtual function [^f]. If, however, its member function [^f] was
not declared as pure virtual:\n
它有一个纯虚函数 [^f]。但是，如果其成员函数 [^f] 没有声明为纯虚：

    struct Base
    {
        virtual ~Base() {}
        virtual int f() { return 0; }
    };

We wrap it this way:\n
我们这样封装它：

    struct BaseWrap : Base, wrapper<Base>
    {
        int f()
        {
            if (override f = this->get_override("f"))
                return f(); // *note*
            return Base::f();
        }

        int default_f() { return this->Base::f(); }
    };

Notice how we implemented `BaseWrap::f`. Now, we have to check if there is an
override for `f`. If none, then we call `Base::f()`.\n
注意我们如何实现 `BaseWrap::f`。现在，我们必须检查是否有一个 `f` 的覆盖函数。如果没有，我们就调用 `Base::f()`。 

[blurb __alert__ [*MSVC6/7 Workaround  MSVC6/7变通方法]

If you are using Microsoft Visual C++ 6 or 7, you have to rewrite the line
with the `*note*` as:\n
如果你用的是Microsoft Visual C++ 6 或 7， 你必须将标注 `*note*` 的代码行改写为：

`return call<char const*>(f.ptr());`.]

Finally, exposing:\n
最后，导出：

    class_<BaseWrap, boost::noncopyable>("Base")
        .def("f", &Base::f, &BaseWrap::default_f)
        ;

Take note that we expose both `&Base::f` and `&BaseWrap::default_f`.
Boost.Python needs to keep track of 1) the dispatch function [^f] and 2) the
forwarding function to its default implementation [^default_f]. There's a
special [^def] function for this purpose.\n
需注意，我们同时导出了 `&Base::f` 和 `&BaseWrap::default_f`。
Boost.Python需要明了: 1)分派函数 [^f] 和 2)转发函数，转发到它的默认实现 [^default_f]。为此，存在一个特别的 [^def] 函数。

In Python, the results would be as expected:\n
在Python中，其结果将一如所料：

[python]

    >>> base = Base()
    >>> class Derived(Base):
    ...     def f(self):
    ...         return 42
    ...
    >>> derived = Derived()

Calling [^base.f()]:\n
调用 [^base.f()]：

    >>> base.f()
    0

Calling [^derived.f()]:\n
调用 [^derived.f()]： 

    >>> derived.f()
    42

[endsect]
[section:class_operators_special_functions Class Operators/Special Functions 类的运算符/特殊函数]

[h2 Python Operators  Python运算符]

C is well known for the abundance of operators. C++ extends this to the
extremes by allowing operator overloading. Boost.Python takes advantage of
this and makes it easy to wrap C++ operator-powered classes.\n
众所周知，C语言具有丰富的运算符。 C++允许运算符重载，更是将它们扩展到极致。 
Boost.Python利用了这一点，可以轻松地封装C++带运算符的类。

Consider a file position class [^FilePos] and a set of operators that take
on FilePos instances:\n
考虑一个文件位置类 [^FilePos]，和一组针对 FilePos 的运算符：

[c++]

    class FilePos { /*...*/ };

    FilePos     operator+(FilePos, int);
    FilePos     operator+(int, FilePos);
    int         operator-(FilePos, FilePos);
    FilePos     operator-(FilePos, int);
    FilePos&    operator+=(FilePos&, int);
    FilePos&    operator-=(FilePos&, int);
    bool        operator<(FilePos, FilePos);

The class and the various operators can be mapped to Python rather easily
and intuitively:\n
该类和各种运算符可以相当轻松地，并且直观地，映射到Python：

    class_<FilePos>("FilePos")
        .def(self + int())          // __add__
        .def(int() + self)          // __radd__
        .def(self - self)           // __sub__
        .def(self - int())          // __sub__
        .def(self += int())         // __iadd__
        .def(self -= other<int>())
        .def(self < self);          // __lt__

The code snippet above is very clear and needs almost no explanation at
all. It is virtually the same as the operators' signatures. Just take
note that [^self] refers to FilePos object. Also, not every class [^T] that
you might need to interact with in an operator expression is (cheaply)
default-constructible. You can use [^other<T>()] in place of an actual
[^T] instance when writing "self expressions".\n
以上代码片断非常清晰，几乎不需要任何解释。它实际上与运算符的函数签名一致。
只需注意 [^self] 是指 FilePos 对象。另外，在运算符表达式中，你可能需要一个类 [^T] 并与之交互，但不是每个类都可以（低廉地）缺省构造的。
当编写"self表达式"时，你可以使用 [^other<T>()] 替代实际的 [^T] 实例。

[h2 Special Methods 特殊方法]

Python has a few more ['Special Methods]. Boost.Python supports all of the
standard special method names supported by real Python class instances. A
similar set of intuitive interfaces can also be used to wrap C++ functions
that correspond to these Python ['special functions]. Example:\n
Python有几个 ['特殊方法]。真实的Python类实例所支持的，所有标准的特殊方法名，Boost.Python都支持。
也可以使用一组类似的直观接口，用来封装对应那些Python ['特殊函数] 的C++函数。例如：

    class Rational
    { public: operator double() const; };

    Rational pow(Rational, Rational);
    Rational abs(Rational);
    ostream& operator<<(ostream&,Rational);

    class_<Rational>("Rational")
        .def(float_(self))                  // __float__
        .def(pow(self, other<Rational>))    // __pow__
        .def(abs(self))                     // __abs__
        .def(str(self))                     // __str__
        ;

Need we say more?\n
还需要多说吗？

[note What is the business of `operator<<`?
Well, the method `str` requires the `operator<<` to do its work (i.e.
`operator<<` is used by the method defined by `def(str(self))`.\n
`operator<<` 有什么用？喔，`str` 方法要求 `operator<<` 为它干活，即 `def(str(self))` 定义的方法用到了 `operator<<`。 ]

[endsect]
[endsect] [/ Exposing Classes ]

[section:functions Functions 函数]

In this chapter, we'll look at Boost.Python powered functions in closer
detail. We will see some facilities to make exposing C++ functions to
Python safe from potential pifalls such as dangling pointers and
references. We will also see facilities that will make it even easier for
us to expose C++ functions that take advantage of C++ features such as
overloading and default arguments.\n
在这一章中，我们将详细查看Boost.Python驱动的函数。
我们将看到一些工具，用来安全地导出C++函数到Python，避免潜在的陷阱，如野指针和野引用。
我们还将看到其他工具，它们利用C++的特性，如重载和默认参数，使我们导出C++函数更加容易。

[:['Read on... 继续看...]]

But before you do, you might want to fire up Python 2.2 or later and type
[^>>> import this].\n
但在此之前，你也许要打开Python 2.2或更新版本，并输入 [^>>> import this]。 

[pre
>>> import this
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
]

[section:call_policies Call Policies 调用策略]

In C++, we often deal with arguments and return types such as pointers
and references. Such primitive types are rather, ummmm, low level and
they really don't tell us much. At the very least, we don't know the
owner of the pointer or the referenced object. No wonder languages
such as Java and Python never deal with such low level entities. In
C++, it's usually considered a good practice to use smart pointers
which exactly describe ownership semantics. Still, even good C++
interfaces use raw references and pointers sometimes, so Boost.Python
must deal with them. To do this, it may need your help. Consider the
following C++ function:\n
在C++中，我们经常按指针和引用处理参数和返回类型。这种原始类型，嗯...，是低级的，它们真的没有多少信息。
至少，我们不知道指针或引用对象的所有者。怪不得如Java和Python这样的语言，从来不处理这种低级的东西。
在C++中通常认为，使用智能指针是一个好习惯，因为智能指针恰恰描述了所有权语义。
但是，即使是优秀的C++接口，有时仍会使用原始的引用和指针，所以Boost.Python必须处理它们。
要做到这一点，它可能需要你的帮助。考虑以下的C++函数：

    X& f(Y& y, Z* z);

How should the library wrap this function? A naive approach builds a
Python X object around result reference. This strategy might or might
not work out. Here's an example where it didn't\n
库应该如何封装这一函数呢？单纯的方法是，围绕结果引用建立Python X对象。这种策略可能行可能不行。这就是不行的例子

    >>> x = f(y, z) # x refers to some C++ X
    >>> del y
    >>> x.some_method() # CRASH!

What's the problem?\n
问题在哪里？

Well, what if f() was implemented as shown below:\n
好，如果 f() 如下实现会怎样：

    X& f(Y& y, Z* z)
    {
        y.z = z;
        return y.x;
    }

The problem is that the lifetime of result X& is tied to the lifetime
of y, because the f() returns a reference to a member of the y
object. This idiom is is not uncommon and perfectly acceptable in the
context of C++. However, Python users should not be able to crash the
system just by using our C++ interface. In this case deleting y will
invalidate the reference to X. We have a dangling reference.\n
问题是，因为 f() 返回y对象成员的引用，结果X&的生命期，是与y的生命期捆绑的。
这个惯用法并不罕见，在C++语境中，它是完全可以接受的。然而，Python用户不应该因为使用我们的C++接口而遭受系统崩溃。
在本例中，删除y会使X的引用失效。我们有野引用。

Here's what's happening:\n
这是所发生的事：

# [^f] is called passing in a reference to [^y] and a pointer to [^z]\n
  调用 [^f]，输入引用 [^y] 和指针 [^z] 
# A reference to [^y.x] is returned\n
  返回 [^y.x] 的引用
# [^y] is deleted. [^x] is a dangling reference\n
  删除 [^y]。[^x] 成为野引用
# [^x.some_method()] is called\n
  调用 [^x.some_method()] 
# [*BOOM!]\n
  [*轰！]

We could copy result into a new object:\n
我们可以将结果复制到一个新的对象：

[python]

    >>> f(y, z).set(42) # Result disappears
    >>> y.x.get()       # No crash, but still bad
    3.14

This is not really our intent of our C++ interface. We've broken our
promise that the Python interface should reflect the C++ interface as
closely as possible.\n
这不是我们C++接口的真实意图。我们违背了承诺：Python接口应尽可能地反映C++接口。

Our problems do not end there. Suppose Y is implemented as follows:\n
我们的问题并没有到此为止。假设Y如下实现：

[c++]

    struct Y
    {
        X x; Z* z;
        int z_value() { return z->value(); }
    };

Notice that the data member [^z] is held by class Y using a raw
pointer. Now we have a potential dangling pointer problem inside Y:\n
注意，数据成员 [^z] 是按原始指针保存在类Y中的。现在Y里面有一个潜在的野指针问题：

    >>> x = f(y, z) # y refers to z
    >>> del z       # Kill the z object
    >>> y.z_value() # CRASH!

For reference, here's the implementation of [^f] again:\n
这里再次列出 [^f] 的实现供参考：

    X& f(Y& y, Z* z)
    {
        y.z = z;
        return y.x;
    }

Here's what's happening:\n
这是所发生的事：

# [^f] is called passing in a reference to [^y] and a pointer to [^z]\n
  调用 [^f]，输入引用 [^y] 和指针 [^z]
# A pointer to [^z] is held by [^y]\n
  [^y] 保存指针 [^z]
# A reference to [^y.x] is returned\n
  返回引用 [^y.x]
# [^z] is deleted. [^y.z] is a dangling pointer\n
  删除 [^z]。[^y.z] 成为野指针
# [^y.z_value()] is called\n
  调用 [^y.z_value()]
# [^z->value()] is called\n
  调用 [^z->value()] 
# [*BOOM!]\n
  [*轰！]

[h2 Call Policies 调用策略]

Call Policies may be used in situations such as the example detailed above.
In our example, [^return_internal_reference] and [^with_custodian_and_ward]
are our friends:\n
调用策略可以用于上述例子的情况下。在我们的例子中，可用 [^return_internal_reference] 和 [^with_custodian_and_ward]：

    def("f", f,
        return_internal_reference<1,
            with_custodian_and_ward<1, 2> >());

What are the [^1] and [^2] parameters, you ask?\n
你问参数 [^1] 和 [^2] 是什么？

    return_internal_reference<1

Informs Boost.Python that the first argument, in our case [^Y& y], is the
owner of the returned reference: [^X&]. The "[^1]" simply specifies the
first argument. In short: "return an internal reference [^X&] owned by the
1st argument [^Y& y]".\n
告诉Boost.Python，第一个参数，在我们的例子中 [^Y& y]，是返回引用 [^X&] 的拥有者。
"[^1]" 简单地指定了第一个参数。简而言之："返回一个由第一参数 [^Y& y] 所拥有的内部引用 [^X&] "。 

    with_custodian_and_ward<1, 2>

Informs Boost.Python that the lifetime of the argument indicated by ward
(i.e. the 2nd argument: [^Z* z]) is dependent on the lifetime of the
argument indicated by custodian (i.e. the 1st argument: [^Y& y]).\n
告诉Boost.Python， ward（被监护人）参数（即第二个参数：[^Z* z]）的生命期，依赖于custodian（监护人）参数（即第一个参数：[^Y& y]）的生命期。

It is also important to note that we have defined two policies above. Two
or more policies can be composed by chaining. Here's the general syntax:\n
同时必须注意，我们在上面定义了两项策略。两个或更多的策略可以链式组合。这是一般的语法：

    policy1<args...,
        policy2<args...,
            policy3<args...> > >

Here is the list of predefined call policies. A complete reference detailing
these can be found [@../../../v2/reference.html#models_of_call_policies here].\n
这是预定义调用策略的列表。完整的详细参考资料，可以在 [@../../../v2/reference.html#models_of_call_policies 这里] 找到。

* [*with_custodian_and_ward]:  Ties lifetimes of the arguments\n
  [*with_custodian_and_ward]:  捆绑参数的生命期
* [*with_custodian_and_ward_postcall]:  Ties lifetimes of the arguments and results\n
  [*with_custodian_and_ward_postcall]:  捆绑参数和结果的生命期
* [*return_internal_reference]:  Ties lifetime of one argument to that of result\n
  [*return_internal_reference]:  把一个参数的生命期捆绑到结果的生命期
* [*return_value_policy<T> with T one of:]
    * [*reference_existing_object]: naive (dangerous) approach\n
      [*reference_existing_object]: 单纯的（危险的）方法
    * [*copy_const_reference]: Boost.Python v1 approach\n
      [*copy_const_reference]: Boost.Python v1 方法
    * [*copy_non_const_reference]:
    * [*manage_new_object]: Adopt a pointer and hold the instance\n
      [*manage_new_object]: 收养指针并保存实例

[blurb :-) [*Remember the Zen 记住禅, Luke:]

"Explicit is better than implicit"\n
"显式比隐式好"

"In the face of ambiguity, refuse the temptation to guess"\n
"面对二义性，拒绝猜测的诱惑"
]

[endsect]
[section:overloading Overloading 重载]

The following illustrates a scheme for manually wrapping an overloaded
member functions. Of course, the same technique can be applied to wrapping
overloaded non-member functions.\n
下面说明了手工封装成员函数重载的方案。当然，同样的技术可以应用于封装非成员函数的重载。

We have here our C++ class:\n
这里是我们的C++类：

    struct X
    {
        bool f(int a)
        {
            return true;
        }

        bool f(int a, double b)
        {
            return true;
        }

        bool f(int a, double b, char c)
        {
            return true;
        }

        int f(int a, int b, int c)
        {
            return a + b + c;
        };
    };

Class X has 4 overloaded functions. We will start by introducing some
member function pointer variables:\n
类X具有4个重载函数。我们将首先介绍一些成员函数指针变量：

    bool    (X::*fx1)(int)              = &X::f;
    bool    (X::*fx2)(int, double)      = &X::f;
    bool    (X::*fx3)(int, double, char)= &X::f;
    int     (X::*fx4)(int, int, int)    = &X::f;

With these in hand, we can proceed to define and wrap this for Python:\n
有了这些，我们就可以着手为Python进行定义和封装：

    .def("f", fx1)
    .def("f", fx2)
    .def("f", fx3)
    .def("f", fx4)

[endsect]
[section:default_arguments Default Arguments 默认参数]

Boost.Python wraps (member) function pointers. Unfortunately, C++ function
pointers carry no default argument info. Take a function [^f] with default
arguments:\n
Boost.Python可以封装（成员）函数的指针。不幸的是，C++函数指针没有默认参数信息。假定函数 [^f] 具有默认参数：

    int f(int, double = 3.14, char const* = "hello");

But the type of a pointer to the function [^f] has no information
about its default arguments:\n
但是，指向函数 [^f] 的指针类型，不知道它的默认参数：

    int(*g)(int,double,char const*) = f;    // defaults lost!

When we pass this function pointer to the [^def] function, there is no way
to retrieve the default arguments:\n
当我们把该函数指针传入 [^def] 函数时，没有办法获取默认参数：

    def("f", f);                            // defaults lost!

Because of this, when wrapping C++ code, we had to resort to manual
wrapping as outlined in the [link python.overloading previous section], or
writing thin wrappers:\n
因此，当封装C++代码时，我们不得不采用如 [link python.overloading 上一节] 所述那样的手工封装，或者编写薄的封装：

    // write "thin wrappers"
    int f1(int x) { f(x); }
    int f2(int x, double y) { f(x,y); }

    /*...*/

        // in module init
        def("f", f);  // all arguments
        def("f", f2); // two arguments
        def("f", f1); // one argument

When you want to wrap functions (or member functions) that either:\n
当你要封装的函数（或成员函数）：

* have default arguments, or\n
  具有默认参数，或
* are overloaded with a common sequence of initial arguments\n
  以公共参数序列进行重载

[h2 BOOST_PYTHON_FUNCTION_OVERLOADS]

Boost.Python now has a way to make it easier. For instance, given a function:\n
Boost.Python现在有个更方便的办法。例如，有函数：

    int foo(int a, char b = 1, unsigned c = 2, double d = 3)
    {
        /*...*/
    }

The macro invocation:\n
宏调用：

    BOOST_PYTHON_FUNCTION_OVERLOADS(foo_overloads, foo, 1, 4)

will automatically create the thin wrappers for us. This macro will create
a class [^foo_overloads] that can be passed on to [^def(...)]. The third
and fourth macro argument are the minimum arguments and maximum arguments,
respectively. In our [^foo] function the minimum number of arguments is 1
and the maximum number of arguments is 4. The [^def(...)] function will
automatically add all the foo variants for us:\n
会自动为我们创建薄封装。这个宏将创建类 [^foo_overloads]，可以传递给 [^def(...)]。
第三和第四个宏参数分别是，最小和最大的参数个数。在我们 [^foo] 函数中，参数个数最小是1，最大是4。 
[^def(...)] 函数将自动为我们添加所有foo变量：

    def("foo", foo, foo_overloads());

[h2 BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS]

Objects here, objects there, objects here there everywhere. More frequently
than anything else, we need to expose member functions of our classes to
Python. Then again, we have the same inconveniences as before when default
arguments or overloads with a common sequence of initial arguments come
into play. Another macro is provided to make this a breeze.\n
这里有对象，那里有对象，这里那里到处有对象。比任何其他事情都频繁地，我们需要向Python导出类的成员函数。
但是，和前面一样，对于默认参数或公共参数序列的重载，我们有相同的麻烦。 Boost.Python提供了另一个宏，使这变得轻而易举。

Like [^BOOST_PYTHON_FUNCTION_OVERLOADS],
[^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS] may be used to automatically create
the thin wrappers for wrapping member functions. Let's have an example:\n
像 [^BOOST_PYTHON_FUNCTION_OVERLOADS]，[^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS] 可用于自动创建封装成员函数的薄封装。让我们举一个例子：

    struct george
    {
        void
        wack_em(int a, int b = 0, char c = 'x')
        {
            /*...*/
        }
    };

The macro invocation:\n
宏调用：

    BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(george_overloads, wack_em, 1, 3)

will generate a set of thin wrappers for george's [^wack_em] member function
accepting a minimum of 1 and a maximum of 3 arguments (i.e. the third and
fourth macro argument). The thin wrappers are all enclosed in a class named
[^george_overloads] that can then be used as an argument to [^def(...)]:\n
将为george的 [^wack_em] 成员函数产生一组薄封装，接受最小1最大3个参数（即第三和第四个宏参数）。
薄封装都封闭在类 [^george_overloads] 中，然后该类可以用作 [^def(...)] 的参数：

    .def("wack_em", &george::wack_em, george_overloads());

See the [@../../../v2/overloads.html#BOOST_PYTHON_FUNCTION_OVERLOADS-spec overloads reference]
for details.\n
详情见 [@../../../v2/overloads.html#BOOST_PYTHON_FUNCTION_OVERLOADS-spec 重载说明]。

[h2 init and optional]

A similar facility is provided for class constructors, again, with
default arguments or a sequence of overloads. Remember [^init<...>]? For example,
given a class X with a constructor:\n
此外，对于类构造函数，存在默认参数，或具有一系列重载时，也有类似的工具。还记得 [^init<...>] 吗？例如，类X有构造函数：

    struct X
    {
        X(int a, char b = 'D', std::string c = "constructor", double d = 0.0);
        /*...*/
    }

You can easily add this constructor to Boost.Python in one shot:\n
你可以轻松地，一次性地添加该构造函数到Boost.Python：

    .def(init<int, optional<char, std::string, double> >())

Notice the use of [^init<...>] and [^optional<...>] to signify the default
(optional arguments).\n
注意 [^init<...>] 和 [^optional<...>] 的使用，它们表示默认（可选参数）。 

[endsect]
[section:auto_overloading Auto-Overloading 自动重载]

It was mentioned in passing in the previous section that
[^BOOST_PYTHON_FUNCTION_OVERLOADS] and [^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS]
can also be used for overloaded functions and member functions with a
common sequence of initial arguments. Here is an example:\n
在上一节中顺带提过，[^BOOST_PYTHON_FUNCTION_OVERLOADS] 和 [^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS] 
也能用于具有公共参数序列的函数和成员函数的重载。下面是一个例子：

     void foo()
     {
        /*...*/
     }

     void foo(bool a)
     {
        /*...*/
     }

     void foo(bool a, int b)
     {
        /*...*/
     }

     void foo(bool a, int b, char c)
     {
        /*...*/
     }

Like in the previous section, we can generate thin wrappers for these
overloaded functions in one-shot:\n
就像在上一节中，我们可以一下子就为这些函数生成薄封装：

    BOOST_PYTHON_FUNCTION_OVERLOADS(foo_overloads, foo, 0, 3)

Then...\n
然后...

    .def("foo", (void(*)(bool, int, char))0, foo_overloads());

Notice though that we have a situation now where we have a minimum of zero
(0) arguments and a maximum of 3 arguments.\n
但请注意，这次，我们的参数个数最小是0，最大3。

[h2:manual_wrapping Manual Wrapping 手工封装]

It is important to emphasize however that [*the overloaded functions must
have a common sequence of initial arguments]. Otherwise, our scheme above
will not work. If this is not the case, we have to wrap our functions
[link python.overloading manually].\n
然而，要强调一点，[*重载函数必须具有公共的参数序列]。否则，上述方案是行不通的。
如果情况并非如此，我们不得不 [link python.overloading 手工] 封装我们的函数。

Actually, we can mix and match manual wrapping of overloaded functions and
automatic wrapping through [^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS] and
its sister, [^BOOST_PYTHON_FUNCTION_OVERLOADS]. Following up on our example
presented in the section [link python.overloading on overloading], since the
first 4 overload functins have a common sequence of initial arguments, we
can use [^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS] to automatically wrap the
first three of the [^def]s and manually wrap just the last. Here's
how we'll do this:\n
其实，我们可以通过 [^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS] 及其姊妹，[^BOOST_PYTHON_FUNCTION_OVERLOADS]，
在手工封装重载函数时，混合和搭配自动封装。继续我们在 [link python.overloading 重载] 一节中的所举的例子，
由于前4个重载函数具有一个公共同参数序列，我们可以利用 [^BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS] 
自动封装前3个 [^def]，手工封装仅仅最后一个。我们将这样做：

    BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(xf_overloads, f, 1, 4)

Create a member function pointers as above for both X::f overloads:\n
与前面一样，为两个 X::f 重载创建成员函数指针：

    bool    (X::*fx1)(int, double, char)    = &X::f;
    int     (X::*fx2)(int, int, int)        = &X::f;

Then...\n
然后...

    .def("f", fx1, xf_overloads());
    .def("f", fx2)

[endsect]
[endsect] [/ Functions ]

[section:object Object Interface Object接口]

Python is dynamically typed, unlike C++ which is statically typed. Python
variables may hold an integer, a float, list, dict, tuple, str, long etc.,
among other things. In the viewpoint of Boost.Python and C++, these
Pythonic variables are just instances of class [^object]. We will see in
this chapter how to deal with Python objects.\n
Python是动态类型的，不像C++是静态类型的。 Python变量可以持有整数、浮点数、列表、字典、元组、字符串、长整型等等，还有其他类型。
从Boost.Python和C++的观点看，这些Python变量只是 [^object] 类的实例。在本章，我们将看到，如何处理Python对象。

As mentioned, one of the goals of Boost.Python is to provide a
bidirectional mapping between C++ and Python while maintaining the Python
feel. Boost.Python C++ [^object]s are as close as possible to Python. This
should minimize the learning curve significantly.\n
正如所提到的，Boost.Python的目标之一，是在C++和Python之间提供一个双向映射关系，同时维持Python的感觉。 
Boost.Python C++ [^object] 尽可能地接近Python。这将显著地减小学习难度。

[$images/python.png]

[section:basic_interface Basic Interface 基本接口]

Class [^object] wraps [^PyObject*]. All the intricacies of dealing with
[^PyObject]s such as managing reference counting are handled by the
[^object] class. C++ object interoperability is seamless. Boost.Python C++
[^object]s can in fact be explicitly constructed from any C++ object.\n
[^object] 类封装了 [^PyObject*] 对象。 使用 [^PyObject] 时所有的错综复杂，例如管理引用计数这样的事情，都可以由 [^object] 类处理。 
C++对象的互操作性是无缝的。Boost.Python C++ [^object] 事实上可以从任何C++对象创建。

To illustrate, this Python code snippet:\n
为了说明这一点，这段Python代码片：

[python]

    def f(x, y):
         if (y == 'foo'):
             x[3:7] = 'bar'
         else:
             x.items += y(3, x)
         return x

    def getfunc():
       return f;

Can be rewritten in C++ using Boost.Python facilities this way:\n
利用Boost.Python工具，可以用C++这样重写：

[c++]

    object f(object x, object y) {
         if (y == "foo")
             x.slice(3,7) = "bar";
         else
             x.attr("items") += y(3, x);
         return x;
    }
    object getfunc() {
        return object(f);
    }

Apart from cosmetic differences due to the fact that we are writing the
code in C++, the look and feel should be immediately apparent to the Python
coder.\n
因为我们是在用C++写代码，所以存在表面上的区别，但是其外观与感觉，对Python程序员应该是显而易见的。

[endsect]
[section:derived_object_types Derived Object types  Object派生类型]

Boost.Python comes with a set of derived [^object] types corresponding to
that of Python's:\n
Boost.Python配备了一套 [^object] 派生类型， 对应于Python的对象：

* list
* dict
* tuple
* str
* long_
* enum

These derived [^object] types act like real Python types. For instance:\n
这些 [^object] 派生类型的行为如同真实的Python类型。 例如：

    str(1) ==> "1"

Wherever appropriate, a particular derived [^object] has corresponding
Python type's methods. For instance, [^dict] has a [^keys()] method:\n
一般情况下，特定的 [^object] 派生对象具有相应的Python类型的方法。 例如，[^dict] 有 [^keys()] 方法：

    d.keys()

[^make_tuple] is provided for declaring ['tuple literals]. Example:\n
[^make_tuple] 用来声明 ['元组字面值]。 例如：

    make_tuple(123, 'D', "Hello, World", 0.0);

In C++, when Boost.Python [^object]s are used as arguments to functions,
subtype matching is required. For example, when a function [^f], as
declared below, is wrapped, it will only accept instances of Python's
[^str] type and subtypes.\n
在C++中，当Boost.Python [^object] 用作函数参数时，要求子类型匹配。 
例如，当封装如下声明的函数 [^f] 时， 它只会接受Python的 [^str] 类型及子类型的实例。

    void f(str name)
    {
        object n2 = name.attr("upper")();   // NAME = name.upper()
        str NAME = name.upper();            // better
        object msg = "%s is bigger than %s" % make_tuple(NAME,name);
    }

In finer detail:\n
更详细的：

    str NAME = name.upper();

Illustrates that we provide versions of the str type's methods as C++
member functions.\n
说明，我们以C++成员函数的形式，提供了str类型的各种方法。

    object msg = "%s is bigger than %s" % make_tuple(NAME,name);

Demonstrates that you can write the C++ equivalent of [^"format" % x,y,z]
in Python, which is useful since there's no easy way to do that in std C++.\n
表明，你可以用C++编写Python的 [^"format" % x,y,z]， 这很有用，因为在std C++中没有什么简单的方法来做到这一点。

[blurb
    __alert__ [*Beware] the common pitfall of forgetting that the constructors
    of most of Python's mutable types make copies, just as in Python.\n
    [*要提防] 常见的陷阱， 就像在Python中一样， 不要忘记大部分Python的可变类型的构造函数需要复制。
]

Python:
[python]

    >>> d = dict(x.__dict__)     # copies x.__dict__
    >>> d['whatever'] = 3        # modifies the copy

C++:
[c++]

    dict d(x.attr("__dict__"));  // copies x.__dict__
    d['whatever'] = 3;           // modifies the copy

[h2 class_<T> as objects]

Due to the dynamic nature of Boost.Python objects, any [^class_<T>] may
also be one of these types! The following code snippet wraps the class
(type) object.\n
由于Boost.Python object 的动态性质， 任何 [^class_<T>] 也可以是这种类型！ 下列代码片断封装了 object 类（类型）。 

We can use this to create wrapped instances. Example:\n
我们可以利用这个来创建封装的实例。例如：

    object vec345 = (
        class_<Vec2>("Vec2", init<double, double>())
            .def_readonly("length", &Point::length)
            .def_readonly("angle", &Point::angle)
        )(3.0, 4.0);

    assert(vec345.attr("length") == 5.0);

[endsect]
[section:extracting_c___objects Extracting C++ objects 提取C++ object]

At some point, we will need to get C++ values out of object instances. This
can be achieved with the [^extract<T>] function. Consider the following:\n
有时，我们需要从object实例得到C++值。[^extract<T>] 函数可以做到这一点。 考虑以下代码：

    double x = o.attr("length"); // compile error

In the code above, we got a compiler error because Boost.Python
[^object] can't be implicitly converted to [^double]s. Instead, what
we wanted to do above can be achieved by writing:\n
上面的代码会产生编译错误，因为Boost.Python [^object] 不能隐式地转化为 [^double]。 可以这样改写，以达到我们上面的目的：

    double l = extract<double>(o.attr("length"));
    Vec2& v = extract<Vec2&>(o);
    assert(l == v.length());

The first line attempts to extract the "length" attribute of the Boost.Python
[^object]. The second line attempts to ['extract] the [^Vec2] object from held
by the Boost.Python [^object].\n
第一行试图从 Boost.Python [^object] 提取“length”属性。 第二行试图 ['提取] Boost.Python [^object] 所持有的 [^Vec2] 对象。

Take note that we said "attempt to" above. What if the Boost.Python [^object]
does not really hold a [^Vec2] type? This is certainly a possibility considering
the dynamic nature of Python [^object]s. To be on the safe side, if the C++ type
can't be extracted, an appropriate exception is thrown. To avoid an exception,
we need to test for extractibility:\n
注意，上面我们说的是"试图"。 如果 Boost.Python [^object] 并不真正持有 [^Vec2] 类型呢？ 
考虑到 Python [^object] 的动态性， 这当然是可能的。 为了安全起见，如果不能提取C++的类型，会抛出一个适当的异常。 
为了避免异常，我们需要测试可提取性：

    extract<Vec2&> x(o);
    if (x.check()) {
        Vec2& v = x(); ...

__tip__ The astute reader might have noticed that the [^extract<T>]
facility in fact solves the mutable copying problem:\n
精明的读者可能已经察觉，[^extract<T>] 机制实际上解决了可变复制问题：

    dict d = extract<dict>(x.attr("__dict__"));
    d["whatever"] = 3;          // modifies x.__dict__ !


[endsect]
[section:enums Enums 枚举]

Boost.Python has a nifty facility to capture and wrap C++ enums. While
Python has no [^enum] type, we'll often want to expose our C++ enums to
Python as an [^int]. Boost.Python's enum facility makes this easy while
taking care of the proper conversions from Python's dynamic typing to C++'s
strong static typing (in C++, ints cannot be implicitly converted to
enums). To illustrate, given a C++ enum:\n
Boost.Python有一个巧妙的机制，用来捕捉和封装C++ enum。 Python没有 [^enum] 类型， 而我们常常想按 [^int] 导出我们的C++ enum到Python。 
Boost.Python 的 enum 工具可以轻松完成导出，同时兼顾了从Python的动态类型，
到C++的强静态类型适当的转换 (在C++中，int不能隐式地转化为enum)。 为了说明这一点，假设有一个C++ enum：

    enum choice { red, blue };

the construct:\n
构造：

    enum_<choice>("choice")
        .value("red", red)
        .value("blue", blue)
        ;

can be used to expose to Python. The new enum type is created in the
current [^scope()], which is usually the current module. The snippet above
creates a Python class derived from Python's [^int] type which is
associated with the C++ type passed as its first parameter.\n
用来导出到Python。 在当前 [^scope()] 中， 通常是当前模块中，会创建新的enum类型。 
上述代码片创建了一个Python类，继承自Python的 [^int] 类型， 即作为第一个参数传入的C++类型的相关类型。

[note [*what is a scope? 什么是scope？]

The scope is a class that has an associated global Python object which
controls the Python namespace in which new extension classes and wrapped
functions will be defined as attributes. Details can be found
[@../../../v2/scope.html here].\n
scope 是一个类，它具有一个相关的全局Python对象， 控制着Python名字空间， 其中新的扩展类和封装的函数，被定义为属性。 
详情可以在 [@../../../v2/scope.html 这里] 找到。]

You can access those values in Python as\n
你可以在Python中访问那些值，如下：

[python]

    >>> my_module.choice.red
    my_module.choice.red

where my_module is the module where the enum is declared. You can also
create a new scope around a class:\n
其中，my_module 是声明 enum 的模块。 你也可以围绕类创建一个新的 scope:

[c++]

    scope in_X = class_<X>("X")
                    .def( ... )
                    .def( ... )
                ;

    // Expose X::nested as X.nested
    enum_<X::nested>("nested")
        .value("red", red)
        .value("blue", blue)
        ;

[def Py_Initialize          [@http://www.python.org/doc/current/api/initialization.html#l2h-652  Py_Initialize]]
[def Py_Finalize            [@http://www.python.org/doc/current/api/initialization.html#l2h-656  Py_Finalize]]
[def Py_XINCREF             [@http://www.python.org/doc/current/api/countingRefs.html#l2h-65     Py_XINCREF]]
[def Py_XDECREF             [@http://www.python.org/doc/current/api/countingRefs.html#l2h-67     Py_XDECREF]]
[def PyImport_AppendInittab [@http://www.python.org/doc/current/api/importing.html#l2h-137       PyImport_AppendInittab]]
[def PyImport_AddModule     [@http://www.python.org/doc/current/api/importing.html#l2h-125       PyImport_AddModule]]
[def PyModule_New           [@http://www.python.org/doc/current/api/moduleObjects.html#l2h-591   PyModule_New]]
[def PyModule_GetDict       [@http://www.python.org/doc/current/api/moduleObjects.html#l2h-594   PyModule_GetDict]]

[endsect]
[endsect] [/ Object Interface]

[section:embedding Embedding 内嵌]

By now you should know how to use Boost.Python to call your C++ code from
Python. However, sometimes you may need to do the reverse: call Python code
from the C++-side. This requires you to ['embed] the Python interpreter
into your C++ program.\n
现在你应该知道，如何使用Boost.Python从Python调用你的C++代码。 不过，有时候你可能需要反过来做： 
从C++这边调用Python代码。 这就要求你在C++程序中 ['内嵌] Python解释器。

Currently, Boost.Python does not directly support everything you'll need
when embedding. Therefore you'll need to use the
[@http://www.python.org/doc/current/api/api.html Python/C API] to fill in
the gaps. However, Boost.Python already makes embedding a lot easier and,
in a future version, it may become unnecessary to touch the Python/C API at
all. So stay tuned... :-)\n
目前，Boost.Python不直接支持内嵌时你所需要的一切。 因此，你需要使用 [@http://www.python.org/doc/current/api/api.html Python/C API]
来填补空白。 不过，Boost.Python已经使内嵌方便了许多，并且，在未来的版本中，它有可能变得完全不必触摸Python/C API。 
所以请继续收看... :-) 

[h2 Building embedded programs 构建内嵌程序]

To be able to embed python into your programs, you have to link to
both Boost.Python's as well as Python's own runtime library.\n
为了能够内嵌Python到你的程序，你必须链接Boost.Python及Python本身的运行库。

Boost.Python's library comes in two variants. Both are located
in Boost's [^/libs/python/build/bin-stage] subdirectory. On Windows, the
variants are called [^boost_python.lib] (for release builds) and
[^boost_python_debug.lib] (for debugging). If you can't find the libraries,
you probably haven't built Boost.Python yet. See
[@../../../building.html Building and Testing] on how to do this.\n
Boost.Python库有两种。 都位于Boost的 [^/libs/python/build/bin-stage] 子目录。 
在Windows上，分别是 [^boost_python.lib]（发行版） 和 [^boost_python_debug.lib]（调试版）。 
如果无法找到该库，你可能还没有构建Boost.Python。 如何构建，请看 [@../../../building.html 构建和测试]。

Python's library can be found in the [^/libs] subdirectory of
your Python directory. On Windows it is called pythonXY.lib where X.Y is
your major Python version number.\n
Python的库，可以在你的Python目录的 [^/libs] 子目录下找到。 在Windows上，名为pythonXY.lib，其中X.Y是你主要的Python版本号。

Additionally, Python's [^/include] subdirectory has to be added to your
include path.\n
此外，Python的 [^/include] 子目录必须已添加到你的包含路径。 

In a Jamfile, all the above boils down to:\n
在Jamfile中，所有上述归结为：

[pre
projectroot c:\projects\embedded_program ; # location of the program

# bring in the rules for python
SEARCH on python.jam = $(BOOST_BUILD_PATH) ;
include python.jam ;

exe embedded_program # name of the executable
  : #sources
     embedded_program.cpp
  : # requirements
     <find-library>boost_python <library-path>c:\boost\libs\python
  $(PYTHON_PROPERTIES)
    <library-path>$(PYTHON_LIB_PATH)
    <find-library>$(PYTHON_EMBEDDED_LIBRARY) ;
]

[h2 Getting started 入门]

Being able to build is nice, but there is nothing to build yet. Embedding
the Python interpreter into one of your C++ programs requires these 4
steps:\n
能构建就好，但是还没有什么可构建的。 内嵌Python解释器到一个你的C++程序，需要这4个步骤： 

# '''#include''' [^<boost/python.hpp>]

# Call Py_Initialize() to start the interpreter and create the [^__main__] module.\n
  调用 Py_Initialize()， 来启动解释器及创建 [^__main__] 模块。

# Call other Python C API routines to use the interpreter.\n
  调用其他Python C API函数来使用解释器。

[/ # Call Py_Finalize() to stop the interpreter and release its resources.]

[note [*Note that at this time you must not call Py_Finalize() to stop the
interpreter. This may be fixed in a future version of boost.python.\n
注意，此时你不可调用 Py_Finalize() 停止解释器。 这可能会在Boost.Python未来的版本中修正。]
]

(Of course, there can be other C++ code between all of these steps.)\n
(当然，所有这些步骤之间也可以有其他C++代码。)

[:['[*Now that we can embed the interpreter in our programs, lets see how to put it to use...\n
现在，我们可以在我们的程序内嵌入解释器了，让我们看看如何使用它...]]]

[section:using_the_interpreter Using the interpreter 使用解释器]

As you probably already know, objects in Python are reference-counted.
Naturally, the [^PyObject]s of the Python C API are also reference-counted.
There is a difference however. While the reference-counting is fully
automatic in Python, the Python C API requires you to do it
[@http://www.python.org/doc/current/c-api/refcounting.html by hand]. This is
messy and especially hard to get right in the presence of C++ exceptions.
Fortunately Boost.Python provides the [@../../../v2/handle.html handle] and
[@../../../v2/object.html object] class templates to automate the process.\n
正如您可能已经知道的，Python对象是引用计数的。 自然，Python C API 中的 [^PyObject] 也是引用计数的。 但是两者是有区别的。 
Python的引用计数是全自动的， 而Python/C API则要求你 [@http://www.python.org/doc/current/c-api/refcounting.html 手工] 计数。 
这就很麻烦，特别是存在C++异常的情况下，很难正确处理。 幸好Boost.Python提供了 [@../../../v2/handle.html handle] 和 
[@../../../v2/object.html object] 类模板，以自动化这一过程。 

[h2 Running Python code 运行Python代码]

Boost.python provides three related functions to run Python code from C++.\n
Boost.Python提供了3个相关的函数，用来从C++运行Python代码。

    object eval(str expression, object globals = object(), object locals = object())
    object exec(str code, object globals = object(), object locals = object())
    object exec_file(str filename, object globals = object(), object locals = object())

eval evaluates the given expression and returns the resulting value.
exec executes the given code (typically a set of statements) returning the result,
and exec_file executes the code contained in the given file.\n
eval计算输入表达式的值，并返回结果。 exec执行输入代码（通常是一组语句）并返回结果， 而exec_file执行输入文件中所包含的代码。

The [^globals] and [^locals] parameters are Python dictionaries
containing the globals and locals of the context in which to run the code.
For most intents and purposes you can use the namespace dictionary of the
[^__main__] module for both parameters.\n
[^globals] 和 [^locals] 参数是Python字典，包含代码运行的全局和局部上下文。 
大多数情况下，这两个参数都可以使用 [^__main__] 模块的名字空间字典。

Boost.python provides a function to import a module:\n
Boost.Python提供了一个导入模块的函数：

    object import(str name)

import imports a python module (potentially loading it into the running process
first), and returns it.\n
import导入了一个python模块（可能首先会将它载入到运行进程中），并返回它。

Let's import the [^__main__] module and run some Python code in its namespace:\n
让我们导入 [^__main__] 模块并在其名字空间运行一些Python代码：

    object main_module = import("__main__");
    object main_namespace = main_module.attr("__dict__");

    object ignored = exec("hello = file('hello.txt', 'w')\n"
                          "hello.write('Hello world!')\n"
                          "hello.close()",
                          main_namespace);

This should create a file called 'hello.txt' in the current directory
containing a phrase that is well-known in programming circles.\n
这应该会在当前目录创建一个文件，名为 'hello.txt'， 其中包含一句在编程圈有名的话。 

[h2 Manipulating Python objects 操作Python对象]

Often we'd like to have a class to manipulate Python objects.
But we have already seen such a class above, and in the
[@python/object.html previous section]: the aptly named [^object] class
and its derivatives. We've already seen that they can be constructed from
a [^handle]. The following examples should further illustrate this fact:\n
我们常常想要一个操纵Python对象的类。 但是，前面以及 [@python/object.html 上一节]， 我们已经看到了这样一个类： 
[^object] 及其派生类。 我们已经看到，它们可以从 [^handle] 构造。 以下的例子将进一步说明这一事实：

    object main_module = import("__main__");
    object main_namespace = main_module.attr("__dict__");
    object ignored = exec("result = 5 ** 2", main_namespace);
    int five_squared = extract<int>(main_namespace["result"]);

Here we create a dictionary object for the [^__main__] module's namespace.
Then we assign 5 squared to the result variable and read this variable from
the dictionary. Another way to achieve the same result is to use eval instead,
which returns the result directly:\n
在这里，我们为 [^__main__] 模块的名字空间创建了一个字典对象。 然后，我们将5的平方赋值到result变量， 并从字典读出该变量。 
另一种等效的方法， 是使用 eval，它直接返回结果：

    object result = eval("5 ** 2");
    int five_squared = extract<int>(result);

[h2 Exception handling 异常处理]

If an exception occurs in the evaluation of the python expression,
[@../../../v2/errors.html#error_already_set-spec error_already_set] is thrown:\n
如果计算Python表达式时发生异常，会抛出 [@../../../v2/errors.html#error_already_set-spec error_already_set]： 

    try
    {
        object result = eval("5/0");
        // execution will never get here:
        int five_divided_by_zero = extract<int>(result);
    }
    catch(error_already_set const &)
    {
        // handle the exception in some way
    }

The [^error_already_set] exception class doesn't carry any information in itself.
To find out more about the Python exception that occurred, you need to use the
[@http://www.python.org/doc/api/exceptionHandling.html exception handling functions]
of the Python C API in your catch-statement. This can be as simple as calling
[@http://www.python.org/doc/api/exceptionHandling.html#l2h-70 PyErr_Print()] to
print the exception's traceback to the console, or comparing the type of the
exception with those of the [@http://www.python.org/doc/api/standardExceptions.html
standard exceptions]:\n
该 [^error_already_set] 异常类本身不带任何信息。 为了查明所发生的异常， 你需要在你的catch语句中使用Python/C API的 
[@http://www.python.org/doc/api/exceptionHandling.html 异常处理函数] 这可以简单地调用 
[@http://www.python.org/doc/api/exceptionHandling.html#l2h-70 PyErr_Print()]， 来打印异常的traceback到控制台， 或者与 
[@http://www.python.org/doc/api/standardExceptions.html 标准异常] 比较类型：

    catch(error_already_set const &)
    {
        if (PyErr_ExceptionMatches(PyExc_ZeroDivisionError))
        {
            // handle ZeroDivisionError specially
        }
        else
        {
            // print all other errors to stderr
            PyErr_Print();
        }
    }

(To retrieve even more information from the exception you can use some of the other
exception handling functions listed [@http://www.python.org/doc/api/exceptionHandling.html here].)\n
(为了从异常获取更多信息， 你可以使用 [@http://www.python.org/doc/api/exceptionHandling.html 这里] 所列的一些其他的异常处理函数。)

[endsect]
[endsect] [/ Embedding]

[section:iterators Iterators 迭代器]

In C++, and STL in particular, we see iterators everywhere. Python also has
iterators, but these are two very different beasts.\n
在C++，特别是STL中，我们到处看到迭代器。 Python也有迭代器，但它们是两个非常不同的野兽。

[*C++ iterators:  C++迭代器:]

* C++ has 5 type categories (random-access, bidirectional, forward, input, output)\n
  在C++中有5个迭代器类别（随机访问、双向、前向、输入、输出）
* There are 2 Operation categories: reposition, access\n
  有2个操作类别：重定位、访问
* A pair of iterators is needed to represent a (first/last) range.\n
  需要一对迭代器表示一个（第一/最后）区间。

[*Python Iterators:  Python迭代器:]

* 1 category (forward)\n
  1个类别（前向）
* 1 operation category (next())\n
  1个操作类别（next()） 
* Raises StopIteration exception at end\n
  结束时抛StopIteration异常

The typical Python iteration protocol: [^[*for y in x...]] is as follows:\n
典型的Python迭代协议：[^[*for y in x...]] 如下：

[python]

    iter = x.__iter__()         # get iterator
    try:
        while 1:
        y = iter.next()         # get each item
        ...                     # process y
    except StopIteration: pass  # iterator exhausted

Boost.Python provides some mechanisms to make C++ iterators play along
nicely as Python iterators. What we need to do is to produce
appropriate `__iter__` function from C++ iterators that is compatible
with the Python iteration protocol. For example:\n
Boost.Python提供了一些机制， 使C++迭代器可以作为Python迭代器很好地运行。 
我们需要做的就是，要从C++迭代器产生适当的 `__iter__` 函数，与Python迭代协议兼容。 例如：

[c++]

    object get_iterator = iterator<vector<int> >();
    object iter = get_iterator(v);
    object first = iter.next();

Or for use in class_<>:\n
或用于 class_<>： 

    .def("__iter__", iterator<vector<int> >())

[*range]

We can create a Python savvy iterator using the range function:\n
我们可以用 range 函数创建一个Python的迭代器：

* range(start, finish)
* range<Policies,Target>(start, finish)

Here, start/finish may be one of:\n
其中，start/finish 可以是下列任一：

* member data pointers\n
  成员数据指针
* member function pointers\n
  成员函数指针
* adaptable function object (use Target parameter)\n
  可适配函数对旬（使用Target参数）

[*iterator]

* iterator<T, Policies>()

Given a container [^T], iterator is a shortcut that simply calls [^range]
with &T::begin, &T::end.\n
给定容器 [^T]， iterator 是用 &T::begin、&T::end 简单调用 [^range] 的快捷方式。

Let's put this into action... Here's an example from some hypothetical
bogon Particle accelerator code:\n
让我们付诸实践... 假设有一段粒子加速器的代码如下：

[python]

    f = Field()
    for x in f.pions:
        smash(x)
    for y in f.bogons:
        count(y)

Now, our C++ Wrapper:\n
现在，我们的C++封装：

[c++]

    class_<F>("Field")
        .property("pions", range(&F::p_begin, &F::p_end))
        .property("bogons", range(&F::b_begin, &F::b_end));

[*stl_input_iterator]

So far, we have seen how to expose C++ iterators and ranges to Python.
Sometimes we wish to go the other way, though: we'd like to pass a
Python sequence to an STL algorithm or use it to initialize an STL
container. We need to make a Python iterator look like an STL iterator.
For that, we use `stl_input_iterator<>`. Consider how we might
implement a function that exposes `std::list<int>::assign()` to
Python:\n
到目前为止，我们已经看到如何导出C++的迭代器和区间到Python。 然而有时候，我们希望能走另一条路： 
我们想传入一个Python序列，到STL算法， 或用它来初始化STL容器。 我们需要让Python迭代器看起来像一个STL迭代器。 
为此，我们使用 `stl_input_iterator<>`。 考虑我们如何实现一个函数，导出 `std::list<int>::assign()` 到Python。

[c++]

    template<typename T>
    void list_assign(std::list<T>& l, object o) {
        // Turn a Python sequence into an STL input range
        stl_input_iterator<T> begin(o), end;
        l.assign(begin, end);
    }

    // Part of the wrapper for list<int>
    class_<std::list<int> >("list_int")
        .def("assign", &list_assign<int>)
        // ...
        ;

Now in Python, we can assign any integer sequence to `list_int` objects:\n
现在，在Python中，我们就可以将任何整数序列赋值到 `list_int` 对象：

[python]

    x = list_int();
    x.assign([1,2,3,4,5])

[endsect]
[section:exception Exception Translation 异常翻译]

All C++ exceptions must be caught at the boundary with Python code. This
boundary is the point where C++ meets Python. Boost.Python provides a
default exception handler that translates selected standard exceptions,
then gives up:\n
所有的C++异常必须在Python代码的边界处捕获。 这个边界，是C++与Python的接触点。 
Boost.Python提供了一个默认的异常处理程序， 它翻译选定的标准异常，然后给出：

    raise RuntimeError, 'unidentifiable C++ Exception'

Users may provide custom translation. Here's an example:\n
用户可提供定制翻译。下面是一个例子：

    struct PodBayDoorException;
    void translator(PodBayDoorException const& x) {
        PyErr_SetString(PyExc_UserWarning, "I'm sorry Dave...");
    }
    BOOST_PYTHON_MODULE(kubrick) {
         register_exception_translator<
              PodBayDoorException>(translator);
         ...

[endsect]
[section:techniques General Techniques 通用技术]

Here are presented some useful techniques that you can use while wrapping code with Boost.Python.\n
这里介绍了一些有用的技巧，可以在用Boost.Python封装代码时使用。

[section:creating_packages Creating Packages 创建包]

A Python package is a collection of modules that provide to the user a certain
functionality. If you're not familiar on how to create packages, a good
introduction to them is provided in the
[@http://www.python.org/doc/current/tut/node8.html Python Tutorial].\n
Python包是一个模块集合，提供给用户一定的功能。 如果您不熟悉如何创建软件包，在 
[@http://www.python.org/doc/current/tut/node8.html Python教程] 中有一个很好的介绍。

But we are wrapping C++ code, using Boost.Python. How can we provide a nice
package interface to our users? To better explain some concepts, let's work
with an example.\n
但是，我们是在用Boost.Python封装C++代码。 我们怎样才能向我们的用户提供一个漂亮的软件包接口？ 
为了更好地解释一些概念，让我们举个例子。

We have a C++ library that works with sounds: reading and writing various
formats, applying filters to the sound data, etc. It is named (conveniently)
[^sounds].  Our library already has a neat C++ namespace hierarchy, like so:\n
我们有一个C++声音库：读写各种格式、对声音数据应用过滤器，等等。 它（方便地）命名为 [^sounds]。 
我们库已经有一个整洁的C++名字空间层次，像这样：

    sounds::core
    sounds::io
    sounds::filters

We would like to present this same hierarchy to the Python user, allowing him
to write code like this:\n
我们想向Python用户呈现这一相同的层次结构，让他可以这样写代码：

    import sounds.filters
    sounds.filters.echo(...) # echo is a C++ function

The first step is to write the wrapping code. We have to export each module
separately with Boost.Python, like this:\n
第一步是编写封装代码。 我们必须用Boost.Python分别导出每个模块，像这样：

    /* file core.cpp */
    BOOST_PYTHON_MODULE(core)
    {
        /* export everything in the sounds::core namespace */
        ...
    }

    /* file io.cpp */
    BOOST_PYTHON_MODULE(io)
    {
        /* export everything in the sounds::io namespace */
        ...
    }

    /* file filters.cpp */
    BOOST_PYTHON_MODULE(filters)
    {
        /* export everything in the sounds::filters namespace */
        ...
    }

Compiling these files will generate the following Python extensions:
[^core.pyd], [^io.pyd] and [^filters.pyd].\n
编译这些文件会生成以下Python扩展：[^core.pyd], [^io.pyd] 和 [^filters.pyd]。

[note The extension [^.pyd] is used for python extension modules, which
are just shared libraries.  Using the default for your system, like [^.so] for
Unix and [^.dll] for Windows, works just as well.\n
Python扩展模块用了扩展名 [^.pyd]， 但它只不过是共享库。 也可以使用你系统默认的扩展名， 如Unix上是 [^.so]， Windows上是 [^.dll]。]

Now, we create this directory structure for our Python package:\n
现在，我们为我们的Python包建立了这个目录结构：

[pre
sounds/
    \_\_init\_\_.py
    core.pyd
    filters.pyd
    io.pyd
]

The file [^\_\_init\_\_.py] is what tells Python that the directory [^sounds/] is
actually a Python package. It can be a empty file, but can also perform some
magic, that will be shown later.\n
文件 [^\_\_init\_\_.py] 将告诉Python，[^sounds/] 其实是一个Python包。 它可以是一个空文件，但也可以执行一些魔术，将在稍后展示。

Now our package is ready. All the user has to do is put [^sounds] into his
[@http://www.python.org/doc/current/tut/node8.html#SECTION008110000000000000000 PYTHONPATH]
and fire up the interpreter:\n
现在我们的软件包已经准备就绪。 用户只需将 [^sounds] 放入他的 
[@http://www.python.org/doc/current/tut/node8.html#SECTION008110000000000000000 PYTHONPATH]， 然后打开解释器：

[python]

    >>> import sounds.io
    >>> import sounds.filters
    >>> sound = sounds.io.open('file.mp3')
    >>> new_sound = sounds.filters.echo(sound, 1.0)

Nice heh?\n
漂亮吧？

This is the simplest way to create hierarchies of packages, but it is not very
flexible. What if we want to add a ['pure] Python function to the filters
package, for instance, one that applies 3 filters in a sound object at once?
Sure, you can do this in C++ and export it, but why not do so in Python? You
don't have to recompile the extension modules, plus it will be easier to write
it.\n
这是创建软件包层次结构最简单的方法，但它不是很灵活。 
如果我们想要在filters包中加入一个 ['纯] Python的函数， 比如，在sound对象中，一次应用3个过滤器， 该怎么做呢？ 
当然，你可以用C++做并导出它， 但为什么不在Python中做呢？ 这样，你不必重新编译扩展模块，再加上会比较容易写。

If we want this flexibility, we will have to complicate our package hierarchy a
little. First, we will have to change the name of the extension modules:\n
如果我们想要这种灵活性， 我们将不得不让我们的包结构复杂一点。 首先，我们必须改变扩展模块的名称：

[c++]

    /* file core.cpp */
    BOOST_PYTHON_MODULE(_core)
    {
        ...
        /* export everything in the sounds::core namespace */
    }

Note that we added an underscore to the module name. The filename will have to
be changed to [^_core.pyd] as well, and we do the same to the other extension modules.
Now, we change our package hierarchy like so:\n
注意，我们给模块名添加了下划线。 同时文件名将不得不改为 [^_core.pyd]， 而且，其他扩展模块也同样处理。 
现在，我们软件包的层次结构改为象这样：

[pre
sounds/
    \_\_init\_\_.py
    core/
        \_\_init\_\_.py
        _core.pyd
    filters/
        \_\_init\_\_.py
        _filters.pyd
    io/
        \_\_init\_\_.py
        _io.pyd
]

Note that we created a directory for each extension module, and added a
\_\_init\_\_.py to each one. But if we leave it that way, the user will have to
access the functions in the core module with this syntax:\n
注意，我们为每个扩展模块创建一个目录， 并且为每个目录添加一个 \_\_init\_\_.py。 
但是，如果我们随它这样， 用户将不得不用这种语法访问核心模块中的功能：

[python]

    >>> import sounds.core._core
    >>> sounds.core._core.foo(...)

which is not what we want. But here enters the [^\_\_init\_\_.py] magic: everything
that is brought to the [^\_\_init\_\_.py] namespace can be accessed directly by the
user.  So, all we have to do is bring the entire namespace from [^_core.pyd]
to [^core/\_\_init\_\_.py]. So add this line of code to [^sounds/core/\_\_init\_\_.py]:\n
这不是我们想要的。 但 [^\_\_init\_\_.py] 魔术开始了： 进入 [^\_\_init\_\_.py] 名字空间的所有东西， 用户都可能直接访问。 
因此，我们要做的就是，将整个名字空间从 [^_core.pyd] 引到 [^core/\_\_init\_\_.py]。 
所以在 [^sounds/core/\_\_init\_\_.py] 中加入这行代码：

    from _core import *

We do the same for the other packages. Now the user accesses the functions and
classes in the extension modules like before:\n
其他包同样处理。 现在，用户可以和以前一样访问扩展模块中的函数和类了：

    >>> import sounds.filters
    >>> sounds.filters.echo(...)

with the additional benefit that we can easily add pure Python functions to
any module, in a way that the user can't tell the difference between a C++
function and a Python function. Let's add a ['pure] Python function,
[^echo_noise], to the [^filters] package. This function applies both the
[^echo] and [^noise] filters in sequence in the given [^sound] object. We
create a file named [^sounds/filters/echo_noise.py] and code our function:\n
额外的好处是，我们现在可以轻易地在任何模块中加入纯Python函数， 让用户不必区分C++函数和Python函数。 
让我们向 [^filters] 包 添加一个['纯]的函数，[^echo_noise]。 该函数对输入的 [^sound] 对象 依次应用 [^echo] 和 [^noise] 过滤器。 
我们创建一个 [^sounds/filters/echo_noise.py] 文件，并如下编写我们的函数：

    import _filters
    def echo_noise(sound):
        s = _filters.echo(sound)
        s = _filters.noise(sound)
        return s

Next, we add this line to [^sounds/filters/\_\_init\_\_.py]:\n
接着，我们把这一行加入 [^sounds/filters/\_\_init\_\_.py]：

    from echo_noise import echo_noise

And that's it. The user now accesses this function like any other function
from the [^filters] package:\n
就是这样。用户现在可以像 [^filters] 包中的任何其他函数一样访问这个函数了：

    >>> import sounds.filters
    >>> sounds.filters.echo_noise(...)

[endsect]
[section:extending_wrapped_objects_in_python Extending Wrapped Objects in Python 在Python中扩展封装的对象]

Thanks to Python's flexibility, you can easily add new methods to a class,
even after it was already created:\n
感谢Python的灵活性，你可以很容易地在类中添加新的方法， 即使是在类创建之后： 

    >>> class C(object): pass
    >>>
    >>> # a regular function
    >>> def C_str(self): return 'A C instance!'
    >>>
    >>> # now we turn it in a member function
    >>> C.__str__ = C_str
    >>>
    >>> c = C()
    >>> print c
    A C instance!
    >>> C_str(c)
    A C instance!

Yes, Python rox. :-)\n
耶，Python 真棒。:-)

We can do the same with classes that were wrapped with Boost.Python. Suppose
we have a class [^point] in C++:\n
我们可以对用Boost.Python封装的类做同样事。 假设我们有一个 [^point] C++类：

[c++]

    class point {...};

    BOOST_PYTHON_MODULE(_geom)
    {
        class_<point>("point")...;
    }

If we are using the technique from the previous session,
[link python.creating_packages Creating Packages], we can code directly
into [^geom/\_\_init\_\_.py]:\n
如果我们使用上一节，[link python.creating_packages 创建包] 中的技术，我们可以在 [^geom/\_\_init\_\_.py] 中直接编码：

[python]

    from _geom import *

    # a regular function
    def point_str(self):
        return str((self.x, self.y))

    # now we turn it into a member function
    point.__str__ = point_str

[*All] point instances created from C++ will also have this member function!
This technique has several advantages:\n
[*所有] 从C++创建的point实例都会拥有这个成员函数！ 这种技术具有几个优势：

* Cut down compile times to zero for these additional functions\n
  这些附加函数的编译时间为零
* Reduce the memory footprint to virtually zero\n
  内存占用几乎为零
* Minimize the need to recompile\n
  尽量减少了重编译的需要
* Rapid prototyping (you can move the code to C++ if required without changing the interface)\n
  快速原型（如有需要，你可以把代码移到C++，而不必更改接口）

You can even add a little syntactic sugar with the use of metaclasses. Let's
create a special metaclass that "injects" methods in other classes.\n
你甚至可以使用元类来添加少许语法糖。 让我们创建一个特别的元类，用来向其他类“注入”方法。

    # The one Boost.Python uses for all wrapped classes.
    # You can use here any class exported by Boost instead of "point"
    BoostPythonMetaclass = point.__class__

    class injector(object):
        class __metaclass__(BoostPythonMetaclass):
            def __init__(self, name, bases, dict):
                for b in bases:
                    if type(b) not in (self, type):
                        for k,v in dict.items():
                            setattr(b,k,v)
                return type.__init__(self, name, bases, dict)

    # inject some methods in the point foo
    class more_point(injector, point):
        def __repr__(self):
            return 'Point(x=%s, y=%s)' % (self.x, self.y)
        def foo(self):
            print 'foo!'

Now let's see how it got:\n
现在让我们来看看结果：

    >>> print point()
    Point(x=10, y=10)
    >>> point().foo()
    foo!

Another useful idea is to replace constructors with factory functions:\n
另一种有用的想法是，用工厂函数取代构造函数：

    _point = point

    def point(x=0, y=0):
        return _point(x, y)

In this simple case there is not much gained, but for constructurs with
many overloads and/or arguments this is often a great simplification, again
with virtually zero memory footprint and zero compile-time overhead for
the keyword support.\n
在这个简单的例子中，它并没有什么用， 但如果构造函数具有许多重载，或者具有许多参数， 
这往往是一个巨大的简化， 而开销仍然是：几乎零内存占用和零编译时间。

[endsect]
[section:reducing_compiling_time Reducing Compiling Time 减少编译时间]

If you have ever exported a lot of classes, you know that it takes quite a good
time to compile the Boost.Python wrappers. Plus the memory consumption can
easily become too high. If this is causing you problems, you can split the
class_ definitions in multiple files:\n
如果你曾经导出了很多类， 你会知道， 编译Boost.Python封装需要好长时间。 还有内存消耗会轻易地升至很高。 
如果这会造成问题， 你可以将class_定义分割到多个文件：

[c++]

    /* file point.cpp */
    #include <point.h>
    #include <boost/python.hpp>

    void export_point()
    {
        class_<point>("point")...;
    }

    /* file triangle.cpp */
    #include <triangle.h>
    #include <boost/python.hpp>

    void export_triangle()
    {
        class_<triangle>("triangle")...;
    }

Now you create a file [^main.cpp], which contains the [^BOOST_PYTHON_MODULE]
macro, and call the various export functions inside it.\n
现在你创建一个 [^main.cpp] 文件， 让它包含 [^BOOST_PYTHON_MODULE] 宏， 并在里面调用各导出函数。

    void export_point();
    void export_triangle();

    BOOST_PYTHON_MODULE(_geom)
    {
        export_point();
        export_triangle();
    }

Compiling and linking together all this files produces the same result as the
usual approach:\n
编译和链接所有这些文件，与以下通常的方法相比，结果是一样的：

    #include <boost/python.hpp>
    #include <point.h>
    #include <triangle.h>

    BOOST_PYTHON_MODULE(_geom)
    {
        class_<point>("point")...;
        class_<triangle>("triangle")...;
    }

but the memory is kept under control.\n
但内存占用会受到控制。 

This method is recommended too if you are developing the C++ library and
exporting it to Python at the same time: changes in a class will only demand
the compilation of a single cpp, instead of the entire wrapper code.\n
如果你正在开发C++库， 并同时将它导出到Python， 推荐你也使用该方法： 一个类中的更改， 只需编译一个cpp， 而不是整个封装代码。

[note If you're exporting your classes with [@../../../../pyste/index.html Pyste],
take a look at the [^--multiple] option, that generates the wrappers in
various files as demonstrated here.\n
如果你是用 [@../../../../pyste/index.html Pyste] 导出类，请看看 [^--multiple] 选项， 它会生成多个封装文件， 就像这里所展示的那样。]

[note This method is useful too if you are getting the error message
['"fatal error C1204:Compiler limit:internal structure overflow"] when compiling
a large source file, as explained in the [@../../../v2/faq.html#c1204 FAQ].\n
当你编译一个大文件时， 如果遇到错误信息 ['"fatal error C1204:Compiler limit:internal structure overflow"]
（“致命错误C1204：编译器限制：内部结构溢出”）， 该方法也是有用的， 解释见 [@../../../v2/faq.html#c1204 FAQ]。]

[endsect]
[endsect] [/ General Techniques]



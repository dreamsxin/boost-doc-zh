t<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>



<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docutils 0.2.8: http://docutils.sourceforge.net/">
<title>Building Hybrid Systems with Boost.Python</title>

<meta name="author" content="David Abrahams">
<meta name="organization" content="Boost Consulting">
<meta name="date" content="2003-03-19">
<meta name="author" content="Ralf W. Grosse-Kunstleve">
<meta name="copyright" content="Copyright David Abrahams and Ralf W. Grosse-Kunstleve 2003. All rights reserved">
<meta name="translation" content="王志勇，Slowness Chen，金庆">
<style type="text/css"><!--

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2003/03/20 02:56:22 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

--></style></head><body>
<div class="document" id="building-hybrid-systems-with-boost-python">
<h1 class="title"><a href="http://www.boost-consulting.com/writing/bpl.html">
Building Hybrid Systems with Boost.Python</a></h1>
<h1 class="title">用Boost.Python构建混合系统</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name">
<col class="docinfo-content">
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>David Abrahams</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:dave@boost-consulting.com">dave@boost-consulting.com</a></td></tr>
<tr><th class="docinfo-name">Organization:</th>
<td><a class="first last reference" href="http://www.boost-consulting.com/">Boost Consulting</a></td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2003-03-19</td></tr>
<tr><th class="docinfo-name">Author:</th>
<td>Ralf W. Grosse-Kunstleve</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>Copyright David Abrahams and Ralf W. Grosse-Kunstleve 2003. All rights reserved</td></tr>
<tr><th class="docinfo-name">翻译:</th>
<td><a href="http://jerrywang-cn.spaces.live.com/blog/cns!7762C01175E3FC8!196.entry">王志勇</a>，
<a href="http://my.donews.com/slowness/2006/04/09">Slowness Chen</a>，
<a href="http://blog.csdn.net/jq0123">金庆</a></td></tr>
<tr><th class="docinfo-name">译文更新:</th>
<td>2008-05-29</td></tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#abstract" id="id5" name="id5">Abstract</a></li>
<li><a class="reference" href="#introduction" id="id6" name="id6">Introduction</a></li>
<li><a class="reference" href="#boost-python-design-goals" id="id7" name="id7">Boost.Python Design Goals</a></li>
<li><a class="reference" href="#hello-boost-python-world" id="id8" name="id8">Hello Boost.Python World</a></li>
<li><a class="reference" href="#library-overview" id="id9" name="id9">Library Overview</a><ul>
<li><a class="reference" href="#exposing-classes" id="id10" name="id10">Exposing Classes</a><ul>
<li><a class="reference" href="#constructors" id="id11" name="id11">Constructors</a></li>
<li><a class="reference" href="#data-members-and-properties" id="id12" name="id12">Data Members and Properties</a></li>
<li><a class="reference" href="#operator-overloading" id="id13" name="id13">Operator Overloading</a></li>
<li><a class="reference" href="#inheritance" id="id14" name="id14">Inheritance</a></li>
<li><a class="reference" href="#virtual-functions" id="id15" name="id15">Virtual Functions</a></li>
<li><a class="reference" href="#deeper-reflection-on-the-horizon" id="id16" name="id16">Deeper Reflection on the Horizon?</a></li>
</ul>
</li>
<li><a class="reference" href="#serialization" id="id17" name="id17">Serialization</a></li>
<li><a class="reference" href="#object-interface" id="id18" name="id18">Object interface</a></li>
</ul>
</li>
<li><a class="reference" href="#thinking-hybrid" id="id19" name="id19">Thinking hybrid</a></li>
<li><a class="reference" href="#development-history" id="id20" name="id20">Development history</a></li>
<li><a class="reference" href="#conclusions" id="id21" name="id21">Conclusions</a></li>
<li><a class="reference" href="#citations" id="id22" name="id22">Citations</a></li>
<li><a class="reference" href="#footnotes" id="id23" name="id23">Footnotes</a></li>
</ul>
</div>

<div class="contents topic" id="table-of-contents_cn">
<p class="topic-title"><a name="table-of-contents_cn">目录</a></p>
<ul class="simple">
<li><a class="reference" href="#abstract" id="id5_cn" name="id5_cn">摘要</a></li>
<li><a class="reference" href="#introduction" id="id6_cn" name="id6_cn">介绍</a></li>
<li><a class="reference" href="#boost-python-design-goals" id="id7_cn" name="id7_cn">Boost.Python的设计目标</a></li>
<li><a class="reference" href="#hello-boost-python-world" id="id8_cn" name="id8_cn">Hello Boost.Python World</a></li>
<li><a class="reference" href="#library-overview" id="id9_cn" name="id9_cn">库概览</a><ul>
<li><a class="reference" href="#exposing-classes" id="id10_cn" name="id10_cn">导出类</a><ul>
<li><a class="reference" href="#constructors" id="id11_cn" name="id11_cn">构造函数</a></li>
<li><a class="reference" href="#data-members-and-properties" id="id12_cn" name="id12_cn">数据成员和属性</a></li>
<li><a class="reference" href="#operator-overloading" id="id13_cn" name="id13_cn">运算符重载</a></li>
<li><a class="reference" href="#inheritance" id="id14_cn" name="id14_cn">继承</a></li>
<li><a class="reference" href="#virtual-functions" id="id15_cn" name="id15_cn">虚函数</a></li>
<li><a class="reference" href="#deeper-reflection-on-the-horizon" id="id16_cn" name="id16_cn">更深的反射即将出现？</a></li>
</ul>
</li>
<li><a class="reference" href="#serialization" id="id17_cn" name="id17_cn">序列化</a></li>
<li><a class="reference" href="#object-interface" id="id18_cn" name="id18_cn">Object接口</a></li>
</ul>
</li>
<li><a class="reference" href="#thinking-hybrid" id="id19_cn" name="id19_cn">混合地思考</a></li>
<li><a class="reference" href="#development-history" id="id20_cn" name="id20_cn">开发历史</a></li>
<li><a class="reference" href="#conclusions" id="id21_cn" name="id21_cn">结论</a></li>
<li><a class="reference" href="#citations" id="id22_cn" name="id22_cn">引用</a></li>
<li><a class="reference" href="#footnotes" id="id23_cn" name="id23_cn">脚注</a></li>
</ul>
</div>

<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5" name="abstract">Abstract</a></h1>
<h1>摘要</h1>
<p>Boost.Python is an open source C++ library which provides a concise
IDL-like interface for binding C++ classes and functions to
Python. Leveraging the full power of C++ compile-time introspection
and of recently developed metaprogramming techniques, this is achieved
entirely in pure C++, without introducing a new syntax.
Boost.Python's rich set of features and high-level interface make it
possible to engineer packages from the ground up as hybrid systems,
giving programmers easy and coherent access to both the efficient
compile-time polymorphism of C++ and the extremely convenient run-time
polymorphism of Python.</p>
<p>
Boost.Python是一个开源C++库，
它提供了一个简明的IDL式的接口，
用于把C++类和函数绑定到Python。
借助C++强大的编译时内省能力和最近发展的元编程技术，
绑定工作完全用纯C++实现，
而没有引入新的语法。

Boost.Python丰富的特性和高级接口，
使得完全按混合系统设计软件包成为可能，
并让程序员以轻松连贯的方式，同时使用
C++高效的编译时多态，
和Python极端便利的运行时多态。
</p>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id6" name="introduction">Introduction</a></h1>
<h1>介绍</h1>
<p>Python and C++ are in many ways as different as two languages could
be: while C++ is usually compiled to machine-code, Python is
interpreted.  Python's dynamic type system is often cited as the
foundation of its flexibility, while in C++ static typing is the
cornerstone of its efficiency. C++ has an intricate and difficult
compile-time meta-language, while in Python, practically everything
happens at runtime.</p>
<p>
作为两种语言，Python和C++存在很多差异。
C++一般被编译为机器码，
而Python是解释执行的。
Python的动态类型系统通常被认为是它灵活性的基础，
而C++的静态类型系统是C++效率的基石。
C++有一种复杂艰深的编译时元语言，
而在Python中，几乎一切都发生在运行时。
</p>
<p>Yet for many programmers, these very differences mean that Python and
C++ complement one another perfectly.  Performance bottlenecks in
Python programs can be rewritten in C++ for maximal speed, and
authors of powerful C++ libraries choose Python as a middleware
language for its flexible system integration capabilities.
Furthermore, the surface differences mask some strong similarities:</p>
<p>
然而对很多程序员来说，
这些差异也意味着Python和C++可以完美互补。
为了提高运行速度，Python程序的性能瓶颈可以用C++重写，
而大型C++库的作者们，
为了获得灵活的系统集成能力，
选择Python作为中间件语言。
此外，在表面差异掩盖之下，二者有一些非常相似之处：
</p>

<ul class="simple">
<li>'C'-family control structures (if, while, for...)</li>
<li>Support for object-orientation, functional programming, and generic
programming (these are both <em>multi-paradigm</em> programming languages.)</li>
<li>Comprehensive operator overloading facilities, recognizing the
importance of syntactic variability for readability and
expressivity.</li>
<li>High-level concepts such as collections and iterators.</li>
<li>High-level encapsulation facilities (C++: namespaces, Python: modules)
to support the design of re-usable libraries.</li>
<li>Exception-handling for effective management of error conditions.</li>
<li>C++ idioms in common use, such as handle/body classes and
reference-counted smart pointers mirror Python reference semantics.</li>
</ul>

<ul class="simple">
<li>'C'-家族的控制结构（if, while, for...）</li>
<li>支持面向对象、函数式编程，以及泛型编程
（它们都是<em>多范式（multi-paradigm）</em>编程语言。）</li>
<li>认同语法可变性（syntactic variability）
对于提高代码可读性和表达力的重要作用，
提供了对运算符重载的广泛支持。</li>
<li>高级概念，如集合和迭代器。</li>
<li>高级封装机制（C++：名字空间，Python：模块），以支持可重用库的设计。</li>
<li>异常处理，提供有效的错误管理。</li>
<li>通用的C++惯用法，如handle/body类，和引用计数的智能指针，
即Python的引用语义。</li>
</ul>

<p>Given Python's rich 'C' interoperability API, it should in principle
be possible to expose C++ type and function interfaces to Python with
an analogous interface to their C++ counterparts.  However, the
facilities provided by Python alone for integration with C++ are
relatively meager.  Compared to C++ and Python, 'C' has only very
rudimentary abstraction facilities, and support for exception-handling
is completely missing.  'C' extension module writers are required to
manually manage Python reference counts, which is both annoyingly
tedious and extremely error-prone. Traditional extension modules also
tend to contain a great deal of boilerplate code repetition which
makes them difficult to maintain, especially when wrapping an evolving
API.</p>
<p>
因为Python有着丰富的'C'语言集成API，
原则上，向Python导出C++类型和函数接口应该是可行的，
并且导出的接口与对应C++的接口应该是相似的。
然而，Python本身提供的C++集成功能相对比较弱。
和C++，Python相比，
'C'只有非常基本的抽象能力，
而且完全不支持异常处理。
'C'扩展模块的作者必须手工管理Python的引用计数，
这不仅单调乏味，令人恼火，而且还极易出错。
传统的扩展模块往往包含大量重复的样板代码，
使它们难以维护，
尤其是当要封装的API尚处于发展之中。
</p>
<p>These limitations have lead to the development of a variety of wrapping
systems.  <a class="reference" href="http://www.swig.org/">SWIG</a> is probably the most popular package for the
integration of C/C++ and Python. A more recent development is <a class="reference" href="http://www.riverbankcomputing.co.uk/sip/index.php">SIP</a>,
which was specifically designed for interfacing Python with the <a class="reference" href="http://www.trolltech.com/">Qt</a>
graphical user interface library.  Both SWIG and SIP introduce their
own specialized languages for customizing inter-language bindings.
This has certain advantages, but having to deal with three different
languages (Python, C/C++ and the interface language) also introduces
practical and mental difficulties.  The <a class="reference" href="http://cxx.sourceforge.net/">CXX</a> package demonstrates an
interesting alternative.  It shows that at least some parts of
Python's 'C' API can be wrapped and presented through a much more
user-friendly C++ interface. However, unlike SWIG and SIP, CXX does
not include support for wrapping C++ classes as new Python types.</p>
<p>
这些限制导致了多种封装系统的发展。
<a class="reference" href="http://www.swig.org/">SWIG</a>
可能是最流行的C/C++和Python集成系统。
还有最近发展的
<a class="reference" href="http://www.riverbankcomputing.co.uk/sip/index.php">SIP</a>，
它是专门为
<a class="reference" href="http://www.trolltech.com/">Qt</a>
图形用户界面库设计的，
用于提供Qt的Python接口。

为了定制语言间的绑定，SWIG和SIP都引入了它们自己的专用语言。
这有一定的好处，
但是你不得不去应付三种不同语言（Python、C/C++和接口语言），
所以也带来了事实上和心理上的困难。

<a class="reference" href="http://cxx.sourceforge.net/">CXX</a>软件包
展示了另一种令人感兴趣的选择。
它显示，至少可以封装部分Python 'C' API，
将它们表示为更友好的C++接口。
然而，不像SWIG和SIP，
CXX不能将C++类封装成新的Python类型。
</p>

<p>The features and goals of <a class="reference" href="http://www.boost.org/libs/python/doc">Boost.Python</a> overlap significantly with
many of these other systems.  That said, Boost.Python attempts to
maximize convenience and flexibility without introducing a separate
wrapping language.  Instead, it presents the user with a high-level
C++ interface for wrapping C++ classes and functions, managing much of
the complexity behind-the-scenes with static metaprogramming.
Boost.Python also goes beyond the scope of earlier systems by
providing:</p>
<p>
<a class="reference" href="http://www.boost.org/libs/python/doc">Boost.Python</a>
的特性和目标与这些系统有很多重叠。

Boost.Python努力提高封装的便利性和灵活性，
但不引入单独的封装语言。
相反，它通过静态元编程，在幕后管理大量的复杂性，
呈现给用户一个高级C++接口来封装C++类和函数。
Boost.Python也在如下领域超越了早期的系统：
</p>

<ul class="simple">
<li>Support for C++ virtual functions that can be overridden in Python.</li>
<li>Comprehensive lifetime management facilities for low-level C++
pointers and references.</li>
<li>Support for organizing extensions as Python packages,
with a central registry for inter-language type conversions.</li>
<li>A safe and convenient mechanism for tying into Python's powerful
serialization engine (pickle).</li>
<li>Coherence with the rules for handling C++ lvalues and rvalues that
can only come from a deep understanding of both the Python and C++
type systems.</li>
</ul>

<ul class="simple">
<li>支持C++虚函数，并能在Python中覆盖。</li>
<li>对于低级的C++指针和引用，提供全面的生命期管理机制。</li>
<li>支持按Python包组织扩展模块，通过中心注册表进行语言间类型转换。</li>
<li>通过一种安全方便的机制，引入Python强大的序列化引擎（pickle）。</li>
<li>与C++处理左值和右值的规则相一致，该一致性只能来自于对Python和C++类型系统的深入理解。
</li>
</ul>

<p>The key insight that sparked the development of Boost.Python is that
much of the boilerplate code in traditional extension modules could be
eliminated using C++ compile-time introspection.  Each argument of a
wrapped C++ function must be extracted from a Python object using a
procedure that depends on the argument type.  Similarly the function's
return type determines how the return value will be converted from C++
to Python.  Of course argument and return types are part of each
function's type, and this is exactly the source from which
Boost.Python deduces most of the information required.</p>
<p>
一个关键性的发现启动了Boost.Python的开发，
即利用C++的编译时内省，可以消除传统扩展模块中的大量样板代码。
如每个封装的C++函数的参数都是从Python对象提取的，
提取时必须根据参数类型调用相应的过程。
类似地，函数返回值从C++转换成Python时，
返回值的类型决定了如何转换。
因为参数和返回值的类型是每个函数类型的一部分，
所以Boost.Python可以从函数类型推导出大部分所需的信息。
</p>

<p>This approach leads to <em>user guided wrapping</em>: as much information is
extracted directly from the source code to be wrapped as is possible
within the framework of pure C++, and some additional information is
supplied explicitly by the user.  Mostly the guidance is mechanical
and little real intervention is required.  Because the interface
specification is written in the same full-featured language as the
code being exposed, the user has unprecedented power available when
she does need to take control.</p>
<p>
这种方法导致了“<em>用户指导的封装（user guided wrapping）</em>”：
在纯C++的框架内，
从待封装的源代码中直接提取尽可能多的信息，
而一些额外的信息由用户显式提供。
通常这种指导是自动的，很少需要真正的干涉。
因为接口规范和导出代码是用同一门全功能的语言写的，
当用户确实需要取得控制时，
他所拥有的权力是空前强大的。
</p>

</div>

<div class="section" id="boost-python-design-goals">
<h1><a class="toc-backref" href="#id7" name="boost-python-design-goals">Boost.Python Design Goals</a></h1>
<h1>Boost.Python的设计目标</h1>

<p>The primary goal of Boost.Python is to allow users to expose C++
classes and functions to Python using nothing more than a C++
compiler.  In broad strokes, the user experience should be one of
directly manipulating C++ objects from Python.</p>
<p>
Boost.Python的首要目标是，
让用户只用C++编译器就能向Python导出C++类和函数。
大体来讲，用户的体验应该是，能够从Python直接操作C++对象。
</p>
<p>However, it's also important not to translate all interfaces <em>too</em>
literally: the idioms of each language must be respected.  For
example, though C++ and Python both have an iterator concept, they are
expressed very differently.  Boost.Python has to be able to bridge the
interface gap.</p>
<p>
然而，有一点也很重要，
那就是不要<em>过于</em>按字面翻译所有接口：
必须考虑每种语言的惯用法。
例如，虽然C++和Python都有迭代器的概念，
表达方式却很不一样。
Boost.Python必须能够消除这种接口的差异。
</p>

<p>It must be possible to insulate Python users from crashes resulting
from trivial misuses of C++ interfaces, such as accessing
already-deleted objects.  By the same token the library should
insulate C++ users from low-level Python 'C' API, replacing
error-prone 'C' interfaces like manual reference-count management and
raw <tt class="literal"><span class="pre">PyObject</span></tt> pointers with more-robust alternatives.</p>
<p>
Python用户可能会误用C++接口，
因此，Boost.Python必须能够隔离因轻微的误用而造成的崩溃，
例如访问已删除的对象。
同样的，Boost.Python库应该把C++用户从低级的Python 'C' API中解放出来，
将容易出错的'C'接口，
如手工引用计数管理、原始的
<tt class="literal"><span class="pre">PyObject</span></tt>
指针，
替换为更健壮的接口。
</p>

<p>Support for component-based development is crucial, so that C++ types
exposed in one extension module can be passed to functions exposed in
another without loss of crucial information like C++ inheritance
relationships.</p>
<p>
支持基于组件的开发是至关重要的，
这样，一个扩展模块导出的C++类型，
可以传递给另一个模块导出的函数，
而不丢失重要的信息，比如C++的继承关系。
</p>
<p>Finally, all wrapping must be <em>non-intrusive</em>, without modifying or
even seeing the original C++ source code.  Existing C++ libraries have
to be wrappable by third parties who only have access to header files
and binaries.</p>
<p>
最后，所有的封装必须是<em>非侵入性的（non-intrusive）</em>，
不能修改最初的C++源码，
甚至不必看到源码。
第三方必须能够封装现有的C++库，
即使他只有头文件和二进制库。
</p>
</div>
<div class="section" id="hello-boost-python-world">
<h1><a class="toc-backref" href="#id8" name="hello-boost-python-world">Hello Boost.Python World</a></h1>
<h1>Hello Boost.Python World</h1>
<p>And now for a preview of Boost.Python, and how it improves on the raw
facilities offered by Python. Here's a function we might want to
expose:</p>
<p>
现在来预览一下Boost.Python，
看看它是如何改进Python原有的封装机制的。
下面是我们想导出的函数:
</p>
<pre class="literal-block">char const* greet(unsigned x)
{
   static char const* const msgs[] = { "hello", "Boost.Python", "world!" };

   if (x &gt; 2) 
       throw std::range_error("greet: index out of range");

   return msgs[x];
}
</pre>
<p>To wrap this function in standard C++ using the Python 'C' API, we'd
need something like this:</p>
<p>
在标准C++中，用Python 'C' API来封装这个函数，我们需要像这样做:
</p>
<pre class="literal-block">extern "C" // all Python interactions use 'C' linkage and calling convention
{
    // Wrapper to handle argument/result conversion and checking
    PyObject* greet_wrap(PyObject* args, PyObject * keywords)
    {
         int x;
         if (PyArg_ParseTuple(args, "i", &amp;x))    // extract/check arguments
         {
             char const* result = greet(x);      // invoke wrapped function
             return PyString_FromString(result); // convert result to Python
         }
         return 0;                               // error occurred
    }

    // Table of wrapped functions to be exposed by the module
    static PyMethodDef methods[] = {
        { "greet", greet_wrap, METH_VARARGS, "return one of 3 parts of a greeting" }
        , { NULL, NULL, 0, NULL } // sentinel
    };

    // module initialization function
    DL_EXPORT init_hello()
    {
        (void) Py_InitModule("hello", methods); // add the methods to the module
    }
}
</pre>
<p>Now here's the wrapping code we'd use to expose it with Boost.Python:</p>
<p>
而这是用Boost.Python来导出函数的封装代码：
</p>
<pre class="literal-block">#include &lt;boost/python.hpp&gt;
using namespace boost::python;
BOOST_PYTHON_MODULE(hello)
{
    def("greet", greet, "return one of 3 parts of a greeting");
}
</pre>
<p>and here it is in action:</p>
<p>
这是运行结果：
</p>
<pre class="literal-block">&gt;&gt;&gt; import hello
&gt;&gt;&gt; for x in range(3):
...     print hello.greet(x)
...
hello
Boost.Python
world!
</pre>
<p>Aside from the fact that the 'C' API version is much more verbose,
it's worth noting a few things that it doesn't handle correctly:</p>
<p>
使用'C' API的版本要冗长的多，此外，还需要注意，有些东西它没有正确处理：
</p>
<ul class="simple">
<li>The original function accepts an unsigned integer, and the Python
'C' API only gives us a way of extracting signed integers. The
Boost.Python version will raise a Python exception if we try to pass
a negative number to <tt class="literal"><span class="pre">hello.greet</span></tt>, but the other one will proceed
to do whatever the C++ implementation does when converting an
negative integer to unsigned (usually wrapping to some very large
number), and pass the incorrect translation on to the wrapped
function.

<p>
原来的函数接受一个无符号整数，
然而Python 'C' API只能提取有符号整数。
如果我们试图向
<tt class="literal"><span class="pre">hello.greet</span></tt>
传递一个负数，
Boost.Python版会引发Python异常，
而另一个则会继续：执行C++代码，
将负数转换为无符号数（通常会变成一个很大的数），
然后把不正确的转换结果传递给被封装的函数。
</p>

</li>

<li>That brings us to the second problem: if the C++ <tt class="literal"><span class="pre">greet()</span></tt>
function is called with a number greater than 2, it will throw an
exception.  Typically, if a C++ exception propagates across the
boundary with code generated by a 'C' compiler, it will cause a
crash.  As you can see in the first version, there's no C++
scaffolding there to prevent this from happening.  Functions wrapped
by Boost.Python automatically include an exception-handling layer
which protects Python users by translating unhandled C++ exceptions
into a corresponding Python exception.

<p>
这引起了第二个问题：
如果输入一个大于2的参数，
C++ <tt class="literal"><span class="pre">greet()</span></tt>函数
会抛出异常。
典型的，如果C++异常传播时，
跨越了'C'编译器生成的代码的边界，
就会导致崩溃。
正如你在第一个版本中所见，
那儿没有防止崩溃的C++机制。
而Boost.Python封装的函数自动包含了异常处理层，
它把未处理的C++异常翻译成相应的Python异常，
从而保护了Python用户。
</p>

</li>

<li>A slightly more-subtle limitation is that the argument conversion
used in the Python 'C' API case can only get that integer <tt class="literal"><span class="pre">x</span></tt> in
<em>one way</em>.  PyArg_ParseTuple can't convert Python <tt class="literal"><span class="pre">long</span></tt> objects
(arbitrary-precision integers) which happen to fit in an <tt class="literal"><span class="pre">unsigned</span>
<span class="pre">int</span></tt> but not in a <tt class="literal"><span class="pre">signed</span> <span class="pre">long</span></tt>, nor will it ever handle a
wrapped C++ class with a user-defined implicit <tt class="literal"><span class="pre">operator</span> <span class="pre">unsigned</span>
<span class="pre">int()</span></tt> conversion. Boost.Python's dynamic type conversion
registry allows users to add arbitrary conversion methods.

<p>
一个更微妙的限制是，
Python 'C' API的参数转换只能以“<em>一种</em>”方式取得整数
<tt class="literal"><span class="pre">x</span></tt>。
如果有一个Python <tt class="literal"><span class="pre">long</span></tt>
对象（任意精度整数），
它的大小正好属于
<tt class="literal"><span class="pre">unsigned</span>
 <span class="pre">int</span></tt>，
但不属于
<tt class="literal"><span class="pre">signed</span> <span class="pre">long</span></tt>，
PyArg_ParseTuple就不能对其进行转换。
对于一个定义了
<tt class="literal"><span class="pre">operator</span>
 <span class="pre">unsigned</span>
 <span class="pre">int()</span></tt>，
即用户自定义隐式转换的C++封装类，
它同样无法处理。
而Boost.Python的动态类型转换注册表允许用户添加任意的转换方法。
</p>

</li>

</ul>
</div>

<div class="section" id="library-overview">
<h1><a class="toc-backref" href="#id9" name="library-overview">Library Overview</a></h1>
<h1>库概览</h1>
<p>This section outlines some of the library's major features.  Except as
neccessary to avoid confusion, details of library implementation are
omitted.</p>
<p>
本节简述了库的一些主要特性。
在不影响理解的情况下，省略了库的实现细节。
</p>
<div class="section" id="exposing-classes">
<h2><a class="toc-backref" href="#id10" name="exposing-classes">Exposing Classes</a></h2>
<h2>导出类</h2>
<p>C++ classes and structs are exposed with a similarly-terse interface.
Given:</p>
<p>
C++类和结构是用同样简洁的接口导出的。如有：
</p>
<pre class="literal-block">struct World
{
    void set(std::string msg) { this-&gt;msg = msg; }
    std::string greet() { return msg; }
    std::string msg;
};
</pre>
<p>The following code will expose it in our extension module:</p>
<p>
以下代码会将它导出到扩展模块：
</p>
<pre class="literal-block">#include &lt;boost/python.hpp&gt;
BOOST_PYTHON_MODULE(hello)
{
    class_&lt;World&gt;("World")
        .def("greet", &amp;World::greet)
        .def("set", &amp;World::set)
    ;
}
</pre>
<p>Although this code has a certain pythonic familiarity, people
sometimes find the syntax bit confusing because it doesn't look like
most of the C++ code they're used to. All the same, this is just
standard C++.  Because of their flexible syntax and operator
overloading, C++ and Python are great for defining domain-specific
(sub)languages
(DSLs), and that's what we've done in Boost.Python. To break it down:</p>
<p>
尽管上述代码具有某种熟悉的Python风格，
但语法还是有点令人迷惑，
因为它看起来不像通常的C++代码。
但是，这仍然是正确的标准C++。
因为C++和Python具有灵活的语法和运算符重载，
它们都很善于定义特定领域（子）语言
（DSLs, domain-specific (sub)languages）。
我们在Boost.Python里面就是定义了一个DSL。
把代码拆开来看:
</p>
<pre class="literal-block">class_&lt;World&gt;("World")
</pre>
<p>constructs an unnamed object of type <tt class="literal"><span class="pre">class_&lt;World&gt;</span></tt> and passes
<tt class="literal"><span class="pre">"World"</span></tt> to its constructor.  This creates a new-style Python class
called <tt class="literal"><span class="pre">World</span></tt> in the extension module, and associates it with the
C++ type <tt class="literal"><span class="pre">World</span></tt> in the Boost.Python type conversion registry.  We
might have also written:</p>
<p>
构造了一个匿名对象，
类型为
<tt class="literal"><span class="pre">class_&lt;World&gt;</span></tt>，
并把<tt class="literal"><span class="pre">"World"</span></tt>
传递给它的构造函数。
这将在扩展模块里创建一个新型Python类
<tt class="literal"><span class="pre">World</span></tt>，
并在Boost.Python的类型转换注册表里，
把它和C++类型
<tt class="literal"><span class="pre">World</span></tt>
关联起来。
我们也可以这么写:
</p>
<pre class="literal-block">class_&lt;World&gt; w("World");
</pre>
<p>but that would've been more verbose, since we'd have to name <tt class="literal"><span class="pre">w</span></tt>
again to invoke its <tt class="literal"><span class="pre">def()</span></tt> member function:</p>
<p>
但是那会显得更冗长，
因为我们不得不再次通过
<tt class="literal"><span class="pre">w</span></tt>
去调用它的
<tt class="literal"><span class="pre">def()</span></tt>
成员函数：
</p>
<pre class="literal-block">w.def("greet", &amp;World::greet)
</pre>
<p>There's nothing special about the location of the dot for member
access in the original example: C++ allows any amount of whitespace on
either side of a token, and placing the dot at the beginning of each
line allows us to chain as many successive calls to member functions
as we like with a uniform syntax.  The other key fact that allows
chaining is that <tt class="literal"><span class="pre">class_&lt;&gt;</span></tt> member functions all return a reference
to <tt class="literal"><span class="pre">*this</span></tt>.</p>
<p>
原来的例子里的点表示成员访问，
它的位置没有什么特别的：
因为C++允许标记（token）的两边可以有任意数量的空白符。
把点放在每行的开始，
允许我们以一致的句法，
链式串接连续的成员函数调用，
想串多少都行。

允许链式调用的另一关键是，
<tt class="literal"><span class="pre">class_&lt;&gt;</span></tt>
的成员函数都返回对
<tt class="literal"><span class="pre">*this</span></tt>
的引用。
</p>
<p>So the example is equivalent to:</p>
<p>
因此本例等同于：
</p>
<pre class="literal-block">class_&lt;World&gt; w("World");
w.def("greet", &amp;World::greet);
w.def("set", &amp;World::set);
</pre>
<p>It's occasionally useful to be able to break down the components of a
Boost.Python class wrapper in this way, but the rest of this article
will stick to the terse syntax.</p>
<p>
这种方式将Boost.Python类包装的部件都拆分开来了，
能这样拆分有时候是有用的。
但本文下面仍将坚持使用简洁格式。
</p>
<p>For completeness, here's the wrapped class in use:</p>
<p>
最后来看封装类的使用:
</p>
<pre class="literal-block">&gt;&gt;&gt; import hello
&gt;&gt;&gt; planet = hello.World()
&gt;&gt;&gt; planet.set('howdy')
&gt;&gt;&gt; planet.greet()
'howdy'
</pre>
<div class="section" id="constructors">
<h3><a class="toc-backref" href="#id11" name="constructors">Constructors</a></h3>
<h3>构造函数</h3>
<p>Since our <tt class="literal"><span class="pre">World</span></tt> class is just a plain <tt class="literal"><span class="pre">struct</span></tt>, it has an
implicit no-argument (nullary) constructor.  Boost.Python exposes the
nullary constructor by default, which is why we were able to write:</p>
<p>
由于我们的
<tt class="literal"><span class="pre">World</span></tt>类
只是一个简单的
<tt class="literal"><span class="pre">struct</span></tt>，
它有一个隐式的无参数的构造函数。
Boost.Python默认会导出这个无参数的构造函数，
所以我们可以这样写：
</p>
<pre class="literal-block">&gt;&gt;&gt; planet = hello.World()
</pre>
<p>However, well-designed classes in any language may require constructor
arguments in order to establish their invariants.  Unlike Python,
where <tt class="literal"><span class="pre">__init__</span></tt> is just a specially-named method, In C++
constructors cannot be handled like ordinary member functions.  In
particular, we can't take their address: <tt class="literal"><span class="pre">&amp;World::World</span></tt> is an
error.  The library provides a different interface for specifying
constructors.  Given:</p>
<p>
然而，在任何语言里，对于设计良好的类，
构造函数可能需要参数，以建立类的不变式（invariant）。
Python的<tt class="literal"><span class="pre">__init__</span></tt>
只是一个特殊命名的方法，
而C++的构造函数与Python不同，
它不能像普通成员函数那样处理。
特别是，我们不能取它的地址：
<tt class="literal"><span class="pre">&amp;World::World</span></tt>
是一个错误。
Boost.Python库提供了一个不同的接口来指定构造函数。
假设有:
</p>
<pre class="literal-block">struct World
{
    World(std::string msg); // added constructor
    ...
</pre>
<p>we can modify our wrapping code as follows:</p>
<p>
我们可以如下修改封装代码:
</p>
<pre class="literal-block">class_&lt;World&gt;("World", init&lt;std::string&gt;())
    ...
</pre>
<p>of course, a C++ class may have additional constructors, and we can
expose those as well by passing more instances of <tt class="literal"><span class="pre">init&lt;...&gt;</span></tt> to
<tt class="literal"><span class="pre">def()</span></tt>:</p>
<p>
当然，C++类可能还有其他的构造函数，
我们也可以导出它们，
只需要向
<tt class="literal"><span class="pre">def()</span></tt>
传入更多的
<tt class="literal"><span class="pre">init&lt;...&gt;</span></tt>
实例:
</p>
<pre class="literal-block">class_&lt;World&gt;("World", init&lt;std::string&gt;())
    .def(init&lt;double, double&gt;())
    ...
</pre>
<p>Boost.Python allows wrapped functions, member functions, and
constructors to be overloaded to mirror C++ overloading.</p>
<p>
Boost.Python封装的函数、成员函数，以及构造函数都可以重载，
以映射C++中的重载。
</p>
</div>

<div class="section" id="data-members-and-properties">
<h3><a class="toc-backref" href="#id12" name="data-members-and-properties">Data Members and Properties</a></h3>
<h3>数据成员和属性</h3>
<p>Any publicly-accessible data members in a C++ class can be easily
exposed as either <tt class="literal"><span class="pre">readonly</span></tt> or <tt class="literal"><span class="pre">readwrite</span></tt> attributes:</p>
<p>
C++中任何可公有访问的数据成员，
都能轻易地封装成
<tt class="literal"><span class="pre">readonly</span></tt>
或者
<tt class="literal"><span class="pre">readwrite</span></tt>
属性:
</p>
<pre class="literal-block">class_&lt;World&gt;("World", init&lt;std::string&gt;())
    .def_readonly("msg", &amp;World::msg)
    ...
</pre>
<p>and can be used directly in Python:</p>
<p>
并直接在Python中使用:
</p>
<pre class="literal-block">&gt;&gt;&gt; planet = hello.World('howdy')
&gt;&gt;&gt; planet.msg
'howdy'
</pre>
<p>This does <em>not</em> result in adding attributes to the <tt class="literal"><span class="pre">World</span></tt> instance
<tt class="literal"><span class="pre">__dict__</span></tt>, which can result in substantial memory savings when
wrapping large data structures.  In fact, no instance <tt class="literal"><span class="pre">__dict__</span></tt>
will be created at all unless attributes are explicitly added from
Python. Boost.Python owes this capability to the new Python 2.2 type
system, in particular the descriptor interface and <tt class="literal"><span class="pre">property</span></tt> type.</p>
<p>
这<em>不会</em>在
<tt class="literal"><span class="pre">World</span></tt>实例
<tt class="literal"><span class="pre">__dict__</span></tt>
中添加属性，
从而在封装大型数据结构时节省大量的内存。
实际上，根本不会创建实例
<tt class="literal"><span class="pre">__dict__</span></tt>，
除非从Python显式添加属性。
Boost.Python的这种能力归功于Python 2.2新的类型系统，
尤其是描述符（descriptor）接口和
<tt class="literal"><span class="pre">property</span></tt>
类型。
</p>

<p>In C++, publicly-accessible data members are considered a sign of poor
design because they break encapsulation, and style guides usually
dictate the use of "getter" and "setter" functions instead.  In
Python, however, <tt class="literal"><span class="pre">__getattr__</span></tt>, <tt class="literal"><span class="pre">__setattr__</span></tt>, and since 2.2,
<tt class="literal"><span class="pre">property</span></tt> 
mean that attribute access is just one more
well-encapsulated syntactic tool at the programmer's disposal.
Boost.Python bridges this idiomatic gap by making Python <tt class="literal"><span class="pre">property</span></tt>
creation directly available to users.  If <tt class="literal"><span class="pre">msg</span></tt> were private, we
could still expose it as attribute in Python as follows:</p>
<p>
在C++中，人们认为，
可公有访问的数据成员是设计糟糕的标志，
因为它们破坏了封装性，
并且风格指南通常指示使用“getter”和“setter”函数作为替代。
然而在Python里，
<tt class="literal"><span class="pre">__getattr__</span></tt>、
<tt class="literal"><span class="pre">__setattr__</span></tt>，
和2.2版出现的
<tt class="literal"><span class="pre">property</span></tt>
意味着，属性访问仅仅是一种任由程序员选用的、
封装性更好的语法工具。
Boost.Python让用户可直接创建Python
 <tt class="literal"><span class="pre">property</span></tt>，
从而消除了二者语言习惯上的差异。
即使<tt class="literal"><span class="pre">msg</span></tt>是私有的，
我们仍可把它导出为Python中的属性，如下：
</p>
<pre class="literal-block">class_&lt;World&gt;("World", init&lt;std::string&gt;())
    .add_property("msg", &amp;World::greet, &amp;World::set)
    ...
</pre>
<p>The example above mirrors the familiar usage of properties in Python
2.2+:</p>
<p>
上例等同于Python 2.2+里面熟悉的属性的用法：
</p>
<pre class="literal-block">&gt;&gt;&gt; class World(object):
...     __init__(self, msg):
...         self.__msg = msg
...     def greet(self):
...         return self.__msg
...     def set(self, msg):
...         self.__msg = msg
...     msg = property(greet, set)
</pre>
</div>

<div class="section" id="operator-overloading">
<h3><a class="toc-backref" href="#id13" name="operator-overloading">Operator Overloading</a></h3>
<h3>运算符重载</h3>
<p>The ability to write arithmetic operators for user-defined types has
been a major factor in the success of both languages for numerical
computation, and the success of packages like <a class="reference" href="http://www.pfdubois.com/numpy/">NumPy</a> attests to the
power of exposing operators in extension modules.  Boost.Python
provides a concise mechanism for wrapping operator overloads. The
example below shows a fragment from a wrapper for the Boost rational
number library:</p>
<p>
两种语言都能够为用户自定义类型编写算术运算符，
这是它们在数值计算上获得成功的主要因素，
并且，像
<a class="reference" href="http://www.pfdubois.com/numpy/">NumPy</a>
这样的软件包的成功证明了在扩展模块中导出运算符的威力。
Boost.Python为封装运算符重载提供了简洁的机制。
下面是Boost有理数库封装代码的片断：
</p>
<pre class="literal-block">class_&lt;rational&lt;int&gt; &gt;("rational_int")
  .def(init&lt;int, int&gt;()) // constructor, e.g. rational_int(3,4)
  .def("numerator", &amp;rational&lt;int&gt;::numerator)
  .def("denominator", &amp;rational&lt;int&gt;::denominator)
  .def(-self)        // __neg__ (unary minus)
  .def(self + self)  // __add__ (homogeneous)
  .def(self * self)  // __mul__
  .def(self + int()) // __add__ (heterogenous)
  .def(int() + self) // __radd__
  ...
</pre>
<p>The magic is performed using a simplified application of "expression
templates" <a class="citation-reference" href="#veld1995" id="id1" name="id1">[VELD1995]</a>, a technique originally developed for
optimization of high-performance matrix algebra expressions.  The
essence is that instead of performing the computation immediately,
operators are overloaded to construct a type <em>representing</em> the
computation.  In matrix algebra, dramatic optimizations are often
available when the structure of an entire expression can be taken into
account, rather than evaluating each operation "greedily".
Boost.Python uses the same technique to build an appropriate Python
method object based on expressions involving <tt class="literal"><span class="pre">self</span></tt>.</p>
<p>
魔法的施展只是简单应用了“表达式模板（expression templates）”
<a class="citation-reference" href="#veld1995" id="id1" name="id1">[VELD1995]</a>，
一种最初为高性能矩阵代数表达式优化而开发的技术。
其精髓是，不是立即进行计算，
而是利用运算符重载，来构造一个<em>代表</em>计算的类型。
在矩阵代数里，
当考虑整个表达式的结构，
而不是“贪婪地”对每步运算求值时，
经常可以获得显著的优化。
Boost.Python使用了同样的技术，
它用包含<tt class="literal"><span class="pre">self</span></tt>的表达式，
构建了一个适当的Python成员方法对象。
</p>
</div>

<div class="section" id="inheritance">
<h3><a class="toc-backref" href="#id14" name="inheritance">Inheritance</a></h3>
<h3>继承</h3>
<p>C++ inheritance relationships can be represented to Boost.Python by adding
an optional <tt class="literal"><span class="pre">bases&lt;...&gt;</span></tt> argument to the <tt class="literal"><span class="pre">class_&lt;...&gt;</span></tt> template
parameter list as follows:</p>
<p>
要在Boost.Python里描述C++继承关系，
可以在<tt class="literal"><span class="pre">class_&lt;...&gt;</span></tt>
模板参数列表里添加一个可选的
<tt class="literal"><span class="pre">bases&lt;...&gt;</span></tt>，
如下:
</p>
<pre class="literal-block">class_&lt;Derived, bases&lt;Base1,Base2&gt; &gt;("Derived")
     ...
</pre>
<p>This has two effects:</p>
<p>
这有两种作用：
</p>
<ol class="arabic simple">
<li>When the <tt class="literal"><span class="pre">class_&lt;...&gt;</span></tt> is created, Python type objects
corresponding to <tt class="literal"><span class="pre">Base1</span></tt> and <tt class="literal"><span class="pre">Base2</span></tt> are looked up in
Boost.Python's registry, and are used as bases for the new Python
<tt class="literal"><span class="pre">Derived</span></tt> type object, so methods exposed for the Python <tt class="literal"><span class="pre">Base1</span></tt>
and <tt class="literal"><span class="pre">Base2</span></tt> types are automatically members of the <tt class="literal"><span class="pre">Derived</span></tt>
type.  Because the registry is global, this works correctly even if
<tt class="literal"><span class="pre">Derived</span></tt> is exposed in a different module from either of its
bases.</li>
<li>C++ conversions from <tt class="literal"><span class="pre">Derived</span></tt> to its bases are added to the
Boost.Python registry.  Thus wrapped C++ methods expecting (a
pointer or reference to) an object of either base type can be
called with an object wrapping a <tt class="literal"><span class="pre">Derived</span></tt> instance.  Wrapped
member functions of class <tt class="literal"><span class="pre">T</span></tt> are treated as though they have an
implicit first argument of <tt class="literal"><span class="pre">T&amp;</span></tt>, so these conversions are
neccessary to allow the base class methods to be called for derived
objects.</li>
</ol>

<ol class="arabic simple">
<li>
当<tt class="literal"><span class="pre">class_&lt;...&gt;</span></tt>创建时，
会在Boost.Python的注册表里查找
<tt class="literal"><span class="pre">Base1</span></tt>
和<tt class="literal"><span class="pre">Base2</span></tt>
所对应的Python类型对象，
并将它们作为新的
Python <tt class="literal"><span class="pre">Derived</span></tt>
类型对象的基类，因此为Python的
<tt class="literal"><span class="pre">Base1</span></tt>
和<tt class="literal"><span class="pre">Base2</span></tt>
类型导出的成员函数自动成为
<tt class="literal"><span class="pre">Derived</span></tt>
类型的成员。
因为注册表是全局的，所以
<tt class="literal"><span class="pre">Derived</span></tt>
和它的基类可以在不同的模块中导出。
</li>
<li>
在Boost.Python的注册表里，
添加了从<tt class="literal"><span class="pre">Derived</span></tt>
到它的基类的C++转换。
这样，封装了
<tt class="literal"><span class="pre">Derived</span></tt>
实例的对象就可以调用其基类的方法，
而该封装的C++方法本该由一个基类对象（指针或引用）来调用。
类<tt class="literal"><span class="pre">T</span></tt>
的成员方法封装后，
可视为它们具有一个隐含的第一参数
<tt class="literal"><span class="pre">T&amp;</span></tt>，
所以为了允许派生类对象调用基类方法，这些转换是必须的。
</li>
</ol>

<p>Of course it's possible to derive new Python classes from wrapped C++
class instances.  Because Boost.Python uses the new-style class
system, that works very much as for the Python built-in types.  There
is one significant detail in which it differs: the built-in types
generally establish their invariants in their <tt class="literal"><span class="pre">__new__</span></tt> function, so
that derived classes do not need to call <tt class="literal"><span class="pre">__init__</span></tt> on the base
class before invoking its methods :</p>
<p>
当然，也可以从封装的C++类实例派生新的Python类。
因为Boost.Python使用了新型类系统，
从封装类派生就像是从Python内置类型派生一样。
但有一个重大区别：
内置类型一般在
<tt class="literal"><span class="pre">__new__</span></tt>
函数里建立不变式，
因此其派生类不需要调用基类的
<tt class="literal"><span class="pre">__init__</span></tt>：
</p>
<pre class="literal-block">&gt;&gt;&gt; class L(list):
...      def __init__(self):
...          pass
...
&gt;&gt;&gt; L().reverse()
&gt;&gt;&gt; 
</pre>
<p>Because C++ object construction is a one-step operation, C++ instance
data cannot be constructed until the arguments are available, in the
<tt class="literal"><span class="pre">__init__</span></tt> function:</p>
<p>
因为C++的对象构造是一个单步操作，
在<tt class="literal"><span class="pre">__init__</span></tt>
函数里，
只有参数齐全，才能构造C++实例数据：
</p>
<pre class="literal-block">&gt;&gt;&gt; class D(SomeBoostPythonClass):
...      def __init__(self):
...          pass
...
&gt;&gt;&gt; D().some_boost_python_method()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: bad argument type for built-in operation
</pre>
<p>This happened because Boost.Python couldn't find instance data of type
<tt class="literal"><span class="pre">SomeBoostPythonClass</span></tt> within the <tt class="literal"><span class="pre">D</span></tt> instance; <tt class="literal"><span class="pre">D</span></tt>'s <tt class="literal"><span class="pre">__init__</span></tt>
function masked construction of the base class.  It could be corrected
by either removing <tt class="literal"><span class="pre">D</span></tt>'s <tt class="literal"><span class="pre">__init__</span></tt> function or having it call
<tt class="literal"><span class="pre">SomeBoostPythonClass.__init__(...)</span></tt> explicitly.</p>
<p>
发生错误的原因是，
Boost.Python在实例
<tt class="literal"><span class="pre">D</span></tt>中，
找不到类型
<tt class="literal"><span class="pre">SomeBoostPythonClass</span></tt>
的实例数据；
<tt class="literal"><span class="pre">D</span></tt>的
<tt class="literal"><span class="pre">__init__</span></tt>函数
遮盖了基类的构造函数。
纠正方法为，
删除
<tt class="literal"><span class="pre">D</span></tt>的
<tt class="literal"><span class="pre">__init__</span></tt>函数，
或者让它显式调用
<tt class="literal"><span class="pre">SomeBoostPythonClass.__init__(...)</span></tt>。
</p>
</div>

<div class="section" id="virtual-functions">
<h3><a class="toc-backref" href="#id15" name="virtual-functions">Virtual Functions</a></h3>
<h3>虚函数</h3>
<p>Deriving new types in Python from extension classes is not very
interesting unless they can be used polymorphically from C++.  In
other words, Python method implementations should appear to override
the implementation of C++ virtual functions when called <em>through base
class pointers/references from C++</em>.  Since the only way to alter the
behavior of a virtual function is to override it in a derived class,
the user must build a special derived class to dispatch a polymorphic
class' virtual functions:</p>
<p>
用Python从扩展类派生新的类型没有太大意思，
除非可以在C++里面多态地使用派生类。
换句话说，
<em>在C++里，通过基类指针或引用</em>调用C++虚函数时，
Python实现的方法应该看起来像是覆盖了C++虚函数的实现。
因为改变虚函数行为的唯一方法是，
在派生类里覆盖它，
所以用户必须构建一个特殊的派生类，
来分派多态类的虚函数:
</p>
<pre class="literal-block">//
// interface to wrap:
//
class Base
{
 public:
    virtual int f(std::string x) { return 42; }
    virtual ~Base();
};

int calls_f(Base const&amp; b, std::string x) { return b.f(x); }

//
// Wrapping Code
//

// Dispatcher class
struct BaseWrap : Base
{
    // Store a pointer to the Python object
    BaseWrap(PyObject* self_) : self(self_) {}
    PyObject* self;

    // Default implementation, for when f is not overridden
    int f_default(std::string x) { return this-&gt;Base::f(x); }
    // Dispatch implementation
    int f(std::string x) { return call_method&lt;int&gt;(self, "f", x); }
};

...
    def("calls_f", calls_f);
    class_&lt;Base, BaseWrap&gt;("Base")
        .def("f", &amp;Base::f, &amp;BaseWrap::f_default)
        ;
</pre>
<p>Now here's some Python code which demonstrates:</p>
<p>
这是Python演示代码：
</p>
<pre class="literal-block">&gt;&gt;&gt; class Derived(Base):
...     def f(self, s):
...          return len(s)
...
&gt;&gt;&gt; calls_f(Base(), 'foo')
42
&gt;&gt;&gt; calls_f(Derived(), 'forty-two')
9
</pre>
<p>Things to notice about the dispatcher class:</p>
<p>
关于分派类需要注意：
</p>
<ul class="simple">
<li>The key element which allows overriding in Python is the
<tt class="literal"><span class="pre">call_method</span></tt> invocation, which uses the same global type
conversion registry as the C++ function wrapping does to convert its
arguments from C++ to Python and its return type from Python to C++.</li>
<li>Any constructor signatures you wish to wrap must be replicated with
an initial <tt class="literal"><span class="pre">PyObject*</span></tt> argument</li>
<li>The dispatcher must store this argument so that it can be used to
invoke <tt class="literal"><span class="pre">call_method</span></tt></li>
<li>The <tt class="literal"><span class="pre">f_default</span></tt> member function is needed when the function being
exposed is not pure virtual; there's no other way <tt class="literal"><span class="pre">Base::f</span></tt> can be
called on an object of type <tt class="literal"><span class="pre">BaseWrap</span></tt>, since it overrides <tt class="literal"><span class="pre">f</span></tt>.</li>
</ul>

<ul class="simple">
<li>
允许在Python里覆盖的关键因素是
<tt class="literal"><span class="pre">call_method</span></tt>
调用，
与C++函数封装一样，
它使用同一个全局注册表，
把参数从C++转换到Python，
并把返回类型从Python转换到C++。
</li>
<li>
任何你希望封装的构造函数，
其函数签名必须有一个的相同的初始化参数
<tt class="literal"><span class="pre">PyObject*</span></tt>。
</li>
<li>
分派者必须保存这个参数，以便调用
<tt class="literal"><span class="pre">call_method</span></tt>
时使用。
</li>
<li>
当导出的函数不是纯虚函数时，
就需要
<tt class="literal"><span class="pre">f_default</span></tt>
成员函数；
在<tt class="literal"><span class="pre">BaseWrap</span></tt>
类型的对象里，
没有其他方式可以调用
<tt class="literal"><span class="pre">Base::f</span></tt>，
因为<tt class="literal"><span class="pre">f</span></tt>
被覆盖了。
</li>
</ul>
</div>

<div class="section" id="deeper-reflection-on-the-horizon">
<h3><a class="toc-backref" href="#id16" name="deeper-reflection-on-the-horizon">Deeper Reflection on the Horizon?</a></h3>
<h3>更深的反射即将出现？</h3>

<p>Admittedly, this formula is tedious to repeat, especially on a project
with many polymorphic classes.  That it is neccessary reflects some
limitations in C++'s compile-time introspection capabilities: there's
no way to enumerate the members of a class and find out which are
virtual functions.  At least one very promising project has been
started to write a front-end which can generate these dispatchers (and
other wrapping code) automatically from C++ headers.</p>
<p>
无可否认，重复这种公式化动作是冗长乏味的，
尤其是项目里有大量多态类的时候。
这里有必要反映一些C++编译时内省能力的限制：
C++无法列举类的成员并找出虚函数。
不过，至少有一个项目已经启动，
有希望编写出一个前端程序，
可以从C++头文件自动生成这些分派类（和其他封装代码），
</p>
<p><a class="reference" href="http://www.boost.org/libs/python/pyste">Pyste</a> is being developed by Bruno da Silva de Oliveira.  It builds on
<a class="reference" href="http://www.gccxml.org/HTML/Index.html">GCC_XML</a>, which generates an XML version of GCC's internal program
representation.  Since GCC is a highly-conformant C++ compiler, this
ensures correct handling of the most-sophisticated template code and
full access to the underlying type system.  In keeping with the
Boost.Python philosophy, a Pyste interface description is neither
intrusive on the code being wrapped, nor expressed in some unfamiliar
language: instead it is a 100% pure Python script.  If Pyste is
successful it will mark a move away from wrapping everything directly
in C++ for many of our users.  It will also allow us the choice to
shift some of the metaprogram code from C++ to Python.  We expect that
soon, not only our users but the Boost.Python developers themselves
will be "thinking hybrid" about their own code.</p>
<p>
Bruno da Silva de Oliveira正在开发
<a class="reference" href="http://www.boost.org/libs/python/pyste">Pyste</a>。
Pyste基于
<a class="reference" href="http://www.gccxml.org/HTML/Index.html">GCC_XML</a>
构建，
而GCC_XML可以生成XML版本的GCC内部程序描述。
因为GCC是一种高度兼容标准的C++编译器，
从而确保了对最复杂的模板代码的正确处理，
和对底层类型系统的完全访问。
和Boost.Python的哲学一致，
Pyste接口描述既不侵入待封装的代码，
也不使用某种不熟悉的语言来表达，
相反，它是100%的纯Python脚本。
如果Pyste成功的话，
它将标志，
我们的许多用户不必直接用C++封装所有东西。
Pyste也将允许我们选择性地
把一些元编程代码从C++转移到Python。
我们期待不久以后，不仅用户，
而且Boost.Python开发者也能，
“混合地思考”他们自己的代码。
（译注：Pyste已不再维护，更新的是
<a href="http://www.language-binding.net/pyplusplus/pyplusplus.html">Py++</a>。）
</p>
</div>
</div>

<div class="section" id="serialization">
<h2><a class="toc-backref" href="#id17" name="serialization">Serialization</a></h2>
<h2>序列化</h2>
<p><em>Serialization</em> is the process of converting objects in memory to a
form that can be stored on disk or sent over a network connection. The
serialized object (most often a plain string) can be retrieved and
converted back to the original object. A good serialization system will
automatically convert entire object hierarchies. Python's standard
<tt class="literal"><span class="pre">pickle</span></tt> module is just such a system.  It leverages the language's strong
runtime introspection facilities for serializing practically arbitrary
user-defined objects. With a few simple and unintrusive provisions this
powerful machinery can be extended to also work for wrapped C++ objects.
Here is an example:</p>
<p>
<em>序列化（serialization）</em>是指，
把内存中的对象转换成可保存格式，
使之可以保存到磁盘上，
或通过网络传送。
序列化后的对象（最常见的是普通字符串），
可以恢复并转换回原来的对象。
好的序列化系统会自动转换整个对象层次结构。
Python的标准模块
<tt class="literal"><span class="pre">pickle</span></tt>
正是这样的系统。
它利用了语言强大的运行时内省机制，
可以序列化几乎任意的用户自定义对象。
只需加入一些简单的、非侵入的处理，
就可以扩展这个威力巨大的系统，
使它也能用于封装的C++对象。
下面是一个例子:
</p>
<pre class="literal-block">#include &lt;string&gt;

struct World
{
    World(std::string a_msg) : msg(a_msg) {}
    std::string greet() const { return msg; }
    std::string msg;
};

#include &lt;boost/python.hpp&gt;
using namespace boost::python;

struct World_picklers : pickle_suite
{
  static tuple
  getinitargs(World const&amp; w) { return make_tuple(w.greet()); }
};

BOOST_PYTHON_MODULE(hello)
{
    class_&lt;World&gt;("World", init&lt;std::string&gt;())
        .def("greet", &amp;World::greet)
        .def_pickle(World_picklers())
    ;
}
</pre>
<p>Now let's create a <tt class="literal"><span class="pre">World</span></tt> object and put it to rest on disk:</p>
<p>
现在，让我们创建一个
<tt class="literal"><span class="pre">World</span></tt>
对象并把它保存到磁盘：
</p>
<pre class="literal-block">&gt;&gt;&gt; import hello
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; a_world = hello.World("howdy")
&gt;&gt;&gt; pickle.dump(a_world, open("my_world", "w"))
</pre>
<p>In a potentially <em>different script</em> on a potentially <em>different
computer</em> with a potentially <em>different operating system</em>:</p>
<p>
然后，可能是在不同的计算机、不同的操作系统上，一个脚本可能这样恢复对象：
</p>
<pre class="literal-block">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; resurrected_world = pickle.load(open("my_world", "r"))
&gt;&gt;&gt; resurrected_world.greet()
'howdy'
</pre>
<p>Of course the <tt class="literal"><span class="pre">cPickle</span></tt> module can also be used for faster
processing.</p>
<p>
当然，使用
<tt class="literal"><span class="pre">cPickle</span></tt>
模块可以更快速地处理。
</p>
<p>Boost.Python's <tt class="literal"><span class="pre">pickle_suite</span></tt> fully supports the <tt class="literal"><span class="pre">pickle</span></tt> protocol
defined in the standard Python documentation. Like a __getinitargs__
function in Python, the pickle_suite's getinitargs() is responsible for
creating the argument tuple that will be use to reconstruct the pickled
object.  The other elements of the Python pickling protocol,
__getstate__ and __setstate__ can be optionally provided via C++
getstate and setstate functions.  C++'s static type system allows the
library to ensure at compile-time that nonsensical combinations of
functions (e.g. getstate without setstate) are not used.</p>
<p>
Boost.Python的
<tt class="literal"><span class="pre">pickle_suite</span></tt>
完全支持标准Python文档定义的
<tt class="literal"><span class="pre">pickle</span></tt>
协议。
类似Python里的__getinitargs__函数，
pickle_suite的getinitargs()负责创建参数元组，
以重建pickle的对象。 
Python pickle协议中的其他元素，
__getstate__和__setstate__，
可以通过C++ getstate和setstate函数来提供，也可以不提供。
利用C++的静态类型系统，
Boost.Python库在编译时保证，
不会使用没有意义的函数组合
（例如，有getstate无setstate）。
</p>
<p>Enabling serialization of more complex C++ objects requires a little
more work than is shown in the example above. Fortunately the
<tt class="literal"><span class="pre">object</span></tt> interface (see next section) greatly helps in keeping the
code manageable.</p>
<p>
要想序列化更复杂的C++对象，
就需要做更多的工作。
幸运的是，
<tt class="literal"><span class="pre">object</span></tt>
接口（见下一节）帮了大忙，
它保持了代码的可管理性。
</p>
</div>
<div class="section" id="object-interface">
<h2><a class="toc-backref" href="#id18" name="object-interface">Object interface</a></h2>
<h2>Object接口</h2>
<p>Experienced 'C' language extension module authors will be familiar
with the ubiquitous <tt class="literal"><span class="pre">PyObject*</span></tt>, manual reference-counting, and the
need to remember which API calls return "new" (owned) references or
"borrowed" (raw) references.  These constraints are not just
cumbersome but also a major source of errors, especially in the
presence of exceptions.</p>
<p>
对于有经验的'C'语言扩展模块的作者，
他们应该熟悉无所不在的
<tt class="literal"><span class="pre">PyObject*</span></tt>，
手工引用计数，
而且需要记住哪个API调用返回“新的”（拥有的）引用，
哪个返回“借来的”（原始的）引用。
这些约束不仅麻烦，
而且是主要的错误源，
尤其是面临异常的时候。
</p>
<p>Boost.Python provides a class <tt class="literal"><span class="pre">object</span></tt> which automates reference
counting and provides conversion to Python from C++ objects of
arbitrary type.  This significantly reduces the learning effort for
prospective extension module writers.</p>
<p>
Boost.Python提供了一个
<tt class="literal"><span class="pre">object</span></tt>类，
它能够自动进行引用计数，
并且能把任意类型的C++对象转换到Python。
对于未来的扩展模块的编写者来说，
这极大地减轻了学习的负担。
</p>
<p>Creating an <tt class="literal"><span class="pre">object</span></tt> from any other type is extremely simple:</p>
<p>
从任何其他类型创建
<tt class="literal"><span class="pre">object</span></tt>
极其简单:
</p>
<pre class="literal-block">object s("hello, world");  // s manages a Python string
</pre>
<p><tt class="literal"><span class="pre">object</span></tt> has templated interactions with all other types, with
automatic to-python conversions. It happens so naturally that it's
easily overlooked:</p>
<p>
<tt class="literal"><span class="pre">object</span></tt>
和所有其他类型的交互，
以及到Python的自动转换，
都已经模板化了。
这一切进行得如此自然，
以至于可以轻松地忽略掉它：
</p>
<pre class="literal-block">object ten_Os = 10 * s[4]; // -&gt; "oooooooooo"
</pre>
<p>In the example above, <tt class="literal"><span class="pre">4</span></tt> and <tt class="literal"><span class="pre">10</span></tt> are converted to Python objects
before the indexing and multiplication operations are invoked.</p>
<p>
上例中，在调用索引和乘法操作之前，
<tt class="literal"><span class="pre">4</span></tt>
和<tt class="literal"><span class="pre">10</span></tt>
被转换成了Python对象。
</p>
<p>The <tt class="literal"><span class="pre">extract&lt;T&gt;</span></tt> class template can be used to convert Python objects
to C++ types:</p>
<p>
用类模板
<tt class="literal"><span class="pre">extract&lt;T&gt;</span></tt>
可以把Python对象转换成C++类型：
</p>
<pre class="literal-block">double x = extract&lt;double&gt;(o);
</pre>
<p>If a conversion in either direction cannot be performed, an
appropriate exception is thrown at runtime.</p>
<p>
如果有一个方向的转换不能进行，则将在运行时抛出一个适当的异常。
</p>
<p>The <tt class="literal"><span class="pre">object</span></tt> type is accompanied by a set of derived types
that mirror the Python built-in types such as <tt class="literal"><span class="pre">list</span></tt>, <tt class="literal"><span class="pre">dict</span></tt>,
<tt class="literal"><span class="pre">tuple</span></tt>, etc. as much as possible. This enables convenient
manipulation of these high-level types from C++:</p>
<p>
除了
<tt class="literal"><span class="pre">object</span></tt>
类型，
还有一组派生类型，
它们尽可能地对应于Python内置类型，如
<tt class="literal"><span class="pre">list</span></tt>、
<tt class="literal"><span class="pre">dict</span></tt>、
<tt class="literal"><span class="pre">tuple</span></tt>
等等。
这样就能方便地从C++操作这些高级类型了：
</p>
<pre class="literal-block">dict d;
d["some"] = "thing";
d["lucky_number"] = 13;
list l = d.keys();
</pre>
<p>This almost looks and works like regular Python code, but it is pure
C++.  Of course we can wrap C++ functions which accept or return
<tt class="literal"><span class="pre">object</span></tt> instances.</p>
<p>
这看起来几乎就像是正规的Python代码，
运行起来也像，
但它是纯的C++。
当然我们也能封装接受或返回
<tt class="literal"><span class="pre">object</span></tt>
实例的C++函数。
</p>
</div>
</div>
<div class="section" id="thinking-hybrid">
<h1><a class="toc-backref" href="#id19" name="thinking-hybrid">Thinking hybrid</a></h1>
<h1>混合地思考</h1>
<p>Because of the practical and mental difficulties of combining
programming languages, it is common to settle a single language at the
outset of any development effort.  For many applications, performance
considerations dictate the use of a compiled language for the core
algorithms.  Unfortunately, due to the complexity of the static type
system, the price we pay for runtime performance is often a
significant increase in development time.  Experience shows that
writing maintainable C++ code usually takes longer and requires <em>far</em>
more hard-earned working experience than developing comparable Python
code.  Even when developers are comfortable working exclusively in
compiled languages, they often augment their systems by some type of
ad hoc scripting layer for the benefit of their users without ever
availing themselves of the same advantages.</p>
<p>
因为混合语言编程具有事实上和心理上的困难，
所以普通的做法是，
在任何开发活动开始时，
先确定一种单一语言。
对很多应用来说，
性能上的考虑决定了
核心算法要用编译性语言实现。
不幸的是，
由于静态类型系统的复杂性，
为了运行时的性能，
我们所付出的代价常常是，
开发时间大大增加。
经验表明，
和开发同等的Python代码相比，
编写可维护的C++代码通常需要更长的时间，
并且要求<em>多得</em>多的来之不易的工作经验。
即使开发者觉得只用一门编译性语言挺好，
为了用户的利益，
他们也经常给他们的系统增加某种专门的脚本层，
但是他们自己却从没利用这种好处。
</p>
<p>Boost.Python enables us to <em>think hybrid</em>.  Python can be used for
rapidly prototyping a new application; its ease of use and the large
pool of standard libraries give us a head start on the way to a
working system.  If necessary, the working code can be used to
discover rate-limiting hotspots.  To maximize performance these can
be reimplemented in C++, together with the Boost.Python bindings
needed to tie them back into the existing higher-level procedure.</p>
<p>
Boost.Python让我们可以<em>混合地思考（think hybrid）</em>。
Python可以为一个新应用快速搭建原型；
在建立一个可运行的系统时，
它的易用性和一大堆标准库让我们处于领先。
如果有必要，
可以用运行的代码来揭示限制速度的热点。
为了提高性能，这些热点可以用C++来重新实现，
然后用Boost.Python绑定，
并提供给现有的高级过程调用。
</p>
<p>Of course, this <em>top-down</em> approach is less attractive if it is clear
from the start that many algorithms will eventually have to be
implemented in C++.  Fortunately Boost.Python also enables us to
pursue a <em>bottom-up</em> approach.  We have used this approach very
successfully in the development of a toolbox for scientific
applications.  The toolbox started out mainly as a library of C++
classes with Boost.Python bindings, and for a while the growth was
mainly concentrated on the C++ parts.  However, as the toolbox is
becoming more complete, more and more newly added functionality can be
implemented in Python.</p>
<p>
当然，如果从一开始就清楚，
有许多算法将最终不得不用C++实现，
这个<em>自上而下（top-down）</em>的方法就不是那么吸引人了。
幸运的是，
Boost.Python让我们也可以采用<em>自下而上（bottom-up）</em>的方法。
我们曾经非常成功地应用这种方法，
开发一个科学软件工具箱。
开始的时候，
这个工具箱主要是一个C++类库，
并带有Boost.Python绑定，
并且有一段时间，
其成长主要集中在C++的部分。
然而，当工具箱越来越完善，
越来越多的新增功能可以用Python实现。
</p>
<!--p><img alt="python_cpp_mix.jpg" src="bpl_files/python_cpp_mix.htm"></p-->

<p><img alt="python_cpp_mix.jpg" src="python_cpp_mix.jpg"></p>

<p>This figure shows the estimated ratio of newly added C++ and Python
code over time as new algorithms are implemented.  We expect this
ratio to level out near 70% Python.  Being able to solve new problems
mostly in Python rather than a more difficult statically typed
language is the return on our investment in Boost.Python.  The ability
to access all of our code from Python allows a broader group of
developers to use it in the rapid development of new applications.</p>
<p>
该图显示，实现新的算法时，
估计新增C++和Python代码的比率随时间的变化。
我们预计这个比率会在接近70%的Python处变平。
能够主要地用Python来解决新问题，
而不是用更困难的静态类型语言，
这是我们在Boost.Python上投入的回报。
我们的所有代码都能从Python访问，
这使得更多的开发者可以用它来快速开发新的应用。
</p>
</div>

<div class="section" id="development-history">
<h1><a class="toc-backref" href="#id20" name="development-history">Development history</a></h1>
<h1>开发历史</h1>
<p>The first version of Boost.Python was developed in 2000 by Dave
Abrahams at Dragon Systems, where he was privileged to have Tim Peters
as a guide to "The Zen of Python".  One of Dave's jobs was to develop
a Python-based natural language processing system.  Since it was
eventually going to be targeting embedded hardware, it was always
assumed that the compute-intensive core would be rewritten in C++ to
optimize speed and memory footprint 
<a class="footnote-reference" href="#proto" id="id2" name="id2"><sup>1</sup></a>.  
The project also wanted to
test all of its C++ code using Python test scripts 
<a class="footnote-reference" href="#test" id="id3" name="id3"><sup>2</sup></a>.  The only
tool we knew of for binding C++ and Python was 
<a class="reference" href="http://www.swig.org/">SWIG</a>, and at the time
its handling of C++ was weak.  It would be false to claim any deep
insight into the possible advantages of Boost.Python's approach at
this point.  Dave's interest and expertise in fancy C++ template
tricks had just reached the point where he could do some real damage,
and Boost.Python emerged as it did because it filled a need and
because it seemed like a cool thing to try.</p>
<p>
Boost.Python的第一版是由Dragon Systems的Dave Abrahams在2000年开发的，
在Dragon Systems，
Dave有幸由Tim Peters引导，
接受了“Python之禅（The Zen of Python）”。
Dave的工作之一是，
开发基于Python的自然语言处理系统（NLP，natural language processing）。
由于最终要用于嵌入式硬件，
所以总是假设，
计算密集的内核将会用C++来重写，
以优化速度和内存占用
<a class="footnote-reference" href="#proto" id="id2" name="id2"><sup>1</sup></a>。
这个项目也想用Python测试脚本来测试所有的C++代码
<a class="footnote-reference" href="#test" id="id3" name="id3"><sup>2</sup></a>。
当时，我们所知的绑定C++和Python的唯一工具是
<a class="reference" href="http://www.swig.org/">SWIG</a>，
但那时它处理C++的能力比较弱。
如果说在那时就有什么深知卓见，
说Boost.Python的方法会有何等优越性，
那是骗人的。
那时，Dave正好对花俏的C++模板技巧感兴趣，
并且娴熟到刚好能真正做点东西，
Boost.Python就那样出现了，
因为它满足了需求，
因为它看起来挺酷，
值得一试。
</p>
<p>This early version was aimed at many of the same basic goals we've
described in this paper, differing most-noticeably by having a
slightly more cumbersome syntax and by lack of special support for
operator overloading, pickling, and component-based development.
These last three features were quickly added by Ullrich Koethe and
Ralf Grosse-Kunstleve <a class="footnote-reference" href="#feature" id="id4" name="id4"><sup>3</sup></a>, 
and other enthusiastic contributors arrived
on the scene to contribute enhancements like support for nested
modules and static member functions.</p>
<p>
这个早期版本针对的目标，
与我们在本文所述的许多基本目标相同，
最显著的区别在于，
语法要稍微麻烦一点，
并且，
对运算符重载、pickling，
和基于组件的开发缺乏专门的支持。
后面这三个特性很快就由Ullrich Koethe和Ralf Grosse-Kunstleve加上了
<a class="footnote-reference" href="#feature" id="id4" name="id4"><sup>3</sup></a>，
并且，
其他热心的贡献者也出现了，
并作了一些改进，
如对嵌套模块和静态成员函数的支持等。
</p>
<p>By early 2001 development had stabilized and few new features were
being added, however a disturbing new fact came to light: Ralf had
begun testing Boost.Python on pre-release versions of a compiler using
the <a class="reference" href="http://www.edg.com/">EDG</a> 
front-end, and the mechanism at the core of Boost.Python
responsible for handling conversions between Python and C++ types was
failing to compile.  As it turned out, we had been exploiting a very
common bug in the implementation of all the C++ compilers we had
tested.  We knew that as C++ compilers rapidly became more
standards-compliant, the library would begin failing on more
platforms.  Unfortunately, because the mechanism was so central to the
functioning of the library, fixing the problem looked very difficult.</p>
<p>
到2001年初，开发已经稳定下来了，
很少有新增特性了，
然而，这时出现了一件新的麻烦事：
Ralf在一个使用
<a class="reference" href="http://www.edg.com/">EDG</a>
前端的编译器的预发布版上测试Boost.Python，
他发现，
Boost.Python内核中，Python和C++类型转换机制无法通过编译。
结果表明，我们一直是在利用一个错误，
这是一个非常普遍的错误，
存在于所有我们已经测试过的C++编译器的实现中。
我们知道，随着C++编译器变得更加符合标准，
很快，库将开始在更多的平台上失败。
很不幸，因为这套机制是Boost.Python库功能的中枢，
解决问题看起来非常困难。
</p>
<p>Fortunately, later that year Lawrence Berkeley and later Lawrence
Livermore National labs contracted with 
<a class="reference" href="http://www.boost-consulting.com/">Boost Consulting</a> 
for support
and development of Boost.Python, and there was a new opportunity to
address fundamental issues and ensure a future for the library.  A
redesign effort began with the low level type conversion architecture,
building in standards-compliance and support for component-based
development (in contrast to version 1 where conversions had to be
explicitly imported and exported across module boundaries).  A new
analysis of the relationship between the Python and C++ objects was
done, resulting in more intuitive handling for C++ lvalues and
rvalues.</p>
<p>
幸运的是，那一年末，
Lawrence Berkeley，后来建立了
Lawrence Livermore National labs，
与<a class="reference" href="http://www.boost-consulting.com/">Boost Consulting</a>
签订了合同，来支持和发展Boost.Python，
这样就有了一个新的机会来处理库的基本问题，
从而确保了库未来的发展。
库进行了重新设计，
开始于底层的类型转换架构，
使它内置具有标准兼容性，
并支持基于组件的开发
（第1版中，转换必须显式地在模块间导入和导出）。
对Python和C++对象的关系进行了新的分析，
从而能更直观地处理C++左值和右值。
</p>
<p>The emergence of a powerful new type system in Python 2.2 made the
choice of whether to maintain compatibility with Python 1.5.2 easy:
the opportunity to throw away a great deal of elaborate code for
emulating classic Python classes alone was too good to pass up.  In
addition, Python iterators and descriptors provided crucial and
elegant tools for representing similar C++ constructs.  The
development of the generalized 
<tt class="literal"><span class="pre">object</span></tt> 
interface allowed us to
further shield C++ programmers from the dangers and syntactic burdens
of the Python 'C' API.  A great number of other features including C++
exception translation, improved support for overloaded functions, and
most significantly, CallPolicies for handling pointers and
references, were added during this period.</p>
<p>
关于是否维护对Python 1.5.2的兼容性，
因为Python 2.2里出现了一个强大的新的类型系统，
选择变得容易了：
这个机会好的令人无法拒绝，
籍此可以抛弃大量复杂精细的代码，
而这些代码仅仅是用来模拟传统的Python类。
另外，Python的迭代器（iterator）和描述符（descriptor）
提供了重要且优雅的工具，
用来表示类似的C++构造。
通用的<tt class="literal"><span class="pre">object</span></tt>
接口的开发进一步方便了C++程序员，
免除了Python 'C' API的危险性和语法负担。
这一阶段，还添加了大量其他特性，
包括C++异常翻译，对函数重载的更好的支持，
还有最重要的，用来处理指针和引用的CallPolicies。
</p>
<p>In October 2002, version 2 of Boost.Python was released.  Development
since then has concentrated on improved support for C++ runtime
polymorphism and smart pointers.  Peter Dimov's ingenious
<tt class="literal"><span class="pre">boost::shared_ptr</span></tt> 
design in particular has allowed us to give the
hybrid developer a consistent interface for moving objects back and
forth across the language barrier without loss of information.  At
first, we were concerned that the sophistication and complexity of the
Boost.Python v2 implementation might discourage contributors, but the
emergence of 
<a class="reference" href="http://www.boost.org/libs/python/pyste">Pyste</a> 
and several other significant feature
contributions have laid those fears to rest.  Daily questions on the
Python C++-sig and a backlog of desired improvements show that the
library is getting used.  To us, the future looks bright.</p>
<p>
2002年十月，Boost.Python第2版发布了。
从那以后，
开发集中于更好地支持C++运行时多态性和智能指针。
特别是Peter Dimov巧妙的
<tt class="literal"><span class="pre">boost::shared_ptr</span></tt> 
的设计，
使我们能给混和系统开发者提供一个一致的接口，
用于跨越语言屏障来回移动对象而不丢失信息。
刚开始，
我们担心Boost.Python v2实现的诡秘与复杂会阻碍贡献者，
但<a class="reference" href="http://www.boost.org/libs/python/pyste">Pyste</a>的出现，
和其他几个重要特性的贡献，
证明那些担心是多余的。
在Python C++-sig上每天的提问，
和积压的改进请求表明了库正在被使用。
对我们来说，未来是光明的。
</p>
</div>

<div class="section" id="conclusions">
<h1><a class="toc-backref" href="#id21" name="conclusions">Conclusions</a></h1>
<h1>结论</h1>
<p>Boost.Python achieves seamless interoperability between two rich and
complimentary language environments.  Because it leverages template
metaprogramming to introspect about types and functions, the user
never has to learn a third syntax: the interface definitions are
written in concise and maintainable C++.  Also, the wrapping system
doesn't have to parse C++ headers or represent the type system: the
compiler does that work for us.</p>
<p>
Boost.Python在两种功能丰富并且互补的语言环境间实现了无缝协作。
因为它利用模板元编程对类型和函数进行内省，
用户不必去学习第三种语言：
接口定义是用简洁和可维护的C++写的。
同时，封装系统不必解析C++头文件或者描述类型系统：
编译器都给我们做了。
</p>
<p>Computationally intensive tasks play to the strengths of C++ and are
often impossible to implement efficiently in pure Python, while jobs
like serialization that are trivial in Python can be very difficult in
pure C++.  Given the luxury of building a hybrid software system from
the ground up, we can approach design with new confidence and power.</p>
<p>
计算密集型任务是C++的强项，
一般不可能用纯Python高效实现，
然而像序列化这样的工作，
用Python很简单，
用纯C++就非常困难。
如果我们能构建完全的混合软件系统，
我们就能以新的信心和力量来进行设计。
</p>
</div>

<div class="section" id="citations">
<h1><a class="toc-backref" href="#id22" name="citations">Citations</a></h1>
<h1>引用</h1>
<table class="citation" id="veld1995" frame="void" rules="none">
<colgroup><col class="label"><col></colgroup>
<col>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="veld1995">[VELD1995]</a></td><td>T. Veldhuizen, "Expression Templates," C++ Report,
Vol. 7 No. 5 June 1995, pp. 26-31.
<a class="reference" href="http://osl.iu.edu/%7Etveldhui/papers/Expression-Templates/exprtmpl.html">http://osl.iu.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="footnotes">
<h1><a class="toc-backref" href="#id23" name="footnotes">Footnotes</a></h1>
<h1>脚注</h1>
<table class="footnote" id="proto" frame="void" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="proto">[1]</a></td>
<td>
In retrospect, it seems that "thinking hybrid" from the
ground up might have been better for the NLP system: the
natural component boundaries defined by the pure python
prototype turned out to be inappropriate for getting the
desired performance and memory footprint out of the C++ core,
which eventually caused some redesign overhead on the Python
side when the core was moved to C++.
<p>
回想起来，对NLP系统来说，
从一开始就“混合地思考”可能会更好：
用纯Python原型定义的组件接口，
对Python来说是自然的，
可后来发现并不合适。
当核心改写成C++时，
使用该接口无法达到期望的性能和内存占用要求，
最后只好对Python这边的某些部分重新设计，
造成了额外开销。
</p>
</td>
</tr>
</tbody>
</table>
<table class="footnote" id="test" frame="void" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="test">[2]</a></td>
<td>We also have some reservations about driving all C++
testing through a Python interface, unless that's the only way
it will be ultimately used.  Any transition across language
boundaries with such different object models can inevitably
mask bugs.
<p>
对于通过Python接口来驱动所有C++测试，我们也持保留态度，
除非从Python调用是最终唯一的使用方式。
因为两种语言的对象模型如此不同，
任何跨越语言边界的转换都会不可避免地掩盖错误。
</p>
</td></tr>
</tbody>
</table>
<table class="footnote" id="feature" frame="void" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="feature">[3]</a></td>
<td>These features were expressed very differently in v1 of
Boost.Python
<p>
这些特性在Boost.Python v1里表达方式非常不同。
</p>
</td></tr>
</tbody>
</table>
</div>
</div>
<hr class="footer">
<div class="footer">
<a class="reference" href="http://www.boost-consulting.com/writing/bpl.txt">View document source</a>.
Generated on: 2003-03-19 03:31 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body></html>
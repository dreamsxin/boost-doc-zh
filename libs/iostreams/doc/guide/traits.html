<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">

    
    
  <title>I/O Traits and Categories</title>
  <link rel="stylesheet" href="../../../../boost.css">

    
  <link rel="stylesheet" href="../theme/iostreams.css">
</head>


<body>


<!-- Begin Banner -->

    
<h1 class="title">I/O Traits 和 Categories</h1>

    
<hr class="banner">

<!-- End Banner -->

<dl class="page-index">

  <dt><a href="#overview">简介</a></dt>

  <dt><a href="#headers">头文件</a></dt>

  <dt><a href="#char_type_of_ref">类模板 <code>char_type_of</code></a></dt>

  <dt><a href="#int_type_of_ref">类模板 <code>int_type_of</code></a></dt>

  <dt><a href="#category_ref">类模板 <code>category_of</code></a></dt>

  <dt><a href="#category_tags">Category 标志</a></dt>

  
</dl>


<hr>

<a name="overview"></a>
<h2>简介</h2>


<p>头文件 <a class="header" href="../../../../boost/iostreams/categories.hpp"><code>&lt;boost/iostreams/categories.hpp&gt;</code></a> 包含了用于标识不同 <a href="concepts.html#filter_concepts">Filter</a> 和 <a href="concepts.html#device_concepts">Device</a> 概念的 model 的 <a href="#category_tags">category tags</a>&nbsp;. 头文件 <a class="header" href="../../../../boost/iostreams/traits.hpp"><code>&lt;boost/iostreams/traits.hpp&gt;</code></a> 则包含了元函数 <a href="#char_type_of_ref"><code>char_type_of</code></a> 和 <a href="#category_ref"><code>category</code></a> 的定义，它们用于取出某个 <a href="concepts.html#filter_concepts">Filter</a> 和 <a href="concepts.html#device_concepts">Device</a> 概念的 model 中的以下两个基础类型：
</p>


<a name="char_type"></a>
<h4>字符类型</h4>


<p>过滤器或设备读写的字符类型。</p>


<a name="category"></a>
<h4>Category</h4>


<p>一个标志结构，Iostreams 库根据它来决定一个过滤器或设备支持哪些操作。对于给定的类型 <code>T</code>，它表示：
</p>

<ul>

    <li class="square"><code>T</code> 是否一个 <a href="concepts.html#filter_concepts">Filter</a> 或 <a href="concepts.html#device_concepts">Device</a>
    </li>
  <li class="square"><code>T</code>&nbsp;的&nbsp;<a href="modes.html">mode</a><code></code>
    </li>
  <li class="square"><code>T</code> 实现的任意 <a href="concepts.html#optional_behavior">optional_behavior</a>&nbsp;
  </li>
</ul>

<p>它的功能类似于 <code>std::iterator_traits</code> 的 <code>iterator_category</code> 成员。<a class="footnote_ref" name="note_1_ref" href="#note_1"><sup>[1]</sup></a> 作为分类标志的类型统称 <a href="#category_tags">category tags</a>.
</p>


<a name="headers"></a>
<h2>头文件</h2>


<dl class="page-index">

  <dt><a class="header" href="../../../../boost/iostreams/categories.hpp"><code>&lt;boost/iostreams/categories.hpp&gt;</code></a></dt>

  <dt><a class="header" href="../../../../boost/iostreams/traits.hpp"><code>&lt;boost/iostreams/traits.hpp&gt;</code></a></dt>

</dl>


<a name="char_type_of_ref"></a>
<h2>类模板 <code>char_type_of</code></h2>


<h4>描述</h4>


<p><a href="http://www.boost.org/libs/mpl/doc/refmanual/metafunction.html" target="_top">Metafunction</a>，关联一个 <a href="traits.html#char_type">字符类型</a> 到某个 <a href="concepts.html#filter_concepts">Filter</a> 或 <a href="concepts.html#device_concepts">Device</a> 类型<a href="#char_type"></a>。虽然 <code>char_type_of</code> 被设计为要对新的过滤器和设备类型进行特化，不过多数情形下，缺省的实现可以适用。

</p>
<h4>摘要</h4>


<pre class="broken_ie"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> iostreams {<br><br><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <a href="#char_type_template_params" class="documented">T</a>&gt;<br><span class="keyword">struct</span> <a class="documented" href="#char_type_template_params">char_type_of</a> {<br>    <span class="keyword">typedef</span> <span class="omitted">see below</span> <a href="#char_type_of_type" class="documented">type</a>;<br>};<br><br>} } <span class="comment">// End namespace boost::io</span></pre>


<a name="char_type_template_params"></a>
<h4>模板参数</h4>


<table style="margin-left: 2em;" border="0" cellpadding="2">

    <tbody>
    <tr>

        <td valign="top"><i>T</i></td>
      <td valign="top" width="2em">-</td>

        <td>某个 <a href="concepts.html#filter_concepts">Filter</a> or <a href="concepts.html#device_concepts">Device</a> 概念的 model</td>

    </tr>

  </tbody>
</table>


<a name="char_type_of_type"></a>
<h4><code>io_traits::type</code></h4>


<pre class="broken_ie">    <span class="keyword">typedef</span> <span class="omitted">see below</span> char_type;</pre>


<p>嵌套类型 <code>type</code> 的值取决于模板参数 <code>T</code> 如下：</p>


<table style="margin-left: 2em;" border="1" cellpadding="4">

  <tbody>
    <tr>
      <th><code>T</code></th>
      <th><code>char_type</code></th>
    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a><code>std::back_insert_iterator</code> 的特化<code></code></td>

        <td>迭代器的 <code>container_type</code> 的 <code>value_type</code><code></code></td>

    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a>所有其它类型</td>

        <td><code>T::char_type</code></td>

    </tr>

  </tbody>
</table>


<a name="int_type_of_ref"></a>
<h2>类模板 <code>int_type_of</code></h2>


<h4>描述</h4>


<p><a href="http://www.boost.org/libs/mpl/doc/refmanual/metafunction.html" target="_top">Metafunction</a>，关联一个整型类型到某个 <a href="concepts.html#filter_concepts">Filter</a> 或 <a href="concepts.html#device_concepts">Device</a> 类型。虽然 <code>int_type_of</code> 被设计为要对新的过滤器和设备类型进行特化，不过多数情形下，缺省的实现可以适用。

</p>
<h4>摘要</h4>


<pre class="broken_ie"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> iostreams {<br><br><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <a href="#int_type_template_params" class="documented">T</a>&gt;<br><span class="keyword">struct</span> <a class="documented" href="#int_type_template_params">int_type_of</a> {<br>    <span class="keyword">typedef</span> <span class="omitted">see below</span> <a href="#int_type_of_type" class="documented">type</a>;<br>};<br><br>} } <span class="comment">// End namespace boost::io</span></pre>


<a name="int_type_template_params"></a>
<h4>模板参数</h4>


<table style="margin-left: 2em;" border="0" cellpadding="2">

    <tbody>
    <tr>

        <td valign="top"><i>T</i></td>
      <td valign="top" width="2em">-</td>

        <td>某个 <a href="concepts.html#filter_concepts">Filter</a> or <a href="concepts.html#device_concepts">Device</a> 概念的 model</td>

    </tr>

  </tbody>
</table>


<a name="int_type_of_type"></a>
<h4><code>io_traits::type</code></h4>


<pre class="broken_ie">    <span class="keyword">typedef</span> <span class="omitted">see below</span> char_type;</pre>


<p>等于 <code>std::char_traits&lt;char_type&gt;::int_type</code>, 其中 <code>char_type</code> 为 <a href="#char_type_of_ref"><code>char_type_of&lt;T&gt;::type</code></a>.

<a name="category_ref"></a>
</p>
<h2>类模板 <code>category_of</code></h2>


<h4>描述</h4>


<p><a href="http://www.boost.org/libs/mpl/doc/refmanual/metafunction.html" target="_top">Metafunction</a>，关联一个 <a href="traits.html#category_tags">category tag</a> 到某个 <a href="concepts.html#filter_concepts">Filter</a> 或 <a href="concepts.html#device_concepts">Device</a> 类型。虽然 <code>category</code>&nbsp;被设计为要对新的过滤器和设备类型进行特化，不过多数情形下，缺省的实现可以适用。

</p>
<h4>摘要</h4>


<pre class="broken_ie"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> iostreams {<br><br><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <a href="#category_template_params" class="documented">T</a>&gt;<br><span class="keyword">struct</span> <a class="documented" href="#category_template_params">category_of</a> {<br>    <span class="keyword">typedef</span> <span class="omitted">see below</span> <a href="#category_type" class="documented">type</a>;<br>};<br><br>} } <span class="comment">// End namespace boost::io</span></pre>


<a name="category_template_params"></a>
<h4>模板参数</h4>


<table style="margin-left: 2em;" border="0" cellpadding="2">

    <tbody>
    <tr>

        <td valign="top"><i>T</i></td>
      <td valign="top" width="2em">-</td>

        <td>某个 <a href="concepts.html#filter_concepts">Filter</a> or <a href="concepts.html#device_concepts">Device</a> 概念的 model</td>

    </tr>

  </tbody>
</table>


<a name="category_type"></a>
<h4><code>category::type</code></h4>


<pre class="broken_ie">    <span class="keyword">typedef</span> <span class="omitted">see below</span> type;</pre>


<p>嵌套类型 <code>type</code> 的值取决于模板参数 <code>T</code> 如下：</p>


<table style="margin-left: 2em;" border="1" cellpadding="4">

    <tbody>
    <tr>
      <th><code>T</code></th>
      <th><code>category</code></th>
    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a><code>std::basic_iostream</code> 的特化及其派生类</td>

        <td><code>iostream_tag</code></td>

    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a><code>std::basic_istream</code> 的特化及其派生类</td>

        <td><code>istream_tag</code></td>

    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a><code>std::basic_ostream</code> 的特化及其派生类</td>

        <td><code>ostream_tag</code></td>

    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a><code>std::basic_streambuf</code> 的特化及其派生类</td>

        <td><code>streambuf_tag</code></td>

    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a><code>std::back_insert_iterator</code> 的特化及其派生类</td>

        <td><code>insert_iterator_tag</code></td>

    </tr>

    <tr>

        <td valign="top"><a name="print_CR"></a>所有其它类型</td>

        <td><code>T::category</code></td>

    </tr>

  </tbody>
</table>


<p>更多信息请见 <a class="header" href="../../../../boost/iostreams/traits.hpp"><code>&lt;boost/iostreams/traits.hpp&gt;</code></a>.</p>


<a name="category_tags"></a>
<h2>Category 标志</h2>


<p>除了各种的 <a href="modes.html#mode_tags">mode 标志</a>, 头文件 <a class="header" href="../../../../boost/iostreams/categories.hpp"><code>&lt;boost/iostreams/categories.hpp&gt;</code></a> 还提供了下表所列的 category 标志。要生成一个组合了多个已有标志的新的 category 标志，只要定义一个派生自已有标志的 <code>struct</code>&nbsp;. 即： 
    </p>
<pre class="broken_ie">    <span class="keyword">struct</span> category<br>        : seekable,<br>          filter_tag, <br>          localizable_tag <br>        { };</pre>
这定义了一个 category 标志，表示 <a href="modes.html#seekable">Seekable</a>, <a href="../concepts/localizable.html">Localizable</a> <a href="../concepts/filter.html">Filters</a>.
<p></p>



<table style="margin-left: 2em; margin-bottom: 2em;" border="1" cellpadding="6">

    <tbody>
    <tr>
      <th>标志</th>
      <th>描述</th>
    </tr>

    <tr>

        <td valign="top"><code>filter_tag</code></td>

        <td>表示一个符合 <a href="../concepts/filter.html">Filter</a> 的类型<a href="../concepts/filter.html"></a></td>

    </tr>

    <tr>

        <td valign="top"><code>device_tag</code></td>

        <td>表示一个符合 <a href="../concepts/device.html">Device</a> 的类型<a href="../concepts/device.html"></a></td>

    </tr>

    <tr>

        <td valign="top">
            <code>closable_tag</code><br>
      <code>localizable_tag</code><br>

            <code>direct_tag</code><br>
      <code>peekable_tag</code><br>

            <code>multichar_tag</code>
        </td>

        <td>用于表示一个过滤器或设备类型实现的&nbsp;<a href="concepts.html#optional_behavior">optional behavior</a>
        </td>

    </tr>

    <tr>

        <td valign="top">
            <code>source_tag</code><br>

            <code>sink_tag</code><br>

            <code>bidirectional_device_tag</code><br>

            <code>seekable_device_tag</code><br>

            <code>input_filter_tag</code><br>

            <code>output_filter_tag</code><br>

            <code>bidirectional_filter_tag</code><br>

            <code>seekable_filter_tag</code><br>

            <code>multichar_input_filter_tag</code><br>

            <code>multichar_output_filter_tag</code><br>

            <code>multichar_bidirectional_filter_tag</code><br>

            <code>multichar_seekable_filter_tag</code>
        </td>

        <td>用于定义不同 <a href="../concepts/filter.html">Filter</a> 和 <a href="../concepts/device.html">Device</a> 强化物的易用标志
        </td>

    </tr>

    <tr>

        <td valign="top">
            <code>istream_tag</code><br>

            <code>ostream_tag</code><br>

            <code>iostream_tag</code><br>

            <code>streambuf_tag</code>
        </td>

        <td>
            内部使用，区分标准流和流缓冲类型
        </td>

    </tr>

    <tr>

        <td valign="top"><code>insert_iterator_tag</code></td>

        <td>内部使用，区分 <code>std::back_insert_iterator</code> 的特化<code></code></td>

    </tr>

  </tbody>
</table>


<!-- Begin Footnotes -->

<hr>

<p>
    <a class="footnote_ref" name="note_1" href="#note_1_ref"><sup>[1]</sup></a><a class="bib_ref" href="../bibliography.html#iso">[I<span style="font-size: 80%;">SO</span>]</a> 24.3.1. <i>See</i> <a href="../../../../more/generic_programming.html#tag_dispatching" target="_top">Tag Dispatching</a> for a discussion.
</p>


<!-- End Footnotes -->

<!-- Begin Footer -->

<hr>
<p class="copyright">Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->
20 May 2004
<!--webbot bot="Timestamp" endspan i-checksum="38504" -->
</p>


<p class="copyright">&copy; Copyright <a href="http://www.kangaroologic.com" target="_top">Jonathan Turkanis</a> 2004</p>

<p class="copyright"> 
    Use modification and distribution are subject to the Boost Software License Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>


<!-- End Footer -->

</body>
</html>

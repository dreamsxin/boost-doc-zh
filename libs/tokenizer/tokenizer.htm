<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  
  <meta http-equiv="Content-Language" content="en-us">

  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">

  
  <meta name="ProgId" content="FrontPage.Editor.Document">


  
  <title>Boost Tokenizer Class</title>
</head>



<body alink="#ff0000" bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b">

  
<p><img src="../../boost.png" alt="C++ Boost" height="86" width="277"><br>
</p>


  
<h1 align="center">Tokenizer 类</h1>

  
<pre>  template &lt;<br>        class TokenizerFunc = char_delimiters_separator&lt;char&gt;, <br>        class Iterator = std::string::const_iterator,<br>        class Type = std::string<br>  &gt;<br>  class tokenizer<br></pre>


  
<p>The tokenizer
类提供了一个容器视图，将一系列单词包含在一个序列中。你将对这个序列进行分解，TokenizerFunction
将在构造时或者使用赋值成员函数时被用于对序列的分解。注：在构造时并不真的进行分解。分解是在通过迭代器访问单词时才按需执行的。</p>


  
<h2>例子</h2>

  
<pre>// simple_example_1.cpp<br>#include&lt;iostream&gt;<br>#include&lt;boost/tokenizer.hpp&gt;<br>#include&lt;string&gt;<br><br>int main(){<br>   using namespace std;<br>   using namespace boost;<br>   string s = "This is,  a test";<br>   tokenizer&lt;&gt; tok(s);<br>   for(tokenizer&lt;&gt;::iterator beg=tok.begin(); beg!=tok.end();++beg){<br>       cout &lt;&lt; *beg &lt;&lt; "\n";<br>   }<br>}<br></pre>


  
<p>&nbsp;</p>


  
<h3>模板参数</h3>


  
<table summary="" border="1">

    <tbody>
    <tr>

      <th>模板</th>


      <th>描述</th>

    </tr>


    <tr>

      <td><tt>TokenizerFunc</tt></td>


      <td>TokenizerFunction 用于分解序列。</td>

    </tr>


    <tr>

      <td><tt>Iterator</tt></td>


      <td>访问该序列的迭代器类型。</td>

    </tr>


    <tr>

      <td><tt>Type</tt></td>


      <td>单词的类型，通常是 string.</td>

    </tr>

  
  </tbody>
</table>


  
<p>&nbsp;</p>


  
<h2>相关的类型</h2>


  
<table summary="" border="1">

    <tbody>
    <tr>

      <td>
        
      <p align="center"><strong>类型</strong></p>

      </td>


      <td>
        
      <p align="center"><strong>说明</strong></p>

      </td>

    </tr>


    <tr>

      <td>iterator</td>


      <td>begin 和 end 函数的返回类型。注：迭代器的种类最多只能是 ForwardIterator. 如果
      Iterator 模板参数是 InputIterator，那么它也是 InputIterator. 对于其它种类，它就是 ForwardIterator.</td>

    </tr>


    <tr>

      <td>const_iterator</td>


      <td>与 iterator 相同的类型。</td>

    </tr>


    <tr>

      <td>value_type</td>


      <td>与模板参数 Type 相同的类型</td>

    </tr>


    <tr>

      <td>reference</td>


      <td>与 value_type&amp; 相同的类型</td>

    </tr>


    <tr>

      <td>const_reference</td>


      <td>与 const reference 相同的类型</td>

    </tr>


    <tr>

      <td>pointer</td>


      <td>与&nbsp;value_type* 相同的类型</td>

    </tr>


    <tr>

      <td>const_pointer</td>


      <td>与 const pointer 相同的类型</td>

    </tr>


    <tr>

      <td>size_type</td>


      <td>void</td>

    </tr>


    <tr>

      <td>difference_type</td>


      <td>void</td>

    </tr>

  
  </tbody>
</table>


  
<p>&nbsp;</p>


  
<h2>构造函数和成员函数</h2>

  
<pre>tokenizer(Iterator first, Iterator last,const TokenizerFunc&amp; f = TokenizerFunc()) <br><br>template&lt;class Container&gt;<br>tokenizer(const Container&amp; c,const TokenizerFunc&amp; f = TokenizerFunc())<br><br>void assign(Iterator first, Iterator last)<br><br>void assign(Iterator first, Iterator last, const TokenizerFunc&amp; f)<br><br>template&lt;class Container&gt;<br>void assign(const Container&amp; c)<br><br>template&lt;class Container&gt;<br>void assign(const Container&amp; c, const TokenizerFunc&amp; f)<br><br>iterator begin() const <br><br>iterator end() const<br></pre>


  
<table summary="" border="1">

    <tbody>
    <tr>

      <td>
        
      <p align="center"><strong>参数</strong></p>

      </td>


      <td>
        
      <p align="center"><strong>描述</strong></p>

      </td>

    </tr>


    <tr>

      <td>c</td>


      <td>一个包含被分解的序列的容器。注：c.begin() 和 c.end() 必须可以转换为模板参数
      Iterator.</td>

    </tr>


    <tr>

      <td>f</td>


      <td>一个符合 TokenizerFunction 的函数对象，用于对序列进行分解。</td>

    </tr>


    <tr>

      <td>first</td>


      <td>迭代器，表示被分解序列的开始位置。</td>

    </tr>


    <tr>

      <td>last</td>


      <td>迭代器，表示被分解序列的末尾位置。</td>

    </tr>

  
  </tbody>
</table>


  
<p>&nbsp;</p>

  
<hr>

  
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Transitional" border="0" height="31" width="88"></a></p>


  
<p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->25 December, 2006<!--webbot bot="Timestamp" endspan i-checksum="38518" --></p>


  
<p><i>Copyright &copy; 2001 John R. Bandela</i></p>


  
<p><i>Distributed under the Boost Software License, Version 1.0. (See
  accompanying file <a href="../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
  copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>

</body>
</html>

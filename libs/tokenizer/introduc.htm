<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>


  
  
  <meta http-equiv="Content-Language" content="en-us">


  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


  
  
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">


  
  
  <meta name="ProgId" content="FrontPage.Editor.Document">



  
  
  <title>Introduction</title>
</head>


<body bgcolor="#ffffff">


  
<p><img src="../../boost.png" alt="C++ Boost" height="86" width="277"><br>

</p>



  
<h1 align="center">介绍</h1>



  
<p align="left">boost Tokenizer 包提供了灵活和易用的方法来将一个字符串或其它字符序列分解成一系列单词。下面是一个简单的例子，将一个短语分解为单词。</p>



  
<div align="left">
    
<pre>// simple_example_1.cpp<br>#include&lt;iostream&gt;<br>#include&lt;boost/tokenizer.hpp&gt;<br>#include&lt;string&gt;<br><br>int main(){<br>   using namespace std;<br>   using namespace boost;<br>   string s = "This is,  a test";<br>   tokenizer&lt;&gt; tok(s);<br>   for(tokenizer&lt;&gt;::iterator beg=tok.begin(); beg!=tok.end();++beg){<br>       cout &lt;&lt; *beg &lt;&lt; "\n";<br>   }<br>}<br></pre>


  </div>



  
<p align="left">你可以通过指定 TokenizerFunction 来选择如何分解字符串。如果你不指定，则缺省的 TokenizerFunction 是 char_delimiters_separator&lt;char&gt;，它的缺省行为是以空格和标点来分解字符串。这里有一个例子使用了另一个名为 escaped_list_separator 的 TokenizerFunction.
  这个 TokenizerFunction 用于分析一个逗号分隔格式(csv)行的超集。该格式如下例：</p>



  
<p align="left">Field 1,"putting quotes around fields, allows commas",Field
  3</p>



  
<p align="left">以下例子将上述行分解为3个域。</p>



  
<div align="left">
    
<pre>// simple_example_2.cpp<br>#include&lt;iostream&gt;<br>#include&lt;boost/tokenizer.hpp&gt;<br>#include&lt;string&gt;<br><br>int main(){<br>   using namespace std;<br>   using namespace boost;<br>   string s = "Field 1,\"putting quotes around fields, allows commas\",Field 3";<br>   tokenizer&lt;escaped_list_separator&lt;char&gt; &gt; tok(s);<br>   for(tokenizer&lt;escaped_list_separator&lt;char&gt; &gt;::iterator beg=tok.begin(); beg!=tok.end();++beg){<br>       cout &lt;&lt; *beg &lt;&lt; "\n";<br>   }<br>}<br></pre>


  </div>



  
<p align="left">最后，对于某些 TokenizerFunctions 你必须传入一些东西给它的构造函数，来做一些有趣的事情。一个例子是 offset_separator. 这个类基于偏移量来分解字符串，例如：</p>



  
<p align="left">用偏移量 2,2,4 来分解 12252001 将产生 12 25
  2001. 下面就是这个分解的例子。</p>



  
<div align="left">
    
<pre>// simple_example_3.cpp<br>#include&lt;iostream&gt;<br>#include&lt;boost/tokenizer.hpp&gt;<br>#include&lt;string&gt;<br><br>int main(){<br>   using namespace std;<br>   using namespace boost;<br>   string s = "12252001";<br>   int offsets[] = {2,2,4};<br>   offset_separator f(offsets, offsets+3);<br>   tokenizer&lt;offset_separator&gt; tok(s,f);<br>   for(tokenizer&lt;offset_separator&gt;::iterator beg=tok.begin(); beg!=tok.end();++beg){<br>       cout &lt;&lt; *beg &lt;&lt; "\n";<br>   }<br>}<br></pre>


  </div>



  
<p align="left">&nbsp;</p>


  
<hr>

  
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Transitional" border="0" height="31" width="88"></a></p>



  
<p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->25 December, 2006<!--webbot bot="Timestamp" endspan i-checksum="38518" --></p>



  
<p><i>Copyright &copy; 2001 John R. Bandela</i></p>



  
<p><i>Distributed under the Boost Software License, Version 1.0. (See
  accompanying file <a href="../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
  copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>


</body>
</html>

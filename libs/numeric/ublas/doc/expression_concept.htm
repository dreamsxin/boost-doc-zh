<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="ublas.css" type="text/css" />
<title>Expression Concepts</title>
</head>
<body>
<h1><img src="../../../../boost.png" align="middle" />
表达式概念(表达式 Concepts)</h1>
<h2><a name="scalar_expression" id="scalar_expression"></a>标量表达式(Scalar 表达式)</h2>
<h4>说明</h4>
<p>一个标量表达式是一个可以转换为标量的表达式。</p>
<h4>优化(Refinement of)</h4>
<p>缺省构造。</p>
<h4>相关类型</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>公有基类</td>
<td>scaler_expression&lt;S&gt;</td>
<td>S 必须继承自这个公有基类。</td>
</tr>
<tr>
<td>值类型</td>
<td><code>value_type</code></td>
<td>标量表达式的类型。</td>
</tr>
</tbody>
</table>
<h4>记法(Notation)</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>S</code></td>
<td>标量表达式模型的类型</td>
</tr>
</tbody>
</table>
<h4>定义</h4>
<h4>合法表达式(Valid expressions)</h4>
<p>除了在缺省构造中定义的表达式之外，下面的表达式必须是合法的。</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>类型要求</th>
<th>返回值类型</th>
</tr>
<tr>
<td>运算</td>
<td><code>operator value_type () const</code></td>
<td>&nbsp;</td>
<td><code>value_type</code></td>
</tr>
</tbody>
</table>
<h4>表达式语义(表达式 semantics)</h4>
<p>一个表达式的语义仅当没有在缺省构造中定义的时候才得以定义。</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>先决条件</th>
<th>语义</th>
<th>后置条件</th>
</tr>
<tr>
<td>运算</td>
<td><code>operator value_type () const</code></td>
<td>&nbsp;</td>
<td>&nbsp; 计算标量表达式</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>复杂度保证(Complexity guarantees)</h4>
<p>求值的运行时复杂度对于所计算的标量表达式是特定的(specific)。</p>
<h4>不变量(Invariants)</h4>
<h4>模型(Models)</h4>
<ul>
<li><code>vector_scalar_unary</code></li>
<li><code>vector_scalar_binary</code></li>
</ul>
<h2><a name="vector_expression" id="vector_expression"></a>向量表达式(Vector 表达式)</h2>
<h4>描述</h4>
<p>一个向量表达式是一个可以作为向量来计算的表达式。提供一个<a href=
"iterator_concept.htm#indexed_bidirectional_iterator">索引双向迭代器(Indexed Bidirectional
Iterator)</a> 或一个 <a href=
"iterator_concept.htm#indexed_random_access_iterator">索引随机访问迭代器(Indexed Random Access
Iterator)</a> 。</p>
<h4>优化(Refinement of)</h4>
<p>缺省构造</p>
<h4>相关类型</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>公有基类</td>
<td>vector_expression&lt;V&gt;</td>
<td>V 必须从这个公有基类型继承。</td>
</tr>
<tr>
<td>值类型</td>
<td><code>value_type</code></td>
<td>
向量表达式的元素类型。
</td>
</tr>
<tr>
<td>引用类型</td>
<td><code>reference</code></td>
<td>
当访问一个向量表达式的元素时返回值的类型。
<br />
可以转化为<code>value_type</code>类型。
</td>
</tr>
<tr>
<td>常引用类型</td>
<td><code>const_reference</code></td>
<td>
当访问一个常向量表达式(const vector expression)的元素时的返回值类型。
<br />
可以转化为<code>value_type</code>类型。
</td>
</tr>
<tr>
<td>大小类型</td>
<td><code>size_type</code></td>
<td>
向量表达式的索引类型。一个无符号整型用于表示大小和索引值。
<br />
可以表达任何的<code>difference_type</code>类型的非负值。
</td>
</tr>
<tr>
<td>距离类型</td>
<td><code>difference_type</code></td>
<td>
一个有符号整型用于表示两个向量表达式迭代器之间的距离。
</td>
</tr>
<tr>
<td>常迭代器类型</td>
<td><code>const_iterator</code></td>
<td>一种用于检查向量表达式元素的类型。</td>
</tr>
<tr>
<td>迭代器类型</td>
<td><code>iterator</code></td>
<td>一种可以用于修改向量表达式元素的类型。</td>
</tr>
<tr>
<td>常量反向迭代器类型&nbsp;</td>
<td><code>const_reverse_iterator</code></td>
<td>一个反向迭代器适配器(Reverse Iterator adaptor),它的基迭代器类型(base iterator type)是向量表达式的常量迭代器类型。
</td>
</tr>
<tr>
<td>反向迭代器类型</td>
<td><code>reverse_iterator</code></td>
<td>一个反向迭代器适配器(Reverse Iterator adaptor)，它的基迭代器类型(base iterator type)是向量表达式的迭代器类型。</td>
</tr>
</tbody>
</table>
<h4>记法(Notation)</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>V</code></td>
<td>向量表达式模型的类型</td>
</tr>
<tr>
<td><code>v, v1, v2</code></td>
<td><code>V</code>类型的对象</td>
</tr>
<tr>
<td><code>i</code></td>
<td>可以转化为<code>size_type</code>类型的对象</td>
</tr>
<tr>
<td><code>t</code></td>
<td>可以转化为<code>value_type</code>类型的对象</td>
</tr>
</tbody>
</table>
<h4>定义</h4>
<h4>合法表达式(Valid expressions)</h4>
<p>除了在缺省构造中定义的表达式之外，下面的表达式必须是合法的。</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>类型要求</th>
<th>返回值类型</th>
</tr>
<tr>
<td rowspan="2">范围开始</td>
<td><code>v.begin ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator</code></td>
</tr>
<tr>
<td><code>v.begin ()</code></td>
<td><code>v</code>是可改变的(mutable)。</td>
<td><code>iterator</code></td>
</tr>
<tr>
<td rowspan="2">范围终止</td>
<td><code>v.end ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator</code></td>
</tr>
<tr>
<td><code>v.end ()</code></td>
<td><code>v</code>是可改变的(mutable)。</td>
<td><code>iterator</code></td>
</tr>
<tr>
<td>大小</td>
<td><code>v.size ()</code></td>
<td>&nbsp;</td>
<td><code>size_type</code></td>
</tr>
<tr>
<td>交换</td>
<td><code>v1.swap (v2)</code></td>
<td><code>v1</code> 和 <code>v2</code> 是可改变的(mutable)。</td>
<td><code>void</code></td>
</tr>
<tr>
<td rowspan="2">反向范围(reverse range)开始</td>
<td><code>v.rbegin ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator</code></td>
</tr>
<tr>
<td><code>v.rbegin ()</code></td>
<td><code>v</code>是可改变的(mutable)。</td>
<td><code>reverse_iterator</code></td>
</tr>
<tr>
<td rowspan="2">反向范围(reverse range)终止</td>
<td><code>v.rend ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator</code></td>
</tr>
<tr>
<td><code>v.rend ()</code></td>
<td><code>v</code>是可改变的(mutable)。</td>
<td><code>reverse_iterator</code></td>
</tr>
<tr>
<td>元素访问</td>
<td><code>v (i)</code></td>
<td><code>i</code> 可以转化为<code>size_type</code>类型。</td>
<td>可以转化为<code>value_type</code>类型。</td>
</tr>
<tr>
<td rowspan="2">赋值</td>
<td><code>v2 = v1</code></td>
<td><code>v2</code>是可改变的(mutable)且<code>v1</code>可以转化为
<code>V</code>类型。</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2.assign (v1)</code></td>
<td><code>v2</code>是可改变的(mutable)且<code>v1</code>可以转化为
<code>V</code>类型。</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td rowspan="5">运算赋值(Computed assignment)</td>
<td><code>v2 += v1</code></td>
<td><code>v2</code>是可改变的(mutable)且<code>v1</code>可以转化为
<code>V</code>类型。</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2.plus_assign (v1)</code></td>
<td><code>v2</code>是可改变的(mutable)且<code>v1</code>可以转化为
<code>V</code>类型。</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2 -= v1</code></td>
<td><code>v2</code>>是可改变的(mutable)且<code>v1</code>可以转化为
<code>V</code>类型。</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2.minus_assign (v1)</code></td>
<td><code>v2</code>>是可改变的(mutable)且<code>v1</code>可以转化为
<code>V</code>类型。</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v *= t</code></td>
<td><code>v</code>>是可改变的(mutable)且<code>t</code>可以转化为
<code>value_type</code>类型。</td>
<td><code>V &amp;</code></td>
</tr>
</tbody>
</table>
<h4>表达式语义</h4>
<p>一个表达式的语义仅当没有在缺省构造中定义的时候才得以定义。</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>先决条件</th>
<th>语义</th>
<th>后置条件</th>
</tr>
<tr>
<td>范围开始</td>
<td><code>v.begin ()</code></td>
<td>&nbsp;</td>
<td>返回指向向量表达式中的第一个元素的迭代器</td>
<td><code>v.begin ()</code>是可解引用的(dereferenceable)或
past-the-end。 当且公当 <code>v.size () ==
0</code> 时，<code>v.begin()</code>是past-the-end。</td>
</tr>
<tr>
<td>范围终止</td>
<td><code>v.end ()</code></td>
<td>&nbsp;</td>
<td>返回指向向量表达式最后一个元素的下一个位置(one past the last element)的迭代器</td>
<td><code>v.end ()</code> is past-the-end.</td>
</tr>
<tr>
<td>大小</td>
<td><code>v.size ()</code></td>
<td>&nbsp;</td>
<td>返回向量表达式的大小，也就是，它的元素的个数。</td>
<td><code>v.size () &gt;= 0</code></td>
</tr>
<tr>
<td>交换</td>
<td><code>v1.swap (v2)</code></td>
<td>&nbsp;</td>
<td>等价于<code>swap (v1, v2)</code>。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>反向范围(reverse range)开始</td>
<td><code>v.rbegin ()</code></td>
<td>&nbsp;</td>
<td>等价于 <code>reverse_iterator (v.end ())</code>。</td>
<td><code>v.rbegin ()</code> 是可解引用的，或是
past-the-end。当且仅当<code>v.size () ==0</code>时，<code>v.rbegin ()</code>是past-the-end
。</td>
</tr>
<tr>
<td>反向范围(reverse range)终止</td>
<td><code>v.rend ()</code></td>
<td>&nbsp;</td>
<td>等价于<code>reverse_iterator (v.begin ())</code>。</td>
<td><code>v.rend ()</code>是 past-the-end。</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>v (i)</code></td>
<td><code>0 &lt;= i &lt; v.size ()</code></td>
<td>返回向量表达式的第<code>i</code>-th 个元素。
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="2">赋值</td>
<td><code>v2 = v1</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>将向量表达式
<code>v1</code>的每个元素赋给向量表达式<code>v2</code>
的对应元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2.assign (v1)</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>将向量表达式<code>v1</code>的每个元素赋给向量表达式
<code>v2</code>的对应元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="5">运算赋值(Computed assignment)</td>
<td><code>v2 += v1</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>将被求值的向量表达式<code>v1</code>的每一个元素加到向量表达式
<code>v2</code>的对应的元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2.plus_assign (v1)</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>将被求值的向量表达式<code>v1</code>的每一个元素加到向量表达式
<code>v2</code>的对应的元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2 -= v1</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>从向量表达式<code>v2</code>的每个元素中减去被求值的向量表达式<code>v1</code>的对应的元素。
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2.minus_assign (v1)</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>从向量表达式<code>v2</code>的每个元素中减去被求值的向量表达式<code>v1</code>的对应的元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v *= t</code></td>
<td>&nbsp;</td>
<td>将向量表达式<code>v</code>中的每个元素乘以<code>t</code>
。</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>复杂度保证(Complexity guarantees)</h4>
<p>对于被计算的向量表达式，函数<code>begin ()</code> 和 <code>end
()</code> 的运行时复杂度( run-time complexity)是特定的，典型情况是摊还常量时间。</p>
<p>函数<code>size ()</code> 的运行时复杂度(run-time complexity)是常量时间(constant
time)。</p>
<p>对于被计算的向量表达式，函数<code>swap ()</code>的运行时复杂度( run-time complexity)是特定的，典型情况是常量时间。</p>
<p>对于被计算的向量表达式，函数<code>rbegin ()</code> and <code>rend
()</code>的运行时复杂度( run-time complexity)是特定的，典型情况是摊还常量时间。</p>
<p>对于被计算的向量表达式，元素访问的运行时复杂度(run-time complexity)是特定的，典型情况下，对于密集(dense)向量是摊还常量时间(amortized constant time)，对于稀疏(sparse)向量是对数时间(logarithmic)。</p>
<p>对于被计算的向量表达式，算术运算的运行时复杂度(run-time complexity)是特定的，典型情况下， 是关于表达式大小的线性时间。</p>
<h4>不变量(Invariants)</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>合法范围</td>
<td>对于任何的向量表达式<code>v</code>, <code>[v.begin (),
v.end ())</code> 都是合法的范围。</td>
</tr>
<tr>
<td>完整性(Computed assignment)</td>
<td>迭代整个<code>[v.begin (),
v.end ())</code>的算法将会遍历<code>v</code>的每个元素。
</td>
</tr>
<tr>
<td>合法反向范围(valid reverse range)</td>
<td><code>[v.rbegin (), v.rend ())</code>是一个合法的范围。</td>
</tr>
<tr>
<td>等价范围(Equivalence of ranges)</td>
<td>从<code>v.begin ()</code> 到 <code>v.end
()</code>的距离与从<code>v.rbegin ()</code>
到 <code>v.rend ()</code>的距离是一样的。</td>
</tr>
</tbody>
</table>
<h4>模型(Models)</h4>
<ul>
<li><code>vector_range;</code></li>
<li><code>vector_slice</code></li>
<li><code>matrix_row</code></li>
<li><code>matrix_column</code></li>
<li><code>matrix_vector_range</code></li>
<li><code>matrix_vector_slice</code></li>
<li><code>vector_unary</code></li>
<li><code>vector_binary</code></li>
<li><code>vector_binary_scalar1</code></li>
<li><code>vector_binary_scalar2</code></li>
<li><code>matrix_vector_unary1</code></li>
<li><code>matrix_vector_unary2</code></li>
<li><code>matrix_vector_binary1</code></li>
<li><code>matrix_vector_binary2</code></li>
</ul>

<h2><a name="matrix_expression" id="matrix_expression"></a>矩阵表达式</h2>
<h4>描述</h4>
<p> 一个矩阵表达式是一个可以作为矩阵计算的表达式。
矩阵表达式提供一个<a href=
"iterator_concept.htm#indexed_bidirectional_cr_iterator">索引双向列/行迭代器(Indexed
Bidirectional Column/Row Iterator)</a> 或一个<a href=
"iterator_concept.htm#indexed_random_access_cr_iterator">索引随机访问列/行迭代器(Indexed Random
Access Column/Row Iterator)</a> 。 </p>
<h4>优化(Refinement of)</h4>
<p>缺省构造。</p>
<h4>相关类型</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>公有基类</td>
<td>matrix_expression&lt;M&gt;</td>
<td>M 必须从这个公有基类型派生。</td>
</tr>
<tr>
<td>值类型</td>
<td><code>value_type</code></td>
<td>
矩阵表达式的元素类型。
</td>
</tr>
<tr>
<td>引用类型</td>
<td><code>reference</code></td>
<td>
访问矩阵表达式的元素时的返回值的类型。
<br />
可以转化为<code>value_type</code>类型。
</td>
</tr>
<tr>
<td>常引用类型</td>
<td><code>const_reference</code></td>
<td>
访问一个常量矩阵表达式(constant matrix expression)时的返回值类型。
<br />
可以转化为<code>value_type</code>类型。
</td>
</tr>
<tr>
<td>大小类型</td>
<td><code>size_type</code></td>
<td>
向量表达式的索引类型。一个无符号整型用于大小和索引类型。
<br />
可以转化为任何的<code>difference_type</code>类型的非负值。
</td>
</tr>
<tr>
<td>距离类型</td>
<td><code>difference_type</code></td>
<td>
一个有符号的整型用于表示两个矩阵表达式迭代器之间的距离。
</td>
</tr>
<tr>
<td rowspan="2">常量迭代器类型</td>
<td><code>const_iterator1</code></td>
<td>用于检查一个矩阵表达式元素的列向量的类型。</td>
</tr>
<tr>
<td><code>const_iterator2</code></td>
<td>用于检查一个矩阵表达式元素的行向量的类型。</td>
</tr>
<tr>
<td rowspan="2">迭代器类型</td>
<td><code>iterator1</code></td>
<td>可以用于修改一个矩阵表达式元素的列向量的类型。</td>
</tr>
<tr>
<td><code>iterator2</code></td>
<td>可以用于修改一个矩阵表达式元素的行向量的类型。</td>
</tr>
<tr>
<td rowspan="2">常量反向迭代器类型</td>
<td><code>const_reverse_iterator1</code></td>
<td>一个反向迭代器适配器(Reverse Iterator adaptor)，它的基迭代器类型(base iterator type)是矩阵表达式的
常量列向量迭代器类型(const column iterator type)。</td>
</tr>
<tr>
<td><code>const_reverse_iterator2</code></td>
<td>一个反向迭代器适配器(Reverse Iterator adaptor)，它的基迭代器类型(base iterator type)是矩阵表达式的
常量行向量迭代器类型(const column iterator type)。</td>
</tr>
<tr>
<td rowspan="2">反向迭代器类型</td>
<td><code>reverse_iterator1</code></td>
<td>一个反向迭代器适配器(Reverse Iterator adaptor)，它的基迭代器类型(base iterator type)是矩阵表达式的
列向量迭代器类型(const column iterator type)。</td>
</tr>
<tr>
<td><code>reverse_iterator2</code></td>
<td>一个反向迭代器适配器(Reverse Iterator adaptor)，它的基迭代器类型(base iterator type)是矩阵表达式的
行向量迭代器类型(const column iterator type)。</td>
</tr>
</tbody>
</table>
<h4>记法(Notation)</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>M</code></td>
<td>矩阵表达式模型的类型</td>
</tr>
<tr>
<td><code>m, m1, m2</code></td>
<td><code>M</code>类型的对象</td>
</tr>
<tr>
<td><code>i, j</code></td>
<td>可以转化为<code>size_type</code>类型的对象</td>
</tr>
<tr>
<td><code>t</code></td>
<td>可以转化为<code>value_type</code>类型的对象</td>
</tr>
</tbody>
</table>
<h4>定义</h4>
<h4>合法表达式(Valid expressions)</h4>
<p>除了在缺省构造中定义的表达式之外，下面的表达式必须是合法的。</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>类型要求</th>
<th>返回值类型</th>
</tr>
<tr>
<td rowspan="4">范围开始</td>
<td><code>m.begin1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator1</code></td>
</tr>
<tr>
<td><code>m.begin2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator2</code></td>
</tr>
<tr>
<td><code>m.begin1 ()</code></td>
<td><code>m</code>是可改变的。&nbsp;</td>
<td><code>iterator1</code></td>
</tr>
<tr>
<td><code>m.begin2 ()</code></td>
<td><code>m</code>是可改变的。</td>
<td><code>iterator2</code></td>
</tr>
<tr>
<td rowspan="4">范围终止</td>
<td><code>m.end1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator1</code></td>
</tr>
<tr>
<td><code>m.end2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator2</code></td>
</tr>
<tr>
<td><code>m.end1 ()</code></td>
<td><code>m</code>是可改变的。&nbsp;</td>
<td><code>iterator1</code></td>
</tr>
<tr>
<td><code>m.end2 ()</code></td>
<td><code>m</code>是可改变的。</td>
<td><code>iterator2</code></td>
</tr>
<tr>
<td rowspan="2">大小</td>
<td><code>m.size1 ()</code></td>
<td>&nbsp;</td>
<td><code>size_type</code></td>
</tr>
<tr>
<td><code>m.size2 ()</code></td>
<td>&nbsp;</td>
<td><code>size_type</code></td>
</tr>
<tr>
<td>交换</td>
<td><code>m1.swap (m2)</code></td>
<td><code>m1</code> and <code>m2</code> are mutable.&nbsp;</td>
<td><code>void</code></td>
</tr>
<tr>
<td rowspan="4">反向范围(reverse range)开始</td>
<td><code>m.rbegin1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rbegin2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator2</code></td>
</tr>
<tr>
<td><code>m.rbegin1 ()</code></td>
<td><code>m</code>是可改变的。&nbsp;</td>
<td><code>reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rbegin2 ()</code></td>
<td><code>m</code>是可改变的。</td>
<td><code>reverse_iterator2</code></td>
</tr>
<tr>
<td rowspan="4">反向范围(reverse range)终止</td>
<td><code>m.rend1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rend2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator2</code></td>
</tr>
<tr>
<td><code>m.rend1 ()</code></td>
<td><code>m</code>是可改变的。</td>
<td><code>reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rend2 ()</code></td>
<td><code>m</code>是可改变的。</td>
<td><code>reverse_iterator2</code></td>
</tr>
<tr>
<td>元素访问</td>
<td><code>m (i, j)</code></td>
<td><code>i</code>且<code>j</code>可以转化为
<code>size_type</code>类型。</td>
<td>可以转化为<code>value_type</code>类型。</td>
</tr>
<tr>
<td rowspan="2">赋值</td>
<td><code>m2 = m1</code></td>
<td><code>m2</code>是可改变的(mutable)且<code>m1</code>可以转化为
<code>M</code>类型。</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2.assign (m1)</code></td>
<td><code>m2</code>是可改变的(mutable)且<code>m1</code>可以转化为
<code>M</code>类型。</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td rowspan="5">运算赋值(Computed assignment)</td>
<td><code>m2 += m1</code></td>
<td><code>m2</code>是可改变的(mutable)且<code>m1</code>可以转化为
<code>M</code>类型。</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2.plus_assign (m1)</code></td>
<td><code>m2</code>是可改变的(mutable)且<code>m1</code>可以转化为
<code>M</code>类型。</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2 -= m1</code></td>
<td><code>m2</code> is mutable and <code>m1</code>可以转化为
<code>M</code>类型。</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2.minus_assign (m1)</code></td>
<td><code>m2</code>是可改变的(mutable)且<code>m1</code>可以转化为
<code>M</code>类型。</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m *= t</code></td>
<td><code>m</code>是可改变的(mutable)且<code>t</code>可以转化为
<code>value_type</code>类型。</td>
<td><code>M &amp;</code></td>
</tr>
</tbody>
</table>
<h4>表达式语义(表达式 semantics)</h4>
<p>一个表达式的语义仅当没有在缺省构造中定义的时候才得以定义。</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>先决条件</th>
<th>语义</th>
<th>后置条件</th>
</tr>
<tr>
<td rowspan="2">范围开始</td>
<td><code>m.begin1 ()</code></td>
<td>&nbsp;</td>
<td>返回指向矩阵表达式的第一列的第一个元素的迭代器
。</td>
<td><code>m.begin1 ()</code>是可解引用的(dereferenceable)或
past-the-end。当且仅当 <code>m.size1 () ==past-the-end if and only if <code>m.size1 () == 0</code>时，
<code>m.begin1 ()</code>是past-the-end。</td>
</tr>
<tr>
<td><code>m.begin2 ()</code></td>
<td>&nbsp;</td>
<td>返回指向矩阵表达式的第一列的第一个元素的迭代器
。</td>
<td><code>m.begin2 ()</code>是可解引用的(dereferenceable)或
past-the-end。当且仅当 <code>m.size2 () == 0</code>时，
<code>m.begin2 ()</code>是past-the-end。</td>
</tr>
<tr>
<td rowspan="2">范围终止</td>
<td><code>m.end1 ()</code></td>
<td>&nbsp;</td>
<td>返回指向矩阵表达式的最后一个元素之外的一个元素(one past the last element)的迭代器。
</td>
<td><code>m.end1 ()</code>是 past-the-end。</td>
</tr>
<tr>
<td><code>m.end2 ()</code></td>
<td>&nbsp;</td>
<td>返回指向矩阵表达式的最后一个元素之外的一个元素(one past the last element)的迭代器。
</td>
<td><code>m.end2 ()</code>是 past-the-end。</td>
</tr>
<tr>
<td rowspan="2">大小</td>
<td><code>m.size1 ()</code></td>
<td>&nbsp;</td>
<td>返回向量表达式的行数。</td>
<td><code>m.size1 () &gt;= 0</code></td>
</tr>
<tr>
<td><code>m.size2 ()</code></td>
<td>&nbsp;</td>
<td>返回矩阵表达式的列数。</td>
<td><code>m.size2 () &gt;= 0</code></td>
</tr>
<tr>
<td>交换</td>
<td><code>m1.swap (m2)</code></td>
<td>&nbsp;</td>
<td>等价于<code>swap (m1, m2)</code>。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="2">反向范围(reverse range)开始</td>
<td><code>m.rbegin1 ()</code></td>
<td>&nbsp;</td>
<td>等价于<code>reverse_iterator1 (m.end1 ())</code>。</td>
<td><code>m.rbegin1 ()</code>是可解引用的(dereferenceable)或
past-the-end。当且仅当<code>m.size1 () == 0</code>时，<code>m.rbegin1 ()</code>是past-the-end。
</td>
</tr>
<tr>
<td><code>m.rbegin2 ()</code></td>
<td>&nbsp;</td>
<td>等价于<code>reverse_iterator2 (m.end2 ())</code>。</td>
<td><code>m.rbegin2 ()</code>是可解引用的(dereferenceable)或
past-the-end。当且仅当<code>m.size2 () == 0</code>时，<code>m.rbegin2 ()</code>是past-the-end。</td>
</tr>
<tr>
<td rowspan="2">反向范围(reverse range)终止</td>
<td><code>m.rend1 ()</code></td>
<td>&nbsp;</td>
<td>等价于<code>reverse_iterator1 (m.begin1
())</code>。</td>
<td><code>m.rend1 ()</code>是 past-the-end。</td>
</tr>
<tr>
<td><code>m.rend2 ()</code></td>
<td>&nbsp;</td>
<td>等价于<code>reverse_iterator2 (m.begin2
())</code>。</td>
<td><code>m.rend2 ()</code>是 past-the-end。</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>m (i, j)</code></td>
<td><code>0 &lt;= i &lt; m.size1 ()</code> 且 <code>0 &lt;= j &lt;
m.size2 ()</code></td>
<td>返回矩阵表达式中第 <code>i</code>-th行第<code>j</code>-th
个元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="2">赋值</td>
<td><code>m2 = m1</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> 且 <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>将被求值的矩阵表达式<code>m1</code>中的每一个元素赋给
矩阵表达式 <code>m2</code>中的对应的元素。
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2.assign (m1)</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> 且 <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>被求值的矩阵表达式<code>m1</code>中的每一个元素赋给
矩阵表达式 <code>m2</code>中的对应的元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="5">运算赋值(Computed assignment)</td>
<td><code>m2 += m1</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> 且 <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>被求值的矩阵表达式<code>m1</code>中的每一个元素加到
矩阵表达式 <code>m2</code>中的对应的元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2.plus_assign (m1)</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> 且 <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>被求值的矩阵表达式<code>m1</code>中的每一个元素加到
矩阵表达式 <code>m2</code>中的对应的元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2 -= m1</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> 且 <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>从矩阵表达式
<code>m2</code>中的每个元素中减去矩阵表达式<code>m1</code>
中的对应元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2.minus_assign (m1)</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> 且 <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>从矩阵表达式
<code>m2</code>中的每个元素中减去矩阵表达式<code>m1</code>
中的对应元素。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m *= t</code></td>
<td>&nbsp;</td>
<td>将矩阵表达式<code>m</code>中的每个元素乘以<code>t</code>
。</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>复杂度保证(Complexity guarantees)</h4>
<p>对于被计算的矩阵表达式，函数<code>begin1 ()</code>, <code>begin2
()</code> , <code>end1 ()</code> 和 <code>end2 ()</code> 的运行时复杂度( run-time complexity)是特定的。</p>
<p>对于被计算的矩阵表达式，函数<code>size1 ()</code> and <code>size2
()</code> 的运行时复杂度( run-time complexity)是常量。</p>
<p>对于被计算的矩阵表达式，函数<code>swap ()</code> 的运行时复杂度( run-time complexity)是特定的，典型情况是常量时间。</p>
<p>对于被计算的矩阵表达式，函数<code>rbegin1 ()</code>,
<code>rbegin2 ()</code> , <code>rend1 ()</code> 和 <code>rend2
()</code>  的运行时复杂度( run-time complexity)是特定的。</p>
<p>对于被计算的矩阵表达式，元素访问的运行时复杂度(run-time complexity)是特定的，典型情况下，对于密集(dense)矩阵是摊还常量时间(amortized constant time)，对于稀疏(sparse)矩阵是对数时间(logarithmic)。</p>
<p>对于被计算的向量表达式，算术运算的运行时复杂度(run-time complexity)是特定的，典型情况下， 是关于代理(proxies)大小的平方时间。</p>
<h4>不变量(Invariants)</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>合法范围</td>
<td>对于任何的矩阵类型<code>m</code>, <code>[m.begin1 (),
m.end1 ())</code> 和 <code>[m.begin2 (), m.end2 ())</code> 都是合法的区间。</td>
</tr>
<tr>
<td>完整性(Computed assignment)</td>
<td>一个迭代整个<code>[m.begin1
(), m.end1 ())</code>区间的算法将会遍历<code>m</code>的每一行
, 一个迭代整个<code>[m.begin2 (),
m.end2 ())</code>区间的元将会遍历整个<code>m</code>的每一行。
</td>
</tr>
<tr>
<td>合法反向范围(valid reverse range)</td>
<td><code>[m.rbegin1 (), m.rend1 ())</code> 和 <code>[m.rbegin2
(), m.rend2 ())</code> 都是合法范围。</td>
</tr>
<tr>
<td>等价范围(Equivalence of ranges)</td>
<td>从<code>m.begin1 ()</code> 到 <code>m.end1
()</code> 的距离与从<code>m.rbegin1
()</code> 到 <code>m.rend1 ()</code>的距离是一样的，且从
<code>m.begin2 ()</code> 到 <code>m.end2 ()</code>的距离与
从<code>m.rbegin2 ()</code> 到 <code>m.rend2
()</code>的距离是一样的。</td>
</tr>
</tbody>
</table>
<h4>模型(Models)</h4>
<ul>
<li><code>matrix_range</code></li>
<li><code>matrix_slice;</code></li>
<li><code>triangular_adaptor</code></li>
<li><code>symmetric_adaptor</code></li>
<li><code>banded_adaptor</code></li>
<li><code>vector_matrix_binary</code></li>
<li><code>matrix_unary1</code></li>
<li><code>matrix_unary2</code></li>
<li><code>matrix_binary</code></li>
<li><code>matrix_binary_scalar1</code></li>
<li><code>matrix_binary_scalar2</code></li>
<li><code>matrix_matrix_binary</code></li>
</ul>
<hr />
<p>Copyright (&copy;) 2000-2002 Joerg Walter, Mathias Koch<br />
   Use, modification and distribution are subject to the
   Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt
   or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
      http://www.boost.org/LICENSE_1_0.txt
   </a>).
</p>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1st March 2004), see www.w3.org" />
<meta http-equiv="Content-Type" content=
"text/html; charset=UTF-8" />
<link href="ublas.css" type="text/css" />
<title>Sparse Storage</title>
</head>
<body>
<h1><img src="../../../../boost.png" align="middle" />
稀疏存储(Sparse Storage)</h1>
<h2><a name="map_std" id="map_std"></a>缺省为标准映射(Default Standard Map)</h2>
<h4>说明</h4>
<p>模板类<code>map_std&lt;I, T, ALLOC&gt;</code> 提供对标准库中的关联容器<code>std::map</code>的一个包装(wrapper)。这个包含(wrapper)有一个简单的目的。当声明稀疏容器类型的时候，它允许定义一个缺省的模板参数。</p>
<h4>例子</h4>
<pre>
#include &lt;boost/numeric/ublas/storage_sparse.hpp&gt;

int main () {
    using namespace boost::numeric::ublas;
    map_std&lt;int, double&gt; a (3);
    for (unsigned i = 0; i &lt; a.size (); ++ i) {
        a [i] = i;
        std::cout &lt;&lt; a [i] &lt;&lt; std::endl;
    }
}
</pre>
<h4>定义</h4>
<p>定义在头文件 storage_sparse.hpp 中。 </p>
<h4>模板参数</h4>
<table border="1" summary="parameters">
<tbody>
<tr>
<th>参数</th>
<th>说明</th>
<th>缺省值</th>
</tr>
<tr>
<td><code>I</code></td>
<td>存储在数组中的索引的类型。</td>
<td></td>
</tr>
<tr>
<td><code>T</code></td>
<td>存储在数组中的对象类型。</td>
<td></td>
</tr>
<tr>
<td><code>ALLOC</code></td>
<td>一个 STL 分配器(Allocator)。</td>
<td>std::allocator</td>
</tr>
</tbody>
</table>
<h4>模型(Model of)</h4>
<p>可反转的容器(Reversible Container)。</p>
<h4>类型要求(Type requirements)</h4>
<p>没有，除了由可反转的容器(Reversible Container)所施加的类型要求。</p>
<h4>公有基类(Public base classes)</h4>
<p>std::map</p>
<h2><a name="map_array" id="map_array"></a>映射数组(Map Array)</h2>
<h4>说明</h4>
<p>模板类<code>map_array&lt;I, T, ALLOC&gt;</code> 实现一个类似于关联容器<code>std::map</code> 的排序数组。因此，一些关联容器接口不具有与std::map相同的语义。
<p>在任何时候<code>map_array</code>都有一个新的元素可以插入的容量(capacity)。如果函数<code>insert</code> 将会导致<code>map_array</code> 的大小超出它的容量( capactity )，那么它将会被<strong>重新分配(reallocated)</strong>。迭代器和引用都将是无效的(invalidated)。可以使用成员函数<code>reserve</code> 来直接控制容器的容量(capacite)。</p>
<h4>例子</h4>
<pre>
#include &lt;boost/numeric/ublas/storage_sparse.hpp&gt;

int main () {
    using namespace boost::numeric::ublas;
    map_array&lt;int, double&gt; a (3);
    for (unsigned i = 0; i &lt; a.size (); ++ i) {
        a [i] = i;
        std::cout &lt;&lt; a [i] &lt;&lt; std::endl;
    }
}
</pre>
<h4>定义</h4>
<p>定义在头文件 storage_sparse.hpp 中。</p>
<h4>模板参数</h4>
<table border="1" summary="parameters">
<tbody>
<tr>
<th>参数</th>
<th>说明</th>
<th>缺省值</th>
</tr>
<tr>
<td><code>I</code></td>
<td>存储在数组中的索引类型。</td>
<td></td>
</tr>
<tr>
<td><code>T</code></td>
<td>存储在数组中的对象类型。</td>
<td></td>
</tr>
<tr>
<td><code>ALLOC</code></td>
<td>一个STL分配器(Allocator)。</td>
<td>std::allocator</td>
</tr>
</tbody>
</table>
<h4>模型(Model of)</h4>
<p>可反转的容器(Reversible Container)。</p>
<h4>类型要求(Type requirements)</h4>
<p>没有，除了由可反转的容器(Reversible Container)所施加的类型要求。</p>
<h4>公有基类(Public base classes)</h4>
<p>None.</p>
<h4>成员</h4>
<table border="1" summary="members">
<tbody>
<tr>
<th>成员</th>
<th>说明</th>
</tr>
<tr>
<td><code>map_array (ALLOC &amp;a = ALLOC())</code></td>
<td>分配一个包含0个元素的 <code>map_array</code>。</td>
</tr>
<tr>
<td><code>map_array (const map_array &amp;c)</code></td>
<td>拷贝构造函数。</td>
</tr>
<tr>
<td><code>~map_array ()</code></td>
<td>析构<code>map_array</code>本身。</td>
</tr>
<tr>
<td><code>void reserve (size_type capacity)</code></td>
<td>
改变<code>map_array</code>的容量(capacity)。它可以包含最多<code>capacity</code>个元素而不需要重新分配内存空间。
可以减小容量(capacity)使得 <code>capacity >= size()</code>。<code>map_array</code>中的元素将会被保留。</td>
</tr>
<tr>
<td><code>size_type size () const</code></td>
<td>返回 <code>map_array</code> 的大小。</td>
</tr>
<tr>
<td><code>size_type size () const</code></td>
<td>返回 <code>map_array</code> 的容量。</td>
</tr>
<tr>
<td><code>data_reference operator [] (index_type i)</code></td>
<td>返回与一个特定的索引下关联的元素的引用。
如果 <code>map_array</code> 没有包含这样一个元素。<code>operator[]</code> 插入缺省的元素<code>T ()</code>。</td>
</tr>
<tr>
<td><code>map_array &amp;operator = (const map_array
&amp;a)</code></td>
<td>赋值运算符。</td>
</tr>
<tr>
<td><code>map_array &amp;assign_temporary (map_array
&amp;a)</code></td>
<td>赋值给一个临时变量。可能会改变数组 <code>a</code> 。</td>
</tr>
<tr>
<td><code>void swap (map_array &amp;a)</code></td>
<td>交换数组的内容。</td>
</tr>
<tr>
<td><code>std::pair&lt;iterator, bool&gt; insert (const value_type
&amp;p)</code></td>
<td>将 <code>p</code> 插入到数组中。如果<code>p</code>被插入到数组中，那么返回值的第二部分为 <code>true</code>。
如果<code>p</code>已经在数组中而没有被插入到数组中，那么返回值的第二部分为 <code>false</code>。</td>
</tr>
<tr>
<td><code>iterator insert (iterator it, const value_type
&amp;p)</code></td>
<td>将 <code>p</code> 插入到数组中，使用 <code>it</code> <code>p</code>所
插入的位置的提示(hint)。</td>
</tr>
<tr>
<td><code>void erase (iterator it)</code></td>
<td>删除在 <code>it</code> 处的元素。</td>
</tr>
<tr>
<td><code>void clear ()</code></td>
<td>清除数组。</td>
</tr>
<tr>
<td><code>const_iterator find (index_type i) const</code></td>
<td>查找索引为 <code>i</code> 的元素。</td>
</tr>
<tr>
<td><code>iterator find (index_type i)</code></td>
<td>查找索引为 <code>i</code> 的元素。</td>
</tr>
<tr>
<td><code>const_iterator lower_bound (index_type i)
const</code></td>
<td>查找索引不小于
<code>i</code> 的第一个元素。</td>
</tr>
<tr>
<td><code>iterator lower_bound (index_type i)</code></td>
<td>查找索引不小于
<code>i</code> 的第一个元素。</td>
</tr>
<tr>
<td><code>const_iterator upper_bound (index_type i)
const</code></td>
<td>查找索引大于
<code>i</code> 的第一个元素。</td>
</tr>
<tr>
<td><code>iterator upper_bound (index_type i)</code></td>
<td>查找索引大于
<code>i</code> 的第一个元素。</td>
</tr>
<tr>
<td><code>const_iterator begin () const</code></td>
<td>返回指向<code>map_array</code>开始处的<code>const_iterator</code>。</td>
</tr>
<tr>
<td><code>const_iterator end () const</code></td>
<td>返回指向<code>map_array</code>终止处的<code>const_iterator</code>。</td>
</tr>
<tr>
<td><code>iterator begin ()</code></td>
<td>返回指向<code>map_array</code>开始处的<code>iterator</code>。</td>
</tr>
<tr>
<td><code>iterator end ()</code></td>
<td>返回指向<code>map_array</code>终止处的<code>iterator</code>。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rbegin () const</code></td>
<td>返回指向反转的(reversed)<code>map_array</code>开始处的 <code>const_reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rend () const</code></td>
<td>返回指向反转的(reversed)<code>map_array</code>终止处的<code>const_reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>reverse_iterator rbegin ()</code></td>
<td>返回指向反转的(reversed)<code>map_array</code>开始处的 <code>reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>reverse_iterator rend ()</code></td>
<td>返回指向反转的(reversed)<code>map_array</code>终止处的 <code>reverse_iterator</code> 。</td>
</tr>
</tbody>
</table>
<hr />
<p>Copyright (&copy;) 2000-2002 Joerg Walter, Mathias Koch<br />
   Use, modification and distribution are subject to the
   Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt
   or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
      http://www.boost.org/LICENSE_1_0.txt
   </a>).
</p>
</body>
</html>

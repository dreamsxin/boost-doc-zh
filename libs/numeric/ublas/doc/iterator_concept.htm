<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1st March 2004), see www.w3.org" />
<meta http-equiv="Content-Type" content=
"text/html; charset=UTF-8" />
<link href="ublas.css" type="text/css" />
<title>Iterator Concepts</title>
</head>
<body>
<h1><img src="../../../../boost.png" align="middle" />
迭代器概念(Iterator Concepts)</h1>
<p>一个迭代器是一个指向一个向量或一个矩阵的受限制的(restricted)类似于指向的对象。</p>
<h2><a name="indexed_bidirectional_iterator" id=
"indexed_bidirectional_iterator"></a>索引双向迭代器(Indexed Bidirectional Iterator)</h2>
<h4>说明</h4>
<p>一个索引双向迭代器是一个容器的迭代器，可以解引用(dereferenced)，递增(incremented)，递减(decremented)并携带索引信息。</p>
<h4>优化(Refinement of)</h4>
<p>赋值，相等比较，缺省构造。</p>
<h4>相关类型(Associated types)</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>值类型(Value type)</td>
<td>解引用一个索引双向迭代器(Indexed Bidirectional Iterator)所获取的值类型。</td>
</tr>
<tr>
<td>容器类型(Container type)</td>
<td>索引双向迭代器(Indexed Bidirectional Iterator)所指向的容器的类型。</td>
</tr>
</tbody>
</table>
<h4>记法(Notation)</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>I</code></td>
<td>索引双向迭代器(Indexed Bidirectional Iterator)模型的类型。</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>I</code>的值类型。</td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>I</code>的容器类型。</td>
</tr>
<tr>
<td><code>it</code>, <code>itt, it1</code>, <code>it2</code></td>
<td><code>I</code>类型的对象。</td>
</tr>
<tr>
<td><code>t</code></td>
<td><code>T</code>类型的对象。</td>
</tr>
<tr>
<td><code>c</code></td>
<td><code>C</code>类型的对象。</td>
</tr>
</tbody>
</table>
<h4>定义</h4>
<p>一个索引双向迭代器(Indexed Bidirectional Iterator) 可能是<i>可变的(mutable)</i>，意味着被这种迭代器类型所指向的对象的值是可以修改的; 或者是<i>常量(constant</i>) ， 意味着它们不可以被修改。如果一个迭代器类型是可变的(mutable)，这暗含着它的值类型是可赋值模型(
model of Assignable); 反之，就不一定必然是真的。</p>
<p>一个索引双向迭代器(Indexed Bidirectional Iterator) 可以有一个<i>单一(singular)</i>
值，意味着大多数运算的结果，包括相等比较，是未定义的(undefined)。所保证的唯一的操作是将一个非单一(nonsingular)赋值给一个单一迭代器(singular)。</p>
<p>一个索引双向迭代器(Indexed Bidirectional Iterator)可能有<i>可解用的(dereferenceable) </i>值，意味差解引用这种迭代器可以产生一个定义良好的(well-defined)值。可解引用的迭代器永远都是非单一的(nonsingular)，但是反之(非可解引用的迭代器)就不是真的</p>
<p>如果一个索引双向迭代器(Indexed Bidirectional Iterator)指向超出容器最后一个元素的位置，那么 个迭代器是<i>past-the-end</i> 。 Past-the-end 值是非单一的(nonsingular)和非可解引用的(nondereferenceable)。</p>
<h4>合法表达式(Valid expressions)</h4>
<p>除了为赋值，相等比较和缺省构造所定义的表达式之外，下面的表达式也应当是合法的。</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>类型要求(Type requirements)</th>
<th>返回值类型(Return type)</th>
</tr>
<tr>
<td>缺省构造函数</td>
<td><code>I it</code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>解引用(Dereference)</td>
<td><code>*it</code></td>
<td>&nbsp;</td>
<td>可以转化为<code>T</code>类型。</td>
</tr>
<tr>
<td>解引用赋值(Dereference assignment)</td>
<td><code>*it = t</code></td>
<td><code>I</code>是可变化的(mutable)。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>成员访问(Member access)</td>
<td><code>it-&gt;m</code></td>
<td><code>T</code> 定义<code>t.m</code>所使用的类型。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>前递增(Preincrement)</td>
<td><code>++ it</code></td>
<td>&nbsp;</td>
<td><code>I &amp;</code></td>
</tr>
<tr>
<td>后递增(Postincrement)</td>
<td><code>it ++</code></td>
<td>&nbsp;</td>
<td><code>I</code></td>
</tr>
<tr>
<td>前递减(Predecrement)</td>
<td><code>-- it</code></td>
<td>&nbsp;</td>
<td><code>I &amp;</code></td>
</tr>
<tr>
<td>后递减(Postdecrement)</td>
<td><code>it --</code></td>
<td>&nbsp;</td>
<td><code>I</code></td>
</tr>
<tr>
<td>索引(Index)</td>
<td><code>it.index ()</code></td>
<td>&nbsp;</td>
<td><code>C::size_type</code></td>
</tr>
</tbody>
</table>
<h4>表达式语义(Expression Semantics)</h4>
<p>仅当一个表达式的语义不同于或没有定义在赋值，相等比较和缺省构造之中时才得以定义。</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>名称</th>
<th>表达式</th>
<th>先决条件(Precondition)</th>
<th>语义(Semantics)</th>
<th>后置条件(Postcondition)</th>
</tr>
<tr>
<td>缺省构造函数</td>
<td><code>I it</code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><code>it</code>是单一的(singular)。</td>
</tr>
<tr>
<td>解引用(Dereference)</td>
<td><code>*it</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>解引用赋值(Dereference assignment)</td>
<td><code>*it = t</code></td>
<td>Same as for <code>*it</code>.</td>
<td>&nbsp;</td>
<td><code>*it</code>是t的拷贝。</td>
</tr>
<tr>
<td>成员访问(Member access)</td>
<td><code>it-&gt;m</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。</td>
<td>等价于<code>(*it).m</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>前递增(Preincrement)</td>
<td><code>++ it</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。</td>
<td><code>it</code>被修改为指向下一个元素。</td>
<td><code>it</code>是可解引用的(dereferenceable)或past-the-end。
<code><br />
&amp;it == &amp;++ it</code>.<br />
If <code>it1 == it2</code>,<br />
then <code>++ it1 == ++ it2</code>.</td>
</tr>
<tr>
<td>后递增(Postincrement)</td>
<td><code>it ++</code></td>
<td>类似于<code>++ it</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I itt = it;<br />
&nbsp;++ it;<br />
&nbsp;返回 itt;<br />
}</code></td>
<td><code>it</code>是可解引用的(dereferenceable)或past-the-end。</td>
</tr>
<tr>
<td>前递减(Predecrement)</td>
<td><code>-- it</code></td>
<td><code>it</code>是可解引用的(dereferenceable)或past-the-end。<br />
存在一个可解引用的(dereferenceable)的迭代器<code>itt</code>使得
<code>it == ++ itt</code>。</td>
<td><code>it</code> 被修改为指向前一个元素。</td>
<td><code>it</code> 是可解引用的。<br />
<code>&amp;it = &amp;-- it</code>。<br />
如果 <code>it1 == it2</code>,<br />
那么 <code>-- it1 == -- it2</code>。<br />
如果 <code>it2</code> 是可解引用的(dereferenceable)且 <code>it1 ==
++it2</code>,<br />
那么 <code>--it1 == it2</code>。</td>
</tr>
<tr>
<td>后递减(Postdecrement)</td>
<td><code>it --</code></td>
<td>类似于 -- <code>it</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I itt = it;<br />
&nbsp;-- it;<br />
&nbsp;返回 itt;<br />
}</code></td>
<td><code>it</code> 是可解引用的(dereferenceable)。&nbsp;</td>
</tr>
<tr>
<td>索引(Index)</td>
<td><code>it.index ()</code></td>
<td><code>it</code> 是可解引用的(dereferenceable)。</td>
<td><code>it.index () &gt;= 0</code><br />
且<br />
<code>it.index () &lt; it ().size ()</code></td>
<td>如果 <code>it1 == it2</code>,<br />
那么 <code>it1.index () == it2.index ()</code>。<br />
如果 <code>it1 == it2</code>,<br />
那么 <code>it1.index () &lt; (++ it2).index
()</code>.<br />
如果 <code>it1 == it2</code>,<br />
那么 <code>it1.index () &gt; (-- it2).index
()</code>。</td>
</tr>
</tbody>
</table>
<h4>复杂度保证(Complexity guarantees)</h4>
<p>索引双向迭代器操作的复杂度保证是摊还常量时间(amortized constant time)。</p>
<h4>不变量(Invariants)</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>相等(Identity)</td>
<td><code>it1 == it2</code>当且仅当 <code>&amp;*it1 ==
&amp;*it2</code>。</td>
</tr>
<tr>
<td>递增递减对称(Symmetry of increment and decrement)</td>
<td>如果 <code>it</code> 是可解引用的(dereferenceable), 那么 <code>++ it;
--it;</code> 是一个空操作(null operation)。类似地，<code>-- it; ++
it;</code>是一个空操作(null operation)。</td>
</tr>
<tr>
<td>迭代器索引和容器元素运算符之间的关系(Relation between iterator index and container element
operator)</td>
<td>如果 <code>it</code> 是可解引用的(dereferenceable), 那么<code>*it == it ()
(it.index ())</code>。</td>
</tr>
</tbody>
</table>
<h4>模型(Models)</h4>
<ul>
<li><code>sparse_vector::iterator</code></li>
</ul>
<h2><a name="indexed_random_access_iterator" id=
"indexed_random_access_iterator"></a>索引随机访问迭代器(Indexed Random Access Iterator)</h2>
<h4>说明</h4>
<p>索引随机访问迭代器(Indexed Random Access Iterator)是一个容器的迭代器，它可以解引用(dereferenced)，向前移动，向后移动并携带索引信息。</p>
<h4>优化(Refinement of)</h4>
<p>小于比较(LessThanComparable)，<a href=
"#indexed_bidirectional_iterator">随机双向迭代器(Indexed Bidirectional
Iterator)</a> 。 </p>
<h4>相关类型(Associated types)</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>Value type</td>
<td>解引用一个索引随机访问迭代器(Indexed Random Access Iterator)所获取的值的类型。</td>
</tr>
<tr>
<td>Container type</td>
<td>索引随机访问迭代器(Indexed Random Access Iterator)所指向的指向的容器的类型。</td>
</tr>
</tbody>
</table>
<h4>记法(Notation)</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>I</code></td>
<td>索引随机访问迭代器(Indexed Random Access Iterator)类型的对象</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>I</code>类型值</td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>I</code>类型容器</td>
</tr>
<tr>
<td><code>it</code>, <code>itt, it1</code>, <code>it2</code></td>
<td><code>I</code>类型对象</td>
</tr>
<tr>
<td><code>t</code></td>
<td><code>T</code>类型对象</td>
</tr>
<tr>
<td><code>n</code></td>
<td><code>C::difference_type</code>类型对象</td>
</tr>
</tbody>
</table>
<h4>定义</h4>
<p>如果将递增运算符<code>++</code> 应用于迭代器<code>it2</code>有限次之后，<code>it1 == it2</code>，那么一个索引随机访问迭代器(Indexed Random Access Iterator) <code>it1</code> 是从一个索引随机访问迭代器<code>it2</code><i>可达的(reachable)</i> 。</p>
<h4>合法表达式(Valid expressions)</h4>
<p>除了为<a href=
"#indexed_bidirectional_iterator">索引双向迭代器(Indexed Bidirectional
Iterator)</a>所定义的表达式是合法的之外，下面的表达式也应当是合法的。</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>名称(Name)</th>
<th>表达式(Expression)</th>
<th>类型要求(Type requirements)</th>
<th>返回 类型(Return type)</th>
</tr>
<tr>
<td>向前移动(Forward motion)</td>
<td><code>it += n</code></td>
<td>&nbsp;</td>
<td><code>I &amp;</code></td>
</tr>
<tr>
<td>迭代器加法(Iterator addition)</td>
<td><code>it + n</code></td>
<td>&nbsp;</td>
<td><code>I</code></td>
</tr>
<tr>
<td>向后移动(Backward motion)</td>
<td><code>i -= n</code></td>
<td>&nbsp;</td>
<td><code>I &amp;</code></td>
</tr>
<tr>
<td>迭代器减法(Iterator subtraction)</td>
<td><code>it - n</code></td>
<td>&nbsp;</td>
<td><code>I</code>&nbsp;</td>
</tr>
<tr>
<td>差值(Difference)</td>
<td><code>it1 - it2</code></td>
<td>&nbsp;</td>
<td><code>C::difference_type</code></td>
</tr>
<tr>
<td>元素操作符(Element operator)</td>
<td><code>it [n]</code></td>
<td>&nbsp;</td>
<td>可以转化为<code>T</code>类型。</td>
</tr>
<tr>
<td>元素赋值(Element assignment)</td>
<td><code>it [n] = t</code></td>
<td><code>I</code> is mutable</td>
<td>可以转化为<code>T</code>类型。</td>
</tr>
</tbody>
</table>
<h4>表达式语义(Expression Semantics)</h4>
<p>仅当一个表达式不同于或没有定义在<a href=
"#indexed_bidirectional_iterator">索引双向迭代器(Indexed Bidirectional
Iterator)</a>中之时，这个表达式的语义才得以定义。 </p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>名称(Name)</th>
<th>表达式(Expression)</th>
<th>先决条件(Precondition)</th>
<th>语义(Semantics)</th>
<th>后置条件(Postcondition)</th>
</tr>
<tr>
<td>向前移动(Forward motion)</td>
<td><code>it += n</code></td>
<td>包括 <code>it</code> 本身，依赖于<code>n</code>是下数或是负数，在<code>it</code>之后或之前必须有<code>n</code>个可解引用的
(dereferenceable)或past-the-end 迭代器。</td>
<td>如果 <code>n &gt; 0</code>, 等价于执行<code>++
it</code> <code>n</code> 次。如果<code>n &lt; 0</code>,
等价于执行 <code>-- it</code> <code>n</code> 次。如果
<code>n == 0</code>, 那么这就是一个空操作(null operation)。</td>
<td><code>it</code>是可解引用的(dereferenceable)或past-the-end。</td>
</tr>
<tr>
<td>迭代器加法(Iterator addition)</td>
<td><code>it + n</code></td>
<td>类似于<code>i += n</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I itt = it;<br />
&nbsp;return itt += n;<br />
}</code></td>
<td>结果是可解引用的(dereferenceable)或past-the-end。</td>
</tr>
<tr>
<td>向后移动(Backward motion)</td>
<td><code>it -= n</code></td>
<td>包括<code>it</code>本身, 依赖于 <code>n</code>是正数或是负数，在<code>it</code>
之前或之后必须有<code>n</code>个可解引用的(dereferenceable) 或 past-the-end 迭代器。</td>
<td>等价于 <code>it += (-n)</code>。</td>
<td><code>it</code> 是可解引用的(dereferenceable)或 past-the-end。</td>
</tr>
<tr>
<td>迭代器减法(Iterator subtraction)</td>
<td><code>it - n</code></td>
<td>类似于 <code>i -= n</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I itt = it;<br />
&nbsp;return itt -= n;<br />
}</code></td>
<td>结果是可解引用的(dereferenceable)或 past-the-end。</td>
</tr>
<tr>
<td>差值(Difference)</td>
<td><code>it1 - it2</code></td>
<td><code>it1</code>从<code>it2</code>是可达的(reachable)或
<code>it2</code>从<code>it1</code>是可达的(reachable)，或者两者都是彼此可达的(reachable)。</td>
<td>返回数字<code>n</code>使得<code>it1 == it2 +
n</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>元素操作符(Element operator)</td>
<td><code>it [n]</code></td>
<td><code>it + n</code> 存在且是可解引用的(dereferenceable)。</td>
<td>等价于 <code>*(it + n)</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>元素赋值(Element assignment)</td>
<td><code>i[n] = t</code></td>
<td>类似于 <code>it [n]</code>。</td>
<td>等价于<code>*(it + n) = t</code></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>复杂度保证(Complexity guarantees)</h4>
<p>索引随机访问迭代器的操作的复杂度保证为摊还常量时间(amortized constant time)。</p>
<h4>不变量(Invariants)</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>加法和减法的对称(Symmetry of addition and subtraction)</td>
<td>如果 <code>it + n</code>是定义良好的(well-defined), 那么 <code>it += n; it
-= n;</code> 且 <code>(it + n) - n</code> 是空操作(null operations)。
类似地, 如果 <code>it - n</code> 是良定义的(well-defined), 那么<code>it -=
n; it += n;</code> 且 <code>(it - n) + n</code>是空操作(null
operations)。</td>
</tr>
<tr>
<td>距离和加法之间的关系</td>
<td>如果 <code>it1 - it2</code> 是定义良好的(well-defined), 那么 <code>it1 ==
it2 + (it1 - it2)</code>。</td>
</tr>
<tr>
<td>可达性和距离(Reachability and distance)</td>
<td>如果 <code>it1</code> 是从<code>it2</code>可达的(reachable)，那么
<code>it1 - it2 &gt;= 0</code>。</td>
</tr>
</tbody>
</table>
<h4>模型(Models)</h4>
<ul>
<li><code>vector::iterator</code></li>
</ul>
<h2><a name="indexed_bidirectional_cr_iterator" id=
"indexed_bidirectional_cr_iterator"></a>索引双向列/行迭代器(Indexed Bidirectional Column/Row Iterator)</h2>
<h4>说明</h4>
<p>一个容器的索引双向列/行迭代器(Indexed Bidirectional Column/Row Iterator)是可解引用的(dereferneced)，递增(incremented)，递减(decremented)并携带索引信息。</p>
<h4>优化(Refinement of)</h4>
<p>赋值，相等比较，缺省构造。</p>
<h4>相关类型(Associated types)</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>值类型(Value type)</td>
<td>解引用一个索引双向列/行迭代器(Indexed Bidirectional Column/Row Iterator)所获取的值的类型。</td>
</tr>
<tr>
<td>容器类型(Container type)</td>
<td>一个索引双向列/行迭代器(Indexed Bidirectional Column/Row Iterator)所指向的容器的类型。</td>
</tr>
</tbody>
</table>
<h4>记法(Notation)</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>I1</code></td>
<td>一个索引双向列/行迭代器(Indexed Bidirectional Column/Row Iterator)
模型的类型。</td>
</tr>
<tr>
<td><code>I2</code></td>
<td>一个索引双向列/行迭代器(Indexed Bidirectional Column/Row Iterator)
模型的类型。</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>I1</code> 和 <code>I2</code>的值类型。</td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>I1</code> 和 <code>I2</code>的容器类型。</td>
</tr>
<tr>
<td><code>it1</code>, <code>it1t, it11</code>,
<code>it12</code></td>
<td><code>I1</code>类型的对象。</td>
</tr>
<tr>
<td><code>it2</code>, <code>it2t</code></td>
<td><code>I2</code>类型的对象。</td>
</tr>
<tr>
<td><code>t</code></td>
<td><code>T</code>类型的对象</td>
</tr>
<tr>
<td><code>c</code></td>
<td><code>C</code>类型的对象。</td>
</tr>
</tbody>
</table>
<h4>定义</h4>
<h4>合法表达式(Valid expressions)</h4>
<p>除了为赋值，相等比较和缺省构造所定义的表达式之外，下面的表达式也应当是合法的。</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>名称(Name)</th>
<th>表达式(Expression)</th>
<th>类型要求(Type requirements)</th>
<th>返回类型(Return type)</th>
</tr>
<tr>
<td>缺省构造函数</td>
<td><code>I1 it</code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>解引用(Dereference)</td>
<td><code>*it</code></td>
<td>&nbsp;</td>
<td>可以转化为<code>T</code>类型。</td>
</tr>
<tr>
<td>解引用赋值(Dereference assignment)</td>
<td><code>*it = t</code></td>
<td><code>I1</code> 是可变的(mutable)。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>成员访问</td>
<td><code>it-&gt;m</code></td>
<td><code>T</code>是定义<code>t.m</code>的类型。
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>前递增(Preincrement)</td>
<td><code>++ it</code></td>
<td>&nbsp;</td>
<td><code>I1 &amp;</code></td>
</tr>
<tr>
<td>后递增(Postincrement)</td>
<td><code>it ++</code></td>
<td>&nbsp;</td>
<td><code>I1</code></td>
</tr>
<tr>
<td>前递减(Predecrement)</td>
<td><code>-- it</code></td>
<td>&nbsp;</td>
<td><code>I1 &amp;</code></td>
</tr>
<tr>
<td>后递减(Postdecrement)</td>
<td><code>it --</code></td>
<td>&nbsp;</td>
<td><code>I1</code></td>
</tr>
<tr>
<td>行索引(Row Index)</td>
<td><code>it.index1 ()</code></td>
<td>&nbsp;</td>
<td><code>C::size_type</code></td>
</tr>
<tr>
<td>列索引(Column Index)</td>
<td><code>it.index2 ()</code></td>
<td>&nbsp;</td>
<td><code>C::size_type</code></td>
</tr>
<tr>
<td>行/列开始位置(Row/Column Begin)</td>
<td><code>it.begin ()</code></td>
<td>&nbsp;</td>
<td><code>I2</code></td>
</tr>
<tr>
<td>行/列结束位置(Row/Column End)</td>
<td><code>it.end ()</code></td>
<td>&nbsp;</td>
<td><code>I2</code></td>
</tr>
<tr>
<td>反向行/列开始位置(Reverse Row/Column Begin)</td>
<td><code>it.rbegin ()</code></td>
<td>&nbsp;</td>
<td><code>reverse_iterator&lt;I2&gt;</code></td>
</tr>
<tr>
<td>反向行/列终止位置(Reverse Row/Column End)</td>
<td><code>it.rend ()</code></td>
<td>&nbsp;</td>
<td><code>reverse_iterator&lt;I2&gt;</code></td>
</tr>
</tbody>
</table>
<h4>表达式语义(Expression Semantics)</h4>
<p>仅当一个表达式的语义不同于或没有定义在赋值，相等比较和缺省构造之中时才得以定义。</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>名称(Name)</th>
<th>表达式(Expression)</th>
<th>先决条件(Precondition)</th>
<th>语义(Semantics)</th>
<th>后置条件(Postcondition)</th>
</tr>
<tr>
<td>缺省构造函数</td>
<td><code>I1 it</code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><code>it</code>是单一的(singular)。</td>
</tr>
<tr>
<td>解引用(Dereference)</td>
<td><code>*it</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>解引用赋值(Dereference assignment)</td>
<td><code>*it = t</code></td>
<td>类似于<code>*it</code>。</td>
<td>&nbsp;</td>
<td><code>*it</code>是t的拷贝。</td>
</tr>
<tr>
<td>成员访问(Member Access)</td>
<td><code>it-&gt;m</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。</td>
<td>等价于<code>(*it).m</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>前递增(Preincrement)</td>
<td><code>++ it</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。</td>
<td><code>it</code>被修改为指向下一列/行。
例如，对于列迭代器满足<br />
<code>it.index1 () &lt; (++ it).index1 ()</code> 且<br />
<code>it.index2 () == (++ it).index2 ()</code>,<br />
对于行迭代器满足<br />
<code>it.index1 () == (++ it).index1 ()</code> 且<br />
<code>it.index2 () &lt; (++ it).index2 ()</code>。<br /></td>
<td><code>it</code> 是可解引用的(dereferenceable)或past-the-end。
<code><br />
&amp;it == &amp;++ it</code>.<br />
如果 <code>it1 == it2</code>,<br />
那么 <code>++ it1 == ++ it2</code>。</td>
</tr>
<tr>
<td>后递增(Postincrement)</td>
<td><code>it ++</code></td>
<td>类似于<code>++ it</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I1 itt = it;<br />
&nbsp;++ it;<br />
&nbsp;return itt;<br />
}</code></td>
<td><code>it</code> 是可解引用的(dereferenceable)或 past-the-end。</td>
</tr>
<tr>
<td>前递减(Predecrement)</td>
<td><code>-- it</code></td>
<td><code>it</code> 是可解引用的(dereferenceable)或past-the-end。<br />
存在一个解引用(dereferenceable)迭代器<code>itt</code>满足
<code>it == ++ itt</code>。</td>
<td><code>it</code> 修改为指向前行或列的前一个元素,
例如，对于列迭代器满足<br />
<code>it.index1 () &gt; (-- it).index1 ()</code> 且<br />
<code>it.index2 () == (-- it).index2 ()</code>,<br />
对于行迭代器满足<br />
<code>it.index1 () == (-- it).index1 ()</code> 且<br />
<code>it.index2 () &gt; (-- it).index2 ()</code>。</td>
<td><code>it</code>是可解引用的(dereferenceable)。<br />
<code>&amp;it = &amp;-- it</code>。<br />
如果 <code>it1 == it2</code>,<br />
那么 <code>-- it1 == -- it2</code>。</td>
</tr>
<tr>
<td>后递减(Postdecrement)</td>
<td><code>it --</code></td>
<td>类似于 -- <code>it</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I1 itt = it;<br />
&nbsp;-- it;<br />
&nbsp;return itt;<br />
}</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。&nbsp;</td>
</tr>
<tr>
<td>行索引(Row Index)</td>
<td><code>it.index1 ()</code></td>
<td>如果 <code>it</code> 是一个行迭代器，那么<code>it</code>必须是可解引用的(dereferenceable)。</td>
<td><code>it.index1 () &gt;= 0</code> 且<br />
<code>it.index1 () &lt; it () .size1 ()</code></td>
<td>如果 <code>it1 == it2</code>,<br />
那么 <code>it1.index1 () == 12.index1 ()</code>。<br />
如果 <code>it1</code>, <code>it2</code> 行迭代器且<code>it1 == it2</code>,<br />
那么 <code>it1.index1 () &lt; (++ it2</code>).<code>index1 ()</code>。<br />
且 <code>it1.index1 () &gt; (-- it2</code>)<code>index1 ()</code>。</td>
</tr>
<tr>
<td>列迭代器(Column Index)</td>
<td><code>it.index2 ()</code></td>
<td>如果<code>it</code>是一个列迭代器，那么<code>it</code>必须是可解引用的(dereferenceable)。</td>
<td><code>it.index2 () &gt;= 0</code> 且<br />
<code>it.index2 () &lt; it () .size2 ()</code></td>
<td>如果 <code>it1 == it2</code>,<br />
那么 <code>it1.index2 () == it2</code>.<code>index2 ()</code>
。<br />
如果 <code>it1</code>, <code>it2</code> 是列迭代器且<code>it1 == i12</code>,<br />
那么 <code>it1.index2 () &lt; (++ it2</code>).<code>index2 ()</code>.<br />
且<code>it1.index2 () &gt; (-- it2</code>).<code>index2 ()</code>。</td>
</tr>
<tr>
<td>行/列开始位置(Row/Column Begin)</td>
<td><code>it.begin ()</code></td>
<td><code>it</code> 是可解引用的(dereferenceable)。</td>
<td>如果 <code>it</code> 是一个列迭代器，那么<br />
<code>it2 = it.begin ()</code> 是一个行迭代器<br />
且 <code>it2.index1 () == it.index1 ()</code>。
<p>如果 <code>it</code> 是一个行迭代器，<br />
那么 <code>it2 = it.begin ()</code> 是一个列迭代器<br />
且 <code>it2.index2 () == it.index2 ()</code>。</p>
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>行/列终止位置(Row/Column End)</td>
<td><code>it.end ()</code></td>
<td><code>it</code> 是可解引用的(dereferenceable)。</td>
<td>如果 <code>it</code>是一个列迭代器，<br />
那么<code>it2 = it.end ()</code>是一个行迭代器<br />
且 <code>it2.index1 () == it.index1 ()</code>。
<p>如果 <code>it</code> 是一个行迭代器，<br />
那么 <code>it2 = it.end ()</code> 是一个列迭代器<br />
且 <code>it2.index2 () == it.index2 ()</code>。</p>
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>反向行/列开始位置(Reverse Row/Column Begin)</td>
<td><code>it.rbegin ()</code></td>
<td><code>it</code> 是可解引用的(dereferenceable)。</td>
<td>等价于 <code>reverse_iterator&lt;I2&gt; (it.end
())</code>。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>反向行/列结束位置(Reverse Row/Column End)</td>
<td><code>it.rend ()</code></td>
<td><code>it</code>是可解引用的(dereferenceable)。</td>
<td>等价于 <code>reverse_iterator&lt;I2&gt; (it.begin
())</code>。</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>复杂度保证(Complexity guarantees)</h4>
<p>索引随机访问迭代器的操作的复杂度保证为依赖于容器大小的对数时间。一个迭代器的复杂度(依赖于存储布局)可以被提升为摊还常量时间(amortized constant time)。分别对于第一行和第一列，另一个迭代器的复杂度(依赖于容器的存储布局)可以被提升为摊还常量时间。</p>
<h4>不变量(Invariants)</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>相等(Identity)</td>
<td><code>it1 == it2</code> 当且仅当<code>&amp;*it1 ==
&amp;*it2</code>。</td>
</tr>
<tr>
<td>递增和递减的对称性(Symmetry of increment and decrement)</td>
<td>如果<code>it</code> 是可解引用的(dereferenceable), 那么<code>++ it;
--it;</code>是一个空操作(null operation)。类似地<code>-- it; ++
it;</code>是一个空操作(null operation)。</td>
</tr>
<tr>
<td>迭代器索引与容器元素操作符之间的关系
</td>
<td>如果 <code>it</code> 是可解引用的(dereferenceable), 那么<code>*it == it ()
(it.index1 (), it.index2 ())</code>。</td>
</tr>
<tr>
<td>迭代器行/列开始位置与迭代器索引之间的关系
</td>
<td>如果<code>it</code>是一个列迭代器
且 <code>it2 = it.begin ()</code>，那么对于所有的<code>it2t</code> 且 <code>it2t ()
== it2 ()</code> 以及 <code>it2t ().index1 () == it2 ().index1
()</code>，<code>it2.index2 () &lt;
it2t.index2 ()</code>
<p>如果 <code>it</code> 是一个行迭代器且
<code>it2 = it.end ()</code> ，那么对于所有的<code>it2t</code> 且 <code>it2t ()
== it2 ()</code> 以及 <code>it2t ().index2 () == it2 ().index2
()</code>，<code>it2.index1 () &gt;
it2t.index1 ()</code>。
</p>
</td>
</tr>
<tr>
<td>迭代器行/列终止位置与迭代器索引之间的关系</td>
<td>如果 <code>it</code> 是一个列迭代器
且 <code>it2 = it.end ()</code> ，那么对于所有的<code>it2t</code> 且 <code>it2t ()
== it2 ()</code> 以及 <code>it2t ().index1 () == it2 ().index1
()</code>， <code>it2.index2 () &gt;
it2t.index2 ()</code>。
<p>如果 <code>it</code> 是一个和列迭代器且
<code>it2 = it.end ()</code> ，那么对于所有的<code>it2t</code> 且 <code>it2t ()
== it2 ()</code> 以及 <code>it2t ().index2 () == it2 ().index2
()</code>，<code>it2.index1 () &gt;
it2t.index1 ()</code>。</p>
</td>
</tr>
</tbody>
</table>
<h4>模型(Models)</h4>
<ul>
<li><code>sparse_matrix::iterator1</code></li>
<li><code>sparse_matrix::iterator2</code></li>
</ul>
<h2><a name="indexed_random_access_cr_iterator" id=
"indexed_random_access_cr_iterator"></a>索引随机访问列/行迭代器(Indexed Random Access Column/Row Iterator)</h2>
<h4>说明</h4>
<p>一个容器的索引随机列/行迭代器(Indexed Random Column/Row Iterator)是可解引用的(dereferneced)，递增(incremented)，递减(decremented)并携带索引信息。</p>
<h4>优化(Refinement of)</h4>
<p><a href="#indexed_bidirectional_cr_iterator">索引双向列/行迭代器(Indexed
Bidirectional Column/Row Iterator)</a> 。 </p>
<h4>相关类型(Associated types)</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>值类型(Value type)</td>
<td>解引用(dereference)索引随机访问列/行迭代器所获取的值的类型
</td>
</tr>
<tr>
<td>容器类型(Container type)</td>
<td>一个索引随机列/行迭代器(Indexed Random Column/Row Iterator)所指向的容器的类型。</td>
</tr>
</tbody>
</table>
<h4>记法(Notation)</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>I</code></td>
<td>一个索引随机列/行迭代器(Indexed Random Column/Row Iterator)模型的类型。</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>I</code>的值类型。</td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>I</code>的容器在类型。</td>
</tr>
<tr>
<td><code>it</code>, <code>itt, it1</code>, <code>it2</code></td>
<td><code>I</code>类型的对象。</td>
</tr>
<tr>
<td><code>t</code></td>
<td><code>T</code>类型的对象。</td>
</tr>
<tr>
<td><code>c</code></td>
<td><code>C</code>类型的对象。</td>
</tr>
</tbody>
</table>
<h4>定义</h4>
<h4>合法表达式(Valid expressions)</h4>
<p>除了为<a href=
"#indexed_bidirectional_cr_iterator">索引双向列/行迭代器(Indexed Bidirectional
Column/Row Iterator)</a> 所定义的表达式之外，下面的表达式也应当是合法的。</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>名称(Name)</th>
<th>表达式(Expression)</th>
<th>类型要求(Type requirements)</th>
<th>返回类型(Return type)</th>
</tr>
<tr>
<td>向前移动(Forward motion)</td>
<td><code>it += n</code></td>
<td>&nbsp;</td>
<td><code>I &amp;</code></td>
</tr>
<tr>
<td>迭代器加法(Iterator addition)</td>
<td><code>it + n</code></td>
<td>&nbsp;</td>
<td><code>I</code></td>
</tr>
<tr>
<td>向后移动(Backward motion)</td>
<td><code>i -= n</code></td>
<td>&nbsp;</td>
<td><code>I &amp;</code></td>
</tr>
<tr>
<td>迭代器减法(Iterator subtraction)</td>
<td><code>it - n</code></td>
<td>&nbsp;</td>
<td><code>I</code>&nbsp;</td>
</tr>
<tr>
<td>差值(Difference)</td>
<td><code>it1 - it2</code></td>
<td>&nbsp;</td>
<td><code>C::difference_type</code></td>
</tr>
<tr>
<td>元素操作符(Element operator)</td>
<td><code>it [n]</code></td>
<td>&nbsp;</td>
<td><code>T</code>.</td>
</tr>
<tr>
<td>元素赋值(Element assignment)</td>
<td><code>it [n] = t</code></td>
<td><code>I</code> 是可变的(mutable)</td>
<td>可以转换为<code>T</code>类型。</td>
</tr>
</tbody>
</table>
<h4>表达式语义(Expression Semantics)</h4>
<p>仅当一个表达式的语义不同于或没有定义在<a href=
"#indexed_bidirectional_cr_iterator">索引双向列/行迭代器(Indexed Bidirectional
Column/Row Iterator)</a> 器中之时才得到定义。 </p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>名称(Name)</th>
<th>表达式(Expression)</th>
<th>先决条件(Precondition)</th>
<th>语义(Semantics)</th>
<th>后置条件(Postcondition)</th>
</tr>
<tr>
<td>前向移动(Forward motion)</td>
<td><code>it += n</code></td>
<td>包括<code>it</code>本身, 在<code>it</code>后面或前面必须有<code>n</code>
个可解引用的(dereferenceable)或past-the-end迭代器
, 依赖于<code>n</code> 是正数或负数。</td>
<td>如果 <code>n &gt; 0</code>, 等价于执行 <code>++
it</code> <code>n</code> 次。如果 <code>n &lt; 0</code>,
等价于执行 <code>-- it</code> <code>n</code> 次。如果
<code>n == 0</code>, 那么这是一个空操作(null operation)。</td>
<td><code>it</code> 是可解引用的(dereferenceable)或past-the-end。</td>
</tr>
<tr>
<td>迭代器加法(Iterator addition)</td>
<td><code>it + n</code></td>
<td>类似于 <code>i += n</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I itt = it;<br />
&nbsp;return itt += n;<br />
}</code></td>
<td>结果是可解引用的(dereferenceable)或past-the-end。</td>
</tr>
<tr>
<td>向后移动(Backward motion)</td>
<td><code>it -= n</code></td>
<td>包括 <code>it</code> 本身，在 <code>it</code>本身之前或之后必须有<code>n</code>个
可解引用的(dereferenceable)或past-the-end迭代器, 依赖于 <code>n</code>是正数或是负数
。</td>
<td>等价于<code>it += (-n)</code>。</td>
<td><code>it</code>是可解引用的(dereferenceable)或past-the-end。</td>
</tr>
<tr>
<td>迭代器减法(Iterator subtraction)</td>
<td><code>it - n</code></td>
<td>类似于 <code>i -= n</code>。</td>
<td>等价于<br />
<code>{<br />
&nbsp;I itt = it;<br />
&nbsp;return itt -= n;<br />
}</code></td>
<td>结果是可解引用的(dereferenceable) 或 past-the-end。</td>
</tr>
<tr>
<td>差值(Difference)</td>
<td><code>it1 - it2</code></td>
<td><code>it1</code>是从<code>it2</code>可达的(reachable)或
<code>it2</code> 是从<code>it1</code>可达的(reachable), 或者两者彼此是可达的。</td>
<td>返回一个数值<code>n</code>使得<code>it1 == it2 +
n</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>元素操作符(Element operator)</td>
<td><code>it [n]</code></td>
<td><code>it + n</code> 存在且是可解引用的(dereferenceable)。</td>
<td>等价于<code>*(it + n)</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>元素赋值(Element assignment)</td>
<td><code>i[n] = t</code></td>
<td>类似于 <code>it [n]</code>。</td>
<td>等价于 <code>*(it + n) = t</code></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>复杂度保证(Complexity guarantees)</h4>
<p>索引随机访问列/行迭代器操作的复杂度保证为摊还常量时间(amortized constant time)。</p>
<h4>不变量(Invariants)</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>加法和减法的对称性(Symmetry of addition and subtraction)</td>
<td>如果 <code>it + n</code> 是定义良好的(well-defined), 那么<code>it += n; it
-= n;</code> 以及 <code>(it + n) - n</code>是空操作(null operations)。
类似地，如果 <code>it - n</code>是定义良好的(well-defined), 那么<code>it -=
n; it += n;</code> 且 <code>(it - n) + n</code>是空操作(null
operations)。</td>
</tr>
<tr>
<td>距离和加法之间的关系(Relation between distance and addition)</td>
<td>如果<code>it1 - it2</code>是定义良好的(well-defined)，那么<code>it1 ==
it2 + (it1 - it2)</code>。</td>
</tr>
<tr>
<td>可达性与距离(Reachability and distance)</td>
<td>如果<code>it1</code>是从<code>it2</code>可达的(reachable), 那么
<code>it1 - it2 &gt;= 0</code>。</td>
</tr>
</tbody>
</table>
<h4>模型(Models)</h4>
<ul>
<li><code>matrix::iterator1</code></li>
<li><code>matrix::iterator2</code></li>
</ul>
<hr />
<p>Copyright (&copy;) 2000-2002 Joerg Walter, Mathias Koch<br />
   Use, modification and distribution are subject to the
   Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt
   or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
      http://www.boost.org/LICENSE_1_0.txt
   </a>).
</p>
</body>
</html>

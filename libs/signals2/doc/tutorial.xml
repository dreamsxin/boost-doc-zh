<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<!--
Copyright Douglas Gregor 2001-2004
Copyright Frank Mori Hess 2007-2009

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->
<section last-revision="$Date: 2007-06-12 14:01:23 -0400 (Tue, 12 Jun 2007) $" id="signals2.tutorial">
  <title>Tutorial 教程</title>

  <using-namespace name="boost"/>
  <using-namespace name="boost::signals2"/>
  <using-class name="boost::signals2::signalN"/>
  <using-class name="boost::signals2::slotN"/>

  <section>
    <title>How to Read this Tutorial 如何阅读本教程</title>
<para>This tutorial is not meant to be read linearly. Its top-level
structure roughly separates different concepts in the library
(e.g., handling calling multiple slots, passing values to and from
slots) and in each of these concepts the basic ideas are presented
first and then more complex uses of the library are described
later. Each of the sections is marked <emphasis>Beginner</emphasis>,
<emphasis>Intermediate</emphasis>, or <emphasis>Advanced</emphasis> to help guide the
reader. The <emphasis>Beginner</emphasis> sections include information that all
library users should know; one can make good use of the Signals2
library after having read only the <emphasis>Beginner</emphasis> sections. The
<emphasis>Intermediate</emphasis> sections build on the <emphasis>Beginner</emphasis>
sections with slightly more complex uses of the library. Finally,
the <emphasis>Advanced</emphasis> sections detail very advanced uses of the
Signals2 library, that often require a solid working knowledge of
the <emphasis>Beginner</emphasis> and <emphasis>Intermediate</emphasis> topics; most users
will not need to read the <emphasis>Advanced</emphasis> sections.<sbr/>
本教程不是用来线性阅读的。其顶层结构大致按库中不同的概念划分，（如处理多个插槽的调用、传值到插槽及回传），
并且在每一个概念中，首先介绍其基本思想，然后说明库较复杂的使用。每个部分都标注了<emphasis>初级</emphasis>、
<emphasis>中级</emphasis>，或<emphasis>高级</emphasis>，以帮助指导读者。<emphasis>初级</emphasis>
部分包括库的所有使用者都该了解的信息；只要阅读了<emphasis>初级</emphasis>部分，就可以很好地使用 Signals2 库。
<emphasis>中级</emphasis>部分建立在<emphasis>初级</emphasis> 部分之上，是库的稍复杂的使用。
最后，<emphasis>高级</emphasis>部分详述了 Signals2 库很高级的应用，这往往需要对<emphasis>初级</emphasis>
和<emphasis>中级</emphasis>内容扎实的实践经验；大多数用户无需阅读<emphasis>高级</emphasis>部分。</para>
</section>

<section><title>Compatibility Note 对兼容性的注释</title>

<para>Boost.Signals2 has two syntactical forms: the preferred form and
the compatibility form. The preferred form fits more closely with the
C++ language and reduces the number of separate template parameters
that need to be considered, often improving readability; however, the
preferred form is not supported on all platforms due to compiler
bugs. Users of Boost.Function, please note
that the preferred syntactic form in Signals2 is equivalent to that of
Function's preferred syntactic form.<sbr/>
Boost.Signals2 有两种句法形式：首选形式和兼容形式。首选形式能更紧密地适合C++语言，
并减少需要考虑的独立模板参数的个数，往往能提高可读性；然而，由于编译器的错误，
首选形式并非所有平台都支持。Boost.Function 的用户请注意，Signals2 中的首选句法形式等效于 Function 的首选句法形式</para>

</section>

<section><title>Hello, World! (Beginner 初级)</title>
<para>The following example writes "Hello, World!" using signals and
slots. First, we create a signal <code>sig</code>, a signal that
takes no arguments and has a void return value. Next, we connect
the <code>hello</code> function object to the signal using the
<code>connect</code> method. Finally, use the signal
<code>sig</code> like a function to call the slots, which in turns
invokes <code>HelloWorld::operator()</code> to print "Hello,
World!".<sbr/>
下例将使用信号和插槽写出“Hello, World!”。首先，我们创建信号 <code>sig</code>，
该信号无参数并且返回值为空。接着，我们使用 <code>connect</code> 方法将 <code>hello</code> 函数对象连接到信号。 
最后，像函数一样使用信号 <code>sig</code> 来调用插槽，它将转而调用 <code>HelloWorld::operator()</code> 
打印 “Hello, World!”。 </para>
<programlisting><xi:include href="hello_world_def_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting><xi:include href="hello_world_single_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
</entry>
<entry>
<programlisting>  // Signal with no arguments and a void return value
  boost::signals2::signal0&lt;void&gt; sig;

  // Connect a HelloWorld slot
  HelloWorld hello;
  sig.connect(hello);

  // Call all of the slots
  sig();
</programlisting>
</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
</section>

<section><title>Calling Multiple Slots 调用多个插槽</title>
<section><title>Connecting Multiple Slots (Beginner) 连接多个插槽（初级）</title>
<para>Calling a single slot from a signal isn't very interesting, so
we can make the Hello, World program more interesting by splitting
the work of printing "Hello, World!" into two completely separate
slots. The first slot will print "Hello" and may look like
this:<sbr/>
从信号调用单个插槽不是很有意思，因此我们将打印“Hello, World!”的工作拆分到两个完全独立的插槽，
让 Hello, World 程序更有趣点。第一个插槽将打印“Hello”，可能看起来像这样：</para>
<programlisting><xi:include href="hello_def_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<para>The second slot will print ", World!" and a newline, to complete
the program. The second slot may look like this:<sbr/>
第二个插槽将打印“, World!”和换行，以完成该程序。第二个插槽可能看起来像这样：</para>
<programlisting><xi:include href="world_def_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<para>Like in our previous example, we can create a signal
<code>sig</code> that takes no arguments and has a
<code>void</code> return value. This time, we connect both a
<code>hello</code> and a <code>world</code> slot to the same
signal, and when we call the signal both slots will be called.<sbr/>
和上个例子一样，我们创建信号 <code>sig</code>，它没有参数并且返回值为 <code>void</code>。
这次，我们将 <code>hello</code> 和 <code>world</code> 插槽都连接到同一个信号，
当我们调用该信号，两个插槽都将会被调用。</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting><xi:include href="hello_world_multi_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
          </entry>
          <entry>
<programlisting>  boost::signals2::signal0&lt;void&gt; sig;

  sig.connect(Hello());
  sig.connect(World());

  sig();
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
<para>By default, slots are pushed onto the back of the slot list,
so the output of this program will be as expected:<sbr/>
默认情况下，插槽会被加到插槽链表的尾部，因此该程序的输出应该是：</para>
<programlisting>
Hello, World!
</programlisting>
</section>

<section><title>Ordering Slot Call Groups (Intermediate) 插槽调用组排序（中级）</title>
<para>Slots are free to have side effects, and that can mean that some
slots will have to be called before others even if they are not connected in that order. The Boost.Signals2
library allows slots to be placed into groups that are ordered in
some way. For our Hello, World program, we want "Hello" to be
printed before ", World!", so we put "Hello" into a group that must
be executed before the group that ", World!" is in. To do this, we
can supply an extra parameter at the beginning of the
<code>connect</code> call that specifies the group. Group values
are, by default, <code>int</code>s, and are ordered by the integer
&lt; relation. Here's how we construct Hello, World:<sbr/>
插槽可以有副作用，这意味着某些插槽必须在另一些之前调用，即使它们不是按那个次序连接的。 
Boost.Signals2 库允许插槽进行分组，并按某种方式排序编组。对于我们的 Hello, World 程序，
我们要“Hello”在“, World!”之前打印，所以我们将“Hello”放入一个组，该组将在“, World!”所在组之前执行。 
为了做到这一点，我们可以在 <code>connect</code> 调用的头部提供一个额外的参数，以指定编组。 
编组值默认为 <code>int</code>，并按整型的 &lt; 关系排序。我们这样构造 Hello, World：</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting><xi:include href="hello_world_ordered_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
</entry>
            <entry>
<programlisting>  boost::signals2::signal0&lt;void&gt; sig;

  sig.connect(1, World());  // connect with group 1
  sig.connect(0, Hello());  // connect with group 0</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>Invoking the signal will correctly print "Hello, World!", because the
<code>Hello</code> object is in group 0, which precedes group 1 where
the <code>World</code> object resides. The group
parameter is, in fact, optional. We omitted it in the first Hello,
World example because it was unnecessary when all of the slots are
independent. So what happens if we mix calls to connect that use the
group parameter and those that don't? The "unnamed" slots (i.e., those
that have been connected without specifying a group name) can be
placed at the front or back of the slot list (by passing
<code>boost::signals2::at_front</code> or <code>boost::signals2::at_back</code>
as the last parameter to <code><methodname
alt="boost::signals2::signalN::connect">connect</methodname></code>, respectively),
and default to the end of the list. When
a group is specified, the final <code>at_front</code> or <code>at_back</code>
parameter describes where the slot
will be placed within the group ordering.  Ungrouped slots connected with
<code>at_front</code> will always precede all grouped slots.  Ungrouped
slots connected with <code>at_back</code> will always succeed all
grouped slots.<sbr/>
调用该信号将正确打印出“Hello, World!”，因为 <code>Hello</code> 对象在组 0，它在 <code>World</code> 对象所在的组 1 之前。 
编组参数实际上是可选的。在第一个 Hello World 例子中我们省略了它，因为当所有的插槽都独立时，编组是不必要的。 
那么，如果我们混合调用使用和不使用编组参数的连接会怎样？“未命名”插槽（即那些连接时未指定组名的插槽）
可置于插槽链表的头部或尾部（通过向 <code><methodname alt="boost::signals2::signalN::connect">connect</methodname></code> 
分别传入 <code>boost::signals2::at_front</code> 或 <code>boost::signals2::at_back</code> 作为最后的参数），
而默认为链表的结尾。当指定了编组时，最后的参数 <code>at_front</code> 或 <code>at_back</code> 描述的是插槽在组内的次序。 
以 <code>at_front</code> 连接的未分组的插槽将总是在所有分组的插槽之前。
以 <code>at_back</code> 连接的未分组的插槽将总是在所有分组的插槽之后。</para>
<para>
  If we add a new slot to our example like this:<sbr/>
  如果在我们的例子中添加新的插槽，如下：
</para>
<programlisting><xi:include href="good_morning_def_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<programlisting><xi:include href="hello_world_ordered_invoke_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<para>... we will get the result we wanted:<sbr/>
... 我们会得到想要的结果：</para>
<programlisting>
Hello, World!
... and good morning!
</programlisting>
</section>
</section>

<section><title>Passing Values to and from Slots 传值到插槽及回传</title>
<section><title>Slot Arguments (Beginner) 插槽的参数（初级）</title>
<para>Signals can propagate arguments to each of the slots they call.
For instance, a signal that propagates mouse motion events might
want to pass along the new mouse coordinates and whether the mouse
buttons are pressed.<sbr/>
信号可以向它们调用的每个插槽传递参数。例如，
一个传递鼠标移动事件的信号可能要传入新的鼠标坐标以及是否按了鼠标键。</para>
<para>As an example, we'll create a signal that passes two
<code>float</code> arguments to its slots. Then we'll create a few
slots that print the results of various arithmetic operations on
these values.<sbr/>
例如，我们创建一个信号，它将传入两个 float 参数到它的插槽。 
然后我们再创建几个插槽，打印对这两个参数进行算术运算的各种结果。</para>
<programlisting><xi:include href="slot_arguments_slot_defs_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting><xi:include href="slot_arguments_main_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
</entry>
<entry>
<programlisting>  boost::signals2::signal2&lt;void, float, float&gt; sig;

  sig.connect(&amp;print_args);
  sig.connect(&amp;print_sum);
  sig.connect(&amp;print_product);
  sig.connect(&amp;print_difference);
  sig.connect(&amp;print_quotient);

  sig(5, 3);</programlisting>
</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

<para>This program will print out the following:<sbr/>
该程序将打印输出如下：</para>
<programlisting>The arguments are 5 and 3
The sum is 8
The product is 15
The difference is 2
The quotient is 1.66667</programlisting>
<para>So any values that are given to <code>sig</code> when it is
called like a function are passed to each of the slots. We have to
declare the types of these values up front when we create the
signal. The type <code><classname>boost::signals2::signal</classname>&lt;void (float,
float)&gt;</code> means that the signal has a <code>void</code>
return value and takes two <code>float</code> values. Any slot
connected to <code>sig</code> must therefore be able to take two
<code>float</code> values.<sbr/>
当像函数一样调用 <code>sig</code> 时，输入它的任何值都传给了每一个插槽。创建信号时，我们必须预先声明这些值的类型。 
类型 <code><classname>boost::signals2::signal</classname>&lt;void (float, float)&gt;</code> 表明信号具有 <code>void</code> 
返回值并接受两个 <code>float</code> 值。因此任何连接到 <code>sig</code> 的插槽都必须能够接受两个 <code>float</code> 值。</para>
</section>

<section><title>Signal Return Values (Advanced) 信号返回值（高级）</title>
<para>Just as slots can receive arguments, they can also return
values. These values can then be returned back to the caller of the
signal through a <firstterm>combiner</firstterm>. The combiner is a mechanism
that can take the results of calling slots (there many be no
results or a hundred; we don't know until the program runs) and
coalesces them into a single result to be returned to the caller.
The single result is often a simple function of the results of the
slot calls: the result of the last slot call, the maximum value
returned by any slot, or a container of all of the results are some
possibilities.<sbr/>
正如插槽可以接收参数，它们也可以返回值。然后这些值可以通过 <firstterm>合并器</firstterm> 返回给信号的调用者。 
合并器是这样一种工具，它接收插槽调用的结果（可能没有结果，也可能有100个结果；程序运行时才知道），
并且把它们合并成单一的结果返回给调用者。 该单一的结果往往是插槽调用结果的一个简单函数，可能是：
最后的插槽调用的结果、所有插槽返回值的最大值，或包含所有结果的容器。</para>
<para>We can modify our previous arithmetic operations example
slightly so that the slots all return the results of computing the
product, quotient, sum, or difference. Then the signal itself can
return a value based on these results to be printed:<sbr/>
我们可以稍微修改前面的算术运算的例子，使插槽分别返回加减乘除的计算结果。 
然后信号本身就可以根据这些结果返回一个值，并打印出来。</para>
<programlisting><xi:include href="signal_return_value_slot_defs_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>boost::signals2::signal&lt;float (float, float)&gt; sig;</programlisting>
</entry>
<entry>
<programlisting>boost::signals2::signal2&lt;float, float, float&gt; sig;</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
<programlisting><xi:include href="signal_return_value_main_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

<para>This example program will output <code>2</code>. This is because the
default behavior of a signal that has a return type
(<code>float</code>, the first template argument given to the
<code><classname>boost::signals2::signal</classname></code> class template) is to call all slots and
then return a <classname>boost::optional</classname> containing
the result returned by the last slot called. This
behavior is admittedly silly for this example, because slots have
no side effects and the result is the last slot connected.<sbr/>
该例程将输出 <code>2</code>。这是因为具有返回类型（<code>float</code>，即输入 
<code><classname>boost::signals2::signal</classname></code> 类模板的第一个模板参数）的信号的默认行为是，
调用所有的插槽，然后返回一个包含最后一次调用插槽所返回的结果的 <classname>boost::optional</classname>。 
对本例来说，该行为确实有点傻，因为这些插槽没有副作用，所以结果就是最后连接的插槽。</para>
<para>A more interesting signal result would be the maximum of the
values returned by any slot. To do this, we create a custom
combiner that looks like this:<sbr/>
求所有插槽返回值的最大值，这样的信号结果才有点意思。为此，我们创建一个自定义合并器如下：</para>
<programlisting><xi:include href="custom_combiners_maximum_def_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<para>The <code>maximum</code> class template acts as a function
object. Its result type is given by its template parameter, and
this is the type it expects to be computing the maximum based on
(e.g., <code>maximum&lt;float&gt;</code> would find the maximum
<code>float</code> in a sequence of <code>float</code>s). When a
<code>maximum</code> object is invoked, it is given an input
iterator sequence <code>[first, last)</code> that includes the
results of calling all of the slots. <code>maximum</code> uses this
input iterator sequence to calculate the maximum element, and
returns that maximum value.<sbr/>
<code>maximum</code> 类模板就像一个函数对象。它的结果类型由其模板参数给出，
并且它正是基于该类型计算最大值（例如，<code>maximum&lt;float&gt;</code> 将在一系列 
<code>float</code> 中查找最大的 <code>float</code>）。当调用 <code>maximum</code> 对象时，
将给出一个输入迭代器序列 <code>[first, last)</code>，其中包含了所有插槽调用的结果。 
<code>maximum</code> 利用该输入迭代器序列来计算最大元素，并返回那个最大值。</para>
<para>We actually use this new function object type by installing it
as a combiner for our signal. The combiner template argument
follows the signal's calling signature:<sbr/>
我们要把这个新的函数对象作为合并器安装到我们的信号，才能实际使用它。
合并器模板参数跟在信号的调用签名式之后。</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
<classname>boost::signals2::signal</classname>&lt;float (float x, float y),
              maximum&lt;float&gt; &gt; sig;
</programlisting>
</entry>
<entry>
<programlisting>
<classname alt="boost::signals2::signalN">boost::signals2::signal2</classname>&lt;float, float, float,
               maximum&lt;float&gt; &gt; sig;
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>Now we can connect slots that perform arithmetic functions and
use the signal:<sbr/>
现在我们可以连接执行算术功能的插槽并使用信号了：</para>
<programlisting><xi:include href="custom_combiners_maximum_usage_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<para>The output of this program will be <code>15</code>, because
regardless of the order in which the slots are connected, the product
of 5 and 3 will be larger than the quotient, sum, or
difference.<sbr/>
该程序的输出为 <code>15</code>，因为不管插槽的连接次序如何，5 和 3 的乘积将大于商、和，或差。</para>
<para>In other cases we might want to return all of the values
computed by the slots together, in one large data structure. This
is easily done with a different combiner:<sbr/>
在其他情况下，我们可能需要同时返回插槽计算的所有值，如保存在一个大型的数据结构中。
用一个不同的合并器就可以轻松做到：</para>
<programlisting><xi:include href="custom_combiners_aggregate_values_def_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<para>
Again, we can create a signal with this new combiner:<sbr/>
我们再次用这个新的合并器创建信号：
</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
<classname>boost::signals2::signal</classname>&lt;float (float, float),
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;</programlisting>
</entry>
<entry>
<programlisting>
<classname alt="boost::signals2::signalN">boost::signals2::signal2</classname>&lt;float, float, float,
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
<programlisting><xi:include href="custom_combiners_aggregate_values_usage_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<para>The output of this program will contain 15, 8, 1.6667, and 2. It
is interesting here that
the first template argument for the <code>signal</code> class,
<code>float</code>, is not actually the return type of the signal.
Instead, it is the return type used by the connected slots and will
also be the <code>value_type</code> of the input iterators passed
to the combiner. The combiner itself is a function object and its
<code>result_type</code> member type becomes the return type of the
signal.<sbr/>
该程序的输出将包含 15、8、1.6667，和 2。有趣的是，<code>signal</code> 类的第一个模板参数，
<code>float</code>，竟然不是信号的返回类型。相反，该参数是所连接插槽的返回类型，
并且它也是传入合并器的输入迭代器的 <code>value_type</code>。合并器本身是个函数对象，
并且它的 <code>result_type</code> 成员类型将成为信号的返回类型。</para>
<para>The input iterators passed to the combiner transform dereference
operations into slot calls. Combiners therefore have the option to
invoke only some slots until some particular criterion is met. For
instance, in a distributed computing system, the combiner may ask
each remote system whether it will handle the request. Only one
remote system needs to handle a particular request, so after a
remote system accepts the work we do not want to ask any other
remote systems to perform the same task. Such a combiner need only
check the value returned when dereferencing the iterator, and
return when the value is acceptable. The following combiner returns
the first non-NULL pointer to a <code>FulfilledRequest</code> data
structure, without asking any later slots to fulfill the
request:<sbr/>
传给合并器的输入迭代器会将解引用操作转换为插槽调用。因此合并器可选择仅调用某些符合特定条件的插槽。 
例如，在分布计算系统中，合并器可能会询问每个远程系统能否处理请求。对于一个特定请求，
仅需一个远程系统进行处理，因此当一个远程系统接受该工作后，我们将不再要求任何其他远程系统来做同一个任务。 
这样一个合并器只需检查迭代器解引用的返回值，并当该值可以接受时就返回。 
以下的合并器返回第一个指向 <code>FulfilledRequest</code> 数据结构的非空指针，
而不必要求任何以后的插槽来完成请求：</para>
<programlisting>
struct DistributeRequest {
  typedef FulfilledRequest* result_type;

  template&lt;typename InputIterator&gt;
  result_type operator()(InputIterator first, InputIterator last) const
  {
    while (first != last) {
      if (result_type fulfilled = *first)
        return fulfilled;
      ++first;
    }
    return 0;
  }
};
</programlisting>
</section>
</section>

<section><title>Connection Management 连接管理</title>
<section><title>Disconnecting Slots (Beginner) 断开插槽（初级）</title>
<para>Slots aren't expected to exist indefinitely after they are
connected. Often slots are only used to receive a few events and
are then disconnected, and the programmer needs control to decide
when a slot should no longer be connected.<sbr/>
插槽在连接之后不必无限期地存在。插槽往往只是用来接收一些事件然后断开，
当插槽不再需要保持连接时，程序员可以做出决定并控制。</para>
<para>The entry point for managing connections explicitly is the
<code><classname>boost::signals2::connection</classname></code> class. The
<code><classname>connection</classname></code> class uniquely represents the connection
between a particular signal and a particular slot. The
<code><methodname alt="connection::connected">connected</methodname>()</code> method checks if the signal and slot are
still connected, and the <code><methodname alt="connection::disconnect">disconnect()</methodname></code> method
disconnects the signal and slot if they are connected before it is
called. Each call to the signal's <code>connect()</code> method
returns a connection object, which can be used to determine if the
connection still exists or to disconnect the signal and slot.<sbr/>
显式管理连接的入口点是 <code><classname>boost::signals2::connection</classname></code> 类。
<code><classname>connection</classname></code> 类唯一代表了特定信号与特定插槽之间的连接。
<code><methodname alt="connection::connected">connected</methodname>()</code> 方法检查信号与插槽是否仍保持连接， 
如果信号与插槽是连接着的，<code><methodname alt="connection::disconnect">disconnect()</methodname></code> 
方法断开它们的连接。每次调用信号的 <code>connect()</code> 方法，就返回一个连接对象，
该对象用于确定连接是否仍然存在，或者用于断开信号和插槽。</para>
<programlisting><xi:include href="disconnect_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
</section>

<section><title>Blocking Slots (Beginner) 阻塞插槽（初级）</title>

<para>Slots can be temporarily "blocked", meaning that they will be
ignored when the signal is invoked but have not been permanently disconnected.
This is typically used to prevent infinite recursion in cases where
otherwise running a slot would cause the signal it is connected to to be
invoked again.  A
<classname>boost::signals2::shared_connection_block</classname> object will
temporarily block a slot.  The connection is unblocked by either
destroying or calling
<methodname alt="shared_connection_block::unblock">unblock</methodname>
on all the
<code>shared_connection_block</code> objects that reference the connection.
Here is an example of
blocking/unblocking slots:<sbr/>
插槽可以被临时“阻塞”，即当信号被调用时，这些插槽将被忽略，但并没有被永久地断开。
这主要用于防止无限递归，如有时，要没有阻塞，插槽运行时会再次调用它所连接的信号。
<classname>boost::signals2::shared_connection_block</classname> 对象会临时阻塞插槽。 
要解除阻塞，需要销毁所有引用该连接的 <code>shared_connection_block</code> 对象，
或者调用它们的 <methodname alt="shared_connection_block::unblock">unblock</methodname>。 
以下是阻塞插槽和解除的例子：</para>

<programlisting><xi:include href="block_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

</section>

<section><title>Scoped Connections (Intermediate) 域内连接（中级）</title>
<para>The <classname>boost::signals2::scoped_connection</classname> class
references a signal/slot connection that will be disconnected when
the <code>scoped_connection</code> class goes out of scope. This
ability is useful when a connection need only be temporary,
e.g.,<sbr/>
<classname>boost::signals2::scoped_connection</classname> 类引用了一个信号/插槽的连接，
当 <code>scoped_connection</code> 类出作用域时，该连接将会被断开。当仅需临时连接时，该功能很有用，如：</para>
<programlisting><xi:include href="scoped_connection_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

<para>
  Note, attempts to initialize a scoped_connection with the assignment syntax
  will fail due to it being noncopyable.  Either the explicit initialization syntax
  or default construction followed by assignment from a <classname>connection</classname>
  will work:<sbr/>
  注意，试图用赋值语句初始化 scoped_connection 会失败，因为它是不可拷贝的。应该使用显式初始化， 
  或者缺省构造然后用 <classname>connection</classname> 对它赋值：
</para>
<programlisting>
// doesn't compile due to compiler attempting to copy a temporary scoped_connection object
// boost::signals2::scoped_connection c0 = sig.<methodname>connect</methodname>(ShortLived());

// okay
boost::signals2::scoped_connection c1(sig.<methodname>connect</methodname>(ShortLived()));

// also okay
boost::signals2::scoped_connection c2;
c2 = sig.<methodname>connect</methodname>(ShortLived());
</programlisting>
</section>

<section><title>Disconnecting Equivalent Slots (Intermediate) 断开等价的插槽（中级）</title>
<para>One can disconnect slots that are equivalent to a given function
object using a form of the
<code><methodname alt="signalN::disconnect">signal::disconnect</methodname></code> method, so long as
the type of the function object has an accessible <code>==</code>
operator. For instance:<sbr/>
你可以使用 <code><methodname alt="signalN::disconnect">signal::disconnect</methodname></code> 
方法断开与给定函数对象等价的多个插槽，只要该函数对象的类型具有可访问的 <code>==</code> 运算符。例如：
</para>
<programlisting><xi:include href="disconnect_by_slot_def_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting><classname>boost::signals2::signal</classname>&lt;void ()&gt; sig;</programlisting>
</entry>
<entry>
<programlisting><classname alt="boost::signals2::signalN">boost::signals2::signal0</classname>&lt;void&gt; sig;</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

</section>
<programlisting><xi:include href="disconnect_by_slot_usage_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

<section id="signals2.tutorial.connection-management"><title>Automatic Connection Management (Intermediate) 自动连接管理（中级）</title>
<para>Boost.Signals2 can automatically track the lifetime of objects
involved in signal/slot connections, including automatic
disconnection of slots when objects involved in the slot call are
destroyed. For instance, consider a simple news delivery service,
where clients connect to a news provider that then sends news to
all connected clients as information arrives. The news delivery
service may be constructed like this: <sbr/>
Boost.Signals2 能自动跟踪信号/插槽连接中所涉及对象的生命期，包括当插槽调用中涉及的对象销毁时自动断开插槽。 
例如，考虑一个简单的新闻发送服务，其中客户会连接到新闻提供者，而新闻提供者一有信息到达，
就发送新闻到所有连接的客户。该新闻发送服务可能像这样构造：</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
class NewsItem { /* ... */ };

typedef boost::signals2::signal&lt;void (const NewsItem&amp;)&gt; signal_type;
signal_type deliverNews;
</programlisting>
</entry>
<entry>
<programlisting>
class NewsItem { /* ... */ };

typedef boost::signals2::signal1&lt;void, const NewsItem&amp;&gt; signal_type;
signal_type deliverNews;
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>Clients that wish to receive news updates need only connect a
function object that can receive news items to the
<code>deliverNews</code> signal. For instance, we may have a
special message area in our application specifically for news,
e.g.,:<sbr/>
希望接收新闻更新的客户只需连接一个函数对象，该对象可以接收传给 <code>deliverNews</code> 信号的新闻条目，例如：</para>
<programlisting>
struct NewsMessageArea : public MessageArea
{
public:
  // ...

  void displayNews(const NewsItem&amp; news) const
  {
    messageText = news.text();
    update();
  }
};

// ...
NewsMessageArea *newsMessageArea = new NewsMessageArea(/* ... */);
// ...
deliverNews.<methodname>connect</methodname>(boost::bind(&amp;NewsMessageArea::displayNews,
  newsMessageArea, _1));
</programlisting>
<para>However, what if the user closes the news message area,
destroying the <code>newsMessageArea</code> object that
<code>deliverNews</code> knows about? Most likely, a segmentation
fault will occur. However, with Boost.Signals2 one may track any object
which is managed by a shared_ptr, by using
<methodname alt="boost::signals2::slotN::track">slot::track</methodname>.  A slot will automatically
disconnect when any of its tracked objects expire.  In
addition, Boost.Signals2 will ensure that no tracked object expires
while the slot it is associated with is in mid-execution.  It does so by creating
temporary shared_ptr copies of the slot's tracked objects before executing it.
To track <code>NewsMessageArea</code>, we use a shared_ptr to manage
its lifetime, and pass the shared_ptr to the slot via its
<methodname alt="boost::signals2::slotN::track">slot::track</methodname>
method before connecting it,
e.g.:<sbr/>
不过，如果用户关闭新闻讯息区，销毁了 <code>deliverNews</code> 所知的 <code>newsMessageArea</code> 对象，那会怎么样？
最有可能的是产生段错误。然而，在Boost.Signals2中，使用 <methodname alt="boost::signals2::slotN::track">slot::track</methodname>，
你可以跟踪由 shared_ptr 管理的任何对象，当插槽的任一个被跟踪对象失效时，插槽会自动断开。另外，当插槽正在执行时， 
Boost.Signals2 会保证它所关联的被跟踪对象不会失效。为此，插槽在执行前会创建被跟踪对象的临时 shared_ptr 副本。 
为了跟踪 <code>newsMessageArea</code>，我们用 shared_ptr 管理其生命期，并在连接它之前，
通过其 <methodname alt="boost::signals2::slotN::track">slot::track</methodname> 方法，把 shared_ptr 传给插槽。例如：</para>
<programlisting>
// ...
boost::shared_ptr&lt;NewsMessageArea&gt; newsMessageArea(new NewsMessageArea(/* ... */));
// ...
deliverNews.<methodname>connect</methodname>(signal_type::slot_type(&amp;NewsMessageArea::displayNews,
  newsMessageArea.get(), _1).track(newsMessageArea));
</programlisting>
<para>
  Note there is no explicit call to bind() needed in the above example.  If the
  <classname alt="slotN">slot</classname> constructor is passed more than one
  argument, it will automatically pass all the arguments to <code>bind</code> and use the
  returned function object.<sbr/>
  注意上例中不需要显式调用 bind()。 如果 <classname alt="slotN">slot</classname> 构造函数传入一个以上的参数， 
  它会自动将所有参数传给 <code>bind</code>， 并使用返回的函数对象。
</para>
<para>Also note, we pass an ordinary pointer as the
  second argument to the slot constructor, using <code>newsMessageArea.get()</code>
  instead of passing the <code>shared_ptr</code> itself.  If we had passed the
  <code>newsMessageArea</code> itself, a copy of the <code>shared_ptr</code> would
  have been bound into the slot function, preventing the <code>shared_ptr</code>
  from expiring.  However, the use of
  <methodname alt="boost::signals2::slotN::track">slot::track</methodname>
  implies we wish to allow the tracked object to expire, and automatically
  disconnect the connection when this occurs.<sbr/>
  还要注意插槽构造函数的第2个参数，我们使用 <code>newsMessageArea.get()</code>，传入了一个普通指针， 
  而不是 <code>shared_ptr</code> 本身。如果传入 <code>newsMessageArea</code> 本身，插槽函数将绑定一个 
  <code>shared_ptr</code> 副本，从而妨碍了 <code>shared_ptr</code> 的失效。然而，使用 
  <methodname alt="boost::signals2::slotN::track">slot::track</methodname> 意味着我们希望允许被跟踪对象失效， 
  并且当它发生时自动断开连接。
</para>
</section>

  <section id="signals2.tutorial.deconstruct">
    <title>Postconstructors and Predestructors (Advanced)  后构造器和预析构器（高级）</title>
    <para>One limitation of using <code>shared_ptr</code> for tracking is that
      an object cannot setup tracking of itself in its constructor.  However, it is
      possible to set up tracking in a post-constructor which is called after the
      object has been created and passed to a <classname>shared_ptr</classname>.
      The Boost.Signals2
      library provides support for post-constructors and pre-destructors
      via the <functionname>deconstruct()</functionname> factory function.<sbr/>
      利用 <code>shared_ptr</code> 跟踪有一个限制：对象不能在其构造函数中建立对自身的跟踪。 
      然而，可以在后构造器中建立跟踪，它会在对象创建并传给 <classname>shared_ptr</classname> 之后被调用。 
      Boost.Signals2 库通过 <functionname>deconstruct()</functionname> 工厂方法， 对后构造器和预析构器提供了支持。
    </para>
    <para>
      For most cases, the simplest and most robust way to setup postconstructors
      for a class is to define an associated <code>adl_postconstruct</code> function
      which can be found by <functionname>deconstruct()</functionname>,
      make the class' constructors private, and give <functionname>deconstruct</functionname>
      access to the private constructors by declaring <classname>deconstruct_access</classname>
      a friend.  This will ensure that objects of the class may only be created
      through the <functionname>deconstruct()</functionname> function, and their
      associated <code>adl_postconstruct()</code> function will always be called.<sbr/>
      在多数情况下，为类建立后构造器的最简单最可靠的方法是：定义一个相关的 <code>adl_postconstruct</code> 函数， 
      让它可以被 <functionname>deconstruct()</functionname> 找到，让类的构造函数为私有的， 
      并通过声明 <classname>deconstruct_access</classname> 为友元，
      让 <functionname>deconstruct</functionname> 可以访问私有的构造函数。 
      这将保证类的对象只能通过 <functionname>deconstruct()</functionname> 函数创建，
      而它们相关的 <code>adl_postconstruct()</code> 函数总是会被调用。
    </para>
    <para>The <link linkend="signals2.examples.deconstruct">examples</link> section
      contains several examples of defining classes with postconstructors and
      predestructors, and creating objects of these classes using
      <functionname>deconstruct()</functionname><sbr/>
      <link linkend="signals2.examples.deconstruct">例程</link> 一节中有几个例子， 
      它们用后构造器和预析构器来定义类，并用 <functionname>deconstruct()</functionname> 创建这些类的对象。
    </para>
    <para>
      Be aware that the postconstructor/predestructor support in Boost.Signals2
      is in no way essential to the use of the library.  The use of
      <functionname>deconstruct</functionname>
      is purely optional.  One alternative is to
      define static factory functions for your classes.  The
      factory function can create an object, pass ownership of the object to
      a <classname>shared_ptr</classname>, setup tracking for the object,
      then return the <classname>shared_ptr</classname>.<sbr/>
      注意，Boost.Signals2 中对 后构造器/预析构器 的支持对于库的使用并非是必须的。
      <functionname>deconstruct</functionname> 的使用完全是可选的。另一选择是为你的类定义静态工厂函数。 
      该工厂函数可以创建对象，传递对象所有权到 <classname>shared_ptr</classname>，为对象建立跟踪，
      然后返回 <classname>shared_ptr</classname>。
    </para>
  </section>

<section><title>When Can Disconnections Occur? (Intermediate) 何时断开？（中级）</title>
<para>Signal/slot disconnections occur when any of these conditions
occur:<sbr/>
以下任一条件发生时，信号/插槽将断开：</para>
<itemizedlist>
<listitem><para>The connection is explicitly disconnected via the connection's
<code>disconnect</code> method directly, or indirectly via the
signal's <code>disconnect</code> method, or
<code>scoped_connection</code>'s destructor.<sbr/>
连接被显式地断开：直接通过连接的 <code>disconnect</code> 方法，或间接地通过信号的 <code>disconnect</code> 方法，
或 <code>scoped_connection</code> 的析构函数。</para></listitem>
<listitem><para>An object tracked by the slot is
destroyed.<sbr/>
插槽所跟踪的对象被销毁。</para></listitem>
<listitem><para>The signal is destroyed.<sbr/>
信号被销毁。</para></listitem></itemizedlist>
<para>These events can occur at any time without disrupting a signal's
calling sequence. If a signal/slot connection is disconnected at
any time during a signal's calling sequence, the calling sequence
will still continue but will not invoke the disconnected slot.
Additionally, a signal may be destroyed while it is in a calling
sequence, and which case it will complete its slot call sequence
but may not be accessed directly.<sbr/>
这些事件可以发生于任何时间，而不会破坏信号的调用序列。如果信号/插槽的连接在信号调用序列的任意时刻被断开，
调用序列仍将继续，只是不会调用被断开的插槽。此外，信号可以在调用序列中间被销毁，这时，
它将完成其插槽调用序列，只是不可以被直接访问。</para>
<para>Signals may be invoked recursively (e.g., a signal A calls a
slot B that invokes signal A...). The disconnection behavior does
not change in the recursive case, except that the slot calling
sequence includes slot calls for all nested invocations of the
signal.<sbr/>
信号可以被递归调用（例如，信号A调用插槽B，而插槽B又调用信号A……）。 
递归情况下，断开的行为不会改变，只是插槽调用序列包括所有嵌套的信号调用。</para>
<para>
  Note, even after a connection is disconnected, its's associated slot
  may still be in the process of executing.  In other words, disconnection
  does not block waiting for the connection's associated slot to complete execution.
  This situation may occur in a multi-threaded environment if the
  disconnection occurs concurrently with signal invocation,
  or in a single-threaded environment if a slot disconnects itself.<sbr/>
  注意，即使在连接断开后，其相关的插槽可能仍处于执行中。也就是说，断开连接不会停止等待连接相关的插槽完成执行。 
  该情形可以发生在多线程环境下，如断开连接与信号调用并行发生，或者在单线程环境下，如插槽断开自身。 
</para>
</section>

<section><title>Passing Slots (Intermediate) 传递插槽（中级）</title>
<para>Slots in the Boost.Signals2 library are created from arbitrary
function objects, and therefore have no fixed type. However, it is
commonplace to require that slots be passed through interfaces that
cannot be templates. Slots can be passed via the
<code>slot_type</code> for each particular signal type and any
function object compatible with the signature of the signal can be
passed to a <code>slot_type</code> parameter. For instance:<sbr/>
Boost.Signals2 库中的插槽可以从任意的函数对象创建，因此没有固定的类型。 
不过通常要求通过不可模板化的接口传递插槽。对于每个特定的信号类型，
都可以通过 <code>slot_type</code> 传递插槽，而与信号的签名式兼容的任意函数对象，
都可以传给 <code>slot_type</code> 参数。例如：</para>
<programlisting><xi:include href="passing_slots_defs_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>
<programlisting>
<xi:include href="passing_slots_usage_code_snippet.xml"
  xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

<para>The <code>doOnClick</code> method is now functionally equivalent
to the <code>connect</code> method of the <code>onClick</code>
signal, but the details of the <code>doOnClick</code> method can be
hidden in an implementation detail file.<sbr/>
<code>doOnClick</code> 方法现在功能上等效于 <code>onClick</code> 信号的 <code>connect</code> 方法，
但是 <code>doOnClick</code> 方法的细节可以隐藏于细节实现文件中。 </para>
</section>
</section>

<section id="signals2.tutorial.document-view">
  <title>Example: Document-View 例子：文档-视图</title>

  <para>Signals can be used to implement flexible Document-View
  architectures. The document will contain a signal to which each of
  the views can connect. The following <code>Document</code> class
  defines a simple text document that supports mulitple views. Note
  that it stores a single signal to which all of the views will be
  connected.<sbr/>
  信号可用于实现灵活的文档-视图架构。文档包含一个信号，而每个视图连接该信号。 
  下面的 <code>Document</code> 类定义了一个简单的支持多视图的文本文档。
  注意它保存了一个单一的信号，所有视图都连接到该信号。</para>

  <programlisting><xi:include href="document_def_code_snippet.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

  <para>
    Next, we can begin to define views. The
    following <code>TextView</code> class provides a simple view of the
    document text.<sbr/>
    接下来，我们可以开始定义视图。 以下 <code>TextView</code> 类是对文档文本的一个简单视图。
  </para>

  <programlisting><xi:include href="text_view_def_code_snippet.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

  <para>Alternatively, we can provide a view of the document
    translated into hex values using the <code>HexView</code>
    view:<sbr/>
    此外，我们可以提供文档翻译成16进制后的视图，如 <code>HexView</code> 视图：</para>

  <programlisting><xi:include href="hex_view_def_code_snippet.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

  <para>
    To tie the example together, here is a
    simple <code>main</code> function that sets up two views and then
    modifies the document:<sbr/>
    为了把例子串起来， 有个简单的 <code>main</code> 函数，它建立了两个视图，然后更改文档：
  </para>

  <programlisting><xi:include href="document_view_main_code_snippet.xml"
    xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml"/></programlisting>

  <para>The complete example source, contributed by Keith MacDonald,
    is available in the <link linkend="signals2.examples.document-view">examples</link> section.
    We also provide variations on the program which employ automatic connection management
    to disconnect views on their destruction.<sbr/>
    完整的例程源码，由 Keith MacDonald 提供，在 <link linkend="signals2.examples.document-view">例程</link>一节中。 
    同时我们提供了该程序的更改版，它们使用了自动连接管理，能在视图析构时断开视图。
  </para>
</section>

  <section id="signals2.tutorial.extended-slot-type">
    <title>Giving a Slot Access to its Connection (Advanced) 让插槽可以操作其连接（高级）</title>
    <para>
      You may encounter situations where you wish to disconnect or block a slot's
      connection from within the slot itself.  For example, suppose you have a group
      of asynchronous tasks, each of which emits a signal when it completes.
      You wish to connect a slot to all the tasks to retrieve their results as
      each completes.  Once a
      given task completes and the slot is run, the slot no longer needs to be
      connected to the completed task.
      Therefore, you may wish to clean up old connections by having the slot
      disconnect its invoking connection when it runs.<sbr/>
      可能有这样的情形：你希望在插槽中断开或阻塞插槽本身的连接。例如，有一组异步任务，
      当每个任务完成时会发出信号。你希望用一个插槽连接所有的任务，来接收它们完成时的结果。 
      一旦某个任务完成并且插槽被运行，该插槽就不必再连接到这个已经完成的任务。 
      因此，你可能希望让插槽运行时断开其连接，以清理旧连接。
    </para>
    <para>
      For a slot to disconnect (or block) its invoking connection, it must have
      access to a <classname>connection</classname> object which references
      the invoking signal-slot connection.  The difficulty is,
      the <classname>connection</classname> object is returned by the
      <methodname alt="signalN::connect">signal::connect</methodname>
      method, and therefore is not available until after the slot is
      already connected to the signal.  This can be particularly troublesome
      in a multi-threaded environment where the signal may be invoked
      concurrently by a different thread while the slot is being connected.<sbr/>
      为了让插槽断开（或阻塞）其连接，它必须能够操作 <classname>connection</classname> 对象，
      即调用的信号-插槽连接对象。难点是，<classname>connection</classname> 对象是由 
      <methodname alt="signalN::connect">signal::connect</methodname> 方法返回的，
      因此只有在插槽连接信号之后才能用。在多线程环境下，这尤其麻烦，当插槽正在被连接时，
      信号可能被其他线程并发调用。
    </para>
    <para>
      Therefore, the signal classes provide
      <methodname alt="signalN::connect_extended">signal::connect_extended</methodname>
      methods, which allow slots which take an extra argument to be connected to a signal.
      The extra argument is a <classname>connection</classname> object which refers
      to the signal-slot connection currently invoking the slot.
      <methodname alt="signalN::connect_extended">signal::connect_extended</methodname>
      uses slots of the type given by the
      <classname alt="signalN::extended_slot_type">signal::extended_slot_type</classname>
      typedef.<sbr/>
      因此，信号类提供了 <methodname alt="signalN::connect_extended">signal::connect_extended</methodname> 方法，
      它允许连接信号的插槽接受一个额外参数。该额外参数是个 <classname>connection</classname> 对象，
      它指向当前调用插槽的信号-插槽连接。<methodname alt="signalN::connect_extended">signal::connect_extended</methodname> 
      使用的插槽类型由 <classname alt="signalN::extended_slot_type">signal::extended_slot_type</classname> 定义。
    </para>
    <para>
      The examples section includes an
      <link linkend="signals2.examples.tutorial.extended_slot">extended_slot</link>
      program which demonstrates the syntax for using
      <methodname alt="signalN::connect_extended">signal::connect_extended</methodname>.<sbr/>
      例程一节中有个 <link linkend="signals2.examples.tutorial.extended_slot">extended_slot</link> 程序，
      它演示了 <methodname alt="signalN::connect_extended">signal::connect_extended</methodname> 的用法。
    </para>
  </section>

  <section id="signals2.tutorial.signal-mutex-template-parameter">
    <title>Changing the <code>Mutex</code> Type of a Signal (Advanced). 改变信号的互斥体类型（高级）</title>
    <para>
      For most cases the default type of <classname>boost::signals2::mutex</classname> for
      a <classname>signal</classname>'s <code>Mutex</code> template type parameter should
      be fine.  If you wish to use an alternate mutex type, it must be default-constructible
      and fulfill the <code>Lockable</code> concept defined by the Boost.Thread library.
      That is, it must have <code>lock()</code> and <code>unlock()</code> methods
      (the <code>Lockable</code> concept also includes a <code>try_lock()</code> method
      but this library does not require try locking).<sbr/>
      <classname>signal</classname> 的模板类型参数 <code>Mutex</code> 默认为 <classname>boost::signals2::mutex</classname>， 
      多数情况下，这应该能行。如果你希望使用其他的互斥体类型，那么它必须可缺省构造，并且满足由 Boost.Thread 库所定义的 
      <code>Lockable</code> 概念。即，它必须具有 <code>lock()</code> 和 <code>unlock()</code> 方法（<code>Lockable</code> 
      概念同时包含了 <code>try_lock()</code> 方法，但本库没用到）。 
    </para>
    <para>
      The Boost.Signals2 library provides one alternate mutex class for use with <classname>signal</classname>:
      <classname>boost::signals2::dummy_mutex</classname>.  This is a fake mutex for
      use in single-threaded programs, where locking a real mutex would be useless
      overhead.  Other mutex types you could use with <classname>signal</classname> include
      <classname>boost::mutex</classname> and the <code>std::mutex</code> from
      C++0x.<sbr/>
      Boost.Signals2 库提供了另外一个可用于 <classname>signal</classname> 的互斥类：
      <classname>boost::signals2::dummy_mutex</classname>。这是个用于单线程的假互斥体，因为在单线程中，
      用真实的互斥体加锁是无谓的开销。其它可用于 <classname>signal</classname> 的互斥体类型有：
      <classname>boost::mutex</classname> 和 C++0x 的 <code>std::mutex</code>。
    </para>
    <para>
      Changing a signal's <code>Mutex</code> template type parameter can be tedious, due to
      the large number of template parameters which precede it.  The
      <classname>signal_type</classname> metafunction is particularly useful in this case,
      since it enables named template type parameters for the <classname>signal</classname>
      class.  For example, to declare a signal which takes an <code>int</code> as
      an argument and uses a <classname>boost::signals2::dummy_mutex</classname>
      for its <code>Mutex</code> types, you could write:<sbr/>
      更改信号的 <code>Mutex</code> 模板类型参数很烦，因为在它之前有许多模板参数。 
      这时，<classname>signal_type</classname> 元函数（metafunction）就特别有用， 
      它开启了 <classname>signal</classname> 类的命名模板类型参数。例如，声明一个信号，
      接收一个 <code>int</code> 参数，并使用 <classname>boost::signals2::dummy_mutex</classname> 
      作为其 <code>Mutex</code> 类型，你可以这样写：
    </para>
<programlisting>namespace bs2 = boost::signals2;
using bs2::keywords;
bs2::signal_type&lt;void (int), mutex_type&lt;bs2::dummy_mutex&gt; &gt;::type sig;
</programlisting>

  </section>

  <section>
    <title>Linking against the Signals2 library 链接 Signals2 库</title>
    <para>Unlike the original Boost.Signals library, Boost.Signals2 is currently header-only.<sbr/>
    与原 Boost.Signals 库不同，Boost.Signals2 现在是纯头文件的。
    </para>
  </section>

</section>

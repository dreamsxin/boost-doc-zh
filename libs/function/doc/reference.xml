<?xml version="1.0" encoding="utf-8"?>
<!--
   Copyright (c) 2002 Douglas Gregor <doug.gregor -at- gmail.com>
  
   Distributed under the Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)
  -->
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">

<library-reference id="function.reference" last-revision="$Date: 2008-07-14 14:32:29 -0400 (Mon, 14 Jul 2008) $">

<section id="function.definitions">
  <title>Definitions 定义</title>
<para>
  <itemizedlist>
    <listitem>
      <para>A function object <computeroutput>f</computeroutput> is
      <emphasis>compatible</emphasis> if for the given set of argument
      types <computeroutput>Arg1</computeroutput>,
      <computeroutput>Arg2</computeroutput>, ...,
      <computeroutput>ArgN</computeroutput> and a
      return type <computeroutput>ResultType</computeroutput>, the
      appropriate following function is well-formed:<sbr/>
      如果对于给定的一套参数类型 <computeroutput>Arg1</computeroutput>,
      <computeroutput>Arg2</computeroutput>, ..., <computeroutput>ArgN</computeroutput> 
      和返回类型 <computeroutput>ResultType</computeroutput>，适合于以下形式，
      则可以说这个函数对象 f 是 compatible（兼容）的：

<programlisting>
  <emphasis>// if ResultType is not <emphasis role="bold">void</emphasis></emphasis>
  ResultType foo(Arg1 arg1, Arg2 arg2, ..., Arg<emphasis>N</emphasis> arg<emphasis>N</emphasis>)
  {
    <emphasis role="bold">return</emphasis> f(arg1, arg2, ..., arg<emphasis>N</emphasis>);
  }

  <emphasis>// if ResultType is <emphasis role="bold">void</emphasis></emphasis>
  ResultType foo(Arg1 arg1, Arg2 arg2, ..., Arg<emphasis>N</emphasis> arg<emphasis>N</emphasis>)
  {
    f(arg1, arg2, ..., arg<emphasis>N</emphasis>);
  }
</programlisting></para>

      <para> A special provision is made for pointers to member
      functions. Though they are not function objects, Boost.Function
      will adapt them internally to function objects. This requires
      that a pointer to member function of the form <code>R
      (X::*mf)(Arg1, Arg2, ..., ArgN)
      cv-quals</code> be adapted to a
      function object with the following function call operator
      overloads:<sbr/>
      对指向成员函数的指针有一条特殊的规定。尽管它们不是函数对象，
      Boost.Function 也可以在内部将它们调整为函数对象。
      这要求这个指针指向的形式为 <code>R (X::*mf)(Arg1, Arg2, ..., ArgN) cv-quals</code> 
      的成员函数适合于带有如下函数调用操作符重载的函数对象：

<programlisting>
  <emphasis role="bold">template</emphasis>&lt;<emphasis role="bold">typename P</emphasis>&gt;
  R <emphasis role="bold">operator</emphasis>()(<emphasis>cv-quals</emphasis> P&amp; x, Arg1 arg1, Arg2 arg2, ..., Arg<emphasis>N</emphasis> arg<emphasis>N</emphasis>) <emphasis role="bold">const</emphasis>
  {
    <emphasis role="bold">return</emphasis> (*x).*mf(arg1, arg2, ..., arg<emphasis>N</emphasis>);
  }
</programlisting>
</para>
    </listitem>
    <listitem>
      <para>A function object <code>f</code> of
      type <code>F</code> is
      <emphasis>stateless</emphasis> if it is a function pointer or if
      <code><classname>boost::is_stateless</classname>&lt;T&gt;</code>
      is true. The construction of or copy to a Boost.Function object
      from a stateless function object will not cause exceptions to be
      thrown and will not allocate any storage.<sbr/>
      如果一个类型为 <code>F</code> 的函数对象 <code>f</code> 是一个函数指针或者 
      <code><classname>boost::is_stateless</classname>&lt;T&gt;</code> 为 true，
      则这个函数对象是 <emphasis>stateless</emphasis> 的。一个 stateless 
      函数对象的构造函数，或者将 stateless 函数对象拷贝到 Boost.Function 对象中，
      都不会抛出异常，而且不分配任何存储空间。
      </para>
    </listitem>
  </itemizedlist>
</para>
</section>

<header name="boost/function.hpp">
<namespace name="boost">
  <class name="bad_function_call">
    <inherit access="public"><classname>std::runtime_error</classname></inherit>
    <purpose>An exception type thrown when an instance of a <code>function</code> object is empty when invoked.<sbr/>
    如果一个 <code>function</code> 对象的实例是空的，调用时就会抛出这个类型的异常。</purpose>
    <constructor>
      <effects><simpara>Constructs a <code><classname>bad_function_call</classname></code> exception object.<sbr/>
      构造一个 <code><classname>bad_function_call</classname></code> 异常对象。</simpara></effects>
    </constructor>
  </class>

  <class name="function_base">
    <purpose>The common base class for all Boost.Function
    objects. Objects of type function_base may not be created
    directly.<sbr/>
    所有 Boost.Function 对象的共通基类。不可以直接创建类型 function_base 的对象。</purpose>

    <method-group name="capacity">
      <method name="empty" cv="const">
        <type>bool</type>
        <returns><simpara><code>false</code> if <code>this</code> has a target, and <code>true</code> otherwise.<sbr/>
        如果 <code>this</code> 有一个目标，则返回 <code>false</code>，否则，返回 <code>true</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>
    </method-group>

    <method-group name="target access">
      <overloaded-method name="target">
        <signature>
          <template> 
            <template-type-parameter name="Functor"/>
          </template>
          <type>Functor*</type>
        </signature>
        <signature cv="const">
          <template> 
            <template-type-parameter name="Functor"/>
          </template>
          <type>const Functor*</type>
        </signature>

        <returns><simpara>If <code>this</code> stores a target of type
        <code>Functor</code>, returns the address of the
        target. Otherwise, returns the NULL
        pointer.<sbr/>
        如果 <code>this</code> 存储一个类型 <code>Functor</code> 的目标，
        则返回目标的地址。否则，返回 NULL 指针。</simpara></returns>

        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </overloaded-method>

      <method name="contains" cv="const">
        <template>
          <template-type-parameter name="Functor"/>
        </template>
        <type>bool</type>
        <parameter name="f">
          <paramtype>const Functor&amp;</paramtype>
        </parameter>
        <returns><simpara><code>true</code> if <code>this-&gt;<methodname>target</methodname>&lt;Functor&gt;()</code> is non-NULL and <code><functionname>function_equal</functionname>(*(this-&gt;target&lt;Functor&gt;()), f)</code><sbr/>
        如果 <code>this-&gt;<methodname>target</methodname>&lt;Functor&gt;()</code> 是非 NULL 的并且 
        <code><functionname>function_equal</functionname>(*(this-&gt;target&lt;Functor&gt;()), f)</code>，
        则返回 <code>true</code>。 </simpara></returns>
 
      </method>

      <method name="target_type" cv="const">
        <type>const std::type_info&amp;</type>
        <returns><simpara><code>typeid</code> of the target function object, or <code>typeid(void)</code> if <code>this-&gt;<methodname>empty</methodname>()</code>.<sbr/>
        目标函数对象的 <code>typeid</code>，或者，如果 <code>this-&gt;<methodname>empty</methodname>()</code>，
        返回 <code>typeid(void)</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>
    </method-group>
  </class>

  <class name="functionN">
    <template>
      <template-type-parameter name="R"/>
      <template-type-parameter name="T1"/>
      <template-type-parameter name="T2"/>
      <template-varargs/>
      <template-type-parameter name="TN"/>
    </template>

    <inherit access="public"><classname>function_base</classname></inherit>

    <purpose>A set of generalized function pointers that can be used for callbacks or wrapping function objects.<sbr/>
    一组可以用于回调或包装函数对象的泛化的函数指针。</purpose>

    <description>
      <para>Class template <classname>functionN</classname> is
      actually a family of related classes <classname
      alt="functionN">function0</classname>, <classname
      alt="functionN">function1</classname>, etc., up to some
      implementation-defined maximum. In this context, <code>N</code>
      refers to the number of parameters.<sbr/>
      类模板 <classname>functionN</classname> 实际上是相关类 <classname alt="functionN">function0</classname>，
      <classname alt="functionN">function1</classname> 等的一个家族，一直到某个由实现定义的最大值。
      在这里的上下文中，<code>N</code> 表示参数个数。</para>
    </description>

    <typedef name="result_type"><type>R</type></typedef>
    <typedef name="argument_type">
      <type>T1</type><purpose>If N == 1</purpose>
    </typedef>
    <typedef name="first_argument_type">
      <type>T1</type>
      <purpose>If N == 2</purpose>
    </typedef>
    <typedef name="second_argument_type">
      <type>T2</type>
      <purpose>If N == 2</purpose>
    </typedef>
    <typedef name="arg1_type"><type>T1</type></typedef>
    <typedef name="arg2_type"><type>T2</type></typedef>
    <typedef name="..."><type/></typedef>
    <typedef name="argN_type"><type>TN</type></typedef>

    <static-constant name="arity">
      <type>int</type>
      <default>N</default>
    </static-constant>

    <struct name="sig">
      <template>
        <template-type-parameter name="Args"/>
      </template>

      <purpose>
        <simpara><libraryname>Lambda</libraryname> library support<sbr/>
        <libraryname>Lambda</libraryname> 库的支持</simpara>
      </purpose>

      <typedef name="type"><type>result_type</type></typedef>
    </struct>

    <constructor>
      <postconditions><simpara><code>this-&gt;<methodname>empty</methodname>()</code></simpara></postconditions>
      <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
    </constructor>

    <constructor>
      <parameter name="f">
        <paramtype>const <classname>functionN</classname>&amp;</paramtype>
      </parameter>
      <postconditions><simpara>Contains a copy of the <code>f</code>'s target, if it has one, or is empty if <code>f.<methodname>empty</methodname>()</code>.<sbr/>
      如果 <code>f</code> 有一个目标，则包含 <code>f</code> 的目标的一个拷贝，或者，
      如果 <code>f.<methodname>empty</methodname>()</code>，则为空。</simpara></postconditions>
      <throws><simpara>Will not throw unless copying the target of <code>f</code> throws.<sbr/>
      不会抛出异常，除非拷贝 <code>f</code> 的目标时抛出。</simpara></throws>
    </constructor>

    <constructor>
      <template>
        <template-type-parameter name="F"/>
      </template>
      <parameter name="f"><paramtype>F</paramtype></parameter>
      <requires><simpara>F is a function object Callable from <code>this</code>.<sbr/>
      F 是一个可由 <code>this</code> 调用的函数对象。</simpara></requires>
      <postconditions><simpara><code>*this</code> targets a copy of <code>f</code> if <code>f</code> is nonempty, or <code>this-&gt;<methodname>empty</methodname>()</code> if <code>f</code> is empty.<sbr/>
      如果 <code>f</code> 非空，则 <code>*this</code> 以 <code>f</code> 的一个拷贝为目标，或者，
      如果 <code>f</code> 为空，则 <code>this-&gt;<methodname>empty</methodname>()</code>。</simpara></postconditions>
    </constructor>

    <constructor>
      <template>
        <template-type-parameter name="F"/>
        <template-type-parameter name="Allocator"/>
      </template>
      <parameter name="f"><paramtype>F</paramtype></parameter>
      <parameter name="alloc"><paramtype>Allocator</paramtype></parameter>
      <requires><simpara>F is a function object Callable from <code>this</code>, Allocator is an allocator. The copy constructor and destructor of Allocator shall not throw.<sbr/>
      F 是一个可以从 <code>this</code> 调用的函数对象，Allocator 是一个分配器。
      Allocator 的复制构造函数和析构函数不能抛出异常。</simpara></requires>
      <postconditions><simpara><code>*this</code> targets a copy of <code>f</code> if <code>f</code> is nonempty, or <code>this-&gt;<methodname>empty</methodname>()</code> if <code>f</code> is empty.<sbr/>
      如果 <code>f</code> 非空，则 <code>*this</code> 以 <code>f</code> 的一个拷贝为目标，或者，
      如果 <code>f</code> 为空，则 <code>this-&gt;<methodname>empty</methodname>()</code>。</simpara></postconditions>
      <effects><simpara>If memory allocation is required, the given allocator (or a copy of it) will be used to allocate that memory.<sbr/>
      如果需要分配内存，则给定的分配器(或它的一份拷贝)将被用于分配内存。</simpara></effects>
    </constructor>

    <destructor>
      <effects><simpara>If <code>!this-&gt;<methodname>empty</methodname>()</code>, destroys the target of this.<sbr/>
      如果 <code>!this-&gt;<methodname>empty</methodname>()</code>，销毁 this 的目标。</simpara></effects>

    </destructor>

    <copy-assignment>
      <parameter name="f">
        <paramtype>const <classname>functionN</classname>&amp;</paramtype>
      </parameter>
      <postconditions><simpara>If copy construction does not throw, <code>*this</code> targets a copy of <code>f</code>'s target, if it has one, or is empty if <code>f.<methodname>empty</methodname>()</code>. If copy construction does throw, <code>this-&gt;<methodname>empty</methodname>()</code>.<sbr/>
      如果拷贝构造不抛出异常，如果 <code>f</code> 有一个目标，则 <code>*this</code> 以 <code>f</code> 的目标的拷贝为目标，
      或者，如果 <code>f.<methodname>empty</methodname>()</code>，则为空。如果拷贝构造抛出异常，
      则 <code>this-&gt;<methodname>empty</methodname>()</code>。</simpara></postconditions>
    </copy-assignment>

    <method-group name="modifiers">
      <method name="swap">
        <type>void</type>
        <parameter name="f"><paramtype>const <classname>functionN</classname>&amp;</paramtype></parameter>
        <effects><simpara>Interchanges the targets of <code>*this</code> and <code>f</code>.<sbr/>
        交换 <code>*this</code> 的目标和 <code>f</code>。</simpara></effects>
      </method>

      <method name="clear">
        <type>void</type>
        <postconditions><simpara>this-&gt;<methodname>empty</methodname>()</simpara></postconditions>
      </method>
    </method-group>

    <method-group name="capacity">
      <method name="empty" cv="const">
        <type>bool</type>
        <returns><simpara><code>false</code> if <code>this</code> has a target, and <code>true</code> otherwise.<sbr/>
        如果 <code>this</code> 有一个目标，则为 <code>false</code>，否则，为 <code>true</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>

      <method name="conversion-operator" cv="const">
        <type>safe_bool</type>
        <returns><simpara>A <code>safe_bool</code> that evaluates <code>false</code> in a boolean context when <code>this-&gt;<methodname>empty</methodname>()</code>, and <code>true</code> otherwise.<sbr/>
        当 <code>this-&gt;<methodname>empty</methodname>()</code> 时，为一个在布尔上下文中求值为 
        <code>false</code> 的 <code>safe_bool</code>，否则，为求值为 <code>true</code> 的 
        <code>safe_bool</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>

      <method name="operator!" cv="const">
        <type>bool</type>
        <returns><simpara><code>this-&gt;<methodname>empty</methodname>()</code></simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>
    </method-group>

    <method-group name="target access">
      <overloaded-method name="target">
        <signature>
          <template> 
            <template-type-parameter name="Functor"/>
          </template>
          <type>Functor*</type>
        </signature>
        <signature cv="const">
          <template> 
            <template-type-parameter name="Functor"/>
          </template>
          <type>const Functor*</type>
        </signature>

        <returns><simpara>If <code>this</code> stores a target of type
        <code>Functor</code>, returns the address of the
        target. Otherwise, returns the NULL
        pointer.<sbr/>
        如果 <code>this</code> 存储一个类型为 <code>Functor</code> 的目标，
        则返回目标的地址。否则，返回 NULL 指针。</simpara></returns>

        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </overloaded-method>

      <method name="contains" cv="const">
        <template>
          <template-type-parameter name="Functor"/>
        </template>
        <type>bool</type>
        <parameter name="f">
          <paramtype>const Functor&amp;</paramtype>
        </parameter>
        <returns><simpara><code>true</code> if <code>this-&gt;<methodname>target</methodname>&lt;Functor&gt;()</code> is non-NULL and <code><functionname>function_equal</functionname>(*(this-&gt;target&lt;Functor&gt;()), f)</code><sbr/>
        如果 <code>this-&gt;<methodname>target</methodname>&lt;Functor&gt;()</code> 为非 NULL，
        而且 <code><functionname>function_equal</functionname>(*(this-&gt;target&lt;Functor&gt;()), f)</code>，
        则为 <code>true</code>。</simpara></returns>
 
      </method>

      <method name="target_type" cv="const">
        <type>const std::type_info&amp;</type>
        <returns><simpara><code>typeid</code> of the target function object, or <code>typeid(void)</code> if <code>this-&gt;<methodname>empty</methodname>()</code>.<sbr/>
        target function object（目标函数对象）的 <code>typeid</code>，或者，
        如果 <code>this-&gt;<methodname>empty</methodname>()</code>，则为 <code>typeid(void)</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>

    </method-group>

    <method-group name="invocation">
      <method name="operator()" cv="const">
        <type>result_type</type>
        <parameter name="a1"><paramtype>arg1_type</paramtype></parameter>
        <parameter name="a2"><paramtype>arg2_type</paramtype></parameter>
        <parameter><paramtype>...</paramtype></parameter>
        <parameter name="aN"><paramtype>argN_type</paramtype></parameter>
        <effects><simpara><code>f(a1, a2, ..., aN)</code>, where <code>f</code> is the target of <code>*this</code>.<sbr/>
        <code>f(a1, a2, ..., aN)</code>，其中 <code>f</code> 为 <code>*this</code> 的目标。</simpara></effects>
        <returns><simpara>if <code>R</code> is <code>void</code>, nothing is returned; otherwise, the return value of the call to <code>f</code> is returned.<sbr/>
        如果 <code>R</code> 为 <code>void</code>，什么都不返回，否则，为调用  <code>f</code> 时的返回值。</simpara></returns>
        <throws><simpara><code><classname>bad_function_call</classname></code> if <code>this-&gt;<methodname>empty</methodname>()</code>. Otherwise, may through any exception thrown by the target function <code>f</code>.<sbr/>
        如果 <code>this-&gt;<methodname>empty</methodname>()</code>，则抛出 
        <code><classname>bad_function_call</classname></code>。
        否则，为目标函数 <code>f</code> 所可能抛出的任何异常。</simpara></throws>
      </method>
    </method-group>

    <free-function-group name="specialized algorithms">
      <function name="swap">
        <template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
          <template-varargs/>
          <template-type-parameter name="TN"/>
        </template>
        <type>void</type>
        <parameter name="f1"><paramtype><classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
        <parameter name="f2"><paramtype><classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
        <effects><simpara><code>f1.<methodname>swap</methodname>(f2)</code></simpara></effects>
      </function>
    </free-function-group>

    <free-function-group name="comparison operators">
      <overloaded-function name="operator==">
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="U1"/>
            <template-type-parameter name="U2"/>
            <template-varargs/>
            <template-type-parameter name="UN"/>
          </template>
          <type>void</type>
          <parameter name="f1"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
          <parameter name="f2"><paramtype>const <classname>functionN</classname>&lt;U1, U2, ..., UN&gt;&amp;</paramtype></parameter>
        </signature>

        <returns><simpara>True when <code>f</code> stores an object of
        type <code>Functor</code> and one of the following conditions applies:<sbr/>
        当 <code>f</code> 存储了一个类型为 <code>Functor</code> 的对象，而且满足下列条件之一时，为 true：
          <itemizedlist>

            <listitem><simpara><code>g</code> is of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and <code>f.target&lt;Functor&gt;() == g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>.<sbr/>
            <code>g</code> 的类型是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且，<code>f.target&lt;Functor&gt;() == g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>。</simpara></listitem>

            <listitem><simpara><code>g</code> is not of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and
            <code><functionname>function_equal</functionname>(*(f.target&lt;Functor&gt;()),
            g)</code>.<sbr/>
            <code>g</code> 的类型不是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且，<code><functionname>function_equal</functionname>(*(f.target&lt;Functor&gt;()),
            g)</code>。</simpara></listitem>

          </itemizedlist>
          </simpara></returns>

        <notes><simpara><code><classname>functionN</classname></code>
        objects are not
        <conceptname>EqualityComparable</conceptname>.<sbr/>
        <code><classname>functionN</classname></code> 对象不是 
        <conceptname>EqualityComparable</conceptname>（可等值比较）的。</simpara></notes>

        <rationale><simpara>The <code>safe_bool</code> conversion
        opens a loophole whereby two <code>functionN</code>
        instances can be compared via <code>==</code>, although this
        is not feasible to implement. The undefined <code>void
        operator==</code> closes the loophole and ensures a
        compile-time or link-time error.<sbr/>
        <code>safe_bool</code> 转换打开一个漏洞，使得两个 <code>functionN</code> 
        实例可以通过 <code>==</code> 进行比较，尽管对于实现来说这是不可行的。
        未定义的 <code>void operator==</code> 封闭这个漏洞并确保一个编译时或连接时错误。</simpara></rationale>
      </overloaded-function>

      <overloaded-function name="operator!=">
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="T1"/>
            <template-type-parameter name="T2"/>
            <template-varargs/>
            <template-type-parameter name="TN"/>
            <template-type-parameter name="U1"/>
            <template-type-parameter name="U2"/>
            <template-varargs/>
            <template-type-parameter name="UN"/>
          </template>
          <type>void</type>
          <parameter name="f1"><paramtype>const <classname>functionN</classname>&lt;T1, T2, ..., TN&gt;&amp;</paramtype></parameter>
          <parameter name="f2"><paramtype>const <classname>functionN</classname>&lt;U1, U2, ..., UN&gt;&amp;</paramtype></parameter>
        </signature>

        <returns><simpara>True when <code>f</code> does not store an
        object of type <code>Functor</code> or it stores an object of
        type <code>Functor</code> and one of the following conditions
        applies:<sbr/>
        当 <code>f</code> 没有存储一个类型为 <code>Functor</code> 
        的对象时或者它存储一个类型为 <code>Functor</code> 的对象并满足下列条件之一时，为 true：
          <itemizedlist>

            <listitem><simpara><code>g</code> is of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and <code>f.target&lt;Functor&gt;() != g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>.<sbr/>
            <code>g</code> 的类型是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且 <code>f.target&lt;Functor&gt;() != g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>。</simpara></listitem>

            <listitem><simpara><code>g</code> is not of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and <code>!<functionname>function_equal</functionname>(*(f.target&lt;Functor&gt;()), g)</code>.<sbr/>
            <code>g</code> 的类型不是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且 <code>!<functionname>function_equal</functionname>(*(f.target&lt;Functor&gt;()), g)</code>。</simpara></listitem>

          </itemizedlist>
          </simpara></returns>

        <notes><simpara><code><classname>functionN</classname></code>
        objects are not
        <conceptname>EqualityComparable</conceptname>.<sbr/>
        <code><classname>functionN</classname></code> 对象不是 
        <conceptname>EqualityComparable</conceptname>（可等值比较）的。</simpara></notes>

        <rationale><simpara>The <code>safe_bool</code> conversion
        opens a loophole whereby two <code>functionN</code>
        instances can be compared via <code>!=</code>, although this
        is not feasible to implement. The undefined <code>void
        operator!=</code> closes the loophole and ensures a
        compile-time or link-time error.<sbr/>
        <code>safe_bool</code> 转换打开一个漏洞，使得两个 <code>functionN</code> 
        实例可以通过 <code>!=</code> 进行比较，尽管对于实现来说这是不可行的。
        未定义的 <code>void operator!=</code> 封闭这个漏洞并确保一个编译时或连接时错误。</simpara></rationale>
      </overloaded-function>
    </free-function-group>
  </class>

  <class name="function">
    <template>
      <template-type-parameter name="Signature">
        <purpose>Function type R (T1, T2, ..., TN)</purpose>
      </template-type-parameter>
    </template>
    <inherit access="public"><classname>functionN</classname>&lt;R, T1, T2, ..., TN&gt;</inherit>

    <purpose>A generalized function pointer that can be used for
    callbacks or wrapping function objects.<sbr/>
    一个可以用于回调或包装函数对象的泛化的函数指针。</purpose>

    <description>
      <para>Class template <classname>function</classname> is a thin
      wrapper around the numbered class templates <classname
      alt="functionN">function0</classname>, <classname
      alt="functionN">function1</classname>, etc. It accepts a
      function type with N arguments and will will derive from
      <classname>functionN</classname> instantiated with the arguments
      it receives.<sbr/>
      类模板 <classname>function</classname> 是包围在带编号的类模板 
      <classname alt="functionN">function0</classname>, <classname alt="functionN">function1</classname> 
      等外面的一层薄薄的包装。它接受一个带有 N 个参数的函数类型，
      并从被它所接收的参数实例化的 <classname>functionN</classname> 继承。</para>

      <para>The semantics of all operations in class template
      <classname>function</classname> are equivalent to that of the
      underlying <classname>functionN</classname> object, although
      additional member functions are required to allow proper copy
      construction and copy assignment of function objects.<sbr/>
      在类模板 <classname>function</classname> 上的所有操作的语义都等价于在下层的 
      <classname>functionN</classname> 对象上的同样操作，
      尽管需要额外的成员函数以允许函数对象的特有的拷贝构造和拷贝赋值。</para>
    </description>

    <typedef name="result_type"><type>R</type></typedef>
    <typedef name="argument_type">
      <type>T1</type><purpose>If N == 1</purpose>
    </typedef>
    <typedef name="first_argument_type">
      <type>T1</type>
      <purpose>If N == 2</purpose>
    </typedef>
    <typedef name="second_argument_type">
      <type>T2</type>
      <purpose>If N == 2</purpose>
    </typedef>
    <typedef name="arg1_type"><type>T1</type></typedef>
    <typedef name="arg2_type"><type>T2</type></typedef>
    <typedef name="..."><type/></typedef>
    <typedef name="argN_type"><type>TN</type></typedef>

    <static-constant name="arity">
      <type>int</type>
      <default>N</default>
    </static-constant>

    <struct name="sig">
      <template>
        <template-type-parameter name="Args"/>
      </template>

      <purpose>
        <simpara><libraryname>Lambda</libraryname> library support<sbr/>
        <libraryname>Lambda</libraryname> 库的支持</simpara>
      </purpose>

      <typedef name="type"><type>result_type</type></typedef>
    </struct>

    <constructor>
      <postconditions><simpara><code>this-&gt;<methodname>empty</methodname>()</code></simpara></postconditions>
      <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
    </constructor>

    <constructor>
      <parameter name="f">
        <paramtype>const <classname>functionN</classname>&amp;</paramtype>
      </parameter>
      <postconditions><simpara>Contains a copy of the <code>f</code>'s target, if it has one, or is empty if <code>f.<methodname>empty</methodname>()</code>.<sbr/>
      如果 <code>f</code> 有一个目标，则包含 <code>f</code> 的目标的一个拷贝，或者，
      如果 <code>f.<methodname>empty</methodname>()</code>，则为空。</simpara></postconditions>
      <throws><simpara>Will not throw unless copying the target of <code>f</code> throws.<sbr/>
      不会抛出异常，除非拷贝 <code>f</code> 的目标时抛出。</simpara></throws>
    </constructor>

    <constructor>
      <parameter name="f">
        <paramtype>const <classname>function</classname>&amp;</paramtype>
      </parameter>
      <postconditions><simpara>Contains a copy of the <code>f</code>'s target, if it has one, or is empty if <code>f.<methodname>empty</methodname>()</code>.<sbr/>
      如果 <code>f</code> 有一个目标，则包含 <code>f</code> 的目标的一个拷贝，或者，
      如果 <code>f.<methodname>empty</methodname>()</code>，则为空。</simpara></postconditions>
      <throws><simpara>Will not throw unless copying the target of <code>f</code> throws.<sbr/>
      不会抛出异常，除非拷贝 <code>f</code> 的目标时抛出。</simpara></throws>
    </constructor>

    <constructor>
      <template>
        <template-type-parameter name="F"/>
      </template>
      <parameter name="f"><paramtype>F</paramtype></parameter>
      <requires><simpara>F is a function object Callable from <code>this</code>.<sbr/>
      F 是一个可由 <code>this</code> 调用的函数对象。</simpara></requires>
      <postconditions><simpara><code>*this</code> targets a copy of <code>f</code> if <code>f</code> is nonempty, or <code>this-&gt;<methodname>empty</methodname>()</code> if <code>f</code> is empty.<sbr/>
       如果 <code>f</code> 非空，则 <code>*this</code> 以 <code>f</code> 的一个拷贝为目标，或者，
       如果 <code>f</code> 为空，则 <code>this-&gt;<methodname>empty</methodname>()</code>。</simpara></postconditions>
    </constructor>

    <constructor>
      <template>
        <template-type-parameter name="F"/>
        <template-type-parameter name="Allocator"/>
      </template>
      <parameter name="f"><paramtype>F</paramtype></parameter>
      <parameter name="alloc"><paramtype>Allocator</paramtype></parameter>
      <requires><simpara>F is a function object Callable from <code>this</code>, Allocator is an allocator. The copy constructor and destructor of Allocator shall not throw.<sbr/>
      F 是一个可以从 <code>this</code> 调用的函数对象，Allocator 是一个分配器。
      Allocator 的复制构造函数和析构函数不能抛出异常。</simpara></requires>
      <postconditions><simpara><code>*this</code> targets a copy of <code>f</code> if <code>f</code> is nonempty, or <code>this-&gt;<methodname>empty</methodname>()</code> if <code>f</code> is empty.<sbr/>
       如果 <code>f</code> 非空，则 <code>*this</code> 以 <code>f</code> 的一个拷贝为目标，或者，
       如果 <code>f</code> 为空，则 <code>this-&gt;<methodname>empty</methodname>()</code>。</simpara></postconditions>
      <effects><simpara>If memory allocation is required, the given allocator (or a copy of it) will be used to allocate that memory.<sbr/>
      如果需要分配内存，则给定的分配器(或它的一份拷贝)将被用于分配内存。</simpara></effects>
    </constructor>

    <destructor>
      <effects><simpara>If <code>!this-&gt;<methodname>empty</methodname>()</code>, destroys the target of <code>this</code>.<sbr/>
      如果 <code>!this-&gt;<methodname>empty</methodname>()</code>，销毁 <code>this</code> 的目标。</simpara></effects>

    </destructor>

    <copy-assignment>
      <parameter name="f">
        <paramtype>const <classname>function</classname>&amp;</paramtype>
      </parameter>
      <postconditions><simpara>If copy construction does not throw, <code>*this</code> targets a copy of <code>f</code>'s target, if it has one, or is empty if <code>f.<methodname>empty</methodname>()</code>. If copy construction does throw, <code>this-&gt;<methodname>empty</methodname>()</code>.<sbr/>
      如果拷贝构造不抛出异常，如果 <code>f</code> 有一个目标，则 <code>*this</code> 以 <code>f</code> 的目标的拷贝为目标，
      或者，如果 <code>f.<methodname>empty</methodname>()</code>，则为空。如果拷贝构造抛出异常，
      则 <code>this-&gt;<methodname>empty</methodname>()</code>。</simpara></postconditions>
    </copy-assignment>

    <copy-assignment>
      <parameter name="f">
        <paramtype>const <classname>function</classname>&amp;</paramtype>
      </parameter>
      <postconditions><simpara>If copy construction of the target of <code>f</code> does not throw, <code>*this</code> targets a copy of <code>f</code>'s target, if it has one, or is empty if <code>f.<methodname>empty</methodname>()</code>. <sbr/>
      如果拷贝构造不抛出异常，如果 <code>f</code> 有一个目标，则 <code>*this</code> 以 <code>f</code> 的目标的拷贝为目标，
      或者，如果 <code>f.<methodname>empty</methodname>()</code>，则为空。如果拷贝构造抛出异常，
      则 <code>this-&gt;<methodname>empty</methodname>()</code>。</simpara></postconditions>
      <throws><simpara>Will not throw when the target of <code>f</code> is a stateless function object or a reference to the function object. If copy construction does throw, <code>this-&gt;<methodname>empty</methodname>()</code>.<sbr/>
      当 f 的目标是一个 stateless 函数对象或者是一个引向函数对象的引用，则不抛出异常。</simpara></throws>
    </copy-assignment>

    <method-group name="modifiers">
      <method name="swap">
        <type>void</type>
        <parameter name="f"><paramtype>const <classname>function</classname>&amp;</paramtype></parameter>
        <effects><simpara>Interchanges the targets of <code>*this</code> and <code>f</code>.<sbr/>
        交换 <code>*this</code> 的目标和 <code>f</code>。</simpara></effects>
      </method>

      <method name="clear">
        <type>void</type>
        <postconditions><simpara><code>this-&gt;<methodname>empty</methodname>()</code></simpara></postconditions>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>
    </method-group>

    <method-group name="capacity">
      <method name="empty" cv="const">
        <type>bool</type>
        <returns><simpara><code>false</code> if <code>this</code> has a target, and <code>true</code> otherwise.<sbr/>
        如果 <code>this</code> 有一个目标，则为 <code>false</code>，否则，为 <code>true</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>

      <method name="conversion-operator" cv="const">
        <type>safe_bool</type>
        <returns><simpara>A <code>safe_bool</code> that evaluates <code>false</code> in a boolean context when <code>this-&gt;<methodname>empty</methodname>()</code>, and <code>true</code> otherwise.<sbr/>
        当 <code>this-&gt;<methodname>empty</methodname>()</code> 时，为一个在布尔上下文中求值为 <code>false</code> 
        的 <code>safe_bool</code>，否则，为求值为 <code>true</code> 的 <code>safe_bool</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>

      <method name="operator!" cv="const">
        <type>bool</type>
        <returns><simpara><code>this-&gt;<methodname>empty</methodname>()</code></simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>
    </method-group>

    <method-group name="target access">
      <overloaded-method name="target">
        <signature>
          <template> 
            <template-type-parameter name="Functor"/>
          </template>
          <type>Functor*</type>
        </signature>
        <signature cv="const">
          <template> 
            <template-type-parameter name="Functor"/>
          </template>
          <type>const Functor*</type>
        </signature>

        <returns><simpara>If <code>this</code> stores a target of type
        <code>Functor</code>, returns the address of the
        target. Otherwise, returns the NULL
        pointer.<sbr/>
        如果 <code>this</code> 存储一个类型为 <code>Functor</code> 的目标，
        则返回目标的地址。否则，返回 NULL 指针。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </overloaded-method>

      <method name="contains" cv="const">
        <template>
          <template-type-parameter name="Functor"/>
        </template>
        <type>bool</type>
        <parameter name="f">
          <paramtype>const Functor&amp;</paramtype>
        </parameter>
        <returns><simpara><code>true</code> if <code>this-&gt;<methodname>target</methodname>&lt;Functor&gt;()</code> is non-NULL and <code><functionname>function_equal</functionname>(*(this-&gt;target&lt;Functor&gt;()), f)</code><sbr/>
        如果 <code>this-&gt;<methodname>target</methodname>&lt;Functor&gt;()</code> 为非 NULL，
        而且 <code><functionname>function_equal</functionname>(*(this-&gt;target&lt;Functor&gt;()), f)</code>，
        则为 <code>true</code>。</simpara></returns>
 
      </method>

      <method name="target_type" cv="const">
        <type>const std::type_info&amp;</type>
        <returns><simpara><code>typeid</code> of the target function object, or <code>typeid(void)</code> if <code>this-&gt;<methodname>empty</methodname>()</code>.<sbr/>
        target function object（目标函数对象）的 <code>typeid</code>，或者，如果 
        <code>this-&gt;<methodname>empty</methodname>()</code>，则为 <code>typeid(void)</code>。</simpara></returns>
        <throws><simpara>will not throw<sbr/>不抛出异常</simpara></throws>
      </method>
    </method-group>

    <method-group name="invocation">
      <method name="operator()" cv="const">
        <type>result_type</type>
        <parameter name="a1"><paramtype>arg1_type</paramtype></parameter>
        <parameter name="a2"><paramtype>arg2_type</paramtype></parameter>
        <parameter><paramtype>...</paramtype></parameter>
        <parameter name="aN"><paramtype>argN_type</paramtype></parameter>
        <effects><simpara><code>f(a1, a2, ..., aN)</code>, where <code>f</code> is the target of <code>*this</code>.<sbr/>
        <code>f(a1, a2, ..., aN)</code>，其中 <code>f</code> 为 <code>*this</code> 的目标。</simpara></effects>
        <returns><simpara>if <code>R</code> is <code>void</code>, nothing is returned; otherwise, the return value of the call to <code>f</code> is returned.<sbr/>
        如果 <code>R</code> 为 <code>void</code>，什么都不返回，否则，为调用  <code>f</code> 时的返回值。</simpara></returns>
        <throws><simpara><code><classname>bad_function_call</classname></code> if <code>this-&gt;<methodname>empty</methodname>()</code>. Otherwise, may through any exception thrown by the target function <code>f</code>.<sbr/>
        如果 <code>this-&gt;<methodname>empty</methodname>()</code>，则抛出 
        <code><classname>bad_function_call</classname></code>。
        否则，为目标函数 <code>f</code> 所可能抛出的任何异常。</simpara></throws>
      </method>
    </method-group>

    <free-function-group name="specialized algorithms">
      <function name="swap">
        <template>
          <template-type-parameter name="Signature"/>
        </template>
        <type>void</type>
        <parameter name="f1"><paramtype><classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
        <parameter name="f2"><paramtype><classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
        <effects><simpara><code>f1.<methodname>swap</methodname>(f2)</code></simpara></effects>
      </function>
    </free-function-group>

    <free-function-group name="comparison operators">
      <overloaded-function name="operator==">
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="Signature1"/>
            <template-type-parameter name="Signature2"/>
          </template>
          <type>void</type>
          <parameter name="f1"><paramtype>const <classname>function</classname>&lt;Signature1&gt;&amp;</paramtype></parameter>
          <parameter name="f2"><paramtype>const <classname>function</classname>&lt;Signature2&gt;&amp;</paramtype></parameter>
        </signature>

        <returns><simpara>True when <code>f</code> stores an object of
        type <code>Functor</code> and one of the following conditions applies:<sbr/>
        当 <code>f</code> 存储了一个类型为 <code>Functor</code> 的对象，而且满足下列条件之一时，为 true：
          <itemizedlist>

            <listitem><simpara><code>g</code> is of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and <code>f.target&lt;Functor&gt;() == g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>.<sbr/>
            <code>g</code> 的类型是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且，<code>f.target&lt;Functor&gt;() == g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>。</simpara></listitem>

            <listitem><simpara><code>g</code> is not of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and <code><functionname>function_equals</functionname>(*(f.target&lt;Functor&gt;()), g)</code>.<sbr/>
            <code>g</code> 的类型不是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且，<code><functionname>function_equal</functionname>(*(f.target&lt;Functor&gt;()),
            g)</code>。</simpara></listitem>

          </itemizedlist>
          </simpara></returns>

        <notes><simpara><code><classname>function</classname></code>
        objects are not
        <conceptname>EqualityComparable</conceptname>.<sbr/>
        <code><classname>function</classname></code> 对象不是 
        <conceptname>EqualityComparable</conceptname>（可等值比较）的。</simpara></notes>

        <rationale><simpara>The <code>safe_bool</code> conversion
        opens a loophole whereby two <code>function</code>
        instances can be compared via <code>==</code>, although this
        is not feasible to implement. The undefined <code>void
        operator==</code> closes the loophole and ensures a
        compile-time or link-time error.<sbr/>
        <code>safe_bool</code> 转换打开一个漏洞，使得两个 <code>function</code> 
        实例可以通过 <code>==</code> 进行比较，尽管对于实现来说这是不可行的。
        未定义的 <code>void operator==</code> 封闭这个漏洞并确保一个编译时或连接时错误。</simpara></rationale>
      </overloaded-function>

      <overloaded-function name="operator!=">
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype>Functor</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="Signature"/>
            <template-type-parameter name="Functor"/>
          </template>
          <type>bool</type>
          <parameter name="g"><paramtype><classname>reference_wrapper</classname>&lt;Functor&gt;</paramtype></parameter>
          <parameter name="f"><paramtype>const <classname>function</classname>&lt;Signature&gt;&amp;</paramtype></parameter>
        </signature>        
        <signature>
          <template>
            <template-type-parameter name="Signature1"/>
            <template-type-parameter name="Signature2"/>
          </template>
          <type>void</type>
          <parameter name="f1"><paramtype>const <classname>function</classname>&lt;Signature1&gt;&amp;</paramtype></parameter>
          <parameter name="f2"><paramtype>const <classname>function</classname>&lt;Signature2&gt;&amp;</paramtype></parameter>
        </signature>

        <returns><simpara>True when <code>f</code> does not store an
        object of type <code>Functor</code> or it stores an object of
        type <code>Functor</code> and one of the following conditions
        applies:<sbr/>
        当 <code>f</code> 没有存储一个类型为 <code>Functor</code> 
        的对象时或者它存储一个类型为 <code>Functor</code> 的对象并满足下列条件之一时，为 true：
          <itemizedlist>

            <listitem><simpara><code>g</code> is of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and <code>f.target&lt;Functor&gt;() != g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>.<sbr/>
            <code>g</code> 的类型是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且 <code>f.target&lt;Functor&gt;() != g.<methodname
            alt="reference_wrapper::get_pointer">get_pointer</methodname>()</code>。</simpara></listitem>

            <listitem><simpara><code>g</code> is not of type
            <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>
            and <code>!<functionname>function_equal</functionname>(*(f.target&lt;Functor&gt;()), g)</code>.<sbr/>
            <code>g</code> 的类型不是 <code><classname>reference_wrapper</classname>&lt;Functor&gt;</code>，
            而且 <code>!<functionname>function_equal</functionname>(*(f.target&lt;Functor&gt;()), g)</code>。</simpara></listitem>

          </itemizedlist>
          </simpara></returns>

        <notes><simpara><code><classname>function</classname></code>
        objects are not
        <conceptname>EqualityComparable</conceptname>.<sbr/>
        <code><classname>function</classname></code> 对象不是 
        <conceptname>EqualityComparable</conceptname>（可等值比较）的。</simpara></notes>

        <rationale><simpara>The <code>safe_bool</code> conversion
        opens a loophole whereby two <code>function</code>
        instances can be compared via <code>!=</code>, although this
        is not feasible to implement. The undefined <code>void
        operator!=</code> closes the loophole and ensures a
        compile-time or link-time error.<sbr/>
        <code>safe_bool</code> 转换打开一个漏洞，使得两个 <code>function</code> 
        实例可以通过 <code>!=</code> 进行比较，尽管对于实现来说这是不可行的。
        未定义的 <code>void operator!=</code> 封闭这个漏洞并确保一个编译时或连接时错误。</simpara></rationale>
      </overloaded-function>
    </free-function-group>
  </class>
</namespace>
</header>

<header name="boost/function_equal.hpp">
  <namespace name="boost">
  <function name="function_equal">
    <template>
      <template-type-parameter name="F"/>
      <template-type-parameter name="G"/>
    </template>
    <type>bool</type>
    <parameter name="f">
      <paramtype>const F&amp;</paramtype>
    </parameter>
    <parameter name="g">
      <paramtype>const G&amp;</paramtype>
    </parameter>
    <purpose><simpara>Compare two function objects for equality.<sbr/>
    比较两个函数对象是否相等。</simpara></purpose>
    <returns><simpara><code>f == g</code>.</simpara></returns>
    <throws><simpara>Only if <code>f == g</code> throws.<sbr/>
    只有当 <code>f == g</code> 时才会抛出。</simpara></throws>
  </function>
  </namespace>
</header>
</library-reference>

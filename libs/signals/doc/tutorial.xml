<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<section last-revision="$Date: 2007-01-29 15:05:29 -0500 (Mon, 29 Jan 2007) $" id="signals.tutorial">
  <title>Tutorial 教程</title>

  <using-namespace name="boost"/>
  <using-namespace name="boost::signals"/>
  <using-class name="boost::signalN"/>

  <section>
    <title>How to Read this Tutorial 如何阅读本教程</title>
<para>This tutorial is not meant to be read linearly. Its top-level
structure roughly separates different concepts in the library
(e.g., handling calling multiple slots, passing values to and from
slots) and in each of these concepts the basic ideas are presented
first and then more complex uses of the library are described
later. Each of the sections is marked <emphasis>Beginner</emphasis>,
<emphasis>Intermediate</emphasis>, or <emphasis>Advanced</emphasis> to help guide the
reader. The <emphasis>Beginner</emphasis> sections include information that all
library users should know; one can make good use of the Signals
library after having read only the <emphasis>Beginner</emphasis> sections. The
<emphasis>Intermediate</emphasis> sections build on the <emphasis>Beginner</emphasis>
sections with slightly more complex uses of the library. Finally,
the <emphasis>Advanced</emphasis> sections detail very advanced uses of the
Signals library, that often require a solid working knowledge of
the <emphasis>Beginner</emphasis> and <emphasis>Intermediate</emphasis> topics; most users
will not need to read the <emphasis>Advanced</emphasis> sections.<sbr/>
本教程不是用来线性阅读的。 其顶层结构大致按库中不同的概念划分，（如处理多个插槽的调用、传值到插槽及回传），
并且在每一个概念中，首先介绍其基本思想，然后说明库较复杂的使用。 每个部分都标注了<emphasis>初级</emphasis>、
<emphasis>中级</emphasis>，或<emphasis>高级</emphasis>，以帮助指导读者。 
<emphasis>初级</emphasis>部分包括库的所有使用者都该了解的信息；只要阅读了初级部分，就可以很好地使用信号库。
<emphasis>中级</emphasis>部分建立在<emphasis>初级</emphasis>部分之上，是库的稍复杂的使用。
最后，<emphasis>高级</emphasis>部分详述了信号库很高级的应用，这往往需要对<emphasis>初级</emphasis>
和<emphasis>中级</emphasis>内容扎实的实践经验；大多数用户无需阅读<emphasis>高级</emphasis>部分。</para>
</section>

<section><title>Compatibility Note 对兼容性的注释</title> 

<para>Boost.Signals has two syntactical forms: the preferred form and
the compatibility form. The preferred form fits more closely with the
C++ language and reduces the number of separate template parameters
that need to be considered, often improving readability; however, the
preferred form is not supported on all platforms due to compiler
bugs. The compatible form will work on all compilers supported by
Boost.Signals. Consult the table below to determine which syntactic
form to use for your compiler. Users of Boost.Function, please note
that the preferred syntactic form in Signals is equivalent to that of
Function's preferred syntactic form.<sbr/>
Boost.Signals 有两种句法形式：首选形式和兼容形式。 首选形式能更紧密地适合C++语言，
并减少需要考虑的独立模板参数的个数，往往能提高可读性；然而，由于编译器的错误，
首选形式并非所有平台都支持。 兼容形式可工作于 Boost.Signals 支持的所有编译器。
参考下表，以确定为你的编译器使用哪种句法形式。 Boost.Function 的用户请注意，
Signals 中的首选句法形式等效于 Function 的首选句法形式。</para>

<para>If your compiler does not appear in this list, please try the
preferred syntax and report your results to the Boost list so that
we can keep this table up-to-date.<sbr/>
如果你的编译器不在这个清单上，请试用首选句法并向Boost列表报告你的结果，以使我们能保持更新该表。</para>

  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
            <itemizedlist>
              <listitem><para>GNU C++ 2.95.x, 3.0.x, 3.1.x</para></listitem>
              <listitem><para>Comeau C++ 4.2.45.2</para></listitem>
              <listitem><para>SGI MIPSpro 7.3.0</para></listitem>
              <listitem><para>Intel C++ 5.0, 6.0</para></listitem>
              <listitem><para>Compaq's cxx 6.2</para></listitem>
              <listitem><para>Microsoft Visual C++ 7.1</para></listitem>
            </itemizedlist>
          </entry>
          <entry>
            <itemizedlist>
              <listitem><para><emphasis>Any compiler supporting the preferred syntax<sbr/>
              支持首选句法的任意编译器</emphasis></para></listitem>
              <listitem><para>Microsoft Visual C++ 6.0, 7.0</para></listitem>
              <listitem><para>Borland C++ 5.5.1</para></listitem>
              <listitem><para>Sun WorkShop 6 update 2 C++ 5.3</para></listitem>
              <listitem><para>Metrowerks CodeWarrior 8.1</para></listitem>
            </itemizedlist>
          </entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
</section>

<section><title>Hello, World! (Beginner 初级)</title>
<para>The following example writes "Hello, World!" using signals and
slots. First, we create a signal <code>sig</code>, a signal that
takes no arguments and has a void return value. Next, we connect
the <code>hello</code> function object to the signal using the
<code>connect</code> method. Finally, use the signal
<code>sig</code> like a function to call the slots, which in turns
invokes <code>HelloWorld::operator()</code> to print "Hello,
World!".<sbr/>
下例将使用信号和插槽写出“Hello, World!”。首先，我们创建信号 <code>sig</code>，
该信号无参数并且返回值为空。接着，我们使用 <code>connect</code> 方法将 <code>hello</code> 函数对象连接到信号。
最后，像函数一样使用信号 <code>sig</code> 来调用插槽，它将转而调用 <code>HelloWorld::operator()</code> 打印 “Hello, World!”。</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
struct HelloWorld 
{
  void operator()() const 
  { 
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
  } 
};

// ...

// Signal with no arguments and a void return value
<classname>boost::signal</classname>&lt;void ()&gt; sig;

// Connect a HelloWorld slot
HelloWorld hello;
sig.<methodname>connect</methodname>(hello);

// Call all of the slots
sig();
</programlisting>
</entry>
<entry>
<programlisting>
struct HelloWorld 
{
  void operator()() const 
  { 
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
  } 
};

// ...

// Signal with no arguments and a void return value
<classname alt="boost::signalN">boost::signal0</classname>&lt;void&gt; sig;

// Connect a HelloWorld slot
HelloWorld hello;
sig.<methodname>connect</methodname>(hello);

// Call all of the slots
sig();
</programlisting>
</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
</section>

<section><title>Calling multiple slots 调用多个插槽</title>
<section><title>Connecting multiple slots (Beginner) 连接多个插槽（初级）</title>
<para>Calling a single slot from a signal isn't very interesting, so
we can make the Hello, World program more interesting by splitting
the work of printing "Hello, World!" into two completely separate
slots. The first slot will print "Hello" and may look like
this:<sbr/>
从信号调用单个插槽不是很有意思，因此我们将打印“Hello, World!”的工作拆分到两个完全独立的插槽，
让 Hello, World 程序更有趣点。 第一个插槽将打印“Hello”，可能看起来像这样：</para>
<programlisting>
struct Hello 
{
  void operator()() const
  {
    std::cout &lt;&lt; "Hello";
  }
};
</programlisting>
<para>The second slot will print ", World!" and a newline, to complete
the program. The second slot may look like this:<sbr/>
第二个插槽将打印“, World!”和换行，以完成该程序。第二个插槽可能看起来像这样：</para>
<programlisting>
struct World
{
  void operator()() const
  {
    std::cout &lt;&lt; ", World!" &lt;&lt; std::endl;
  }
};
</programlisting>
<para>Like in our previous example, we can create a signal
<code>sig</code> that takes no arguments and has a
<code>void</code> return value. This time, we connect both a
<code>hello</code> and a <code>world</code> slot to the same
signal, and when we call the signal both slots will be called.<sbr/>
和上个例子一样，我们创建信号 <code>sig</code>，它没有参数并且返回值为 <code>void</code>。
这次，我们将 <code>hello</code> 和 <code>world</code> 插槽都连接到同一个信号，
当我们调用该信号，两个插槽都将会被调用。</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
<classname>boost::signal</classname>&lt;void ()&gt; sig;

sig.<methodname>connect</methodname>(Hello());
sig.<methodname>connect</methodname>(World());

sig();
</programlisting>
</entry>
<entry>
<programlisting>
<classname alt="boost::signalN">boost::signal0</classname>&lt;void&gt; sig;

sig.<methodname>connect</methodname>(Hello());
sig.<methodname>connect</methodname>(World());

sig();
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
<para>By default, slots are called in first-in first-out (FIFO) order,
so the output of this program will be as expected:<sbr/>
默认情况下，插槽以先进先出（FIFO）的次序被调用，因此该程序的输出应该是：</para>
<programlisting>
Hello, World!
</programlisting>
</section>

<section><title>Ordering slot call groups (Intermediate) 插槽调用组排序（中级）</title>
<para>Slots are free to have side effects, and that can mean that some
slots will have to be called before others even if they are not connected in that order. The Boost.Signals
library allows slots to be placed into groups that are ordered in
some way. For our Hello, World program, we want "Hello" to be
printed before ", World!", so we put "Hello" into a group that must
be executed before the group that ", World!" is in. To do this, we
can supply an extra parameter at the beginning of the
<code>connect</code> call that specifies the group. Group values
are, by default, <code>int</code>s, and are ordered by the integer
&lt; relation. Here's how we construct Hello, World:<sbr/>
插槽可以有副作用，这意味着某些插槽必须在另一些之前调用，即使它们不是按那个次序连接的。
Boost.Signals 库允许插槽进行分组，并按某种方式排序编组。 对于我们的 Hello, World 程序，
我们要“Hello”在“, World!”之前打印，所以我们将“Hello”放入一个组，该组将在“, World!”所在组之前执行。
为了做到这一点，我们可以在 <code>connect</code> 调用的头部提供一个额外的参数，以指定编组。 
编组值默认为 <code>int</code>，并按整型的 &lt; 关系排序。 我们这样构造 Hello, World：</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
<classname>boost::signal</classname>&lt;void ()&gt; sig;
sig.<methodname>connect</methodname>(1, World());
sig.<methodname>connect</methodname>(0, Hello());
sig();
</programlisting>
</entry>
            <entry>
<programlisting>
<classname alt="boost::signalN">boost::signal0</classname>&lt;void&gt; sig;
sig.<methodname>connect</methodname>(1, World());
sig.<methodname>connect</methodname>(0, Hello());
sig();
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>This program will correctly print "Hello, World!", because the
<code>Hello</code> object is in group 0, which precedes group 1 where
the <code>World</code> object resides. The group
parameter is, in fact, optional. We omitted it in the first Hello,
World example because it was unnecessary when all of the slots are
independent. So what happens if we mix calls to connect that use the
group parameter and those that don't? The "unnamed" slots (i.e., those
that have been connected without specifying a group name) can be
placed at the front or back of the slot list (by passing
<code>boost::signals::at_front</code> or <code>boost::signals::at_back</code>
as the last parameter to <code><methodname
alt="boost::signalN::connect">connect</methodname></code>, respectively), and defaults to the end of the list. When
a group is specified, the final parameter describes where the slot
will be placed within the group ordering. If we add a new slot
to our example like this:<sbr/>
该程序将正确打印出“Hello, World!”，因为 <code>Hello</code> 对象在组 0，它在 <code>World</code> 对象所在的组 1 之前。 
编组参数实际上是可选的。在第一个 Hello World 例子中我们省略了它，因为当所有的插槽都独立时，编组是不必要的。 
那么，如果我们混合调用使用和不使用编组参数的连接会怎样？ “未命名”插槽（即那些连接时未指定组名的插槽）
可置于插槽链表的头部或尾部（通过向 <code><methodname alt="boost::signalN::connect">connect</methodname></code> 
分别传入 <code>boost::signals::at_front</code> 或 <code>boost::signals::at_back</code> 作为最后的参数），
而默认为链表的结尾。当指定了编组时，最后的参数描述的是插槽在组内的次序。如果在我们的例子中添加新的插槽，如下：</para>
<programlisting>
struct GoodMorning
{
  void operator()() const
  {
    std::cout &lt;&lt; "... and good morning!" &lt;&lt; std::endl;
  }
};

sig.<methodname>connect</methodname>(GoodMorning());
</programlisting>
<para>... we will get the result we wanted:<sbr/>
... 我们会得到想要的结果：</para>
<programlisting>
Hello, World!
... and good morning!
</programlisting>
</section>
</section>

<section><title>Passing values to and from slots 传值到插槽及回传</title>
<section><title>Slot Arguments (Beginner) 插槽的参数（初级）</title>
<para>Signals can propagate arguments to each of the slots they call.
For instance, a signal that propagates mouse motion events might
want to pass along the new mouse coordinates and whether the mouse
buttons are pressed.<sbr/>
信号可以向它们调用的每个插槽传递参数。例如，一个传递鼠标移动事件的信号可能要传入新的鼠标坐标以及是否按了鼠标键。</para>
<para>As an example, we'll create a signal that passes two
<code>float</code> arguments to its slots. Then we'll create a few
slots that print the results of various arithmetic operations on
these values.<sbr/>
例如，我们创建一个信号，它将传入两个 float 参数到它的插槽。然后我们再创建几个插槽，
打印对这两个参数进行算术运算的各种结果。</para>
<programlisting>
void print_sum(float x, float y)
{
  std::cout &lt;&lt; "The sum is " &lt;&lt; x+y &lt;&lt; std::endl;
}

void print_product(float x, float y)
{
  std::cout &lt;&lt; "The product is " &lt;&lt; x*y &lt;&lt; std::endl;
}

void print_difference(float x, float y)
{
  std::cout &lt;&lt; "The difference is " &lt;&lt; x-y &lt;&lt; std::endl;
}

void print_quotient(float x, float y)
{
  std::cout &lt;&lt; "The quotient is " &lt;&lt; x/y &lt;&lt; std::endl;
}
</programlisting>

  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
<classname>boost::signal</classname>&lt;void (float, float)&gt; sig;

sig.<methodname>connect</methodname>(&amp;print_sum);
sig.<methodname>connect</methodname>(&amp;print_product);
sig.<methodname>connect</methodname>(&amp;print_difference);
sig.<methodname>connect</methodname>(&amp;print_quotient);

sig(5, 3);
</programlisting>
</entry>
<entry>
<programlisting>
<classname alt="boost::signalN">boost::signal2</classname>&lt;void, float, float&gt; sig;

sig.<methodname>connect</methodname>(&amp;print_sum);
sig.<methodname>connect</methodname>(&amp;print_product);
sig.<methodname>connect</methodname>(&amp;print_difference);
sig.<methodname>connect</methodname>(&amp;print_quotient);

sig(5, 3);
</programlisting>
</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

<para>This program will print out the following:<sbr/>
该程序将打印输出如下：</para>
<programlisting>
The sum is 8
The product is 15
The difference is 2
The quotient is 1.66667
</programlisting>
<para>So any values that are given to <code>sig</code> when it is
called like a function are passed to each of the slots. We have to
declare the types of these values up front when we create the
signal. The type <code><classname>boost::signal</classname>&lt;void (float,
float)&gt;</code> means that the signal has a <code>void</code>
return value and takes two <code>float</code> values. Any slot
connected to <code>sig</code> must therefore be able to take two
<code>float</code> values.<sbr/>
当像函数一样调用 <code>sig</code> 时，输入它的任何值都传给了每一个插槽。
创建信号时，我们必须预先声明这些值的类型。类型 <code><classname>boost::signal</classname>&lt;void (float, float)&gt;</code> 
表明信号具有 <code>void</code> 返回值并接受两个 <code>float</code> 值。 
因此任何连接到 <code>sig</code> 的插槽都必须能够接受两个 <code>float</code> 值。</para>
</section>

<section><title>Signal Return Values (Advanced) 信号返回值（高级）</title>
<para>Just as slots can receive arguments, they can also return
values. These values can then be returned back to the caller of the
signal through a <firstterm>combiner</firstterm>. The combiner is a mechanism
that can take the results of calling slots (there many be no
results or a hundred; we don't know until the program runs) and
coalesces them into a single result to be returned to the caller.
The single result is often a simple function of the results of the
slot calls: the result of the last slot call, the maximum value
returned by any slot, or a container of all of the results are some
possibilities.<sbr/>
正如插槽可以接收参数，它们也可以返回值。然后这些值可以通过 <firstterm>合并器</firstterm> 返回给信号的调用者。
合并器是这样一种工具，它接收插槽调用的结果（可能没有结果，也可能有100个结果；程序运行时才知道），
并且把它们合并成单一的结果返回给调用者。 该单一的结果往往是插槽调用结果的一个简单函数，可能是：
最后的插槽调用的结果、所有插槽返回值的最大值，或包含所有结果的容器。</para>
<para>We can modify our previous arithmetic operations example
slightly so that the slots all return the results of computing the
product, quotient, sum, or difference. Then the signal itself can
return a value based on these results to be printed:<sbr/>
我们可以稍微修改前面的算术运算的例子，使插槽分别返回加减乘除的计算结果。
然后信号本身就可以根据这些结果返回一个值，并打印出来。</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
float product(float x, float y) { return x*y; }
float quotient(float x, float y) { return x/y; }
float sum(float x, float y) { return x+y; }
float difference(float x, float y) { return x-y; }

<classname>boost::signal</classname>&lt;float (float x, float y)&gt; sig;

sig.<methodname>connect</methodname>(&amp;product);
sig.<methodname>connect</methodname>(&amp;quotient);
sig.<methodname>connect</methodname>(&amp;sum);
sig.<methodname>connect</methodname>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</programlisting>
</entry>
<entry>
<programlisting>
float product(float x, float y) { return x*y; }
float quotient(float x, float y) { return x/y; }
float sum(float x, float y) { return x+y; }
float difference(float x, float y) { return x-y; }

<classname alt="boost::signalN">boost::signal2</classname>&lt;float, float, float&gt; sig;

sig.<methodname>connect</methodname>(&amp;product);
sig.<methodname>connect</methodname>(&amp;quotient);
sig.<methodname>connect</methodname>(&amp;sum);
sig.<methodname>connect</methodname>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>This example program will output <code>2</code>. This is because the
default behavior of a signal that has a return type
(<code>float</code>, the first template argument given to the
<code><classname>boost::signal</classname></code> class template) is to call all slots and
then return the result returned by the last slot called. This
behavior is admittedly silly for this example, because slots have
no side effects and the result is the last slot connect.<sbr/>
该例程将输出 <code>2</code>。这是因为具有返回类型（<code>float</code>，
即输入 <code><classname>boost::signal</classname></code> 类模板的第一个模板参数）的信号的默认行为是，
调用所有的插槽，然后返回最后一个被调用插槽的结果。对本例来说，该行为确实有点傻，
因为这些插槽没有副作用，所以结果就是最后连接的插槽。</para>
<para>A more interesting signal result would be the maximum of the
values returned by any slot. To do this, we create a custom
combiner that looks like this:<sbr/>
求所有插槽返回值的最大值，这样的信号结果才有点意思。为些，我们创建一个自定义合并器如下：</para>
<programlisting>
template&lt;typename T&gt;
struct maximum
{
  typedef T result_type;

  template&lt;typename InputIterator&gt;
  T operator()(InputIterator first, InputIterator last) const
  {
    // If there are no slots to call, just return the
    // default-constructed value
    if (first == last)
      return T();

    T max_value = *first++;
    while (first != last) {
      if (max_value &lt; *first)
        max_value = *first;
      ++first;
    }
  
    return max_value;
  }
};
</programlisting>
<para>The <code>maximum</code> class template acts as a function
object. Its result type is given by its template parameter, and
this is the type it expects to be computing the maximum based on
(e.g., <code>maximum&lt;float&gt;</code> would find the maximum
<code>float</code> in a sequence of <code>float</code>s). When a
<code>maximum</code> object is invoked, it is given an input
iterator sequence <code>[first, last)</code> that includes the
results of calling all of the slots. <code>maximum</code> uses this
input iterator sequence to calculate the maximum element, and
returns that maximum value.<sbr/>
<code>maximum</code> 类模板就像一个函数对象。它的结果类型由其模板参数给出，
并且它正是基于该类型计算最大值（例如，<code>maximum&lt;float&gt;</code> 将在一系列 
<code>float</code> 中查找最大的 <code>float</code>）。当调用 <code>maximum</code> 对象时，
将给出一个输入迭代器序列 <code>[first, last)</code>，其中包含了所有插槽调用的结果。
<code>maximum</code> 利用该输入迭代器序列来计算最大元素，并返回那个最大值。</para>
<para>We actually use this new function object type by installing it
as a combiner for our signal. The combiner template argument
follows the signal's calling signature:<sbr/>
我们要把这个新的函数对象作为合并器安装到我们的信号，才能实际使用它。
合并器模板参数跟在信号的调用签名式之后。</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
<classname>boost::signal</classname>&lt;float (float x, float y), 
              maximum&lt;float&gt; &gt; sig;
</programlisting>
</entry>
<entry>
<programlisting>
<classname alt="boost::signalN">boost::signal2</classname>&lt;float, float, float, 
               maximum&lt;float&gt; &gt; sig;
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>Now we can connect slots that perform arithmetic functions and
use the signal:<sbr/>
现在我们可以连接执行算术功能的插槽并使用信号了：</para>
<programlisting>
sig.<methodname>connect</methodname>(&amp;quotient);
sig.<methodname>connect</methodname>(&amp;product);
sig.<methodname>connect</methodname>(&amp;sum);
sig.<methodname>connect</methodname>(&amp;difference);

std::cout &lt;&lt; sig(5, 3) &lt;&lt; std::endl;
</programlisting>
<para>The output of this program will be <code>15</code>, because
regardless of the order in which the slots are connected, the product
of 5 and 3 will be larger than the quotient, sum, or
difference.<sbr/>
该程序的输出为 <code>15</code>，因为不管插槽的连接次序如何，
5 和 3 的乘积将大于商、和，或差。</para>
<para>In other cases we might want to return all of the values
computed by the slots together, in one large data structure. This
is easily done with a different combiner:<sbr/>
在其他情况下，我们可能需要同时返回插槽计算的所有值，如保存在一个大型的数据结构中。
用一个不同的合并器就可以轻松做到：</para>
<programlisting>
template&lt;typename Container&gt;
struct aggregate_values
{
  typedef Container result_type;

  template&lt;typename InputIterator&gt;
  Container operator()(InputIterator first, InputIterator last) const
  {
    return Container(first, last);
  }
};
</programlisting>
<para>
Again, we can create a signal with this new combiner: <sbr/>
我们再次用这个新的合并器创建信号：
</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
<classname>boost::signal</classname>&lt;float (float, float), 
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;

sig.<methodname>connect</methodname>(&amp;quotient);
sig.<methodname>connect</methodname>(&amp;product);
sig.<methodname>connect</methodname>(&amp;sum);
sig.<methodname>connect</methodname>(&amp;difference);

std::vector&lt;float&gt; results = sig(5, 3);
std::copy(results.begin(), results.end(), 
    std::ostream_iterator&lt;float&gt;(cout, " "));
</programlisting>
</entry>
<entry>
<programlisting>
<classname alt="boost::signalN">boost::signal2</classname>&lt;float, float, float,
    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;

sig.<methodname>connect</methodname>(&amp;quotient);
sig.<methodname>connect</methodname>(&amp;product);
sig.<methodname>connect</methodname>(&amp;sum);
sig.<methodname>connect</methodname>(&amp;difference);

std::vector&lt;float&gt; results = sig(5, 3);
std::copy(results.begin(), results.end(), 
    std::ostream_iterator&lt;float&gt;(cout, " "));
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>The output of this program will contain 15, 8, 1.6667, and 2. It
is interesting here that
the first template argument for the <code>signal</code> class,
<code>float</code>, is not actually the return type of the signal.
Instead, it is the return type used by the connected slots and will
also be the <code>value_type</code> of the input iterators passed
to the combiner. The combiner itself is a function object and its
<code>result_type</code> member type becomes the return type of the
signal.<sbr/>
该程序的输出将包含 15、8、1.6667，和 2。有趣的是，<code>signal</code> 类的第一个模板参数，
<code>float</code>，竟然不是信号的返回类型。相反，该参数是所连接插槽的返回类型，
并且它也是传入合并器的输入迭代器的 <code>value_type</code>。合并器本身是个函数对象，
并且它的 <code>result_type</code> 成员类型将成为信号的返回类型。</para>
<para>The input iterators passed to the combiner transform dereference
operations into slot calls. Combiners therefore have the option to
invoke only some slots until some particular criterion is met. For
instance, in a distributed computing system, the combiner may ask
each remote system whether it will handle the request. Only one
remote system needs to handle a particular request, so after a
remote system accepts the work we do not want to ask any other
remote systems to perform the same task. Such a combiner need only
check the value returned when dereferencing the iterator, and
return when the value is acceptable. The following combiner returns
the first non-NULL pointer to a <code>FulfilledRequest</code> data
structure, without asking any later slots to fulfill the
request:<sbr/>
传给合并器的输入迭代器会将解引用操作转换为插槽调用。因此合并器可选择仅调用某些符合特定条件的插槽。
例如，在分布计算系统中，合并器可能会询问每个远程系统能否处理请求。对于一个特定请求，
仅需一个远程系统进行处理，因此当一个远程系统接受该工作后，我们将不再要求任何其他远程系统来做同一个任务。
这样一个合并器只需检查迭代器解引用的返回值，并当该值可以接受时就返回。
以下的合并器返回第一个指向 <code>FulfilledRequest</code> 数据结构的非空指针，而不必要求任何以后的插槽来完成请求：</para>
<programlisting>
struct DistributeRequest {
  typedef FulfilledRequest* result_type;

  template&lt;typename InputIterator&gt;
  result_type operator()(InputIterator first, InputIterator last) const
  {
    while (first != last) {
      if (result_type fulfilled = *first)
        return fulfilled;
      ++first;
    }
    return 0;
  }
};
</programlisting>
</section>
</section>

<section><title>Connection Management 连接管理</title>
<section><title>Disconnecting Slots (Beginner) 断开插槽（初级）</title>
<para>Slots aren't expected to exist indefinately after they are
connected. Often slots are only used to receive a few events and
are then disconnected, and the programmer needs control to decide
when a slot should no longer be connected.<sbr/>
插槽在连接之后不必无限期地存在。插槽往往只是用来接收一些事件然后断开，
当插槽不再需要保持连接时，程序员可以做出决定并控制。</para>
<para>The entry point for managing connections explicitly is the
<code><classname>boost::signals::connection</classname></code> class. The
<code><classname>connection</classname></code> class uniquely represents the connection
between a particular signal and a particular slot. The
<code><methodname alt="connection::connected">connected</methodname>()</code> method checks if the signal and slot are
still connected, and the <code><methodname alt="connection::disconnect">disconnect()</methodname></code> method
disconnects the signal and slot if they are connected before it is
called. Each call to the signal's <code>connect()</code> method
returns a connection object, which can be used to determine if the
connection still exists or to disconnect the signal and slot.<sbr/>
显式管理连接的入口点是 <code><classname>boost::signals::connection</classname></code> 类。 
<code><classname>connection</classname></code> 类唯一代表了特定信号与特定插槽之间的连接。 
<code><methodname alt="connection::connected">connected</methodname>()</code> 方法检查信号与插槽是否仍保持连接，
如果信号与插槽是连接着的，<code><methodname alt="connection::disconnect">disconnect()</methodname></code> 方法断开它们的连接。
每次调用信号的 <code>connect()</code> 方法，就返回一个连接对象，该对象用于确定连接是否仍然存在，或者用于断开信号和插槽。</para>
<programlisting>
boost::signals::connection c = sig.<methodname>connect</methodname>(HelloWorld());
if (c.<methodname>connected</methodname>()) {
<emphasis>// c is still connected to the signal</emphasis>
  sig(); <emphasis>// Prints "Hello, World!"</emphasis>
}

c.disconnect(); <emphasis>// Disconnect the HelloWorld object</emphasis>
assert(!c.<methodname>connected</methodname>()); <emphasis>c isn't connected any more</emphasis>

sig(); <emphasis>// Does nothing: there are no connected slots</emphasis>
</programlisting>
</section>

<section><title>Blocking Slots (Beginner) 阻塞插槽（初级）</title> 

<para>Slots can be temporarily "blocked", meaning that they will be
ignored when the signal is invoked but have not been disconnected. The
<code><methodname>block</methodname></code> member function
temporarily blocks a slot, which can be unblocked via
<code><methodname>unblock</methodname></code>. Here is an example of
blocking/unblocking slots:<sbr/>
插槽可以被临时“阻塞”，即当信号被调用时，这些插槽将被忽略，但并没有被断开。
<code><methodname>block</methodname></code> 成员函数临时地阻塞一个插槽，
可通过 <code><methodname>unblock</methodname></code> 解除阻塞。这是一个阻塞/开启插槽的例子：</para>

<programlisting>
boost::signals::connection c = sig.<methodname>connect</methodname>(HelloWorld());
sig(); <emphasis>// Prints "Hello, World!"</emphasis>

c.<methodname>block</methodname>(); <emphasis>// block the slot</emphasis>
assert(c.<methodname>blocked</methodname>());
sig(); <emphasis>// No output: the slot is blocked</emphasis>

c.<methodname>unblock</methodname>(); <emphasis>// unblock the slot</emphasis>
sig(); <emphasis>// Prints "Hello, World!"</emphasis>
</programlisting>

</section>

<section><title>Scoped connections (Intermediate) 域内连接（中级）</title>
<para>The <code>boost::signals::scoped_connection</code> class
references a signal/slot connection that will be disconnected when
the <code>scoped_connection</code> class goes out of scope. This
ability is useful when a connection need only be temporary,
e.g.,<sbr/>
<code>boost::signals::scoped_connection</code> 类引用了一个信号/插槽的连接，
当 <code>scoped_connection</code> 类出作用域时，该连接将会被断开。 
当仅需临时连接时，该功能很有用，如：</para>
<programlisting>
{
  boost::signals::scoped_connection c = sig.<methodname>connect</methodname>(ShortLived());
  sig(); <emphasis>// will call ShortLived function object</emphasis>
}
sig(); <emphasis>// ShortLived function object no longer connected to sig</emphasis>
</programlisting>
</section>

<section><title>Disconnecting equivalent slots (Intermediate) 断开等价的插槽（中级）</title>
<para>One can disconnect slots that are equivalent to a given function
object using a form of the
<code><methodname>disconnect</methodname></code> method, so long as
the type of the function object has an accessible <code>==</code>
operator. For instance:<sbr/>
你可以使用 <code><methodname>disconnect</methodname></code> 方法断开与给定函数对象等价的多个插槽，
只要该函数对象的类型具有可访问的 <code>==</code> 运算符。例如：
</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
void foo();
void bar();

signal&lt;void()&gt; sig;

sig.connect(&amp;foo);
sig.connect(&amp;bar);

// disconnects foo, but not bar
sig.disconnect(&amp;foo);
</programlisting>
</entry>
<entry>
<programlisting>
void foo();
void bar();

signal0&lt;void&gt; sig;

sig.connect(&amp;foo);
sig.connect(&amp;bar);

// disconnects foo, but not bar
sig.disconnect(&amp;foo);
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

</section>

<section><title>Automatic connection management (Intermediate) 自动连接管理（中级）</title>
<para>Boost.Signals can automatically track the lifetime of objects
involved in signal/slot connections, including automatic
disconnection of slots when objects involved in the slot call are
destroyed. For instance, consider a simple news delivery service,
where clients connect to a news provider that then sends news to
all connected clients as information arrives. The news delivery
service may be constructed like this: <sbr/>
Boost.Signals 能自动跟踪信号/插槽连接中所涉及对象的生命期，包括当插槽调用中涉及的对象销毁时自动断开插槽。 
例如，考虑一个简单的新闻发送服务，其中客户会连接到新闻提供者，而新闻提供者一有信息到达，就发送新闻到所有连接的客户。
该新闻发送服务可能像这样构造：</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
class NewsItem { /* ... */ };

boost::signal&lt;void (const NewsItem&amp;)&gt; deliverNews;
</programlisting>
</entry>
<entry>
<programlisting>
class NewsItem { /* ... */ };

boost::signal1&lt;void, const NewsItem&amp;&gt; deliverNews;
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>Clients that wish to receive news updates need only connect a
function object that can receive news items to the
<code>deliverNews</code> signal. For instance, we may have a
special message area in our application specifically for news,
e.g.,:<sbr/>
希望接收新闻更新的客户只需连接一个函数对象，该对象可以接收传给 <code>deliverNews</code> 信号的新闻条目，例如：</para>
<programlisting>
struct NewsMessageArea : public MessageArea
{
public:
  // ...

  void displayNews(const NewsItem&amp; news) const
  {
    messageText = news.text();
    update();
  }
};

// ...
NewsMessageArea newsMessageArea = new NewsMessageArea(/* ... */);
// ...
deliverNews.<methodname>connect</methodname>(boost::bind(&amp;NewsMessageArea::displayNews, 
                                newsMessageArea, _1));
</programlisting>
<para>However, what if the user closes the news message area,
destroying the <code>newsMessageArea</code> object that
<code>deliverNews</code> knows about? Most likely, a segmentation
fault will occur. However, with Boost.Signals one need only make
<code>NewsMessageArea</code> <emphasis>trackable</emphasis>, and the slot
involving <code>newsMessageArea</code> will be disconnected when
<code>newsMessageArea</code> is destroyed. The
<code>NewsMessageArea</code> class is made trackable by deriving
publicly from the <code>boost::signals::trackable</code> class,
e.g.:<sbr/>
不过，如果用户关闭新闻讯息区，销毁了 <code>deliverNews</code> 所知的 <code>newsMessageArea</code> 对象，那会怎么样？ 
最有可能的是产生段错误。然而，你只需在使用 Boost.Signals 时，让 <code>NewsMessageArea</code> <emphasis>可跟踪</emphasis>，
那么当 <code>newsMessageArea</code> 被销毁时，调用 <code>newsMessageArea</code> 的插槽就会被断开。
通过公有继承自 <code>boost::signals::trackable</code> 类，<code>NewsMessageArea</code> 类就会变成可跟踪的，例如：</para>
<programlisting>
struct NewsMessageArea : public MessageArea, public boost::signals::trackable
{
  // ...
};
</programlisting>
<para>At this time there is a significant limitation to the use of
<code>trackable</code> objects in making slot connections: function
objects built using Boost.Bind are understood, such that pointers
or references to <code>trackable</code> objects passed to
<code>boost::bind</code> will be found and tracked.<sbr/>
目前，用 <code>trackable</code> 对象制作插槽连接有个重要的限制：它理解使用 Boost.Bind 构建的函数对象，
如传入 <code>boost::bind</code> 的 <code>trackable</code> 对象指针或引用将会被发现和跟踪。</para>
<para><emphasis role="bold">Warning</emphasis>: User-defined function objects and function
objects from other libraries (e.g., Boost.Function or Boost.Lambda)
do not implement the required interfaces for <code>trackable</code>
object detection, and <emphasis>will silently ignore any bound trackable
objects</emphasis>. Future versions of the Boost libraries will address
this limitation.<sbr/>
<emphasis role="bold">警告</emphasis>：用户自定义函数对象和来自其他库的函数对象（例如来自 Boost.Function 或 Boost.Lambda）， 没有实现所要求的 <code>trackable</code> 对象检测接口，<emphasis>将会默默地忽略任何绑定的可跟踪对象</emphasis>。 Boost库的未来版本将会解除该限制。</para>
</section>

<section><title>When can disconnections occur? (Intermediate) 何时断开？（中级）</title>
<para>Signal/slot disconnections occur when any of these conditions
occur:<sbr/>
以下任一条件发生时，信号/插槽将断开：</para>
<itemizedlist>
<listitem><para>The connection is explicitly disconnected via the connection's
<code>disconnect</code> method directly, or indirectly via the
signal's <code>disconnect</code> method or
<code>scoped_connection</code>'s destructor.<sbr/>
连接被显式地断开：直接通过连接的 <code>disconnect</code> 方法， 或间接地通过信号的 
<code>disconnect</code> 方法或 <code>scoped_connection</code> 的析构函数。</para></listitem>
<listitem><para>A <code>trackable</code> object bound to the slot is
destroyed.<sbr/>
绑定于插槽的 <code>trackable</code> 对象被销毁。</para></listitem>
<listitem><para>The signal is destroyed.<sbr/>
信号被销毁。</para></listitem></itemizedlist>
<para>These events can occur at any time without disrupting a signal's
calling sequence. If a signal/slot connection is disconnected at
any time during a signal's calling sequence, the calling sequence
will still continue but will not invoke the disconnected slot.
Additionally, a signal may be destroyed while it is in a calling
sequence, and which case it will complete its slot call sequence
but may not be accessed directly.<sbr/>
这些事件可以发生于任何时间，而不会破坏信号的调用序列。如果信号/插槽的连接在信号调用序列的任意时刻被断开，
调用序列仍将继续，只是不会调用被断开的插槽。此外，信号可以在调用序列中间被销毁，这时，
它将完成其插槽调用序列，只是不可以被直接访问。</para>
<para>Signals may be invoked recursively (e.g., a signal A calls a
slot B that invokes signal A...). The disconnection behavior does
not change in the recursive case, except that the slot calling
sequence includes slot calls for all nested invocations of the
signal.<sbr/>
信号可以被递归调用（例如，信号A调用插槽B，而插槽B又调用信号A……）。递归情况下，
断开的行为不会改变，只是插槽调用序列包括所有嵌套的信号调用。</para>
</section>

<section><title>Passing slots (Intermediate) 传递插槽（中级）</title>
<para>Slots in the Boost.Signals library are created from arbitrary
function objects, and therefore have no fixed type. However, it is
commonplace to require that slots be passed through interfaces that
cannot be templates. Slots can be passed via the
<code>slot_type</code> for each particular signal type and any
function object compatible with the signature of the signal can be
passed to a <code>slot_type</code> parameter. For instance:<sbr/>
Boost.Signals 库中的插槽可以从任意的函数对象创建，因此没有固定的类型。 
不过通常要求通过不可模板化的接口传递插槽。对于每个特定的信号类型，
都可以通过 <code>slot_type</code> 传递插槽，而与信号的签名式兼容的任意函数对象，
都可以传给 <code>slot_type</code> 参数。例如：</para>
  <informaltable>
    <tgroup cols="2" align="left">
      <thead>
        <row>
          <entry>Preferred syntax 首选句法</entry>
          <entry>Portable syntax 兼容句法</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
<programlisting>
class Button 
{
  typedef boost::signal&lt;void (int x, int y)&gt; OnClick;

public:
  void doOnClick(const OnClick::slot_type&amp; slot);

private:
  OnClick onClick;
};

void Button::doOnClick(
      const OnClick::slot_type&amp; slot
    )
{
  onClick.<methodname>connect</methodname>(slot);
}

void printCoordinates(long x, long y)
{
  std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")\n";
}

void f(Button&amp; button)
{
  button.doOnClick(&amp;printCoordinates);
}
</programlisting>
</entry>
<entry>
<programlisting>
class Button 
{
  typedef <classname alt="boost::signalN">boost::signal2</classname>&lt;void,int,int&gt; OnClick;

public:
  void doOnClick(const OnClick::slot_type&amp; slot);

private:
  OnClick onClick;
};

void Button::doOnClick(
      const OnClick::slot_type&amp; slot
    )
{
  onClick.<methodname>connect</methodname>(slot);
}

void printCoordinates(long x, long y)
{
  std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")\n";
}

void f(Button&amp; button)
{
  button.doOnClick(&amp;printCoordinates);
}
</programlisting>
</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

<para>The <code>doOnClick</code> method is now functionally equivalent
to the <code>connect</code> method of the <code>onClick</code>
signal, but the details of the <code>doOnClick</code> method can be
hidden in an implementation detail file.<sbr/>
<code>doOnClick</code> 方法现在功能上等效于 <code>onClick</code> 信号的 <code>connect</code> 方法，
但是 <code>doOnClick</code> 方法的细节可以隐藏于细节实现文件中。 </para>
</section>
</section>

<section>
  <title>Example: Document-View 例子：文档-视图</title>
  
  <para>Signals can be used to implement flexible Document-View
  architectures. The document will contain a signal to which each of
  the views can connect. The following <code>Document</code> class
  defines a simple text document that supports mulitple views. Note
  that it stores a single signal to which all of the views will be
  connected.<sbr/>
  信号可用于实现灵活的文档-视图（Document-View）架构。文档包含一个信号，
  而每个视图连接该信号。下面的 <code>Document</code> 类定义了一个简单的支持多视图的文本文档。 
  注意它保存了一个单一的信号，所有视图都连接到该信号。</para>

  <programlisting>class Document
{
public:
    typedef boost::signal&lt;void (bool)&gt;  signal_t;
    typedef boost::signals::connection  connection_t;

public:
    Document()
    {}

    connection_t connect(signal_t::slot_function_type subscriber)
    {
        return m_sig.connect(subscriber);
    }

    void disconnect(connection_t subscriber)
    {
        subscriber.disconnect();
    }

    void append(const char* s)
    {
        m_text += s;
        m_sig(true);
    }

    const std::string&amp; getText() const
    {
        return m_text;
    }

private:
    signal_t    m_sig;
    std::string m_text;
};</programlisting>

  <para>Next, we can define a <code>View</code> base class from which
  views can derive. This isn't strictly required, but it keeps the
  Document-View logic separate from the logic itself. Note that the
  constructor just connects the view to the document and the
  destructor disconnects the view.<sbr/>
  接下来，我们可以定义视图的基类 <code>View</code>。这并非严格需要，
  但它能让文档-视图的逻辑与逻辑本身分离。注意构造函数仅仅连接视图到文档，
  而析构函数断开视图。</para>

  <programlisting>
class View
{
public:
    View(Document&amp; m)
        : m_document(m)
    {
        m_connection = m_document.connect(boost::bind(&amp;View::refresh, this, _1));
    }

    virtual ~View()
    {
        m_document.disconnect(m_connection);
    }

    virtual void refresh(bool bExtended) const = 0;

protected:
    Document&amp;               m_document;

private:
    Document::connection_t  m_connection;
};
  </programlisting>

  <para>Finally, we can begin to define views. The
  following <code>TextView</code> class provides a simple view of the
    document text.<sbr/>
    最后，我们可以开始定义视图。下面的 <code>TextView</code> 类提供了文档文本的一个简单视图。</para>

  <programlisting>class TextView : public View
{
public:
    TextView(Document&amp; doc)
        : View(doc)
    {}

    virtual void refresh(bool bExtended) const
    {
        std::cout &lt;&lt; "TextView: " &lt;&lt; m_document.getText() &lt;&lt; std::endl;
    }
};</programlisting>

  <para>Alternatively, we can provide a view of the document
    translated into hex values using the <code>HexView</code>
    view:<sbr/>
    此外，我们可以提供文档翻译成16进制后的视图，如 <code>HexView</code> 视图：</para>

  <programlisting>class HexView : public View
{
public:
    HexView(Document&amp; doc)
        : View(doc)
    {}

    virtual void refresh(bool bExtended) const
    {
        const std::string&amp;  s = m_document.getText();

        std::cout &lt;&lt; "HexView:";

        for (std::string::const_iterator it = s.begin(); it != s.end(); ++it)
            std::cout &lt;&lt; ' ' &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(*it);

        std::cout &lt;&lt; std::endl;
    }
};</programlisting>

  <para>To tie the example together, here is a
  simple <code>main</code> function that sets up two views and then
    modifies the document:<sbr/>
    为了把例子串起来，有个简单的 <code>main</code> 函数，它建立了两个视图，然后更改文档：</para>

  <programlisting>int main(int argc, char* argv[])
{
    Document    doc;
    TextView    v1(doc);
    HexView     v2(doc);

    doc.append(argc == 2 ? argv[1] : "Hello world!");
    return 0;
}</programlisting>

  <para>The complete example source, contributed by Keith MacDonald,
    is available in <ulink
    url="../../libs/signals/example/doc_view.cpp"><code>libs/signals/example/doc_view.cpp</code></ulink>.<sbr/>
    完整的例程源码，由 Keith MacDonald 提供，在 <ulink url="../../libs/signals/example/doc_view.cpp">
    <code>libs/signals/example/doc_view.cpp</code></ulink>。</para>
</section>

<section>
  <title>Linking against the Signals library 链接信号库</title>

  <para>Part of the Boost.Signals library is compiled into a binary
  library that must be linked into your application to use
  Signals. Please refer to
    the <ulink url="../../more/getting_started.html">Getting Started</ulink>
  guide. You will need to link against the <code>boost_signals</code>
  library.<sbr/>
  Boost.Signals 库要编译成二进制库， 为使用信号库，应用程序必须链接该二进制库。请参考 
  <ulink url="../../more/getting_started.html">Getting Started</ulink> 指导。
  你将需要链接 <code>boost_signals</code> 库。</para>
</section>

</section>

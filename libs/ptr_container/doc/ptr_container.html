<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" /><title>Boost Pointer Container Library</title>

<meta name="author" content="Thorsten Ottosen" />
<meta name="date" content="27th of October 2007" />
<meta name="copyright" content="Thorsten Ottosen 2004-2007. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt)." />
<style type="text/css">
/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2007-11-25 13:38:02 -0500 (Sun, 25 Nov 2007) $
:Revision: $Revision: 41370 $
:Copyright: This stylesheet has been placed in the public domain.
Default cascading style sheet for the HTML output of Docutils.
See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/
/* "! important" is used here to override other ``margin-top`` and
``margin-bottom`` styles that are later in the stylesheet or more specific. See http://www.w3.org/TR/CSS1#the-cascade */
.first {
margin-top: 0 ! important }
.last, .with-subtitle {
margin-bottom: 0 ! important }
.hidden {
display: none }
a.toc-backref {
text-decoration: none ;
color: black }
blockquote.epigraph {
margin: 2em 5em ; }
dl.docutils dd {
margin-bottom: 0.5em }
/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
font-weight: bold }
*/
div.abstract {
margin: 2em 5em }
div.abstract p.topic-title {
font-weight: bold ;
text-align: center }
div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
margin: 2em ;
border: medium outset ;
padding: 1em }
div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
font-weight: bold ;
font-family: sans-serif }
div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
color: red ;
font-weight: bold ;
font-family: sans-serif }
/* Uncomment (and remove this text!) to get reduced vertical space in
compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
margin-bottom: 0.5em }
div.compound .compound-last, div.compound .compound-middle {
margin-top: 0.5em }
*/
div.dedication {
margin: 2em 5em ;
text-align: center ;
font-style: italic }
div.dedication p.topic-title {
font-weight: bold ;
font-style: normal }
div.figure {
margin-left: 2em }
div.footer, div.header {
clear: both;
font-size: smaller }
div.line-block {
display: block ;
margin-top: 1em ;
margin-bottom: 1em }
div.line-block div.line-block {
margin-top: 0 ;
margin-bottom: 0 ;
margin-left: 1.5em }
div.sidebar {
margin-left: 1em ;
border: medium outset ;
padding: 1em ;
background-color: #ffffee ;
width: 40% ;
float: right ;
clear: right }
div.sidebar p.rubric {
font-family: sans-serif ;
font-size: medium }
div.system-messages {
margin: 5em }
div.system-messages h1 {
color: red }
div.system-message {
border: medium outset ;
padding: 1em }
div.system-message p.system-message-title {
color: red ;
font-weight: bold }
div.topic {
margin: 2em }
h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
margin-top: 0.4em }
h1.title {
text-align: center }
h2.subtitle {
text-align: center }
hr.docutils {
width: 75% }
img.align-left {
clear: left }
img.align-right {
clear: right }
img.borderless {
border: 0 }
ol.simple, ul.simple {
margin-bottom: 1em }
ol.arabic {
list-style: decimal }
ol.loweralpha {
list-style: lower-alpha }
ol.upperalpha {
list-style: upper-alpha }
ol.lowerroman {
list-style: lower-roman }
ol.upperroman {
list-style: upper-roman }
p.attribution {
text-align: right ;
margin-left: 50% }
p.caption {
font-style: italic }
p.credits {
font-style: italic ;
font-size: smaller }
p.label {
white-space: nowrap }
p.rubric {
font-weight: bold ;
font-size: larger ;
color: maroon ;
text-align: center }
p.sidebar-title {
font-family: sans-serif ;
font-weight: bold ;
font-size: larger }
p.sidebar-subtitle {
font-family: sans-serif ;
font-weight: bold }
p.topic-title {
font-weight: bold }
pre.address {
margin-bottom: 0 ;
margin-top: 0 ;
font-family: serif ;
font-size: 100% }
pre.line-block {
font-family: serif ;
font-size: 100% }
pre.literal-block, pre.doctest-block {
margin-left: 2em ;
margin-right: 2em ;
background-color: #eeeeee }
span.classifier {
font-family: sans-serif ;
font-style: oblique }
span.classifier-delimiter {
font-family: sans-serif ;
font-weight: bold }
span.interpreted {
font-family: sans-serif }
span.option {
white-space: nowrap }
span.pre {
white-space: pre }
span.problematic {
color: red }
span.section-subtitle {
/* font-size relative to parent (h1..h6 element) */
font-size: 80% }
table.citation {
border-left: solid thin gray }
table.docinfo {
margin: 2em 4em }
table.docutils {
margin-top: 0.5em ;
margin-bottom: 0.5em }
table.footnote {
border-left: solid thin black }
table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
padding-left: 0.5em ;
padding-right: 0.5em ;
vertical-align: top }
table.docutils th.field-name, table.docinfo th.docinfo-name {
font-weight: bold ;
text-align: left ;
white-space: nowrap ;
padding-left: 0 }
h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
font-size: 100% }
tt.docutils {
background-color: #eeeeee }
ul.auto-toc {
list-style-type: none }
</style></head>
<body>
<div class="document" id="boost-pointer-container-library">
<h1 class="title"><img alt="Boost" src="boost.png" /> Pointer Container Library 指针容器库</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" /><tbody valign="top">
<tr>
<th class="docinfo-name">Author:</th>
<td>Thorsten Ottosen</td>
</tr>
<tr>
<th class="docinfo-name">Contact:</th>
<td><a class="first reference" href="mailto:nesotto@cs.aau.dk">nesotto@cs.aau.dk</a>
or <a class="last reference" href="mailto:tottosen@dezide.com">tottosen@dezide.com</a></td>
</tr>
<tr class="field">
<th class="docinfo-name">Organizations:</th>
<td class="field-body"><a class="reference" href="http://www.cs.aau.dk">Department of Computer Science</a>,
Aalborg University, and <a class="reference" href="http://www.dezide.com">Dezide Aps</a></td>
</tr>
<tr>
<th class="docinfo-name">Date:</th>
<td>27th of October 2007</td>
</tr>
<tr>
<th class="docinfo-name">Copyright:</th>
<td>Thorsten Ottosen 2004-2007. Use, modification and
distribution is subject to the Boost Software License, Version 1.0 (see
<a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">LICENSE_1_0.txt</a>).</td>
</tr>
</tbody>
</table>
<div class="section">
<h1><a id="overview" name="overview">Overview
总览</a></h1>
<p>Boost.Pointer Container provides containers for holding
heap-allocated
objects in an exception-safe manner and with minimal overhead.
The aim of the library is in particular to make OO programming
easier in C++ by establishing a standard set of classes, methods
and designs for dealing with OO specific problems<br />
Boost.Pointer Container
以异常安全的风格和最小的开销提供了保存堆分配对象的容器。本库的目标是通过为处理OO特定问题建立一套标准的类、方法和设计，来使得用C++进行OO编
程更为容易。</p>
<ul class="simple">
<li><a class="reference" href="#motivation">Motivation
动机</a></li>
<li><a class="reference" href="tutorial.html">Tutorial
教程</a></li>
<li><a class="reference" href="reference.html">Reference
参考</a></li>
<li><a class="reference" href="guidelines.html">Usage
guidelines 用法指引</a></li>
<li><a class="reference" href="examples.html">Examples
例子</a></li>
<li><a class="reference" href="headers.html">Library
headers 库头文件</a></li>
<li><a class="reference" href="faq.html">FAQ
常见问题</a></li>
<li><a class="reference" href="#upgrading-from-boost-v-1-33">Upgrading from Boost v.
1.33.* 从 Boost 1.33.* 升级</a></li>
<li><a class="reference" href="#upgrading-from-boost-v-1-34">Upgrading from Boost v.
1.34.* 从 Boost 1.34.* 升级</a></li>
<li><a class="reference" href="#future-developments">Future
Developments 未来的发展</a></li>
<li><a class="reference" href="#acknowledgements">Acknowledgements
鸣谢</a></li>
<li><a class="reference" href="#references">References
参考文档</a></li>
</ul>
<!-- - `Conventions <conventions.html>`_ - `The Clonable Concept <reference.html#the-clonable-concept>`_ - `The Clone Allocator Concept <reference.html#the-clone-allocator-concept>`_ - `Pointer container adapters <reference.html#pointer-container-adapters>`_ - `Sequence container classes <reference.html#sequence-containers>`_ - `ptr_vector <ptr_vector.html>`_ - `ptr_deque <ptr_deque.html>`_ - `ptr_list <ptr_list.html>`_ - `ptr_array <ptr_array.html>`_ - `Associative container classes <reference.html#associative-containers>`_ - `ptr_set <ptr_set.html>`_ - `ptr_multiset <ptr_multiset.html>`_ - `ptr_map <ptr_map.html>`_ - `ptr_multimap <ptr_multimap.html>`_ - `Indirected functions <indirect_fun.html>`_ - `Class nullable <reference.html#class-nullable>`_ - `Exception classes <reference.html#exception-classes>`_ -->
</div>
<div class="section">
<h1><a id="motivation" name="motivation">Motivation
动机</a></h1>
<p>Whenever a programmer wants to have a container of pointers to
heap-allocated objects, there is usually only one exception-safe way:
to make a container of smart pointers like <a class="reference" href="../../smart_ptr/shared_ptr.htm">boost::shared_ptr</a>
This approach is suboptimal if<br />
当一个程序员想要一个堆分配对象指针的容器时，通常只有一个异常安全的方法：建造一个智能指针如 <a class="reference" href="../../smart_ptr/shared_ptr.htm">boost::shared_ptr</a>
的容器。这个方法并不是最理想的，如果：</p>
<ol class="arabic simple">
<li>the stored objects are not shared, but owned exclusively,
or <br />
被保存的对象并不是共享的，而是专有的，或者</li>
</ol>
<!-- -->
<ol class="arabic simple" start="2">
<li>the overhead implied by smart pointers is inappropriate
<br />
智能指针所带来的开销是不适当的</li>
</ol>
<p>This library therefore provides standard-like containers that
are for storing
heap-allocated or <a class="reference" href="reference.html#the-clonable-concept">cloned</a>
objects (or in case of a map, the mapped object must be
a heap-allocated or cloned object). For each of the standard
containers there is a pointer container equivalent that takes ownership
of
the objects in an exception safe manner. In this respect the library is
intended
to solve the so-called
<a class="reference" href="faq.html#what-is-the-polymorphic-class-problem">polymorphic
class problem</a>.<br />
因此本库提供了与标准相似的容器，用于保存堆分配的或<a class="reference" href="reference.html#the-clonable-concept">克隆的</a>对象(或者
在 map
中，被映射的对象必须一个堆分配的或克隆的对象)。对于每一种标准容器，都有一个等价的指针容器，以一种异常安全的方式来接受对象的拥有权。在这方面，本
库的目的是解决被称为
<a class="reference" href="faq.html#what-is-the-polymorphic-class-problem">多态类的问题</a>。</p>
<p>The advantages of pointer containers are<br />
指针容器的优点是：</p>
<ol class="arabic simple">
<li>Exception-safe pointer storage and manipulation.<br />
异常安全的指针存储和操作。</li>
</ol>
<!-- -->
<ol class="arabic simple" start="2">
<li>Notational convenience compared to the use of containers of
pointers.<br />
比使用指针的容器更方便的写法。</li>
</ol>
<!-- -->
<ol class="arabic simple" start="3">
<li>Can be used for types that are neither Assignable nor Copy
Constructible.<br />
可用于既不可赋值也不可复制构造的类型。</li>
</ol>
<!-- -->
<ol class="arabic simple" start="4">
<li>No memory-overhead as containers of smart pointers can have
(see <a class="footnote-reference" href="#id23" id="id2" name="id2">[11]</a> and <a class="footnote-reference" href="#id25" id="id3" name="id3">[12]</a>).<br />
无内存开销，而智能指针容器可能会有(参见 <a class="footnote-reference" href="ptr_container.html#id23" id="id2" name="id2">[11]</a>
和 <a class="footnote-reference" href="ptr_container.html#id25" id="id3" name="id3">[12]</a>)。</li>
</ol>
<!-- -->
<ol class="arabic simple" start="5">
<li>Usually faster than using containers of smart pointers (see
<a class="footnote-reference" href="#id23" id="id4" name="id4">[11]</a> and <a class="footnote-reference" href="#id25" id="id5" name="id5">[12]</a>).<br />
通常比智知指针容器更快(参见 <a class="footnote-reference" href="ptr_container.html#id23" id="id2" name="id2">[11]</a>
和 <a class="footnote-reference" href="ptr_container.html#id25" id="id3" name="id3">[12]</a>)。</li>
</ol>
<!-- -->
<ol class="arabic simple" start="6">
<li>The interface is slightly changed towards the domain of
pointers
instead of relying on the normal value-based interface. For example,
now it is possible for <tt class="docutils literal"><span class="pre">pop_back()</span></tt> to return the
removed element.<br />
接口有些修改，接近于指针接口而不是依赖于普通的值接口。例如，<tt class="docutils literal"><span class="pre">pop_back()</span></tt> 有可能返回被删除的元素。</li>
</ol>
<!-- -->
<ol class="arabic simple" start="7">
<li>Propagates constness such that one cannot modify the
objects via a <tt class="docutils literal"><span class="pre">const_iterator</span></tt>.<br />
传播常量性，你不能通过 <tt class="docutils literal"><span class="pre">const_iterator</span></tt>&nbsp;修
改对象。</li>
</ol>
<!-- -->
<ol class="arabic simple" start="8">
<li>Built-in support for deep-copy semantics via the <a class="reference" href="reference.html#the-cloneable-concept">the
Cloneable concept</a><br />
内建的对深复制语义的支持，通过 <a class="reference" href="reference.html#the-cloneable-concept">可克隆概念</a>
实现。</li>
</ol>
<p>The disadvantages are<br />
缺点是：</p>
<ol class="arabic simple">
<li>Less flexible than containers of smart pointers like <a class="reference" href="../../smart_ptr/shared_ptr.htm">boost::shared_ptr</a><br />
与智能指针容器如 <a class="reference" href="../../smart_ptr/shared_ptr.htm">boost::shared_ptr</a>
相比，灵活性较少。</li>
</ol>
<p>When you do need shared semantics, this library is not what
you need.<br />
如果你需要分享的语义，那么本库不是你所需要的。</p>
</div>
<div class="section">
<h1><a id="upgrading-from-boost-v-1-33" name="upgrading-from-boost-v-1-33">Upgrading from Boost v. <tt class="docutils literal"><span class="pre">1.33.*</span></tt>
从 Boost&nbsp;v. <tt class="docutils literal"><span class="pre">1.33.*</span></tt> 升级</a></h1>
<p>If you upgrade from one of these versions of Boost, then there
has been one
major interface change: map iterators now mimic iterators from <tt class="docutils literal"><span class="pre">std::map</span></tt>.
Previously you may have written<br />
如果你从 Boost 的这些版本中是某一个升级，那么会有一个主要的接口发生了变化：map 迭代器现在是模仿来自 <tt class="docutils literal"><span class="pre">std::map</span></tt>
的迭代器。以前你可能要这样写：</p>
<pre class="literal-block">for( boost::ptr_map&lt;std::string,T&gt;::iterator i = m.begin(), e = m.end();<br /> i != e; ++i )<br />{<br /> std::cout &lt;&lt; "key:" &lt;&lt; i.key();<br /> std::cout &lt;&lt; "value:" &lt;&lt; *i;<br /> i-&gt;foo(); // call T::foo()<br />}<br /></pre>
<p>and this now needs to be converted into<br />
而现在要变成这样：</p>
<pre class="literal-block">for( boost::ptr_map&lt;std::string,T&gt;::iterator i = m.begin(), e = m.end();<br /> i != e; ++i )<br />{<br /> std::cout &lt;&lt; "key:" &lt;&lt; i-&gt;first;<br /> std::cout &lt;&lt; "value:" &lt;&lt; *i-&gt;second;<br /> i-&gt;second-&gt;foo(); // call T::foo()<br />}<br /></pre>
<p>Apart from the above change, the library now also introduces<br />
除了以上变化，本库现在还引入了：</p>
<ul>
<li>
<p class="first"><tt class="docutils literal"><span class="pre">std::auto_ptr&lt;T&gt;</span></tt>
overloads:<br /><tt class="docutils literal"><span class="pre">std::auto_ptr&lt;T&gt;</span></tt>
重载：</p>
<pre class="literal-block">std::auto_ptr&lt;T&gt; p( new T );<br />container.push_back( p );<br /></pre>
</li>
<li>
<p class="first">Derived-to-Base conversion in <tt class="docutils literal"><span class="pre">transfer()</span></tt>:<br />在&nbsp;<tt class="docutils literal"><span class="pre">transfer()</span></tt> 中的<tt class="docutils literal"><span class="pre"></span></tt>派生类到基类的转换：</p>
<pre class="literal-block">boost::ptr_vector&lt;Base&gt; vec;<br />boost::ptr_list&lt;Derived&gt; list;<br />...<br />vec.transfer( vec.begin(), list ); // now ok<br /></pre>
</li>
</ul>
<p>Also note that <a class="reference" href="../../assign/index.html">Boost.Assign</a>
introduces better support
for pointer containers.<br />还是留意 <a class="reference" href="../../assign/index.html">Boost.Assign</a>
引入了对指针容器更好的支持。</p>
</div>
<div class="section">
<h1><a id="upgrading-from-boost-v-1-33" name="upgrading-from-boost-v-1-33">Upgrading from Boost v. <tt class="docutils literal"><span class="pre">1.34.*</span></tt> 从 Boost&nbsp;v. <tt class="docutils literal"><span class="pre">1.34.*</span></tt> 升级</a></h1>
<p>Serialization have now been made optional thanks to Sebastian
Ramacher.
You simply include <tt class="docutils literal"><span class="pre">&lt;boost/ptr_container/serialize.hpp&gt;</span></tt>
or perhaps
just one of the more specialized headers.<br />序列化现在是可选的了，感谢 Sebastian
Ramacher。你只要包含 <tt class="docutils literal"><span class="pre">&lt;boost/ptr_container/serialize.hpp&gt;</span></tt>
或者只需其中某一个特定头文件即可。</p>
<p>All containers are now copy-constructible and assignable. So
you can e.g. now
do:<br />所有容器现在都是可复制构造和可赋值的。所以现在你可以这样做：</p>
<pre class="literal-block">boost::ptr_vector&lt;Derived&gt; derived = ...;<br />boost::ptr_vector&lt;Base&gt; base( derived );<br />base = derived;<br /></pre>
<p>As the example shows, derived-to-base class conversions are
also allowed.<br />如上例所示，派生类至基类的转换也是允许的。</p>
<p>A few general functions have been added:<br />增加了少量常用函数：</p>
<pre class="literal-block">VoidPtrContainer&amp; base();<br />const VoidPtrContainer&amp; base() const;<br /></pre>
<p>These allow direct access to the wrapped container which is
somtimes needed when you want to provide extra functionality.<br />这些函数允许直接访问被包装的容器，当你想提供更多的功能时就会需要这样的容器。</p>
<p>A few new functions have been added to sequences:<br />对于序列容器，增加了少量函数：</p>
<pre class="literal-block">void resize( size_type size );<br />void resize( size_type size, T* to_clone );<br /></pre>
<p><tt class="docutils literal"><span class="pre">ptr_vector&lt;T&gt;</span></tt>
has a few new helper functions to integrate better with C-arrays:<br /><tt class="docutils literal"><span class="pre">ptr_vector&lt;T&gt;</span></tt>
有新的辅助函数，以更好地与C数组集成：</p>
<pre class="literal-block">void transfer( iterator before, T** from, size_type size, bool delete_from = true );<br />T** c_array();<br /></pre>
<p>Finally you can now also "copy" and "assign" an <tt class="docutils literal"><span class="pre">auto_type</span></tt>
ptr by calling <tt class="docutils literal"><span class="pre">move()</span></tt>:<br />最后，现在你也可以通过调用 <tt class="docutils literal"><span class="pre">move()</span></tt> "复制"和"赋值"一个 <tt class="docutils literal"><span class="pre">auto_type</span></tt>
指针：</p>
<pre class="literal-block">boost::ptr_vector&lt;T&gt;::auto_type move_ptr = ...;<br />return boost::ptr_container::move( move_ptr );<br /></pre>
</div>
<div class="section">
<h1><a id="future-developments" name="future-developments">Future Developments 未来的发展</a></h1>
<p>There are indications that the <tt class="docutils literal"><span class="pre">void*</span></tt> implementation has
a slight
performance overhead compared to a <tt class="docutils literal"><span class="pre">T*</span></tt> based implementation.
Furthermore, a <tt class="docutils literal"><span class="pre">T*</span></tt> based implementation
is so much easier to use type-safely with algorithms. Therefore I
anticipate to move to a <tt class="docutils literal"><span class="pre">T*</span></tt> based implementation.<br />有迹象表明，<tt class="docutils literal"><span class="pre">void*</span></tt> 的实现与基于 <tt class="docutils literal"><span class="pre">T*</span></tt> 的实现相比性能开销稍多一点。此外，基于 <tt class="docutils literal"><span class="pre">T*</span></tt> 的实现更易于异常安全地使用算法。因此我准备转移到一个基于 <tt class="docutils literal"><span class="pre">T*</span></tt> 的实现。</p>
</div>
<div class="section">
<h1><a id="acknowledgements" name="acknowledgements">Acknowledgements 鸣谢</a></h1>
<p>The following people have been very helpful:<br />以下人员提供了非常大的帮助：</p>
<ul class="simple">
<li>Bjørn D. Rasmussen for unintentionally motivating me to
start this library</li>
<li>Pavel Vozenilek for asking me to make the adapters</li>
<li>David Abrahams for the <tt class="docutils literal"><span class="pre">indirect_fun</span></tt> design</li>
<li>Pavol Droba for being review manager</li>
<li>Ross Boylan for trying out a prototype for real</li>
<li>Felipe Magno de Almeida for giving fedback based on using
the
library in production code even before the library was part of boost</li>
<li>Jonathan Turkanis for supplying his <tt class="docutils literal"><span class="pre">move_ptr</span></tt>
framework
which is used internally</li>
<li>Stefan Slapeta and Howard Hinnant for Metrowerks support</li>
<li>Russell Hind for help with Borland compatibility</li>
<li>Jonathan Wakely for his great help with GCC compatibility
and bug fixes</li>
<li>Pavel Chikulaev for comments and bug-fixes</li>
<li>Andreas Hommel for fixing the nasty Metrowerks bug</li>
<li>Charles Brockman for his many comments on the documentation</li>
<li>Sebastian Ramacher for implementing the optinal
serialization support</li>
</ul>
</div>
<div class="section">
<h1><a id="references" name="references">References 参考文档</a></h1>
<table class="docutils footnote" id="id8" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id8">[1]</a></td>
<td>Matt Austern: <a class="reference" href="http://www.cuj.com/documents/s=7990/cujcexp1910austern/">"The
Standard Librarian: Containers of Pointers"</a> , C/C++ Users
Journal Experts Forum.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id10" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id10">[2]</a></td>
<td>Bjarne Stroustrup, "The C++ Programming Language", <a class="reference" href="http://www.research.att.com/%7Ebs/3rd_safe.pdf">Appendix
E: "Standard-Library Exception Safety"</a></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id12" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id12">[3]</a></td>
<td>Herb Sutter, "Exceptional C++".</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id13" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id13">[4]</a></td>
<td>Herb Sutter, "More Exceptional C++".</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id14" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id14">[5]</a></td>
<td>Kevlin Henney: <a class="reference" href="http://www.cuj.com/documents/s=7986/cujcexp2002henney/henney.htm">"From
Mechanism to Method: The Safe Stacking of Cats"</a> , C++ Experts
Forum, February 2002.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id16" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id16">[6]</a></td>
<td>Some of the few earlier attempts of pointer containers
I have seen are the rather interesting <a class="reference" href="http://www.ntllib.org/asp.html">NTL</a> and the <a class="reference" href="http://ootips.org/yonat/4dev/pointainer.h">pointainer</a>.
As of this writing both libraries are not exceptions-safe and can leak.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id17" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id17">[7]</a></td>
<td>INTERNATIONAL STANDARD, Programming languages --- C++,
ISO/IEC 14882, 1998. See section 23 in particular.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id18" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id18">[8]</a></td>
<td>C++ Standard Library Closed Issues List (Revision 27),
Item 218, <a class="reference" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-closed.html#218">Algorithms
do not use binary predicate objects for default comparisons</a>.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id20" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id20">[9]</a></td>
<td>C++ Standard Library Active Issues List (Revision 27),
Item 226, <a class="reference" href="http://gcc.gnu.org/onlinedocs/libstdc++/ext/lwg-active.html#226">User
supplied specializations or overloads of namespace std function
templates</a>.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id22" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id22">[10]</a></td>
<td>Harald Nowak, "A remove_if for vector", C/C++ Users
Journal, July 2001.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id23" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id23">[11]</a></td>
<td><em>(<a class="fn-backref" href="#id2">1</a>,
<a class="fn-backref" href="#id4">2</a>)</em>
Boost smart pointer <a class="reference" href="http://www.boost.org/libs/smart_ptr/smarttests.htm">timings</a></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id25" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id25">[12]</a></td>
<td><em>(<a class="fn-backref" href="#id3">1</a>,
<a class="fn-backref" href="#id5">2</a>)</em>
<a class="reference" href="http://www.ntllib.org/asp.html">NTL</a>: Array
vs std::vector and boost::shared_ptr</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="id26" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr>
<td class="label"><a name="id26">[13]</a></td>
<td>Kevlin Henney, <a class="reference" href="http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/NullObject.pdf">Null
Object</a>, 2002.</td>
</tr>
</tbody>
</table>
<hr />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" /><tbody valign="top">
<tr class="field">
<th class="field-name">Copyright:</th>
<td class="field-body">Thorsten Ottosen 2004-2006.</td>
</tr>
</tbody>
</table>
</div>
</div>
</body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" /><title>Boost Pointer Container Library</title>

<style type="text/css">
/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2007-11-25 13:38:02 -0500 (Sun, 25 Nov 2007) $
:Revision: $Revision: 41370 $
:Copyright: This stylesheet has been placed in the public domain.
Default cascading style sheet for the HTML output of Docutils.
See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/
/* "! important" is used here to override other ``margin-top`` and
``margin-bottom`` styles that are later in the stylesheet or more specific. See http://www.w3.org/TR/CSS1#the-cascade */
.first {
margin-top: 0 ! important }
.last, .with-subtitle {
margin-bottom: 0 ! important }
.hidden {
display: none }
a.toc-backref {
text-decoration: none ;
color: black }
blockquote.epigraph {
margin: 2em 5em ; }
dl.docutils dd {
margin-bottom: 0.5em }
/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
font-weight: bold }
*/
div.abstract {
margin: 2em 5em }
div.abstract p.topic-title {
font-weight: bold ;
text-align: center }
div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
margin: 2em ;
border: medium outset ;
padding: 1em }
div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
font-weight: bold ;
font-family: sans-serif }
div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
color: red ;
font-weight: bold ;
font-family: sans-serif }
/* Uncomment (and remove this text!) to get reduced vertical space in
compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
margin-bottom: 0.5em }
div.compound .compound-last, div.compound .compound-middle {
margin-top: 0.5em }
*/
div.dedication {
margin: 2em 5em ;
text-align: center ;
font-style: italic }
div.dedication p.topic-title {
font-weight: bold ;
font-style: normal }
div.figure {
margin-left: 2em }
div.footer, div.header {
clear: both;
font-size: smaller }
div.line-block {
display: block ;
margin-top: 1em ;
margin-bottom: 1em }
div.line-block div.line-block {
margin-top: 0 ;
margin-bottom: 0 ;
margin-left: 1.5em }
div.sidebar {
margin-left: 1em ;
border: medium outset ;
padding: 1em ;
background-color: #ffffee ;
width: 40% ;
float: right ;
clear: right }
div.sidebar p.rubric {
font-family: sans-serif ;
font-size: medium }
div.system-messages {
margin: 5em }
div.system-messages h1 {
color: red }
div.system-message {
border: medium outset ;
padding: 1em }
div.system-message p.system-message-title {
color: red ;
font-weight: bold }
div.topic {
margin: 2em }
h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
margin-top: 0.4em }
h1.title {
text-align: center }
h2.subtitle {
text-align: center }
hr.docutils {
width: 75% }
img.align-left {
clear: left }
img.align-right {
clear: right }
img.borderless {
border: 0 }
ol.simple, ul.simple {
margin-bottom: 1em }
ol.arabic {
list-style: decimal }
ol.loweralpha {
list-style: lower-alpha }
ol.upperalpha {
list-style: upper-alpha }
ol.lowerroman {
list-style: lower-roman }
ol.upperroman {
list-style: upper-roman }
p.attribution {
text-align: right ;
margin-left: 50% }
p.caption {
font-style: italic }
p.credits {
font-style: italic ;
font-size: smaller }
p.label {
white-space: nowrap }
p.rubric {
font-weight: bold ;
font-size: larger ;
color: maroon ;
text-align: center }
p.sidebar-title {
font-family: sans-serif ;
font-weight: bold ;
font-size: larger }
p.sidebar-subtitle {
font-family: sans-serif ;
font-weight: bold }
p.topic-title {
font-weight: bold }
pre.address {
margin-bottom: 0 ;
margin-top: 0 ;
font-family: serif ;
font-size: 100% }
pre.line-block {
font-family: serif ;
font-size: 100% }
pre.literal-block, pre.doctest-block {
margin-left: 2em ;
margin-right: 2em ;
background-color: #eeeeee }
span.classifier {
font-family: sans-serif ;
font-style: oblique }
span.classifier-delimiter {
font-family: sans-serif ;
font-weight: bold }
span.interpreted {
font-family: sans-serif }
span.option {
white-space: nowrap }
span.pre {
white-space: pre }
span.problematic {
color: red }
span.section-subtitle {
/* font-size relative to parent (h1..h6 element) */
font-size: 80% }
table.citation {
border-left: solid thin gray }
table.docinfo {
margin: 2em 4em }
table.docutils {
margin-top: 0.5em ;
margin-bottom: 0.5em }
table.footnote {
border-left: solid thin black }
table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
padding-left: 0.5em ;
padding-right: 0.5em ;
vertical-align: top }
table.docutils th.field-name, table.docinfo th.docinfo-name {
font-weight: bold ;
text-align: left ;
white-space: nowrap ;
padding-left: 0 }
h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
font-size: 100% }
tt.docutils {
background-color: #eeeeee }
ul.auto-toc {
list-style-type: none }
</style>
</head>


<body>
<div class="document" id="boost-pointer-container-library">
<h1 class="title"><img alt="Boost" src="boost.png" /> Pointer Container Library 指针容器库</h1>
<h2 class="subtitle" id="faq">FAQ 常见问题</h2>
<div class="contents local topic">
<ul class="simple">
<li><a class="reference" href="#calling-assign-is-very-costly-and-i-do-not-really-need-to-store-cloned-objects-i-merely-need-to-overwrite-the-existing-ones-what-do-i-do" id="id5" name="id5">Calling <tt class="docutils literal"><span class="pre">assign()</span></tt>
is very costly and I do not really need to store cloned objects; I
merely need to overwrite the existing ones; what do I do? 调用 <tt class="docutils literal"><span class="pre">assign()</span></tt>
的开销非常大而且我不需要保存克隆的对象；我只需要重写已有的对象；我要怎么做？</a></li>
<li><a class="reference" href="#which-mutating-algorithms-are-safe-to-use-with-pointers" id="id6" name="id6">Which mutating algorithms are
safe to use with pointers? 哪些可变算法可以安全使用指针？</a></li>
<li><a class="reference" href="#why-does-ptr-map-t-insert-replace-take-two-arguments-the-key-and-the-pointer-instead-of-one-std-pair-and-why-is-the-key-passed-by-non-const-reference" id="id7" name="id7">Why does <tt class="docutils literal"><span class="pre">ptr_map&lt;T&gt;::insert()/replace()</span></tt>
take two arguments (the key and the pointer) instead of one <tt class="docutils literal"><span class="pre">std::pair</span></tt>?
And why is the key passed by non-const reference? 为什么 <tt class="docutils literal"><span class="pre">ptr_map&lt;T&gt;::insert()/replace()</span></tt>
接受两个参数(键值和指针)而不是一个 <tt class="docutils literal"><span class="pre">std::pair</span></tt>
？为什么键值要以非常量引用来传递？</a></li>
<li><a class="reference" href="#when-instantiating-a-pointer-container-with-a-type-t-is-t-then-allowed-to-be-incomplete-at-that-point" id="id8" name="id8">When instantiating a pointer
container with a type <tt class="docutils literal"><span class="pre">T</span></tt>, is <tt class="docutils literal"><span class="pre">T</span></tt>
then allowed to be incomplete at that point? 在以类型 <tt class="docutils literal"><span class="pre">T</span></tt>
实例化一个指针容器时，<tt class="docutils literal"><span class="pre">T</span></tt> 是否可以是不完整的？</a></li>
<li><a class="reference" href="#why-do-iterator-range-inserts-give-the-strong-exception-safety-guarantee" id="id9" name="id9">Why do iterator-range inserts
give the strong exception-safety guarantee? 为什么迭代器区间的插入给出了强异常安全的保证？</a></li>
<li><a class="reference" href="#what-is-the-polymorphic-class-problem" id="id10" name="id10">What is the polymorphic class
problem?&nbsp;多态类的问题的什么？</a></li>
<li><a class="reference" href="#are-the-pointer-containers-faster-and-do-they-have-a-better-memory-footprint-than-a-container-of-smart-pointers" id="id11" name="id11">Are the pointer containers
faster and do they have a better memory footprint than a container of
smart pointers? 指针容器是否更快，它们是否比智能指针容器具有更佳的内存开销？</a></li>
<li><a class="reference" href="#when-the-stored-pointers-cannot-be-0-how-do-i-allow-this-empty-behavior-anyway" id="id12" name="id12">When the stored pointers cannot
be <tt class="docutils literal"><span class="pre">0</span></tt>,
how do I allow this "empty" behavior anyway? 如果被存指针不能为 <tt class="docutils literal"><span class="pre">0</span></tt>，
我怎样可以实现"空"的行为？</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id5" id="calling-assign-is-very-costly-and-i-do-not-really-need-to-store-cloned-objects-i-merely-need-to-overwrite-the-existing-ones-what-do-i-do" name="calling-assign-is-very-costly-and-i-do-not-really-need-to-store-cloned-objects-i-merely-need-to-overwrite-the-existing-ones-what-do-i-do">Calling
<tt class="docutils literal docutils literal"><span class="pre">assign()</span></tt> is very costly
and I do not really need to store cloned objects; I merely need to
overwrite the existing ones; what do I do?&nbsp;调用 <tt class="docutils literal"><span class="pre">assign()</span></tt>
的开销非常大而且我不需要保存克隆的对象；我只需要重写已有的对象；我要怎么做？
</a></h1>
<p>Call <tt class="docutils literal"><span class="pre">std::copy(</span> <span class="pre">first,</span>
<span class="pre">last,</span> <span class="pre">c.begin()</span>
<span class="pre">);</span></tt>.<br />
调用 <tt class="docutils literal"><span class="pre">std::copy(</span>
<span class="pre">first,</span>
<span class="pre">last,</span> <span class="pre">c.begin()</span>
<span class="pre">);</span></tt>。</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="which-mutating-algorithms-are-safe-to-use-with-pointers" name="which-mutating-algorithms-are-safe-to-use-with-pointers">Which
mutating algorithms are safe to use with pointers? 哪些可变算法可以安全使用指针？</a></h1>
<p>Any mutating algorithm that moves elements around by swapping
them. An important example is <tt class="docutils literal"><span class="pre">std::sort()</span></tt>; examples of
unsafe algorithms are <tt class="docutils literal"><span class="pre">std::unique()</span></tt> and <tt class="docutils literal"><span class="pre">std::remove()</span></tt>.<br />
任何通过交换元素来移动元素的可变算法。一个重要的例子就是 <tt class="docutils literal"><span class="pre">std::sort()</span></tt>；不安全的算法例子是 <tt class="docutils literal"><span class="pre">std::unique()</span></tt>
和 <tt class="docutils literal"><span class="pre">std::remove()</span></tt>。</p>
<!-- That is why these algorithms are provided as member functions. -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="why-does-ptr-map-t-insert-replace-take-two-arguments-the-key-and-the-pointer-instead-of-one-std-pair-and-why-is-the-key-passed-by-non-const-reference" name="why-does-ptr-map-t-insert-replace-take-two-arguments-the-key-and-the-pointer-instead-of-one-std-pair-and-why-is-the-key-passed-by-non-const-reference">Why
does <tt class="docutils literal docutils literal"><span class="pre">ptr_map&lt;T&gt;::insert()/replace()</span></tt>
take two arguments (the key and the pointer) instead of one <tt class="docutils literal docutils literal"><span class="pre">std::pair</span></tt>? And why is
the key passed by non-const reference? 为什么 <tt class="docutils literal"><span class="pre">ptr_map&lt;T&gt;::insert()/replace()</span></tt>
接受两个参数(键值和指针)而不是一个 <tt class="docutils literal"><span class="pre">std::pair</span></tt>
？为什么键值要以非常量引用来传递？
</a></h1>
<p>This is the only way the function can be implemented in an
exception-safe manner; since the copy-constructor of the key might
throw, and since function arguments are not guaranteed to be evaluated
from left to right, we need to ensure that evaluating the first
argument does not throw. Passing the key as a reference achieves just
that.<br />
这是以异常安全的方式实现该函数的唯一办法；因为键值的复制构造函数有可能抛出，而且函数参数也不保证是从左到右进行求值，我们需要确保第一个参数的求值
不会抛出。以引用来传递键值正是为了解决这一问题。</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="when-instantiating-a-pointer-container-with-a-type-t-is-t-then-allowed-to-be-incomplete-at-that-point" name="when-instantiating-a-pointer-container-with-a-type-t-is-t-then-allowed-to-be-incomplete-at-that-point">When
instantiating a pointer container with a type <tt class="docutils literal docutils literal"><span class="pre">T</span></tt>, is <tt class="docutils literal docutils literal"><span class="pre">T</span></tt> then allowed to be
incomplete at that point? 在以类型 <tt class="docutils literal"><span class="pre">T</span></tt>
实例化一个指针容器时，<tt class="docutils literal"><span class="pre">T</span></tt> 是否可以是不完整的？
</a></h1>
<p>No. This is a distinct property of <tt class="docutils literal"><span class="pre">shared_ptr</span></tt>
which implies some overhead.<br />
不可以。这是和 <tt class="docutils literal"><span class="pre">shared_ptr</span></tt>
明确不同的一个特性，这样可以减少开销。</p>
<p>However, one can leave <tt class="docutils literal"><span class="pre">T</span></tt> incomplete in the
header file:<br />
不过，在头文件中 <tt class="docutils literal"><span class="pre">T</span></tt>
可以是不完整的：</p>
<pre class="literal-block">// foo.hpp<br />class Foo { ... };<br />new_clone( const Foo&amp; ) { ... }<br />delete_clone( const Foo* ) { ... }<br /><br />// x.hpp<br />class Foo; // Foo is incomplete here 这里Foo是不完整的<br />class X { ptr_deque&lt;Foo&gt; container; ... }<br /><br />// x.cpp<br />#include &lt;x.hpp&gt;<br />#include &lt;foo.hpp&gt; // now Foo is not incomplete anymore 现在Foo不可以是不完整的<br />...<br /></pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="why-do-iterator-range-inserts-give-the-strong-exception-safety-guarantee" name="why-do-iterator-range-inserts-give-the-strong-exception-safety-guarantee">Why
do iterator-range inserts give the strong exception-safety guarantee? 为什么迭代器区间的插入给出了强异常安全的保证？</a></h1>
<p>Is this not very inefficient? It is because it is actually
affordable to do so; the overhead is one heap-allocation which is
relatively small compared to cloning N objects.<br />这样会很低效吗？之所以这样，是因为完全可以这样做；它的开销只是一次堆分配，与克隆N个对象相比小得多。</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id10" id="what-is-the-polymorphic-class-problem" name="what-is-the-polymorphic-class-problem">What is the <span class="target" id="polymorphic-class-problem">polymorphic
class problem</span>? 多态类的问题的什么？</a></h1>
<p>The problem refers to the relatively troublesome way C++
supports Object Oriented programming in connection with containers of
pointers to polymorphic objects. In a language without garbage
collection, you end up using either a container of smart pointers or a
container that takes ownership of the pointers. The hard part is to
find a safe, fast and elegant solution.<br />问题在于，C++所支持的面向对象编程在处理多态对象指针的容器时，方法相对麻烦一些。在一个没有垃圾回收机制的语言中，你要么使用智能指针容器，要么使用拥有指针所有权的容器。最难的部分是找到一种安全、快速和优雅的解决方案。</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="are-the-pointer-containers-faster-and-do-they-have-a-better-memory-footprint-than-a-container-of-smart-pointers" name="are-the-pointer-containers-faster-and-do-they-have-a-better-memory-footprint-than-a-container-of-smart-pointers">Are
the pointer containers faster and do they have a better memory
footprint than a container of smart pointers? 指针容器是否更快，它们是否比智能指针容器具有更佳的内存开销？</a></h1>
<p>The short answer is yes: they are faster and they do use less
memory; in fact, they are the only way to obtain the zero-overhead
hallmark of C++. Smart pointers usually have one word or more of memory
overhead per pointer because a reference count must be maintained. And
since the reference count must be maintained, there is also a
runtime-overhead. If your objects are big, then the memory overhead is
often negligible, but if you have many small objects, it is not.
Further reading can be found in these references: <a class="reference" href="ptr_container.html#references">[11]</a>
and <a class="reference" href="ptr_container.html#references">[12]</a>.<br />简
单来说，是：指针容器更快，也使用更少的内存；事实上，它们是C++中获得零开销的唯一方法。智能指针通常要为每个指针多用一个字或更多的内存开销，因为
它需要维护一个引用计数。而且由于要维护引用计数，还会有运行时间的开销。如果你的对象非常大，那么内存开销通常可以忽略不计，但如果你有很多小对象，就
不是这样了。可以进一步阅读以下参考：<a class="reference" href="ptr_container.html#references">[11]</a> 和 <a class="reference" href="ptr_container.html#references">[12]</a>。</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="when-the-stored-pointers-cannot-be-0-how-do-i-allow-this-empty-behavior-anyway" name="when-the-stored-pointers-cannot-be-0-how-do-i-allow-this-empty-behavior-anyway">When
the stored pointers cannot be <tt class="docutils literal docutils literal"><span class="pre">0</span></tt>, how do I allow this
"empty" behavior anyway? 如果被存指针不能为 <tt class="docutils literal docutils literal"><span class="pre">0</span></tt>
，我怎样可以实现"空"的行为？</a></h1>
<p>Storing a null-pointer among a list of pointers does not fit
well into the Object Oriented paradigm. The most elegant design is to
use the Null-Object Pattern where one basically makes a concrete
class with dummy implementations of the virtual functions. See <a class="reference" href="ptr_container.html#references">[13]</a>
for details.<br />
在一组指针中保存一个空指针并不符合面向对象的范例。最优雅的设计是使用 Null-Object
模式，你只要构建一个具体类，对虚拟函数给出一个假的实现即可。细节请见 <a class="reference" href="ptr_container.html#references">[13]</a>。</p>
<hr />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" /><tbody valign="top">
<tr class="field">
<th class="field-name">Copyright:</th>
<td class="field-body">Thorsten Ottosen 2004-2006.
Use, modification and distribution is subject to the Boost Software
License, Version 1.0 (see <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">LICENSE_1_0.txt</a>).</td>
</tr>
</tbody>
</table>
</div>
</div>
</body></html>
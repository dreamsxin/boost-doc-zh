<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link href="pool.css" rel="stylesheet" type="text/css">

  <title>Boost Pool Library</title></head>


<body>
  <img src="../../../boost.png" alt="C++ Boost" height="86" width="276">

  <h1 align="center">Boost Pool Library</h1>

  <h2>Introduction 简介</h2>

  <h3>What is Pool? 内存池是什么？</h3>

  <p>Pool allocation is a memory allocation scheme that is very fast, but 
  limited in its usage. For more information on pool allocation (also called 
  "simple segregated storage"), see <a href="concepts.html">the concepts 
  document</a>.<br>内存池分配是一种非常快速但用途有限的内存分配机制。有关内存池分配(又称"简单的分隔式存储")的更多信息，请见 <a href="concepts.html">"概念"文档</a>。</p>

  <h3>Why should I use Pool? 为什么要使用内存池？</h3>

  <p>Using Pools gives you more control over how memory is used in your 
  program. For example, you could have a situation where you want to allocate 
  a bunch of small objects at one point, and then reach a point in your 
  program where none of them are needed any more. Using pool interfaces, you 
  can choose to run their destructors or just drop them off into oblivion; the 
  pool interface will guarantee that there are no system memory leaks.<br>使
用内存池可以让你更好地控制在程序中如何使用内存。例如，你可能在某种情形下想要在一个执行点分配一群小型对象，然后在到达程序的另一个执行点时则不再需
要这些小型对象。使用内存池接口，你可以选择运行它们的析构函数，或者只是丢弃它们；内存池接口可以保证没有系统内存泄漏。</p>

  <h3>When should I use Pool? 什么时候应该使用内存池？</h3>

  <p>Pools are generally used when there is a lot of allocation and 
  deallocation of small objects. Another common usage is the situation above, 
  where many objects may be dropped out of memory.<br>如果有大量小型对象的分配和释放，通常就会使用内存池。另一种常见的用途就是上面的情形，即有许多对象要被丢弃。</p><p>In general, use Pools when you need a more efficient way to do unusual 
  memory control.<br>通常来说，当你需要一个更高效的方法来进行非常规的内存控制时，使用内存池。</p>

  <h3>How do I use Pool? 如何使用内存池？</h3>

  <p>See the <a href="interfaces.html">pool interfaces document</a>, which 
  covers the different Pool interfaces supplied by this library.<br>参见 <a href="interfaces.html">pool 接口文档</a>，它涵盖了本库所提供各个不同的内存池接口。</p>

  <h2>Library Structure and Dependencies 库结构和依赖关系</h2>

  <p>Forward declarations of all the exposed symbols for this library are in 
  the header <span class="code">&lt;boost/pool/poolfwd.hpp&gt;</span>.<br>本库对外公开的所有符号的前向声明，位于头文件 <span class="code">&lt;boost/pool/poolfwd.hpp&gt;</span>。</p>

  <p>The library may use macros, which will be prefixed with <span class="code">BOOST_POOL_</span>. The exception to this rule are the include file 
  guards, which (for file <em>xxx</em>.hpp) is <span class="code">BOOST_<em>xxx</em>_HPP</span>.<br>本库所使用的宏均以 <span class="code">BOOST_POOL_</span> 开头。这一规则的唯一例外是头文件的重入防卫，文件 <em>xxx</em>.hpp 的重入防卫为 <span class="code">BOOST_<em>xxx</em>_HPP</span>。</p>

  <p>All exposed symbols defined by the library will be in namespace
  <span class="code">boost</span>. All symbols used only by the implementation 
  will be in namespace <span class="code">boost::details::pool</span>.<br>本库所定义的所有公开符号均位于
  <span class="code">boost</span> 名字空间。而只用于实现的符号则位于 <span class="code">boost::details::pool</span> 名字空间。</p>

  <p>Every header used only by the implementation is in the subdirectory
  <span class="code">detail/</span>.<br>只用于实现的头文件位于子目录 <span class="code">detail/</span>。</p>

  <p>Any header in the library may include any other header in the library or 
  any system-supplied header at its discretion.<br>本库中的任一头文件都可能包含库内的另一个头文件，或者系统提供的任意头文件，视其需要而定。</p>

  <h2>Installation 安装</h2>

  <p>The Boost Pool library is a header file library. That means there is no 
  .lib, .dll, or .so to build; just add the Boost directory to your compiler's 
  include file path, and you should be good to go!<br>Boost Pool 库是一个头文件库。即没有 
  .lib, .dll, 或 .so 文件要构建；只需要把 Boost 目录加到你的编译器头文件包含路径中，你就可以用了！</p>

  <h2>Building the Test Programs 构建测试程序</h2>

  <p>The subdirectory "build" contains subdirectories for several different 
  platforms. These subdirectories contain all necessary work-around code for 
  that platform, as well as makefiles or IDE project files as appropriate.<br>子目录 "build" 中包含多个不同平台的子目录。这些子目录中含有相应平台所需的变通代码，以及适当的 makefiles 或 IDE 项目。</p>

  <p>Read the "readme.txt" in the proper subdirectory, if it exists.<br>请阅读相应子目录中的 "readme.txt"，如果该文件存在的话。</p>

  <p>The standard makefile targets are "all", "clean" (which deletes any 
  intermediate files), and "veryclean" (which deletes any intermediate files 
  and executables). All intermediate and executable files are built in the 
  same directory as the makefile/project file. If there is a project file 
  supplied instead of a makefile, "clean" and "veryclean" shell scripts/batch 
  files will be provided.<br>标
准的 makefile 目标是 "all", "clean" (删除所有中间文件)，和 "veryclean"
(删除所有中间文件和可执行文件)。所有中间文件和可执行文件在 makefile/project
文件所在的目录中构建。如果提供的是项目文件而不是 makefile，则会提供 "clean"和 "veryclean" shell
脚本或批处理文件。</p>

  <p>Project files and makefiles for additional platforms may be sent to 
  Stephen Cleary at scleary AT jerviswebb DOT com.<br>如果你有其它平台所用的项目文件和 makefiles，可以发送至 Stephen Cleary at scleary AT jerviswebb DOT com.</p>

  <h2>Documentation Map 文档地图</h2>

  <ul>
    <li>Overview of Pooling <br>内存池简介

      <ul>
        <li><a href="concepts.html">concepts.html</a> - The basic ideas behind 
        pooling.<br><a href="concepts.html">concepts.html</a> - 内存池背后的基本意思。</li>

        <li><a href="implementation/alignment.html">implementation/alignment.html</a> - 
        How we guarantee alignment portably.<br><a href="implementation/alignment.html">implementation/alignment.html</a> - 
        我们如何保证字节对齐的可移植性。</li>

        <li><a href="interfaces.html">interfaces.html</a> - What interfaces 
        are provided and when to use each one.<br><a href="interfaces.html">interfaces.html</a> - 提供哪些接口，以及何时使用哪一种。</li>
      </ul>
    </li>

    <li>Pool Exposed Interfaces<br>公开的内存池接口

      <ul>
        <li><a href="interfaces/simple_segregated_storage.html">
        interfaces/simple_segregated_storage.html</a>
        - Not for the faint of heart; embedded programmers only.<br><a href="interfaces/simple_segregated_storage.html">
        interfaces/simple_segregated_storage.html</a>
        - 不适用于脆弱的心脏；只适用于嵌入式程序员。</li>

        <li><a href="interfaces/pool.html">interfaces/pool.html</a> - The 
        basic pool interface.<br><a href="interfaces/pool.html">interfaces/pool.html</a> - 内存池的基本接口。</li>

        <li><a href="interfaces/singleton_pool.html">interfaces/singleton_pool.html</a> - 
        The basic pool interface as a thread-safe singleton.<br><a href="interfaces/singleton_pool.html">interfaces/singleton_pool.html</a> - 作为线程安全的单件的基本内存池接口。</li>

        <li><a href="interfaces/object_pool.html">interfaces/object_pool.html</a> - A 
        type-oriented (instead of size-oriented) pool interface.<br><a href="interfaces/object_pool.html">interfaces/object_pool.html</a> - 面向类型(而不是面向大小)的内存池接口。</li>

        <li><a href="interfaces/pool_alloc.html">interfaces/pool_alloc.html</a> - A 
        Standard Allocator pool interface based on singleton_pool.<br><a href="interfaces/pool_alloc.html">interfaces/pool_alloc.html</a> - 基于 singleton_pool 的标准分配器内存池接口。</li>

        <li><a href="interfaces/user_allocator.html">interfaces/user_allocator.html</a> - 
        OK, not a pool interface, but it describes how the user can control 
        how Pools allocate system memory.<br><a href="interfaces/user_allocator.html">interfaces/user_allocator.html</a> - 
        OK, 不是一个内存池接口，不过它说明了用户如何控制内存池分配系统内存的方法。</li>
      </ul>
    </li>

    <li>Pool Implementation Details and Extensions<br>内存池实现细节和扩展

      <ul>
        <li>Interface Implementations and Extensions<br>接口实现和扩展

          <ul>
            <li><a href="implementation/simple_segregated_storage.html">
            implementation/simple_segregated_storage.html</a></li>

            <li><a href="implementation/pool.html">implementation/pool.html</a></li>

            <li><a href="implementation/singleton_pool.html">
            implementation/singleton_pool.html</a></li>

            <li><a href="implementation/object_pool.html">implementation/object_pool.html</a></li>

            <li><a href="implementation/pool_alloc.html">implementation/pool_alloc.html</a></li>
          </ul>
        </li>

        <li>Components Used Only by the Implementation<br>仅由实现使用的组件

          <ul>
            <li><a href="implementation/ct_gcd_lcm.html">implementation/ct_gcd_lcm.html</a>
            - Compile-time GCD and LCM.<br><a href="implementation/ct_gcd_lcm.html">implementation/ct_gcd_lcm.html</a>
            - 编译期 GCD 和 LCM.</li>

            <li><a href="implementation/for.html">implementation/for.html</a>
            - Description of an m4 component.<br><a href="implementation/for.html">implementation/for.html</a>
            - 一个 m4 组件的描述。</li>

            <li><a href="implementation/gcd_lcm.html">implementation/gcd_lcm.html</a> - 
            Run-time GCD and LCM.<br><a href="implementation/gcd_lcm.html">implementation/gcd_lcm.html</a> - 
            运行期 GCD 和 LCM.</li>

            <li><a href="implementation/guard.html">implementation/guard.html</a> - Auto 
            lock/unlock for mutex.<br><a href="implementation/guard.html">implementation/guard.html</a> - 用于互斥体的自动锁定/解锁。</li>

            <li><a href="implementation/mutex.html">implementation/mutex.html</a> - 
            Platform-dependent mutex type.<br><a href="implementation/mutex.html">implementation/mutex.html</a> - 
            平台相关的互斥体类型。</li>

            <li><a href="implementation/pool_construct.html">
            implementation/pool_construct.html</a>
            - The system for supporting more constructor arguments in 
            object_pool.<br><a href="implementation/pool_construct.html">
            implementation/pool_construct.html</a>
            - 在 object_pool 的构造函数中使用更多参数的支持系统。</li>

            <li><a href="implementation/singleton.html">implementation/singleton.html</a>
            - Singleton that avoids static initialization problem.<br><a href="implementation/singleton.html">implementation/singleton.html</a>
            - 避免静态初始化问题的单件。</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <h2>Future Directions 未来的方向</h2>

  <p>Another pool interface will be written: a base class for per-class pool 
  allocation.<br>将编写另一个内存池接口：针对每个类进行内存池分配的基类。</p>

  <h2>Acknowledgements 鸣谢</h2>

  <p>Many, many thanks to the Boost peers, notably Jeff Garland, Beman Dawes, 
  Ed Brey, Gary Powell, Peter Dimov, and Jens Maurer for providing helpful 
  suggestions!</p>
  <hr>

  <p><a href="http://validator.w3.org/check?uri=referer"><img style="border: 0px solid ; width: 88px; height: 31px;" src="../../../valid-html401.png" alt="Valid HTML 4.01 Transitional"></a></p>

  <p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->05 December, 2006<!--webbot bot="Timestamp" endspan i-checksum="38516" --></p>

  <p><i>Copyright © 2000, 2001 Stephen Cleary (scleary AT jerviswebb DOT com)</i></p>

  <p><i>Distributed under the Boost Software License, Version 1.0. (See 
  accompanying file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or 
  copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>
</body></html>
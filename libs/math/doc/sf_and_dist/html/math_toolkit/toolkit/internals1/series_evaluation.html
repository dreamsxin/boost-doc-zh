<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Series Evaluation</title><link rel="stylesheet" href="../../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_2006-12-17_0120">
<link rel="start" href="../../../index.html" title="Math Toolkit">
<link rel="up" href="../internals1.html" title="Reused Utilities">
<link rel="prev" href="constants.html" title="Numeric Constants">
<link rel="next" href="cf.html" title="Continued Fraction Evaluation"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="constants.html"><img src="../../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../internals1.html"><img src="../../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="cf.html"><img src="../../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div>
  <h4 class="title">
<a name="math_toolkit.toolkit.internals1.series_evaluation"></a><a href="series_evaluation.html" title="Series Evaluation">
        级数计算(Series Evaluation)</a>
</h4>
</div></div></div>
<a name="math_toolkit.toolkit.internals1.series_evaluation.synopsis"></a>
<h5>
<a name="id773378"></a>
          <a href="series_evaluation.html#math_toolkit.toolkit.internals1.series_evaluation.synopsis">概要</a>
  </h5>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">tools</span><span class="special">/</span><span class="identifier">series</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
  </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">math</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">tools</span><span class="special">{</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">V</span><span class="special">&gt;</span><br><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">U</span><span class="special">&amp;</span> <span class="identifier">tolerance</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_terms</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">V</span><span class="special">&amp;</span> <span class="identifier">init_value</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">V</span><span class="special">&gt;</span><br><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">U</span><span class="special">&amp;</span> <span class="identifier">tolerance</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_terms</span><span class="special">);</span><br><br><span class="comment">//<br></span><span class="comment">// The following interfaces are now deprecated:<br></span><span class="comment">//   <br></span><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">&gt;</span><br><span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">bits</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">&gt;</span><br><span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">bits</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_terms</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span><br><span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">bits</span><span class="special">,</span> <span class="identifier">U</span> <span class="identifier">init_value</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span><br><span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">bits</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_terms</span><span class="special">,</span> <span class="identifier">U</span> <span class="identifier">init_value</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">&gt;</span><br><span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">kahan_sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">bits</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Functor</span><span class="special">&gt;</span><br><span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">kahan_sum_series</span><span class="special">(</span><span class="identifier">Functor</span><span class="special">&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">bits</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_terms</span><span class="special">);</span><br><br><span class="special">}}}</span> <span class="comment">// namespaces</span><span class="comment"></span></pre>

<h5>
<a name="id774327"></a>
          <a href="series_evaluation.html#math_toolkit.toolkit.internals1.series_evaluation.description">说明</a>
        </h5>
<p>
          这些算法打算用来进行<a href="http://en.wikipedia.org/wiki/Series_%28mathematics%29" target="_top">无限级数求和</a>.
        </p>
<p>
  每个算法都带有一个 nullary-function 函数对象作为第一个参数：这个函数将被重复调用来获取这个被计算的级数的后续项。</p><p>第二个参数是结果的所要求的精度，当下一项小于&nbsp;<span class="emphasis"><em>tolerance</em></span> 乘以结果时求和就会停止。旧的 sum_series 版本在此接受一个位数长度 - 在内部它们只是将它转换为一个tolerance并前转调用。</p>
<p>The third argument <span class="emphasis"><em>max_terms</em></span> sets an 
upper limit on the number of terms of the series to evaluate. In addition, on 
exit the function will set <span class="emphasis"><em>max_terms</em></span> to the 
actual number of terms of the series that were evaluated: this is particularly 
useful for profiling the convergence properties of a new series. </p><p>
  第三个参数<span class="emphasis"><em>max_terms</em></span> 设置被计算的级数项数的上限。此外，在函数退出的时候，函数将会把<span class="emphasis"><em>max_terms</em></span> 设置为实际的级数项数：这对于为一个新级数绘制收敛性质图像会很有帮助。</p>
<p>
  最后一个可选参数<span class="emphasis"><em>init_value</em></span> 是这个级数和的初始值。这在两种情况下很有用：</p>
<div class="itemizedlist"><ul type="disc">
<li>
            对于级数的后续项，级数的第一个值具有不同的方程。在这种情况下，级数的第一个值可以作为最后一个参数进行传递，而且函数对象的逻辑可以简化为计算后续级数项的和。</li>
<li>
            级数需要加上(或者减去)其它的值:如果这个其它的值作为函数的最后一个参数，那么级数计算的停止可能会更快一些。例如，有一些函数可以表示为<span class="emphasis"><em>1 - S(z)</em></span> 其中
            S(z) 是一个无限级数。在这种情况下，传递 -1 作为最后一个参数，然后将结果取负就可以得到求和的结果<span class="emphasis"><em>1
            - S(z)</em></span>。</li>
</ul></div>
<p>
          这些算法的两个<span class="emphasis"><em>kahan_sum_series</em></span> 变量和一个携带项(carray term)来校正求和过程中的舍入误差。这受到在<a href="http://docs.sun.com/source/806-3568/ncg_goldberg.html" target="_top">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.中的 <a href="http://en.wikipedia.org/wiki/Kahan_Summation_Algorithm" target="_top"><span class="emphasis"><em>Kahan
  Summation Formula</em></span></a> 的启发。然而，需要指出的是，只有非常少的级数需要以这种方式求和。</p>
<a name="math_toolkit.toolkit.internals1.series_evaluation.example"></a>
<h5>
<a name="id774475"></a>
          <a href="series_evaluation.html#math_toolkit.toolkit.internals1.series_evaluation.example">例子</a>
  </h5>
<p>
          假设我们想要通过无限级数来实现函数<span class="emphasis"><em>log(1+x)</em></span> ， </p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/log1pseries.png"></span>
  </p>
<p>
  我们定义一个返回级数连续项的小的函数对象：</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">log1p_series</span>
<span class="special">{</span>
   <span class="comment">// 我们定义一个 result_type typedef:<br></span>   <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">result_type</span><span class="special">;</span>

   <span class="identifier">log1p_series</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">x</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">k</span><span class="special">(</span><span class="number">0</span><span class="special">),</span> <span class="identifier">m_mult</span><span class="special">(-</span><span class="identifier">x</span><span class="special">),</span> <span class="identifier">m_prod</span><span class="special">(-</span><span class="number">1</span><span class="special">){}</span>

   <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()()</span>
   <span class="special">{</span>
      <span class="comment">// 这是被求和算法使用的函数对象<br></span>      <span class="comment">// 对这个运算符的第一次调用应当返回<br></span>      <span class="comment">// 级数的第一项，第二次调用返回第二项<br></span>      <span class="comment">// 以此类推.<br></span>      <span class="identifier">m_prod</span> <span class="special">*=</span> <span class="identifier">m_mult</span><span class="special">;</span>
      <span class="keyword">return</span> <span class="identifier">m_prod</span> <span class="special">/</span> <span class="special">++</span><span class="identifier">k</span><span class="special">;</span> <br>   <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
   <span class="keyword">int</span> <span class="identifier">k</span><span class="special">;</span>
   <span class="keyword">const</span> <span class="identifier">T</span> <span class="identifier">m_mult</span><span class="special">;</span>
   <span class="identifier">T</span> <span class="identifier">m_prod</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
  实现 log(1+x) 现在就非常简单：</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">log1p</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">x</span><span class="special">)</span>
<span class="special">{</span>
   <span class="comment">// 我们需要在这里对x进行一些错误检查!<br></span>   <span class="identifier">assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">fabs</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">&lt;</span> <span class="number">1</span><span class="special">);</span>
   
   <span class="comment">// 构造级数函数对象:<br></span>   <span class="identifier">log1p_series</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">s</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span><br>   <span class="comment">// 对所允许的迭代次数设置一个限额:<br></span>   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span> <span class="identifier">max_iter</span> <span class="special">=</span> <span class="number">1000</span><span class="special">;</span><br>   <span class="comment">// </span><span class="comment">并将其累加，使用完全的机器精度</span><span class="comment">:<br></span>   <span class="keyword">return</span> <span class="identifier">tools</span><span class="special">::</span><span class="identifier">sum_series</span><span class="special">(</span><span class="identifier">s</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">epsilon</span><span class="special">(),</span> <span class="identifier">max_iter</span><span class="special">);</span><br><span class="special">}</span><span class="special"></span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright ?2006 , 2007, 2008 John Maddock, Paul A. Bristow, Hubert
      Holin, Xiaogang Zhang and Bruno Lalande<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="constants.html"><img src="../../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../internals1.html"><img src="../../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="cf.html"><img src="../../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
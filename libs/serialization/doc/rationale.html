<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<!--
(C) Copyright 2002-4 Robert Ramey - http://www.rrsd.com . 
Use, modification and distribution is subject to the Boost Software
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
-->



  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">




  
  
  
  <link rel="stylesheet" type="text/css" href="../../../boost.css">




  
  
  
  <link rel="stylesheet" type="text/css" href="style.css">




  
  
  
  <title>Seriealization - Rationale</title>
</head>


<body link="#0000ff" vlink="#800080">




<table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">




  <tbody>



    <tr>



 
    <td valign="top" width="300"> 
      
      
      
      
      <h3><a href="http://www.boost.org"><img alt="C++ Boost" src="../../../boost.png" border="0" height="86" width="277"></a></h3>




    </td>




    <td valign="top"> 
      
      
      
      
      <h1 align="center">Serialization序列化</h1>




      
      
      
      
      <h2 align="center">基本原理</h2>




    </td>




  </tr>




  
  
  
  </tbody>
</table>




<hr>
<dl class="index">




  <dt><a href="#serialization">术语 "serialization" 优于 "persistence"</a></dt>




  <dt><a href="#archives">存档不是一种流</a></dt>




  <dt><a href="#strings">在文本存档中对字符串的特殊处理</a></dt>




  <dt><a href="#typeid"><code style="white-space: normal;">typeid</code> 信息不包含于存档中</a></dt>




  <dt><a href="#trap">保存一个非-const值时的编译期陷阱</a></dt>




  <!--
  <dt><a href="#footnotes">Footnotes</a></dt>
  -->
</dl>




<h2><a name="serialization"></a>术语 "serialization" 优于 "persistence"</h2>




<p>我发现 persistence 常常被用于表示另外一些很不同的意思。例如，在数据库 schema 中的类实例(对象)存储<a href="bibliography.html#4">[4]</a>。这个库是用于 persistence 以外的一些环境中的。最明显的例子是对数据进行整编以传送到其它系统。
</p>



<h2><a name="archives"></a>存档不是一种流</h2>




<p>存档类并不是派生自流的，虽然它们在语法上有点类似。
</p>



<ul>




    <li>存档类并不是某一种流，虽然它的实现要依赖于流。其中的区别请看 <a href="bibliography.html#5">[5]</a> 中的 item 41。</li>



  <li>我们不想让用户直接插入数据到流中或者直接从流中取出数据。这样会破坏存档。如果存档派生自流，就有可能这样做。所以存档类只定义了安全和必须的操作。
    </li>



  <li>在本库中我们用流来实现存档类，仅仅是为了方便 - 而不是必须的。库的用户如果想定义自己的存档格式，完全可以不使用流。
  </li>



</ul>




<h2><a name="primitives"></a>存档成员是模板而不是虚拟函数</h2>

本库的旧版本中，为所有基本类型定义了虚拟函数。它们会被每个存档类所覆写。这样就存在两个问题：

    
</body>
<ul>
  <li>有些人不喜欢虚拟函数，因为这要增加程序的执行时间开销。
    </li>
  <li>这会导致实现困难，由于在不同的平台间，基本数据类型是不一样的。为了定义正确的虚拟函数集，(想象一下 <code style="white-space: normal;">long long</code>, 
    <code style="white-space: normal;">__int64</code>, 等等)，会导致杂乱和脆弱的代码。以模板来代替虚拟函数，让编译器为要用的基本类型生成代码，可以解决这个问题。当然，这种设计的改变具有重大意义，可以生成更小、更快、更易于维护的代码。

  
  
  </li>
</ul>
<body link="#0000ff" vlink="#800080">



<li>
  <h2><a name="strings"></a><code style="white-space: normal;"></code>在文本存档中对 <code style="white-space: normal;">std::string </code>的特殊处理</h2>




  
  
  
  <p>将字符串当作 STL 向量来处理可以得到最小的代码。不这样做的原因是：
  </p>



  
  
  
  <ul>




     <li>在文本存档中应该可以将字符串显示出来。我们的文本存档实现将单个字符保存为整数。将字符串按字符向量来保存既浪费空间，又不利于对存档进行调试。
     </li>



    <li>流的实现对于 <code style="white-space: normal;">std::string</code> 和 <code style="white-space: normal;">std::wstring</code> 都有特殊的处理函数。它们有可能都经过了优化。
     </li>



    <li><code style="white-space: normal;">std::basic_string</code> 的其它规格其实和元素类型的向量一致。
    </li>



  
  
  
  </ul>





  
  
  
  <h2><a name="typeid"></a><code style="white-space: normal;">typeid</code> 信息不包含于存档中</h2>




  
  
  
  <p>原来我曾经想将由 <code style="white-space: normal;">std::type_of::name()</code> 得到的类名保存到存档中。但是这有困难，由于 <code style="white-space: normal;">std::type_of::name()</code> 不是可移植的，也不保证返回的是类名。这对于实现存档的可移植性毫无用处。该主题的详细解释请见
  <a href="bibliography.html#6">[7] 第206页</a>。所以它不是必须的。只要对象严格按照保存时的顺序来导入，那么导入时的类型就是有效的。唯一的例外发生在遇到从未导入/保存过的多态指针时。这种情况的解决方法是 <code style="white-space: normal;">register_type()</code>
和/或在参考中介绍的 <code style="white-space: normal;">export</code> 工具。实际，<code style="white-space: normal;">export</code> 生成了一个可移植的
  <code style="white-space: normal;">typeid</code> 等效物。

  </p>



  
  
  
  <h2><a name="trap"></a>保存一个非-const值时的编译期陷阱</h2>

以下代码不能通过编译。失败将发生在某行
  <code style="white-space: normal;">BOOST_STATIC_ASSERT</code> 上。这里我们称之为编译期陷阱。
  <code style="white-space: normal;"></code>
  
  
  
  <pre>T t;<br>ar &lt;&lt; t;<br></pre>

除非 tracking_level 序列化 trait 被设为 "track_never". 而以下代码则可以编译，没有问题：

  <code style="white-space: normal;"></code>
  
  
  
  <pre>const T t<br>ar &lt;&lt; t;<br></pre>

类似地，以下代码也会进入编译期陷阱：<code style="white-space: normal;"></code>
  
  
  
  <pre>T * t;<br>ar &gt;&gt; t;<br></pre>

如果 tracking_level 序列化 trait 被设为 "track_never".
  
  
  
  <p>这种行为是矛盾的，以后可能会被修正。主要的批评是，指出的代码实际上是正确的，还要强迫用户插入
  <code style="white-space: normal;">const_cast</code>. 我的观点是：
  </p>



  
  
  
  <ul>




  <li>这个陷阱是有用的，可以检测出这类程序错误。
  </li>



    <li>否则这种错误是很难发现的。
  </li>



    <li>与它带来的好处相比，这个陷阱带来的不方便是非常微小的。
    </li>



  
  
  
  </ul>

下面的例子示范了我的观点。该代码原本是 Peter Dimov 的邮件列表中的一个例子。

  <code style="white-space: normal;"></code>
  
  
  
  <pre>class construct_from <br>{ <br>    ... <br>}; <br><br>void main(){ <br>    ... <br>    Y y; <br>    construct_from x(y); <br>    ar &lt;&lt; x; <br>} <br></pre>

假设没有前面所说的陷阱，那么：
  
  
  
  <ol>




  <li>这个例子可以编译和正常执行。由于 
  construct_from 从未以指针方式进行序列化，所以不会有跟踪信息。过了一段时间，另一个程序员(2)来了，要增加一些功能。他认为存档有点象日志。<code style="white-space: normal;"></code>
      
      
      
      <pre>void main(){ <br>    ... <br>    Y y; <br>    construct_from x(y); <br>    ar &lt;&lt; x; <br>    ... <br>    x.f(); // change x in some way <br>   ... <br>    ar &lt;&lt; x <br>} <br></pre>




  
      
      
      


      
      
      
      <p>还是没有问题。他在存档中得到了两份不同的拷贝。这正是他想要的，他自然很高兴。</p>



    </li>



    <li>再过了一段时间，第三个程序员(3)看到了 construct_from，并且说 - 
  喔酷，这正是我要的。他在另一个完全分离的模块中写了一个函数(这个项目太大了，他没有了解原来已有的用法)。他写下了这样的代码：<code style="white-space: normal;"></code>
      
      
      
      <pre>class K { <br>    shared_ptr &lt;construct_from&gt; z; <br>    template &lt;class Archive&gt; <br>    void serialize(Archive &amp; ar, const unsigned version){ <br>        ar &lt;&lt; z; <br>    } <br>}; <br></pre>





  
      
      
      


      
      
      
      <p>他构建并运行了这个程序，测试了他新增的功能。一切顺利，他也很高兴。</p>



    </li>



    <li>和之前一样，事情依然很平稳。一个月过去了，直到从上个月创建的存档中进行导入时(读入日志)，才发现有问题。程序不能工作了。
第二个日志项总是与第一个一样。经过一系列非常长和严厉的电子邮件的反复，才发现原来是程序员(3)不小心破坏了程序员(2)的代码。由于要通过指针进行
序列化，"log" 对象现在需要被跟踪了。这是因为缺省的跟踪行为是 "track_selectively".
即某个类实例要被跟踪当且仅当它们在程序中的某处被通过指针进行序列化。现在从同一地址进行的多次保存只会在第一次时写入到存档中。之后的保存仅仅会向存
档中加入地址信息 -
即使数据可能已经被改变。当进行数据导入时，日志记录的所有实例都会呈现相同的数据。这样，某个代码片段的行为由于另一个独立模块的修改所带来的副作用而
改变。更差的是，数据会丢失，不能从存档中恢复。人人都非常沮丧，并且对 boost (至少是其中的序列化系统)感到失望。


    </li>



    <li>经过大量的调查研究，终于发现了这个问题的根源，并且将类 construct_from 标记为 "track_never"，指定：<code style="white-space: normal;"></code>
      
      
      
      <pre>BOOST_SERIALIZATION_TRACKING(construct_from, track_never) <br></pre>




  </li>



    <li>现在所有东西又都正常工作了。或者说 - 看起来是这样。


    </li>



    <li><code style="white-space: normal;">shared_ptr&lt;construct_from&gt;</code>
的多个实例间不再共享单个裸指针。每一个导入的 
      <code style="white-space: normal;">shared_ptr&lt;construct_from&gt;</code> 都有自己独立的裸指针。这将破坏 
      <code style="white-space: normal;">shared_ptr</code> 并导致内存泄漏。再者，导致该问题的地方远离发现问题的地方。直到导入存档之后，才可能发现该问题。现在我们不仅很难发现和修正这个 bug, 而且我们还有了一堆无效的存档和丢失的数据。
    </li>



  
  
  
  </ol>

现在考虑一下如果有陷阱的话，会发生什么事情：



  
    
    
    
  <ol>



    <li>马上，程序会在这里陷入错误<code style="white-space: normal;"></code>
      
      
      
      <pre>ar &lt;&lt; x; <br></pre>




  
      
      
      


    </li>



    <li>程序会咒骂(或者是 %^&amp;*&amp;*). 如果他很急(或者不急)且不想使用 <code style="white-space: normal;">const_cast</code>
  - 因为这样看起来很差。那么他只能把代码改成这样才能继续：<code style="white-space: normal;"></code>
      
      
      
      <pre>Y y; <br>const construct_from x(y); <br>ar &lt;&lt; x; <br></pre>




  
      
      
      


      
      
      
      <p>现在可以正常工作了，他也可以继续了。</p>



    </li>



    <li>现在程序员(2)想进行修改 - 再一次碰到恼人的 const 问题：<code style="white-space: normal;"></code>
      
      
      
      <pre>Y y; <br>const construct_from x(y); <br>... <br>x.f(); // 以某种方式修改 x ; 由于 f() 不是 const 的，所以编译错误<br>... <br>ar &lt;&lt; x <br></pre>




  
      
      
      
      <p>他现在有点恼火，于是他尝试这样： 
  </p>



      
      
      
      <ul>




    <li>他考虑将 f() 变为 const 的 - 但是这样会使得 const 
    错误出现在别处。并且他也不想为了这个序列化系统中的怪癖而修改他的代码。


        </li>



        <li>他从前面的&nbsp;<code style="white-space: normal;">const construct_from</code> 中删去 <code style="white-space: normal;">const</code> - 他又重新陷入了错误。如果他看到发生 
    <code style="white-space: normal;">BOOST_STATIC_ASSERT</code>
    处的注释，那么它将会做以下其中一件事情：



      
            
            
            
          <ol>



            <li>这是令人疯狂的。它让我难受，看起来代码是好的。所以我使用了 <code style="white-space: normal;">const_cast</code>
      来解决问题，并通过邮件列表发出抱怨，希望有人可以解决它。这样，故事回到了前面的情节。


            </li>



            <li>喔，这个陷阱提示我，缺省的序列化不是我想要的。当然在这个特定程序中不是这样。但是这里的代码并不能真正代表其它模块中的代码(甚至可能是尚未写出的代码)。OK, 我将在 construct_from.hpp 中加上以下代码以解决这个问题。 
              <code style="white-space: normal;"></code>
              
              
              
              <pre>BOOST_SERIALIZATION_TRACKING(construct_from, track_never) <br></pre>




    </li>



          
          
          
          </ol>




  </li>



      
      
      
      </ul>




  
      
      
      


    </li>



    <li>现在程序员(3)接着要修改代码。原有代码(位于其它模块中)的行为保持不变，因为 
  <code style="white-space: normal;">construct_from</code> trait 被设为 "track_never"，所以他总是能得到对象的拷贝，而 log 的行为也正是我们想要的。


    </li>



    <li>不过现在他进入了另一个陷阱 - 试图通过指针保存一个标记为 "track_never" 的类的对象。所以他回到 
  construct_from.hpp 并且注释掉了被插入的 
  <code style="white-space: normal;">BOOST_SERIALIZATION_TRACKING</code>. 现在第二个陷阱被躲过了，但是 - 第一个陷阱又再次出现。最后，在重新编写了部分代码后，终于可以满足序列化 <code style="white-space: normal;">construct_from</code> 的不同要求了。
    </li>



  
  
  
  </ol>

请注意，在第二种情况中：
  
  
  
  <ul>




  <li>所有错误都会在编译期发现。
  </li>



    <li>不会创建无效的存档。
  </li>



    <li>没有数据丢失。
  </li>



    <li>没有运行期错误发生。
    </li>



  
  
  
  </ul>

确实，这些陷阱有时会指出当前正确的代码有错，这会惹恼一些程序员。但是，以上例子证明了我的观点，即这些陷阱是很有用的，这些不愉快只是很少的代价，它们可以避免程序的错误。<!--
<h2><a name="footnotes"></a>Footnotes</h2>
<dl>
  <dt><a name="footnote1" class="footnote">(1)</a> {{text}}</dt>
  <dt><a name="footnote2" class="footnote">(2)</a> {{text}}</dt>
</dl>
-->
  
  
  
  <hr>
  
  
  
  <p><i>&copy; Copyright <a href="http://www.rrsd.com">Robert Ramey</a> 2002-2004. 
Distributed under the Boost Software License, Version 1.0. (See
accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
  </i></p>




</li>



</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<!--
(C) Copyright 2002-4 Robert Ramey - http://www.rrsd.com . 
Use, modification and distribution is subject to the Boost Software
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
-->







  
  
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">








  
  
  
  
  
  
  
  <link rel="stylesheet" type="text/css" href="../../../boost.css">








  
  
  
  
  
  
  
  <link rel="stylesheet" type="text/css" href="style.css">








  
  
  
  
  
  
  
  <title>Serialization - Special Considerations</title>
</head>


<body link="#0000ff" vlink="#800080">








<table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">








  <tbody>







    <tr>







 
    <td valign="top" width="300"> 
      
      
      
      
      
      
      
      
      <h3><a href="../../../index.htm"><img alt="C++ Boost" src="../../../boost.png" border="0" height="86" width="277"></a></h3>








    </td>








    <td valign="top"> 
      
      
      
      
      
      
      
      
      <h1 align="center">Serialization序列化</h1>








      
      
      
      
      
      
      
      
      <h2 align="center">特殊的考虑</h2>








    </td>








  </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<hr>
<dl class="page-index">








  <li><a href="#objecttracking">对象跟踪</a>
  </li>







  <li><a href="#export">Exporting 类的序列化</a>
  </li>







  <li><a href="#classinfo">类的信息</a>
  </li>







  <li><a href="#portability">存档的可移植性</a>
  </li>







  
  
  
  
  
  
  
  <dl class="page-index">








    <dt><a href="#numerics">数字</a>
    </dt>







    <dt><a href="#traits">Traits</a>
  </dt>







  
  
  
  
  
  
  
  </dl>








  <li><a href="#binary_archives">二进制存档</a>
  </li>







  <li><a href="#xml_archives">XML 存档</a></li>

  <li><a href="#dlls">DLLS - 序列化与运行期链接</a> 
  </li>

  <li><a href="#multi_threading">多线程</a> 
  </li>

  <li><a href="#optimizations">优化</a></li>







  <li><a href="exceptions.html">存档的异常</a>
  </li>







  <li><a href="exception_safety.html">异常安全性</a>
  </li>







</dl>









<h3><a name="objecttracking">对象跟踪</a></h3>






依赖于类的使用方法以及其它因素，序列化的对象以内存地址来跟踪。这样可防止同一个对象被多次写入存档或多次读出。这个保存的地址也可以在导入过程由于异常抛出而中断时用于删除已创建的对象。  
<p>如果在一个程序中，不同对象的拷贝被保存在同一地址，这种方式就会导致问题。
</p>







<pre><code>
template&lt;class Archive&gt;
void save(boost::basic_oarchive  &amp; ar, const unsigned int version) const
{
    for(int i = 0; i &lt; 10; ++i){
        A x = a[i];
        ar &lt;&lt; x;
    }
}
</code></pre>








以这个例子中，要保存的数据位于栈中。循环的每次迭代都更新栈中的值。虽然数据在每次迭代都被改变，但数据的地址没有变。如果 a[i] 是一个以内存地址进行跟踪的对象的数组，则本库会跳过第一次以后的所有对象保存，因为它假定同一地址的对象是相同的对象。
<p>为了帮助检测出这种情形，输出存档操作符要求以
<code style="white-space: normal;">const</code> 引用作为参数传入。
</p>







<p>这样，以上代码将引发一个编译期断言。显然，上例应被修改为：
</p>







<pre><code>
template&lt;class Archive&gt;
void save(boost::basic_oarchive &amp; ar, const unsigned int version) const
{
    for(int i = 0; i &lt; 10; ++i){
        ar &lt;&lt; a[i];
    }
}
</code></pre>






才可以正确地编译和运行。将输出存档操作符声明为 <code style="white-space: normal;">const</code>&nbsp;可以确保序列化的过程中不会改变被序列化对象的状态。试图改变对象的状态会使得状态保存这一概念增加某些不明确的副作用。这几乎肯定是一种错误，并且可能会引发微妙的 bugs.
<p>不幸的是，当前的实现方法在数据项被包装为一个名字-值对时，不能检测这种错误。
</p>







<p>当不同的对象被导入且导入地址不是最终位置时，也会发生同样的问题：
</p>







<pre><code>
template&lt;class Archive&gt;
void load(boost::basic_oarchive  &amp; ar, const unsigned int version) const
{
    for(int i = 0; i &lt; 10; ++i){
        A x;
        ar &gt;&gt; x;
        std::m_set.insert(x);
    }
}
</code></pre>





在这种情况下，被跟踪的是 <code>x</code> 的地址，而不是被加入到 set 中的新项的地址。这样会破坏象通过指针导入对象这样的跟踪特性。程序中会被引入奇怪的 bugs.  要解决这个问题，可以把代码改为：

<pre><code>
template&lt;class Archive&gt;
void load(boost::basic_iarchive  &amp; ar, const unsigned int version) const
{
    for(int i = 0; i &lt; 10; ++i){
        A x;
        ar &gt;&gt; x;
        std::pair&lt;std::set::const_iterator, bool&gt; result;
        result = std::m_set.insert(x);
        ar.reset_object_address(&amp; (*result.first), &amp;x);
    }
}
</code></pre>





这样就可以调整跟踪信息，以反映出变量的最终位置，从而解决上述问题。
<p>如果已经知道不会有指针的值重复，就可以去掉对象跟踪以减少开销，方法是适当设置与对象跟踪相关的类序列化 trait.
</p>







<p>缺省地，被类序列化 trait 中的 
<a target="detail" href="traits.html#level">实现级别</a> 指定为基本级的数据类型不会被跟踪。如果想要跟踪一个通过指针访问的共享基本对象(如一个
用作引用计数的 <code style="white-space: normal;">long</code>)，则要将它包装到一个类/结构中以成为一个可确认的类型。另一个方法是，修改 <code style="white-space: normal;">long</code> 的实现级别，这将影响整个程序中的所有 <code style="white-space: normal;">long</code> 的序列化 - 这可能不是你想要的。
</p>







<p>有可能我们想跟踪一个从未通过指针进行序列化的对象。例如，虚基类只需保存/导入一次。通过将它的序列化 trait 设置为 <code style="white-space: normal;">track_always</code>, 我们可以禁止多余的保存/导入操作。
</p>







<pre><code>
BOOST_CLASS_TRACKING(my_virtual_base_class, boost::serialization::track_always)
</code></pre>









<h3><a name="export">Exporting 类的序列化</a></h3>








在本手册的&nbsp;<a target="detail" href="traits.html#export">其它地方</a>，我们讨论了 
<code style="white-space: normal;">BOOST_CLASS_EXPORT</code>. 它用于让序列化库对一个给定的类进行序列化代码的实例化，即使该类还未被该程序使用过。通过一个虚基类指针实现指针的序列化是需要这一功能。这就是多态指针。 
<p>该宏指定一个"全局唯一标识符<b>G</b>lobally <b>U</b>nique <b>ID</b>entifier"。这是一个字符串，标识了在导入数据时所创建的类。通常使用该类名的文本表示就可以满足这一目的，但是在特定情况下，可能需要指定不同的字符串，这时使用 <code style="white-space: normal;">BOOST_CLASS_EXPORT_GUID</code> 而不是简单的 <code style="white-space: normal;">BOOST_CLASS_EXPORT</code>. 
</p>
<p><code style="white-space: normal;">BOOST_CLASS_EXPORT</code> 通常在相应的类声明所在的头文件中指定。即，<code style="white-space: normal;">BOOST_CLASS_EXPORT(T)</code> 是类 T 的一个  "trait". 所以使用这个类的程序会象这样： </p>
<pre><code><br>#include &lt;boost/archive/xml_oarchive.hpp&gt;<br>.... // 任意其它存档类<br>#include "my_class.hpp"  // 其中包含 BOOST_CLASS_EXPORT(my_class)<br></code></pre>
这些头文件可以按任意顺序排列。(在 boost&nbsp;1.34 及更早版本中，存档头文件必须在任何包含 <code style="white-space: normal;">BOOST_CLASS_EXPORT</code> 的头文件之前) 任何需要序列化由 <code style="white-space: normal;">BOOST_CLASS_EXPORT</code> 指定的类型的代码会为每一个被包含了头文件的存档进行实例化。(注意，不管代码是否被实际调用，它都会被实例化) 如果没有包含任何存档头文件 - 则没有代码会被实例化。这将允许 <code style="white-space: normal;">BOOST_CLASS_EXPORT</code> 作为 <code style="white-space: normal;">my_class.hpp</code> 的永久组成部分。 
<p>注意，这一功能的实现依赖于厂家对C++语言的特殊扩展。所以，不能保证使用了这一功能的程序的可移植性。不过，所有测试过 boost 的C++编译器均提供所需的扩展。本库包含了这些编译器所要求的额外声明。有理由相信未来的C++编译器会支持这些扩展或相应功能。<br>
</p>
<h3><a name="classinfo">类的信息</a></h3>




缺省情况下，对于每个被序列化的类，该类的信息会被写到存档中。这些信息包括版本号、实现级别和跟踪行为。这是必要的，即使新版本的程序修改了类的一些当
前的 trait
值，存档也可以被正确地反序列化。这些数据所占的空间是很少的。这有一点运行时间的开销，因为每个类都必须被检查，以确定该类的信息是否已包含在存档中。
有些情况下，这些开销会被认为太大了。这些开销可以被消除，方法是将类 trait 中的 <a target="detail" href="traits.html#level">实现级别</a>
设为 <code style="white-space: normal;">boost::serialization::object_serializable</code>. 
<p>
<i>关闭跟踪和类信息的序列化，将生成纯的模板内联代码，理论上可以优化为简单的流读/写。</i>以这种方式消除所有序列化的开销是有代价的。一旦存
档被发布给了用户，类的序列化 traits
就不能改变了，否则会使得旧的存档不可用。在存档中包含类的信息，可以保证即使类的定义被修改，已有存档也都是可读的。一个轻量级结构，如显示的像素，可
以在头文件中声明如下：
</p>







<pre><code><br>#include &lt;boost/serialization/serialization.hpp&gt;<br>#include &lt;boost/serialization/level.hpp&gt;<br>#include &lt;boost/serialization/tracking.hpp&gt;<br><br>// 像素是一个轻量级</code><code>但被大量使用</code><code>的结构<br>struct pixel<br>{<br>    unsigned char red, green, blue;<br>    template&lt;class Archive&gt;<br>    void serialize(Archive &amp; ar, const unsigned int /* version */){<br>        ar &lt;&lt; red &lt;&lt; green &lt;&lt; blue;<br>    }<br>};<br><br>// 消除序列化的开销，代价是不能再修改该版本了<br>BOOST_CLASS_IMPLEMENTATION(pixel, boost::serialization::object_serializable);<br><br>// 消除对象跟踪 (即使是通过指针进行序列化)<br>// 风险是程序有可能错误地创建重复的对象<br>BOOST_CLASS_TRACKING(pixel, boost::serialization::track_never)<br></code></pre>









<h3><a name="portability">存档的可移植性</a></h3>



有几个存档类是以文本形式或可移植的二进制格式来创建它们的数据。因此有可能在一个平台上保存一个类而在另一个平台上导入。这受制于几个条件。
<h4><a name="numerics">数字</a></h4>



读取存档的机器的体系必须可以处理被保存的数据。例如，gcc 编译器用4个字节来保存一个类型为
<code style="white-space: normal;">wchar_t</code> 的变量，而其它编译器只用2个字节。因此有可能写入的值不能被导入程序正确表示。这是很明显的，使用
<a target="cstding" href="../../../boost/cstdint.hpp">&lt;boost/cstdint.hpp&gt;</a> 中的数字类型就可以很容易地解决。
<p>一个特定的整数类型是 <code>std::size_t</code>，它是对一个保证足以保存任意集合大小的整数类型的 typedef, 
但是它的实际大小可以在不同平台上有所不同。包装器 <a href="wrappers.html#collection_size_type"><code>collection_size_type</code></a> 使得对存档中的集合大小的序列化具有可移植性。对集合大小的可移植序列化建议使用64位或可变长度的整数表示。 </p>


<h4><a name="traits">Traits</a></h4>



另一个潜在的问题可以用以下例子来说明：
<pre><code>
template&lt;class T&gt;
struct my_wrapper {
    template&lt;class Archive&gt;
    Archive &amp; serialize ...
};

...

class my_class {
    wchar_t a;
    short unsigned b;
    template&lt;&lt;class Archive&gt;
    Archive &amp; serialize(Archive &amp; ar, unsigned int version){
        ar &amp; my_wrapper(a);
        ar &amp; my_wrapper(b);
    }
};
</code></pre>



如果 <code style="white-space: normal;">my_wrapper</code> 使用缺省的序列化
traits，就会有问题。对于缺省的 traits, 每一次添加一个新的类型到存档中，会加入相应的薄记信息。所以在本例中，存档中会包含 
<code style="white-space: normal;">my_wrapper&lt;wchar_t&gt;</code> 和
<code style="white-space: normal;">my_wrapper&lt;short_unsigned&gt;</code> 的薄记信息。真是如此吗？如果编译器视 
<code style="white-space: normal;">wchar_t</code> 为 <code style="white-space: normal;">unsigned short</code> 的同义字，又该如何？这时只有一个类型 - 而不是两个。如果存档在两个由不同编译器所编译的程序间交换，而两个编译器将 <code style="white-space: normal;">wchar_t</code> 视为不同的类型，那么导入操作将以一种悲惨的方式失败。
<p>一种解决方法是，将模板
<code style="white-space: normal;">my_template</code> 的序列化 traits 赋为该模板的实例的类信息不被序列化。这个过程在&nbsp;<a target="detail" href="traits.html#templates">这里</a>&nbsp;介绍且已被用于 <a target="detail" href="wrappers.html#nvp"><strong>名字-值对</strong></a>。上例中的
Wrappers 显然应该赋予这样的 traits.
</p>







<p>另一种避免这个问题的方法是，将模板 <code style="white-space: normal;">my_wrapper</code> 对于所有基本类型的特化版本，都将序列化 traits
赋为不保存类信息。这正是我们在STL集合序列化的实现中所做的。

</p>







<h3><a name="binary_archives">二进制存档</a></h3>


在一些系统上的标准流 i/o 会在输出时将 LF 字符扩展为 CR/LF. 这对于二进制存档会有问题。最容易的解决方法是，使用标志
<code style="white-space: normal;">ios::binary</code> 来以 "二进制模式"&nbsp;打开二进制存档。如果不这样做，那么生成的存档将是不可读的。
<p>不幸的是，没有办法在导入存档之前检测到这种错误。为调试而构建的版本会在检测到该错误时产生断言失败，这样有助于捕捉该错误。

</p>







<h3><a name="xml_archives">XML 存档</a></h3>


XML 存档有些特殊。XML 格式是一种嵌套结构，可以很好地映射到序列化系统所用的 "recursive class member
visitor" 模式。不过，XML
与其它格式的不同在于，它要求每个数据成员都有一个名字。我们的目标是将这个信息增加到类的序列化规范中，同时也要允许序列化代码可以用于任何类型的存
档。方法是要求所有序列化到 XML 存档中的数据以 <a target="detail" href="wrappers.html#nvp">名字-值对</a> 的方式进行序列化。其中第一个成员为用作与数据项对应的 XML 标志的名字，而第二个成员则是数据项本身的引用。试图将未包装为 <a target="detail" href="wrappers.html#nvp">名字-值对</a> 的数据进行序列化会在编译期被捕获。系统对于其它存档类也以相同方式执行，但是仅对数据中的值部分进行序列化。名字部分将在编译时被忽略。因此，只要保持使用 <a target="detail" href="wrappers.html#nvp">名字-值对</a>，就可以保证所有数据都以最大效率序列化到所有的存档类。
<h3><a name="dlls">DLLS - 序列化与运行期链接</a></h3>
序列化代码可以置于运行期链接的库中。即，这些代码可以被置于DLLS(Windows)或共享库(*nix)中。这与 "export" 
工具一起，就可以允许在不知道被序列化的实际类型的情况下编写程序。这个包中没有包含使用这一技术的例子 - 但是相关代码与例子 <a href="../example/demo_pimpl.cpp" target="demo_pimpl"><code style="white-space: normal;">demo_pimpl.cpp</code> </a>, <a href="../example/demo_pimpl_A.cpp" target="demo_pimpl"><code style="white-space: normal;">demo_pimpl_A.cpp</code> </a>和 <a href="../example/demo_pimpl_A.hpp" target="demo_pimpl"><code style="white-space: normal;">demo_pimpl_A.hpp</code> </a>非常相似，这三个文件实现了序列化代码从主程序的完全分离。 
<h3><a name="multi_threading">多线程</a></h3>
如果多线程同时对单个存档进行读/写，这样的序列化自然是有冲突的。不过由于每个存档与其它存档相互无关，所以在一个或多个线程中打开多个存档是没有问题的。 
<p>喔，这并不完全。 
</p>
<p>有一组全局数据结构用于保存可序列化类型的信息。这些结构被用于分派正确的代码来处理每一对可序列化类型和存档类型。由于这些信息是由所有存档共享的，这就有潜在的问题了。这些问题已经在本库的仔细实现中得到解决，这些结构全都在 <code style="white-space: normal;">main(...)</code> 被调用之前完成初始化。这以后它们不再改变。所以在同时打开多个存档时也不会有问题 - 不论是从同一个还是不同的线程打开。 
</p>
<p>喔，差不多了。 
</p>
<p>对于动态装入的代码 - DLLS或共享库，这些全局数据结构在一个库被装入或卸载时可以发生改变。即在这种情况下，这些全局数据结构可以在 <code style="white-space: normal;">main(...)</code> 被调用之后改变。所以，如果一个线程在某个存档被打开时动态装入/卸载含有序列化代码的模块，就可能有问题。还有，如果同样的装入/卸载操作同时在其它线程中发生，也同样存在问题。 
</p>
<p>这可能不容易控制。有些系统可能直到真正需要某个模块时才会装入它。所以即使我们以为没有这样的动态装入/卸载代码，它仍然有可能发生，以"帮助"管理资源。在这些系统上，访问存档的代码必须使用某些多线程结构来同步，才能正常使用。 
</p>
<h3><a name="optimizations">优化</a></h3>
在性能至关重要的应用中，对于相同类型的连续数据的序列化，你可能希望避免逐个数据进行序列化的开销，这正是 <a href="wrappers.html#arrays"><code>array</code></a> 
包装器的原因。对于包含相同类型的连续数组的数据类型，如 <code>std::vector</code>, 
<code>std::valarray</code> 或 <code>boost::multiarray</code>，序列化函数将使用一个 <a href="wrappers.html#arrays"><code>array</code></a> 包装器来序列化它们，以使用这些优化技术。可以为相同类型的连续数组提供优化序列化的存档类型，应通过重载对 <a href="wrappers.html#arrays"><code>array</code></a> 包装器的序列化函数来实现，对于二进制存档就是如此。 

<h3><a href="exceptions.html">存档的异常</a></h3>








<h3><a href="exception_safety.html">异常安全性</a></h3>









<hr>
<p><i>&copy; Copyright <a href="http://www.rrsd.com/">Robert Ramey</a> 2002-2004. 
Distributed under the Boost Software License, Version 1.0. (See accompanying 
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) </i></p>
<p></p>
<p></p>








</body>
</html>

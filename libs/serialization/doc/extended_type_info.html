<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<!--
(C) Copyright 2002-4 Robert Ramey - http://www.rrsd.com . 
Use, modification and distribution is subject to the Boost Software
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
-->


  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">



  
  
  <link rel="stylesheet" type="text/css" href="../../../boost.css">



  
  
  <link rel="stylesheet" type="text/css" href="style.css">



  
  
  <title>Serialization - extended_type_info</title>
</head>


<body link="#0000ff" vlink="#800080">



<table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">



  <tbody>


    <tr>


 
    <td valign="top" width="300"> 
      
      
      
      <h3><a href="../../../index.htm"><img alt="C++ Boost" src="../../../boost.png" border="0" height="86" width="277"></a></h3>



    </td>



    <td valign="top"> 
      
      
      
      <h1 align="center">Serialization序列化</h1>



      
      
      
      <h2 align="center"><code style="white-space: normal;">extended_type_info</code></h2>



    </td>



  </tr>



  
  
  </tbody>
</table>



<hr>
<dl class="page-index">



  <li><a href="#motivation">动机</a>
  </li>


  <li><a href="#runtime">运行时接口</a>
  </li>


  <li><a href="#requirements">要求</a>
  </li>


  <li><a href="#models">模型</a></li>
  <li><a href="#example">例子</a></li>


</dl>





<h3><a name="motivation">动机</a></h3>


serialization 库需要一个类似于 
<code style="white-space: normal;">type_info/typeid()</code> 的系统来执行以下功能
<ol>



  <li>给定一个类型 T 的指针，得到所指物的真实类型。
  </li>


  <li>给定一个 "外部" 键 - 确定要创建的对象的类型。
  </li>


</ol>



<h3> <code style="white-space: normal;">std::type_info</code>&nbsp;的问题<code style="white-space: normal;"></code></h3>



<ul>



  <li>我们想要的主要函数 - <code style="white-space: normal;">std::typeid()</code>
    并不是在所有环境下都可用的。该函数的支持信赖于编译器对运行期类型识别(RTTI)的支持。这有可能因为效率的原因而不提供或不激活。
  </li>


  <li>
    <code style="white-space: normal;">std::type_info</code> 包括一个包含了类型名的字符串。看起来满足上述的第2)项。但该字符串的格式在不同的编译器、库、操作系统的环境下是不一致的。这使得它不能用于可移植的存档。
  </li>


  <li>即使类型名字符串可以实现可移植性，也不能保证在不同应用中类的头文件被包含在相同的名字空间中。事实上，在不同的名字空间中包含不同的头文件正是避免名字空间冲突的常用方法。所以 namespace::class_name 不能被用作关键字。
  </li>


  <li>我们还可能希望可以通过基类来序列化一个对象，即使它没有虚拟函数。即该类的对象并不是严格C++意义上的多态类。在标准系统中这是不能支持的。
  </li>


  <li>有可能不同的类使用了不同的 type id 
    机制。类的头文件可能包含此信息。如果我们想跨应用引入类的头文件，就需要 type id
    机制支持不同 type id 系统间的互操作。
  </li>


</ul>



<h3>特性</h3>



<code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 是 <code style="white-space: normal;">std::type_info</code> 功能的一个实现，并具有以下特性：
<ul>



  <li>维护 <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 记录的一张全局表格 - 程序中每个已知类型对应一条记录。
  </li>


  <li>允许关联一个任意的关键字到一个类型。通常这个关键字就是类的名字 - 但也可以不是。这个关键字被称为 GUID - 全局唯一标识。它被假定为是宇宙中唯一的。典型地，这个 GUID 应位于头文件中并用于匹配跨应用的类型。
  </li>


  <li>允许 "混用" 各种类型信息系统。例如，一个类可以使用 
    <code style="white-space: normal;">typeid()</code> 来查找类的外部标识，而另一个类则可以不用如此。
  </li>


</ul>

序列化系统维护两张全局表格：
<ul>



  <li>第一张是全局类型表格。每一个使用的类型对应一行。每一行是派生自 
  <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 的某个类的一个实例。这张表格用于为给定的类型取出唯一的 <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code>
  信息。
  </li>


  <li>第二张是全局关键字表格。每一个被赋予了 GUID 字符串关键字的类型对应一行。这张表格用于为给定的 GUID 取出唯一的 
  <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 信息。
  </li>


</ul>

本库包含两个不同的 type id 系统：
<ul>



  <li>
    <code style="white-space: normal;"><a target="extended_type_info_typeid.hpp" href="../../../boost/serialization/extended_type_info_typeid.hpp">extended_type_info_typeid</a></code>
    依据标准的
    <code style="white-space: normal;">typeid()</code> 实现。
  </li>


  <li>
    <code style="white-space: normal;"><a target="extended_type_info_no_rtti.hpp" href="../../../boost/serialization/extended_type_info_no_rtti.hpp">extended_type_info_no_rtti</a></code>
    则是一个不依赖于 RTTI 的实现。但是，它要求所有要使用 type id 的类都要显式地赋予一个外部关键字 - 其它类则可不赋。
  </li>


</ul>




<h3><a name="runtime">运行时接口</a></h3>



<pre><code ="">
namespace boost { 
namespace serialization {

class BOOST_SERIALIZATION_DECL extended_type_info : 
    private boost::noncopyable 
{
protected:
    extended_type_info(const char * type_info_key);
public:
    void self_register();
    void key_register(const char *key);
    const char * get_key() const;

    bool operator&lt;(const extended_type_info &amp;rhs) const;
    bool operator==(const extended_type_info &amp;rhs) const;
    bool operator!=(const extended_type_info &amp;rhs) const;

    static const extended_type_info * find(const char *key);
    static const extended_type_info * find(const extended_type_info * t);
};

} // namespace serialization 
} // namespace boost
</code></pre>

对于每一个类型，必须且只能创建一个 <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 实例。由于这个原因，该类派生自
<code style="white-space: normal;">boost::noncopyable</code>.



  
<dl>


  
  
  <h4>
  
  
  <pre><code>
extended_type_info(const char * type_info_key);</code></pre>


  </h4>



  <dd>这个构造函数被所有派生类调用。它被传入一个常量字符串的指针，该字符串标识了使用的 type id 系统。这个
type id 被用于区别可以使用的不同的 type id 系统，且允许它们之间的互操作。</dd>




  

  
  
  <h4>
  
  
  <pre><code>
void self_register();
</code></pre>


  </h4>



  <dd>该函数向全局类型表格添加一行。通常会从实现了 <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 功能的派生类的构造函数中调用。
  </dd>




  <dt></dt>


  
  
  <h4>
  
  
  <pre><code>
void key_register(const char *key);
</code></pre>


  </h4>



  <dd>赋一个唯一的字符串标识给这个
    <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 实例，并将它添加到相应的全局表格中。该关键字用于在不同程序实例间标识一个类型。使用了这种方法，一个实例在需要时就可以知道创建什么类型。为此，它必须在使用同一类型的所有程序实例中保持一致。
    
    
    <p>有时它也被称为 GUID - 全局唯一标识。
    </p>


  </dd>


  <dt></dt>


  
  
  <h4>
  
  
  <pre><code>
const char *get_key() const;
</code></pre>


  </h4>



  <dd>取出 <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 实例的关键字。如果该实例没有相关联的关键字，则返回 NULL.
  </dd>




  <dt></dt>


  
  
  <h4>
  
  
  <pre><code>
bool operator&lt;(const extended_type_info &amp;rhs) const;
bool operator==(const extended_type_info &amp;rhs) const;
bool operator!=(const extended_type_info &amp;rhs) const;
</code></pre>


  </h4>



  <dd>这些函数用于比较两个 <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 对象。它们用于在表格中进行查找。

  </dd>


  <dt></dt>


  
  
  <h4>
  
  
  <pre><code>
static const extended_type_info * find(const char *key);
</code></pre>


  </h4>



  <dd>给定一个字符串关键字或 <strong>GUID</strong>, 返回相对应的唯一的 <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 对象的地址。 

  </dd>


  <dt></dt>


  
  
  <h4>
  
  
  <pre><code>
static const extended_type_info * find(const extended_type_info * t);
</code></pre>


  </h4>



  <dd>给定一个
    <code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 的指针，返回在主表格中同一类型实例的地址。这里的参数 t 被用作一个查找参数，在主表格中查找给定类型的一行。它也可以这样用：
    <code></code>
    
    
    <pre>// 返回类型 T 在全局类型表格中的行<br>return find(some_extended_type_info_implementation&lt;T&gt;())<br></pre>




  </dd>


</dl>




<h3><a name="requirements">要求</a></h3>

为了被 serialization 库使用，一个
<code style="white-space: normal;">extended_type_info</code> 的实现(这里称之为 ETI)，必须实现以下要求：

<dl>




  <dt></dt>


  
  
  <h4><code style="white-space: normal;"></code>
  
  
  <pre>template&lt;class ETI&gt;<br>virtual bool<br>ETI::less_than(const extended_type_info &amp;rhs) const;<br></pre>


  </h4>



  <dd>对类 ETI 的所有实例施加严格全序。
  </dd>




  <dt></dt>


  
  
  <h4><code style="white-space: normal;"></code>
  
  
  <pre>template&lt;class ETI&gt;<br>static const extended_type_info *<br>ETI::get_derived_extended_type_info(const T &amp; t);<br></pre>


  </h4>



  <dd>返回一个 <code style="white-space: normal;">extended_type_info</code>
实例的指针，该实例对应于类型 T 的 "真实类型"。"真实类型" 是指在类层次中最底层的类型。类型 T 总是可以静态转型为 "真实类型"。该函数的实现是 type id 系统的区别之一，有时候会假定类型 T 可以用一个特殊的 <code style="white-space: normal;">extended_type_info 实现来标识。</code>
  </dd>




  <dt></dt>


  
  
  <h4><code style="white-space: normal;"></code>
  
  
  <pre>template&lt;class ETI&gt;<br>static extended_type_info *<br>ETI::get_instance();<br></pre>


  </h4>



  <dd>返回一个
    <code style="white-space: normal;">extended_type_info</code>
实例的指针，该实例对应于类型 T.  通常这些实例是静态对象，所以它只是返回静态对象的地址。
  </dd>




  <dt></dt>


  
  
  <h4><code style="white-space: normal;"></code>
  
  
  <pre>static void<br>template&lt;class ETI&gt;<br>ETI::export_register(const char * key);<br></pre>


  </h4>



  <dd>该主函数调用 key_register 来添加 GUID 到全局表格。依赖于所使用的 type id 系统，它可能执行其它初始化功能。
  </dd>



</dl>

必须定义以下类型 
<a href="../../mpl/doc/refmanual/bool.html">bool</a> 的 
<a href="../../mpl/doc/refmanual/integral-constant.html">
Itegral Constant</a>:
<dl>



  <dt></dt>


  
  
  <h4><code style="white-space: normal;"></code>
  
  
  <pre>ETI::is_polymorphic<br></pre>


  </h4>



  <dd>
  </dd>




</dl>




<h3><a name="models">模型</a></h3>

serialization 库包含两个不同的
<code style="white-space: normal;"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code> 实现。
<p>
<code style="white-space: normal;"></code></p>


<h4><a target="extended_type_info_typeid.hpp" href="../../../boost/serialization/extended_type_info_typeid.hpp">
extended_type_info_typeid</a></h4>

依据标准的 typeid() 实现。它假设编译器支持 RTTI.
<p>
<code style="white-space: normal;"></code></p>


<h4><a target="extended_type_info_no_rtti.hpp" href="../../../boost/serialization/extended_type_info_no_rtti.hpp">
extended_type_info_no_rtti</a></h4>

以不依赖于 RTTI 的方式实现。但是，它要求所有要使用 type id 的类实现以下虚拟函数：
<code></code>
<pre>virtual const char * get_key();<br></pre>

它返回最底层类的唯一字符串。该函数必须是虚拟的，以实现前述
<code style="white-space: normal;">ETI::get_derived_extended_type_info</code>
所要求的功能。<br>
<h3><a name="example">Example</a></h3>
测试程序 <code style="white-space: normal;"><a target="test_no_rtti" href="../test/test_no_rtti.cpp">test_no_rtti</a></code> 根据前述的 <code style="white-space: normal;"><a target="extended_type_info_no_rtti.hpp" href="../../../boost/serialization/extended_type_info_no_rtti.hpp">
extended_type_info</a></code> API 实现了这个函数，返回与该类相关联的外部关键字。它要求输出非抽象类。

<hr>
<p><i>&copy; Copyright <a href="http://www.rrsd.com">Robert Ramey</a> 2005. 
Distributed under the Boost Software License, Version 1.0. (See
accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
</i></p>



</body>
</html>

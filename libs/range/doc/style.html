<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Boost.Range Terminology and Style Guidelines</title>


  <link rel="stylesheet" href="style.css" type="text/css">

</head>


<body>

<table border="0">

  <tbody>

    <tr>

      <td><img src="../../../boost.png" border="0"></td>

      <td>
      <h1 align="center">Boost.Range </h1>

      </td>

    </tr>

  </tbody>
</table>

<h2>术语和风格 </h2>

<p>使用一致的术语对于 <a href="range.html">区间</a>
和基于区间的算法是很重要的，就象对于迭代器和基于迭代器的算法一样。采用一组约定俗成的名字，我们可以避免误解并写出的泛型函数原型将是<span style="font-style: italic;">自说明的</span>。 </p>

<p>由于区间的特点在于其底层的迭代器类型，我们从每一种迭代器类型得到一种区间类型。因此我们可以有以下几种类型的区间： </p>

<ul>

  <li> <i>值访问类别：</i>
    <ul>

      <li>可读区间 </li>

      <li>可写区间 </li>

      <li>可交换区间 </li>

      <li>左值区间 </li>

    </ul>

  </li>

  <li> <i>遍历类别：</i>
    <ul>

      <li> <a href="range.html#single_pass_range">单遍
区间</a> </li>

      <li> <a href="range.html#forward_range">前向区间</a>
      </li>

      <li> <a href="range.html#bidirectional_range">双
向区间</a> </li>

      <li> <a href="range.html#random_access_range">随
机访问区间</a> </li>

    </ul>

  </li>

</ul>

注意，我们使用的是 <a href="../../iterator/doc/new-iter-concepts.html">新
式迭代器</a> 的分类类别。
<p>一个迭代器(或一个区间)有一个<span style="font-style: italic;">遍
历</span>属性和一个或多个<span style="font-style: italic;">值访问</span>类
别。所以事实上我们多数时候讨论的是一个混合物，如： </p>

<ul>

  <li>随机访问可读可写区间 </li>

  <li>前向左值区间 </li>

</ul>

为了方便起见，我们总是先指定<span style="font-style: italic;">遍历</span>属
性，象上面那样。因为只有一个<span style="font-style: italic;">遍历</span>属
性而可能有多个<span style="font-style: italic;">值访问</span>属
性，所以这是合理的。
<p></p>

<p>不过，只指定一个类别也是合理的，如果不关心另一个类别的话。例如，<a href="utility_class.html#iter_range">iterator_range</a>
可以从一个前向区间构造。这意味着我们不关心这个区间的<span style="font-style: italic;">值
访问</span>属性。同样，一个可读区间具有最小可能的<span style="font-style: italic;">遍
历</span>属性(单遍)。 </p>

<p>再看另一个例子，我们如何指定 <code>std::sort()</code> 的接口。通常，算法在指定接口时很麻烦，因为必须
同时精确地定义<span style="font-style: italic;">遍历</span>和<span style="font-style: italic;">值访问</span>属性。基于迭代器的版本如下：
</p>

<pre> <span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">RandomAccessTraversalReadableWritableIterator </span><span class="special">&gt;<br> </span><span class="keyword">void </span><span class="identifier">sort</span><span class="special">( </span><span class="identifier">RandomAccessTraversalReadableWritableIterator </span><span class="identifier">first</span><span class="special">,<br> </span><span class="identifier">RandomAccessTraversalReadableWritableIterator </span><span class="identifier">last </span><span class="special">);</span>
</pre>

而对于区间来说，接口变为：
<pre> <span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">RandomAccessReadableWritableRange </span><span class="special">&gt;<br> </span><span class="keyword">void </span><span class="identifier">sort</span><span class="special">( </span><span class="identifier">RandomAccessReadableWritableRange</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);</span>
</pre>

<p></p>

<p> </p>

<hr>&copy; <a id="Copyright" name="Copyright">Copyright</a> Thorsten Ottosen 2008. 
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying 
file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a>) 
</p>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

        
        
  <title>Boost.Range Reference</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        
  <link rel="stylesheet" href="style.css" type="text/css">
</head>


    <body>

        
<table>

            <tbody>
    <tr>

                <td><img src="../../../boost.png" border="0" width="100%"></td>

                <td>
      <h1><br>

                        Boost.Range
                    </h1>

                </td>

            </tr>

        
  </tbody>
</table>

        
<h2>概要及参考
        </h2>

        
<ul>

            <li>
                <a href="#overview">简介</a>
            </li>
  <li>
                <a href="#Synopsis">概要</a>
            </li>
  <li>
                <a href="#Semantics">语义</a>
            </li>
  <li>
                <a href="#minimal_interface">扩展本库</a></li>

        
</ul>

        
<hr size="1">
        <a name="overview"></a>
        
<h3>简介</h3>

        
<p>本库当前支持四种对象类型： </p>

<ul>
  <li>类似于标准的容器 
  </li>
  <li><code>std::pair&lt;iterator,iterator&gt;</code></li>
  <li>内建数组 </li>
</ul>
虽然主模板的缺省行为是要正确提供对标准容器的支持，但是其要求要低于标准容器的要求。例如，工具类 <a href="utility_class.html#iter_range"><code>iterator_range</code></a> 实现了满足 <a href="range.html#forward_range">前向区间</a> 的 <a href="boost_range.html#minimal_interface">最小接口</a>。 

<p>更多细节请参见 <a href="range.html">区间概念</a>。</p>
<a name="Synopsis"></a>
        
<h3>概要</h3>

        
<p>
            </p>
<pre><span class="keyword">namespace </span><span class="identifier">boost</span>
<span class="special">{<br>    </span><span class="comment">//<br>    // </span><span class="comment">单遍区间的元函数<br>    //<br>                   <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><a href="#range_iterator"><span class="identifier">range_iterator</span></a><span class="special">;<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><a href="#range_value"><span class="identifier">range_value</span></a><span class="special">;<br>  <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><a href="#range_reference"><span class="identifier">range_reference</span></a><span class="special">;<br><br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><a href="#range_pointer"><span class="identifier">range_pointer</span></a><span class="special">;<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><a href="#range_category"><span class="identifier">range_category</span></a><span class="special">;<br><br>    </span><span class="comment">//<br>    // 前向区间的元函数<br>    //<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><a href="#range_difference"><span class="identifier">range_difference</span></a><span class="special">;<br>    <br>    </span><span class="comment">//<br>    // 双向区间的元函数<br>    //<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><a href="#range_reverse_iterator"><span class="identifier">range_reverse_iterator</span></a><span class="special">;<br>    <br>    </span><span class="comment">//<br>    // 单遍区间的函数<br>    //<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#begin"><span class="identifier">begin</span></a><span class="special">( </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#begin"><span class="identifier">begin</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>        <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#end"><span class="identifier">end</span></a><span class="special">( </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>                      <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#end"><span class="identifier">end</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">bool<br>    </span><a href="#empty"><span class="identifier">empty</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>               <br>    </span><span class="comment">//<br>    // 前向区间的函数<br>    //<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_difference</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#size"><span class="identifier">distance</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>                            <br>    </span><span class="comment">//<br>    // 双向区间的函数<br>    //<br>                     <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_reverse_iterator</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#rbegin"><span class="identifier">rbegin</span></a><span class="special">( </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_reverse_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#rbegin"><span class="identifier">rbegin</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>        <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_reverse_iterator</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#rend"><span class="identifier">rend</span></a><span class="special">( </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>                      <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_reverse_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#rend"><span class="identifier">rend</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>    </span>
    <span class="comment">//<br>    // 随机访问区间的函数<br>    //<br>    <br>    </span><span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;<br>    </span><span class="keyword"></span><span class="keyword">typename </span><span class="identifier">range_difference</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type<br>    </span><a href="#size"><span class="identifier">size</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);</span>
    
    <span class="comment">//<br>    // 特殊的常量区间函数<br>    // <br>    </span>
    <span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;</span>
    <span class="keyword">typename </span><span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type </span>
    <a href="#const_begin"><span class="identifier">const_begin</span></a><span class="special">(</span><span class="keyword"> const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>    </span>
    <span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;</span>
    <span class="keyword">typename </span><span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type </span>
    <a href="#const_end"><span class="identifier">const_end</span></a><span class="special">(</span><span class="keyword"> const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>    </span>
    <span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;</span>
    <span class="keyword">typename </span><span class="identifier">range_reverse_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type </span>
    <a href="#const_rbegin"><span class="identifier">const_rbegin</span></a><span class="special">(</span><span class="keyword"> const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);<br>    </span>
    <span class="keyword">template</span><span class="special">&lt; </span><span class="keyword">class </span><span class="identifier">T </span><span class="special">&gt;</span>
    <span class="keyword">typename </span><span class="identifier">range_reverse_iterator</span><span class="special">&lt;</span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type </span>
    <a href="#const_rend"><span class="identifier">const_rend</span></a><span class="special">( </span><span class="keyword">const </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">r </span><span class="special">);</span>

    <span class="comment">//<br>    // 字符串工具<br>    //</span>
    
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="identifier">iterator_range</span><span class="special">&lt;...</span><span class="identifier">see</span> <span class="identifier">below</span><span class="special">...&gt;</span> <br>    <span class="identifier"><a href="#as_literal">as_literal</a></span><span class="special">(</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">r</span> <span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="identifier">iterator_range</span><span class="special">&lt;...</span><span class="identifier">see</span> <span class="identifier">below</span><span class="special">...&gt;</span> <br>    <span class="identifier"><a href="#as_array">as_literal</a></span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">r</span> <span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="identifier">iterator_range</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <br>    <span class="identifier"><a href="#as_array">as_array</a></span><span class="special">(</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">r</span> <span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="identifier">iterator_range</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">range_iterator</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <br>    <span class="identifier"><a href="#as_literal">as_array</a></span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">r</span> <span class="special">);</span>

<span class="special">} </span><span class="comment">// namespace 'boost' <br></span>
</pre>

        
<p></p>

        <a name="Semantics"></a>
        
<h3>语义</h3>

        
<h4>符号</h4>

        
<p>
            
<table border="1" cellpadding="5">

                <tbody>
    <tr>

                    <th>类型</th>
      <th>对象
                            </th>
      <th>说明
                </th>
    </tr>

                <tr>

                    <td><code>X</code>
                    </td>
      <td><code>x</code>
                    </td>
      <td>任意类型</td>

                </tr>
    <tr>

                    <td><code>T</code>
                    </td>

                    <td><code>t</code>
                    </td>
      <td>表示主模板的行为</td>

                </tr>

                <tr>

                    <td><code>P</code>
                    </td>
      <td><code>p</code>
                    </td>
      <td>表示 <code>std::pair&lt;iterator,iterator&gt;</code></td>

                </tr>
    <tr>

                    <td><code>A[sz]</code>
                    </td>
      <td><code>a</code>
                    </td>
      <td>表示一个类型 A 的大小为 sz 的数组<code></code><code></code>
                </td>
    </tr>
    <tr>

                </tr>
    <tr>

                    <td><code>Char*</code>
                    </td>
      <td><code>s</code>
                    </td>
      <td>表示 <code>char*</code> 或 <code>wchar_t*</code><code></code></td>

                </tr>

            
  </tbody>
</table>

        </p>

        
<p>请留意，下表中有些单元格有四行文字，其中第一行代表主模板，第二行代表迭代器对，第三行代表数组，最后一行代表空字符结尾的字符串。
        </p>

        
<h4>元函数</h4>

        
<p>
            <a name="range_iterator"></a>
                    <a name="range_const_iterator"></a>
                    <a name="range_value"></a>
                    <a name="range_reference"></a>
                    <a name="range_pointer"></a>
                    <a name="range_category"></a>
                    <a name="range_difference"></a>
                    <a name="range_reverse_iterator"></a>
                    <a name="range_const_reverse_iterator"></a>
                    
<table border="1" cellpadding="5">

                <tbody>
    <tr>

                    <th>表达式</th>

                    <th>返回类型</th>

                    <th>复杂度</th>

                </tr>

                <tr>

                    <td><code>range_iterator&lt;X&gt;::type</code></td>

                    <td><code>T::iterator</code><br>

                        <code>P::first_type</code><br>

                        <code>A*</code><br>


                    </td>
      <td>编译时间</td>

                </tr>

                <tr>

                    <td><code>range_iterator&lt;const X&gt;::type</code></td>

                    <td><code>T::const_iterator</code><br>

                        <code>P::first_type</code><br>

                        <code>const A*</code><br>


                    </td>
      <td>编译时间</td>

                </tr>

                <tr>

                    <td><code>range_value&lt;X&gt;::type</code></td>

                    <td><code>boost::iterator_value&lt;range_iterator&lt;X&gt;::type&gt;::type</code>
                     </td>
  
                    <td>编译时间</td>

                </tr>

                <tr>

                    <td><code>range_reference&lt;X&gt;::type</code></td>

                    <td><code>boost::iterator_reference&lt;range_iterator&lt;X&gt;::type&gt;::type</code>
                     </td>
  
                    <td>编译时间</td>

                </tr>


                                <tr>

                    <td><code>range_pointer&lt;X&gt;::type</code></td>

                    <td><code>boost::iterator_pointer&lt;range_iterator&lt;X&gt;::type&gt;::type</code>
                     </td>
  
                    <td>编译时间</td>

                </tr>

                
                                <tr>

                    <td><code>range_category&lt;X&gt;::type</code></td>

                    <td><code>boost::iterator_category&lt;range_iterator&lt;X&gt;::type&gt;::type</code>
                     </td>
  
                    <td>编译时间</td>

                </tr>

                <tr>

                    <td><code>range_difference&lt;X&gt;::type</code></td>

                    <td>
                        <code>boost::iterator_difference&lt;range_iterator&lt;X&gt;::type&gt;::type</code></td>

                        
                    <td>编译时间</td>

                </tr>

                

                <tr>

                    <td><code>range_reverse_iterator&lt;X&gt;::type</code></td>

                    <td><code>boost::reverse_iterator&lt;range_iterator&lt;X&gt;::type&gt;</code><br>

                    </td>
      <td>编译时间</td>

                </tr>

                <tr>

                    <td><code>range_reverse_iterator&lt;const X&gt;::type</code></td>

                    <td><code>boost::reverse_iterator&lt;range_iterator&lt;const X&gt;::type&gt;</code>
                        <br>

                    </td>
      <td>编译时间</td>

                </tr>

            
  </tbody>
</table>

        </p>

        
<h4>函数</h4>

        
<p>
            <a name="begin"></a>
                    <a name="end"></a>
                    <a name="empty"></a>
                    <a name="distance"></a>
                    <a name="size"></a>
                    <a name="rbegin"></a>
                    <a name="rend"></a>
                    <a name="const_begin"></a>
                    <a name="const_end"></a>
                    <a name="const_rbegin"></a>
                    <a name="const_rend"></a>
                    <a name="as_literal"></a>
                    <a name="as_array"></a>
                    
<table border="1" cellpadding="5">

                <tbody>
    <tr>

                    <th>
                        表达式</th>

                    <th>返回类型</th>

                    <th>返回</th>

                    <th>复杂度</th>

                </tr>

                <tr>

                    <td><code>begin(x)</code></td>

                    <td><code>range_iterator&lt;X&gt;::type</code></td>

                    <td>
                        <code>p.first</code> 如果 <code>p</code> 为类型 
      <code>std::pair&lt;T&gt;<code><br>
      <code>a</code> 如果 <code>a</code> 
为数组<br>
      <code>s</code> 如果 <code>s</code> 
为字符串字面值<br>
      <code>boost_range_begin(x)</code> 如果该表达式由 ADL 执行函数查找<br>
      <code>否则 
t.begin()</code>&nbsp;&nbsp;</code></code><code><code>
   
                    </code></code></td>
      <td>常量时间</td>

                </tr>

                <tr>

                    <td><code>end(x)</code></td>

                    <td><code>range_iterator&lt;X&gt;::type</code></td>

                    <td>
                        <code>p.second</code> 如果 <code>p</code> 为类型 
      <code>std::pair&lt;T&gt;<code><br>
      <code>a + sz</code> 如果 <code>a</code> 是大小为 sz 
的数组<code></code><br>
      <code>s + std::char_traits&lt;X&gt;::length( s )</code> 如果 
      <code>s</code> 是 <code>Char*</code> <br>
      <code>s + sz - 1</code> 如果 
      <code>s</code> 是大小为 sz 
的字符串字面值<br>
      <code>boost_range_end(x)</code>&nbsp;</code></code><code><code>如果该表达式由 ADL 
执行函数查找</code></code><code><code> <br>
      <code>否则 t.end()</code>&nbsp;&nbsp;</code></code><code><code>
                        
                    </code></code></td>
      <td>常量时间 </td>

                </tr>

                <tr>

                    <td><code>empty(x)</code></td>

                    <td><code>bool</code></td>

                    <td><code>boost::begin(x) == boost::end(x)</code><br>

                    </td>
      <td>常量时间&nbsp;
                    </td>

                </tr>

                <tr>

                    <td><code>distance(x)</code></td>

                    <td><code>range_difference&lt;X&gt;::type</code></td>

                    <td>
                        <code>
                            std::distance(boost::begin(x),boost::end(x))
                        </code>
                         </td>

                    <td>-</td>
     

                </tr>


                <tr>

                    <td><code>size(x)</code></td>

                    <td><code>range_difference&lt;X&gt;::type</code></td>

                    <td><code> boost::end(x) - boost::begin(x)</code>
                        
                    </td>
      <td>常量时间 </td>

                </tr>

                <tr>

                    <td><code>rbegin(x)</code></td>

                    <td><code>range_reverse_iterator&lt;X&gt;::type</code></td>

                    <td><code>range_reverse_iterator&lt;X&gt;::type( boost::end(x) )</code>
                        <br>

                    </td>
      <td>常量时间
                    </td>

                </tr>

                <tr>

                    <td><code>rend(x)</code></td>

                    <td><code>range_reverse_iterator&lt;X&gt;::type</code></td>

                    <td><code>range_reverse_iterator&lt;X&gt;::type( boost::begin(x) )</code>
                    </td>
      <td>常量时间</td>

                </tr>

                <tr>

                    <td><code>const_begin(x)</code></td>

                    <td><code>range_iterator&lt;const X&gt;::type</code></td>

                    <td><code>range_iterator&lt;const X&gt;::type( boost::begin(x) )</code>
                        <br>

                    </td>
      <td>常量时间
                    </td>

                </tr>

                <tr>

                    <td><code>const_end(x)</code></td>

                    <td><code>range_iterator&lt;const X&gt;::type</code></td>

                    <td><code>range_iterator&lt;const X&gt;::type( boost::end(x) )</code>
                    </td>
      <td>常量时间</td>

                </tr>

                <tr>

                    <td><code>const_rbegin(x)</code></td>

                    <td><code>range_reverse_iterator&lt;const X&gt;::type</code></td>

                    <td><code>range_reverse_iterator&lt;const X&gt;::type( boost::rbegin(x) )</code>
                        <br>

                    </td>
      <td>常量时间
                    </td>

                </tr>

                <tr>

                    <td><code>const_rend(x)</code></td>

                    <td><code>range_reverse_iterator&lt;const X&gt;::type</code></td>

                    <td><code>range_reverse_iterator&lt;const X&gt;::type( boost::rend(x) )</code>                    
        
                    </td>
      <td>常量时间</td>

                </tr>

                 <tr>

                    <td><code>as_literal(x)</code></td>

                     <td><code>iterator_range&lt;U&gt;</code> 其中 <code>U</code> 为 
                        <code>Char*</code> 如果 <code>x</code> 是一个字符串指针，否则 <code>U</code> 为
                        <code>range_iterator&lt;X&gt;::type</code>&nbsp;
                        </td>

                     <td>
                         
                        <code>[a,a+sz-1)</code> 如果 <code>a</code> 是一个大小为 <code>sz 的数组</code><br>

                            <code>[s,s + std::char_traits&lt;X&gt;::length(s))</code> 如果 <code>s</code> 为 <code>Char*</code>
                                <br>

                                    <code>否则返回 [boost::begin(x),boost::end(x))</code>


                         
                         </td>
   
                    <td>对于字符串指针为线性时间，否则为常量时间</td>

                </tr>

                 <tr>

                    <td><code>as_array(x)</code></td>

                     <td><code>iterator_range&lt;X&gt;</code>                       </td>

                     <td>
                                  <code>[boost::begin(x),boost::end(x))</code> 
                                    


                         
                         </td>
   
                    <td>否则为常量时间</td>

                </tr>


            
  </tbody>
</table>

        </p>

        
<p>特定的 <code>const_</code> 函数可用于示意你的代码为只读。
        </p>

            
<p>
                <code>as_literal()</code> 可在能够正确处理字符数组的字符串算法库内部使用。
                </p>

            
<p>
                <code>as_array()</code> 可用于字符串算法库，可以清晰表明字符数组的处理类似于数组而非字符串。 
                </p>
    
            
<p>注意以上函数总是要以限定方式(<code>boost::</code>)来调用，以防止<span style="font-style: italic;">无意</span>的ADL。
                </p>

        
<hr>
        <a name="minimal_interface"></a>
        
<h3>扩展本库</h3>

        
<ul>

        <li><a href="#method1">方法 1: 提供成员函数和嵌套类型</a></li>

            
        <li><a href="#method2">方法 2: 提供独立函数和特化的元函数</a></li>

        
</ul>


        <!--<b>Warning:</b><i> If possible, then prefer method 1 if you want to be absolutely sure your code is forward compatible. 
                       </i>-->

        <a name="method1"></a>
        
<h4>方法 1: 提供成员函数和嵌套类型</h4>

        
        
<p>这个方法假定你可以控制要改编以符合区间概念的类型。如果不是这样，请看 <a href="#method2">方法 2</a>。 </p>

<p>本库的主模板的实现是要使得标准容器可以自动工作，也包括 <code>boost::<a href="../../array/index.html">array</a></code>. 
以下给出一个概览，一个类要可以作为区间概念使用，必须指定哪些成员函数和成员类型。<br>
</p>
<p>
            
<table border="1" cellpadding="5">

                <tbody>
    <tr>

                    <th>成员函数</th>

                    <th>相关概念</th>

                </tr>
    <tr>

                    <td><code>begin()</code></td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>

                <tr>

                    <td><code>end()</code>
                    </td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>

            
  </tbody>
</table>

        </p>

        
<p>注意，<code>rbegin()</code> 和 <code>rend()</code> 成员函数不是必须的，即使该容器支持双向迭代。 </p>

<p>要求的成员类型有：<br>
</p>
<p>
            
<table border="1" cellpadding="5">

                <tbody>
    <tr>

                    <th>成员类型</th>

                    <th>相关概念</th>

                </tr>
    <tr>

                </tr>
    <tr>

                    <td><code>iterator</code></td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>

                <tr>

                    <td><code>const_iterator</code></td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>

            
  </tbody>
</table>

        </p>

        
<p>再次提醒，成员类型 <code>reverse_iterator</code> 和 
<code>const_reverse_iterator</code>&nbsp;是不需要的。 </p>
<a name="method2"></a>
<h4>方法 2: 提供独立函数和特化的元函数</h4>

<p>这一方法假定你不能(或不愿)修改要改编以符合区间概念的类型。如果不是这样，请看 <a href="#method1">方法 1</a>。 </p>

<p>本库的主模板实现是要使得特定的函数可以被ADL查找得到。以下给出一个概览，一个类要可以作为区间概念使用，必须指定哪些独立函数。其中 
<code>x</code> 是该类的一个变量(<code>const</code> 或 mutable)。<br>
</p>
<p>
            
<table id="Table1" border="1" cellpadding="5">

                <tbody>
    <tr>

                    <th>
                        函数</th>

                    <th>相关概念</th>

                </tr>
    <tr>

                    <td><code>range_begin(x)</code></td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>

                <tr>

                    <td><code>range_end(x)</code>
                    </td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>


            
  </tbody>
</table>
        
        </p>

        
<p><code>boost_range_begin()</code> 和 <code>boost_range_end()</code> 
必须同时为常量和非常量引用参数进行重载。 </p>

<p>你还必须为你的类型 X 特化2个元函数：<br>
</p>
<p>
            
<table id="Table2" border="1" cellpadding="5">

                <tbody>
    <tr>

                    <th>元函数</th>

                    <th>相关概念</th>

                </tr>
    <tr>

                    <td><code>boost::range_mutable_iterator</code></td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>

                <tr>

                    <td><code>boost::range_const_iterator</code></td>

                    <td><a href="range.html#single_pass_range">单遍区间</a></td>

                </tr>


            
  </tbody>
</table>

        </p>

        
<p>这里给出一个完整的例子：&nbsp;
        </p>

        
<blockquote>
        
  <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">range</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">&gt;</span>         <span class="comment">// for std::iterator_traits, std::distance()</span>

<span class="keyword">namespace</span> <span class="identifier">Foo</span>
<span class="special">{</span>
    <span class="comment">//<br>    // 我们的 UDT 例子。一个 'Pair' 保存了<br>    // 一对迭代器，可用为一个区间来使用。<br>    //</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">Pair</span>
    <span class="special">{</span>
        <span class="identifier">T</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">;</span>  <br>    <span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace 'Foo'</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="comment">//<br>    // 特化元函数。我们必须包含 range.hpp 头文件。<br>    // 我们必须打开 'boost' 名字空间。<br>    //</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">range_mutable_iterator</span><span class="special">&lt;</span> <span class="identifier">Foo</span><span class="special">::</span><span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">range_const_iterator</span><span class="special">&lt;</span> <span class="identifier">Foo</span><span class="special">::</span><span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="comment">//<br>        // 注：这个定义与 'range_mutable_iterator' 相同，因为 'Pair' 类型<br>        //    无法区分 iterator 和 const_iterator.<br>        //</span>
        <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace 'boost'</span>

<span class="keyword">namespace</span> <span class="identifier">Foo</span>
<span class="special">{</span>
    <span class="comment">//<br>    // 要求的函数。应定义于 'Pair' 所在的名字空间，<br>    // 在本例中即名字空间 'Foo'.<br>    //</span>
    
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">inline</span> <span class="identifier">T</span> <span class="identifier">range_begin</span><span class="special">(</span> <span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span> <span class="special">)</span>
    <span class="special">{</span> <br>        <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">first</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">inline</span> <span class="identifier">T</span> <span class="identifier">range_begin</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span> <span class="special">)</span>
    <span class="special">{</span> <br>        <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">first</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">inline</span> <span class="identifier">T</span> <span class="identifier">range_end</span><span class="special">(</span> <span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span> <span class="special">)</span>
    <span class="special">{</span> <br>        <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">last</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">inline</span> <span class="identifier">T</span> <span class="identifier">range_end</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span> <span class="special">)</span>
    <span class="special">{</span> <br>        <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">last</span><span class="special">;</span>
    <span class="special">}</span>

<span class="special">}</span> <span class="comment">// namespace 'Foo'</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">iterator</span>  <span class="identifier">iter</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>                    <span class="identifier">vec</span><span class="special">;</span>
    <span class="identifier">Foo</span><span class="special">::</span><span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">iter</span><span class="special">&gt;</span>                     <span class="identifier">pair</span>  <span class="special">=</span> <span class="special">{</span> <span class="identifier">vec</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">vec</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">};</span>
    <span class="keyword">const</span> <span class="identifier">Foo</span><span class="special">::</span><span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">iter</span><span class="special">&gt;&amp;</span>              <span class="identifier">cpair</span> <span class="special">=</span> <span class="identifier">pair</span><span class="special">;</span> <br>    <span class="comment">//<br>    // 注意，我们以带限定符的方式调用 'begin' 等函数。<br>    //</span>
    <span class="identifier">iter</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span> <span class="identifier">pair</span> <span class="special">);</span>
    <span class="identifier">iter</span> <span class="identifier">e</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span> <span class="identifier">pair</span> <span class="special">);</span>
    <span class="identifier">i</span>      <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span> <span class="identifier">cpair</span> <span class="special">);</span>
    <span class="identifier">e</span>      <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span> <span class="identifier">cpair</span> <span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">range_difference</span><span class="special">&lt;</span> <span class="identifier">Foo</span><span class="special">::</span><span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">iter</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">s</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span><span class="special">(</span> <span class="identifier">pair</span> <span class="special">);</span>
    <span class="identifier">s</span>      <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span><span class="special">(</span> <span class="identifier">cpair</span> <span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">range_reverse_iterator</span><span class="special">&lt;</span> <span class="identifier">const Foo</span><span class="special">::</span><span class="identifier">Pair</span><span class="special">&lt;</span><span class="identifier">iter</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">ri</span>     <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">rbegin</span><span class="special">(</span> <span class="identifier">cpair</span> <span class="special">),</span>
    <span class="identifier">re</span>     <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">rend</span><span class="special">(</span> <span class="identifier">cpair</span> <span class="special">);</span>
<span class="special">}</span>    <br></pre>

</blockquote>

        
        
<hr>
        
<p>
          &copy; <a name="Copyright" id="Copyright">Copyright</a> Thorsten Ottosen 2008.
        </p>

        
        
<p>
          Distributed under the Boost Software License, Version 1.0. (See
          accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a>)
        </p>

        <br>

        <br>

        <br>

        <br>

        <br>

        <br>

        <br>

        <br>

        <br>

        <br>

        <br>

        <br>

    
</body>
</html>

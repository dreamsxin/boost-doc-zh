<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
<!--
  -- Copyright (c) Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  We make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
  <title>Iterator Property Map Adaptor</title>
</head>


<body alink="#ff0000" bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b">
 
<img src="../../boost.png" alt="C++ Boost" height="86" width="277"> 

<br clear="">



<h2><a name="sec:const-associative-property-map"></a>
</h2>

<pre>const_associative_property_map&lt;UniquePairAssociativeContainer&gt;<br></pre>


<p>
该 property map 是一个适配器，将同时符合 <a href="http://www.sgi.com/tech/stl/PairAssociativeContainer.html">Pair 
Associative Container</a> 和 <a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique 
Associative Container</a> 的任意类型，如 <a href="http://www.sgi.com/tech/stl/Map.html"><tt>std::map</tt></a>，转换为常量 <a href="./LvaluePropertyMap.html">左值 Property Map</a>. 
注意，该适配器只保留了对容器的引用，所以容器的生命周期必须长于该适配器。
</p>


<h3>例子</h3>


<a href="./example1.cpp">example1.cpp</a>:
<pre><font color="#008040">#include &lt;iostream&gt;</font>
<font color="#008040">#include &lt;map&gt;</font>
<font color="#008040">#include &lt;string&gt;</font>
<font color="#008040">#include &lt;boost/property_map.hpp&gt;</font>


<b>template</b> &lt;<b>typename</b> ConstAddressMap&gt;<br><b>void</b> display(ConstAddressMap address)<br>{<br>  <b>typedef</b> <b>typename</b> boost::property_traits&lt;ConstAddressMap&gt;::value_type<br>    value_type;<br>  <b>typedef</b> <b>typename</b> boost::property_traits&lt;ConstAddressMap&gt;::key_type key_type;<br><br>  key_type fred = <font color="#0000ff">"Fred"</font>;<br>  key_type joe = <font color="#0000ff">"Joe"</font>;<br><br>  value_type freds_address = get(address, fred);<br>  value_type joes_address = get(address, joe);<br>  <br>  std::cout &lt;&lt; fred &lt;&lt; <font color="#0000ff">": "</font> &lt;&lt; freds_address &lt;&lt; <font color="#0000ff">"\n"</font>
	    &lt;&lt; joe  &lt;&lt; <font color="#0000ff">": "</font> &lt;&lt; joes_address  &lt;&lt; <font color="#0000ff">"\n"</font>;<br>}<br><br><b>int</b>
main()
{
  std::map&lt;std::string, std::string&gt; name2address;
  boost::const_associative_property_map&lt; std::map&lt;std::string, std::string&gt; &gt;
    address_map(name2address);

  name2address.insert(make_pair(std::string(<font color="#0000ff">"Fred"</font>), <br>				std::string(<font color="#0000ff">"710 West 13th Street"</font>)));<br>  name2address.insert(make_pair(std::string(<font color="#0000ff">"Joe"</font>), <br>				std::string(<font color="#0000ff">"710 West 13th Street"</font>)));<br><br>  display(address_map);<br>  <br>  <b>return</b> EXIT_SUCCESS;<br>}<br><br><br></pre>


<h3>定义于</h3>


<p>
<a href="../../boost/property_map.hpp"><tt>boost/property_map.hpp</tt></a>

</p>
<p>
</p>
<h3>Model Of</h3>


<a href="./LvaluePropertyMap.html">左值 Property Map</a>

<p>

</p>
<h3>模板参数</h3>


<p>

<table border="1">

  <tbody>
    <tr>

      <th>参数</th>
      <th>描述</th>
      <th>缺省值</th>

    </tr>



    <tr>

      <td><tt>UniquePairAssociativeContainer</tt></td>
 
      <td>必须同时符合&nbsp;<a href="http://www.sgi.com/tech/stl/PairAssociativeContainer.html">Pair
Associative Container</a> 和 <a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique
Associative Container</a> .</td>

      <td>&nbsp;</td>

    </tr>


  </tbody>
</table>

</p>
<p>

</p>
<h3>成员</h3>


<p>除了 <a href="./LvaluePropertyMap.html">左值 Property Map</a> 中要求的方法和函数以外，该类还有以下成员。

</p>
<hr>

<pre>property_traits&lt;const_associative_property_map&gt;::value_type<br></pre>
与&nbsp;<tt>UniquePairAssociativeContainer::data_type</tt> 相同的类型。

<hr>

<pre>const_associative_property_map()<br></pre>
缺省构造函数。

<pre>const_associative_property_map(const UniquePairAssociativeContainer&amp; c)<br></pre>
构造函数。

<hr>

<pre>const data_type&amp; operator[](const key_type&amp; k) const<br></pre>
[]操作符用于属性访问。<tt>key_type</tt> 和 <tt>data_type</tt> 类型均来自于 
<tt>UniquePairAssociativeContainer</tt> 中的 typedef.&nbsp;

<hr>

<h3>非成员函数</h3>


<hr>

<pre>  template &lt;typename UniquePairAssociativeContainer&gt;<br>  const_associative_property_map&lt;UniquePairAssociativeContainer&gt;<br>  make_assoc_property_map(const UniquePairAssociativeContainer&amp; c);<br></pre>
用于创建一个 associative property map 的工具函数。



<hr>


<br>

<hr>
<table>

  <tbody>
    <tr valign="top">

      <td nowrap="nowrap">Copyright &copy; 2002</td>
      <td>
      <a href="../../people/jeremy_siek.htm">Jeremy Siek</a>,
Indiana University (<a href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)<br>

      <a href="http://www.boost.org/people/liequan_lee.htm">Lie-Quan Lee</a>, Indiana University (<a href="mailto:llee1@osl.iu.edu">llee1@osl.iu.edu</a>)<br>

      <a href="http://www.osl.iu.edu/%7Elums">Andrew Lumsdaine</a>,
Indiana University (<a href="mailto:lums@osl.iu.edu">lums@osl.iu.edu</a>)
      </td>
    </tr>
  </tbody>
</table>


</body>
</html>

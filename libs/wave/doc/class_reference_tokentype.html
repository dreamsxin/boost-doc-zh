<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<title>The Token Type</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="theme/style.css" type="text/css"></head>
<body background="theme/bkd.gif" text="#000000">
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr> 
    <td width="21"> <h1></h1></td>
    <td width="885"> <font face="Verdana, Arial, Helvetica, sans-serif"><b><font size="6">The 
      Token Type 单词类型</font></b></font></td>
    <td width="96"><a href="http://www.boost.org"><img src="theme/wave.gif" align="right" border="0" height="68" width="93"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="class_reference_lexer.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="30"><a href="token_ids.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<blockquote>
  <p><a href="class_reference_tokentype.html#introduction">Introduction 简介</a><br>
    <a href="class_reference_tokentype.html#header_synopsis">Header 'wave/context.hpp' 
    synopsis 头文件概要</a><br>
    <a href="class_reference_tokentype.html#template_parameters">Template parameters 模板参数</a><br>
	<a href="class_reference_tokentype.html#public_typedefs">Public Typedefs &nbsp;公有typedef</a><br>
    <a href="class_reference_tokentype.html#member_functions">Member functions 成员函数</a></p>
</blockquote>
<h2><a name="Introduction"></a>Introduction 简介</h2>
<p>The token type in <tt>Wave</tt> is the main carrier of information. It
is returned by dereferencing the iterators exposed by the lexing
component and the iterator exposed by the preprocessor component. The
tokens are originally generated by the lexer ("An entity that lexically
transforms the subject of parsing to a sequence of objects (called
tokens) more suitable for subsequent parsing."). The Wave library
contains two different, interchangable C++ lexers, which may be used as
a starting point during developing your own application. The lexer
generated tokens are transformed by the preprocessing engine (macro
expansion, include file processing etc.) and after this returned to the
user of the <tt>Wave</tt> 
  library.<br><tt>Wave</tt>
中的 token
类型是信息的主要载体。它通过对由lexing组件暴露的迭代器或由预处理器组件暴露的迭代器进行解引用来返回得到。单词原本是由lexer("一个实
体，将分析对象按词汇转换为某个对象(称为单词)序列以便更适合于进行下一步分析")生成的。Wave 库带有两个不同的、可互换的C++
lexer，可以作为起点来开发你自己的应用程序。lexer生成的单词将被预处理引擎转换(宏展开、头文件处理等等)，然后返回给 <tt>Wave</tt> 库的用户。</p>
<p>You can use arbitrary token types in conjunction with your own lexer as long 
  as these implement some required interface. The required token type interface 
  is described below and is implemented by the <tt>wave::cpplexer::lex_token</tt> 
  template, the required lexer interface is described <a href="class_reference_lexer.html">here</a>.<br>你可以把任意的单词类型用于你自己的lexer，只要它们实现了所要求的接口。要求的单词类型接口在下文描述，并通过 <tt>wave::cpplexer::lex_token</tt> 模板实现，要求的lexer接口则在<a href="class_reference_lexer.html">这里</a>描述。 
</p>
<p>In the following is described the token type predefined inside the <tt>Wave</tt> 
  library, which is used in conjunction with the two predefined C++ lexers contained 
  in the <tt>Wave</tt> library too. If you need to use your own token type, it 
  is required to implement the interafce described below.<br>以下将描述在 <tt>Wave</tt> 
  库中预定义的单词类型，它可以与两个也是在 <tt>Wave</tt> 库中预定义的C++ lexer共用。如果你需要使用自己的单词类型，则必须实现下述接口。</p>
<h2><b><a name="header_synopsis"></a>Header <a href="svn.boost.org/trac/boost/browser/trunk/boost/wave/cpplexer/cpp_lex_token.hpp">wave/cpplexer/cpp_lex_token.hpp</a> 
  synopsis 头文件概要</b></h2>
<pre><span class="keyword">namespace</span> boost {<br><span class="keyword">namespace</span> wave {<br><span class="keyword">namespace</span> cpplexer {<br><br>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Position&gt;<br>    <span class="keyword">class</span> lex_token <br>    {<br>    <span class="keyword">public</span>:<br>        <span class="keyword">typedef</span> <span class="keyword">std::basic_string</span><char>&lt;char&gt; string_type;<br>        <span class="keyword">typedef</span> Position                position_type;<br>    <br>        <a href="class_reference_tokentype.html#constructor">lex_token</a>();<br>        <a href="class_reference_tokentype.html#constructor">lex_token</a>(token_id id, string_type <span class="keyword">const</span> &amp;value, <br>            PositionT <span class="keyword">const</span> &amp;pos);<br><br>    // accessors<br>        <a href="class_reference_tokentype.html#operator_tokenid">operator token_id</a>() <span class="keyword">const</span>;<br>        string_type const &amp;<a href="class_reference_tokentype.html#get_value">get_value</a>() <span class="keyword">const</span>;<br>        position_type const &amp;<a href="class_reference_tokentype.html#get_position">get_position</a>() <span class="keyword">const</span>;<br>        void <a href="class_reference_tokentype.html#set_token_id">set_token_id</a> (token_id id);<br>        void <a href="class_reference_tokentype.html#set_value">set_value</a> (string_type <span class="keyword">const</span> &amp;newval);<br>        void <a href="class_reference_tokentype.html#set_position">set_position</a> (position_type <span class="keyword">const</span> &amp;pos);<br>    };<br><br>}   <span class="comment">// namespace cpplexer</span>
}   <span class="comment">// namespace wave</span>
}   <span class="comment">// namespace boost</span>
</char></pre>
<h2><b><a name="template_parameters" id="template_parameters"></a>Template parameters 模板参数</b></h2>
<p>The  predefined token type uses a template parameter <tt>Position</tt>, which 
  allows to specify the type to be used to carry the file position information 
  contained inside the generated tokens. Your own token type do not need to take this <tt>Position</tt> template parameter, but please note, that the token type in any case needs to have an embedded type definition <tt>position_type</tt> (see below) .<br>预定义的单词类型使用一个模板参数 <tt>Position</tt>，它可以指定一个类型，用于保存包含在生成的单词中的文件位置信息。你自己的单词类型不一定要带有这个 <tt>Position</tt> 模板参数，不过请注意，任何情况下，单词类型都需要具有内嵌的类型定义 <tt>position_type</tt> (见后)。 </p>
<h2><a name="public_typedefs" id="public_typedefs"></a>Public Typedefs 公有的typedef</h2>
<p>The token type needs to define two embedded types: <tt>string_type</tt> and <tt>position_type</tt>. The <tt>string_type</tt> needs to be a type compatible to the <tt>std::basic_string&lt;&gt;</tt> class.<br>单词类型需要定义两个类型：<tt>string_type</tt> 和 <tt>position_type</tt>。<tt>string_type</tt> 必须是一个兼容于 <tt>std::basic_string&lt;&gt;</tt> 类的类型。 </p>
<p>This type should contain at least the filename, the line number and
the column number of the position, where the token was recognized. For
the predefined token type it defaults to a simple file_position
template class described <a href="class_reference_filepos.html">here</a>. Note, that your own <tt>position_type</tt> should follow the interface described for the file_position template as well.<br>这个类型应至少含有文件名、识别出单词的位置的行号和列号。对于预定义的单词类型，缺省为一个简单的 file_position
模板类，相关说明<a href="class_reference_filepos.html">在此</a>。注意，你自己的 <tt>position_type</tt> 也应遵循和 file_position 模板一样的接口。 </p>
<h2><b><a name="member_functions"></a>Member functions 成员函数</b></h2>
<p><b><a name="constructor" id="constructor"></a>Constructors 构造函数</b></p>
<pre>    lex_token();<br><br>    lex_token(token_id id, <br>        string_t <span class="keyword">const</span> &amp;value, <br>        PositionT <span class="keyword">const</span> &amp;pos);</pre>
<blockquote> 
  <p>The first (default) constructor is for generating an end of stream token, 
    which is used for indicating the end of the underlying input stream.<br>第一个(缺省)构造函数生成一个流结束单词，用于表示底层输入流的结束。</p>
  <p>The second constructor initializes the newly created token object with its 
    token id (for a list of valid token id's please look <a href="token_ids.html">here</a>), 
    the string representation of its value and the file position, describing the 
    position inside the input stream , where this token was recognized.<br>第二个构造函数对新创建的单词对象以token id(有效的token id列表请见<a href="token_ids.html">此处</a>)、该值的字符串表示法和在输入流中识别出该单词的文件位置进行初始化。</p>
</blockquote>
<h2>Accessor functions 访问器函数</h2>
<p><a name="operator_tokenid"></a><b>operator token_id</b></p>
<pre>    <span class="keyword">operator</span> token_id() <span class="keyword">const</span>;</pre>
<blockquote> 
  <p>Allows the access to the token id of the token. This accessor allows the usage of <tt>Spirit</tt> 
    parsers directly on top 


 top of a token stream generated by Wave. The possible token id's are described

  <a href="token_ids.html">here</a>.<br>允许访问该单词的 id。这个访问器允许你在 Wave 生成的单词流之上直接使用 <tt>Spirit</tt> 
    分析器。可用的单词 id 在<a href="token_ids.html">此处</a>描述。 </p>
  <p>This function does not throw in any case.<br>该函数在任何情况下都不会抛出。</p>
</blockquote>
<p><a name="get_value"></a><b>get_value</b></p>
<pre>    string_type <span class="keyword">const</span> &amp;get_value() <span class="keyword">const</span>;</pre>
<blockquote> 
  <p>Returns the value of the token, as it was recognized in the input stream. 
    Even for constant tokens (as keywords or operators etc.) the returned value 
    reflects the character sequence as found in the input stream.<br>返回该单词的值，即在输入流中识别到的值。即使对于常量单词(如关键字或操作符等)，返回值反映了在输入流中查找到的字符序列。 </p>
  <p>This function does not throw in any case.<br>该函数在任何情况下都不会抛出。</p>
</blockquote>
<p><b><a name="get_position"></a>get_position</b></p>
<pre>    Position <span class="keyword">const</span> &amp;get_position() <span class="keyword">const</span>;</pre>
<blockquote> 
  <p>Returns the position of the token in the input stream, where it was recognized. 
    The position contains information about the filename, the line number and 
    the column number of the token. By default the <tt>Wave</tt> library uses 
    a file_position template for this purpose, which is described in more detail 
    <a href="class_reference_filepos.html">here</a>.<br>返回该单词在输入流中被识别出来的位置。该位置含有关于文件名、单词所在的行号及列号的信息。缺省情况下，<tt>Wave</tt> 库使用一个 file_position 模板来表示，详细说明请见<a href="class_reference_filepos.html">这里</a>。</p>
  <p>This function does not throw in any case.<br>该函数在任何情况下都不会抛出。</p>
</blockquote>
<p><a name="set_token_id"></a><b>set_token_id</b></p>
<pre>    void set_token_id(token_id id);</pre>
<blockquote> 
  <p>Changes the token id of the token to the new value. The possible token id's 
    are described <a href="token_ids.html">here</a>. Probably this function is 
    of little value for the library user, but it is required under certain circumstances 
    for correct operation of the preprocessing engine.<br>将该单词的 id 改为新的值。可用的单词 id 
    在<a href="token_ids.html">此处</a>描述。也许这个函数对于库用户来说用处不大，不过它对于在某些情况下预处理引擎的正常运行是必须的。</p>
  <p>This function does not throw in any case.<br>该函数在任何情况下都不会抛出。</p>
</blockquote>
<p><a name="set_value"></a><b>set_value</b></p>
<pre>    void set_value(string_type <span class="keyword">const</span> &amp;newval);</pre>
<blockquote> 
  <p>Changes the value stored inside the token to the new value. Propably this 
    function is of little value for the library user, but it is required under 
    certain circumstances for correct operation of the preprocessing engine.<br>将保存在该单词内的值改为新的值。也许这个函数对于库用户来说用处不大，不过它对于在某些情况下预处理引擎的正常运行是必须的。</p>
</blockquote>
<p><a name="set_position"></a><b>set_position</b></p>
<pre>    void set_position(Position <span class="keyword">const</span> &amp;newpos);</pre>
<blockquote>
  <p>Changes the position stored inside the token to the new value. This is used 
    for instance for implementing the functionality required for to implement 
    the <tt>#line</tt> directive.<br>将保存在该单词内的位置改为新的值。用于实现象 <tt>#line</tt> 指令所需的功能。</p>
</blockquote>
<table border="0">
  <tbody><tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="class_reference_lexer.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="30"><a href="token_ids.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<hr size="1">
<p class="copyright">Copyright © 2003-2008 Hartmut Kaiser<br>
  <br>
  <font size="2">Distributed
under the Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) </font> </p>
<span class="updated"></span>
<p class="copyright"><span class="updated">Last updated: 
  <!-- #BeginDate format:fcAm1m -->Sunday, October 12, 2008  20:15<!-- #EndDate -->
  </span></p>
</body></html>
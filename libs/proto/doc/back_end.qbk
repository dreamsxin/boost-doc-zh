[/
 / Copyright (c) 2007 Eric Niebler
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[/================================================================================]
[section:back_end Back Ends:
    Making Expression Templates Do Useful Work 后端：让表达式模板做有用的事情]
[/================================================================================]

Now that you've written the front end for your DSEL compiler, and you've learned a bit about the intermediate form it produces, it's time to think about what to /do/ with the intermediate form. This is where you put your domain-specific algorithms and optimizations. Proto gives you two ways to evaluate and manipulate expression templates: contexts and transforms.\n
现在你已经为你的DSEL编写了前端，也已经学习了一些关于它所生成的中间格式的知识，是时候考虑要对这个中间格式/做些/什么了。
这就是你置入你的领域专用算法和优化的地方。Proto 为你提供了两种方法来对表达式模板进行求值和处理：上下文和变换。

* A /context/ is like a function object that you pass along with an expression to 
  the _eval_ function. It associates behaviors with node types. _eval_ walks the 
  expression and invokes your context at each node.\n
  /上下文/ 类似于一个函数对象，你可以把它与某个表达式一起传递给 _eval_ 函数。
  它将某些行为与节点类型关联起来。_eval_ 对表达式进行遍历并在每个节点处调用你的上下文。
* A /transform/ is a way to associate behaviors, not with node types in an 
  expression, but with rules in a Proto grammar. In this way, they are like 
  semantic actions in other compiler-construction toolkits.\n
  /变换/ 是将某些行为与 Proto 语法中的规则而不是与表达式的节点类型相关联的方法。
  使用这种方法，类似于其它编译器构造工具中的语义动作。

Two ways to evaluate expressions! How to choose? Since contexts are largely procedural, they are a bit simpler to understand and debug so they are a good place to start. But although transforms are more advanced, they are also more powerful; since they are associated with rules in your grammar, you can select the proper transform based on the entire /structure/ of a sub-expression rather than simply on the type of its top-most node.\n
有两种方法对表达式进行求值！如何选择？因为上下文基本上是过程性的，它们对于理解和调试来说更简单些，所以上下文是一个良好的开端。
但是，变换更为高级，也更强大；因为它是与你的语法中的规则相关联的，
你可以基于某个子表达式的整个/结构/而不仅仅是顶层节点的类型来选择正确的变换。

Also, transforms have a concise and declarative syntax that can be confusing at first, but highly expressive and fungible once you become accustomed to it. And -- this is admittedly very subjective -- the author finds programming with Proto transforms to be an inordinate amount of /fun!/ Your mileage may vary.\n
另外，变换具有简明和声明性的语法，刚开始可能会有些混乱，但一旦你熟悉了它，就会发现它具有高度的表达力和可替代性。
而且 -- 这一点公认是非常主观的 -- 作者发现，用 Proto 变换来编程具有更多的/乐趣/！你的感觉可能会有所不同。

[/================================================================================]
[section:expression_evaluation Expression Evaluation:
    Imparting Behaviors with a Context 表达式求值：用上下文指定行为]
[/================================================================================]

Once you have constructed a Proto expression tree, either by using Proto's
operator overloads or with _make_expr_ and friends, you probably want to
actually /do/ something with it. The simplest option is to use `proto::eval()`,
a generic expression evaluator. To use _eval_, you'll need to define a
/context/ that tells _eval_ how each node should be evaluated. This section
goes through the nuts and bolts of using _eval_, defining evaluation contexts,
and using the contexts that Proto provides.\n
一旦你用 Proto 的操作符重载或是用 _make_expr_ 及其辅助物构造了一个 Proto 表达式树，你可能想要实实在在地用它来/做些/什么。
最简单的方式是使用 `proto::eval()`，它是一个泛型的表达式求值器。要使用 _eval_，你需要定义一个/上下文/，
告知 _eval_ 如何对每个节点进行求值。本节将介绍使用 _eval_，定义求值上下文，以及使用 Proto 所提供的上下文等细节。

[note `proto::eval()` is a less powerful but easier-to-use evaluation technique
than Proto transforms, which are covered later. Although very powerful,
transforms have a steep learning curve and can be more difficult to debug.
`proto::eval()` is a rather weak tree traversal algorithm. Dan Marsden has
been working on a more general and powerful tree traversal library. When it is
ready, I anticipate that it will eliminate the need for `proto::eval()`.\n
`proto::eval()` 是比 Proto 变换稍弱但更易于使用的一种求值技术，稍后我们将会讨论到 Proto 变换。变换虽然很强大，
但是却具有陡峭的学习曲线，而且很难调试。`proto::eval()` 则是一种相对较弱的树遍历算法。
Dan Marsden 已经在开发一个更为通用和强大的树遍历程序库。当他完成时，我期望它可以完全替代 `proto::eval()`。]

[/================================================================]
[section:proto_eval Evaluating an Expression with [^proto::eval()] 用[^proto::eval()]求值一个表达式]
[/================================================================]

[:[*Synopsis 摘要:]]

    namespace proto
    {
        namespace result_of
        {
            // A metafunction for calculating the return
            // type of proto::eval() given certain Expr
            // and Context types.
            // 用于计算给定了Expr和Context类型的proto::eval()的返回类型的元函数
            template<typename Expr, typename Context>
            struct eval
            {
                typedef
                    typename Context::template eval<Expr>::result_type
                type;
            };
        }

        namespace functional
        {
            // A callable function object type for evaluating
            // a Proto expression with a certain context.
            // 用于以特定上下文对一个Proto表达式进行求值的可调用函数对象
            struct eval : callable
            {
                template<typename Sig>
                struct result;

                template<typename Expr, typename Context>
                typename proto::result_of::eval<Expr, Context>::type
                operator ()(Expr &expr, Context &context) const;

                template<typename Expr, typename Context>
                typename proto::result_of::eval<Expr, Context>::type
                operator ()(Expr &expr, Context const &context) const;
            };
        }

        template<typename Expr, typename Context>
        typename proto::result_of::eval<Expr, Context>::type
        eval(Expr &expr, Context &context);

        template<typename Expr, typename Context>
        typename proto::result_of::eval<Expr, Context>::type
        eval(Expr &expr, Context const &context);
    }

Given an expression and an evaluation context, using _eval_ is quite simple.
Simply pass the expression and the context to _eval_ and it does the rest and
returns the result. You can use the `eval<>` metafunction in the
`proto::result_of` namespace to compute the return type of _eval_. The
following demonstrates a use of _eval_:\n
给定一个表达式和一个求值上下文，使用 _eval_ 是很简单的。只要将表达式和上下文传递给 _eval_ 就可以了，
它会完成剩余的任务并返回结果。你可以用 `proto::result_of` 名字空间中的 `eval<>` 元函数来计算 _eval_ 的返回类型。
以下示范了 _eval_ 的使用：

    template<typename Expr>
    typename proto::result_of::eval<Expr const, MyContext>::type
    MyEvaluate(Expr const &expr)
    {
        // Some user-defined context type 用户定义的上下文类型
        MyContext ctx;

        // Evaluate an expression with the context 以该上下文对一个表达式求值
        return proto::eval(expr, ctx);
    }

What _eval_ does is also very simple. It defers most of the work to the
context itself. Here essentially is the implementation of _eval_:\n
_eval_ 所做的也很简单。它将多数工作推给上下文本身。以下是 _eval_ 的实现：

    // eval() dispatches to a nested "eval<>" function
    // object within the Context:
    // eval()分派至Context内嵌的一个"eval<>"函数对象：
    template<typename Expr, typename Context>
    typename Context::template eval<Expr>::result_type
    eval(Expr &expr, Context &ctx)
    {
        typename Context::template eval<Expr> eval_fun;
        return eval_fun(expr, ctx);
    }

Really, _eval_ is nothing more than a thin wrapper that dispatches to the
appropriate handler within the context class. In the next section, we'll see
how to implement a context class from scratch.\n
其实，_eval_ 只是一个很薄的包装器，将任务分派至上下文类中适当的处理者。
在下一节中，我们将看到如何从零开始实现一个上下文类。

[endsect]

[/==============================================]
[section:contexts Defining an Evaluation Context 定义一个求值上下文]
[/==============================================]

As we saw in the previous section, there is really not much to the _eval_
function. Rather, all the interesting expression evaluation goes on within
a context class. This section shows how to implement one from scratch.\n
正如我们在上一节中所看到的，对于 _eval_ 函数确实没有更多东西了。相反，
表达式求值的所有有趣动作都是在上下文类的内部。本节将展示如何如何从零开始实现一个上下文。

All context classes have roughly the following form:\n
所有的上下文类都大概是以下形式：

    // A prototypical user-defined context. 一个proto型的用户自定义上下文。
    struct MyContext
    {
        // A nested eval<> class template 嵌套的eval<>类模板
        template<
            typename Expr
          , typename Tag = typename proto::tag_of<Expr>::type
        >
        struct eval;

        // Handle terminal nodes here... 在此处理终结符节点...
        template<typename Expr>
        struct eval<Expr, proto::tag::terminal>
        {
            // Must have a nested result_type typedef. 必须有一个嵌套的result_type typedef.
            typedef ... result_type;

            // Must have a function call operator that takes
            // an expression and the context.
            // 必须有一个函数调用操作符，接受一个表达式及本上下文。
            result_type operator()(Expr &expr, MyContext &ctx) const
            {
                return ...;
            }
        };

        // ... other specializations of struct eval<> 其它的struct eval<>特化 ...
    };

Context classes are nothing more than a collection of specializations of a
nested `eval<>` class template. Each specialization handles a different
expression type.\n
上下文类其实就是一组嵌套的 `eval<>` 类型模板的特化。每一个特化处理一种不同的表达式类型。

In the [link boost_proto.users_guide.getting_started.hello_calculator Hello Calculator]
section, we saw an example of a user-defined context class for evaluating
calculator expressions. That context class was implemented with the help
of Proto's _callable_context_. If we were to implement it from scratch, it
would look something like this:\n
在 [link boost_proto.users_guide.getting_started.hello_calculator Hello Calculator] 一节中，
我们看过一个用户自定义上下文的例子，用于对计算器表达式进行求值。那个上下文类是在 Proto 的 
_callable_context_ 的帮助下实现的。如果我们要从零开始实现它，它看起来会是象这样：

    // The calculator_context from the "Hello Calculator" section,
    // implemented from scratch.
    // 从零开始实现"Hello Calculator"一节中的calculator_context。
    struct calculator_context
    {
        // The values with which we'll replace the placeholders
        // 我们准备用于替换占位符的值。
        std::vector<double> args;

        template<
            typename Expr
            // defaulted template parameters, so we can
            // specialize on the expressions that need
            // special handling.
            // 缺省的模板参数，这样我们就可以对需要特殊处理的表达式进行特化。
          , typename Tag = typename proto::tag_of<Expr>::type
          , typename Arg0 = typename proto::child_c<Expr, 0>::type
        >
        struct eval;

        // Handle placeholder terminals here... 在此处理占位符终结符...
        template<typename Expr, int I>
        struct eval<Expr, proto::tag::terminal, placeholder<I> >
        {
            typedef double result_type;

            result_type operator()(Expr &, MyContext &ctx) const
            {
                return ctx.args[I];
            }
        };

        // Handle other terminals here... 在此处理其它终结符...
        template<typename Expr, typename Arg0>
        struct eval<Expr, proto::tag::terminal, Arg0>
        {
            typedef double result_type;

            result_type operator()(Expr &expr, MyContext &) const
            {
                return proto::child(expr);
            }
        };

        // Handle addition here... 在此处理加法...
        template<typename Expr, typename Arg0>
        struct eval<Expr, proto::tag::plus, Arg0>
        {
            typedef double result_type;

            result_type operator()(Expr &expr, MyContext &ctx) const
            {
                return proto::eval(proto::left(expr), ctx)
                     + proto::eval(proto::right(expr), ctx);
            }
        };

        // ... other eval<> specializations for other node types ...
        // ...对于其它节点类型的eval<>特化...
    };

Now we can use _eval_ with the context class above to evaluate calculator
expressions as follows:\n
现在我们可以以这个上下文类来用 proto::eval() 对计算器表达式进行求值，如下：

    // Evaluate an expression with a calculator_context
    // 用一个calculator_context对一个表达式进行求值
    calculator_context ctx;
    ctx.args.push_back(5);
    ctx.args.push_back(6);
    double d = proto::eval(_1 + _2, ctx);
    assert(11 == d);

Defining a context from scratch this way is tedious and verbose, but it gives
you complete control over how the expression is evaluated. The context class in
the [link boost_proto.users_guide.getting_started.hello_calculator Hello Calculator] example
was much simpler. In the next section we'll see the helper class Proto provides
to ease the job of implementing context classes.\n
这种从零开始定义一个上下文的方法是沉闷而冗长的，但是它可以让你完成控制如何对表达式进行求值。
在 [link boost_proto.users_guide.getting_started.hello_calculator Hello Calculator] 
的例子中的上下文类更为简单。在下一节，我们将看到 Proto 所提供的辅助类，它们可以让实现上下文类的工作变得更为容易。

[endsect]

[/================================================]
[section:canned_contexts Proto's Built-In Contexts Proto的内建上下文]
[/================================================]

Proto provides some ready-made context classes that you can use as-is, or that
you can use to help while implementing your own contexts. They are:\n
Proto 提供了一些可用的上下文类，你可以原样照用，或者用它们来帮助你实现自己的上下文。它们包括：

[variablelist
  [ [[link boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.default_context [^default_context]]]
    [An evaluation context that assigns the usual C++ meanings to all the
     operators. For example, addition nodes are handled by evaluating the
     left and right children and then adding the results. The _default_context_
     uses Boost.Typeof to deduce the types of the expressions it evaluates.\n
     为所有操作符赋予通常的C++意义的求值上下文。例如，加法节点的处理方法是，
     对左、右子节点求值，然后将结果相加。_default_context_ 使用了 Boost.Typeof 
     来推断所求值的表达式的类型。] ]
  [ [[link boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.null_context [^null_context]]]
    [A simple context that recursively evaluates children but does not combine
     the results in any way and returns void.\n
     一个简单的上下文，递归地对子节点进行求值，但不以任何方式对结果进行组合，返回 void。] ]
  [ [[link boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.callable_context [^callable_context<>]]]
    [A helper that simplifies the job of writing context classes. Rather than
     writing template specializations, with _callable_context_ you write a
     function object with an overloaded function call operator. Any expressions
     not handled by an overload are automatically dispatched to a default
     evaluation context that you can specify.\n
     帮助简化编写上下文类的工作的助手。使用 _callable_context_，不再需要编写模板特化，
     而是以重载的函数调用操作符编写一个函数对象。任何没有被重载进行处理的表达式将自动分派至你指定的某个缺省求值上下文。] ]
]

[/=========================================]
[section:default_context [^default_context]]
[/=========================================]

The _default_context_ is an evaluation context that assigns the usual C++
meanings to all the operators. For example, addition nodes are handled by
evaluating the left and right children and then adding the results. The
_default_context_ uses Boost.Typeof to deduce the types of the expressions it
evaluates.\n
_default_context_ 是一个为所有操作符赋予普通的C++意义的求值上下文。例如，
加法节点的处理方法是，对左、右子节点求值，然后将结果相加。_default_context_ 
使用了 Boost.Typeof 来推断所求值的表达式的类型。

For example, consider the following "Hello World" example:\n
例如，考虑以下 "Hello World" 示例：

    #include <iostream>
    #include <boost/proto/proto.hpp>
    #include <boost/proto/context.hpp>
    #include <boost/typeof/std/ostream.hpp>
    using namespace boost;

    proto::terminal< std::ostream & >::type cout_ = { std::cout };

    template< typename Expr >
    void evaluate( Expr const & expr )
    {
        // Evaluate the expression with default_context,
        // to give the operators their C++ meanings:
        // 以default_context对表达式求值，给予操作符本身的C++意义：
        proto::default_context ctx;
        proto::eval(expr, ctx);
    }

    int main()
    {
        evaluate( cout_ << "hello" << ',' << " world" );
        return 0;
    }

This program outputs the following:\n
该程序的输出如下：

[pre
hello, world
]

_default_context_ is trivially defined in terms of a `default_eval<>`
template, as follows:\n
_default_context_ 是很简单地根据一个 `default_eval<>` 模板来定义的，如下：

    // Definition of default_context  default_context的定义
    struct default_context
    {
        template<typename Expr>
        struct eval
          : default_eval<
                Expr
              , default_context const
              , typename tag_of<Expr>::type
            >
        {};
    };

There are a bunch of `default_eval<>` specializations, each of which handles
a different C++ operator. Here, for instance, is the specialization for binary
addition:\n
有一组 `default_eval<>` 特化，每一个特化处理一个C++操作符。例如，以下是对二元加法的特化：

    // A default expression evaluator for binary addition 对二元加法的缺省表达式求值器
    template<typename Expr, typename Context>
    struct default_eval<Expr, Context, proto::tag::plus>
    {
    private:
        static Expr    & s_expr;
        static Context & s_ctx;

    public:
        typedef
            decltype(
                proto::eval(proto::child_c<0>(s_expr), s_ctx)
              + proto::eval(proto::child_c<1>(s_expr), s_ctx)
            )
        result_type;

        result_type operator ()(Expr &expr, Context &ctx) const
        {
            return proto::eval(proto::child_c<0>(expr), ctx)
                 + proto::eval(proto::child_c<1>(expr), ctx);
        }
    };

The above code uses `decltype` to calculate the return type of the function
call operator. `decltype` is a new keyword in the next version of C++ that gets
the type of any expression. Most compilers do not yet support `decltype`
directly, so `default_eval<>` uses the Boost.Typeof library to emulate it. On
some compilers, that may mean that `default_context` either doesn't work or
that it requires you to register your types with the Boost.Typeof library.
Check the documentation for Boost.Typeof to see.\n
以上代码使用了 `decltype` 来计算函数调用操作符的返回类型。`decltype` 是下一个C++版本中的新关键字，
取出任一表达式的类型。多数编译器尚未直接支持 `decltype`，所以 `default_eval<>` 使用 Boost.Typeof 库来模拟它。
在某些编译器上，这可能意味着 `default_context` 不能工作，或是要求你要将你的类型注册到 Boost.Typeof 库。
请查阅 Boost.Typeof 相关文档。

[endsect]

[/===================================]
[section:null_context [^null_context]]
[/===================================]

The _null_context_ is a simple context that recursively evaluates children
but does not combine the results in any way and returns void. It is useful
in conjunction with `callable_context<>`, or when defining your own contexts
which mutate an expression tree in-place rather than accumulate a result, as
we'll see below.\n
_null_context_ 是一个简单的上下文，递归地对子节点进行求值，但不以任何方式对结果进行组合，返回 void。
它可以与 `callable_context<>` 一起使用，或是在定义那些要就地修改表达式树而不是要计算结果的上下文时使用，
稍后我们将看到相关示例。

_null_context_ is trivially implemented in terms of `null_eval<>` as follows:\n
_null_context_ 是很简单地根据 `null_eval<>` 来实现的，如下：

    // Definition of null_context  null_context的定义
    struct null_context
    {
        template<typename Expr>
        struct eval
          : null_eval<Expr, null_context const, Expr::proto_arity::value>
        {};
    };

And `null_eval<>` is also trivially implemented. Here, for instance is
a binary `null_eval<>`:\n
`null_eval<>` 的实现也很简单。例如，以上是一个二元的 `null_eval<>`： 

    // Binary null_eval<>  二元null_eval<>
    template<typename Expr, typename Context>
    struct null_eval<Expr, Context, 2>
    {
        typedef void result_type;

        void operator()(Expr &expr, Context &ctx) const
        {
            proto::eval(proto::child_c<0>(expr), ctx);
            proto::eval(proto::child_c<1>(expr), ctx);
        }
    };

When would such classes be useful? Imagine you have an expression tree with
integer terminals, and you would like to increment each integer in-place. You
might define an evaluation context as follows:\n
这样的类在什么时候有用呢？想象一下，你有一个带整数终结符的表达式树，你想就地将每个整数加一。
你可以如下定义一个求值上下文：

    struct increment_ints
    {
        // By default, just evaluate all children by delegating
        // to the null_eval<>
        // 缺省时，委派至null_eval<>时只对子节点求值
        template<typename Expr, typename Arg = proto::result_of::child<Expr>::type>
        struct eval
          : null_eval<Expr, increment_ints const>
        {};

        // Increment integer terminals 将整数终结符加一
        template<typename Expr>
        struct eval<Expr, int>
        {
            typedef void result_type;

            void operator()(Expr &expr, increment_ints const &) const
            {
                ++proto::child(expr);
            }
        };
    };

In the next section on _callable_context_, we'll see an even simpler way to
achieve the same thing.\n
在下一节的 _callable_context_ 中，我们将看到一个完成相同任务的更为简单的方法。

[endsect]

[/=============================================]
[section:callable_context [^callable_context<>]]
[/=============================================]

The _callable_context_ is a helper that simplifies the job of writing context
classes. Rather than writing template specializations, with _callable_context_
you write a function object with an overloaded function call operator. Any
expressions not handled by an overload are automatically dispatched to a
default evaluation context that you can specify.\n
_callable_context_ 是一个帮助简化编写上下文类的工作的助手。使用 _callable_context_，不再需要编写模板特化，
而是以重载的函数调用操作符编写一个函数对象。任何没有被重载进行处理的表达式将自动分派至你指定的某个缺省求值上下文。

Rather than an evaluation context in its own right, _callable_context_ is more
properly thought of as a context adaptor. To use it, you must define your own
context that inherits from _callable_context_.\n
与其说它是一个求值上下文，不如说 _callable_context_ 是一个上下文适配器更为恰当。
要使用它，你必须从 _callable_context_ 派生你自己的上下文。

In the [link boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.null_context [^null_context]]
section, we saw how to implement an evaluation context that increments all the
integers within an expression tree. Here is how to do the same thing with the
_callable_context_:\n
在 [link boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.null_context [^null_context]] 一节中，
我们看到了如何实现一个对表达式树中所有整数进行加一运算的求值上下文。以下是如何用 _callable_context_ 完成相同任务的方法： 

    // An evaluation context that increments all
    // integer terminals in-place.\n
    // 将所有整数终结符就地加一的求值上下文
    struct increment_ints
      : callable_context<
            increment_ints const // derived context 派生的上下文
          , null_context const  // fall-back context 后传的上下文
        >
    {
        typedef void result_type;

        // Handle int terminals here: 在此处理终结符：
        void operator()(proto::tag::terminal, int &i) const
        {
            ++i;
        }
    };

With such a context, we can do the following:\n
用这个上下文，我们可以做： 

    literal<int> i = 0, j = 10;
    proto::eval( i - j * 3.14, increment_ints() );

    std::cout << "i = " << i.get() << std::endl;
    std::cout << "j = " << j.get() << std::endl;

This program outputs the following, which shows that the integers `i` and `j`
have been incremented by `1`:\n
该程序输出如下，其中显示整数 `i` 和 `j` 都加了 `1`: 

[pre
i = 1
j = 11
]

In the `increment_ints` context, we didn't have to define any nested `eval<>`
templates. That's because _callable_context_ implements them for us.
_callable_context_ takes two template parameters: the derived context and a
fall-back context. For each node in the expression tree being evaluated,
_callable_context_ checks to see if there is an overloaded `operator()` in the
derived context that accepts it. Given some expression `expr` of type `Expr`,
and a context `ctx`, it attempts to call:\n
在 `increment_ints` 上下文中，我们不需要定义嵌套的 `eval<>` 模板。这是因为 _callable_context_ 已经为我们实现了它们。
_callable_context_ 带有两个模板参数：派生的上下文和后传的上下文。对于被求值表达式树中的每个节点，_callable_context_ 
检查在派生上下文中是否有一个重载的 `operator()` 接受它。给定类型为 `Expr` 的表达式 `expr`，以及一个上下文 `ctx`，它尝试调用：

    ctx(
        typename Expr::proto_tag()
      , proto::child_c<0>(expr)
      , proto::child_c<1>(expr)
        ...
    );

Using function overloading and metaprogramming tricks, _callable_context_ can
detect at compile-time whether such a function exists or not. If so, that
function is called. If not, the current expression is passed to the fall-back
evaluation context to be processed.\n
通过使用函数重载和元编程技巧，_callable_context_ 可以在编译期检测出是否有一个这样的函数存在。
如果有，则调用该函数。如果没有，则将当前表达式传递给后传上下文来处理。

We saw another example of the _callable_context_ when we looked at the simple
calculator expression evaluator. There, we wanted to customize the evaluation
of placeholder terminals, and delegate the handling of all other nodes to the
_default_context_. We did that as follows:\n
我们来看 _callable_context_ 的另一个例子，我们看一个简单的计算器表达式求值器。
我们想定制对占位符终结符的求值，并将所有其它节点的处理委派给 _default_context_。我们可以这样做：

    // An evaluation context for calculator expressions that
    // explicitly handles placeholder terminals, but defers the
    // processing of all other nodes to the default_context.
    // 一个计算器表达式的求值上下文，显式地处理占位符终结符，而将所有其它节点的处理交给 default_context.
    struct calculator_context
      : proto::callable_context< calculator_context const >
    {
        std::vector<double> args;

        // Define the result type of the calculator. 定义计算器的返回类型。
        typedef double result_type;

        // Handle the placeholders: 处理占位符：
        template<int I>
        double operator()(proto::tag::terminal, placeholder<I>) const
        {
            return this->args[I];
        }
    };

In this case, we didn't specify a fall-back context. In that case,
_callable_context_ uses the _default_context_. With the above
`calculator_context` and a couple of appropriately defined placeholder
terminals, we can evaluate calculator expressions, as demonstrated
below:\n
在这个例子中，我们没有指定后传上下文。为此，_callable_context_ 使用了 _default_context_。
使用以上 `calculator_context` 以及一些适当定义的占位符终结符，我们可以对计算器表达式求值，示范如下： 

    template<int I>
    struct placeholder
    {};

    terminal<placeholder<0> >::type const _1 = {{}};
    terminal<placeholder<1> >::type const _2 = {{}};
    // ...

    calculator_context ctx;
    ctx.args.push_back(4);
    ctx.args.push_back(5);

    double j = proto::eval( (_2 - _1) / _2 * 100, ctx );
    std::cout << "j = " << j << std::endl;

The above code displays the following:\n
以上代码输出如下：

[pre
j = 20
]

[endsect]

[endsect]

[endsect]

[import ../test/examples.cpp]

[/============================================================================]
[section:expression_transformation Expression Transformation: Semantic Actions 表达式变换：语义动作]
[/============================================================================]

If you have ever built a parser with the help of a tool like Antlr, yacc or Boost.Spirit, you might be familiar with /semantic actions/. In addition to allowing you to define the grammar of the language recognized by the parser, these tools let you embed code within your grammar that executes when parts of the grammar participate in a parse. Proto has the equivalent of semantic actions. They are called /transforms/. This section describes how to embed transforms within your Proto grammars, turning your grammars into function objects that can manipulate or evaluate expressions in powerful ways.\n
如果你曾经在某个工具，如 Antlr, yacc 或 Boost.Spirit，的帮助下构建过一个词法分析器，你可能会知道/语义动作/。
除了可以让你定义词法分析器所识别的语言的语法之外，这些工具还可以让你将一些代码嵌入到你的语法中，当这部分语法在分析时可以执行这些代码。
Proto 也有与语义动作相当的东西。它们被称为/变换/。本节将描述如何将变换嵌入到你的 Proto 语法中，将你的语法变为函数对象，
以更强大的方式来操纵表达式和进行求值。

Proto transforms are an advanced topic. We'll take it slow, using examples to illustrate the key concepts, starting simple.\n
Proto 变换是一个高级议题。我们会慢慢讲，用一些例子来示范其中的关键概念，先从简单的开始。

[/==================================]
[section ["Activating] Your Grammars "激活"你的语法]
[/==================================]

The Proto grammars we've seen so far are static. You can check at compile-time to see if an expression type matches a grammar, but that's it. Things get more interesting when you give them runtime behaviors. A grammar with embedded transforms is more than just a static grammar. It is a function object that accepts expressions that match the grammar and does /something/ with them.\n
到目前为止，我们见到的 Proto 语法都是静态的。你可以在编译期检查某个表达式类型是否与语法匹配，仅此而已。
如果你给予它们运行期行为，则事情会更有趣。嵌入了变换的语法不再仅仅是一个静态语法而已。它是一个函数对象，
接受与此语法匹配的表达式，并会对它们做些/事情/。

Below is a very simple grammar. It matches terminal expressions.\n
以下是一个更深简单的语法。它匹配终结符表达式。

    // A simple Proto grammar that matches all terminals
    // 一个匹配所有终结符的简单的 Proto 语法
    proto::terminal< _ >

Here is the same grammar with a transform that extracts the value from the terminal:\n
以下是一个相同的语法，带有一个从终结符取出值的变换：

    // A simple Proto grammar that matches all terminals
    // *and* a function object that extracts the value from
    // the terminal
    // 一个匹配所有终结符的简单的Proto语法，以及一个从终结符取出值的函数对象
    proto::when<
        proto::terminal< _ >
      , proto::_value          // <-- Look, a transform! 看，这是一个变换！
    >

You can read this as follows: when you match a terminal expression, extract the value. The type `proto::_value` is a so-called transform. Later we'll see what makes it a transform, but for now just think of it as a kind of function object. Note the use of _when_: the first template parameter is the grammar to match and the second is the transform to execute. The result is both a grammar that matches terminal expressions and a function object that accepts terminal expressions and extracts their values. \n
你可以之样来读它：当你匹配了一个终结符表达式，取出它的值。类型 `proto::_value` 是一个所谓的变换。
稍后我们将看到是什么使得它成为一个变换，不过现在我们只把它想象为一种函数对象。留意 _when_ 的用法：
第一个模板参数是要匹配的语法，第二个是要执行的变换。其结果既是一个匹配终结符表达式的语法，
也是一个接受终结符表达式并返回其值的函数对象。

As with ordinary grammars, we can define an empty struct that inherits from a grammar+transform to give us an easy way to refer back to the thing we're defining, as follows:\n
和普通的语法一样，我们可以定义一个空的结构，派生自一个语法+变换，这样可以很容易地引用回我们定义的东西，如下：

    // A grammar and a function object, as before
    // 一个语法和一个函数对象，如前
    struct Value
      : proto::when<
            proto::terminal< _ >
          , proto::_value
        >
    {};

    // "Value" is a grammar that matches terminal expressions
    // ”Value"是一个匹配终结符表达式的语法
    BOOST_MPL_ASSERT(( proto::matches< proto::terminal<int>::type, Value > ));

    // "Value" also defines a function object that accepts terminals
    // and extracts their value.
    // "Value"也定义了一个接受一个终结符并取出其值的函数对象。
    proto::terminal<int>::type answer = {42};
    Value get_value;
    int i = get_value( answer );

As already mentioned, `Value` is a grammar that matches terminal expressions and a function object that operates on terminal expressions. It would be an error to pass a non-terminal expression to the `Value` function object. This is a general property of grammars with transforms; when using them as function objects, expressions passed to them must match the grammar.\n
前面已经提过，`Value` 是一个匹配终结符表达式的语法，也是一个操作于终结符表达式之上的函数对象。
传递一个非终结符表达式给 `Value` 函数对象是错误的。这是带有变换的语法的基本特性；把它们当作函数对象使用时，
传递给它们的表达式必须符合相应的语法。

Proto grammars are valid TR1-style function objects. That means you can use `boost::result_of<>` to ask a grammar what its return type will be, given a particular expression type. For instance, we can access the `Value` grammar's return type as follows:\n
Proto 语法是有效的TR1风格的函数对象。这意味着你可以用 `boost::result_of<>` 来询问某个语法，给定一个特定的表达式类型，
它的返回类型是什么。例如，我们可以如下获得 `Value` 语法的返回类型：

    // We can use boost::result_of<> to get the return type
    // of a Proto grammar.
    // 我们可以用 boost::result_of<> 来获得一个 Proto 语法的返回类型
    typedef
        typename boost::result_of<Value(proto::terminal<int>::type)>::type
    result_type;

    // Check that we got the type we expected
    // 检查我们获得的类型是否所期望的
    BOOST_MPL_ASSERT(( boost::is_same<result_type, int> ));

[note A grammar with embedded transforms is both a grammar and a function object. Calling these things "grammars with transforms" would get tedious. We could call them something like "active grammars", but as we'll see /every/ grammar that you can define with Proto is "active"; that is, every grammar has some behavior when used as a function object. So we'll continue calling these things plain "grammars". The term "transform" is reserved for the thing that is used as the second parameter to the _when_ template.\n
一个带有内嵌变换的语法既是一个语法，也是一个函数对象。把它称为"带变换的语法"太过麻烦。我们可以称之为"主动语法"，不过，
就象我们即将看到的那样，你用 Proto 定义的/每一个/语法都是"主动"的；即，每一个语法被作为函数对象使用时都会有一些行为。
所以，我们继续把它们称为"语法"就算了。术语"变换"保留作为对 _when_ 模板的第二个参数的称呼。]

[endsect]

[/=========================================]
[section Handling Alternation and Recursion 处理多选与递归]
[/=========================================]

Most grammars are a little more complicated than the one in the preceding section. For the sake of illustration, let's define a rather nonsensical grammar that matches any expression and recurses to the leftmost terminal and returns its value. It will demonstrate how two key concepts of Proto grammars -- alternation and recursion -- interact with transforms. The grammar is described below.\n
多数语法要比上一节中的复杂一点。为了示范之用，我们来定义一个荒谬的语法，它匹配任意的表达式，递归至最左侧的终结符并返回其值。
它将示范 Proto 语法的两个关键概念 -- 多选与递归 -- 是如何与变换相结合的。该语法表示如下。

    // A grammar that matches any expression, and a function object
    // that returns the value of the leftmost terminal.
    // 一个匹配任意表达式的语法，以及一个返回最左侧终结符的值的函数对象。
    struct LeftmostLeaf
      : proto::or_<
            // If the expression is a terminal, return its value
            // 如果该表达式是一个终结符，则返回它的值
            proto::when<
                proto::terminal< _ >
              , proto::_value
            >
            // Otherwise, it is a non-terminal. Return the result
            // of invoking LeftmostLeaf on the 0th (leftmost) child.
            // 否则，它不是一个终结符。返回对第0个(最左边的)子节点调用LeftmostLeaf的结果。
          , proto::when<
                _
              , LeftmostLeaf( proto::_child0 )
            >
        >
    {};

    // A Proto terminal wrapping std::cout 包装了std::cout的Proto终结符
    proto::terminal< std::ostream & >::type cout_ = { std::cout };
    
    // Create an expression and use LeftmostLeaf to extract the
    // value of the leftmost terminal, which will be std::cout.
    // 创建一个表达式并用LeftmostLeaf来取出最左侧终结符的值，即std::cout。
    std::ostream & sout = LeftmostLeaf()( cout_ << "the answer: " << 42 << '\n' );

We've seen `proto::or_<>` before. Here it is serving two roles. First, it is a grammar that matches any of its alternate sub-grammars; in this case, either a terminal or a non-terminal. Second, it is also a function object that accepts an expression, finds the alternate sub-grammar that matches the expression, and applies its transform. And since `LeftmostLeaf` inherits from `proto::or_<>`, `LeftmostLeaf` is also both a grammar and a function object.\n
前面我们已经见过 `proto::or_<>` 了。在这里它扮演两个角色。首先，它是一个匹配其任一子语法的语法；在这个例子中，
即为终结符或非终结符。其次，它也是一个函数对象，接受一个表达式，找出与该表达式相匹配的子语法，并对它应用变换。
由于 `LeftmostLeaf` 继承自 `proto::or_<>`，所以 `LeftmostLeaf` 既是一个语法，也是一个函数对象。

[def _some_transform_ [~some-transform]]

[note The second alternate uses `proto::_` as its grammar. Recall that `proto::_` is the wildcard grammar that matches any expression. Since alternates in `proto::or_<>` are tried in order, and since the first alternate handles all terminals, the second alternate handles all (and only) non-terminals. Often enough, `proto::when< _, _some_transform_ >` is the last alternate in a grammar, so for improved readability, you could use the equivalent `proto::otherwise< _some_transform_ >`.\n
第二个选择以 `proto::_` 作为其语法。回想一下，`proto::_` 是匹配任意表达式的通配语法。由于在 `proto::or_<>` 中的候选项是按顺序尝试的，
而且第一个候选项对应所有终结符，所以第二个候选项代表所有(也仅仅是)非终结符。通常来说，`proto::when< _, _some_transform_ >` 
作为语法中的最后一个候选项就足够了，如果要提高可读性，你可以用等价的 `proto::otherwise< _some_transform_ >`. ]

The next section describes this grammar further.\n
下一节将进一步讨论这个语法。

[endsect]

[/==========================]
[section Callable Transforms 可调用变换]
[/==========================]

[def __bold_transform__ [*LeftmostLeaf( proto::_child0 )]]

In the grammar defined in the preceding section, the transform associated with non-terminals is a little strange-looking:\n
在前一节中定义的语法中，与非终结符相关联的变换看起来有些奇怪：

    proto::when<
        _
      , __bold_transform__   // <-- a "callable" transform 一个"可调用"变换
    >

It has the effect of accepting non-terminal expressions, taking the 0th (leftmost) child and recursively invoking the `LeftmostLeaf` function on it. But `LeftmostLeaf( proto::_child0 )` is actually a /function type/. Literally, it is the type of a function that accepts an object of type `proto::_child0` and returns an object of type `LeftmostLeaf`. So how do we make sense of this transform? Clearly, there is no function that actually has this signature, nor would such a function be useful. The key is in understanding how `proto::when<>` /interprets/ its second template parameter.\n
其中含有对于非终结符表达式的动作，取出第0个(最左边)子节点并对其递归调用 `LeftmostLeaf` 函数。但是 `LeftmostLeaf( proto::_child0 )` 
是一个实实在在的/函数类型/啊。从字面上看，它是一个函数的类型，该函数接受一个类型为 `proto::_child0` 的对象并返回一个类型为 
`LeftmostLeaf` 的对象。那么我们要如何弄清楚这个变换的意思呢？无疑，并没有一个函数真的具有这个签名，这样的函数也没有用。
关键在于要弄明白 `proto::when<>` 如何解释它的第二个模板参数。

When the second template parameter to _when_ is a function type, _when_ interprets the function type as a transform. In this case, `LeftmostLeaf` is treated as the type of a function object to invoke, and `proto::_child0` is treated as a transform. First, `proto::_child0` is applied to the current expression (the non-terminal that matched this alternate sub-grammar), and the result (the 0th child) is passed as an argument to `LeftmostLeaf`.\n
如果传递给 _when_ 的第二个模板参数是一个函数类型，则 _when_ 将该函数类型解释为一个变换。在这个例子中，
`LeftmostLeaf` 被视为要调用的函数对象的类型，而 `proto::_child0` 则被视为一个变换。首先，将 `proto::_child0` 应用至当前表达式
(匹配该被选子语法的非终结符)，然后将结果(第0个子节点)作为参数传递给 `LeftmostLeaf`。

[note *Transforms are a Domain-Specific Language 变换是一种领域专用语言*

`LeftmostLeaf( proto::_child0 )` /looks/ like an invocation of the `LeftmostLeaf` function object, but it's not, but then it actually is! Why this confusing subterfuge? Function types give us a natural and concise syntax for composing more complicated transforms from simpler ones. The fact that the syntax is suggestive of a function invocation is on purpose. It is a domain-specific embedded language for defining expression transformations. If the subterfuge worked, it may have fooled you into thinking the transform is doing exactly what it actually does! And that's the point.\n
`LeftmostLeaf( proto::_child0 )` /看起来/就象对 `LeftmostLeaf` 函数对象的一次调用，但它不是，然后实际上它就是！为什么说的如此混乱？
函数类型给了我们一个自然且简洁的语法来从简单的变换组合出复杂的变换。事实上，这个语法只是某个函数的提示，调用才是目的。
它是一种用于定义表达式变换的领域专用语言。如果这种托词可以成功，它可能会蒙蔽你，使你以为变换在做的其实就是它实际上要做的！这就是重点。]

The type `LeftmostLeaf( proto::_child0 )` is an example of a /callable transform/. It is a function type that represents a function object to call and its arguments. The types `proto::_child0` and `proto::_value` are /primitive transforms/. They are plain structs, not unlike function objects, from which callable transforms can be composed. There is one other type of transform, /object transforms/, that we'll encounter next.\n
类型 `LeftmostLeaf( proto::_child0 )` 是 /可调用变换/ 的一个例子。它是一个函数类型，表示一个要调用的函数对象及其参数。
类型 `proto::_child0` 和 `proto::_value` 则是 /基本变换/。它们是普通的结构，不象函数对象，可以由它们组合出可调用变换。
另外还有一种变换类型，/对象变换/，后面我们将要提到。

[endsect]

[/========================]
[section Object Transforms 对象变换]
[/========================]

The very first transform we looked at simply extracted the value of terminals. Let's do the same thing, but this time we'll promote all ints to longs first. (Please forgive the contrived-ness of the examples so far; they get more interesting later.) Here's the grammar:\n
我们最早见到的一个变换只是取出终结符的值。下面我们再来做同样的事情，不过这次我们先要将所有 int 提升为 long。
(请忘记到目前为止的这些例子的做作性；稍后它们会更有趣些)。以下是相应语法：

    // A simple Proto grammar that matches all terminals,
    // and a function object that extracts the value from
    // the terminal, promoting ints to longs:
    // 一个简单的Proto语法，匹配所有终结符，以及一个从终结符取出值的函数对象，将int提升为long:
    struct ValueWithPomote
      : proto::or_<
            proto::when<
                proto::terminal< int >
              , long(proto::_value)     // <-- an "object" transform 一个"对象"变换
            >
          , proto::when<
                proto::terminal< _ >
              , proto::_value
            >
        >
    {};

You can read the above grammar as follows: when you match an int terminal, extract the value from the terminal and use it to initialize a long; otherwise, when you match another kind of terminal, just extract the value. The type `long(proto::_value)` is a so-called /object/ transform. It looks like the creation of a temporary long, but it's really a function type. Just as a callable transform is a function type that represents a function to call and its arguments, an object transforms is a function type that represents an object to construct and the arguments to its constructor.\n
你可这样来读以上语法：如果你匹配到一个int终结符，就从终结符中取出它的值，并用它来初始化一个long；否则，如果你匹配到其它类型的终结符，
则只是取出它的值。类型 `long(proto::_value)` 是一个所谓的 /对象/变换。它看起来象是创建一个临时的long，其实它是一个函数类型。
和可调用变换是一个表示了要调用的函数及其参数的函数类型一样，对象变换是一个表示了要构造的对象及其构造函数的参数的函数类型。

[/================================================]
[note *Object Transforms vs. Callable Transforms 对象变换 vs. 可调用变换*

When using function types as Proto transforms, they can either represent an object to construct or a function to call. It is similar to "normal" C++ where the syntax `foo("arg")` can either be interpreted as an object to construct or a function to call, depending on whether `foo` is a type or a function. But consider two of the transforms we've seen so far:\n
把函数类型用作 Proto 变换时，它们可以表示一个要构造的对象，或者表示一个要调用的函数。这类似于"普通"的C++，
语法 `foo("arg")` 可以解释为一个要构造的对象，或者是一个要调用的函数，这取决于 `foo` 是一个类型还是一个函数。
不过，考虑一下我们已见到的两个变换：

``
    LeftmostLeaf(proto::_child0)  // <-- a callable transform 一个可调用变换
    long(proto::_value)           // <-- an object transform  一个对象变换
``

Proto can't know in general which is which, so it uses a trait, `proto::is_callable<>`, to differentiate. `is_callable< long >::value` is false so `long(proto::_value)` is an object to construct, but `is_callable< LeftmostLeaf >::value` is true so `LeftmostLeaf(proto::_child0)` is a function to call. Later on, we'll see how Proto recognizes a type as "callable".\n
Proto 通常并不知道哪个是哪个，所以它使用了 trait，`proto::is_callable<>`，来区分。`is_callable< long >::value` 为false，
所以 `long(proto::_value)` 是一个要构造的对象，而 `is_callable< LeftmostLeaf >::value` 为true，所以 `LeftmostLeaf(proto::_child0)` 
是一个要调用的函数。接着，我们将会看到 Proto 是如何把一个类型识别为"可调用"的。]
[/================================================]

[endsect]

[/================================]
[section Example: Calculator Arity 示例：计算器Arity]
[/================================]

Now that we have the basics of Proto transforms down, let's consider a slightly more realistic example. We can use transforms to improve the type-safety of the [link boost_proto.users_guide.getting_started.hello_calculator calculator DSEL]. If you recall, it lets you write infix arithmetic expressions involving argument placeholders like `_1` and `_2` and pass them to STL algorithms as function objects, as follows:\n
现在我们已经有了 Proto 变换的基础，让我们来考虑一下更现实一些例子。我们可以用变换来改进 
[link boost_proto.users_guide.getting_started.hello_calculator calculator 计算器 DSEL] 的类型安全性。
如果你还记得，它可以让你编写含有参数占位符，如 `_1` 和 `_2`，的中缀算术表达式，并将表达式作为函数对象传递给STL算法，如下：

    double a1[4] = { 56, 84, 37, 69 };
    double a2[4] = { 65, 120, 60, 70 };
    double a3[4] = { 0 };

    // Use std::transform() and a calculator expression
    // to calculate percentages given two input sequences:
    // 用std::transform()和一个计算器表达式对给定的两个输入序列计算百分比：
    std::transform(a1, a1+4, a2, a3, (_2 - _1) / _2 * 100);

This works because we gave calculator expressions an `operator()` that evaluates the expression, replacing the placeholders with the arguments to `operator()`. The overloaded `calculator<>::operator()` looked like this:\n
这可以是因为我们给了计算器表达式一个 `operator()` 来对表达式进行求值并以传给 `operator()` 的参数替换相应的占位符。
重载的 `calculator<>::operator()` 看起来如下：

    // Overload operator() to invoke proto::eval() with
    // our calculator_context.
    // 重载operator()，以我们的calculator_context调用proto::eval()。
    template<typename Expr>
    double
    calculator<Expr>::operator()(double a1 = 0, double a2 = 0) const
    {
        calculator_context ctx;
        ctx.args.push_back(a1);
        ctx.args.push_back(a2);
        
        return proto::eval(*this, ctx);
    }

Although this works, it's not ideal because it doesn't warn users if they supply too many or too few arguments to a calculator expression. Consider the following mistakes:\n
虽然这样做可以，但是它还不是完美的，因为如果向计算器表达式提供了过多或过少的参数，它不会给出警告。考虑以下错误：

    (_1 * _1)(4, 2);  // Oops, too many arguments! 喔，太多参数了！
    (_2 * _2)(42);    // Oops, too few arguments! 喔，太少参数了！

The expression `_1 * _1` defines a unary calculator expression; it takes one argument and squares it. If we pass more than one argument, the extra arguments will be silently ignored, which might be surprising to users. The next expression, `_2 * _2` defines a binary calculator expression; it takes two arguments, ignores the first and squares the second. If we only pass one argument, the code silently fills in `0.0` for the second argument, which is also probably not what users expect. What can be done?\n
表达式 `_1 * _1` 定义了一个单参数的计算器表达式；它接受一个参数并对它求平方。如果我们传入一个以上的参数，则额外的参数会被悄悄地忽略掉，
这可能会令用户惊讶。第二个表达式，`_2 * _2` 定义了一个二元计算器表达式；它接受两个参数，忽略其中第一个而对第二个求平方。
如果我们只传入一个参数，代码会悄悄地将 `0.0` 填入第二个参数，这同样可能不是用户想要的。那么可以怎么做呢？

We can say that the /arity/ of a calculator expression is the number of arguments it expects, and it is equal to the largest placeholder in the expression. So, the arity of `_1 * _1` is one, and the arity of `_2 * _2` is two. We can increase the type-safety of our calculator DSEL by making sure the arity of an expression equals the actual number of arguments supplied. Computing the arity of an expression is simple with the help of Proto transforms.\n
我们可以说，一个计算器表达式的 /arity/ 是它所期望的参数数量，它等于表达式中最大的占位符。因此，`_1 * _1` 的arity为1，
而 `_2 * _2` 的arity为2。我们可以通过确认一个表达式的arity是否等于实际提供的参数数量来提高我们的计算器DSEL的类型安全性。
有了 Proto 变换的帮助，计算一个表达式的arity很简单。

It's straightforward to describe in words how the arity of an expression should
be calculated. Consider that calculator expressions can be made of `_1`, `_2`, literals, unary expressions and binary expressions. The following table shows the arities for each of these 5 constituents.\n
用语言来表达如何计算一个表达式的arity非常简单。考虑到计算器表达式可以由 `_1`, `_2`, 字面值，单参数表达式和二元表达式组成。
下表展示了这5种情况的arity。

[table Calculator Sub-Expression Arities 计算器子表达式的arity
    [[Sub-Expression 子表达式]       [Arity]]
    [[Placeholder 1 占位符1]        [`1`]]
    [[Placeholder 2 占位符2]        [`2`]]
    [[Literal 字面值]              [`0`]]
    [[Unary Expression 单参数表达式]     [ /arity of the operand 操作数的arity/ ]]
    [[Binary Expression 二元表达式]    [ /max arity of the two operands 两个操作数的arity的最大值/ ]]
]

Using this information, we can write the grammar for calculator expressions and attach transforms for computing the arity of each constituent. The code below computes the expression arity as a compile-time integer, using integral wrappers and metafunctions from the Boost MPL Library. The grammar is described below.\n
使用这些信息，我们可以写出计算器表达式的语法并附上计算每种情形的arity的变换。以下代码将表达式的arity计算为一个编译期整数，
使用来自Boost MPL库的整数包装器和元函数。语法描述如下。

[CalcArity]

When we find a placeholder terminal or a literal, we use an /object transform/ such as `mpl::int_<1>()` to create a (default-constructed) compile-time integer representing the arity of that terminal.\n
当我们找到一个占位符终结符或一个字面值时，我们使用一个形如 `mpl::int_<1>()` 的/对象变换/ 来创建一个(缺省构造的)编译期整数，
表示这个终结符的arity。

For unary expressions, we use `CalcArity(proto::_child)` which is a /callable transform/ that computes the arity of the expression's child.\n
对于单参数表达式，我们使用 `CalcArity(proto::_child)`，它是一个计算该表达式的子节点的arity的/可调用变换/。

The transform for binary expressions has a few new tricks. Let's look more closely:\n
二元表达式的变换有点诀窍。我们靠近一点来看：

    // Compute the left and right arities and
    // take the larger of the two.
    // 计算左、右节点的arity，并取出两者中的较大值。
    mpl::max<CalcArity(proto::_left),
             CalcArity(proto::_right)>()

This is an object transform; it default-constructs ... what exactly? The `mpl::max<>` template is an MPL metafunction that accepts two compile-time integers. It has a nested `::type` typedef (not shown) that is the maximum of the two. But here, we appear to be passing it two things that are /not/ compile-time integers; they're Proto callable transforms. Proto is smart enough to recognize that fact. It first evaluates the two nested callable transforms, computing the arities of the left and right child expressions. Then it puts the resulting integers into `mpl::max<>` and evaluates the metafunction by asking for the nested `::type`. That is the type of the object that gets default-constructed and returned.\n
这是一个对象变换；它缺省构造了 ... 什么呢？模板 `mpl::max<>` 是一个MPL元函数，它接受两个编译期整数。
它有一个嵌套的 `::type` typedef (未示出)表示这两个整数中的最大者。不过在这里，我们看到的是，传给它的是两个/不是/编译期整数的东西；
传入的是 Proto 可调用变换。Proto 是很聪明的，它可以识别出这个事实。它首先对两个嵌套的可调用变换进行求值，分别计算左、右节点的arity。
然后将结果整数放入 `mpl::max<>` 并通过询问嵌套的 `::type` 来对元函数求值。结果就是获得缺省构造并返回的对象类型。

More generally, when evaluating object transforms, Proto looks at the object type and checks whether it is a template specialization, like `mpl::max<>`. If it is, Proto looks for nested transforms that it can evaluate. After any nested transforms have been evaluated and substituted back into the template, the new template specialization is the result type, unless that type has a nested `::type`, in which case that becomes the result.\n
更一般地说，在对对象变换进行求值时，Proto 会查看对象的类型并检查它是否为一个模板特化，如 `mpl::max<>`。如果是，
则 Proto 寻找它可以求值的嵌套变换。在所有嵌套变换都求值后，将结果替换回模板中，新的模板特化就是结果类型，
除非该类型带有一个嵌套的 `::type`，这种情况下它才是结果。

Now that we can calculate the arity of a calculator expression, let's redefine the `calculator<>` expression wrapper we wrote in the Getting Started guide to use the `CalcArity` grammar and some macros from Boost.MPL to issue compile-time errors when users specify too many or too few arguments.\n
现在，我们可以计算一个计算器表达式的arity了，让我们用 `CalcArity` 语法和来自Boost.MPL的一些宏来对我们在"入门"一节中写过的 
`calculator<>` 表达式包装器进行重新定义，以便当用户指定了过多或过少参数时给出编译期错误。

    // The calculator expression wrapper, as defined in the Hello
    // Calculator example in the Getting Started guide. It behaves
    // just like the expression it wraps, but with extra operator()
    // member functions that evaluate the expression.
    //   NEW: Use the CalcArity grammar to ensure that the correct
    //   number of arguments are supplied.
    // 计算器表达式包装器，类似于在"入门"一节的 Hello Calculator 例子中的定义。
    // 其行为类似于所包装的表达式，但带有额外的operator()成员函数来对表达式求值。
    //   新增：使用CalcArity语法来确保给出的参数数量是正确的。
    template<typename Expr>
    struct calculator
      : proto::extends<Expr, calculator<Expr>, calculator_domain>
    {
        typedef
            proto::extends<Expr, calculator<Expr>, calculator_domain>
        base_type;

        calculator(Expr const &expr = Expr())
          : base_type(expr)
        {}

        typedef double result_type;

        // Use CalcArity to compute the arity of Expr: 
        // 用CalcArity来计算Expr的arity：
        static int const arity = boost::result_of<CalcArity(Expr)>::type::value;

        double operator()() const
        {
            BOOST_MPL_ASSERT_RELATION(0, ==, arity);
            calculator_context ctx;
            return proto::eval(*this, ctx);
        }

        double operator()(double a1) const
        {
            BOOST_MPL_ASSERT_RELATION(1, ==, arity);
            calculator_context ctx;
            ctx.args.push_back(a1);
            return proto::eval(*this, ctx);
        }

        double operator()(double a1, double a2) const
        {
            BOOST_MPL_ASSERT_RELATION(2, ==, arity);
            calculator_context ctx;
            ctx.args.push_back(a1);
            ctx.args.push_back(a2);
            return proto::eval(*this, ctx);
        }
    };

Note the use of `boost::result_of<>` to access the return type of the `CalcArity` function object. Since we used compile-time integers in our transforms, the arity of the expression is encoded in the return type of the `CalcArity` function object. Proto grammars are valid TR1-style function objects, so you can use `boost::result_of<>` to figure out their return types.\n
注意，其中使用了 `boost::result_of<>` 来获得 `CalcArity` 函数对象的返回类型。由于我们在变换中使用了编译期整数，
所以表达式的arity是被编码在 `CalcArity` 函数对象的返回类型中的。Proto 语法是有效的TR1风格的函数对象，所以你可以用 
`boost::result_of<>` 来取出它的返回类型。

With our compile-time assertions in place, when users provide too many or too few arguments to a calculator expression, as in:\n
有了我们的编译期断言后，当用户提供过多或过少参数给计算器表达式时，如下：

    (_2 * _2)(42); // Oops, too few arguments! 喔，太少参数了！

... they will get a compile-time error message on the line with the assertion that reads something like this:\n
... 他们将得到一个编译期的错误信息，指向断言所在的行，提示类似于[footnote This error message was generated with Microsoft Visual C++ 9.0. Different compilers will emit different messages with varying degrees of readability.\n
这个错误信息是由 Microsoft Visual C++ 9.0 产生的。不同的编译器会给出可读性程度不同的信息。]:

[pre
c:\boost\org\trunk\libs\proto\scratch\main.cpp(97) : error C2664: 'boost::mpl::asse
rtion\_failed' : cannot convert parameter 1 from 'boost::mpl::failed \*\*\*\*\*\*\*\*\*\*\*\*boo
st::mpl::assert\_relation<x,y,\_\_formal>::\*\*\*\*\*\*\*\*\*\*\*\*' to 'boost::mpl::assert<false>
::type'
   with
   \[
       x\=1,
       y\=2,
       \_\_formal\=bool boost::mpl::operator\=\=(boost::mpl::failed,boost::mpl::failed)
   \]
]

The point of this exercise was to show that we can write a fairly simple Proto grammar with embedded transforms that is declarative and readable and can compute interesting properties of arbitrarily complicated expressions. But transforms can do more than that. Boost.Xpressive uses transforms to turn expressions into finite state automata for matching regular expressions, and Boost.Spirit uses transforms to build recursive descent parser generators. Proto comes with a collection of built-in transforms that you can use to perform very sophisticated expression manipulations like these. In the next few sections we'll see some of them in action.\n
这个练习所展示的观点是，我们可以编写一个很简单的、带有嵌入变换的、具有描述性和可读性的 Proto 语法，
它可以计算一个任意复杂的表达式的某些你感兴趣的属性。但是变换可以做得更多。
Boost.Xpressive 使用变换来将表达式转为有限状态机以匹配正则表达式，而 Boost.Spirit 则使用变换来构建递归下降分析器的生成器。
Proto 配备了一组内建变换，你可以用它们来执行象这样的一些非常复杂的表达式处理。在下面几节中，我们将看到其中的一些。

[endsect]

[/===============================================]
[section:state Transforms With State Accumulation 带状态累计的变换]
[/===============================================]

So far, we've only seen examples of grammars with transforms that accept one argument: the expression to transform. But consider for a moment how, in ordinary procedural code, you would turn a binary tree into a linked list. You would start with an empty list. Then, you would recursively convert the right branch to a list, and use the result as the initial state while converting the left branch to a list. That is, you would need a function that takes two parameters: the current node and the list so far. These sorts of /accumulation/ problems are quite common when processing trees. The linked list is an example of an accumulation variable or /state/. Each iteration of the algorithm takes the current element and state, applies some binary function to the two and creates a new state. In the STL, this algorithm is called `std::accumulate()`. In many other languages, it is called /fold/. Let's see how to implement a fold algorithm with Proto transforms.\n
到目前为止，我们看到的语法例子中的变换都只是接受一个参数：即进行变换的表达式。但是考虑一下，在普通的程序代码中，
你会如何将一个二叉树转换为一个链表。你会从一个空链表开始。然后递归地将右分支转换为一个链表，并以此结果作为初始状态，
同时将左分支也转换为一个链表。也就是说，你需要一个接受两个参数的函数，这两个参数分别是：当前节点以及到目前为止的链表。
在处理树结构时，这一类/累计/问题是很常见的。这个链表是累计变量或/状态/的一个例子。该算法的每一次迭代都接受当前元素和状态，
对这两者应用某些二元函数并创建一个新的状态。在STL中，这个算法称为 `std::accumulate()`。而在许多其它的语言中，它被称为/折叠/。
我们来看看如何用Proto变换来实现一个折叠算法。

All Proto grammars can optionally accept a state parameter in addition to the expression to transform. If you want to fold a tree to a list, you'll need to make use of the state parameter to pass around the list you've built so far. As for the list, the Boost.Fusion library provides a `fusion::cons<>` type from which you can build heterogeneous lists. The type `fusion::nil` represents an empty list. \n
所有的Proto语法除了变换的表达式之外，都接受一个可选的状态参数。如果你想将一棵树折叠为一个链表，
你需要利用这个状态参数来传递迄今你所建立的链表。至于这个链表，Boost.Fusion 库提供了一个 `fusion::cons<>` 类型，
从中你可以建立一个异构的链表。类型 `fusion::nil` 则表示一个空的链表。

Below is a grammar that recognizes output expressions like `cout_ << 42 << '\n'` and puts the arguments into a Fusion list. It is explained below.\n
以下是一个语法，它识别形如 `cout_ << 42 << '\n'` 的输出表达式并将参数放入一个 Fusion 链表。解释如下。

    // Fold the terminals in output statements like
    // "cout_ << 42 << '\n'" into a Fusion cons-list.
    // 将形如"cout_ << 42 << '\n'"这样的输出语句中的终结符折叠到一个Fusion cons-链表中。
    struct FoldToList
      : proto::or_<
            // Don't add the ostream terminal to the list
            // 不要将ostream终结符加到链表中
            proto::when<
                proto::terminal< std::ostream & >
              , proto::_state
            >
            // Put all other terminals at the head of the
            // list that we're building in the "state" parameter
            // 将其它所有终结符放在我们正在"state"参数中构建的链表的头部
          , proto::when<
                proto::terminal<_>
              , fusion::cons<proto::_value, proto::_state>(
                    proto::_value, proto::_state
                )
            >
            // For left-shift operations, first fold the right
            // child to a list using the current state. Use
            // the result as the state parameter when folding
            // the left child to a list.
            // 对于左移操作，首先将右子节点与当前state折叠到一个链表中。        
            // 然后在将左子节点折叠至链表时，把该结果作为state参数。
          , proto::when<
                proto::shift_left<FoldToList, FoldToList>
              , FoldToList(
                    proto::_left
                  , FoldToList(proto::_right, proto::_state)
                )
            >
        >
    {};

Before reading on, see if you can apply what you know already about object, callable and primitive transforms to figure out how this grammar works.\n
在继续往下之前，看看你是否可以用你已知的关于对象变换、可调用变换和基本变换的知识来找出这个语法是如何工作的。

When you use the `FoldToList` function, you'll need to pass two arguments: the expression to fold, and the initial state: an empty list. Those two arguments get passed around to each transform. We learned previously that `proto::_value` is a primitive transform that accepts a terminal expression and extracts its value. What we didn't know until now was that it also accepts the current state /and ignores it/. `proto::_state` is also a primitive transform. It accepts the current expression, which it ignores, and the current state, which it returns.\n
当你使用 `FoldToList` 函数时，你需要传入两个参数：进行折叠的表达式，以及初始状态：一个空的链表。
这两个参数被传递给每一个变换。前面我们已经学过 `proto::_value` 是一个基本变换，接受一个终结符表达式并了取出其值。
我们还不知道的是，它也可以接受当前的状态/并忽略它/。`proto::_state` 也是一个基本变换。它接受当前的表达式和当前状态，
但忽略前者而返回后者。

When we find a terminal, we stick it at the head of the cons list, using the current state as the tail of the list. (The first alternate causes the `ostream` to be skipped. We don't want `cout` in the list.) When we find a shift-left node, we apply the following transform:\n
当我们找到一个终结符时，我们把它放在cons链表的头部，并以当前状态作为链表的尾部。(第一个候选项导致 `ostream` 被跳过。
我们不想让 `cout` 出现在链表中)。当我们找到一个左移节点时，我们使用以下变换：

    // Fold the right child and use the result as
    // state while folding the right.
    // 折叠右子节点并将结果用作折叠左子节点时的状态。
    FoldToList(
        proto::_left
      , FoldToList(proto::_right, proto::_state)
    )

You can read this transform as follows: using the current state, fold the right child to a list. Use the new list as the state while folding the left child to a list.\n
你可以这样来解读这个变换：使用当前状态，将右子节点折叠至一个链表。把这个新链表用作状态参数，将左子节点折叠至一个链表。

[tip If your compiler is Microsoft Visual C++, you'll find that the above transform does not compile. The compiler has bugs with its handling of nested function types. You can work around the bug by wrapping the inner transform in `proto::call<>` as follows:\n
如果你的编译器是 Microsoft Visual C++，你会发现以上变换不能通过编译。该编译器对于嵌套函数类型的处理存在缺陷。
你可以象下面这样通过将内层的变换包装在 `proto::call<>` 中来绕过这一缺陷：

``
    FoldToList(
        proto::_left
      , proto::call<FoldToList(proto::_right, proto::_state)>
    )
``

`proto::call<>` turns a callable transform into a primitive transform, but more on that later.\n
`proto::call<>` 将一个可调用变换变为一个基本变换，稍后会更多用到。
]

Now that we have defined the `FoldToList` function object, we can use it to turn output expressions into lists as follows:\n
现在，我们已经定义了 `FoldToList` 函数对象，我们可以用它来把输出表达式转换为链表，如下：

    proto::terminal<std::ostream &>::type const cout_ = {std::cout};

    // This is the type of the list we build below
    // 这是我们后面要构建的链表的类型
    typedef
        fusion::cons<
            int
          , fusion::cons<
                double
              , fusion::cons<
                    char
                  , fusion::nil
                >
            >
        >
    result_type;

    // Fold an output expression into a Fusion list, using
    // fusion::nil as the initial state of the transformation.
    // 将一个输出表达式折叠至一个Fusion链表，以fusion::nil作为变换的初始状态。
    FoldToList to_list;
    result_type args = to_list(cout_ << 1 << 3.14 << '\n', fusion::nil());

    // Now "args" is the list: {1, 3.14, '\n'}
    // 现在"args"为链表：{1, 3.14, '\n'}

When writing transforms, "fold" is such a basic operation that Proto provides a number of built-in fold transforms. We'll get to them later. For now, rest assured that you won't always have to stretch your brain so far to do such basic things.\n
在编写变换时，"折叠"是一个非常基本的操作，所以Proto提供了一些内建的折叠变换。我们稍后将会提及它们。现在你可以放心了，
你不需要总是花费脑筋去做这些基本的东西。 

[endsect]

[/================================================]
[section:data Passing Auxiliary Data to Transforms 传递辅助数据给变换]
[/================================================]

In the last section, we saw that we can pass a second parameter to grammars with transforms: an accumulation variable or /state/ that gets updated as your transform executes. There are times when your transforms will need to access auxiliary data that does /not/ accumulate, so bundling it with the state parameter is impractical. Instead, you can pass auxiliary data as a third parameter, known as the /data/ parameter. Below we show an example involving string processing where the data parameter is essential.\n
在上一节，我们看到了，我们可以传递第二个参数给带有变换的语法：一个累计变量或/状态/，它会在你的变换执行中被更新。有时，
你的变换会需要访问一些/并非/累计的辅助数据，所以以 state 参数来绑定它是不合适的。这时，你可以将这些辅助数据作为第三个参数来传递，
即 /data/ 参数。下面我们将示范一个字符串处理的例子，其中将用到 data 参数。

[note All Proto grammars are function objects that take one, two or three arguments: the expression, the state, and the data. There are no additional arguments to know about, we promise. In Haskell, there is set of tree traversal technologies known collectively as _SYB_. In that framework, there are also three parameters: the term, the accumulator, and the context. These are Proto's expression, state and data parameters under different names.\n
所有Proto语法都是函数对象，它可能带一个、两个或三个参数：表达式、状态和数据。我们承诺，没有其它参数了。在Haskell中，
有成套的树遍历技术，它们被统称为 _SYB_。在那个框架中，也有三个参数：术语、累计器和上下文。
它们就是不同名字下的Proto表达式、状态和数据参数。]

Expression templates are often used as an optimization to eliminate temporary objects. Consider the problem of string concatenation: a series of concatenations would result in the needless creation of temporary strings. We can use Proto to make string concatenation very efficient. To make the problem more interesting, we can apply a locale-sensitive transformation to each character during the concatenation. The locale information will be passed as the data parameter.\n
表达式模板通常被用作一种优化手段，以消除临时对象。考虑一个字符串串接的问题：一系列的串接会导致不必要的临时字符串的创建。
我们可以用Proto来使得字符串串接更为高效。为了让这个问题更加有趣，我们可以在串接的过程中对每个字符施加一个locale敏感的变换。
locale信息将作为data参数传递。

Consider the following expression template:\n
考虑以下表达式模板：

    proto::lit("hello") + " " + "world";

We would like to concatenate this string into a statically allocated wide character buffer, widening each character in turn using the specified locale. The first step is to write a grammar that describes this expression, with transforms that calculate the total string length. Here it is:\n
我们希望将这个字符串串接到一个静态分配的宽字符缓冲区中，使用指定的locale对字符逐个扩宽。第一步是编写一个语法来描述该表达式，
并带有计算字符串总长度的变换。如下：

    // A grammar that matches string concatenation expressions, and
    // a transform that calculates the total string length.
    // 一个匹配字符串串接表达式的语法，以及一个计算字符串总长度的变换。
    struct StringLength
      : proto::or_<
            proto::when<
                // When you find a character array ... 当你找到一个字符串数组...
                proto::terminal<char[proto::N]>
                // ... the length is the size of the array minus 1. 数组长度减1。
              , mpl::prior<mpl::sizeof_<proto::_value> >()
            >
          , proto::when<
                // The length of a concatenated string is ... 串接的字符串长度为...
                proto::plus<StringLength, StringLength>
                // ... the sum of the lengths of each sub-string. 各个子串长度之和。
              , proto::fold<
                    _
                  , mpl::size_t<0>()
                  , mpl::plus<StringLength, proto::_state>()
                >
            >
        >
    {};

Notice the use of _fold_pt_. It is a primitive transform that takes a sequence, a state, and function, just like `std::accumulate()`. The three template parameters are transforms. The first yields the sequence of expressions over which to fold, the second yields the initial state of the fold, and the third is the function to apply at each iteration. The use of `proto::_` as the first parameter might have you confused. In addition to being Proto's wildcard, `proto::_` is also a primitive transform that returns the current expression, which (if it is a non-terminal) is a sequence of its child expressions.\n
注意其中对 _fold_pt_ 的使用。它是一个基本变换，接受一个序列、一个状态和一个函数，就象 `std::accumulate()` 那样。
这三个模板参数都是变换。第一个参数产生要进行折叠的表达式序列，第二个参数产生折叠的初始状态，第三个参数则是应用于每次迭代的函数。
以 `proto::_` 作为第一个参数可能会使你感到困惑。除了作为Proto的通配符以外，`proto::_` 还是一个返回当前表达式的基本变换，
即(如果它是一个非终结符)一个由各子表达式组成的序列。 

Next, we need a function object that accepts a narrow string, a wide character buffer, and a `std::ctype<>` facet for doing the locale-specific stuff. It's fairly straightforward.\n
接着，我们需要一个函数对象，它接受一个窄字符串、一个宽字符缓冲区和一个 `std::ctype<>` facet 来进行特定locale的填充。它非常简单。

    // A function object that writes a narrow string
    // into a wide buffer.
    // 一个函数对象，将一个窄字符串写入到宽字符缓冲区。
    struct WidenCopy : proto::callable
    {
        typedef wchar_t *result_type;

        wchar_t *
        operator()(char const *str, wchar_t *buf, std::ctype<char> const &ct) const
        {
            for(; *str; ++str, ++buf)
                *buf = ct.widen(*str);
            return buf;
        }
    };

Finally, we need some transforms that actually walk the concatenated string expression, widens the characters and writes them to a buffer. We will pass a `wchar_t*` as the state parameter and update it as we go. We'll also pass the `std::ctype<>` facet as the data parameter. It looks like this:\n
最后，我们需要一些变换来实际遍历要串接的字符串表达式，对字符进行扩宽，并将它们写入至缓冲区。我们将传入一个 `wchar_t*` 作为 state 参数，
并随着我们的进度更新它。我们还会传入 `std::ctype<>` facet 作为 data 参数。它看起来象这样：

    // Write concatenated strings into a buffer, widening
    // them as we go.
    // 将串接的字符串写入到缓冲区，并扩宽它们。
    struct StringCopy
      : proto::or_<
            proto::when<
                proto::terminal<char[proto::N]>
              , WidenCopy(proto::_value, proto::_state, proto::_data)
            >
          , proto::when<
                proto::plus<StringCopy, StringCopy>
              , StringCopy(
                    proto::_right
                  , StringCopy(proto::_left, proto::_state, proto::_data)
                  , proto::_data
                )
            >
        >
    {};

Let's look more closely at the transform associated with non-terminals:\n
我们来仔细地看一下与非终结符相关联的变换：

    StringCopy(
        proto::_right
      , StringCopy(proto::_left, proto::_state, proto::_data)
      , proto::_data
    )

This bears a resemblance to the transform in the previous section that folded an expression tree into a list. First we recurse on the left child, writing its strings into the `wchar_t*` passed in as the state parameter. That returns the new value of the `wchar_t*`, which is passed as state while transforming the right child. Both invocations receive the same `std::ctype<>`, which is passed in as the data parameter.\n
这与上一节中将表达式树折叠为链表的那个变换非常相似。首先我们对左子节点进行递归，将它的字符串写入到作为 state 参数传入的 `wchar_t*` 中。
返回的 `wchar_t*` 新值，在转换右子节点时作为 state 传入。两个调用均接受同一个 `std::ctype<>`，它被作为 data 参数传递。

With these pieces in our pocket, we can implement our concatenate-and-widen function as follows:\n
通过我们口袋中的这些零件，我们可以实现我们的串接并扩宽，如下：

    template<typename Expr>
    void widen( Expr const &expr )
    {
        // Make sure the expression conforms to our grammar 确保表达式符合我们的语法
        BOOST_MPL_ASSERT(( proto::matches<Expr, StringLength> ));

        // Calculate the length of the string and allocate a buffer statically
        // 计算字符串的总长度并静态分配一个缓冲区
        static std::size_t const length =
            boost::result_of<StringLength(Expr)>::type::value;
        wchar_t buffer[ length + 1 ] = {L'\0'};

        // Get the current ctype facet 取得当前的ctype facet
        std::locale loc;
        std::ctype<char> const &ct(std::use_facet<std::ctype<char> >(loc));

        // Concatenate and widen the string expression 串接并扩宽这个字符串表达式
        StringCopy()(expr, &buffer[0], ct);

        // Write out the buffer. 输出该缓冲区。
        std::wcout << buffer << std::endl;
    }

    int main()
    {
        widen( proto::lit("hello") + " " + "world" );
    }

The above code displays:\n
以上代码将显示：

[pre
hello world
]

This is a rather round-about way of demonstrating that you can pass extra data to a transform as a third parameter. There are no restrictions on what this parameter can be, and (unlike the state parameter) Proto will never mess with it.\n
这是一个相当绕的示范方式，示范了你可以将额外的数据作为第三个参数进行传递。对于该参数可以是什么，并没有限制，
而且(与 state 参数不同) Proto 绝对不会干预它。

[heading Implicit Parameters to Primitive Transforms 给基本变换的隐式参数]

Let's use the above example to illustrate some other niceties of Proto transforms. We've seen that grammars, when used as function objects, can accept up to 3 parameters, and that when using these grammars in callable transforms, you can also specify up to 3 parameters. Let's take another look at the transform associated with non-terminals above:\n
让我们以上述例子为例，说明一下Proto变换的其它一些细节。我们已经看到，语法被作为函数对象使用时，可以接受多达3个参数，而且，
把这些语法在可调用变换中使用时，你也可以指定最多3个参数。让我们再看看上述例子中与非终结符相关联的变换：

    StringCopy(
        proto::_right
      , StringCopy(proto::_left, proto::_state, proto::_data)
      , proto::_data
    )

Here we specify all three parameters to both invocations of the `StringCopy` grammar. But we don't have to specify all three. If we don't specify a third parameter, `proto::_data` is assumed. Likewise for the second parameter and `proto::_state`. So the above transform could have been written more simply as:\n
在此，我们对两次 `StringCopy` 语法的调用都指定了所有三个参数。但是其实我们并不需要指定全部三个参数。如果我们不指定第三个参数，
将会假定为 `proto::_data`。同样，第二个参数会假定为 `proto::_state`。所以，以上变换可以简化为：

    StringCopy(
        proto::_right
      , StringCopy(proto::_left)
    )

The same is true for any primitive transform. The following are all equivalent:\n
对于任意的基本变换，也是如此。以下写法都是等价的：

[table Implicit Parameters to Primitive Transforms 基本变换的隐式参数
  [[Equivalent Transforms 相互等价的变换]]
  [[`proto::when<_, StringCopy>`]]
  [[`proto::when<_, StringCopy()>`]]
  [[`proto::when<_, StringCopy(_)>`]]
  [[`proto::when<_, StringCopy(_, proto::_state)>`]]
  [[`proto::when<_, StringCopy(_, proto::_state, proto::_data)>`]]
]

[note *Grammars Are Primitive Transforms Are Function Objects 语法是基本变换，也是函数对象 *

So far, we've said that all Proto grammars are function objects. But it's more accurate to say that Proto grammars are primitive transforms -- a special kind of function object that takes between 1 and 3 arguments, and that Proto knows to treat specially when used in a callable transform, as in the table above.\n
到目前为止，我们曾经说过，所有Proto语法都是函数对象。但是更准确的说法是，Proto语法是基本变换 -- 一种特定类型的函数对象，
它接受1至3个参数，且Proto知道当语法被用在一个可调用变换中时，对其特殊看待，如上表所示。]

[note *Not All Function Objects Are Primitive Transforms 不是所有函数对象都是基本变换*

You might be tempted now to drop the `_state` and `_data` parameters to `WidenCopy(proto::_value, proto::_state, proto::_data)`. That would be an error. `WidenCopy` is just a plain function object, not a primitive transform, so you must specify all its arguments. We'll see later how to write your own primitive transforms.\n
也许现在你会想把 `_state` 和 `_data` 参数从 `WidenCopy(proto::_value, proto::_state, proto::_data)` 中去掉。这样做是错误的。
`WidenCopy` 只是一个普通的函数对象，而不是一个基本变换，所以你必须指定所有参数。稍后我们将看到如何编写你自己的基本变换。]

Once you know that primitive transforms will always receive all three parameters -- expression, state, and data -- it makes things possible that wouldn't be otherwise. For instance, consider that for binary expressions, these two transforms are equivalent. Can you see why?\n
一旦你知道了基本变换总是接受所有三个参数 -- 表达式、状态和数据 -- 这会让某些意外的事情成为可能。例如，对于二元表达式，
以下两个变换是等价的。你能看出为什么吗？

[table Two Equivalent Transforms 两个等价的变换
  [[Without [^proto::fold<>]][With [^proto::fold<>]]]
  [[``StringCopy(
    proto::_right
  , StringCopy(proto::_left, proto::_state, proto::_data)
  , proto::_data
)``
][``proto::fold<_, proto::_state, StringCopy>``]]
]

[endsect]

[/====================================================]
[section:canned_transforms Proto's Built-In Transforms  Proto的内建变换]
[/====================================================]

[def _N_ [~N]]
[def _G_ [~G]]
[def _G0_ [~G0]]
[def _G1_ [~G1]]
[def _CT_ [~CT]]
[def _OT_ [~OT]]
[def _ET_ [~ET]]
[def _ST_ [~ST]]
[def _FT_ [~FT]]

Primitive transforms are the building blocks for more interesting composite transforms. Proto defines a bunch of generally useful primitive transforms. They are summarized below.\n
基本变换是有趣的复杂变换的构建块。Proto定义了一组常用的基本变换。概述如下。

[variablelist
 [[_value_pt_]
      [Given a terminal expression, return the value of the terminal.\n
      给定一个终结符表达式，返回该终结符的值。]]
 [[_child_c_pt_]
      [Given a non-terminal expression, `proto::_child_c<_N_>` returns the _N_-th 
       child.\n
       给定一个非终结符表达式，`proto::_child_c< _N_ >` 返回第_N_个子节点。]]
 [[_child_pt_]
      [A synonym for `proto::_child_c<0>`.\n
      `proto::_child_c<0>` 的同义词。]]
 [[_left_pt_]
      [A synonym for `proto::_child_c<0>`.\n
      `proto::_child_c<0>` 的同义词。]]
 [[_right_pt_]
      [A synonym for `proto::_child_c<1>`.\n
      `proto::_child_c<1>` 的同义词。]]
 [[_expr_pt_]
      [Returns the current expression unmodified.\n
      原样返回当前表达式。]]
 [[_state_pt_]
      [Returns the current state unmodified.\n
      原样返回当前状态。]]
 [[_data_pt_]
      [Returns the current data unmodified.\n
      原样返回当前数据。]]
 [[_call_pt_]
      [For a given callable transform `_CT_`, `proto::call<_CT_>` turns the 
       callable transform into a primitive transform. This is useful for 
       disambiguating callable transforms from object transforms, and also for 
       working around compiler bugs with nested function types.\n
       对于给定的可调用变换 `_CT_`，`proto::call< _CT_ >` 将该可调用变换转为基本变换。
       这对于消除可调用变换与对象变换间的歧义非常有用，也可以绕过编译器中关于嵌套函数类型的缺陷。]]
 [[_make_pt_]
      [For a given object transform `_OT_`, `proto::make<_OT_>` turns the 
       object transform into a primitive transform. This is useful for 
       disambiguating object transforms from callable transforms, and also for 
       working around compiler bugs with nested function types.\n
       对于给定的对象变换 `_OT_`，`proto::make< _OT_ >` 将该对象变换转为基本变换。
       这对于消除对象变换与可调用变换间的歧义非常有用，也可以绕过编译器中关于嵌套函数类型的缺陷。]]
 [[_default_pt_]
      [Given a grammar _G_, `proto::_default<_G_>` evaluates the current node 
       according to the standard C++ meaning of the operation the node represents.
       For instance, if the current node is a binary plus node, the two children 
       will both be evaluated according to `_G_` and the results will be added and
       returned. The return type is deduced with the help of the Boost.Typeof 
       library.\n
       给定一个语法 _G_，`proto::_default< _G_ >` 根据该节点所代表的操作的标准C++意义对当前节点进行求值。
       例如，如果当前节点为二元加法节点，则根据 `_G_` 对两个子节点进行求值，然后将结果相加并返回。
       返回类型用 Boost.Typeof 库来帮助推导。]]
 [[_fold_pt_]
      [Given three transforms `_ET_`, `_ST_`, and `_FT_`, 
       `proto::fold<_ET_, _ST_, _FT_>` first evaluates `_ET_` to obtain a Fusion 
       sequence and `_ST_` to obtain an initial state for the fold, and then 
       evaluates `_FT_` for each element in the sequence to generate the next 
       state from the previous.\n
       给定三个变换 `_ET_`, `_ST_`, 和 `_FT_`, `proto::fold<_ET_, _ST_, _FT_>` 首先对 ET 求值得到一个Fusion序列，
       然后对 `_ST_` 求值得到一个用于折叠的初始状态，最后对 `_FT_` 求值，对于序列中的每个元素，
       由上一个状态生成下一个状态。]]
 [[_reverse_fold_pt_]
      [Like _fold_pt_, except the elements in the Fusion sequence are iterated in 
       reverse order.\n
       与 _fold_pt_ 类似，但是以相反顺序遍历Fusion序列中的元素。]]
 [[_fold_tree_pt_]
      [Like `proto::fold<_ET_, _ST_, _FT_>`, except that the result of the `_ET_` 
       transform is treated as an expression tree that is /flattened/ to generate 
       the sequence to be folded. Flattening an expression tree causes child nodes 
       with the same tag type as the parent to be put into sequence. For instance, 
       `a >> b >> c` would be flattened to the sequence \[`a`, `b`, `c`\], and this 
       is the sequence that would be folded.\n
       类似于 `proto::fold<_ET_, _ST_, _FT_>`，但是 `_ET_` 变换的结果被视为一棵表达式树，该树/被压平/后生成要折叠的序列。
       压平一棵表达式树将使得具有与父节点相同标签类型的子节点被放入序列中。例如，`a >> b >> c` 会被压平为序列 `[a, b, c]`，
       该序列将被折叠。]]
 [[_reverse_fold_tree_pt_]
      [Like _fold_tree_pt_, except that the flattened sequence is iterated in 
       reverse order.\n
       类似于 _fold_tree_pt_，不过是以相反顺序遍历压平的序列。]]
 [[_lazy_pt_]
      [A combination of _make_pt_ and _call_pt_ that is useful when the nature of 
       the transform depends on the expression, state and/or data parameters. 
       `proto::lazy<R(A0,A1...An)>` first evaluates `proto::make<R()>` to compute a 
       callable type `R2`. Then, it evaluates `proto::call<R2(A0,A1...An)>`.\n
       _make_pt_ 和 _call_pt_ 的组合，当变换的本性是依赖于表达式、状态和/或数据参数时使用。
       `proto::lazy<R(A0,A1...An)>` 首先对 `proto::make<R()>` 求值以计算一个可调用类型 `R2`。
       然后对 `proto::call<R2(A0,A1...An)>` 求值。]]
]

[/============================================]
[heading All Grammars Are Primitive Transforms 所有语法都是基本变换]
[/============================================]

In addition to the above primitive transforms, all of Proto's grammar elements are also primitive transforms. Their behaviors are described below.\n
除了以上的基本变换外，所有的Proto语法元素也都是基本变换。它们的行为描述如下。

[variablelist
 [[_wild_]
      [Return the current expression unmodified.\n
      原样返回当前表达式。]]
 [[_or_]
      [For the specified set of alternate sub-grammars, find the one that matches 
       the given expression and apply its associated transform.\n
       对于指定的候选子语法集，找出与给定表达式相匹配的候选项，并应用其相关联的变换。]]
 [[_and_]
      [For the given set of sub-grammars, apply all the associated transforms and
       return the result of the last.\n
       对于给定的子语法集，应用其相关联的变换并返回最后一个的结果。]]
 [[_not_]
      [Return the current expression unmodified.\n
      原样返回当前表达式。]]
 [[_if_]
      [Given three transforms, evaluate the first and treat the result as a 
       compile-time Boolean value. If it is true, evaluate the second transform. 
       Otherwise, evaluate the third.\n
       给定三个变换，对第一个进行求值，将结果视为一个编译期布尔值。如果该值为真，
       对第二个变换求值。否则对第三个变换求值。]]
 [[_switch_]
      [As with _or_, find the sub-grammar that matches the given expression and 
       apply its associated transform.\n
       类似于 _or_，找出与给定表达式相匹配的子语法，并应其相关联的变换。]]
 [[_terminal_]
      [Return the current terminal expression unmodified.\n
      原样返回当前的终结符表达式。]]
 [[_plus_, _nary_expr_, et. al.]
      [A Proto grammar that matches a non-terminal such as
       `proto::plus<_G0_, _G1_>`, when used as a primitive transform, creates a new 
       plus node where the left child is transformed according to `_G0_` and the 
       right child with `_G1_`.\n
       匹配一个形如 `proto::plus<_G0_, _G1_>` 的非终结符的Proto语法，当被用作为一个基本变换时，
       创建一个新的加法节点，其中左子节点依据 `_G0_` 进行变换，而右子节点依据 `_G1_` 进行变换。]]
]

[/=================================]
[heading The Pass-Through Transform 直通变换]
[/=================================]

Note the primitive transform associated with grammar elements such as _plus_ described above. They possess a so-called /pass-through/ transform. The pass-through transform accepts an expression of a certain tag type (say, `proto::tag::plus`) and creates a new expression of the same tag type, where each child expression is transformed according to the corresponding child grammar of the pass-through transform. So for instance this grammar ...\n
留意一下前面所介绍的与 _plus_ 这样的语法元素相对应原基本变换。它们持有一个所谓的/直通/变换。直通变换接受某个标签类型
(如 `proto::tag::plus`)的表达式，并创建一个相同标签类型的新表达式，其中的各个子表达式是由依照直通变换的相应子语法变换而来的。
例如以下语法 ... 

    proto::function< X, proto::vararg<Y> >

... matches function expressions where the first child matches the `X` grammar and the rest match the `Y` grammar. When used as a transform, the above grammar will create a new function expression where the first child is transformed according to `X` and the rest are transformed according to `Y`.\n
... 它匹配那些第一个子节点与 `X` 语法相匹配而其余部分与 `Y` 语法相匹配的函数表达式。当上述语法被用作一个变换时，
它将创建一个新的函数表达式，其第一个子节点是依照 `X` 变换而来的，剩余部分则依照 `Y` 变换而来。

The following class templates in Proto can be used as grammars with pass-through transforms:\n
Proto中的以下类模板可以用作带直通变换的语法：

[table Class Templates With Pass-Through Transforms 带直通变换的类模板
    [[Templates with Pass-Through Transforms 带直通变换的模板]]
    [[`proto::unary_plus<>`]]
    [[`proto::negate<>`]]
    [[`proto::dereference<>`]]
    [[`proto::complement<>`]]
    [[`proto::address_of<>`]]
    [[`proto::logical_not<>`]]
    [[`proto::pre_inc<>`]]
    [[`proto::pre_dec<>`]]
    [[`proto::post_inc<>`]]
    [[`proto::post_dec<>`]]
    [[`proto::shift_left<>`]]
    [[`proto::shift_right<>`]]
    [[`proto::multiplies<>`]]
    [[`proto::divides<>`]]
    [[`proto::modulus<>`]]
    [[`proto::plus<>`]]
    [[`proto::minus<>`]]
    [[`proto::less<>`]]
    [[`proto::greater<>`]]
    [[`proto::less_equal<>`]]
    [[`proto::greater_equal<>`]]
    [[`proto::equal_to<>`]]
    [[`proto::not_equal_to<>`]]
    [[`proto::logical_or<>`]]
    [[`proto::logical_and<>`]]
    [[`proto::bitwise_and<>`]]
    [[`proto::bitwise_or<>`]]
    [[`proto::bitwise_xor<>`]]
    [[`proto::comma<>`]]
    [[`proto::mem_ptr<>`]]
    [[`proto::assign<>`]]
    [[`proto::shift_left_assign<>`]]
    [[`proto::shift_right_assign<>`]]
    [[`proto::multiplies_assign<>`]]
    [[`proto::divides_assign<>`]]
    [[`proto::modulus_assign<>`]]
    [[`proto::plus_assign<>`]]
    [[`proto::minus_assign<>`]]
    [[`proto::bitwise_and_assign<>`]]
    [[`proto::bitwise_or_assign<>`]]
    [[`proto::bitwise_xor_assign<>`]]
    [[`proto::subscript<>`]]
    [[`proto::if_else_<>`]]
    [[`proto::function<>`]]
    [[`proto::unary_expr<>`]]
    [[`proto::binary_expr<>`]]
    [[`proto::nary_expr<>`]]
]

[/=====================================================]
[heading The Many Roles of Proto Operator Metafunctions  Proto操作符元函数的多重角色]
[/=====================================================]

We've seen templates such as _terminal_, _plus_ and _nary_expr_ fill many roles. They are metafunction that generate expression types. They are grammars that match expression types. And they are primitive transforms. The following code samples show examples of each.\n
我们已经看到，象 _terminal_, _plus_ 和 _nary_expr_ 这些模板充当了多重角色。它们是生成表达式类型的元函数。它们是匹配表达式类型的语法。
它们也是基本变换。以下代码展现了它们的各种例子。

[*As Metafunctions ... 作为元函数...]

    // proto::terminal<> and proto::plus<> are metafunctions
    // that generate expression types:
    // proto::terminal<>和proto::plus<>是生成表达式类型的元函数：
    typedef proto::terminal<int>::type int_;
    typedef proto::plus<int_, int_>::type plus_;

    int_ i = {42}, j = {24};
    plus_ p = {i, j};

[*As Grammars ... 作为语法...]

    // proto::terminal<> and proto::plus<> are grammars that
    // match expression types
    // proto::terminal<>和proto::plus<>是匹配表达式类型的语法
    struct Int : proto::terminal<int> {};
    struct Plus : proto::plus<Int, Int> {};

    BOOST_MPL_ASSERT(( proto::matches< int_, Int > ));
    BOOST_MPL_ASSERT(( proto::matches< plus_, Plus > ));

[*As Primitive Transforms ... 作为基本变换...]

    // A transform that removes all unary_plus nodes in an expression
    // 一个将表达式中的所有unary_plus节点移除的变换
    struct RemoveUnaryPlus
      : proto::or_<
            proto::when<
                proto::unary_plus<RemoveUnaryPlus>
              , RemoveUnaryPlus(proto::_child)
            >
            // Use proto::terminal<> and proto::nary_expr<>
            // both as grammars and as primitive transforms.
            // 把proto::terminal<>和proto::nary_expr<>同时用作语法和基本变换。
          , proto::terminal<_>
          , proto::nary_expr<_, proto::vararg<RemoveUnaryPlus> >
        >
    {};

    int main()
    {
        proto::literal<int> i(0);

        proto::display_expr( 
            +i - +(i - +i)
        );

        proto::display_expr( 
            RemoveUnaryPlus()( +i - +(i - +i) )
        );
    }

The above code displays the following, which shows that unary plus nodes have been stripped from the expression:\n
以上代码输出如下，可以看到单参数加法已经从表达式中去掉了： 

[pre
minus(
    unary_plus(
        terminal(0)
    )
  , unary_plus(
        minus(
            terminal(0)
          , unary_plus(
                terminal(0)
            )
        )
    )
)
minus(
    terminal(0)
  , minus(
        terminal(0)
      , terminal(0)
    )
)
]

[endsect]

[/======================================================]
[section:primitives Building Custom Primitive Transforms 构建定制的基本变换]
[/======================================================]

In previous sections, we've seen how to compose larger transforms out of smaller transforms using function types. The smaller transforms from which larger transforms are composed are /primitive transforms/, and Proto provides a bunch of common ones such as `_child0` and `_value`. In this section we'll see how to author your own primitive transforms.\n
在上一节中，我们看到了用函数类型从较小的变换组合出较大的变换。组成较大变换的较小变换是/基本变换/，Proto提供了一组常用的基本变换，
如 `_child0` 和 `_value`。在本节中，我们将看看如何创作你自己的基本变换。

[note There are a few reasons why you might want to write your own primitive transforms. For instance, your transform may be complicated, and composing it out of primitives becomes unwieldy. You might also need to work around compiler bugs on legacy compilers that make composing transforms using function types problematic. Finally, you might also decide to define your own primitive transforms to improve compile times. Since Proto can simply invoke a primitive transform directly without having to process arguments or differentiate callable transforms from object transforms, primitive transforms are more efficient.\n
为什么你可能会想编写自己的基本变换呢？这有几个原因。例如，你的变换可能很复杂，由基本变换组合出来会很笨重。
你也可能需要绕过一些旧编译器中的缺陷，如用函数类型来组合变换时存在问题。最后，你还可能决定定义你自己的基本变换来改进编译时间。
由于Proto可以直接调用一个基本变换，而无须处理参数或区分可调用变换与对象变换，所以基本变换会更为高效。]

Primitive transforms inherit from `proto::transform<>` and have a nested `impl<>` template that inherits from `proto::transform_impl<>`. For example, this is how Proto defines the `_child_c<_N_>` transform, which returns the _N_-th child of the current expression:\n
基本变换继承自 `proto::transform<>` 且带有一个嵌套的 `impl<>` 模板，该模板继承自 `proto::transform_impl<>`。例如，
以下是Proto定义 `_child_c<_N_>` 变换的方法，该变换返回当前表达式的第_N_个子节点。

    namespace boost { namespace proto
    {
        // A primitive transform that returns N-th child
        // of the current expression.
        // 返回当前表达式的第N个子节点的基本变换。
        template<int N>
        struct _child_c : transform<_child_c<N> >
        {
            template<typename Expr, typename State, typename Data>
            struct impl : transform_impl<Expr, State, Data>
            {
                typedef
                    typename result_of::child_c<Expr, N>::type
                result_type;

                result_type operator ()(
                    typename impl::expr_param expr
                  , typename impl::state_param state
                  , typename impl::data_param data
                ) const
                {
                    return proto::child_c<N>(expr);
                }
            };
        };

        // Note that _child_c<N> is callable, so that
        // it can be used in callable transforms, as:
        //   _child_c<0>(_child_c<1>)
        // 注意，_child_c<N>是可调用的，这样它就可以在可调用    
        // 变换中使用，如：_child_c<0>(_child_c<1>)
        template<int N>
        struct is_callable<_child_c<N> >
          : mpl::true_
        {};
    }}

The `proto::transform<>` base class provides the `operator()` overloads and the nested `result<>` template that make your transform a valid function object. These are implemented in terms of the nested `impl<>` template you define.\n
基类 `proto::transform<>` 提供了 `operator()` 重载和嵌套的 `result<>` 模板，使你的变换成为一个有效的函数对象。
它们是依据你定义的嵌套 `impl<>` 模板来实现的。

The `proto::transform_impl<>` base class is a convenience. It provides some nested typedefs that are generally useful. They are specified in the table below:\n
基类 `proto::transform_impl<>` 是一个便利的工具。它提供了一些常用的嵌套typedef。在下表中列出：

[table proto::transform_impl<Expr, State, Data> typedefs
[[typedef][Equivalent To 等价于]]
[[`expr`][`typename remove_reference<Expr>::type`]]
[[`state`][`typename remove_reference<State>::type`]]
[[`data`][`typename remove_reference<Data>::type`]]
[[`expr_param`][`typename add_reference<typename add_const<Expr>::type>::type`]]
[[`state_param`][`typename add_reference<typename add_const<State>::type>::type`]]
[[`data_param`][`typename add_reference<typename add_const<Data>::type>::type`]]
]

You'll notice that `_child_c::impl::operator()` takes arguments of types `expr_param`, `state_param`, and `data_param`. The typedefs make it easy to accept arguments by reference or const reference accordingly.\n
你应该会留意到 `_child_c::impl::operator()` 所接受的参数类型分别是 `expr_param`, `state_param`, 和 `data_param`。
这些 typedef 使得我们可以很容易地通过引用或常量引用来接受参数。

The only other interesting bit is the `is_callable<>` specialization, which will be described in the [link boost_proto.users_guide.back_end.expression_transformation.is_callable next section].\n
现在，有趣的部分只剩下 `is_callable<>` 的特化了，它将在
[link boost_proto.users_guide.back_end.expression_transformation.is_callable 下一节] 中介绍。 

[endsect]

[/=================================================]
[section:is_callable Making Your Transform Callable 让你的变换可调用]
[/=================================================]

Transforms are typically of the form `proto::when< Something, R(A0,A1,...) >`. The question is whether `R` represents a function to call or an object to construct, and the answer determines how _when_ evaluates the transform. _when_ uses the `proto::is_callable<>` trait to disambiguate between the two. Proto does its best to guess whether a type is callable or not, but it doesn't always get it right. It's best to know the rules Proto uses, so that you know when you need to be more explicit.\n
变换典型地具有形如 `proto::when< Something, R(A0,A1,...) >` 的格式。问题是，`R` 代表的是一个要调用的函数，抑或是一个要构造的对象，
其答案取决于 _when_ 如何对该变换进行求值。_when_ 使用 `proto::is_callable<>` trait 来区分这两者。
Proto尽最大努力去猜测一个类型是否可调用，但是它不会总是猜对的。最好还是知道一下Proto所使用的规则，这样你就知道何时需要做得更清楚些。

For most types `R`, `proto::is_callable<R>` checks for inheritance from `proto::callable`. However, if the type `R` is a template specialization, Proto assumes that it is /not/ callable ['even if the template inherits from `proto::callable`]. We'll see why in a minute. Consider the following erroneous callable object:\n
对于大多数类型 `R`, `proto::is_callable<R>` 检查它是否继承自 `proto::callable`。不过，如果类型 `R` 是一个模板特化，
Proto将会假定它/不是/可调用的，['即使该模板继承自 `proto::callable`]。等会我们将看到为什么会这样。考虑以下这个错误的可调用对象：

    // Proto can't tell this defines something callable!
    // Proto不能将这个定义认作为可调用的！
    template<typename T>
    struct times2 : proto::callable
    {
        typedef T result_type;

        T operator()(T i) const
        {
            return i * 2;
        }
    };

    // ERROR! This is not going to multiply the int by 2:
    // 错误！这不会把int乘以2：
    struct IntTimes2
      : proto::when<
            proto::terminal<int>
          , times2<int>(proto::_value)
        >
    {};

The problem is that Proto doesn't know that `times2<int>` is callable, so rather that invoking the `times2<int>` function object, Proto will try to construct a `times2<int>` object and initialize it will an `int`. That will not compile.\n
问题在于，Proto不知道 `times2<int>` 是可调用的，所以不会调用 `times2<int>` 函数对象，
Proto会尝试构造一个 `times2<int>` 对象并将它初始化为 `int`。这样将不能编译。

[note Why can't Proto tell that `times2<int>` is callable? After all, it inherits from `proto::callable`, and that is detectable, right? The problem is that merely asking whether some type `X<Y>` inherits from `callable` will cause the template `X<Y>` to be instantiated. That's a problem for a type like `std::vector<_value(_child1)>`. `std::vector<>` will not suffer to be instantiated with `_value(_child1)` as a template parameter. Since merely asking the question will sometimes result in a hard error, Proto can't ask; it has to assume that `X<Y>` represents an object to construct and not a function to call.\n
为什么Proto不能认为 `times2<int>` 是可调用的呢？毕竟，它是继承自 `proto::callable` 的，而且这是可以被检测到的，不是吗？问题是，
哪怕只是询问一下 type `X<Y>` 是否继承自 `callable`，也会引起模板 `X<Y>` 的实例化。这对于象 `std::vector<_value(_child1)>` 
这样的类型来说就是一个问题。`std::vector<>` 不能忍受以 `_value(_child1)` 作为模板参数进行实例化。因为仅仅是询问一下这个问题，
有时都会导致一个硬错误，所以Proto不能问；它必须假定 `X<Y>` 代表的是一个要构造的对象，而不是一个要调用的函数。]

There are a couple of solutions to the `times2<int>` problem. One solution is to wrap the transform in `proto::call<>`. This forces Proto to treat `times2<int>` as callable:\n
有几种方法来解决这个 `times2<int>` 的问题。一种方法是，把这个变换包装在 `proto::call<>` 中。
这将强迫Proto把 `times2<int>` 视为可调用的：

    // OK, calls times2<int> 好的，可以调用times2<int>
    struct IntTimes2
      : proto::when<
            proto::terminal<int>
          , proto::call<times2<int>(proto::_value)>
        >
    {};

This can be a bit of a pain, because we need to wrap every use of `times2<int>`, which can be tedious and error prone, and makes our grammar cluttered and harder to read.\n
这可能有一点麻烦，因为我们需要对 `times2<int>` 的每一次使用都进行包装，这是很乏味且易错的，也使得我们的语法显得混乱而更难阅读。

Another solution is to specialize `proto::is_callable<>` on our `times2<>` template:\n
另一个方法是，针对我们的 `times2<>` 模板特化 `proto::is_callable<>`：

    namespace boost { namespace proto
    {
        // Tell Proto that times2<> is callable 告诉Proto，times2<>是可调用的
        template<typename T>
        struct is_callable<times2<T> >
          : mpl::true_
        {};
    }}

    // OK, times2<> is callable  好的，times2<>是可调用的
    struct IntTimes2
      : proto::when<
            proto::terminal<int>
          , times2<int>(proto::_value)
        >
    {};

This is better, but still a pain because of the need to open Proto's namespace.\n
这个方法更好些，但还是有点麻烦，因为需要打开Proto的名字空间。

You could simply make sure that the callable type is not a template specialization. Consider the following:\n
你可以只需确保可调用类型不是一个模板特化。如下：

    // No longer a template specialization!  不再是一个模板特化！
    struct times2int : times2<int> {};

    // OK, times2int is callable  好的，times2int是可调用的
    struct IntTimes2
      : proto::when<
            proto::terminal<int>
          , times2int(proto::_value)
        >
    {};

This works because now Proto can tell that `times2int` inherits (indirectly) from `proto::callable`. Any non-template types can be safely checked for inheritance because, as they are not templates, there is no worry about instantiation errors.\n
这样可以用了，因为现在Proto可以认出 `times2int` (间接地)继承自 `proto::callable`。任何非模板类型都可以安全地检查继承关系，
因为它们不是模板，不需要担心实例化的错误。

There is one last way to tell Proto that `times2<>` is callable. You could add an extra dummy template parameter that defaults to `proto::callable`:\n
以下是最后一种告知Proto `times2<>` 可调用的方法。你可以增加一个额外的哑模板参数，该参数的缺省值为 `proto::callable`：

    // Proto will recognize this as callable  Proto将此模板识别为可调用的
    template<typename T, typename Callable = proto::callable>
    struct times2 : proto::callable
    {
        typedef T result_type;

        T operator()(T i) const
        {
            return i * 2;
        }
    };

    // OK, this works!  好的，可以工作！
    struct IntTimes2
      : proto::when<
            proto::terminal<int>
          , times2<int>(proto::_value)
        >
    {};

Note that in addition to the extra template parameter, `times2<>` still inherits from `proto::callable`. That's not necessary in this example but it is good style because any types derived from `times2<>` (as `times2int` defined above) will still be considered callable.\n
注意，增加了这个额外的模板参数后，`times2<>` 依然继承自 `proto::callable`。在这个例子中，这是不必要的，但这是一个好的习惯，
因为派生自 `times2<>` 的任意类型(如前面的 `times2int`)也还会被认为是可调用的。

[endsect]

[endsect]

[endsect]

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>Boost Function Object Adapter Library</title></head>
<body bgcolor="#ffffff" text="#000000">
  <table summary="" bgcolor="#007f7f" border="1" cellpadding="2">
    <tbody><tr>
      <td bgcolor="#ffffff"><img src="../../boost.png" alt="boost.png (6897 bytes)" height="86" width="277"></td>

      <td><a href="../../index.htm"><font color="#ffffff" face="Arial"><big>Home</big></font></a></td>

      <td><a href="../libraries.htm"><font color="#ffffff" face="Arial"><big>Libraries</big></font></a></td>

      <td><a href="http://www.boost.org/people/people.htm"><font color="#ffffff" face="Arial"><big>People</big></font></a></td>

      <td><a href="http://www.boost.org/more/faq.htm"><font color="#ffffff" face="Arial"><big>FAQ</big></font></a></td>

      <td><a href="../../more/index.htm"><font color="#ffffff" face="Arial"><big>More</big></font></a></td>
    </tr>
  </tbody></table>

  <h1>Function Object Traits 函数对象 Traits</h1>

  <p>The header <a href="../../boost/functional.hpp">functional.hpp</a>
  provides two traits class templates for functions and function objects:</p><p>头文件 <a href="../../boost/functional.hpp">functional.hpp</a> 为函数和函数对象提供了两个 traits 类模板：</p>

  <table summary="" border="1">
    <tbody><tr>
      <th>Type 类型</th>

      <th>Contents 内容</th>

      <th>Description 说明</th>
    </tr>

    <tr>
      <td rowspan="4" valign="top">
      <tt>template&nbsp;&lt;typename&nbsp;T&gt;<br>
      struct&nbsp;unary_traits</tt></td>

      <td valign="top"><tt>function_type</tt></td>

      <td valign="top">The type of the function or function object itself
      (i.e., <tt>T</tt>).<br>函数或函数对象本身的类型(即 <tt>T</tt>)。</td>
    </tr>

    <tr>
      <td valign="top"><tt>param_type</tt></td>

      <td valign="top">The type that should be used to pass the function or
      function object as a parameter.<br>将函数或函数对象作为参数传递时应使用的类型。</td>
    </tr>

    <tr>
      <td valign="top"><tt>result_type</tt></td>

      <td valign="top">The type returned by the function or function
      object.<br>函数或函数对象返回的类型。</td>
    </tr>

    <tr>
      <td valign="top"><tt>argument_type</tt></td>

      <td valign="top">The type of the argument to the function or function
      object.<br>函数或函数对象的参数的类型。</td>
    </tr>

    <tr>
      <td rowspan="5" valign="top">
      <tt>template&nbsp;&lt;typename&nbsp;T&gt;<br>
      struct&nbsp;binary_traits</tt></td>

      <td valign="top"><tt>function_type</tt></td>

      <td valign="top">The type of the function or function object itself
      (i.e., <tt>T</tt>).<br>函数或函数对象本身的类型(即 <tt>T</tt>)。</td>
    </tr>

    <tr>
      <td valign="top"><tt>param_type</tt></td>

      <td valign="top">The type that should be used to pass the function or
      function object as a parameter.<br>将函数或函数对象作为参数传递时应使用的类型。</td>
    </tr>

    <tr>
      <td valign="top"><tt>result_type</tt></td>

      <td valign="top">The type returned by the function or function
      object.<br>函数或函数对象返回的类型。</td>
    </tr>

    <tr>
      <td valign="top"><tt>first_argument_type</tt></td>

      <td valign="top">The type of the first argument to the function or
      function object.<br>函数或函数对象的第一个参数的类型。</td>
    </tr>

    <tr>
      <td valign="top"><tt>second_argument_type</tt></td>

      <td valign="top">The type of the second argument to the function or
      function object.<br>函数或函数对象的第二个参数的类型。</td>
    </tr>
  </tbody></table>

  <h3>Usage 用法</h3>

  <p><tt>unary_traits</tt> should be instantiated with either a function
  taking a single parameter, or an adaptable unary function object (i.e., a
  class derived from <tt>std::unary_function</tt> or one which provides the
  same typedefs). (See §20.3.1 in the C++ Standard.)</p>

  <p><tt>unary_traits</tt> 应该用一个带单个参数的函数，或者用一个可适配的单参函数对象(即一个派生自 <tt>std::unary_function</tt> 的类或者一个提供相同 typedefs 的类)来实例化。(请见C++标准 §20.3.1)</p>

  <p><tt>binary_traits</tt> should be instantiated with either a function
  taking two parameters, or an adaptable binary function object (i.e., a
  class derived from <tt>std::binary_function</tt> or one which provides the
  same typedefs). (See §20.3.1 in the C++ Standard.)</p>

  <p><tt>binary_traits</tt> 应该用一个带两个参数的函数，或者用一个可适配的两元函数对象(即一个派生自 <tt>std::binary_function</tt> 的类或者一个提供相同 typedefs 的类)来实例化。(请见C++标准 §20.3.1)</p>

  <p>The most common usage of these templates is in function object adapters,
  thus allowing them to adapt plain functions as well as function objects.
  You can do this by wherever you would normally write, for example,</p>

  
    <p><span style="font-family: monospace;">这些模板最常见的用法是用在函数对象适配器中，以使得适配器可以象适配函数对象一样适配普通函数。</span>你可以象平时所写的那样使用它，例如：</p>

  <blockquote>
    <pre>typename Operation::argument_type<br></pre>
  </blockquote>

  <p>simply writing</p><p>只要写为：</p>

  <blockquote>
    <pre>typename boost::unary_traits&lt;Operation&gt;::argument_type<br></pre>
  </blockquote>

  <p>instead.</p>

  <h3>Additional Types Defined 其它已定义的类型</h3>

  <p>In addition to the standard result and argument typedefs, these traits
  templates define two additional types.</p><p>除了标准的结果和参数 typedefs, 这两个 traits
  模板还定义了另外两个类型。</p>

  <h4><tt>function_type</tt></h4>

  <p>This is the type of the function or function object, and can be used in
  declarations such as</p><p>这是函数或函数对象本身的类型，可以象下面这样用在声明中：</p>

  <blockquote>
    <pre>template &lt;class Predicate&gt;<br>class unary_negate : // ...<br>{<br>  // ...<br>  private:<br>    <strong>typename unary_traits&lt;Predicate&gt;::function_type</strong> pred;<br>};<br></pre>
  </blockquote>

  <p>If this typedef were not provided, it would not be possible to declare
  <tt>pred</tt> in a way that would allow <tt>unary_negate</tt> to be
  instantiated with a function type (see the C++ Standard §14.3.1
  ¶3).</p>

  <p>如果不提供这个 typedef, 那么当允许以函数类型对 <tt>unary_negate</tt> 进行实例化时就没有办法声明
  <tt>pred</tt> 了(参见C++标准 §14.3.1
  ¶3)。</p>

  <h4><tt>param_type</tt></h4>

  <p>This is a type suitable for passing the function or function object as a
  parameter to another function. For example,</p><p>这是将函数或函数对象作为参数传递给其它函数时适合使用的类型。例如：</p>

  <blockquote>
    <pre>template &lt;class Predicate&gt;<br>class unary_negate : // ...<br>{<br>  public:<br>    explicit unary_negate(<strong>typename unary_traits&lt;Predicate&gt;::param_type</strong> x)<br>        :<br>        pred(x)<br>    {}<br>    // ...<br>};<br></pre>
  </blockquote>

  <p>Function objects are passed by reference to const; function pointers are
  passed by value.</p><p>函数对象以常量引用的方式传递；函数指针则以值的方式传递。</p>

  <h3>Limitations 局限</h3>

  <p>This library uses these traits within all function object adapters,
  theoretically rendering <tt>ptr_fun</tt> obsolete. However, third party
  adapters probably won't take advantage of this mechanism, and so
  <tt>ptr_fun</tt> may still be required. Accordingly, this library also
  provides <a href="ptr_fun.html">improved versions of the standard function
  pointer adapters</a>.</p>

  <p>本库在所有函数对象适配器中都使用了这些 traits, 理论上可以不再需要 <tt>ptr_fun</tt>。但是，第三方的适配器可能还不会利用这一机制，所以可能还是需要
  <tt>ptr_fun</tt>。因此，本库也提供了 <a href="ptr_fun.html">标准函数指针适配器的改良版本</a>。</p>

  <p>These traits templates will also not work with compilers that fail to
  support partial specialisation of templates. With these compilers, the
  traits templates can only be instantiated with adaptable function objects,
  thus requiring <tt>ptr_fun</tt> to be used, even with the function object
  adapters in this library.</p><p>这些 traits 模板不能在不支持模板偏特化的编译器上使用。对于这些编译器，以上 traits 模板只能以可适配函数对象来进行实例化，因此虽然有了本库中的函数对象适配器，还是需要使用 <tt>ptr_fun</tt>。</p>
  <hr>

  <p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Transitional" border="0" height="31" width="88"></a></p>

  <p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->02
  December, 2006<!--webbot bot="Timestamp" endspan i-checksum="38510" --></p>

  <p><i>Copyright © 2000 Cadenza New Zealand Ltd.</i></p>

  <p><i>Distributed under the Boost Software License, Version 1.0. (See
  accompanying file <a href="../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
  copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>
</body></html>
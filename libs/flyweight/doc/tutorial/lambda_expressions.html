<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>Boost.Flyweight Documentation - Tutorial - Annex - MPL
lambda expressions</title>


  <link rel="stylesheet" href="../style.css" type="text/css">

  <link rel="start" href="../index.html">

  <link rel="prev" href="technical.html">

  <link rel="up" href="index.html">

  <link rel="next" href="../reference/index.html">

</head>


<body>

<h1><img src="../../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Tutorial Annex: MPL lambda expressions</h1>

<div class="prev_link"><a href="technical.html"><img src="../prev.gif" alt="technical issues" border="0"><br>

Technical issues
</a></div>

<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>

Boost.Flyweight tutorial
</a></div>

<div class="next_link"><a href="../reference/index.html"><img src="../next.gif" alt="Boost.Flyweight reference" border="0"><br>

Boost.Flyweight reference
</a></div>

<br style="" clear="all">

<hr>
<p>This short introduction to lambda expressions is meant for
readers unfamiliar
with the <a href="../../../mpl/doc/index.html">Boost MPL
Library</a> who
want to rapidly acquire a working knowledge of the basic concepts for
the purposes
of using them in Boost.Flyweight. Please refer to the Boost.MPL
documentation
for further information beyond these introductory notes.</p>

<p>&#36825;&#20010;&#20851;&#20110;lambda&#34920;&#36798;&#24335;&#30340;&#31616;&#30701;&#30340;&#20171;&#32461;&#26159;&#20026;&#37027;&#20123;&#19981;&#29087;&#24713;<a href="../../../mpl/doc/index.html">Boost MPL&#24211;</a>&#20294;&#26159;&#24819;&#35201;&#24555;&#36895;
&#25484;&#25569;&#22522;&#26412;&#27010;&#24565;&#30340;&#21487;&#25805;&#20316;&#30693;&#35782;&#20197;&#20415;&#20110;&#22312;Boost.Flyweight&#37324;&#20351;&#29992;&#23427;&#20204;&#30340;&#35835;&#32773;&#20934;&#22791;&#30340;&#12290;<span class="wbtr_mn">&#36229;
&#20986;&#36825;&#20123;&#20171;&#32461;&#24615;&#35828;&#26126;&#20043;&#22806;&#26356;</span>&#36827;&#19968;&#27493;&#30340;&#20449;&#24687;&#35831;&#21442;&#32771;Boost.MPL&#30340;&#25991;&#26723;
</p>

<p>
The specifiers defined by Boost.Flyweight rely heavily on the
<a href="../../../mpl/doc/refmanual/lambda-expression.html"><code>Lambda
Expression</code></a> concept defined by the <a href="../../../mpl/doc/index.html">Boost MPL Library</a>.
A lambda
expression can be thought of as a compile-time "type function", an
entity (a
concrete type, actually) that can be invoked with a list of types and
returns
some associated type in its turn. Consider for instance an arbitrary
class
template:</p>

<p>Boost.Flyweight&#23450;&#20041;&#30340;&#25551;&#36848;&#31526;&#38750;&#24120;&#20381;&#36182;&#20110;<a href="../../../mpl/doc/index.html">Boost MPL &#24211;</a>&#23450;&#20041;&#30340;<a href="../../../mpl/doc/refmanual/lambda-expression.html"><code>Lambda&nbsp;</code>&#34920;
&#36798;&#24335;<code></code></a>&#36825;&#20010;&#27010;&#24565;&#12290;&#19968;&#20010;lambda&#34920;&#36798;&#24335;&#21487;&#20197;&#34987;&#35748;&#20026;&#26159;&#19968;&#20010;&#32534;&#35793;&#26102;&#30340;&amp;
amp;
ldquo;&#31867;&#22411;&#20989;&#25968;&rdquo;&#65292;&#25110;&#32773;&#26159;&#19968;&#20010;&#29992;&#19968;&#20018;&#31867;&#22411;&#35843;&#29992;&#21518;&#21453;&#36807;&#26469;&#36820;&#22238;&#26576;&#20010;&#30456;&#20851;&#31867;&#22411;&#30340;&#23454;&#20307;&#65288;&#23454;&#38469;&#19978;&#26159;&#19968;&#20010;&#20855;&#20307;&#31867;&#22411;&#65289;&#12290;&#20363;&#22914;&#32771;&#34385;&#20219;&#24847;&#30340;&#19968;&#20010;&#31867;
&#27169;&#26495;&#65306;
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Q</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">foo</span><br><span class="special">{</span><br><span class="special">...</span><br><span class="special">};</span></pre>

</blockquote>

<p>
and suppose we want to have a lambda expression that, when invoked
with some generic types <code>Arg1</code> and <code>Arg2</code>,
returns <code>foo&lt;Arg1,Arg2&gt;</code>. Such a
lambda expression
can be implemented in two ways</p>

<p>&#28982;&#21518;&#20551;&#35774;&#25105;&#20204;&#24819;&#35201;&#36825;&#26679;&#19968;&#20010;lambda&#34920;&#36798;&#24335;&#65306;&#24403;&#29992;&#19968;&#20123;&#27867;&#22411;&#31867;&#22411;<code>Arg1</code>&#21644;<code>Arg2</code>&#26469;
&#35843;&#29992;&#23427;&#26102;&#65292;&#36820;&#22238;<code>foo&lt;Arg1,Arg2&gt;</code>&#12290;&#36825;&#26679;&#19968;&#20010;lambda&#34920;
&#36798;&#24335;&#21487;&#20197;&#29992;&#20004;&#31181;&#26041;&#24335;&#26469;&#23454;&#29616;
</p>

<ol>

  <li>As a <a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL
Metafunction Class</code></a>, a type with a special nested
class template named <code>apply</code>:
    <p>&#20316;&#20026;&#19968;&#20010;<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL</code>&#20803;
&#20989;&#25968;&#31867;<code></code></a>&#65292;&#23427;&#26159;&#20869;&#23884;&#20102;&#19968;&#20010;&#29305;&#27530;&#30340;&#21517;&#20026;<code>apply</code>&#30340;
&#31867;
&#27169;&#26495;&#30340;&#31867;&#22411;&#65306;</p>

    <blockquote>
      <pre><span class="keyword">struct</span> <span class="identifier">foo_specifier</span><br><span class="special">{</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Arg2</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">apply</span><br><span class="special">{</span><br><span class="comment">// this is the "return type" of foo_specifier</span><br><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">Arg1</span><span class="special">,</span><span class="identifier">Arg2</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">};</span><br><span class="special">};</span></pre>

    </blockquote>

  </li>

  <li> As a <a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
Placeholder Expression</code></a>, a class template
instantiated with one or more <i>placeholders</i>:
    <p>&#20316;&#20026;&#19968;&#20010;<a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL</code>&#21344;&#20301;&#31526;&#34920;&#36798;&#24335;<code></code></a>&#65292;&#23427;&#26159;&#29992;&#19968;&#20010;&#25110;&#22810;&#20010;<span style="font-style: italic;">&#21344;&#20301;&#31526;</span>&#23454;&#20363;&#21270;&#30340;&#31867;&#27169;&#26495;&#12290;</p>

    <blockquote>
      <pre><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">&gt;</span> <span class="identifier">foo_specifier</span><span class="special">;</span></pre>

    </blockquote>

Note that, in this case, <code>foo_specifier</code> is a
concrete type, much as <code>int</code> or <code>std::set&lt;std::string&gt;</code>
are; yet, MPL internal mechanisms are able to detect that this type has
been gotten from instantiating a class template with placeholders <code>boost::mpl::_1</code>
and <code>boost::mpl::_2</code> and take these
placeholders as slots to be substituted for actual types (the first and
second type supplied, respectively) when <code>foo_specifier</code>
is invoked. So, an instantiation of <code>foo</code> can
be used to refer back to the <code>foo</code> class
template itself! The net effect is the same as with metafunctions, but
placeholder expressions spare us the need to write boilerplate
metafunction classes --and the kind of metaprogramming magic they
depend on has an undeniable beauty to it.</li>

</ol>

<div style="margin-left: 40px;">&#27880;&#24847;&#65292;&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;<code>foo_specifier</code>&#26159;
&#19968;&#20010;&#20855;&#20307;&#31867;&#22411;&#65292;&#23601;&#20687;<code>int</code>&#25110;&#32773;<code>std::set&lt;std::string&gt;</code>&#23427;
&#20204;&#37027;&#26679;&#65307;&#28982;&#32780;&#65292;MPL&#20869;&#37096;&#26426;&#21046;&#33021;&#20390;&#27979;&#21040;&#36825;&#20010;&#31867;&#22411;&#26159;&#36890;&#36807;&#29992;&#21344;&#20301;&#31526;<code>boost::mpl::_1</code>&#21644;&nbsp;
&nbsp;&nbsp;&nbsp;<code>boost::mpl::_2</code>&#23454;
&#20363;&#21270;&#19968;&#20010;&#31867;&#27169;&#26495;&#32780;&#26469;&#65292;<code></code>&#24403;<code>foo_specifier</code>&#24403;
&#34987;&#35843;&#29992;&#26102;&#65292;&#36825;&#20123;&#21344;&#20301;&#31526;&#23601;&#20687;&#25554;&#27133;&#19968;&#26679;&#34987;&#23454;&#38469;&#31867;&#22411;&#65288;&#20998;&#21035;&#26159;&#25552;&#20379;&#30340;&#31532;&#19968;&#20010;&#21644;&#31532;&#20108;&#20010;&#31867;&#22411;&#65289;&#26367;&#25442;&#25481;&#20102;&#12290;&#22240;&#27492;&#65292;&#19968;&#20010;<code>foo</code>
&#30340;&#23454;&#20363;&#21487;&#20197;&#29992;&#26469;&#24341;&#29992;&#22238;<code>foo</code>&#31867;&#27169;&#26495;&#33258;&#36523;&#65281;&#23454;&#38469;&#25928;&#26524;&#21644;&#20803;&#20989;&#25968;&#26159;&#30456;&#21516;&#30340;&#65292;&#20294;&#26159;&#21344;&#20301;&#31526;&#34920;&#36798;&#24335;&#25226;&#25105;&#20204;&#20174;&#32534;&#20889;<span class="mn">&#19968;&#25104;&#19981;&#21464;&#30340;</span>&#20803;&#20989;&#25968;&#31867;&#20013;&#35299;&#25918;&#20986;&#26469;&mdash;&mdash;&#32780;
&#19988;&#23427;&#20204;&#25152;&#22522;&#20110;&#30340;&#36825;&#31181;&#20803;&#32534;&#31243;&#30340;&#39764;&#21147;&#26377;&#19968;&#31181;<span class="mn">&#26080;&#21487;&#21542;&#35748;&#30340;</span>&#32654;&#24863;&#12290;<br>

<br>

</div>

So far the examples shown just forward the arguments <code>Arg1</code>
and
<code>Arg2</code> directly to a class template without
further elaboration,
but there is nothing preventing us from doing some argument
manipulation,
like, for instance, switching their places:<br>

<br>

&#21040;&#30446;&#21069;&#20026;&#27490;&#23637;&#31034;&#30340;&#20363;&#23376;&#21482;&#26159;&#19981;&#20570;&#20219;&#20309;&#21152;&#24037;&#30452;&#25509;&#23558;&#21442;&#25968;<code>Arg1</code>&#21644;<code>Arg2</code>&#20256;
&#36882;&#21040;&#31867;&#27169;&#26495;&#65292;&#20294;&#26159;&#27809;&#26377;&#20160;&#20040;&#38459;&#27490;&#25105;&#20204;&#36827;&#34892;&#19968;&#20123;&#21442;&#25968;&#22788;&#29702;&#65292;&#27604;&#22914;&#35828;&#65292;&#20132;&#25442;&#23427;&#20204;&#30340;&#20301;&#32622;&#65306;
<blockquote>
  <pre><span class="keyword">struct</span> <span class="identifier">foo_specifier</span><br><span class="special">{</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Arg2</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">apply</span><span class="special">{</span><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">Arg2</span><span class="special">,</span><span class="identifier">Arg1</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;};</span><br><span class="special">};</span><br><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span> <span class="identifier">foo_specifier</span><span class="special">;</span></pre>

</blockquote>

<p>
passing placeholder subexpressions as arguments to the overall
expression:</p>

<p>&#20256;&#36882;&#21344;&#20301;&#31526;&#23376;&#34920;&#36798;&#24335;&#20316;&#20026;&#25972;&#20010;&#34920;&#36798;&#24335;&#30340;&#21442;&#25968;&#65306;
</p>

<blockquote>
  <pre><span class="keyword">struct</span> <span class="identifier">foo_specifier</span><br><span class="special">{</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Arg2</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">apply</span><span class="special">{</span><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">Arg1</span><span class="special">&gt;,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">Arg2</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;};</span><br><span class="special">};</span><br><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">foo_specifier</span><span class="special">;</span></pre>

</blockquote>

<p>
or accepting less or more arguments than the class template itself
(the number of parameters of a lambda expression is called its <i>arity</i>):</p>

<p>&#25110;&#32773;&#25509;&#21463;&#23569;&#20110;&#25110;&#32773;&#22810;&#20313;&#31867;&#27169;&#26495;&#26412;&#36523;&#30340;&#21442;&#25968;&#65288;lambda&#34920;&#36798;&#24335;&#30340;&#21442;&#25968;&#20010;&#25968;&#21483;&#20570;&#23427;&#30340;<i>arity</i>&#65289;&#65306;
</p>

<blockquote>
  <pre><span class="keyword">struct</span> <span class="identifier">foo_specifier</span><br><span class="special">{</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg1</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">apply</span><span class="special">{</span><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">Arg1</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">Arg1</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;};</span><br><span class="special">};</span><br><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">foo_specifier</span><span class="special">;</span><br><span class="keyword">struct</span> <span class="identifier">foo_specifier</span><br><span class="special">{</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Arg2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Arg3</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">apply</span><span class="special">{</span><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">Arg1</span><span class="special">,</span><span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">Arg2</span><span class="special">,</span><span class="identifier">Arg3</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;};</span><br><span class="special">};</span><br><span class="keyword">typedef</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_3</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">foo_specifier</span><span class="special">;</span></pre>

</blockquote>

<hr>
<div class="prev_link"><a href="technical.html"><img src="../prev.gif" alt="technical issues" border="0"><br>

Technical issues
</a></div>

<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>

Boost.Flyweight tutorial
</a></div>

<div class="next_link"><a href="../reference/index.html"><img src="../next.gif" alt="Boost.Flyweight reference" border="0"><br>

Boost.Flyweight reference
</a></div>

<br style="" clear="all">

<br>

<p>Revised August 13th 2008</p>

<p>&copy; Copyright 2006-2008 Joaqu&iacute;n M
L&oacute;pez Mu&ntilde;oz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>

</body>
</html>

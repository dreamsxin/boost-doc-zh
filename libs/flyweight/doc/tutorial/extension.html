<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>


  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  


  
  <title>Boost.Flyweight Documentation - Tutorial - Extending Boost.Flyweight</title>
  <link rel="stylesheet" href="../style.css" type="text/css">


  
  <link rel="start" href="../index.html">


  
  <link rel="prev" href="configuration.html">


  
  <link rel="up" href="index.html">


  
  <link rel="next" href="technical.html">
</head>

<body>


<h1><img src="../../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Tutorial: Extending Boost.Flyweight</h1>


<div class="prev_link"><a href="configuration.html"><img src="../prev.gif" alt="configuring Boost.Flyweight" border="0"><br>


Configuring Boost.Flyweight
</a></div>


<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>


Boost.Flyweight tutorial
</a></div>


<div class="next_link"><a href="technical.html"><img src="../next.gif" alt="technical issues" border="0"><br>


Technical issues
</a></div>


<br style="" clear="all">


<hr>
<h2>Contents &nbsp;目录</h2>


<ul>


  <li><a href="#intro">Introduction &nbsp;简介</a></li>


  <li><a href="#factories">Custom factories
&nbsp;定制工厂</a></li>


  <li><a href="#holders">Custom holders
&nbsp;定制holders</a></li>


  <li><a href="#locking">Custom locking policies
&nbsp;定制锁定策略</a></li>


  <li><a href="#tracking">Custom tracking policies
&nbsp;定制跟踪策略</a></li>


</ul>


<h2><a name="intro">Introduction &nbsp;简介</a></h2>


<p>
Boost.Flyweight provides public interface specifications of
its <a href="configuration.html">configurable aspects</a>
so that the user
can extend the library by implementing her own components and providing
them to
instantiations of the <code>flyweight</code> class
template.</p>


<p>
Boost.Flyweight<span class="mn">规定</span>了它的<a href="configuration.html">可配置界面</a>的公共接
口标准，于是用户可以实现她们自己的组件，然后把它们提供给<big><code>flyweight</code></big>类
模板的实例来扩展这个库。
</p>


<p>
In most cases there are two types of entities involved in extending a
given
aspect of Boost.Flyweight:</p>


<p>在绝大多数情况下扩展Boost.Flyweight的某一界面时涉及到2种类型的实体
</p>


<ul>


  <li>The component itself (for instance, a factory class
template).</li>


</ul>


<div style="margin-left: 40px;">组件本身（例如，一个工厂类模板）</div>


<ul>


  <li>The associated <i>component specifier</i>,
which is the type provided as a template argument of a <code>flyweight</code>
instantiation.</li>


</ul>


<div style="margin-left: 40px;">相关的<span style="font-style: italic;">组件描述符</span>，它是<big><span style="font-family: monospace;"></span></big>提供给<big><code>flyweight</code></big>实
例的模板参数类型<br>


<br>


</div>


For example, the type
<a href="configuration.html#static_holder"><code>static_holder</code></a>
is a holder specifier which is used by <code>flyweight</code>
to generate
actual holder classes, in this case instantiations of the class
template <a href="../reference/holders.html#static_holder_class"><code>static_holder_class</code></a>.
Note that <code>static_holder</code> is a concrete type
while
<code>static_holder_class</code> is a class template, so a
specifier can be
seen as a convenient way to provide access to a family of related
concrete
components (the different possible instantiations of the class
template):
<code>flyweight</code> internally selects the particular
component
appropriate for its internal needs.<br>


<br>


例如，<big><a href="configuration.html#static_holder"><code>static_holder</code></a></big>类
型是一个描述符，<big><code>flyweight</code></big>用它来生成实际
的holder类，这种情况下是<big><a href="../reference/holders.html#static_holder_class"><code>static_holder_class</code></a></big>类
模板的实例。注意<big><code>static_holder</code></big>是一个
具体类型而<big><code>static_holder_class</code></big>是
一个模板类，于是一个描述符可以被看作是一种访问一族相关具体组件（可能的类模板的不同实例）的简便办法：<big><code>flyweight</code></big>在
内部选择适合它内部需要的特定的组件。
<h2><a name="factories">Custom factories
&nbsp;定制工厂</a></h2>


<p>
In a way, factories resemble unique associative containers like <code>std::set</code>,
though their expected interface is much more concise:</p>


<p><span class="mn">在某种程度上，工厂类似于唯一关联容器比如</span><big><code>std::set</code></big><span class="mn">，然而它们要求的接口要简洁的多：</span>
</p>


<blockquote>
  
  <pre><span class="comment">// example of a possible factory class template</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">custom_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <span class="special">...</span> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier"> insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span> </pre>


</blockquote>


<p>
Factories are parameterized by <code>Entry</code> and <code>Key</code>:
the first is the type of the objects stored, while the second is the
public
key type on which <code>flyweight</code> operates (e.g.
the <code>std::string</code>
in <code>flyweight&lt;std::string&gt;</code> or
<code>flyweight&lt;key_value&lt;std::string,texture&gt;
&gt;</code>). An entry holds a
shared value to which flyweight objects are associated as well as
internal bookkeeping information, but from the
point of view of the factory, though, the only fact known about <code>Entry</code>
is that it is implicitly convertible to <code>const Key&amp;</code>,
and it is
based on their associated <code>Key</code> that entries
are to be considered
equivalent or not. The factory <code>insert()</code>
member function locates a previously stored entry whose
associated <code>Key</code> is equivalent to that of the <code>Entry</code>
object being passed (for some equivalence relation on <code>Key</code>
germane to
the factory), or stores the new entry if no equivalent one is found. A
<code>handle_type</code> to the equivalent or newly
inserted entry is returned;
this <code>handle_type</code> is a token for further
access to an entry via
<code>erase()</code> and <code>entry()</code>.
Consult the
<a href="../reference/factories.html#factory">reference</a>
for the formal
definition of the <code>Factory</code> concept.</p>


<p>工厂通过<big><code>Entry</code></big>和<big><code>Key</code></big>来
参数化：<big><code>Entry</code></big>是工厂存储的对象的类型，<big><code>Key</code></big>是<big><code>flyweight</code></big>操
作的公开的键类型（<span class="mn">例如，</span><big><code>flyweight&lt;std::string&gt;</code></big><span class="mn">或者</span><big><code>flyweight&lt;key_value&lt;std::string,texture&gt;
&gt;</code></big><span class="mn">里</span>的<big><code>std::string</code></big>）。
一个entry包含一个flyweight对象关联到的共享的值还有一些内部<span class="mn">簿记信息，然
而，从工厂的角度来看，它所知道的关于</span><big><code>Entry</code></big><span class="mn">的</span><span class="mn">唯一</span><span class="mn">事实是它可以隐式的转换到</span><code><big>const
Key&amp;</big>，</code>然后entries<span class="mn">的
相等与否是基于它
们相关的</span><big><code>Key</code></big><span class="mn">来
判断的。工厂的</span><big><code>insert()</code></big><span class="mn">成
员函数定位到一个之前存储过的</span>entry，如果<span class="mn">与它相关的</span><big><code>Key</code></big><span class="mn">等于作为参数传递的</span><big><code>Entry</code></big><span class="mn">的</span><code><big>Key</big></code>（基
于与工厂密切相关的作用在<big><code>Key</code></big>上的某种相等关系<span class="mn"></span>）<code>，</code><span class="mn">或者在没有找到相等的</span><big><code>Key</code></big><span class="mn">时存储这个新的</span>entry。函数返回一个到新插入的或者相等的entry的<big><code>handle_type</code></big>；<span style="font-family: monospace;"></span><big><code></code></big>它
是后
续通过<big><code>erase()</code></big>和<big><code>entry()</code></big>对entry
访问的令牌<code></code>
&nbsp;。工厂概念的正式定义查阅<a href="../reference/factories.html#factory">参
考</a>。
</p>


<p>
Let us see an actual example of realization of a custom factory class.
Suppose
we want to trace the different invocations by Boost.Flyweight of the
<code>insert()</code> and <code>erase()</code>
member functions: this can be
done by using a custom factory whose member methods emit trace messages
to the program console. We base the implementation of the repository
functionality on a regular <code>std::set</code>:</p>


<p>让我们看一个实现了客户化工厂类的实际例子。假设我们想要跟踪Boost.Flyweight对<big><code>insert()</code></big>和<big><code>erase()</code></big>成
员函数的各种调用：这可以通过一个定制的工厂来做到，它的成员函数输出调试信息到程序的控制台。我们基于一个普通的<big><code>std::set</code></big>实
现存储桶的功能。
</p>


<blockquote>
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">verbose_factory_class</span><br><span class="special">{</span> <br>&nbsp; <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">Entry</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">store_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; store_type</span> <span class="identifier">store</span><span class="special">;</span><br><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <span class="keyword">typename</span> <span class="identifier">store_type</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><br><span class="special">&nbsp; {</span><br><span class="identifier">&nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">handle_type</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">p</span><span class="special">=</span><span class="identifier">store</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; &nbsp; if</span><span class="special">(</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span><span class="special">){</span> <span class="comment">/* new entry */</span><br><span class="identifier">&nbsp; &nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"new: "</span><span class="special">&lt;&lt;(</span><span class="keyword">const</span> <span class="identifier">Key</span><span class="special">&amp;)</span><span class="identifier">x</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">&nbsp; &nbsp; }</span><br><span class="keyword">&nbsp; &nbsp; else</span><span class="special">{</span> <span class="comment">&nbsp; &nbsp; &nbsp; &nbsp; /* existing entry */</span><br><span class="identifier">&nbsp; &nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"hit: "</span><span class="special">&lt;&lt;(</span><span class="keyword">const</span> <span class="identifier">Key</span><span class="special">&amp;)</span><span class="identifier">x</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">&nbsp; &nbsp; }</span><br><span class="keyword">&nbsp; &nbsp; return</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">first</span><span class="special">;</span><br><span class="special">&nbsp; }</span><br><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">)</span><br><span class="special">&nbsp; {</span><br><span class="identifier">&nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"del: "</span><span class="special">&lt;&lt;(</span><span class="keyword">const</span> <span class="identifier">Key</span><span class="special">&amp;)*</span><span class="identifier">h</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="identifier">&nbsp; &nbsp; store</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">h</span><span class="special">);</span><br><span class="special">&nbsp; }</span><br><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">)</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; return</span> <span class="special">*</span><span class="identifier">h</span><span class="special">;</span><br><span class="special">&nbsp; }</span><br><span class="special">};</span> </pre>


</blockquote>


<p>
The code deserves some commentaries:</p>


<p>这段代码值得一些注释：
</p>


<ul>


  <li> Note that the factory is parameterized by <code>Entry</code>
and <code>Key</code>, as these types are provided
internally by Boost.Flyweight when the factory is instantiated as part
of the machinery of <code>flyweight</code>; but there is
nothing to prevent us from having more template parameters for finer
configuration of the factory type: for instance, we could extend <code>verbose_factory_class</code>
to accept some comparison predicate rather than the default <code>std::less&lt;Key&gt;</code>,
or to specify the allocator used by the internal <code>std::set</code>.</li>


</ul>


<div style="margin-left: 40px;">注意工厂是通过<big><code>Entry</code></big>和<big><code>Key</code></big>来
参数化的，作为<big><code>flyweight</code></big>机制的一部分，当
工厂被实例化时这些参数由Boost.Flyweight内部
提供；但是我们完全可以使用更多的模板参数来更精细的配制工厂类，我们可以扩展<code>verbose_factory_class</code>让
它接受非默认的比较谓词<big><code>std::less&lt;Key&gt;</code></big>，
或者指定内部<big><code>std::set</code></big>用的分配器。</div>


<ul>


  <li> The fact that <code>Entry</code> is
convertible to <code>const Key&amp;</code> (which is
about the only property known about <code>Entry</code>) is
exploited in the specification of <code>std::less&lt;Key&gt;</code>
as the comparison predicate for the <code>std::set</code>
of <code>Entry</code>s used as the internal repository.</li>


</ul>


<div style="margin-left: 40px;">利用<big><code>Entry</code></big>可
以转换到<big><code>const Key&amp;</code></big>的事
实（这大概是<code></code>唯一所
知的<code>Entry</code>属性），我们指明<big><code>std::less&lt;Key&gt;</code></big>作
为存储<big><code>Entry</code>s</big>的内部存储
桶&mdash;&mdash;<big><code>std::set</code></big>的
比较谓词。</div>


<ul>


  <li> As our public <code>handle_type</code> we are
simply using an iterator to the internal <code>std::set</code>.</li>


</ul>


<div style="margin-left: 40px;">我们简单的使用一个指向内部<big><code>std::set</code></big>的
迭代器作为我们公开的<code><big>handle_type</big></code>。</div>


<p>
In order to plug a custom factory into the specification of a <code>flyweight</code>
type, we need an associated construct called the <i>factory
specifier</i>.
A factory specifier is a <a href="lambda_expressions.html"><code>Lambda
Expression</code></a> accepting the two argument types <code>Entry</code>
and <code>Key</code> and returning the corresponding
factory class:</p>


<p>为了在一个专门化的<big><code>flyweight</code></big>类
型里使用一个定制的工厂，我们需要一个相关
的概念叫做<span style="font-style: italic;">工厂描述符</span>。一
个工厂描述符是一个<a href="lambda_expressions.html"><code>Lambda&nbsp;</code>表
达式</a>，它接受2个参数类型<big><code>Entry</code></big>和<big><code>Key</code></big>并
且返回相关的工厂类：
</p>


<blockquote>
  
  <pre><span class="comment">// Factory specifier (metafunction class version)</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_factory_specifier</span><br><span class="special">{</span><br><span class="keyword">&nbsp; template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">&nbsp; struct</span> <span class="identifier">apply</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; typedef</span> <span class="identifier">custom_factory_class</span><span class="special">&lt;</span><span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">&nbsp; }</span> <br><span class="special">};</span><br><br><span class="comment">// Factory specifier (placeholder version)</span><br><br><span class="keyword">typedef</span> <span class="identifier">custom_factory_class</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><br><span class="identifier">&nbsp; boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><br><span class="special">&gt;</span> <span class="identifier">custom_factory_specifier</span><span class="special">;</span> </pre>


</blockquote>


<p>
There is one last detail: in order to implement <code>flyweight</code>
<a href="configuration.html#free_order_template">free-order
template
parameter interface</a>, it is necessary to explicitly tag a
factory specifier as such, so that it can be distinguised from other
types of specifiers. Boost.Flyweight provides three different
mechanisms
to do this tagging:</p>


<p>还有最后一个细节：为了实现<big><code>flyweight</code></big>的<a href="configuration.html#free_order_template">自由顺序模板参数</a><a href="configuration.html#free_order_template">接口</a>，
必须显式地标记一个工厂描述符，这样它才能同其它类型的描述符区分开。Boost.Flyweight提供3种标记的办法：<a href="configuration.html#free_order_template"><code></code></a>
</p>


<ol>


  <li>Have the specifier derive from the dummy type <code>factory_marker</code>.
Note that this mechanism cannot be used with placeholder expressions.
    
    <p>让这个描述符从一个空类型<big><code>factory_marker</code></big>派
生而来。注意这
种机制不能用于占位符表达式。</p>


    
    <blockquote>
      
      <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">factory_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_factory_specifier</span><span class="special">:</span> <span class="identifier"><b>factory_marker</b></span><br><span class="special">{</span><br><span class="keyword">&nbsp; template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">&nbsp; struct</span> <span class="identifier">apply</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; typedef</span> <span class="identifier">custom_factory_class</span><span class="special">&lt;</span><span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">&nbsp; }</span><br><span class="special">};</span>      </pre>


    </blockquote>


  </li>


  <li>Specialize a special class template called <a href="../reference/factories.html#is_factory"><code>is_factory</code></a>:
    
    <p>特化一个叫做<big><a href="../reference/factories.html#is_factory"><code>is_factory</code></a></big>的
特殊类型。</p>


    
    <blockquote>
      
      <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">factory_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_factory_specifier</span><span class="special">{};</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_factory</span><span class="special">&lt;</span><span class="identifier">custom_factory_specifier</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><br><span class="special">}</span><br><span class="special">}</span>      </pre>


    </blockquote>


  </li>


  <li>The third mechanism, which is the least intrusive, consists
in wrapping the specifier inside the <a href="../reference/factories.html#factory_construct"><code>factory</code></a>
construct:
    
    <p>第三种办法，这是对boost名字空间入侵性最小的办法，是把描述符包到<big><a href="../reference/factories.html#factory_construct"><code>factory</code></a></big>的构造中：</p>


    
    <blockquote>
      
      <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">factory_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier"> std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier"><b> factory</b></span><span class="special">&lt;</span><span class="identifier">custom_factory_specifier</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>      </pre>


    </blockquote>


  </li>


</ol>


<p>
<a href="../examples.html#example7">Example 7</a> in
the examples section develops
in full the <code>verbose_factory_class</code> case
sketched above.</p>


<p>示例章节的<a href="../examples.html#example7">例7</a>完
整的实现了上面概述的<code>verbose_factory_class</code>例子。
</p>


<h2><a name="holders">Custom holders &nbsp;定制holders</a></h2>


<p>
A holder is a class with a static member function <code>get()</code>
giving
access to a unique instance of a given type <code>C</code>:</p>


<p><big>holder</big>是这样一个类，它的静态成员函数<big><code>get()</code></big>提供到给定类型<big><code>C</code></big>的
唯一实例的访问：
</p>


<blockquote>
  
  <pre><span class="comment">// example of a possible holder class template</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">custom_holder_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; static</span> <span class="identifier">C</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span><br><span class="special">};</span>  </pre>


</blockquote>


<p>
<code>flyweight</code> internally uses a holder to create
its associated
factory as well as some other global data. A holder specifier is a
<a href="lambda_expressions.html"><code>Lambda
Expression</code></a> accepting the type <code>C</code>
upon which
the associated holder class operates:</p>


<p><big><code>flyweight</code></big>在内部使用一
个holder来创建与之相关的工厂和其它一些全
局数据。一个holder描述符是一个<a href="lambda_expressions.html"><code>Lambda&nbsp;</code>表
达式</a>，接受一个它所操纵的类型<big><code>C</code></big>作
为参数。
</p>


<blockquote>
  
  <pre><span class="comment">// Holder specifier (metafunction class version)</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_holder_specifier</span><br><span class="special">{</span><br><span class="keyword">&nbsp; template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">&gt;</span><br><span class="keyword">&nbsp; struct</span> <span class="identifier">apply</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; typedef</span> <span class="identifier">custom_holder_class</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">&nbsp; }</span> <br><span class="special">};</span><br><br><span class="comment">// Holder specifier (placeholder version)</span><br><br><span class="keyword">typedef</span> <span class="identifier">custom_holder_class</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span> <span class="identifier">custom_factory_specifier</span><span class="special">;</span>  </pre>


</blockquote>


<p>
As is the case with <a href="#factories">factory
specifiers</a>, holder
specifiers must be tagged in order to be properly recognized when
provided to <code>flyweight</code>, and there are three
available mechanisms
to do so:</p>


<p>如同<a href="#factories">工厂描述符</a>，为了提供给<big><code>flyweight</code></big>的
时候能被正确识别，holder描述符必须
被标记，有3种办法可以做到这一点：
</p>


<blockquote>
  
  <pre><span class="comment">// Alternatives for tagging a holder specifier</span><br><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">holder_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="comment">// 1: Have the specifier derive from holder_marker</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_holder_specifier</span><span class="special">:</span> <span class="identifier"><b>holder_marker</b></span><br><span class="special">{</span><br><span class="special">&nbsp; ...</span><br><span class="special">};</span><br><br><span class="comment">// 2: Specialize the is_holder class template</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_holder</span><span class="special">&lt;</span><span class="identifier">custom_holder_specifier</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><span class="special"><br>}}</span><br><br><span class="comment">// 3: use the holder&lt;&gt; wrapper when passing the specifier<br>// to flyweight</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier"><b>&nbsp; holder</b></span><span class="special">&lt;</span><span class="identifier">custom_holder_specifier</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>  </pre>


</blockquote>


<h2><a name="locking">Custom locking policies
&nbsp;定制锁定策略</a></h2>


<p>
A custom locking policy presents the following simple interface:</p>


<p>一个客户化的锁定策略提供如下简单的接口：
</p>


<blockquote>
  
  <pre><span class="comment">// example of a custom policy</span><br><br><span class="keyword">class</span> <span class="identifier">custom_locking</span><br><span class="special">{</span><br><span class="keyword">&nbsp; typedef</span> <span class="special">...</span> <span class="identifier">mutex_type</span><span class="special">;</span><br><span class="keyword">&nbsp; typedef</span> <span class="special">...</span> <span class="identifier">lock_type</span><span class="special">;</span><br><span class="special">};</span>  </pre>


</blockquote>


<p>
where <code>lock_type</code> is used to acquire/release
mutexes according to
the <i>scoped lock</i> idiom:</p>


<p>在这里<big><code>lock_type</code></big>根据<span style="font-style: italic;">范围锁</span>惯用法来分配/释放互斥体：
</p>


<blockquote>
  
  <pre><span class="identifier">mutex_type</span> <span class="identifier">m</span><span class="special">;</span><br><span class="special">...</span><br><span class="special">{</span><br><span class="identifier">&nbsp; lock_type</span> <span class="identifier">lk</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span> <span class="comment">// acquire the mutex<br>&nbsp; // zone of mutual exclusion, no other thread can acquire the mutex</span><br><span class="special">&nbsp; ...</span><br><span class="special">}</span> <span class="comment">// m released at lk destruction</span>  </pre>


</blockquote>


<p>
Formal definitions for the concepts
<a href="../reference/locking.html#preliminary"><code>Mutex</code></a>
and
<a href="../reference/locking.html#preliminary"><code>Scoped
Lock</code></a>
are given at the reference. To pass a locking policy as a template
argument of
<code>flyweight</code>, the class must be appropriately
tagged:</p>


<p>参考部分有<a href="../reference/locking.html#preliminary"><code></code>互
斥体<code></code></a>和<a href="../reference/locking.html#preliminary"><code></code>范
围锁<code></code></a>的正式定义。为了将锁定策略作为<big><code>flyweight</code></big>的
模板参数传递，这个类必须被适当的标记：
</p>


<blockquote>
  
  <pre><span class="comment">// Alternatives for tagging a locking policy</span><br><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">locking_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="comment">// 1: Have the policy derive from locking_marker</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_locking</span><span class="special">:</span> <span class="identifier">locking_marker</span><br><span class="special">{</span><br><span class="special">&nbsp; ...</span><br><span class="special">};</span><br><br><span class="comment">// 2: Specialize the is_locking class template</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_locking</span><span class="special">&lt;</span><span class="identifier">custom_locking</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><span class="special"><br>}}</span><br><span class="comment"><br>// 3: use the locking&lt;&gt; wrapper when passing the policy<br>// to flyweight</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">&nbsp; locking</span><span class="special">&lt;</span><span class="identifier">custom_locking</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>  </pre>


</blockquote>


<p>
Note that a locking policy is its own specifier, i.e. there is no
additional class to be passed as a proxy for the real component as is
the case with factories and holders.</p>


<p>注意一个锁定策略是它自己的描述符，就是说，这里不需要像工厂和holders那样传递一个作为真实组件代理的额外的类型。
</p>


<h2><a name="tracking">Custom tracking policies
&nbsp;定制跟踪策略</a></h2>


<p>
Tracking policies contribute some type information to the process of
definition of the internal flyweight factory, and are given access
to that factory to allow for the implementation of the tracking
code. A tracking policy <code>Tracking</code> is defined
as a class with
the following nested elements:</p>


<p>跟踪策略在定义内部flyweight工厂的过程中加入了一些类型信息，它被授权访问工厂以实现跟踪代码。一个跟踪策略<big><code>Tracking</code></big>是
一个定义了以下内嵌元素的类：
</p>


<ul>


  <li>A type <code>Tracking::entry_type</code>.</li>


</ul>


<div style="margin-left: 40px;">一个<big><code>Tracking::entry_type</code></big>类
型</div>


<ul>


  <li>A type <code>Tracking::handle_type</code>.</li>


</ul>


<div style="margin-left: 40px;">一个<big><code>Tracking::handle_type</code></big>类
型<br>

<br>


</div>


Each of these elements build on the preceding one, in the sense that
Boost.Flyweight internal machinery funnels the results produced by an
element into the following:<br>


<br>
每个元素都建立在前一个的基础上，Boost.Flyweight的内部机制按以下的方式传递元素生成的类型：
<ul>


  <li><code>Tracking::entry_type</code> is a <a href="lambda_expressions.html"><code>Lambda Expression</code></a>
accepting two different types named <code>Value</code> and
    <code>Key</code> such that <code>Value</code>
is implicitly convertible to <code>const Key&amp;</code>.
The expression is expected to return a type implicitly convertible to
both <code>const Value&amp;</code> and <code>const
Key&amp;</code>. <code>Tracking::entry_type</code>
corresponds to the actual type of the entries stored into the <a href="configuration.html#factory_types">flyweight factory</a>:
by allowing the tracking policy to take part on the definition of this
type it is possible for the policy to add internal tracking information
to the entry data in case this is needed. If no additional information
is required, the tracking policy can simply return <code>Value</code>
as its <code>Tracking::entry_type</code> type.</li>


</ul>


<div style="margin-left: 40px;"><big><code>Tracking::entry_type</code></big>是
一个<a href="lambda_expressions.html"><code><big>Lambda</big>&nbsp;</code>表
达式</a>，它接受2个名为<code>Value</code>和<code>Key</code>的不同类型，
这个<big><code>Value</code></big>可以隐式转换到<big><code>const Key&amp;</code></big>。
这个表达式返回的结果是一个可以隐式转换到<big><code>const Value&amp;</code></big>和<big><code>const
Key&amp;</code></big>的类型。<big><code>Tracking::entry_type</code></big>相
当于存储在<a href="configuration.html#factory_types">flyweight工厂</a>里
的entries的实际类型：通过允许跟踪策略参与到entry类型的定义，跟踪策略就可以在需要的时候添加内部跟踪信息到entry数据。如果不
需要额外的信息，跟踪策略可以简单的返回<big><code>Value</code></big>作为它的<big><code>Tracking::entry_type</code></big>类
型。</div>


<ul>


  <li> The binary <a href="lambda_expressions.html"><code>Lambda
Expression</code></a> <code>Tracking::handle_type</code>
is invoked with types <code>InternalHandle</code> and <code>TrackingHandler</code>
to produce a type <code>Handle</code>, which will be used
as the handle type of the flyweight factory. <a href="../reference/tracking.html#preliminary"><code>TrackingHandler</code></a>
is passed as a template argument to <code>Tracking::handle_type</code>
to offer functionality supporting the implementation of the tracking
code.</li>


</ul>


<div style="margin-left: 40px;">二元<a href="lambda_expressions.html"><code><big>Lambda</big>&nbsp;</code>表
达式</a><big><code>Tracking::handle_type</code></big>通过类型<big><code>InternalHandle</code></big>和<big><code>TrackingHandler</code></big>调
用产生一个<big><code>Handle</code></big>类型，该类型被用作flyweight工厂的handle类型。作为模板参数传
递给<big><code>Tracking::handle_type</code></big>的<a href="../reference/tracking.html#preliminary"><code>TrackingHandler</code></a>用来实现跟踪代码。<br>

<br>


</div>


So, in order to define the factory of some instantiation
<code>fw_t</code> of <code>flyweight</code>, <code>Tracking::entry_type</code>
is invoked with an internal type <code>Value</code>
implicitly convertible
to&nbsp;<code>const fw_t::key_type&amp;</code> to
obtain
the entry type for the factory,
which must be convertible to both <code>const Value&amp;</code>
and
<code>const fw_t::key_type&amp;</code>.
Then, <code>Tracking::handle_type</code> is fed an
internal handle
type and a tracking policy helper to produce the factory handle type.
The observant reader might have detected an apparent circularity: <code>Tracking::handle_type</code>
produces the handle type of
the flyweight factory, and at the same time is passed a tracking helper
that grants access to the factory being defined!
The solution to this riddle comes from the realization of the fact that
<code>TrackingHandler</code> is an <i>incomplete
type</i> by the time it is passed to <code>Tracking::handle_type</code>:
only when <code>Handle</code> is instantiated at a later
stage will this
type be complete.<br>


<br>


于是，为了定义某个<big><code>flyweight</code></big>实例<big><code>fw_t</code></big>的工厂<code>，</code><code></code>用
一个可以隐式转换到<big><code>const fw_t::key_type&amp;</code></big>的<code></code>内
部类型<big><code>Value</code></big>来调用<big><code>Tracking::entry_type</code></big>，得到工厂的entry类型，这个类型可以同时转换成<big><code>const
Value&amp;</code>&nbsp;</big>和<big>
<code>const fw_t::key_type&amp;</code></big>。然后，<code></code>提供一个内部handle类型和一个跟踪策略辅助器给<big><code>Tracking::handle_type</code></big>用来生成工厂的handle类型。敏锐的读者可能已经观察到一个明显的循环：<big><code>Tracking::handle_type</code></big>生
成flyweight工厂的handle类型，同时它被传递一个可以访问正在被创建的工厂的跟踪辅助器！这个谜题的解决方案在于：<big><code>TrackingHandler</code></big>在
传递给<big><code>Tracking::handle_type</code></big>时是一个不完全的类型，只有在<big><code>Handle</code></big>后来被
实例化之后它才成为一个完整的类型。<code></code>
<p>In order for a tracking policy to be passed to <code>flyweight</code>,
it must be tagged much in the same way as the rest of specifiers.</p>


<p>为了让一个跟踪策略可以传递给<big><code>flyweight</code></big>，它必须像其它标识符一样被标
记。
</p>


<blockquote>
  
  <pre><span class="comment">// Alternatives for tagging a tracking policy</span><br><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">tracking_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="comment">// 1: Have the policy derive from tracking_marker</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_tracking</span><span class="special">:</span> <span class="identifier"><b>tracking_marker</b></span><br><span class="special">{</span><br><span class="special">&nbsp; ...</span><br><span class="special">};</span><br><br><span class="comment">// 2: Specialize the is_tracking class template</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_tracking</span><span class="special">&lt;</span><span class="identifier">custom_tracking</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><span class="special"><br>}}</span><br><br><span class="comment">// 3: use the tracking&lt;&gt; wrapper when passing the policy<br>// to flyweight</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier"><b>&nbsp; tracking</b></span><span class="special">&lt;</span><span class="identifier">custom_tracking</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>  </pre>


</blockquote>


<p>
Tracking policies are their own specifiers, that is, they are provided
directly
as template arguments to the <code>flyweight</code> class
template.</p>


<p>跟踪策略是它们自己的描述符，就是说，它们作为模板参数被直接提供给<big><code>flyweight</code></big>类
模板。
</p>


<hr>
<div class="prev_link"><a href="configuration.html"><img src="../prev.gif" alt="configuring Boost.Flyweight" border="0"><br>


Configuring Boost.Flyweight
</a></div>


<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>


Boost.Flyweight tutorial
</a></div>


<div class="next_link"><a href="technical.html"><img src="../next.gif" alt="technical issues" border="0"><br>


Technical issues
</a></div>


<br style="" clear="all">


<br>


<p>Revised December 2nd 2008</p>


<p>&copy; Copyright 2006-2008 Joaqu&iacute;n M
L&oacute;pez Mu&ntilde;oz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>


</body>
</html>

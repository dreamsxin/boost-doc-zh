<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html><head>



  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


  


  
  
  
  
  <title>Boost.Flyweight Documentation - Tutorial - Configuring Boost.Flyweight</title><link rel="stylesheet" href="../style.css" type="text/css">



  
  
  <link rel="start" href="../index.html">



  
  
  <link rel="prev" href="key_value.html">



  
  
  <link rel="up" href="index.html">



  
  
  <link rel="next" href="extension.html"></head>
<body>



<h1><img src="../../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Tutorial: Configuring Boost.Flyweight</h1>



<div class="prev_link"><a href="key_value.html"><img src="../prev.gif" alt="key-value flyweights" border="0"><br>



Key-value flyweights
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>



Boost.Flyweight tutorial
</a></div>



<div class="next_link"><a href="extension.html"><img src="../next.gif" alt="extending Boost.Flyweight" border="0"><br>



Extending Boost.Flyweight
</a></div>



<br style="" clear="all">



<hr>
<h2>Contents &nbsp;目录</h2>



<ul>



  <li><a href="#intro">Configurable aspects of
Boost.Flyweight &nbsp;Boost.Flyweight可配置的界面</a>
    
    
    <ul>



      <li><a href="#free_order_template">Free-order
template parameter interface &nbsp;模板参数顺序自由的界面</a></li>



      <li><a href="#header_inclusion">Header
inclusion &nbsp;所包含的头文件</a></li>



    
    
    </ul>



  </li>



  <li><a href="#tagging">Tagging &nbsp;标记</a></li>



  <li><a href="#factories">Factory specification
&nbsp;工厂规范</a>
    
    
    <ul>



      <li><a href="#factory_types">Types involved in
the configuration of factories &nbsp;配置工厂时所需的类型</a></li>



      <li><a href="#hashed_factory"><code>hashed_factory</code></a></li>



      <li><a href="#set_factory"><code>set_factory</code></a></li>



      <li><a href="#assoc_container_factory"><code>assoc_container_factory</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#holders">Holder specification
&nbsp;Holder规范</a>
    
    
    <ul>



      <li><a href="#static_holder"><code>static_holder</code></a></li>



      <li><a href="#intermodule_holder"><code>intermodule_holder</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#locking">Locking policies
&nbsp;锁定策略</a>
    
    
    <ul>



      <li><a href="#simple_locking"><code>simple_locking</code></a></li>



      <li><a href="#no_locking"><code>no_locking</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#tracking">Tracking policies
&nbsp;跟踪策略</a>
    
    
    <ul>



      <li><a href="#refcounted"><code>refcounted</code></a></li>



      <li><a href="#no_tracking"><code>no_tracking</code></a></li>



    
    
    </ul>



  </li>



</ul>



<h2><a name="intro">Configurable aspects of
Boost.Flyweight &nbsp;Boost.Flyweight可配置的界面</a></h2>



<p>
Most of the time, <code>flyweight</code> default
configuration is just good
enough and the user need not care about further tuning of her <code>flyweight</code>
instantiations; however, when the necessity for more control over
Boost.Flyweight
behavior arises, comprehensive mechanisms are provided to select,
configure and
even extend the following implementation aspects:</p>



<p>
绝大多数时候，<code>flyweight</code>的默认配置足够好，并且用户不需要关心对<code>flyweight</code>实
例的进一步调整；然而，当有必要对Boost.Flyweight的行为进行更多的控制时，我们提供了全面的机制可供挑选，进行配置以及甚至扩展如下的实现方面。</p>



<ul>



  <li><a href="#tagging">Type tagging</a>.
&nbsp;<a href="configuration.html#tagging">类型标注</a></li>



  <li><a href="#factories">Factory</a> used to
store the shared values <code>flyweight</code> objects
refer to. &nbsp;用来存储被flyweight对象所引用的共享的值的<a href="configuration.html#factories">工厂</a> </li>



  <li><a href="#holders">Mechanism of instantiation</a>
of the flyweight factory. &nbsp;flyweight工厂的<a href="configuration.html#holders">实例化机制</a></li>



  <li>Internal <a href="#locking">synchronization
mechanism</a> for access to the internal factory in multithreaded
environments. &nbsp;在多线程环境下对内部工厂访问时的内部<a href="configuration.html#locking">同步机制</a></li>



  <li><a href="#tracking">Tracking policy</a>
controlling how a value stored in the factory is handled when all the
flyweight objects associated to it are destroyed.
&nbsp;<a href="configuration.html#tracking">跟踪策略</a>控制当所有关联到存储在工厂中的值的flyweight对象都销毁后它该怎
么处理。



  </li>



</ul>



<h3><a name="free_order_template">Free-order
template parameter interface &nbsp;模板参数顺序自由的接口</a></h3>



<p>
The <code>flyweight</code> class template features a
"smart" specification
interface by which the configuration aspects can be provided as
optional template arguments
in whatever order the user pleases. For instance, a tagged <code>flyweight</code>
of <code>std::string</code>s with a <a href="#set_factory">set-based factory</a> and
<a href="#no_tracking">no tracking</a> can be
specified like this:</p>



<p>
<code>flyweight</code>类模板的特性是有一个“智能的”接口，
通过这个接口配用户可以以任何喜欢的顺序来提供可选的模板参数。例如，一个<code></code>同时拥有tagged，<a href="configuration.html#set_factory">set-based factory</a>和<a href="configuration.html#no_tracking">no tracking</a>等几
项配置界面的<code>std::string</code>s类的<code>flyweight</code>可
以按这样的方式指定：</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">label_t</span><span class="special">&gt;,</span> <span class="identifier">set_factory</span><span class="special">&lt;&gt;,</span> <span class="identifier">no_tracking</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
or like this:</p>



<p>
或者像这样
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">no_tracking</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">label_t</span><span class="special">&gt;,</span> <span class="identifier">set_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
or in any other order; only <code>std::string</code> is
required to occupy
the first place in the specification.</p>



<p>
或者以任何其它顺序；只要<code>std::string</code>出现在的第一的位置。</p>



<h3><a name="header_inclusion">Header inclusion
&nbsp;头文件包含</a></h3>



<p>
The example code shown at the <a href="basics.html#intro">introductory
section</a>
uses the
<a href="../reference/index.html#flyweight_synopsis"><code>"boost/flyweight.hpp"</code></a>
convenience header, which simply includes the headers for the class
template
<code>flyweight</code> and its default configuration
components:</p>



<p><a href="basics.html#intro">简介一节</a>中展示的示例代码
使用<a href="../reference/index.html#flyweight_synopsis"><code>"boost/flyweight.hpp"</code></a>简
易头文件，它只是简单的包含了<code>flyweight</code>类模板和它的默认配置组件的头文件。
</p>



<blockquote>
  
  
  <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// class template flyweight</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">hashed_factory</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// hashed flyweight factory</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">static_holder</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// regular factory instantiation</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">simple_locking</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// simple locking policy</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">refcounted</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// refcounting tracking policy</span></pre>



</blockquote>



<p>
When using components other than these, their specific headers must be
explicitly included.</p>



<p>
当使用除此之外其它的组件时，必须显式包含特定的头文件。
</p>



<h2><a name="tagging">Tagging &nbsp;标记</a></h2>



<p>
Consider the following two types:</p>



<p>
考虑以下2种类型：
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">name_t</span><span class="special">;</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">ip_address_t</span><span class="special">;</span></pre>



</blockquote>



<p>
Although technically both types are identical, this is so by virtue of
coincidence, as there is no sensible relation between names and IP
addresses.
Internally, the fact that <code>name_t</code> and <code>ip_address_t</code>
are the same flyweight type causes values of both classes to be stored
together
in the same flyweight factory, although their respective ranges
are not expected to overlap. <i>Tagging</i> can be used to
turn these
into really different types:</p>



<p>虽然严格来说这2种类型是完全一样的，但是这纯属巧合，因为在名字和IP地址之间没有有意义的关系。从内部看，<code>name_t</code>和<code>ip_address_t</code>是
相同flyweight类型的事实导致两种类型的值存在同一个flyweight工厂里，虽然可以预料它们各自的范围是不会有交集的。<i>标
注 </i>可以使这两种类型成为真正不同的类型。
</p>



<blockquote>
  
  
  <pre><span class="keyword">struct</span> <span class="identifier">name_tag</span><span class="special">{};</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">name_tag</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">name_t</span><span class="special">;</span><br><span class="keyword">struct</span> <span class="identifier">ip_address_tag</span><span class="special">{};</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">ip_address_tag</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">ip_address_t</span><span class="special">;</span></pre>



</blockquote>



<p>
Now, <code>name_t</code> and <code>ip_address_t</code>
are different
flyweight classes having separate factories each. Tags are a purely
syntactic
device: any type can be used for tagging inside the <code>tag</code>
construct, though good style recommends using tag classes with
descriptive names which are local to the context where the flyweight
type
is being defined.</p>



<p>
现在，<code>name_t</code>和<code>ip_address_t</code>是
分别拥有自身存储桶的不同的flyweight类型。标记纯粹是一种语法装置：任何类型都可拿来构造一个<code>tag</code>做
标记，然而好的风格建议tag类型应该使用具备描述性的类名字并且这个类型应该靠近定义flyweight类型的上下文。
</p>



<h2><a name="factories">Factory specification
&nbsp;工厂规范</a></h2>



<p>
<code>flyweight</code> uses a type of internal component
called
<i>factory</i> whose purpose is to store and retrieve the
different values
flyweight objects refer to at a given time. By default, a factory based
on
a hashed container is used, so that <code>flyweight&lt;T&gt;</code>
is
actually equivalent to</p>



<p>
<code>flyweight</code>使用一种称之为<span style="font-style: italic;">工厂</span>的内部组件类型，工厂被用来存取在某一
时刻flyweight对象引用的不同的值。默认情况下，使用的是一个基于哈希容器的工厂，因此<code>flyweight&lt;T&gt;</code>实
际上相当于
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">hashed_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
where <code>hashed_factory</code> is a so-called <i>factory
specifier</i>.
Boost.Flyweight provides several predefined factory specifiers, which
not
only let the user select the specific type of factory used, but also
accept their own template arguments to customize each factory.</p>



<p>
在这里<code>hashed_factory</code>是一个所谓的<span style="font-style: italic;">工厂描述符</span>。Boost.Flyweight
提供了几个预定义的工厂描述符，它们不仅允许用户选择特定类型的工厂，而且每个工厂自己也接受模板参数来加以订制。
</p>



<h3><a name="factory_types">Types involved in the
configuration of factories &nbsp;配置工厂时所需的类型</a></h3>



<p>
A given <code>flyweight</code> instantiation has
associated
<code>flyweight::key_type</code>
and <code>flyweight::value_type</code> types (which are
equal in the case
of regular flyweights or different if <a href="key_value.html">key-value
flyweights</a>
are used). Also, there is an internal <code>Entry</code>
type which
corresponds to the type of the objects actually stored in the factory:
<code>Entry</code> contains the shared <code>value_type</code>
objects
of <code>flyweight</code> as well a some internal
bookkeeping information;
also, <code>Entry</code> is implicitly convertible to
<code>const key_type&amp;</code>, so that factories can
rely on
<code>key_type</code> to look up <code>Entrie</code>s.
Since
<code>Entry</code> is internal to the implementation of <code>flyweight</code>,
it cannot be directly referred to by the user in the configuration of
factories. Instead, the proxy
<a href="../../../mpl/doc/refmanual/placeholders.html"><i>placeholder</i></a>
type <code>boost::mpl::_1</code> can be used.</p>



<p>
一个给定的<code>flyweight</code>实例有相关的<code>flyweight::key_type</code>和<code>flyweight::value_type</code>类
型（它们在普通flyweights情况下是相同的，而在<a href="key_value.html">键-值
flyweights</a>时是不同的）。与此同时，还有一个内部的<code>Entry</code>类型相当
于实际存储在工厂里的对象的类型：<code>Entry</code>包含<code>flyweight</code>对
象所共享的<code>value_type</code>，还包括一些内部<span class="mn">簿</span>记信息；而且，<code>Entry</code>可以隐式转换成<code>const
key_type&amp;，</code>因此工厂可以依赖<code>key_type</code>来
查找<code>Entrie</code>s。既然<code>Entry</code>是<code>flyweight</code>的
内部实现细节，它不能在配置工厂的时候被用户直接引用。可以用代理的<i><a href="../../../mpl/doc/refmanual/placeholders.html"><i>占
位符</i></a></i>类型<big><code>boost::mpl::_1</code></big>作
为替代。
</p>



<h3><a name="hashed_factory"><code>hashed_factory</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/factories.html#hashed_factory_synopsis"><code>"boost/flyweight/hashed_factory.hpp"</code></a><br>



  <b>Syntax:</b> <code>hashed_factory&lt;[Hash[,Pred[,Allocator]]]&gt;</code>
</blockquote>



<p>
This specifier, which Boost.Flyweight takes by default, controls the
usage of a
factory internally based in a hash container. Values are determined to
be
equivalent by means of the
<a href="http://www.sgi.com/tech/stl/BinaryPredicate.html"><code>Binary
Predicate</code></a> <code>Pred</code>, and
indexed into the factory container
using <code>Hash</code>, which is assumed to be a <i>hash
function</i>, i.e. a
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary
Function</code></a> assigning to each value a hash
identifier of
type <code>std::size_t</code>. The <code>Allocator</code>
parameter is
used by the factory container for its memory allocation needs. The
default
types for these parameters are such that the expression</p>



<p>这是Boost.Flyweight默认使用的描述符，它控制一个在内部基于哈希容器的工厂的使用。<a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">二元谓词</a><big><code>Pred</code></big>用
来判断值是否相等，<big><code>Hash</code></big>用来计算出到这个工厂容
器的索引<code></code>，假定它是一个<i style="font-style: italic;">哈希</i><span style="font-style: italic;">函数</span>，即一个为每个值分配一个<big><code>std::size_t</code></big>类
型的哈希标识符的<a href="http://www.sgi.com/tech/stl/UnaryFunction.html">一
元函数</a>。<big><code>Allocator</code></big>参
数被工厂容器用来进行所需的内存分配。这些参数的默认类型的表达式
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">hashed_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span> </pre>



</blockquote>



<p>
is equivalent to<br>



相当于
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">T</span><span class="special">,</span><br><span class="identifier">hashed_factory</span><span class="special">&lt;</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">key_value</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">key_value</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="special">&gt;</span></pre>



</blockquote>



<p>
where <code>key_type</code> is the key type of the
flyweight and
<code>boost::mpl::_1</code>, as explained above, stands for
the
internal <code>Entry</code> type of the elements stored in
the factory.
Suppose we would like to configure <code>hashed_factory</code>
for
a <code>std::string</code> flyweight with
a special hash predicate <code>special_hash</code> and a
custom allocator
<code>custom_allocator</code>; this would be specified as
follows:</p>



<p>这里<big><code>key_type</code></big>是flyweight
的键类型，如前所说，<big><code>boost::mpl::_1</code></big>代
表存储在工厂里的元素的内部<big><code>Entry</code></big>类型。假定我
们想要配置一个<big><code>std::string</code></big>的flyweight
的<code><big>hashed_factory</big>，</code>给它提供一个特别
的哈希谓词<big><code>special_hash</code></big>还有一个自定义
的分配器<code><big>custom_allocator</big>，</code>可以按
照下面的方式指定：
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">hashed_factory</span><span class="special">&lt;</span><br><span class="identifier">special_hash</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">key_value</span><span class="special">&gt;,</span><br><span class="identifier">custom_allocator</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="special">&gt;</span></pre>



</blockquote>



<h3><a name="set_factory"><code>set_factory</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/factories.html#set_factory_synopsis"><code>"boost/flyweight/set_factory.hpp"</code></a><br>



  <b>Syntax:</b> <code>set_factory&lt;[Compare[,Allocator]]&gt;</code>
</blockquote>



<p>
<code>set_factory</code> resorts to an <code>std::set</code>-like
ordered
container for the implementation of the flyweight factory.
<code>Compare</code> must be a
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code>Strict
Weak Ordering</code></a> on the value type <code>flyweight</code>
is
acting upon; as is customary with STL ordered containers, two values
are considered equivalent if none is less than the other according to <code>Pred</code>.
<code>Allocator</code> is an allocator type passed along to
the factory
internal container for its memory-related tasks. When default
parameters are
used, the expression</p>



<p><big><code>set_factory</code></big>采用一个
类似于<big><code>std::set</code></big>的有序容器来实现
flyweight工厂。<big><code>Compare</code></big>对于<big><code>flyweight</code></big>用
到的值类型必须是<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">严
格弱序</a>的；按照STL有序容器的惯例，根据<code>Compare</code><font size="-1">(译注：原文有误)</font>来
判断如果没有一个值比另一个值小那么这两个值被认为是相等的。&nbsp;<big><code>Allocator</code><code></code></big>是
一个传递给工厂内部容器的分配器类型，用来处理内存相关的任务。当使用默认的参数时，表达式
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">set_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
is equivalent to<br>



相当于
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">T</span><span class="special">,</span><br><span class="identifier">set_factory</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">key_type</span><span class="special">&gt;,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span> <span class="special">&gt;</span><br><span class="special">&gt;</span></pre>



</blockquote>



<p>
Usual tradeoffs arising in the comparison of ordered and hashed
containers
also apply when choosing between <code>set_factory</code>
and
<code>hashed_factory</code>:
so, set-based lookup and insertion of values are generally slower than
those based on hashing,
but the latter can be affected by pathological worst-case scenarios
with very
poor performance.</p>



<p>在比较有序容器和哈希容器时得出的权衡同样适用于在选择<big><code>set_factory</code></big>还
是<big><code>hashed_factory</code></big>时：因此，基于
set的查找和插入通常要慢于那些基于哈希的，但是后者能被病态的最差环境所影响而导致具有非常差的性能。
</p>



<h3><a name="assoc_container_factory"><code>assoc_container_factory</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/factories.html#assoc_container_factory_synopsis"><code>"boost/flyweight/assoc_container_factory.hpp"</code></a><br>



  <b>Syntax:</b> <code>assoc_container_factory&lt;ContainerSpecifier&gt;</code>
</blockquote>



<p>
This specifier can be seen as a generalization of
<code>hashed_factory</code> and <code>set_factory</code>
where the user
supplies the exact type of container on which the factory is based. The
way in which the container is specified might seem at first a little
daunting to those unfamiliar with the
<a href="../../../mpl/doc/index.html">Boost MPL Library</a>:
<code>ContainerSpecifier</code> must be an <a href="lambda_expressions.html"><code>MPL Lambda
Expression</code></a> such that, when invoked with the
types <code>Entry</code> and <code>key_type</code>
explained <a href="#factory_types">above</a>, it
produces the type of a container of <code>Entry</code>
elements satisfying the following
requirements:</p>



<p>这种描述符可以被看作是<big><code>hashed_factory</code></big>和<big><code>set_factory</code></big>的
一般化形式，此时用户提供工厂所依赖的容器的确切类型。对那些不熟悉<a href="../../../mpl/doc/index.html">Boost
MPL 库</a>的人来说，描述容器的方式乍看起来可能会有点吓人：<big><code>ContainerSpecifier</code></big>必
须是一个<a href="lambda_expressions.html"><code>MPL
Lambda
</code>表达式<code></code></a>，当用<a href="#factory_types">上文</a>描述的类型<big><code>Entry</code></big>和<big><code>key_type</code></big>来
调用它时，它将生成一个满足以下要求的<code>Entry</code>元素的容器：<span style="text-decoration: underline;"></span>
</p>



<ol>



  <li>The container type must be a model of <a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html"><code>Unique
Associative Container</code></a> where equivalence of <code>Entry</code>s
is determined by the <code>key_type</code> values the
entries are convertible to .</li>



  
  
  <p>容器类型必须是<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">唯一关联容器</a>模型，<big><code>Entry</code>s</big>的相等性是由可由它们转化而成的<big><code>key_type</code></big>的值来决定。</p>



  <li>The container must be <i>stable</i>, i.e. its
iterators must remain valid after insert and erase operations. Note
that this condition is not met by many existing implementations of
hashed containers that invalidate iterators upon a rehashing operation.
&nbsp;</li>


  
  
  <p>容器必须是<span style="font-style: italic;">稳定</span>的，就是说，在插入和删除操作之后它的迭代器必须仍然有效。注意许多现成的哈希容器的实现都不符合这个标准，它们的迭代器在一
次重哈希操作之后就无效了。</p>



</ol>



Let us see what a container specifier looks like with an example.
Suppose we have our own ordered container like the following:<br>



<br>



让我们以一个例子来看看容器描述符是怎样的。假设我们有一个自己的有序容器像下面这个样子：
<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">typename</span> <span class="identifier">Elem</span><span class="special">,</span><br><span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">Elem</span><span class="special">&gt;,</span><br><span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">Elem</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">ultrafast_set</span><br><span class="special">{</span><br><span class="special">...</span><br><span class="special">};</span></pre>



</blockquote>



<p>
Then <code>ultrafast_set</code> can be plugged into
<code>assoc_container_factory</code> like this:</p>


<p>
<big><code>ultrafast_set</code></big>可以像这样的方式植入<code><big>assoc_container_factory</big>：</code>
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">assoc_container_factory</span><span class="special">&lt;</span><br><span class="comment">// MPL lambda expression follows</span><br><b><span class="identifier">ultrafast_set</span><span class="special">&lt;</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span></b><br><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span></pre>



</blockquote>



<p>
As has been explained, <code>mpl::_1</code> is a so-called
MPL
placeholder standing as a "slot" to be replaced with
<code>Entry</code> by the internal machinery of
Boost.Flyweight.
Note that we have not
relied on the default argument of <code>ultrafast_set</code>
for
<code>Compare</code> and instead we have provided a fixed
instantiation for <code>std::string</code>: this is so
because
requirements state that the type with which <code>ContainerSpecifier</code>
will be filled in internally is convertible to <code>const
key_type&amp;</code>
(here <code>const std::string&amp;</code>), and it is
based on
<code>key_type</code> that lookup and equivalence of
entries
should be determined. On the other hand, the default argument for the <code>Allocator</code>
parameter works
just fine, as is more apparent if we write it down explicitly:</p>



<p>正如已经描述的那样，<big><code>mpl::_1</code></big>的是一个所谓的MPL占位符，代表一个被Boost.Flyweight的内部机制用<big><code>Entry</code></big>替换掉的“插槽” &nbsp;。注意我们没有使用<big><code>ultrafast_set</code></big>的
默认<big><code>Compare</code></big>参数而是提供了一个<code>std::string</code>类的不变实例： 这是因为规范声明<big><code>ContainerSpecifier</code></big>内部将要填充的类型可以转换为<big><code>const
key_type&amp;</code></big>（这里是<big><code>const std::string&amp;</code></big>），而且entries的查找和判等是基于<big><code>key_type</code></big>来决定的<code>。</code>&nbsp;
另一方面，<big><code>Allocator</code></big>参数的默认值可以很好的工作，如果我们显式地写出来会更明显：
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">assoc_container_factory</span><span class="special">&lt;</span><br><b><span class="identifier">ultrafast_set</span><span class="special">&lt;</span><br><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="special">&gt;</span></b><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span> </pre>



</blockquote>



<h2><a name="holders">Holder specification &nbsp;Holder &nbsp;规范</a></h2>



<p>
Each flyweight type, that is, each distinct instantiation of the class
template <code>flyweight</code>, is associated with
exactly one factory
object. In most cases, how this factory object is created is of little
importance to the user of Boost.Flyweight, but there are special
circumstances where control of this aspect is necessary. An internal
component called <i>holder</i> is in charge of
instantiating the
factory class and some other internal information; this component is
stipulated by means of a <i>holder specifier</i>, <code>static_holder</code>
being the default one.</p>



<p>每个flyweight类型，就是说，每个<big><code>flyweight</code></big>类模板的不同实例，
只会有一个相关的工厂对象。绝大多数情况下，这个工厂对象是如何创建的对Boost.Flyweight的用户是无关紧要的，但是在一些特殊的环境下对这个
界面的控制是必要的。一个名为<i>holder</i>的内部组件掌管工厂类和其它一些内部信息的实例化；该组件用一个<i>holder
描述符</i>来规定，默认的描述符是<code><big>static_holder</big>。</code>
</p>



<h3><a name="static_holder"><code>static_holder</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/holders.html#static_holder_synopsis"><code>"boost/flyweight/static_holder.hpp"</code></a><br>



  <b>Syntax:</b> <code>static_holder</code>
</blockquote>



<p>
This the default holder specifier of Boost.Flyweight, and produces
holders where the unique factory lives as a local static variable of
the
program.</p>



<p>这是Boost.Flyweight的默认holder默描述符，它生成的holder的工厂以局部静态变量的方式存在于程序中。
</p>



<h3><a name="intermodule_holder"><code>intermodule_holder</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/holders.html#intermodule_holder_synopsis"><code>"boost/flyweight/intermodule_holder.hpp"</code></a><br>



  <b>Syntax:</b> <code>intermodule_holder</code>
</blockquote>



<p>
In most C++ environments, static variables do not mix well with
dynamically loaded modules in the sense that instances of the same
static variable can be duplicated across different modules, even
though by definition the variable should be unique. In many
cases, this duplication goes unnoticed if the modules do not
communicate
between each other using the affected types, but consider this
case where such communication does happen:</p>



<p>在大多数C++环境里，静态变量不能与动态加载的模块很好地协同，原因在于同一个静态变量可以在不同的模块中重复，即使根据定义这个变量应
该是唯一的。在很多情况下，如果模块之间不通过受影响的类型来交互的话是不会注意到这个重复的，但是考虑一下这种通讯确实发生的例子：
</p>



<blockquote>
  
  
  <pre><span class="comment">// module 1</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span><br><span class="comment">// produce_string is exported so that it can be dynamically<br>// linked</span><br><span class="identifier">flyweight_string</span> <span class="identifier">produce_string</span><span class="special">()</span><br><span class="special">{</span><br><span class="keyword">return</span> <span class="identifier">flyweight_string</span><span class="special">(</span><span class="string">"boost"</span><span class="special">);</span><br><span class="special">}</span> </pre>



</blockquote>



<blockquote>
  
  
  <pre><span class="comment">// main program</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="special">...</span> <span class="comment">// import module 1</span><br><span class="identifier">flyweight_string</span> <span class="identifier">str1</span><span class="special">=</span><span class="identifier">produce_string</span><span class="special">();</span><br><span class="identifier">flyweight_string</span> <span class="identifier">str2</span><span class="special">(</span><span class="string">"boost"</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(</span><span class="identifier">str1</span><span class="special">==</span><span class="identifier">str2</span><span class="special">);</span><br><span class="special">}</span> </pre>



</blockquote>



<p>
In many environments, this program results in an assertion
failure because the flyweight factory object used
by <code>flyweight_string</code> as seen within module 1
is
not the same factory object as seen within the main program: hence
the value representations internally pointed to by <code>str1</code>
and <code>str2</code> will differ and will be mistakenly
considered as not equal. Many other problems might arise
due to factory duplication, including undefined behavior.</p>



<p>在很多环境下这个程序导致断言错误，因为在模块1中看到的<big><code>flyweight_string</code></big>用
到的工厂和主程序里看到的工厂对象不是同一个：因此<big><code>str1</code></big>和<big><code>str2</code></big>内部所指向的值的表示是不同的，于是它们被错误的认为不相等。工厂重复可能导致很多其它的错误，包括未定义的行为。
</p>



<p>
<code>intermodule_holder</code> specifies a factory holder
which
is capable of avoiding the duplication problem and ensuring that
all modules of a program are using the same factory instance.
To fix the example above, it suffices to redefine
<code>flyweight_string</code> in both modules as:</p>



<p><big><code>intermodule_holder</code></big>指定的工厂的holder能够避免重复问题，它保证程序中所有的模块都使用同一个工厂实例。只要在两个模块中都像这样重新定义<code><big>flyweight_string</big>，</code>就
可以修正上例中的问题。
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><span class="identifier"><b>intermodule_holder</b></span><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span> </pre>



</blockquote>



<p>
<code>intermodule_holder</code> is considerably more
onerous than
<code>static_holder</code> in terms of compilation times
and
introduces a non-negligible overhead at program start-up, so its use
should be reserved to the situations where it is really necessary.</p>



<p><big><code>intermodule_holder</code></big>修在编译时要比<big><code>static_holder</code></big>笨重的多并且导致不可忽视的程序启动时的额外开销，因此只有真的有必要时才使用它。
</p>



<h2><a name="locking">Locking policies &nbsp;锁定策略</a></h2>



<p>
The internal factory associated to each <code>flyweight</code>
type is a shared resource and as such access to it must be properly
synchronized in multithreaded environments. A <i>locking policy</i>
specifies the synchronization mechanisms to be used for this purpose.</p>



<p>与每个<code>flyweight</code>类型关联的内部工厂是一个共享资源，因此在多线程环境下
对它的访问必须被恰当的同步。一种<span style="font-style: italic;">锁定策略</span>指
定了用于此目的的同步机制。
</p>



<h3><a name="simple_locking"><code>simple_locking</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/locking.html#simple_locking_synopsis"><code>"boost/flyweight/simple_locking.hpp"</code></a><br>



  <b>Syntax:</b> <code>simple_locking</code>
</blockquote>



<p>
This is the default locking policy. It specifies the simplest native
synchronization primitives provided by the operating system, whenever
available.</p>



<p>这是默认的锁定机制。只要可行它就使用操作系统所提供的最简单的原生同步原语。
</p>



<h3><a name="no_locking"><code>no_locking</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/locking.html#no_locking_synopsis"><code>"boost/flyweight/no_locking.hpp"</code></a><br>



  <b>Syntax:</b> <code>no_locking</code>
</blockquote>



<p>
No synchronization is enforced so that irrestricted internal access
to the implementation shared resources is allowed.
Selecting <code>no_locking</code> results in somewhat
faster execution than
the default <code>simple_locking</code>, but it renders
the type
thread-unsafe, which can have catastrophic consequences.
This policy should not be used except in single-threaded environments
or
when there is an absolute guarantee that the particular <code>flyweight</code>
type will not be used in a concurrent scenario.</p>



<p>因为没有施加任何同步机制，所以可以对共享资源进行无限制访问。选择<code>no_locking</code>导
致执行速度要比默认的<code>simple_locking</code>快一点，但是类型因此不再线程安全了，这可能会有
灾难性的后果。除非是在单线程的环境里或者当绝对可以保证特定的<code>flyweight</code>类型不会在同步环
境下被使用，否则不应该使用这种策略。
</p>



<h2><a name="tracking">Tracking policies
&nbsp;跟踪策略</a></h2>



<p>
A <i>tracking policy</i> controls the lifetimes of the <code>flyweight</code>
objects and can act based on this information. For instance, a suitable
tracking mechanism can determine when a given value stored in the
factory
can be safely erased because it is no longer referenced by any
<code>flyweight</code>; this is precisely what the default
tracking policy,
<code>refcounted</code>, does.</p>



<p>
跟踪策略控制着<code>flyweight</code>对象的生存期。例如，一种合适的跟踪策略可以决定当工厂里的某个给
定的值没有被任何<code>flyweight</code>对象引用的时候它可以被安全的清理；这正是默认的跟踪策略<code>refcounted</code>所做的事情</p>



<h3><a name="refcounted"><code>refcounted</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/tracking.html#refcounted_synopsis"><code>"boost/flyweight/refcounted.hpp"</code></a><br>



  <b>Syntax:</b> <code>refcounted</code>
</blockquote>



<p>
This tracking policy determines that values stored in the factory be
equipped with reference counting mechanisms so that a factory entry is
erased when the last <code>flyweight</code> object
associated to it
is destroyed.</p>



<p>
这种跟踪策略决定存储在工厂里的值配有引用计数机制，于是当关联到该工厂某个条目的最后一个<code>flyweight</code>对
象被销毁的时候，该条目将被清理。</p>



<h3><a name="no_tracking"><code>no_tracking</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/tracking.html#no_tracking_synopsis"><code>"boost/flyweight/no_tracking.hpp"</code></a><br>



  <b>Syntax:</b> <code>no_tracking</code>
</blockquote>



<p>
No flyweight tracking is done when this policy is selected, which
implies
that the values stored in the factory remain in it until program
termination.
As compared with <code>refcounted</code>, <code>no_tracking</code>
presents
advantages and drawbacks. The benefits are:</p>



<p>
当选择这种策略时，不进行flyweight的跟踪，这暗示存储在工厂里的值将一直存在直到程序结束。与<code>refcounted</code>相
比，<code>no_tracking</code>既有优点也有缺点。优点是：</p>



<ul>



  <li>Non-tracked flyweight objects are faster to pass around
than refcounted ones. &nbsp;</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
不进行跟踪的flyweight对象在传递时要快于使用了引用计数的。
<ul>



  <li>There is some reduction in memory usage due to the absence
of reference counters. &nbsp;</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
由于没有引用计数内存使用上会有一些减少<br>



<br>



whereas potential drawbacks of using <code>no_tracking</code>
include:<br>



<br>



反之使用<code>no_tracking</code>潜在的缺点包括：
<ul>



  <li>The number of unused entries stored in the factory can keep
growing during the program lifetime, which can become a problem for
certain patterns of flyweight creation where the set of active values
"drifts" over time.</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
存储在工厂中没用的条目的数量在程序运行期间可能持续增长，这对于特定的flyweight模式的创建可能会成为问题，在那些特定模式中活动值的集合会不时的“漂移”。
<ul>



  <li>There can be a potential delay during program termination,
since it is then when all the factory entries get destroyed at once.</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
程序终止时可能会有一个潜在的时延，因为这时所有的工厂条目将被一起销毁。
<hr>
<div class="prev_link"><a href="key_value.html"><img src="../prev.gif" alt="key-value flyweights" border="0"><br>



Key-value flyweights
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>



Boost.Flyweight tutorial
</a></div>



<div class="next_link"><a href="extension.html"><img src="../next.gif" alt="extending Boost.Flyweight" border="0"><br>



Extending Boost.Flyweight
</a></div>



<br style="" clear="all">



<br>



<p>Revised November 8th 2008</p>



<p>© Copyright 2006-2008 Joaquín M
López Muñoz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>



</body></html>
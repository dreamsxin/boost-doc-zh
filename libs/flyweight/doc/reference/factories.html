<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>



  
  
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">


  


  
  
  
  <title>Boost.Flyweight Documentation - Factories reference</title>
  <link rel="stylesheet" href="../style.css" type="text/css">



  
  
  <link rel="start" href="../index.html">



  
  
  <link rel="prev" href="tags.html">



  
  
  <link rel="up" href="index.html">



  
  
  <link rel="next" href="holders.html">
</head>


<body>



<h1><img src="../../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Factories reference</h1>



<div class="prev_link"><a href="tags.html"><img src="../prev.gif" alt="tags" border="0"><br>



Tags
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight reference" border="0"><br>



Boost.Flyweight reference
</a></div>



<div class="next_link"><a href="holders.html"><img src="../next.gif" alt="holders" border="0"><br>



Holders
</a></div>



<br style="" clear="all">



<hr>
<h2>Contents &nbsp;&#30446;&#24405;</h2>



<ul>



  <li><a href="#factory">Factories and factory
specifiers &nbsp;&#24037;&#21378;&#21644;&#24037;&#21378;&#25551;&#36848;&#31526;</a></li>



  <li><a href="#factory_tag_synopsis">Header <code>"boost/flyweight/factory_tag.hpp"</code>
synopsis &nbsp;&#22836;&#25991;&#20214;"boost/flyweight/factory_tag.hpp"&#22823;&#24847;</a>
    
    
    <ul>



      <li><a href="#is_factory">Class template <code>is_factory &nbsp;&#31867;&#27169;&#26495; is_factory</code></a></li>



      <li><a href="#factory_construct">Class
template <code>factory &nbsp;&#31867;&#27169;&#26495; factory</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#hashed_factory_fwd_synopsis">Header <code>"boost/flyweight/hashed_factory_fwd.hpp"</code>
synopsis &nbsp;&#22836;&#25991;&#20214;"boost/flyweight/hashed_factory_fwd.hpp"&#22823;&#24847;</a> </li>



  <li><a href="#hashed_factory_synopsis">Header <code>"boost/flyweight/hashed_factory.hpp"</code>
synopsis &nbsp;&#22836;&#25991;&#20214;"boost/flyweight/hashed_factory.hpp"&#22823;&#24847;</a>
    
    
    <ul>



      <li><a href="#hashed_factory_class">Class
template <code>hashed_factory_class &nbsp;&#31867;&#27169;&#26495; hashed_factory_class</code></a></li>



      <li><a href="#hashed_factory">Class template <code>hashed_factory &#31867;&#27169;&#26495;&nbsp; hashed_factory&nbsp;</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#set_factory_fwd_synopsis">Header <code>"boost/flyweight/set_factory_fwd.hpp"</code>
synopsis &nbsp;&#22836;&#25991;&#20214;"boost/flyweight/set_factory_fwd.hpp"&#22823;&#24847;</a> </li>



  <li><a href="#set_factory_synopsis">Header <code>"boost/flyweight/set_factory.hpp"</code>
synopsis &nbsp;&#22836;&#25991;&#20214;"boost/flyweight/set_factory.hpp"&#22823;&#24847;</a>
    
    
    <ul>



      <li><a href="#set_factory_class">Class
template <code>set_factory_class &nbsp;&#31867;&#27169;&#26495; set_factory_class</code></a></li>



      <li><a href="#set_factory">Class template <code>set_factory &nbsp;&#31867;&#27169;&#26495; set_factory</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#assoc_container_factory_fwd_synopsis">Header
    <code>"boost/flyweight/assoc_container_factory_fwd.hpp"</code>
synopsis &nbsp;&#22836;&#25991;&#20214;"boost/flyweight/assoc_container_factory_fwd.hpp"&#22823;&#24847;</a> </li>



  <li><a href="#assoc_container_factory_synopsis">Header
    <code>"boost/flyweight/assoc_container_factory.hpp"</code>
synopsis &nbsp;&#22836;&#25991;&#20214;"boost/flyweight/assoc_container_factory.hpp"&#22823;&#24847;</a>
    
    
    <ul>



      <li><a href="#assoc_container_factory_class">Class
template <code>assoc_container_factory_class &nbsp;&#31867;&#27169;&#26495;&nbsp; assoc_container_factory_class</code></a></li>



      <li><a href="#assoc_container_factory">Class
template <code>assoc_container_factory &nbsp;&#31867;&#27169;&#26495;&nbsp; assoc_container_factory</code></a></li>



    
    
    </ul>



  </li>



</ul>



<h2><a name="factory">Factories and factory
specifiers &nbsp;&#24037;&#21378;&#21644;&#24037;&#21378;&#25551;&#36848;&#31526;</a></h2>



<p>
Given a type <code>Key</code> and an
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>
type <code>Entry</code> implicitly convertible to <code>const
Key&amp;</code>, a
<i>factory of <code>Entry</code> elements</i>
(implicitly associated to
<code>Key</code>) is a
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a> entity able to store and retrieve
immutable elements of
type <code>Entry</code>. A factory is governed by an
associated equivalence
relation defined on <code>Key</code> so that no two
<code>Entry</code> objects convertible to equivalent <code>Key</code>s
can be stored simultaneously in the factory. Different factory types
can
use different equivalence relations.</p>



<p>&#32473;&#23450;&#19968;&#20010;<big><code>Key</code></big>&#31867;&#22411;&#21644;&#19968;&#20010;<a href="http://www.sgi.com/tech/stl/Assignable.html">&#21487;&#36171;&#20540;</a>&#21487;
&#38544;&#24335;&#36716;&#25442;&#25104;<big><code>const Key&amp;</code></big>&#30340;<big><code>Entry</code></big>&#31867;
&#22411;&#65292;&#19968;<big>&#20010;<i><code>Entry</code></i></big>&#65288;&#38544;&#21547;&#20851;&#32852;&#21040;<big><code>Key</code></big>&#65289;<i><code></code>&#20803;
&#32032;&#30340;&#24037;&#21378;</i>&#26159;&#19968;&#20010;&#21487;&#40664;&#35748;&#26500;&#36896;&#30340;&#23454;&#20307;&#65292;&#23427;&#21487;&#20197;&#23384;&#21462;&#19981;&#21487;&#21464;&#30340;<big><code>Entry</code></big>&#31867;&#22411;&#30340;&#20803;&#32032;&#12290;&#19968;
&#20010;&#24037;&#21378;&#21463;&#23450;&#20041;&#22312;<big><code>Key</code></big>&#19978;&#30340;&#30456;&#31561;&#20851;&#31995;&#25903;&#37197;&#65292;2&#20010;&#21487;&#20197;&#36716;&#25442;&#21040;&#30456;&#21516;<big><code>Key</code>s</big>&#30340;<big><code>Entry</code></big>&#23545;&#35937;&#19981;&#33021;&#21516;&#26102;&#23384;&#20648;&#22312;&#24037;&#21378;&#37324;&#12290;&#19981;&#21516;&#30340;&#24037;&#21378;&#31867;&#22411;&#21487;&#20197;&#20351;&#29992;&#19981;&#21516;&#30340;&#30456;&#31561;&#20851;&#31995;&#12290;
</p>



<p>
In the following table, <code>Factory</code> is a factory
of elements
of type <code>Entry</code>, <code>f</code>
denotes an object of type <code>Factory</code>,
<code>x</code> is an object of type <code>Entry</code>
and <code>h</code> is a
value of <code>Factory::handle_type</code>.
</p>



<p style="text-align: left;">
&#22312;&#19979;&#38754;&#36825;&#20010;&#34920;&#26684;&#37324;&#65292;<big><code>Factory</code></big>&#26159;&#19968;&#20010;<big><code>Entry</code></big>&#31867;
&#22411;&#20803;&#32032;&#30340;&#24037;&#21378;&#65292;<big><code>f</code></big>&#20195;&#34920;&#19968;&#20010;<big><code>Factory</code></big>&#31867;&#22411;&#30340;
&#23545;&#35937;&#65292;<big><code>x</code></big>&#26159;&#19968;&#20010;<big><code>Entry</code></big>&#31867;&#22411;&#30340;&#23545;&#35937;&#32780;<big><code>h</code></big>&#26159;<big><code>Factory::handle_type</code></big>&#31867;
&#22411;&#30340;&#20540;&#12290;</p>



<table cellspacing="0">



  <caption><b>Factory requirements.</b></caption>
  <tbody>



    <tr>



      <th align="center">expression</th>



      <th align="center">return type</th>



      <th align="center">assertion/note<br>



pre/post-condition</th>



    </tr>



    <tr>



      <td><code>Factory::handle_type</code></td>



      <td>handle to elements of type <code>T</code><br>



stored in the factory </td>



      <td><code>handle_type</code> is <a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>
and its copy and<br>



assignment operations never throw an exception.<br>



      <code>handle_type</code>&#26159;<a href="http://www.sgi.com/tech/stl/Assignable.html">&#21487;&#36171;&#20540;&#30340;</a>&#32780;
&#19988;&#23427;&#30340;&#25335;&#36125;&#21644;&#36171;<br>



&#20540;&#25805;&#20316;&#32477;&#19981;&#20250;&#25243;&#20986;&#24322;&#24120; </td>



    </tr>



    <tr class="odd_tr">



      <td><code>f.insert(x);</code></td>



      <td><code>handle_type</code></td>



      <td>Inserts a copy of <code>x</code> if there
is no equivalent entry in <code>f</code>;<br>



returns a handle to the inserted or equivalent element.<br>



&#22914;&#26524;<code>f</code>&#37324;&#27809;&#26377;&#30456;&#31561;&#30340;entry&#25554;&#20837;&#19968;&#20010;<code>x</code>&#30340;&#25335;
&#36125;&#65307;&#36820;<br>



&#22238;&#19968;&#20010;&#21040;&#25554;&#20837;&#30340;&#25110;&#32773;&#30456;&#31561;&#30340;&#20803;&#32032;&#30340;&#21477;&#26564; </td>



    </tr>



    <tr>



      <td><code>f.erase(h);</code></td>



      <td><code>void</code></td>



      <td>Erases the element associated to <code>h</code>.<br>



This operation does not throw.<br>



&#28165;&#38500;&#20851;&#32852;&#21040;<code>h</code>&#30340;&#20803;&#32032;&#12290;&#36825;&#20010;&#25805;&#20316;&#19981;&#25243;&#20986;&#24322;&#24120; </td>



    </tr>



    <tr class="odd_tr">



      <td><code>f.entry(h);</code></td>



      <td><code>const Entry&amp;</code></td>



      <td>Returns a reference to the element associated to <code>h</code>.<br>



This operation does not throw.<br>



&#36820;&#22238;&#20851;&#32852;&#21040;<code>h</code>&#30340;&#20803;&#32032;&#30340;&#24341;&#29992;&#12290;&#36825;&#20010;&#25805;&#20316;&#19981;&#25243;&#20986;&#24322;&#24120; </td>



    </tr>



  
  
  </tbody>
</table>



<p>
Additionally to the basic thread safety guarantee which is implicitly
assumed
for most classes including the majority of components of the
C++ standard library, it is required that the member function <code>entry</code>
can be invoked simultaneously from different threads, even in the
presence
of concurrent accesses to <code>insert</code> and <code>erase</code>
(as long
as the entry returned by <code>entry</code> is not the one
which is being
erased).</p>



<p>&#38500;&#24320;&#22823;&#22810;&#25968;&#31867;&#22411;&#21253;&#25324;C++&#26631;&#20934;&#24211;&#30340;&#22823;&#37096;&#20998;&#32452;&#20214;&#38544;&#21547;&#20551;&#35774;&#30340;&#22522;&#26412;&#32447;&#31243;&#23433;&#20840;&#20445;&#35777;&#20197;&#22806;&#65292;&#36824;&#35201;&#27714;&#25104;&#21592;&#20989;&#25968;<big><code>entry</code></big>&#21487;
&#20197;&#21516;&#26102;&#20174;&#19981;&#21516;&#30340;&#32447;&#31243;&#37324;&#35843;&#29992;&#65292;&#21363;&#20351;&#26159;&#22312;&#24182;&#21457;&#30340;&#35775;&#38382;<big><code>insert</code></big>&#21644;<big><code>erase</code></big>&#30340;
&#24773;&#20917;&#19979;&#65288;&#21482;&#35201;<big><code>entry</code></big>&#20989;&#25968;&#36820;&#22238;&#30340;entry&#19981;&#26159;&#27491;&#22312;&#34987;&#28165;&#38500;&#30340;&#37027;&#20010;&#65289;&#12290;
</p>



<p>
A type <code>S</code> is said to be a <i>factory
specifier</i> if: &nbsp;&#19968;&#20010;&#31867;&#22411;<code>S</code>&#34987;&#31216;&#20026;&#26159;&#19968;&#20010;<span style="font-style: italic;">&#24037;&#21378;&#25551;&#36848;&#31526;</span>&#22914;&#26524;&#65306;
</p>



<ol>



  <li>One of the following conditions is satisfied:
&nbsp;&#28385;&#36275;&#20197;&#19979;&#26465;&#20214;&#20043;&#19968;&#65306;
    
    
    <ol type="a">



      <li><a href="#is_factory"><code>is_factory&lt;S&gt;::type</code></a>
is <a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a>,
&nbsp;<a href="factories.html#is_factory"><code>is_factory&lt;S&gt;::type</code></a>
&#26159; <a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a></li>



      <li><code>S</code> is of the form <a href="#factory_construct"><code>factory&lt;S'&gt;</code></a>.
        <code>S</code>&#30340;&#26684;&#24335;&#26159;<a href="factories.html#factory_construct"><code>factory&lt;S'&gt;</code></a></li>



    
    
    </ol>



  </li>



  <li><code>S</code>, or <code>S'</code>
if (b) applies, is an <a href="../../../mpl/doc/refmanual/lambda-expression.html"><code>MPL
Lambda Expression</code></a> such that invoking it with
types (<code>Entry</code>, <code>Key</code>)
resolves to a factory type of <code>Entry</code> elements
(implicitly associated to <code>Key</code>).</li>



</ol>



<div style="margin-left: 40px;"><code>S</code>&#65292;
&#25110;&#32773;<code>S'</code>&#22914;&#26524;&#26465;&#20214;b&#36866;&#29992;&#65292;&#26159;&#19968;&#20010;<a href="../../../mpl/doc/refmanual/lambda-expression.html"><code><big>MPL
Lambda</big> <big>&#34920;&#36798;&#24335;</big></code></a>&#65292;&#24403;&#29992;&#31867;&#22411;&#65288;<big><code>Entry&#65292;</code>
<code>Key</code></big>&#65289;&#35843;&#29992;&#26102;&#29983;&#25104;&#19968;&#20010;<big><code>Entry</code></big>&#20803;&#32032;&#65288;&#38544;&#21547;&#20851;
&#32852;&#21040;<big><code>Key</code></big>&#65289;&#30340;&#24037;&#21378;&#31867;&#22411;&#12290;</div>



<h2><a name="factory_tag_synopsis">Header
</a><a href="../../../../boost/flyweight/factory_tag.hpp"><code>"boost/flyweight/factory_tag.hpp"</code></a>
synopsis &nbsp;</h2>



<h2>&#22836;&#25991;&#20214;<a href="file:///boost/flyweight/factory_tag.hpp"><code>"boost/flyweight/factory_tag.hpp"</code></a>&#22823;
&#24847;</h2>



<blockquote>
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">struct</span> <span class="identifier">factory_marker</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">is_factory</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><span class="special">}</span> <span class="comment">// namespace boost</span>  </pre>



</blockquote>



<h3><a name="is_factory">Class template <code>is_factory
&nbsp;&#31867;&#27169;&#26495; is_factory</code></a></h3>



<p>
Unless specialized by the user, <code>is_factory&lt;T&gt;::type</code>
is
<a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a>
if <code>T</code> is derived from <code>factory_marker</code>,
and it is
<a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::false_</code></a>
otherwise.</p>



<p>&#38500;&#38750;&#29992;&#25143;&#36827;&#34892;&#19987;&#38376;&#21270;&#65292;&#22914;&#26524;<big><code>T</code></big>&#26159;&#20174;<big><code>factory_marker</code></big>&#27966;
&#29983;&#30340;&#65292;<big><code>is_factory&lt;T&gt;::type</code></big>&#26159;<big><a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a></big>&#65292;
&#21542;&#21017;&#26159;<big><a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::false_</code></a></big>&#12290;<a href="../../../mpl/doc/refmanual/bool.html"><code></code></a>
</p>



<h3><a name="factory_construct">Class template <code>factory
&nbsp;&#31867;&#27169;&#26495; factory</code></a></h3>



<p>
<code>factory&lt;T&gt;</code> is a syntactic
construct meant to indicate
that <code>T</code> is a factory specifier without
resorting to the
mechanisms provided by the <code>is_factory</code> class
template.</p>



<p><big><code>factory&lt;T&gt;</code></big>&#26159;&#19968;&#31181;&#34920;&#26126;<code>T</code>&#26159;
&#19968;&#20010;&#24037;&#21378;&#25551;&#36848;&#31526;&#30340;&#35821;&#27861;&#26500;&#36896;&#65292;&#36825;&#26679;&#23601;&#19981;&#38656;&#35201;&#20511;&#21161;&#20110;<big><code>is_factory</code></big>&#31867;&#27169;&#26495;&#25552;&#20379;&#30340;&#26426;&#21046;&#12290;
</p>



<h2><a name="hashed_factory_fwd_synopsis">Header
</a><a href="../../../../boost/flyweight/hashed_factory_fwd.hpp"><code>"boost/flyweight/hashed_factory_fwd.hpp"</code></a>
synopsis &nbsp;</h2>



<h2>&#22836;&#25991;&#20214;<a href="file:///boost/flyweight/hashed_factory_fwd.hpp"><code>"boost/flyweight/hashed_factory_fwd.hpp"</code></a>&#22823;
&#24847;</h2>



<blockquote>
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Hash</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Pred</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">hashed_factory_class</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Hash</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp;&nbsp;typename</span> <span class="identifier">Pred</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">hashed_factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><br><span class="special">}</span> <span class="comment">// namespace boost</span>  </pre>



</blockquote>



<p>
<code>hashed_factory_fwd.hpp</code> forward declares the
class templates
<a href="#hashed_factory_class"><code>hashed_factory_class</code></a>
and <a href="#hashed_factory"><code>hashed_factory</code></a>.</p>



<p><big><code>hashed_factory_fwd.hpp</code></big>&#21069;&#32622;&#22768;&#26126;&#20102;&#31867;&#27169;&#26495;<big><a href="factories.html#hashed_factory_class"><code>hashed_factory_class</code></a></big>&#21644;<big><a href="factories.html#hashed_factory"><code>hashed_factory</code></a></big>
</p>



<h2><a name="hashed_factory_synopsis">Header
</a><a href="../../../../boost/flyweight/hashed_factory.hpp"><code>"boost/flyweight/hashed_factory.hpp"</code></a>
synopsis &nbsp;</h2>



<h2>&#22836;&#25991;&#20214;<a href="file:///boost/flyweight/hashed_factory.hpp"><code>"boost/flyweight/hashed_factory.hpp"</code></a>&#22823;
&#24847;</h2>



<h3><a name="hashed_factory_class">Class template <code>hashed_factory_class
&nbsp;&#31867;&#27169;&#26495; hashed_factory_class</code></a></h3>



<p>
<code>hashed_factory_class</code> is a <a href="#factory"><code>Factory</code></a>
implemented with a hashed container.</p>



<p><big><code>hashed_factory_class</code></big>&#26159;&#19968;&#20010;&#29992;&#21704;&#35199;&#23481;&#22120;&#23454;&#29616;&#30340;<a href="#factory">&#24037;&#21378;</a>
</p>



<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Hash</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Pred</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">hashed_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <b>implementation defined</b> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span>  </pre>



</blockquote>



<p>
<code>Hash</code> is a
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a>
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary
Function</code></a>
taking a single argument of type <code>Key</code> and
returning a
value of type <code>std::size_t</code> in the range
<code>[0, std::numeric_limits&lt;std::size_t&gt;::max())</code>.
<code>Pred</code> is a
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a> <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
<code>Binary Predicate</code></a> inducing an
equivalence relation
on elements of <code>Key</code>. It is required that
a <code>Hash</code> object return the same value for
objects
equivalent under <code>Pred</code>.
The equivalence relation on <code>Key</code> associated to
the factory is
that induced by <code>Pred</code>.
The default arguments for <code>Hash</code> and <code>Pred</code>
are
<a href="../../../functional/hash/index.html"><code>boost::hash&lt;Key&gt;</code></a>
and <code>std::equal_to&lt;Key&gt;</code>,
respectively. <code>Allocator</code> must be an allocator
of <code>Entry</code> objects
satisfying the associated C++ requirements at <b>[lib.allocator.requirements]</b>.
The default argument is <code>std::allocator&lt;Entry&gt;</code>.
The internal
hashed container upon which <code>hashed_factory_class</code>
is based is
constructed with default initialized objects of type <code>Hash</code>,
<code>Pred</code> and <code>Allocator</code>.</p>



<p><big><code>Hash</code></big>&#26159;&#19968;&#20010;<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">&#21487;
&#40664;&#35748;&#26500;&#36896;</a>&#30340;<a href="http://www.sgi.com/tech/stl/UnaryFunction.html">&#19968;&#20803;&#20989;&#25968;</a>&#65292;
&#24102;&#19968;&#20010;<big><code>Key</code></big>&#31867;&#22411;&#30340;&#21442;&#25968;&#36820;&#22238;&#19968;&#20010;<big><code>[0,
std::numeric_limits&lt;std::size_t&gt;::max())</code></big>&#33539;&#22260;&#30340;<big><code>std::size_t</code></big>&#31867;
&#22411;&#30340;&#20540;&#12290;<big><code>Pred</code></big>&#26159;&#19968;&#20010;&#21487;&#40664;&#35748;&#26500;&#36896;&#30340;&#20108;&#20803;&#35859;&#35789;&#21028;&#26029;<big><code>Key</code></big>&#20803;
&#32032;&#30340;&#30456;&#31561;&#20851;&#31995;&#12290;&#35201;&#27714;&#23545;&#20110;&#20351;&#29992;<big><code>Pred</code></big>&#21028;&#26029;&#30456;&#31561;&#30340;&#23545;&#35937;<big><code>Hash</code></big>&#23545;
&#35937;&#36820;&#22238;&#30456;&#21516;&#30340;&#20540;&#12290;&#19982;&#24037;&#21378;&#30456;&#20851;&#30340;<big><code>Key</code></big>&#19978;&#30340;&#30456;&#31561;&#20851;&#31995;&#26159;&#30001;<big><code>Pred</code></big>&#24471;
&#20986;&#12290;<big><code>Hash</code></big>&#21644;<big><code>Pred</code></big>&#30340;&#40664;&#35748;&#21442;&#25968;&#20998;&#21035;&#26159;<big><a href="../../../functional/hash/index.html"><code>boost::hash&lt;Key&gt;</code></a></big>
&#21644; <code><big>std::equal_to&lt;Key&gt;</big></code>&#12290;<big><code>Allocator</code></big>&#24517;
&#39035;&#26159;&#28385;&#36275;<b>[lib.allocator.requirements]</b>&#37324;&#30340;&#30456;&#20851;C++&#35201;&#27714;&#30340;<big><code>Entry</code></big>&#23545;
&#35937;&#30340;&#20998;&#37197;&#22120;&#12290;&#40664;&#35748;&#30340;&#21442;&#25968;&#26159;<big><code>std::allocator&lt;Entry&gt;</code><code></code></big>&#12290;<big><code>hashed_factory_class</code></big>&#22522;
&#20110;&#30340;&#20869;&#37096;&#21704;&#35199;&#23481;&#22120;&#26159;&#29992;<big><code>Hash</code></big>&#65292;<big><code>Pred</code></big> &#21644;
<big><code>Allocator</code></big>&#31867;&#22411;&#30340;&#40664;&#35748;&#21021;&#22987;&#21270;&#23545;&#35937;&#21019;&#24314;&#30340;&#12290;
</p>



<h3><a name="hashed_factory">Class template <code>hashed_factory
&nbsp;&#31867;&#27169;&#26495; &nbsp;hashed_factory</code></a></h3>



<p>
<a href="#factory"><code>Factory Specifier</code></a>
for <a href="#hashed_factory_class"><code>hashed_factory_class</code></a>.</p>



<p><big><a href="factories.html#hashed_factory_class"><code>hashed_factory_class</code></a></big>&#30340;<a href="#factory">&#24037;&#21378;&#25551;&#36848;&#31526;</a>
</p>



<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Hash</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Pred</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">hashed_factory</span><span class="special">;</span>  </pre>



</blockquote>



<p>
<code>hashed_factory&lt;Hash,Pred,Allocator&gt;</code>
is an
<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL
Metafunction
Class</code></a> such that the type</p>



<p><big><code>hashed_factory&lt;Hash,Pred,Allocator&gt;</code></big>&#26159;
&#19968;&#20010;<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL
<big>&#20803;&#20989;&#25968;&#31867;</big></code></a>&#65292;&#20110;&#26159;&#31867;&#22411;
</p>



<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier">  hashed_factory</span><span class="special">&lt;</span><span class="identifier">Hash</span><span class="special">,</span><span class="identifier">Pred</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier">  Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span>  </pre>



</blockquote>



<p>
is the same as</p>



<p>&#31561;&#21516;&#20110;
</p>



<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier">  hashed_factory_class</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span><span class="identifier">Hash</span><span class="special">,</span><span class="identifier">Pred</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier">  Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span>  </pre>



</blockquote>



<p>
This implies that <code>Hash</code>, <code>Pred</code>
and <code>Allocator</code>
can be <a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
Placeholder Expressions</code></a> resolving to the actual
types used by
<code>hashed_factory_class</code>.</p>



<p>&#36825;&#26263;&#31034;&#30528;<big><code>Hash</code></big>, <big><code>Pred</code></big>
&#21644; <big><code>Allocator</code></big>&#21487;&#20197;&#26159;<a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
<big>&#21344;&#20301;&#31526;&#34920;&#36798;&#24335;</big></code></a><code><big>&#65292;&#29983;
&#25104;</big></code><big><code>hashed_factory_class</code></big><code><big>&#29992;
&#21040;&#30340;&#23454;&#38469;&#31867;&#22411;</big></code>
</p>



<h2><a name="set_factory_fwd_synopsis">Header
</a><a href="../../../../boost/flyweight/set_factory_fwd.hpp"><code>"boost/flyweight/set_factory_fwd.hpp"</code></a>
synopsis &nbsp;</h2>



<h2>&#22836;&#25991;&#20214;<a href="file:///boost/flyweight/set_factory_fwd.hpp"><code>"boost/flyweight/set_factory_fwd.hpp"</code></a>&#22823;
&#24847;</h2>



<blockquote>
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Compare</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">set_factory_class</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Compare</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">set_factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><br><span class="special">}</span> <span class="comment">// namespace boost</span>  </pre>



</blockquote>



<p>
<code>set_factory_fwd.hpp</code> forward declares the class
templates
<a href="#set_factory_class"><code>set_factory_class</code></a>
and <a href="#set_factory"><code>set_factory</code></a>.</p>



<p><big><code>set_factory_fwd.hpp</code></big>&#21069;&#32622;&#22768;&#26126;&#20102;&#31867;&#27169;&#26495;<big><a href="factories.html#set_factory_class"><code>set_factory_class</code></a></big>
&#21644; <big><a href="factories.html#set_factory"><code>set_factory</code></a></big>
</p>



<h2><a name="set_factory_synopsis">Header
</a><a href="../../../../boost/flyweight/set_factory.hpp"><code>"boost/flyweight/set_factory.hpp"</code></a>
synopsis &nbsp;</h2>
<h2>&#22836;&#25991;&#20214;<a href="../../../../boost/flyweight/set_factory.hpp"><code>"boost/flyweight/set_factory.hpp"</code></a>&#22823;&#24847;</h2>



<h3><a name="set_factory_class">Class template <code>set_factory_class &nbsp;&#31867;&#27169;&#26495; set_factory_class</code></a></h3>



<p>
<code>set_factory_class</code> is a <a href="#factory"><code>Factory</code></a>
implemented on top of an orderded associative container.</p>



<p><big><code>set_factory_class</code></big>&#26159;&#19968;&#20010;&#22522;&#20110;&#26377;&#24207;&#20851;&#32852;&#23481;&#22120;&#23454;&#29616;&#30340;<a href="#factory">&#24037;&#21378;</a>
</p>



<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Compare</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">set_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <b>implementation defined</b> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span>  </pre>



</blockquote>



<p>
<code>Compare</code> is a <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a>
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code>Strict
Weak Ordering</code></a> on <code>Key</code>.
Two <code>Key</code>s
<code>x</code> and <code>y</code> are
considered equivalent if
<code>!c(x,y)&amp;&amp;!c(y,x)</code> for <code>c</code>
of type <code>Compare</code>.
The default argument of <code>Compare</code> is <code>std::less&lt;Key&gt;</code>.
<code>Allocator</code> must be an allocator of <code>Entry</code>
objects
satisfying the associated C++ requirements at <b>[lib.allocator.requirements]</b>.
The default argument is <code>std::allocator&lt;Entry&gt;</code>.
The internal
container upon which <code>set_factory_class</code> is
based is
constructed with default initialized objects of type <code>Compare</code>
and <code>Allocator</code>.</p>



<p><big><code>Compare</code></big>&#26159;&#19968;&#20010;<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">&#21487;
&#40664;&#35748;&#26500;&#36896;</a>&#32780;&#19988;&#22312;<big><code>Key</code></big>&#19978;<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">&#20005;&#26684;
&#24369;&#24207;</a>&#30340;&#31867;&#22411;&#12290;&#22914;&#26524;&#23545;<big><code>Compare</code></big>&#31867;
&#22411;&#30340;<big><code>c</code></big>&#31867;&#26469;&#35828;<big><code>!c(x,y)&amp;&amp;!c(y,
x)</code></big>&#65292;2&#20010;<big><code>Key</code>s
<code>x</code></big> &#21644;<big><code>y</code></big>&#34987;&#30475;&#20316;&#30456;&#31561;<code>&#12290;</code><big><code>Compare</code></big>&#30340;&#40664;&#35748;&#21442;&#25968;&#26159;<big><code>std::less&lt;Key&gt;</code></big>&#12290;<big><code>Allocator</code></big>&#24517;&#39035;&#26159;&#28385;&#36275;<b>[lib.allocator.requirements]</b>&#37324;
&#30340;&#30456;&#20851;C++&#35201;&#27714;&#30340;<big><code>Entry</code></big>&#23545;&#35937;&#30340;&#20998;&#37197;&#22120;&#12290;&#40664;&#35748;&#30340;&#21442;&#25968;&#26159;<big><code>std::allocator&lt;Entry&gt;</code></big><code>&#12290;</code><code></code><code></code><big><code>set_factory_class</code></big>&#22522;
&#20110;&#30340;&#20869;&#37096;&#23481;&#22120;&#26159;&#29992;<big><code>Compare</code></big> &#21644; <big><code>Allocator</code></big>&#31867;
&#22411;&#30340;&#40664;&#35748;&#21021;&#22987;&#21270;&#23545;&#35937;&#21019;&#24314;&#30340;&#12290;<code></code>
</p>



<h3><a name="set_factory">Class template <code>set_factory
&nbsp;&#31867;&#27169;&#26495; set_factory</code></a></h3>



<p>
<a href="#factory"><code>Factory Specifier</code></a>
for <a href="#set_factory_class"><code>set_factory_class</code></a>.</p>



<p><big><a href="factories.html#set_factory_class"><code>set_factory_class</code></a></big>&#30340;<a href="#factory">&#24037;&#21378;&#25551;&#36848;&#31526;</a>
</p>



<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">set_factory</span><span class="special">;</span>  </pre>



</blockquote>



<p>
<code>set_factory&lt;Compare,Allocator&gt;</code>
is an
<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL
Metafunction
Class</code></a> such that the type</p>



<p><big><code>set_factory&lt;Compare,Allocator&gt;</code></big>&#26159;
&#19968;&#20010;<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code><big>MPL</big>
<big>&#20803;&#20989;&#25968;&#31867;</big></code></a>&#65292;&#20110;&#26159;&#31867;&#22411;<br>



</p>



<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier">  set_factory</span><span class="special">&lt;</span><span class="identifier">Compare</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier">  Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span>  </pre>



</blockquote>



<p>
is the same as</p>



<p>&#31561;&#21516;&#20110;
</p>



<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier">  set_factory_class</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span><span class="identifier">Compare</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier">  Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span>  </pre>



</blockquote>



<p>
This implies that <code>Compare</code> and <code>Allocator</code>
can be <a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
Placeholder Expressions</code></a> resolving to the actual
types used by
<code>set_factory_class</code>.</p>



<p>&#36825;&#26263;&#31034;&#30528;<big><code>Compare</code></big> &#21644; <big><code>Allocator</code></big>&#21487;
&#20197;&#26159;<a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
<big>&#21344;&#20301;&#31526;&#34920;&#36798;&#24335;</big></code></a><code><big>&#65292;</big></code><code><big>&#29983;</big></code><code><big>&#25104;</big></code><big><code>set_factory_class</code></big><code><big>&#29992;
&#21040;&#30340;&#23454;&#38469;&#31867;&#22411;</big></code>
</p>



<h2><a name="assoc_container_factory_fwd_synopsis">Header
</a><a href="../../../../boost/flyweight/assoc_container_factory_fwd.hpp"><code>"boost/flyweight/assoc_container_factory_fwd.hpp"</code></a>
synopsis &nbsp;</h2>



<h2>&#22836;&#25991;&#20214;<a href="file:///boost/flyweight/assoc_container_factory_fwd.hpp"><code>"boost/flyweight/assoc_container_factory_fwd.hpp"</code></a>&#22823;
&#24847;</h2>



<blockquote>
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">assoc_container_factory_class</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ContainerSpecifier</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">assoc_container_factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><br><span class="special">}</span> <span class="comment">// namespace boost</span>  </pre>



</blockquote>



<p>
<code>assoc_container_factory_fwd.hpp</code> forward
declares the class templates
<a href="#assoc_container_factory_class"><code>assoc_container_factory_class</code></a>
and <a href="#assoc_container_factory"><code>assoc_container_factory</code></a>.</p>



<p><big><code>assoc_container_factory_fwd.hpp</code></big>&#21069;&#32622;&#22768;&#26126;&#20102;&#31867;&#27169;
&#26495;<big><a href="factories.html#assoc_container_factory_class"><code>assoc_container_factory_class</code></a></big>
&#21644; <big><a href="factories.html#assoc_container_factory"><code>assoc_container_factory</code></a></big>
</p>



<h2><a name="assoc_container_factory_synopsis">Header
</a><a href="../../../../boost/flyweight/assoc_container_factory.hpp"><code>"boost/flyweight/assoc_container_factory.hpp"</code></a>
synopsis &nbsp;</h2>



<h2>&#22836;&#25991;&#20214;<a href="file:///boost/flyweight/assoc_container_factory.hpp"><code>"boost/flyweight/assoc_container_factory.hpp"</code></a>&#22823;
&#24847;</h2>



<h3><a name="assoc_container_factory_class">Class
template <code>assoc_container_factory_class &nbsp;&#31867;&#27169;&#26495;
&nbsp;assoc_container_factory_class</code></a></h3>



<p>
<code>assoc_container_factory_class</code> wraps a suitable
associative container
to provide a <a href="#factory"><code>Factory</code></a>
interface.</p>



<p><big><code>assoc_container_factory_class</code></big>&#21253;&#35013;&#20102;&#19968;&#20010;&#21512;&#36866;&#30340;&#20851;
&#32852;&#23481;&#22120;&#29992;&#26469;&#25552;&#20379;<a href="#factory">&#24037;&#21378;</a>&#30340;&#30028;&#38754;
</p>



<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">assoc_container_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span>  </pre>



</blockquote>



<p>
<code>Container</code> must be an (ordered or unordered)
associative container
such that &nbsp;<code>Container</code>&#24517;&#39035;&#26159;&#19968;&#20010;&#65288;&#26377;&#24207;&#30340;&#25110;&#32773;&#26080;&#24207;&#30340;&#65289;&#20851;&#32852;&#23481;
&#22120;&#65292;&#35813;&#23481;&#22120;&#28385;&#36275;
</p>



<ol>



  <li><code>Container::key_type</code> is the same as
    <code>Container::value_type</code> (which is the entry
type associated to the factory). </li>



  
  
  <p><big><code>Container::key_type</code></big>&#31561;&#21516;&#20110;<big><code>Container::value_type</code></big>&#65288;&#23427;&#26159;&#30456;&#20851;&#24037;&#21378;&#30340;entry&#31867;&#22411;&#65289;</p>



  <li>Unique keys (rather than equivalent keys) are supported.</li>



  
  
  <p>&#25903;&#25345;&#21807;&#19968;&#30340;keys&#65288;&#32780;&#38750;&#30456;&#31561;&#30340;key&#65289;</p>



  <li><code>Container</code> is <i>stable</i>,
i.e. its iterators are not invalidated upon insert or erase operations.</li>



  
  
  <p>&#23481;&#22120;&#26159;<span style="font-style: italic;">&#31283;&#23450;&#30340;</span>&#65292;&#23601;&#26159;&#35828;&#65292;&#25554;&#20837;&#21644;&#21024;&#38500;&#25805;&#20316;&#20043;&#21518;&#23427;&#30340;&#36845;&#20195;&#22120;&#20381;&#28982;&#26377;&#25928;<code></code><br>


  </p>



</ol>




The equivalence relation associated to <code>assoc_container_factory_class</code>
is the one induced by <code>Container</code>. If
equivalence of elements
of <code>Container::value_type</code> is determined solely
on the basis of a
type <code>value_type'</code> to which <code>value_type</code>
is
implicitly convertible, then <code>assoc_container_factory_class</code>
is
a factory of entries of type <code>value_type</code>
implicitly associated to
<code>value_type'</code>. For example, the instantiation<br>


<code></code><br>


<big><code>assoc_container_factory_class</code></big>&#19978;&#30340;&#30456;&#31561;&#20851;&#31995;&#30001;<big><code>Container</code></big>&#23548;&#20986;&#12290;&#22914;&#26524;<big><code>Container::value_type</code></big>&#20803;&#32032;&#30340;&#30456;&#31561;&#20851;&#31995;&#23436;&#20840;&#30001;&#31867;&#22411;<big><code>value_type'</code></big>&#20915;&#23450;&#65292;&#32780;&#19988;<big><code>value_type</code></big>&#21487;&#20197;&#38544;&#24335;&#36716;&#25442;&#25104;<code><big>value_type'</big>&#65292;</code>&#37027;&#20040;<big><code>assoc_container_factory_class</code></big>&#26159;&#19968;&#20010;&#38544;&#24335;&#20851;&#32852;&#21040;<big><code>value_type'</code></big>&#30340;<big><code>value_type</code></big>&#31867;&#22411;&#20803;&#32032;&#30340;&#24037;&#21378;&#12290;&#20363;&#22914;&#65292;&#36825;&#20010;&#23454;&#20363;
<blockquote>
  
  
  <pre><span class="identifier">assoc_container_factory_class</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">derived</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">base</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="comment">// derived inherits from base</span><br><span class="special">&gt;</span>  </pre>



</blockquote>



<p>
is a factory of <code>derived</code> elements implicitly
associated to
<code>base</code>.</p>


<p>&#26159;&#19968;&#20010;&#38544;&#24335;&#20851;&#32852;&#21040;<big><code>base</code></big>&#30340;<big><code>derived</code></big>&#20803;&#32032;&#30340;&#24037;&#21378;
</p>



<h3><a name="assoc_container_factory">Class template
<code>assoc_container_factory &nbsp;&#31867;&#27169;&#26495; &nbsp;assoc_container_factory</code></a></h3>



<p>
<a href="#factory"><code>Factory Specifier</code></a>
for <a href="#assoc_container_factory_class"><code>assoc_container_factory_class</code></a>.</p>


<p><big><a href="factories.html#assoc_container_factory_class"><code>assoc_container_factory_class</code></a></big>&#30340;<a href="#factory">&#24037;&#21378;&#25551;&#36848;&#31526;</a>
</p>



<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ContainerSpecifier</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">assoc_container_factory</span><span class="special">;</span>  </pre>



</blockquote>



<p>
<code>ContainerSpecifier</code> must be an <a href="../../../mpl/doc/refmanual/lambda-expression.html"><code>MPL
Lambda
Expression</code></a> resolving, when invoked with (<code>Entry</code>,
<code>Key</code>), to a type <code>Container</code>
such that
<code>assoc_container_factory_class&lt;Container&gt;</code>
is a factory
of <code>Entry</code> elements implicitly associated to <code>Key</code>.</p>


<p><big><code>ContainerSpecifier</code></big>&#24517;&#39035;&#26159;&#19968;&#20010;<a href="../../../mpl/doc/refmanual/lambda-expression.html"><code><big>MPL
Lambda</big> <big>&#34920;&#36798;&#24335;</big></code></a>&#65292;&#24403;&#29992;&#65288;<big><code>Entry</code>&#65292;<code>Key</code></big>&#65289;&#35843;&#29992;&#26102;&#65292;&#29983;&#25104;&#19968;&#20010;<code><big>Container</big>&#65292;</code>&#28982;&#21518;<big><code>assoc_container_factory_class&lt;Container&gt;</code></big>&#26159;&#19968;&#20010;<code></code>&#38544;&#24335;&#20851;&#32852;&#21040;<big><code>Key</code></big>&#30340;<big><code>Entry</code></big>&#20803;&#32032;&#30340;&#24037;&#21378;&#65292;
</p>



<hr>
<div class="prev_link"><a href="tags.html"><img src="../prev.gif" alt="tags" border="0"><br>



Tags
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight reference" border="0"><br>



Boost.Flyweight reference
</a></div>



<div class="next_link"><a href="holders.html"><img src="../next.gif" alt="holders" border="0"><br>



Holders
</a></div>



<br style="" clear="all">



<br>



<p>Revised August 13th 2008</p>



<p>&copy; Copyright 2006-2008 Joaqu&iacute;n M
L&oacute;pez Mu&ntilde;oz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>



</body>
</html>

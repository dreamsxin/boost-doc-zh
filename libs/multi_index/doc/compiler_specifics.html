<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html><head>



  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">




  
  
  
  
  
  <title>Boost.MultiIndex Documentation - Compiler specifics</title><link rel="stylesheet" href="style.css" type="text/css">



  
  
  <link rel="start" href="index.html">



  
  
  <link rel="prev" href="reference/key_extraction.html">



  
  
  <link rel="up" href="index.html">



  
  
  <link rel="next" href="performance.html"></head>
<body>



<h1><img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">Boost.MultiIndex 编译器的特性</h1>




<div class="prev_link"><a href="reference/key_extraction.html"><img src="prev.gif" alt="key extraction" border="0"><br>


键提取
</a></div>



<div class="up_link"><a href="index.html"><img src="up.gif" alt="index" border="0"><br>


索引
</a></div>



<div class="next_link"><a href="performance.html"><img src="next.gif" alt="performance" border="0"><br>


性能
</a></div>


<br style="" clear="all">




<hr>

<p>
Boost.MultiIndex 已经在多个不同的编译器中试过，有不同程序的成功。下面我们列出遇到的限制，以及可用时的适合环境中。
</p>




<h2>Contents目录</h2>




<ul>



  <li><a href="#bcb_64">Borland C++ Builder 6.4 及后续版本</a></li><li><a href="#comeau_43101_win_vc7_71">Comeau C/C++ 4.3.10.1 for Windows (VC++ 9.0 
为后端)</a></li><li><a href="#compaq_65">Compaq C++ 6.5-042 for Tru64 UNIX 及后续版本</a></li>



  <li>
    <a href="#gcc_32">GNU GCC 3.2 及后续版本</a>
    
    
    
    <ul>



      <li><a href="#gcc_tru64">GNU GCC for Tru64 UNIX</a></li>



      <li><a href="#gcc_4_darwin">Darwin GCC 4.0</a></li>



    
    
    
    </ul>



  </li>



  <li><a href="#acc_612">HP aC++ A.06.12 for HP-UX</a></li><li><a href="#acc_380_pa_risc">HP aC++ A.03.80 for HP-UX PA-RISC</a></li>



  <li><a href="#va_60">IBM VisualAge C++ V6.0 for AIX</a></li><li><a href="#xl_90">IBM XL C/C++ V9.0 for AIX 及后续版本</a></li><li><a href="#intel_81_lin">Intel C++ Compiler for Linux 8.1 及后续版本</a></li><li><a href="#intel_91_mac">Intel C++ Compiler for Mac OS 9.1 及后续版本</a></li><li><a href="#intel_80_win">Intel C++ Compiler for Windows 32-bit 8.0 及后续版本</a></li><li><a href="#intel_100_win64">Intel C++ Compiler for Windows 64-bit 10.0 及后续版本</a></li><li><a href="#cw_83">Metrowerks CodeWarrior 8.3</a></li>



  <li><a href="#cw_9x">Metrowerks CodeWarrior 9 及后续版本</a></li>



  <li>
    <a href="#msvc_60">Microsoft Visual C++ 6.0 Service Pack 5</a>
    
    
    
    <ul>



      <li><a href="#msvc_60_stlport_453">Microsoft Visual C++ 6.0 Service Pack 5 + STLport 4.5.3 及后续版本</a></li>



    
    
    
    </ul>



  </li>



  <li>
    <a href="#msvc_70">Microsoft Visual C++ 7.0</a>
    
    
    
    <ul>



      <li><a href="#msvc_70_stlport_501">Microsoft Visual C++ 7.0 + STLport 5.0.1</a></li>



    
    
    
    </ul>



  </li>



  <li>
    <a href="#msvc_71">Microsoft Visual C++ 7.1</a></li>



  <li>
    <a href="#msvc_80">Microsoft Visual C++ 8.0 及后续版本</a></li><li><a href="#sun_11">Sun Studio 10 for Solaris 及后续版本</a></li>



  <li><a href="#portability">可移植技术</a>
    
    
    
    <ul>



      <li><a href="#member_offset">使用 <code>member_offset</code></a></li>



      <li><a href="#mem_fun_explicit">使用 <code>const_mem_fun_explicit</code> 和
        <code>mem_fun_explicit</code></a></li>



      <li><a href="#composite_key_no_pts"><code>在无模板偏特化的编译器中的 composite_key</code></a></li>



      <li><a href="#symbol_reduction">缩短符号名长度</a>
        
        
        
        <ul>



          <li><a href="#argument_limitation">最大参数数量的限制</a></li>



          <li><a href="#type_hiding">类型隐藏</a></li>



        
        
        
        </ul>



      </li>



    
    
    
    </ul>



  </li>



</ul>




<h2><a name="bcb_64">Borland C++ Builder 6.4 及后续版本</a></h2>




<p>当前，Boost.MultiIndex 不能用于 BCB 6.4 至 BCB 2006 的任何版本。测试中出现了很多问题，看起来库的未来版本也很难在这个编译器下工作。</p>
<h2><a name="comeau_43101_win_vc7_71">Comeau C/C++ 4.3.10.1 for Windows (VC++ 9.0 为后端)</a></h2>
<p><b>注：</b>最后的测试是在 Boost 1.38. 该信息可能不再准确。</p><p>这个编译器没有发现问题。不过，如果以Microsoft Visual C++
6.0作为后端，则编译失败。最近进行的测试中(Boost.1.34.1), VC++ 7.0/7.1 后端可以正常工作。使用 Comeau
compiler 4.3.10.1 的 beta 2 版本。</p><h2><a name="compaq_65">Compaq C++ 6.5-042 for Tru64 UNIX 及后续版本</a></h2>




<p><b>注：</b>最后的测试是在 Boost 1.38. 该信息可能不再准确。</p><p>没有发现问题。已测试Versions 6.5-042, 7.1-005 和 7.1-006。
</p>




<h2><a name="gcc_32">GNU GCC 3.2 and later</a></h2>




<p>版本3.2以后的几个编译器都没有发现问题。已测试的版本有：</p>

<ul><li>GCC 3.4.3 under Linux x86-64, 
</li><li>GCC 3.4.6 under Linux, 
</li><li>GCC 4.0.1 under Linux x86-64, (Apple Computer, Inc. build 5370), (Apple Inc. 
build 5465) and (Apple Inc. build 5488) under Mac OS, 
</li><li>GCC 4.1.2 20070115 (prerelease) (SUSE Linux) and 20080704 (Red Hat 4.1.2-44) 
under Linux x86-64, 
</li><li>GCC 4.2.1 under Linux x86-64, 20070719 [FreeBSD] under FreeBSD, (Apple Inc. 
build 5564) under Mac OS, 
</li><li>GCC 4.2.4 under Linux x86-64, 
</li><li>GCC 4.3.2 under Linux and Linux x86-64, 
</li><li>GCC 4.3.3 under Linux x86-64 and MinGW, 
</li><li>GCC 4.3.3 gnu++0x under Linux x86-64, 
</li><li>GCC 4.4.0 under Linux x86-64 and MinGW, 
</li><li>GCC 4.4.0 gnu++0x under Linux x86-64.</li></ul>

Boost.MultiIndex 不能工作于版本3.1及之前的GCC。


<h3><a name="gcc_tru64">GNU GCC for Tru64 UNIX</a></h3>




<p>在这个平台上，GCC不能调试长度超过32,768字节的符号名，导致<code>mips-tfile, ... string too big</code>. 
象Boost.MultiIndex这样的重量级模板代码就可能遇到这种情形，因为它常常会产生长符号名。只要不使用选项<code>-g</code> 
(生成调试信息)，就可以避免该问题。此外，不同的应用环境请参考<a href="#symbol_reduction">减少符号名长度</a>一节。
</p>




<h3><a name="gcc_4_darwin">Darwin GCC 4.0</a></h3>




<p>Darwin 8.2 及先前版本 (Mac OS X 10.4.2 及先前版本)带的是GCC 4.0的 Build 4061，对应于GNU GCC 4.0.0 
的预发布版本，有一个 <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=17435">regression 
bug</a>，该缺陷与绑定到临时对象的引用有关。该缺陷影响Boost.MultiIndex <a href="tutorial/debug.html#invariant_check">不变量检查模式</a>的使用。除此之外，Boost.MultiIndex 
工作正常。该缺陷已在GCC 4.0 Apple build 5026中被修正，该版本对应于GNU GCC 4.0.0的官方版本，不变量检查模式可用于该升级版本。
</p>




<h2><a name="acc_612">HP aC++ A.06.12 for HP-UX IA64 及后续版本</a></h2>




<p><b>注：</b>最后的测试是在 Boost 1.38. 该信息可能不再准确。</p><p>没有发现问题。最近测试的版本是 A.06.12。</p>
<h2><a name="acc_380_pa_risc">HP aC++ A.03.80 for HP-UX PA-RISC</a></h2>
<p><b>注：</b>最后的测试是在 Boost 1.38. 该信息可能不再准确。</p><p>没有发现问题。</p>




<h2><a name="va_60">IBM VisualAge C++ V6.0 for AIX</a></h2>




<p>
<span style="font-weight: bold;">注意</span><b>:</b> 这个信息最后对 Boost 1.33.1 做过检查。由于该版本在这个平台上会导致问题，Boost 有可能会修改。
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>
<a href="reference/key_extraction.html#member"><code>member</code></a> 
不被支持，详细情况请参看 <a href="#member_offset">使用 <code>member_offset</code></a> 
一节。<code>member_offset</code> 导致该编译器产生告警：对非POD类型使用 
<code>offset</code><code>of</code>。该告警可以通过设置编译器选项 
<code>-qsuppress=1540-1281</code>来关闭，或者加入以下预处理指令：
</p>




<blockquote>
  
  
  <pre><span class="preprocessor">#pragma</span> <span class="identifier">info</span><span class="special">(</span><span class="identifier">nolan</span><span class="special">)</span>
  </pre>


</blockquote>




<p>不过该pragma指令也可能关闭掉其它与<code>offsetof</code>的使用无关的告警。
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>如Boost.Serialization不被该平台支持一样，则序列化功能也不可用。</p>
<h2><a name="va_90">IBM VisualAge C++ V9.0 for AIX</a></h2>
<p><a href="reference/key_extraction.html#member"><code></code></a>不支持 <a href="reference/key_extraction.html#member"><code>member</code></a>，替代方法参见 <a href="#member_offset">使用 
<code>member_offset</code></a> 一节。<code>member_offset</code> 导致该编译器产生告警：对非POD类型使用 
<code>offset</code><code>of</code>。该告警可以通过设置编译器选项 
<code>-qsuppress=1540-1281</code>来关闭，或者加入以下预处理指令：





</p><blockquote>
  
  
  <pre><span class="preprocessor">#pragma</span> <span class="identifier">info</span><span class="special">(</span><span class="identifier">nolan</span><span class="special">)</span><br>  </pre>


</blockquote>




<p>不过该pragma指令也可能关闭掉其它与<code>offsetof</code>的使用无关的告警。除此之外，使用 Boost.MultiIndex 没有其它问题。</p>
<h2><a name="intel_81_lin">Intel C++ Compiler for Linux 8.1 及后续版本</a></h2>
<p>没有发现问题。已对 9.0 至 
11.0 的编译器版本进行测试。 </p>
<h2><a name="intel_91_mac">Intel C++ Compiler for Mac OS 9.1 及后续版本</a></h2>
<p>没有发现问题。已对 10.1 至 
11.0 的编译器版本进行测试。<br></p><h2><a name="intel_80_win">Intel C++ Compiler for Windows 32-bit 8.0 及后续版本</a></h2>




<p>使用MSVC++ 
7.0或先前版本时，参数相关查找(ADL)缺省是被禁用的。对于很多Boost库，这会引发问题，特别是Boost.MultiIndex的序列化部分。ADL可以通过 
<code>/Qoption,c,--arg_dep_lookup</code> 选项激活。除此之外，Boost.MultiIndex 
没有其它问题。最后测试的编译器版本是 11.1。</p>
<h2><a name="intel_100_win64">Intel C++ Compiler for Windows 64-bit 10.0 and 
later</a></h2><p>没有发现问题。最后测试的编译器版本是 11.1。</p><h2><a name="cw_83">Metrowerks CodeWarrior 8.3</a></h2>




<p><b>说明:</b> 最近的测试为 Boost 1.36。以下信息可能不再准确。 </p><p>以给定类型进行实例化的预定义键提取器不提供派生类型的对象。例如：
</p>




<blockquote>
  
  
  <pre><span class="keyword">struct</span> <span class="identifier">base</span><span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">derived</span><span class="special">:</span><span class="keyword">public</span> <span class="identifier">base</span><span class="special">{};</span>
<span class="special">...</span>

<span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">base</span><span class="special">&gt;</span> <span class="identifier">key_extractor</span><span class="special">;</span>
<span class="identifier">derived</span>        <span class="identifier">x</span><span class="special">;</span>

<span class="comment">// 该编译器不接受：要求显式转型为 base</span>
<span class="identifier">key_extractor</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
  </pre>


</blockquote>




<p>除此以外，Boost.MultiIndex 在两个操作系统 Mac OS 和 Windows 都测试过，没有问题。
</p>




<h2><a name="cw_9x">Metrowerks CodeWarrior 9 及后续版本</a></h2>




<p>
Boost.MultiIndex 从 9.0 到 9.5 版本都工作正常，在两个操作系统 Mac OS 和 Windows 都是如此。
</p>




<h2><a name="msvc_60">Microsoft Visual C++ 6.0 Service Pack 5</a></h2>




<p><b>注：</b>最近的测试在 Boost 1.36 中。这个信息可能不再准确。 </p>
<blockquote>
<hr>
</blockquote>
<p>从 Boost.1.36 开始，Boost.Serialization 不再支持该编译器，因此序列化能力不能再使用。 </p>
<blockquote>
<hr>
</blockquote>


<p><a href="reference/key_extraction.html#member"><code>member</code></a> 
不被支持，详见 <a href="compiler_specifics.html#member_offset">使用 
<code>member_offset</code></a>&nbsp;一节。 </p>


<p><a href="reference/key_extraction.html#const_mem_fun"><code>const_mem_fun</code></a> 
和 <a href="reference/key_extraction.html#mem_fun"><code>mem_fun</code></a> 
不被支持，详见 <a href="#mem_fun_explicit">使用 <code>const_mem_fun_explicit</code> 和 
<code>mem_fun_explicit</code></a> 一节。</p>

<blockquote>
  
  
  <hr></blockquote>




<p>不支持 <a href="reference/multi_index_container.html#index_retrieval">index 
retrieval</a> 和 <a href="reference/multi_index_container.html#projection">projection</a> 
的嵌套类型和成员函数：
</p>


<ul>



  <li><code>nth_index</code>,</li>



  <li><code>index</code>,</li>



  <li><code>nth_index_iterator</code>,</li>



  <li><code>nth_index_const_iterator</code>,</li>



  <li><code>index_iterator</code>,</li>



  <li><code>index_const_iterator</code>,</li>



  <li><code>get</code>,</li>



  <li><code>project</code>.</li>



</ul>

你可以使用它们的全局等价物。另外，这个编译器也没有实现ADL，因此你需要在这些全局名字前加上<code>::boost::multi_index</code>。


<blockquote>
  
  
  <hr></blockquote>




<p>
<code>boost::multi_index::multi_index_container</code> 已通过<code>using</code>声明引入到<code>namespace boost</code>。但是，MSVC++ 
6.0不能完全正确地处理名字的引入。因此，不能写：
</p>




<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index_container</span><span class="special">&lt;...&gt;</span>
  </pre>


</blockquote>




<p>而要这样写：
</p>




<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">multi_index_container</span><span class="special">&lt;...&gt;</span>
  </pre>


</blockquote>




<p>或者采用直接的 <code>using namespace boost::multi_index</code>.
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>由于MSVC++ 6.0不支持模板偏特化，所以在使用<code>composite_key</code>时会不太方便，解决的办法请见 <a href="#composite_key_no_pts">"在无模板偏特化的编译器中使用<code>composite_key</code>"</a>一节。
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>由于函数模板分类支持的问题，<a href="reference/key_extraction.html#composite_key_compare"><code>composite_key_compare</code></a> 及相关类不接受
<code>operator()</code> 的符号变种，其中一个参数为长度为1的 tuple 时。结果用户在指定查找操作的参数时不能省略 tuple。
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>以给定类型进行实例化的预定义键提取器不提供派生类型的对象。例如：
</p>




<blockquote>
  
  
  <pre><span class="keyword">struct</span> <span class="identifier">base</span><span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">derived</span><span class="special">:</span><span class="keyword">public</span> <span class="identifier">base</span><span class="special">{};</span>
<span class="special">...</span>

<span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">base</span><span class="special">&gt;</span> <span class="identifier">key_extractor</span><span class="special">;</span>
<span class="identifier">derived</span>        <span class="identifier">x</span><span class="special">;</span>

<span class="comment">// </span><span class="comment">该编译器不接受：要求显式转型为</span><span class="comment"> base</span>
<span class="identifier">key_extractor</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
  </pre>


</blockquote>




<blockquote>
  
  
  <hr></blockquote>




<p>MSVC++ 6.0 在最大符号名长度方面也存在重大限制，会导致链接错误 <code><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccore98/html/lnk1179.asp">LNK1179</a>: 
invalid or corrupt file: duplicate comdat comdat</code>. 解决该问题的办法请见<a href="#symbol_reduction">缩短符号名长度reduction of symbol name lengths</a> 一节。 
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>在某些情形下，编译器会在MSVC内部头文件<code>&lt;xlocnum&gt;</code>处产生错误 <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccore98/html/C2587.asp"><code>C2587</code></a><code>: 
'_U' : illegal use of local variable as default 
parameter</code>。这是该编译器常见的bug，在其它库中也曾出现过，如 <a href="../../../libs/graph/doc/table_of_contents.html">Boost Graph Library</a>, 
<a href="../../../libs/multi_array/doc/index.html">Boost.MultiArray</a>, <a href="../../../libs/regex/doc/index.html">Boost.Regex</a>, <a href="http://www.cgal.org/">CGAL</a> 和 <a href="http://www.mysql.com/downloads/api-mysql++.html">MySQL++</a>。该错误会在使用<code>multi_index_container</code>的迭代器构造函数时触发。存在两种解决办法：第一种是避免使用该构造函数，将以下代码：
</p>




<blockquote>
  
  
  <pre><span class="identifier">multi_index_container</span><span class="special">&lt;...&gt;</span> <span class="identifier">s</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
  </pre>


</blockquote>




<p>替换为如下等价操作：
</p>




<blockquote>
  
  
  <pre><span class="identifier">multi_index_container</span><span class="special">&lt;...&gt;</span> <span class="identifier">s</span><span class="special">;</span>
<span class="identifier">s</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
  </pre>


</blockquote>




<p>第二种办法还没有得到作者的确认，它是从互联网上其它库的同类错误所提供的。将<code>&lt;xlocnum&gt;</code>的第84行：<code></code>

</p>


<blockquote>
  
  
  <pre> <span class="preprocessor">#define</span> <span class="identifier">_VIRTUAL</span>	<span class="keyword">virtual</span>
  </pre>


</blockquote>




<p>替换如下：
</p>




<blockquote>
  
  
  <pre> <span class="preprocessor">#define</span> <span class="identifier">_VIRTUAL</span>
  </pre>


</blockquote>




<p>
<b>警告：</b>现在还不清楚这种替换方法会否对其它使用<code>&lt;xlocnum&gt;</code>的代码产生副作用。
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>Boost.MultiIndex 中大量使用的模板技术对于编译器而言是重大的考验，很多内部的局限都会被触及。以下办法可以减轻这些问题： </p>


<ul>

  <li>打开编译器选项 <code>/Zm</code> (指定内存分配限制) 以增加编译的可用内存。该选项的正常值为300至800。 
  </li>

  <li>如果是调试模式，请尝试从 <code>/ZI</code> (Program Database for Edit and Continue) 
切换到类型调试信息较少的模式(<code>/Zi</code>, <code>/Z7</code> or <code>/Zd</code>)。 
  </li>

  <li>调整头文件预编译选项。通常关闭该选项会好一些。 
  </li>

  <li>如果编译器报告错误 <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccore98/html/c1055.asp"><code>C1055</code></a><code>: 
compiler limit : out of keys</code>, 试一下关闭选项 <code>/Gm</code> (Enable Minimal 
Rebuild)。这样有利于将项目分割为更小的子项目。</li>

</ul>

<h3>
<a name="msvc_60_stlport_453">Microsoft Visual C++ 6.0 Service Pack 5
+ STLport 4.5.3 及后续版本</a>
</h3>




<p><b>注：</b>最近的测试在 Boost 1.36 中。这个信息可能不再准确。</p><p>Boost.MultiIndex 可以在此配置下工作。与 MSVC++ 6.0 + Dinkumware标准库遇到的限制一样。STLport 4.6.2 
和 5.0.1 也已确认工作正常。</p><h2><a name="msvc_70">Microsoft Visual C++ 7.0</a></h2>




<p>
<b>注：</b>最近的测试在 Boost 1.35 中。以下信息可能不再准确。 </p>
<blockquote>
<hr>
</blockquote>
<p>从 Boost.1.36 开始，Boost.Serialization 不再支持该编译器，因此序列化能力不能再使用。 </p>
<blockquote>
<hr>
</blockquote><a href="reference/key_extraction.html#member"><code>member</code></a> 不被支持，详见 
<a href="#member_offset">使用 <code>member_offset</code></a> 一节。





<blockquote>
  
  
  <hr></blockquote>




<p>不支持 <a href="reference/multi_index_container.html#index_retrieval">index 
retrieval</a> 和 <a href="reference/multi_index_container.html#projection">projection</a> 
的嵌套类型和成员函数：
</p>


<ul>



  <li><code>nth_index</code>,</li>



  <li><code>index</code>,</li>



  <li><code>nth_index_iterator</code>,</li>



  <li><code>nth_index_const_iterator</code>,</li>



  <li><code>index_iterator</code>,</li>



  <li><code>index_const_iterator</code>,</li>



  <li><code>get</code>,</li>



  <li><code>project</code>.</li>



</ul>

你可以使用它们的全局等价物。另外，这个编译器也没有实现ADL，因此你需要在这些全局名字前加上<code>::boost::multi_index</code>。


<blockquote>
  
  
  <hr></blockquote>




<p>
<code>boost::multi_index::multi_index_container</code> 已通过<code>using</code>声明引入到<code>namespace boost</code>。但是，MSVC++ 
7.0不能完全正确地处理名字的引入。因此，不能写：
</p>




<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index_container</span><span class="special">&lt;...&gt;</span>
  </pre>


</blockquote>




<p>而要这样写：
</p>




<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">multi_index_container</span><span class="special">&lt;...&gt;</span>
  </pre>


</blockquote>




<p>或者采用直接的&nbsp;<code>using namespace boost::multi_index</code>.
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>由于MSVC++ 7.0不支持模板偏特化，所以在使用<code>composite_key</code>时会不太方便，解决的办法请见 <a href="#composite_key_no_pts">"在无模板偏特化的编译器中使用<code>composite_key</code>"</a>一节。
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>由于函数模板分类支持的问题，<a href="reference/key_extraction.html#composite_key_compare"><code>composite_key_compare</code></a> 及相关类不接受
<code>operator()</code> 的符号变种，其中一个参数为长度为1的 tuple 时。结果用户在指定查找操作的参数时不能省略 tuple。
</p>




<blockquote>
  
  
  <hr></blockquote>




<p>以给定类型进行实例化的预定义键提取器不提供派生类型的对象。例如：
</p>




<blockquote>
  
  
  <pre><span class="keyword">struct</span> <span class="identifier">base</span><span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">derived</span><span class="special">:</span><span class="keyword">public</span> <span class="identifier">base</span><span class="special">{};</span>
<span class="special">...</span>

<span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">base</span><span class="special">&gt;</span> <span class="identifier">key_extractor</span><span class="special">;</span>
<span class="identifier">derived</span>        <span class="identifier">x</span><span class="special">;</span>

<span class="comment">// </span><span class="comment">该编译器不接受：要求显式转型为</span><span class="comment"> base</span><span class="comment"></span>
<span class="identifier">key_extractor</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
  </pre>


</blockquote>




<h3><a name="msvc_70_stlport_501">Microsoft Visual C++ 7.0 + STLport 5.0.1</a></h3>





<p><b>注:</b> 最后测试的是 Boost 1.35. 这一信息可能不再准确。<br></p><p>Boost.MultiIndex 在此配置下可用。MSVC++ 7.0 + 原本的 Dinkumware 标准库也是如此。 
</p>




<h2><a name="msvc_71">Microsoft Visual C++ 7.1</a></h2>




<p>当使用<code>/Gm</code>选项(Enable Minimal 
Rebuild)编译本库时会有问题。看起来这应该是编译器的内部问题(请见Boost用户邮件列表中的 <a href="http://lists.boost.org/MailArchives/boost-users/msg05988.php">this mention 
of a similar issue</a>)。如果关闭<code>/Gm</code>，Boost.MultiIndex 的编译和运行都没有问题。</p><h2><a name="msvc_80">Microsoft Visual C++ 8.0 及后续版本</a></h2>




<p>没有发现问题，包括32位和64位模式。最后测试的是编译器版本9.0和10.0。</p><h2><a name="sun_11">Sun Studio 10 for Solaris 及后续版本</a></h2>




<p>没有发现问题。以下编译器版本已被测试： 
</p><ul><li>Sun C++ 5.7 Patch 117830-07 2006/03/15 (Sun Studio 10), 
</li><li>Sun C++ 5.8 Patch 121017-09 2007/01/17 (Sun Studio 11), 
</li><li>Sun C++ 5.9 (Sun Studio 12). </li></ul>使用了选项
<code>-library=stlport4</code> 来以 STLport 替换缺省的标准库。





<h2><a name="portability">可移植性技术</a></h2>




<h3><a name="member_offset">使用 <code>member_offset</code></a></h3>




<p><code>member</code> 键提取器在不能正确支持以成员指针为非类型模板参数的编译器上会有问题，正如 <a href="../../../libs/config/config.htm">Boost Configuration Library</a> 的宏 
<code>BOOST_NO_POINTER_TO_MEMBER_TEMPLATE_PARAMETERS</code> 
所指出的一样。以下编译器已被证实不能正确处理 <code>member</code>：
</p>


<ul>



  <li>MSVC++ 6.0/7.0,</li>



  <li>Intel C++ 7.0/7.1 for Windows,</li>



  <li>VisualAge 6.0 for AIX.</li>



</ul>

以下程序可以帮助确认你的编译器是否正确支持以成员指针为非类型模板参数：


<blockquote>
  
  
  <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">pair</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span><span class="identifier">y</span><span class="special">;</span>

  <span class="identifier">pair</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x_</span><span class="special">,</span><span class="keyword">int</span> <span class="identifier">y_</span><span class="special">):</span><span class="identifier">x</span><span class="special">(</span><span class="identifier">x_</span><span class="special">),</span><span class="identifier">y</span><span class="special">(</span><span class="identifier">y_</span><span class="special">){}</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">pair</span><span class="special">::*</span> <span class="identifier">PtrToPairMember</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">foo</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">bar</span><span class="special">(</span><span class="identifier">pair</span><span class="special">&amp;</span> <span class="identifier">p</span><span class="special">){</span><span class="keyword">return</span> <span class="identifier">p</span><span class="special">.*</span><span class="identifier">PtrToPairMember</span><span class="special">;}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
  <span class="identifier">pair</span> <span class="identifier">p</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">);</span>
  <span class="identifier">foo</span><span class="special">&lt;&amp;</span><span class="identifier">pair</span><span class="special">::</span><span class="identifier">x</span><span class="special">&gt;</span> <span class="identifier">fx</span><span class="special">;</span>
  <span class="identifier">foo</span><span class="special">&lt;&amp;</span><span class="identifier">pair</span><span class="special">::</span><span class="identifier">y</span><span class="special">&gt;</span> <span class="identifier">fy</span><span class="special">;</span>

  <span class="keyword">if</span><span class="special">(</span><span class="identifier">fx</span><span class="special">.</span><span class="identifier">bar</span><span class="special">(</span><span class="identifier">p</span><span class="special">)!=</span><span class="number">0</span><span class="special">||</span><span class="identifier">fy</span><span class="special">.</span><span class="identifier">bar</span><span class="special">(</span><span class="identifier">p</span><span class="special">)!=</span><span class="number">1</span><span class="special">)</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"KO"</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="keyword">else</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"OK"</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>

  </pre>


</blockquote>




<p>如果你发现某个编译器不能通过测试，而且其没有定义 
<code>BOOST_NO_POINTER_TO_MEMBER_TEMPLATE_PARAMETERS</code> 宏，请报告到 Boost 
开发者邮件列表。
</p>



<p>为了解决该问题，提供了一个代用工具 <a href="reference/key_extraction.html#member_offset"><code>member_offset</code></a>，它可以完成 
<code>member</code> 
的工作，只是用起来不太方便，而且可能不太符合标准。关于<code>member_offset</code>的详细说明请见“参考”一节。作为示例，给出一个类：
</p>




<blockquote>
  
  
  <pre><span class="keyword">class</span> <span class="identifier">A</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="special">}</span>
  </pre>


</blockquote>




<p>实例化 <code>member&lt;A,int,&amp;A::x&gt;</code> 可以替换为 <code>member_offset&lt;A,int,offsetof(A,x)&gt;</code>.
</p>




<p>为了代码的可移植性，Boost.MultiIndex 提供了三元宏 <a href="reference/key_extraction.html#boost_multi_index_member"><code>BOOST_MULTI_INDEX_MEMBER</code></a>. 
继续上面的例子，表达式：
</p>




<blockquote>
  
  
  <pre><span class="identifier">BOOST_MULTI_INDEX_MEMBER</span><span class="special">(</span><span class="identifier">A</span><span class="special">,</span><span class="keyword">int</span><span class="special">,</span><span class="identifier">x</span><span class="special">)</span>
  </pre>


</blockquote>




<p>缺省被展开为：
</p>




<blockquote>
  
  
  <pre><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="keyword">int</span><span class="special">,&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">x</span><span class="special">&gt;</span>
  </pre>


</blockquote>




<p>或者当<code>BOOST_NO_POINTER_TO_MEMBER_TEMPLATE_PARAMETERS</code>被定义时，展开为：
</p>




<blockquote>
  
  
  <pre><span class="identifier">member_offset</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="keyword">int</span><span class="special">,</span><span class="identifier">offsetof</span><span class="special">(</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">x</span><span class="special">)&gt;</span>
  </pre>


</blockquote>




<p><br>


</p>




<h3><a name="mem_fun_explicit">使用 <code>const_mem_fun_explicit</code> 和
<code>mem_fun_explicit</code></a></h3>




<p>MSVC++ 6.0 在使用 <code>const</code> 成员函数作为非类型模板参数时有问题，因此不能接受 
<code>const_mem_fun</code> 键提取器。一个简单的解决办法是，增加一个模板参数以指定该指针的<span style="font-style: italic;">类型</span>。提取器 <a href="reference/key_extraction.html#const_mem_fun_explicit"><code>const_mem_fun_explicit</code></a> 
用的就是这个办法，例如以下类型：
</p>




<blockquote>
  
  
  <pre><span class="keyword">struct</span> <span class="identifier">A</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">f</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>


</blockquote>




<p>提取器 <code>const_mem_fun&lt;A,int,&amp;A::f&gt;</code> 可以替换为 
<code>const_mem_fun_explicit&lt;A,int,int 
(A::*)()const,&amp;A::f&gt;</code>。另一个类似的 <code>mem_fun_explicit</code> 
类模板可用于非常量成员函数。
</p>




<p>如果你需要跨平台的代码，可以用宏<a href="reference/key_extraction.html#boost_multi_index_const_mem_fun"><code>BOOST_MULTI_INDEX_CONST_MEM_FUN</code></a>来选择使用哪个键提取器，以下宏：
</p>




<blockquote>
  
  
  <pre><span class="identifier">BOOST_MULTI_INDEX_CONST_MEM_FUN</span><span class="special">(</span><span class="identifier">A</span><span class="special">,</span><span class="keyword">int</span><span class="special">,</span><span class="identifier">f</span><span class="special">)</span>
  </pre>


</blockquote>




<p>缺省被展开为：
</p>




<blockquote>
  
  
  <pre><span class="identifier">const_mem_fun</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="keyword">int</span><span class="special">,&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">f</span><span class="special">&gt;</span>
  </pre>


</blockquote>




<p>而在MSVC++ 6.0中则被展开为： 
</p>




<blockquote>
  
  
  <pre><span class="identifier">const_mem_fun_explicit</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="keyword">int</span><span class="special">,</span><span class="keyword">int</span> <span class="special">(</span><span class="identifier">A</span><span class="special">::*)()</span><span class="keyword">const</span><span class="special">,&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">f</span><span class="special">&gt;</span>
  </pre>


</blockquote>




<p>非<code>const</code>成员函数则使用 <a href="reference/key_extraction.html#mem_fun_explicit"><code>mem_fun_explicit</code></a> 
和宏
<a href="reference/key_extraction.html#boost_multi_index_mem_fun"><code>BOOST_MULTI_INDEX_MEM_FUN</code></a>.
</p>




<h3><a name="composite_key_no_pts"><code>在无模板偏特化的编译器中使用 composite_key</code></a></h3>




<p>使用 <code>composite_key</code> 时，要传入多个值的组合以执行查找：这需要为<a href="reference/key_extraction.html#composite_key_result"> 
<code>composite_key_result</code></a>的实例正确地特化类模板 <code>std::equal_to</code>, 
<code>std::less</code>, <code>std::greater</code> 和 
<code>boost::hash</code>，以提供接受 tuple 的正确重载函数——而且对于 <code>std::less</code> 和 
<code>std::greater</code>，还要接受仅有第一部分的组合。
</p>




<p>在不支持模板偏特化的编译器中，这些特化不能得到支持，因此基于组合值的查找缺省情况下无法使用。这种情况下，使用组合键的 
<code>multi_index_container</code> 
实例还可以工作，无论是有序索引还是散列索引，除了其查找操作不能以组合值为参数。对于有序索引，最明显的解决办法是显式地用<a href="reference/key_extraction.html#composite_key_compare"><code>composite_key_compare</code></a>给出比较谓词；对于散列索引，我们可以使用 
<a href="reference/key_extraction.html#composite_key_equal_to"><code>composite_key_equal_to</code></a> 
和 <a href="reference/key_extraction.html#composite_key_hash"><code>composite_key_hash</code></a>。不过这些解决办法都很冗长，需要显式地给出键提取器的所有组合元素。因此，Boost.MultiIndex 
提供了以下替代类模板：
</p>


<ul>



  <li><a href="reference/key_extraction.html#composite_key_result_equal_to">
    <code>composite_key_result_equal_to</code></a>,</li>



  <li><a href="reference/key_extraction.html#composite_key_result_less">
    <code>composite_key_result_less</code></a>,</li>



  <li><a href="reference/key_extraction.html#composite_key_result_greater">
    <code>composite_key_result_greater</code></a> 和</li>



  <li><a href="reference/key_extraction.html#composite_key_result_hash">
    <code>composite_key_result_hash</code></a>,</li>



</ul>

它们替代了<code>composite_key_result</code>的 <code>std::equal_to</code>, 
<code>std::less</code>, <code>std::greater</code> 和 
<code>boost::hash</code>&nbsp;特化。它们可以象以下那样使用：


<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">composite_key</span><span class="special">&lt;</span>
  <span class="identifier">phonebook_entry</span><span class="special">,</span>
  <span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">phonebook_entry</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,&amp;</span><span class="identifier">phonebook_entry</span><span class="special">::</span><span class="identifier">family_name</span><span class="special">&gt;,</span>
  <span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">phonebook_entry</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,&amp;</span><span class="identifier">phonebook_entry</span><span class="special">::</span><span class="identifier">given_name</span><span class="special">&gt;</span>
<span class="special">&gt;</span> <span class="identifier">ckey_t</span><span class="special">;</span>

<span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span>
  <span class="identifier">phonebook_entry</span><span class="special">,</span>
  <span class="identifier">indexed_by</span><span class="special">&lt;</span>
    <span class="identifier">ordered_non_unique</span><span class="special">&lt;</span> <br>      <span class="identifier">ckey_t</span><span class="special">,</span>
      <span class="comment">// composite_key_result_less 替代 std::less&lt;ckey_t::result_type&gt;</span>
      <span class="identifier">composite_key_result_less</span><span class="special">&lt;</span><span class="identifier">ckey_t</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">&gt;</span>
    <span class="special">&gt;,</span>
    <span class="identifier">ordered_unique</span><span class="special">&lt;</span>
      <span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">phonebook_entry</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,&amp;</span><span class="identifier">phonebook_entry</span><span class="special">::</span><span class="identifier">phone_number</span><span class="special">&gt;</span>
    <span class="special">&gt;</span>
  <span class="special">&gt;</span>
<span class="special">&gt;</span> <span class="identifier">phonebook</span><span class="special">;</span>
  </pre>


</blockquote>




<h3><a name="symbol_reduction">缩短符号名长度</a></h3>




<p><code>multi_index_container</code>实例化所产生的类型通常都有很长的符号名，有时会超出编译器的限制。有几个方法可以缩短这些生成的符号名，这些方法还可以使得错误信息更容易读。
</p>




<h4><a name="argument_limitation">参数数量的最大限制</a></h4>




<p>类模板 <a href="reference/indices.html#indexed_by"><code>indexed_by</code></a>, <a href="reference/indices.html#tag"><code>tag</code></a> 和 <a href="reference/key_extraction.html#composite_key"><code>composite_key</code></a>&nbsp;接受可变数量的参数，其最大值通过内部宏限定。即使没有使用的参数也会增加最终类型名字的长度，所以手工调整相应的宏可以明显缩短符号名。
</p>




<p align="center">
</p>
<table cellspacing="0">

  <caption><b>Boost.MultiIndex 的某些类模板的参数数量的最大限制值</b></caption>
  <tbody>
    <tr>

  <th>类模板</th>

  <th>限制宏</th>

  <th>缺省值</th>

  <th>缺省值<br>
(MSVC++ 6.0)</th>

    </tr>

    <tr>

  <td align="center">&nbsp;<code>indexed_by</code>&nbsp;</td>

  <td align="center">&nbsp;<code>BOOST_MULTI_INDEX_LIMIT_INDEXED_BY_SIZE</code>&nbsp;</td>

  <td align="center">20</td>

  <td align="center">5</td>

    </tr>

    <tr class="odd_tr">

  <td align="center">&nbsp;<code>tag</code>&nbsp;</td>

  <td align="center">&nbsp;<code>BOOST_MULTI_INDEX_LIMIT_TAG_SIZE</code>&nbsp;</td>

  <td align="center">20</td>

  <td align="center">3</td>

    </tr>

    <tr>

  <td align="center">&nbsp;<code>composite_key</code>&nbsp;</td>

  <td align="center">&nbsp;<code>BOOST_MULTI_INDEX_LIMIT_COMPOSITE_KEY_SIZE</code>&nbsp;</td>

  <td align="center">10</td>

  <td align="center">5</td>

    </tr>

  </tbody>
</table>





<h4><a name="type_hiding">类型隐藏</a></h4>




<p>考虑以下<code>multi_index_container</code>实例化：
</p>




<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span>
  <span class="identifier">employee</span><span class="special">,</span>
  <span class="identifier">indexed_by</span><span class="special">&lt;</span>
    <span class="identifier">ordered_unique</span><span class="special">&lt;</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
    <span class="identifier">ordered_non_unique</span><span class="special">&lt;</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">name</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
    <span class="identifier">ordered_unique</span><span class="special">&lt;</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span><span class="keyword">int</span><span class="special">,&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">ssnumber</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">&gt;</span>
<span class="special">&gt;</span> <span class="identifier">employee_set</span><span class="special">;</span>
  </pre>


</blockquote>




<p>在GCC中，类型 <code>employee_set::nth_type&lt;0&gt;::type</code> 会被展开如下：
</p>




<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">ordered_index</span><span class="special">&lt;</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;,</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;,</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">nth_layer</span><span class="special">&lt;</span>
    <span class="number">1</span><span class="special">,</span> <span class="identifier">employee</span><span class="special">,</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">indexed_by</span><span class="special">&lt;</span>
      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">ordered_unique</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span>
      <span class="special">&gt;,</span>
      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">ordered_non_unique</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">name</span><span class="special">&gt;,</span>
        <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span>
      <span class="special">&gt;,</span>
      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">ordered_unique</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">ssnumber</span><span class="special">&gt;,</span>
        <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span>
      <span class="special">&gt;,</span>
      <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span>
      <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span>
      <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">,</span> <span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span>
    <span class="special">&gt;,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;</span>
  <span class="special">&gt;,</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">vector0</span><span class="special">&lt;</span><span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">&gt;,</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">ordered_unique_tag</span>
<span class="special">&gt;</span>
  </pre>


</blockquote>




<p>可以看到类型名的主要部分是 <code>indexed_by&lt;...&gt;</code> 
部分，而它只是<code>employee_set</code>定义中的索引说明部分的扩展版本。我们可以防止这种超长名字，方法是将它封装成一个名字短一些的结构：
</p>




<blockquote>
  
  
  <pre><span class="comment">// </span><span class="comment">通</span><span class="comment"></span><span class="comment">过类型隐藏缩短符号名</span><span class="comment"><br>// </span><span class="comment">用</span><span class="comment">employee_set_indices</span><span class="comment">隐藏索引说明列表</span><span class="comment"></span>

<span class="keyword">struct</span> <span class="identifier">employee_set_indices</span><span class="special">:</span>
  <span class="identifier">indexed_by</span><span class="special">&lt;</span>
    <span class="identifier">ordered_unique</span><span class="special">&lt;</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
    <span class="identifier">ordered_non_unique</span><span class="special">&lt;</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">name</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
    <span class="identifier">ordered_unique</span><span class="special">&lt;</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span><span class="keyword">int</span><span class="special">,&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">ssnumber</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span>
  <span class="identifier">employee</span><span class="special">,</span>
  <span class="identifier">employee_set_indices</span>
<span class="special">&gt;</span> <span class="identifier">employee_set</span><span class="special">;</span>
  </pre>


</blockquote>




<p>
<code>employee_set_indices</code> 就象一个常见的 <code>typedef</code> 
那样保存了详细信息，但是它的名字不象<code>indexed_by</code>实例化那样显式包含信息。使用这个方法，<code>employee_set::nth_type&lt;0&gt;::type</code> 
现在变成了：
</p>




<blockquote>
  
  
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">ordered_index</span><span class="special">&lt;</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;,</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;,</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">nth_layer</span><span class="special">&lt;</span>
    <span class="number">1</span><span class="special">,</span> <span class="identifier">employee</span><span class="special">,</span>
    <span class="identifier">employee_set_indices</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;</span>
  <span class="special">&gt;,</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">vector0</span><span class="special">&lt;</span><span class="identifier">mpl_</span><span class="special">::</span><span class="identifier">na</span><span class="special">&gt;,</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">ordered_unique_tag</span>
<span class="special">&gt;</span>
  </pre>


</blockquote>




<p>明显比原先的短了许多，也更易于阅读。如果我们不是将<code>employee_set_indices</code>从<code>struct</code> 
<code>indexed_by&lt;...&gt;</code>继承，而是用<code>typedef</code>，那么类型隐藏将没有用：<code>typedef</code> 
是语法上的别名，编译器在进一步处理之前都要先展开它。 </p>


<p>类型隐藏的方法也可用于同样会产生长名字的 <code>composite_key</code> 实例化。</p>

<hr>

<div class="prev_link"><a href="reference/key_extraction.html"><img src="prev.gif" alt="key extraction" border="0"><br>

键提取
</a></div>



<div class="up_link"><a href="index.html"><img src="up.gif" alt="index" border="0"><br>

索引
</a></div>



<div class="next_link"><a href="performance.html"><img src="next.gif" alt="performance" border="0"><br>

性能
</a></div>


<br style="" clear="all">




<br><p>Revised July 21st 2009</p><p>© Copyright 2003-2009 Joaquín M López Muñoz. Distributed under the Boost 
Software License, Version 1.0. (See accompanying file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</p></body></html>
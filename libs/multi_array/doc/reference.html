<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>







  
  
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">







  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>Boost.MultiArray Reference Manual</title>
  <meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
</head>


<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">







<div class="article" lang="en">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a name="id729900"></a>Boost.MultiArray 参考手册</h1>







</div>







<div>
<div class="author">
<h3 class="author"><span class="firstname">Ronald</span> <span class="surname">Garcia</span></h3>







<div class="affiliation"><span class="orgname">Indiana University<br>







</span><span class="orgdiv">Open Systems Lab<br>







</span></div>







</div>







</div>







<div>
<p class="copyright">Copyright &copy; 2002 The Trustees of Indiana University</p>







</div>







</div>







<hr></div>







<div class="toc">
<p><b>目录</b></p>







<dl>







  <dt><span class="sect1"><a href="#synopsis">本库概要</a></span></dt>







  <dt><span class="sect1"><a href="#MultiArray">MultiArray 概念</a></span></dt>







  <dd>
    
    
    
    
    
    
    
    <dl>







      <dt><span class="sect2"><a href="#id834641">符号</a></span></dt>







      <dt><span class="sect2"><a href="#id834809">相关类型</a></span></dt>







      <dt><span class="sect2"><a href="#id835319">有效表达式</a></span></dt>







      <dt><span class="sect2"><a href="#id836109">复杂度保证</a></span></dt>







      <dt><span class="sect2"><a href="#id836133">不变式</a></span></dt>







      <dt><span class="sect2"><a href="#view_types">视图的相关类型</a></span></dt>







      <dt><span class="sect2"><a href="#id837503">Models</a></span></dt>







    
    
    
    
    
    
    
    </dl>







  </dd>







  <dt><span class="sect1"><a href="#array_types">数组组件</a></span></dt>







  <dd>
    
    
    
    
    
    
    
    <dl>







      <dt><span class="sect2"><a href="#multi_array"><code class="literal">multi_array</code></a></span></dt>







      <dt><span class="sect2"><a href="#multi_array_ref"><code class="literal">multi_array_ref</code></a></span></dt>







      <dt><span class="sect2"><a href="#const_multi_array_ref"><code class="literal">const_multi_array_ref</code></a></span></dt>







    
    
    
    
    
    
    
    </dl>







  </dd>







  <dt><span class="sect1"><a href="#auxiliary">辅助组件</a></span></dt>







  <dd>
    
    
    
    
    
    
    
    <dl>







      <dt><span class="sect2"><a href="#multi_array_types"><code class="literal">multi_array_types</code></a></span></dt>







      <dt><span class="sect2"><a href="#extent_range"><code class="classname">extent_range</code></a></span></dt>







      <dt><span class="sect2"><a href="#extent_gen"><code class="classname">extent_gen</code></a></span></dt>







      <dt><span class="sect2"><a href="#id862083">全局对象</a></span></dt>







      <dt><span class="sect2"><a href="#generators">视图和子数组生成器</a></span></dt>







      <dt><span class="sect2"><a href="#memory_layout">内存布局指示符</a></span></dt>







      <dt><span class="sect2"><a href="#range_checking">范围检查</a></span></dt>







    
    
    
    
    
    
    
    </dl>







  </dd>







</dl>







</div>







<p>Boost.MultiArray 由多个组件组成。MultiArray 概念定义了多维容器的一个泛型接口。<code class="literal">multi_array</code> 是一个参照 MultiArray 的通用容器类。<code class="literal">multi_array_ref</code> 和 <code class="literal">const_multi_array_ref</code> 则是适配器类。通过使用它们，你可以象操作一个
<code class="literal">multi_array</code> 一样操作任意的连续数据块。<code class="literal">const_multi_array_ref</code> 与
<code class="literal">multi_array_ref</code> 的区别在于其元素不可以通过接口来修改。最后还有几个辅助类用于创建和特化数组，还有一些全局对象被定义为本库接口的一部分。</p>







<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="synopsis"></a>本库概要</h2>







</div>







</div>







</div>







<p>要使用 Boost.MultiArray, 你必须在你的源程序中包含头文件 
<code class="filename">boost/multi_array.hpp</code>. 该文件将以下声明带入到当前域：</p>







<pre class="programlisting">namespace boost {<br>  <br>  namespace multi_array_types {<br>    typedef *unspecified* index;<br>    typedef *unspecified* size_type;<br>    typedef *unspecified* difference_type;<br>    typedef *unspecified* index_range;<br>    typedef *unspecified* extent_range;<br>    typedef *unspecified* index_gen;<br>    typedef *unspecified* extent_gen;<br>  }<br><br>  template &lt;typename ValueType, <br>            std::size_t NumDims, <br>            typename Allocator = std::allocator&lt;ValueType&gt; &gt;<br>  class multi_array;<br><br>  template &lt;typename ValueType, <br>            std::size_t NumDims&gt;<br>  class multi_array_ref;<br><br>  template &lt;typename ValueType, <br>            std::size_t NumDims&gt; <br>  class const_multi_array_ref;<br><br>  multi_array_types::extent_gen extents;<br>  multi_array_types::index_gen  indices;<br><br>  template &lt;typename Array, int N&gt; class subarray_gen;<br>  template &lt;typename Array, int N&gt; class const_subarray_gen;<br>  template &lt;typename Array, int N&gt; class array_view_gen;<br>  template &lt;typename Array, int N&gt; class const_array_view_gen;<br><br>  class c_storage_order; <br>  class fortran_storage_order;<br>  template &lt;std::size_t NumDims&gt; class general_storage_order;<br><br>}<br></pre>







</div>







<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="MultiArray"></a>MultiArray 概念</h2>







</div>







</div>







</div>







<p>MultiArray
概念定义了一个分层嵌套容器的接口。它指定了访问元素、遍历容器和创建数据视图等操作。MultiArray 定义了一个灵活的内存模式以适应不同的数据布局。
</p>







<p>在一个 MultiArray 容器层次的每一层(或每一维)都可视为一组有序的容器，其中每一个都包含相同数量和类型的值。容器层次的深度就是 MultiArray 的 <span class="emphasis"><em>维度</em></span>。MultiArray 是递归定义的；每一层的容器都符合
MultiArray。一个 MultiArray
的每个维度都有各自的大小，由所有维度的大小所组成的列表定义了整个 MultiArray 的 <span class="emphasis"><em>形状</em></span>。该容器层次的基础可以视为1维的
MultiArrays.  它们的值是所有被容器包含的元素，而不是其中一部分。它们就是 MultiArray 的元素。
</p>







<p>与其它容器概念一样，MultiArray 提供了迭代器来遍历它的值。另外，也可以用方括号来直接访问这些值。
</p>







<p>
MultiArray 还提供了创建特定视图的方法。<span class="emphasis"><em>视图</em></span> 可以让你将一个 MultiArray 中的元素的子集视为一个独立的
MultiArray. 由于视图是引向同一组底层元素的，所以对视图的元素进行修改地反映到原来的
MultiArray 中。例如，给定一组3维"立体"的元素，它的一个2维切片可以被视为一个无关的
MultiArray.

视图可以用 <code class="literal">index_gen</code> 和
<code class="literal">index_range</code> 对象来创建。<code class="literal">index_range</code> 代表了某个维度被包含在视图中的元素范围。<code class="literal">index_gen</code> 则将这些范围数据集合起来，并进行簿记工作，以确定返回的视图类型。MultiArray 的 <code class="literal">operator[]</code>
 必须被传入对 
<code class="literal">index_gen::operator[]</code> 的 <code class="literal">N</code> 次链式调用的结果，即：

</p>







<pre class="programlisting">indices[a0][a1]...[aN];<br></pre>







<p>其中 <code class="literal">N</code> 为 
MultiArray 的维度，而
<code class="literal">indices</code> 是一个类型为 <code class="literal">index_gen</code> 的对象。视图的类型取决于 <code class="literal">index_gen</code> 所指定的退化的维度数量。一个退化的维度表示对某个维度向
<code class="literal">index_gen</code> 指定单个值。例如，如果
<code class="literal">indices</code> 是一个类型为
<code class="literal">index_gen</code> 的对象，那么以下例子：

</p>







<pre class="programlisting">indices[index_range(0,5)][2][index_range(0,4)];<br></pre>







<p>其中第二个维度是退化的。由以上语句生成的视图具有2个维度，形状为 <code class="literal">5 x 4</code>.
如果上面的 "<code class="literal">2</code>" 被替换为另一个 <code class="literal">index_range</code> 对象，例如：

</p>







<pre class="programlisting">indices[index_range(0,5)][index_range(0,2)][index_range(0,4)];<br></pre>







<p>那么该视图有3个维度。</p>







<p>
MultiArray 还提供了关于所含元素的内存布局的信息。它存储元素的内存模式由4个属性来定义：原点、形状、索引基数和步幅。原点是以 <code class="literal">a[0][0]...[0]</code>来访问的元素在内存中的地址，其中
<code class="literal">a</code> 为一个 MultiArray.
形状是一个数字列表，指定容器的各个维度的大小。例如，列表中第一个数字是最外层容器的大小，第二个数字是下一层容器的大小，依此类推。索引基数是一个有
符号整数的列表，指定了容器中第一个值的索引。在同一个维度的所有容器共享一个相同的索引基数。注意，由于索引基数可以为正，所以原点不一定位于
MultiArray
的元素的内存中。步幅决定了索引值如何映射到内存的偏移量。它们适应多种可能的元素布局。例如，一个2维数组的元素可以按行存储(即每一行的元素被连续存
储)或者按列存储(即每一列的元素被连续存储)。
</p>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id834641"></a>符号</h3>







</div>







</div>







</div>







<p>以下是将用于 MultiArray 接口说明的符号描述。</p>







<div class="table"><a name="id834650"></a>
<p class="title"><b>表&nbsp;1. 符号</b></p>







<table summary="Notation" border="1">







  <colgroup><col><col></colgroup><tbody>







    <tr>







      <td><code class="literal">A</code></td>







      <td>一个参照 MultiArray 的类型
      </td>







    </tr>







    <tr>







      <td><code class="literal">a,b</code></td>







      <td>类型 <code class="literal">A</code> 的对象<code class="literal"></code></td>







    </tr>







    <tr>







      <td><code class="literal">NumDims</code></td>







      <td><code class="literal">A</code> 的维度数</td>







    </tr>







    <tr>







      <td><code class="literal">Dims</code></td>







      <td>某个满足 
      <code class="literal">0&lt;Dims&lt;NumDims</code> 的数字，用作维度参数
      </td>







    </tr>







    <tr>







      <td><code class="literal">indices</code></td>







      <td>一个由对 <code class="literal">index_gen::operator[](index_range)</code> 的多次链式调用所创建的对象</td>







    </tr>







    <tr>







      <td><code class="literal">index_list</code></td>







      <td>一个对象，其类型参照了 <a href="../../utility/Collection.html" target="_top">Collection</a>
      </td>







    </tr>







    <tr>







      <td><code class="literal">idx</code></td>







      <td>一个有符号整数值</td>







    </tr>







    <tr>







      <td><code class="literal">tmp</code></td>







      <td>类型
	      <code class="literal">boost::array&lt;index,NumDims&gt;</code> 的对象<code class="literal"></code></td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id834809"></a>相关类型</h3>







</div>







</div>







</div>







<p>
</p>







<div class="table"><a name="id834817"></a>
<p class="title"><b>表&nbsp;2. 相关类型</b></p>







<table summary="Associated Types" border="1">







  <colgroup><col><col></colgroup><thead><tr>







    <th>类型</th>







    <th>说明</th>







  </tr>







  </thead><tbody>







    <tr>







      <td><code class="literal">value_type</code></td>







      <td>容器的值类型。如果 <code class="literal">NumDims == 1</code>, 则它就是
      <code class="literal">element</code>. 否则，它是最直接的嵌套容器的值类型。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">reference</code>
      </td>







      <td>所含值的引用类型。如果 <code class="literal">NumDims == 1</code>, 则它就是 
      <code class="literal">element&amp;</code>. 否则，它与
      <code class="literal">template subarray&lt;NumDims-1&gt;::type</code> 类型相同。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">const_reference</code>
      </td>







      <td>所含值的常量引用类型。如果 <code class="literal">NumDims == 1</code>, 则它就是  
      <code class="literal">const element&amp;</code>. 否则，它与
      <code class="literal">template const_subarray&lt;NumDims-1&gt;::type</code> 类型相同。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">size_type</code>
      </td>







      <td>这是一个无符号整数类型。主要用于指定数组的形状。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">difference_type</code>
      </td>







      <td>这是一个有符号整数类型，用于表示两个迭代器间的距离。它与
      <code class="literal">std::iterator_traits&lt;iterator&gt;::difference_type</code> 类型相同。
      </td>







    </tr>







    <tr>







      <td><code class="literal">iterator</code></td>







      <td><code class="literal">A</code>&nbsp;的迭代器。如果 <code class="literal">NumDims == 1</code>, 则它符合 
      <a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html" target="_top">
      <code class="literal">随机访问迭代器</code></a>。否则，它符合 
      <a href="./iterator_categories.html#concept_RandomAccessTraversalIterator" target="_top">
随机访问遍历迭代器</a>，<a href="./iterator_categories.html#concept_ReadableIterator" target="_top">可读迭代器</a> 和
      <a href="./iterator_categories.html#concept_WritableIterator" target="_top">
可写迭代器</a>。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">const_iterator</code>
      </td>







      <td><code class="literal">A</code> 的常量迭代器。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">reverse_iterator</code>
      </td>







      <td>反向迭代器，用于对 <code class="literal">A</code> 进行反向迭代。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">const_reverse_iterator</code>
      </td>







      <td> <code class="literal">A</code> 的反向常量迭代器。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">element</code>
      </td>







      <td>存储在 MultiArray 的基础层的对象的类型。类型与
      <code class="literal">template subarray&lt;1&gt;::value_type</code> 相同<code class="literal"></code>
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">index</code>
      </td>







      <td>这是一个有符号整数类型，用于 <code class="literal">A</code> 中的索引。也被用于表示步幅和索引基数。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">index_gen</code>
      </td>







      <td>
该类型用于创建一个 <code class="literal">index_range</code> 的 tuple，传递给 <code class="literal">operator[]</code>，以创建一个 <code class="literal">array_view&lt;Dims&gt;::type</code> 对象。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">index_range</code>
      </td>







      <td>该类型指定一个
MultiArray 的某些维度的索引范围。该范围对于一个 <code class="literal">array_view&lt;Dims&gt;::type</code> 对象是可见的。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">template subarray&lt;Dims&gt;::type</code>
      </td>







      <td>这是 <code class="literal">Dims</code> 维度的子数组类型。它是 <code class="literal">A</code> 的 <code class="literal">(NumDims - Dims)</code>
维度的引用类型，同样符合
MultiArray.
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">template const_subarray&lt;Dims&gt;::type</code>
      </td>







      <td>这是常量的子数组类型。
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">template array_view&lt;Dims&gt;::type</code>
      </td>







      <td>这是 <code class="literal">Dims</code> 维度的视图类型。通过调用 <code class="literal">operator[](<code class="literal">indices</code>)</code> 返回。它符合 MultiArray.
      </td>







    </tr>







    <tr>







      <td>
      <code class="literal">template
const_array_view&lt;Dims&gt;::type</code>
      </td>







      <td>这是 <code class="literal">Dims</code> 维度的常量视图类型。
      </td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id835319"></a>有效表达式</h3>







</div>







</div>







</div>







<div class="table"><a name="id835323"></a>
<p class="title"><b>表&nbsp;3. 有效表达式</b></p>







<table summary="Valid Expressions" border="1">







  <colgroup><col><col><col></colgroup><thead><tr>







    <th>表达式</th>







    <th>返回类型</th>







    <th>语义</th>







  </tr>







  </thead><tbody>







    <tr>







      <td><code class="literal">a.shape()</code></td>







      <td><code class="literal">const size_type*</code></td>







      <td>返回由 <code class="literal">NumDims</code> 个元素组成的列表，表示每个维度的长度。
      </td>







    </tr>







    <tr>







      <td><code class="literal">a.strides()</code></td>







      <td><code class="literal">const index*</code></td>







      <td>返回由 <code class="literal">NumDims</code> 个元素组成的列表，表示与每个维度相关的步幅。在访问数组中的值时，步幅用于计算一个元素在内存中的位置。
      </td>







    </tr>







    <tr>







      <td><code class="literal">a.index_bases()</code></td>







      <td><code class="literal">const index*</code></td>







      <td>返回由 <code class="literal">NumDims</code> 个元素组成的列表，表示每个维度第一个元素的索引。
      </td>







    </tr>







    <tr>







      <td><code class="literal">a.origin()</code></td>







      <td>
      <code class="literal">element*</code> 如果 <code class="literal">a</code> 是可变的，否则为
      <code class="literal">const element*</code>&nbsp;
      </td>







      <td>返回由表达式
      <code class="literal">a[0][0]...[0]所访问的元素的地址。如果有某个索引基数是正的，该元素将不存在，但该地址还是可以用来定位一个给定索引的有效元素。</code>
      </td>







    </tr>







    <tr>







      <td><code class="literal">a.num_dimensions()</code></td>







      <td><code class="literal">size_type</code></td>







      <td>返回数组的维数(注意 <code class="literal">a.num_dimensions() == NumDims</code>)。</td>







    </tr>







    <tr>







      <td><code class="literal">a.num_elements()</code></td>







      <td><code class="literal">size_type</code></td>







      <td>返回数组中包含的元素数量。等价于以下代码：
      
      
      
      
      
      
      
      <pre class="programlisting">std::accumulate(a.shape(),a.shape+a.num_dimensions(),<br>    size_type(1),std::multiplies&lt;size_type&gt;());<br></pre>








      </td>







    </tr>







    <tr>







      <td><code class="literal">a.size()</code></td>







      <td><code class="literal">size_type</code></td>







      <td>返回
      <code class="literal">a</code> 中包含的值的数量。等价于 <code class="literal">a.shape()[0];</code>
      </td>







    </tr>







    <tr>







      <td><code class="literal">a(index_list)</code></td>







      <td>
      <code class="literal">element&amp;</code>  如果 <code class="literal">a</code> 是可变的，否则为
      <code class="literal">const element&amp;</code>&nbsp;
            </td>







      <td>该表达式访问 <code class="literal">a</code> 的某个特定元素。<code class="literal">index_list</code> 是表示所返回的元素的唯一索引组合。它等价于以下代码(忽略其中的临时对象)：
      
      
      
      
      
      
      
      <pre class="programlisting">    // 用步幅与索引相乘<br>    std::transform(index_list.begin(), index_list.end(),<br>      a.strides(), tmp.begin(), std::multiplies&lt;index&gt;()),<br><br>    // 将积的总和加到原点上<br>    *std::accumulate(tmp.begin(), tmp.end(), a.origin());<br></pre>








      </td>







    </tr>







    <tr>







      <td><code class="literal">a.begin()</code></td>







      <td>
      <code class="literal">iterator</code> 如果 <code class="literal">a</code> 是可变的，否则为
      <code class="literal">const_iterator</code>&nbsp;
            </td>







      <td>返回指向
      <code class="literal">a</code> 的始端的迭代器。</td>







    </tr>







    <tr>







      <td><code class="literal">a.end()</code></td>







      <td>
      <code class="literal">iterator</code> 如果 <code class="literal">a</code> 是可变的，否则为
      <code class="literal">const_iterator</code>&nbsp;
            </td>







      <td>返回指向 <code class="literal">a</code> 的末端的迭代器。</td>







    </tr>







    <tr>







      <td><code class="literal">a.rbegin()</code></td>







      <td>
      <code class="literal">reverse_iterator</code> 如果 <code class="literal">a</code> 是可变的，否则为 
      <code class="literal">const_reverse_iterator</code>&nbsp;
            </td>







      <td>返回一个反向迭代器，指向反向 <code class="literal">a</code> 的始端。
      </td>







    </tr>







    <tr>







      <td><code class="literal">a.rend()</code></td>







      <td>
      <code class="literal">reverse_iterator</code> 如果 <code class="literal">a</code> 是可变的，否则为 
      <code class="literal">const_reverse_iterator</code>&nbsp;
      </td>







      <td>返回一个反向迭代器，指向反向 <code class="literal">a</code> 的末端。
      </td>







    </tr>







    <tr>







      <td><code class="literal">a[idx]</code></td>







      <td>
      <code class="literal">reference</code> 如果 <code class="literal">a</code> 是可变的，否则为
      <code class="literal">const_reference</code>&nbsp;
            </td>







      <td>返回一个引用类型，绑定到 <code class="literal">a</code> 中索引为
      <code class="literal">idx</code> 的值。注意，如果
      <code class="literal">i</code> 为该维度的索引基数，以上表达式将返回第 <code class="literal">(idx-i)个元素</code>(从零起计)。该表达式等价于
      <code class="literal">*(a.begin()+idx-a.index_bases()[0]);</code>.
      </td>







    </tr>







    <tr>







      <td><code class="literal">a[indices]</code></td>







      <td>
      <code class="literal">array_view&lt;Dims&gt;::type</code> 如果 <code class="literal">a</code> 是可变的，否则为
      <code class="literal">const_array_view&lt;Dims&gt;::type</code>&nbsp;
            </td>







      <td>该表达式生成一个数组的视图，依据构成 <code class="literal">indices</code> 的
      <code class="literal">index_range</code> 和 <code class="literal">index</code> 值。
      </td>







    </tr>







    <tr>







      <td><code class="literal">a == b</code></td>







      <td>bool</td>







      <td>执行对 <code class="literal">a</code> 和 <code class="literal">b</code> 中各个值的逐一比较。元素类型必须是 <a href="http://www.sgi.com/tech/stl/EqualityComparable.html" target="_top">相等性可比较的</a>，该表达式才有效。</td>







    </tr>







    <tr>







      <td><code class="literal">a &lt; b</code></td>







      <td>bool</td>







      <td>执行对 <code class="literal">a</code> 和 <code class="literal">b</code> 中各个值的逐一比较。元素类型必须是 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html" target="_top">小于关系可比较的</a>，该表达式才有效。</td>







    </tr>







    <tr>







      <td><code class="literal">a &lt;= b</code></td>







      <td>bool</td>







      <td>执行对 <code class="literal">a</code> 和 <code class="literal">b</code> 中各个值的逐一比较。元素类型必须是 <a href="http://www.sgi.com/tech/stl/EqualityComparable.html" target="_top">相等性可比较的</a> 且
      <a href="http://www.sgi.com/tech/stl/LessThanComparable.html" target="_top">小于关系可比较的</a>，该表达式才有效。</td>







    </tr>







    <tr>







      <td><code class="literal">a &gt; b</code></td>







      <td>bool</td>







      <td>执行对 <code class="literal">a</code> 和 <code class="literal">b</code> 中各个值的逐一比较。元素类型必须是 <a href="http://www.sgi.com/tech/stl/EqualityComparable.html" target="_top">相等性可比较的</a> 且 
      <a href="http://www.sgi.com/tech/stl/LessThanComparable.html" target="_top">小于关系可比较的</a>，该表达式才有效。</td>







    </tr>







    <tr>







      <td><code class="literal">a &gt;= b</code></td>







      <td>bool</td>







      <td>执行对 <code class="literal">a</code> 和 <code class="literal">b</code> 中各个值的逐一比较。元素类型必须是 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html" target="_top">小于关系可比较的</a>，该表达式才有效。</td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id836109"></a>复杂度保证</h3>







</div>







</div>







</div>







<code class="literal">begin()</code> 和 <code class="literal">end()</code> 具有分期常量时间复杂度。<code class="literal">size()</code> 则具有与 
MultiArray 的大小线性相关的时间复杂度。 
</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id836133"></a>不变式</h3>







</div>







</div>







</div>







<div class="table"><a name="id836139"></a>
<p class="title"><b>表&nbsp;4. 不变式</b></p>







<table summary="Invariants" border="1">







  <colgroup><col><col></colgroup><tbody>







    <tr>







      <td>有效范围</td>







      <td><code class="literal">[a.begin(),a.end())</code> 为有效范围。
            </td>







    </tr>







    <tr>







      <td>范围大小</td>







      <td>
      <code class="literal">a.size() == std::distance(a.begin(),a.end());</code>.
      </td>







    </tr>







    <tr>







      <td>完整性</td>







      <td>
对区间 
      <code class="literal">[a.begin(),a.end())</code> 进行迭代，将遍历 <code class="literal">a</code> 中的每一个 <code class="literal">value_type</code>.
      </td>







    </tr>







    <tr>







      <td>等价的访问方法</td>







      <td>调用 <code class="literal">a[a1][a2]...[aN]</code>，其中 <code class="literal">N==NumDims</code>，产生的结果与调用 
      <code class="literal">a(index_list)</code>，其中 <code class="literal">index_list</code>
是由值 <code class="literal">a1...aN</code> 组成的 <a href="../../utility/Collection.html" target="_top">Collection</a> 是相同的。
      </td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="view_types"></a>视图的相关类型</h3>







</div>







</div>







</div>







<p>以下 MultiArray 相关类型定义了创建已有
MultiArray 的视图的接口。以下描述其接口及规则。</p>







<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="index_range"></a><code class="literal">index_range</code></h4>







</div>







</div>







</div>







<p><code class="literal">index_range</code> 对象表示一个指定步幅的半开区间。它们可以被聚集起来(用一个
<code class="literal">index_gen</code> 对象)传递给某个 MultiArray 的 <code class="literal">operator[]</code>
以创建一个数组视图。在创建视图时，每个 <code class="literal">index_range</code> 代表 MultiArray 的某个维度上的有效索引范围。通过这些范围组合可以访问到的元素构成了这个视图。在某些情况下，可以创建一个没有指定开始和结束值的
<code class="literal">index_range</code>.  这样，该对象就被解释为从 MultiArray 的某个维度的始端开始，在该维度的末端结束。</p>







<p>
<code class="literal">index_range</code>&nbsp;对象有多种方式进行构造和修改，为索引范围提供方便且清晰的表达方式。为了指定区间，<code class="literal">index_range</code> 提供了一组构造函数，可变成员函数，以及一种新颖的不等式操作符。使用这种不等式操作符，可以这样来表示非开区间 [5,10)：
</p>







<pre class="programlisting">5 &lt;= index_range() &lt; 10;</pre>







<p> 或
</p>







<pre class="programlisting">4 &lt; index_range() &lt;= 9;</pre>







<p> 等等。以下描述
<code class="literal">index_range</code> 的接口。
</p>







<div class="table"><a name="id836367"></a>
<p class="title"><b>表&nbsp;5. 符号</b></p>







<table summary="Notation" border="1">







  <colgroup><col><col></colgroup><tbody>







    <tr>







      <td><code class="literal">i</code></td>







      <td>类型 <code class="literal">index_range</code> 的一个对象</td>







    </tr>







    <tr>







      <td><code class="literal">idx,idx1,idx2,idx3</code></td>







      <td>类型 <code class="literal">index</code> 的一个对象</td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







<div class="table"><a name="id836420"></a>
<p class="title"><b>表&nbsp;6. 相关类型</b></p>







<table summary="Associated Types" border="1">







  <colgroup><col><col></colgroup><thead><tr>







    <th>类型</th>







    <th>说明</th>







  </tr>







  </thead><tbody>







    <tr>







      <td><code class="literal">index</code></td>







      <td>一个有符号整数类型。用于指定开始值、结束值和步幅值。</td>







    </tr>







    <tr>







      <td><code class="literal">size_type</code></td>







      <td>一个无符号整数类型。用于报告一个 <code class="literal">index_range</code> 
所代表的范围大小。</td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







<div class="table"><a name="id836483"></a>
<p class="title"><b>表&nbsp;7. 有效表达式</b></p>







<table summary="Valid Expressions" border="1">







  <colgroup><col><col><col></colgroup><thead><tr>







    <th>表达式</th>







    <th>返回类型</th>







    <th>语义</th>







  </tr>







  </thead><tbody>







    <tr>







      <td><code class="literal">index_range(idx1,idx2,idx3)</code></td>







      <td><code class="literal">index_range</code></td>







      <td>构造一个 <code class="literal">index_range</code>，表示步幅为 <code class="literal">idx3</code> 的区间 <code class="literal">[idx1,idx2)</code></td>







    </tr>







    <tr>







      <td><code class="literal">index_range(idx1,idx2)</code></td>







      <td><code class="literal">index_range</code></td>







      <td>构造一个 <code class="literal">index_range</code>，表示单位步幅的区间 <code class="literal">[idx1,idx2)</code>. 等价于
	    <code class="literal">index_range(idx1,idx2,1)</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">index_range()</code></td>







      <td><code class="literal">index_range</code></td>







      <td>构造一个 <code class="literal">index_range</code>，不指定开始值和结束值。</td>







    </tr>







    <tr>







      <td><code class="literal">i.start(idx1)</code></td>







      <td><code class="literal">index&amp;</code></td>







      <td>将 <code class="literal">i</code> 的开始索引设为
	    <code class="literal">idx</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">i.finish(idx)</code></td>







      <td><code class="literal">index&amp;</code></td>







      <td>将&nbsp;<code class="literal">i</code> 的结束索引设为 
            <code class="literal">idx</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">i.stride(idx)</code></td>







      <td><code class="literal">index&amp;</code></td>







      <td>将&nbsp;<code class="literal">i</code> 的步幅设为
            <code class="literal">idx</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">i.start()</code></td>







      <td><code class="literal">index</code></td>







      <td>返回 <code class="literal">i</code> 的开始索引。</td>







    </tr>







    <tr>







      <td><code class="literal">i.finish()</code></td>







      <td><code class="literal">index</code></td>







      <td>返回 <code class="literal">i</code> 的结束索引。</td>







    </tr>







    <tr>







      <td><code class="literal">i.stride()</code></td>







      <td><code class="literal">index</code></td>







      <td>返回 <code class="literal">i</code> 的步幅。</td>







    </tr>







    <tr>







      <td><code class="literal">i.get_start(idx)</code></td>







      <td><code class="literal">index</code></td>







      <td>如果 <code class="literal">i</code> 指定了开始值，则等价于 <code class="literal">i.start()</code>. 否则返回 <code class="literal">idx</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">i.get_finish(idx)</code></td>







      <td><code class="literal">index</code></td>







      <td>如果 <code class="literal">i</code> 指定了结束值，则等价于 <code class="literal">i.finish()</code>. 否则返回 <code class="literal">idx</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">i.size(idx)</code></td>







      <td><code class="literal">size_type</code></td>







      <td>如果 <code class="literal">i</code> 指定了开始值和结束值，则等价于 <code class="literal">(i.finish()-i.start())/i.stride()</code>. 否则返回 <code class="literal">idx</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">i &lt; idx</code></td>







      <td><code class="literal">index</code></td>







      <td>指定结束值的另一种语法。表示有效索引的区间不包含 
      <code class="literal">idx</code>. 等价于 
      <code class="literal">index_range(r.start(), idx, r.stride())</code></td>







    </tr>







    <tr>







      <td><code class="literal">i &lt;= idx</code></td>







      <td><code class="literal">index</code></td>







      <td>指定结束值的另一种语法。表示有效索引的区间包含 
      <code class="literal">idx</code>. 等价于 
      <code class="literal">index_range(r.start(), idx + 1, r.stride())</code></td>







    </tr>







    <tr>







      <td><code class="literal">idx &lt; i</code></td>







      <td><code class="literal">index</code></td>







      <td>指定开始值的另一种语法。表示有效索引的区间不包含 
      <code class="literal">idx</code>. 等价于 
      <code class="literal">index_range(idx + 1, i.finish(), i.stride())</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">idx &lt;= i</code></td>







      <td><code class="literal">index</code></td>







      <td>指定开始值的另一种语法。表示有效索引的区间包含 
      <code class="literal">idx</code>. 等价于 
      <code class="literal">index_range(idx, i.finish(), i.stride())</code>.</td>







    </tr>







    <tr>







      <td><code class="literal">i + idx</code></td>







      <td><code class="literal">index</code></td>







      <td>该表达式将 <code class="literal">i</code> 的开始值和结束值都增加 <code class="literal">idx</code>. 等价于 
      <code class="literal">index_range(r.start()+idx, r.finish()+idx, r.stride())</code></td>







    </tr>







    <tr>







      <td><code class="literal">i - idx</code></td>







      <td><code class="literal">index</code></td>







      <td>该表达式将 <code class="literal">i</code> 的开始值和结束值都减少 <code class="literal">idx</code>. 等价于 
      <code class="literal">index_range(r.start()-idx, r.finish()-idx, r.stride())</code></td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







</div>







<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="index_gen"></a><code class="literal">index_gen</code></h4>







</div>







</div>







</div>







<p> <code class="literal">index_gen</code> 将 
<code class="literal">index_range</code> 对象聚集起来用作指定视图的参数。通过对 <code class="literal">operator[]</code> 的链式调用，保存相关的区间和维度信息，用于在 MultiArray 中初始化一个新的视图。
</p>







<div class="table"><a name="id837149"></a>
<p class="title"><b>表&nbsp;8. 符号</b></p>







<table summary="Notation" border="1">







  <colgroup><col><col></colgroup><tbody>







    <tr>







      <td><code class="literal">Dims,Ranges</code></td>







      <td>无符号整数值。</td>







    </tr>







    <tr>







      <td><code class="literal">x</code></td>







      <td>类型 
      <code class="literal">template gen_type&lt;Dims,Ranges&gt;::type</code> 的对象</td>







    </tr>







    <tr>







      <td><code class="literal">i</code></td>







      <td>类型 <code class="literal">index_range</code> 的对象。</td>







    </tr>







    <tr>







      <td><code class="literal">idx</code></td>







      <td>类型 <code class="literal">index</code> 的对象</td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







<div class="table"><a name="id837235"></a>
<p class="title"><b>表&nbsp;9. 相关类型</b></p>







<table summary="Associated Types" border="1">







  <colgroup><col><col></colgroup><thead><tr>







    <th>类型</th>







    <th>说明</th>







  </tr>







  </thead><tbody>







    <tr>







      <td><code class="literal">index</code></td>







      <td>有符号整数类型。用于指定退化的维度。</td>







    </tr>







    <tr>







      <td><code class="literal">size_type</code></td>







      <td>无符号整数类型。用于报告 <code class="literal">index_range</code> 
所表示的范围大小。</td>







    </tr>







    <tr>







      <td>
      <code class="literal">template gen_type::&lt;Dims,Ranges&gt;::type</code></td>







      <td>该类型生成器命名了对
      <code class="literal">index_gen::operator[]</code>  
      <code class="literal">进行 Dims</code> 次链式调用的结果。
      <code class="literal">Ranges</code> 参数由退化的区间(即调用
      <code class="literal">operator[](index)</code>)的数量所决定。注意，<code class="classname">index_gen</code> 和
      <code class="classname">gen_type&lt;0,0&gt;::type</code> 是相同的类型。</td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







<div class="table"><a name="id837347"></a>
<p class="title"><b>表&nbsp;10. 有效表达式</b></p>







<table summary="Valid Expressions" border="1">







  <colgroup><col><col><col></colgroup><thead><tr>







    <th>表达式</th>







    <th>返回类型</th>







    <th>语义</th>







  </tr>







  </thead><tbody>







    <tr>







      <td><code class="literal">index_gen()</code></td>







      <td><code class="literal">gen_type&lt;0,0&gt;::type</code></td>







      <td>构造一个 <code class="literal">index_gen</code>
对象。该对象可用于生成 多个 <code class="literal">index_range</code> 值所组成的 tuple.</td>







    </tr>







    <tr>







      <td><code class="literal">x[i]</code></td>







      <td><code class="literal">gen_type&lt;Dims+1,Ranges+1&gt;::type</code>
      </td>







      <td>返回一个新对象，包含所有以前的
      <code class="classname">index_range</code> 对象再外加
      <code class="literal">i.</code> 对
      <code class="function">operator[]</code> 的链式调用就是聚集
      <code class="classname">index_range</code> 对象的方法。</td>







    </tr>







    <tr>







      <td><code class="literal">x[idx]</code></td>







      <td><code class="literal">gen_type&lt;Dims,Ranges&gt;::type</code>
      </td>







      <td>返回一个新对象，包含所有以前的
      <code class="classname">index_range</code> 对象再外加一个退化区间 <code class="literal">index_range(idx,idx).</code> 注意，这并不等价于 <code class="literal">x[index_range(idx,idx)]</code>，后者的返回类型为
      <code class="literal">gen_type&lt;Dims+1,Ranges+1&gt;::type</code>.
      </td>







    </tr>







  
  
  
  
  
  
  
  </tbody>
</table>







</div>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id837503"></a>Models</h3>







</div>







</div>







</div>







<div class="itemizedlist">
<ul type="disc">







  <li><code class="literal">multi_array</code></li>







  <li><code class="literal">multi_array_ref</code></li>







  <li><code class="literal">const_multi_array_ref</code></li>







  <li><code class="literal">template array_view&lt;Dims&gt;::type</code></li>







  <li><code class="literal">template const_array_view&lt;Dims&gt;::type</code></li>







  <li><code class="literal">template subarray&lt;Dims&gt;::type</code></li>







  <li><code class="literal">template const_subarray&lt;Dims&gt;::type</code></li>







</ul>







</div>







</div>







</div>







<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="array_types"></a>数组组件</h2>







</div>







</div>







</div>







<p>
Boost.MultiArray 定义了一个数组类
<code class="literal">multi_array</code>, 以及两个适配器类
<code class="literal">multi_array_ref</code> 和 
<code class="literal">const_multi_array_ref</code>. 这三个类均符合 
MultiArray 概念，所以它们共享了多项功能。<code class="literal">multi_array_ref</code> 与
<code class="literal">multi_array</code> 的区别在于，<code class="literal">multi_array</code> 管理它所拥有的内存，而
<code class="literal">multi_array_ref</code> 则被传入一块内存且该块内存是由外部管理的。<code class="literal">const_multi_array_ref</code> 与
<code class="literal">multi_array_ref</code> 的区别在于它所适配的底层元素不可以通过其接口进行修改，虽然某些数组属性，包括数组的形状和索引基数，可以被修改。这些类所具备的共有功能说明如下。
</p>







<p><b>注：前提条件、作用和实现。</b>在以下几节中，我们会用一些C++代码片断来说明象前提条件、作用和后续条件等约束。没有必要对数组组件
的底层实现进行描述；这些代码描述了所需的输入以及特定操作的行为。不满足前提条件将导致未定义的行为。不是所有列出的作用(如复制构造函数等)都必须精
确模仿。这些代码片断的主要意图是捉住所描述的操作的本质。 </p>







<p><b>查询</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">element* data();<br>const element* data() const;</pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>返回一个指针，指向数组的数据所在的连续内存块的开头。如果所有数组的所有维度都是从零起计的，且均按升序存储，则它等价于 <code class="literal">origin()</code>. 注意，<code class="literal">const_multi_array_ref</code> 只提供该函数的 const 版本。
    </p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">element* origin();<br>const element* origin() const;</pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>返回
    <code class="literal">multi_array</code> 的原点元素。注意，<code class="literal">const_multi_array_ref</code> 只提供该函数的 const
版本。(MultiArray 所必需的)
    </p>







  </dd>







  <dt><span class="term"><code class="function">const index* index_bases();</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>返回
    <code class="literal">multi_array</code> 的索引基数。(MultiArray 所必需的)
    </p>







  </dd>







  <dt><span class="term"><code class="function">const index* strides();</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>返回
    <code class="literal">multi_array</code> 的步幅。(MultiArray 所必需的)
    </p>







  </dd>







  <dt><span class="term"><code class="function">const size_type* shape();</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>返回 <code class="literal">multi_array</code> 的形状。(MultiArray 所必需的)
    </p>







  </dd>







</dl>







</div>







<p><b>比较操作</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">bool operator==(const *array-type*&amp; rhs);<br>bool operator!=(const *array-type*&amp; rhs);<br>bool operator&lt;(const *array-type*&amp; rhs);<br>bool operator&gt;(const *array-type*&amp; rhs);<br>bool operator&gt;=(const *array-type*&amp; rhs);<br>bool operator&lt;=(const *array-type*&amp; rhs);</pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>每个比较操作按两个数组的值类型进行比较。(MultiArray 所必需的)
    </p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b><code class="literal">element</code> 必须支持在
    <code class="literal">multi_array</code> 上调用的相应比较操作。</p>







    
    
    
    
    
    
    
    <p><b>复杂度：</b>O(<code class="literal">num_elements()</code>).</p>







  </dd>







</dl>







</div>







<p><b>修改操作</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">template &lt;typename SizeList&gt;<br>void reshape(const SizeList&amp; sizes)<br><br></pre>








    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该操作修改 <code class="literal">multi_array</code> 的形状。元素数量及索引基数保持不变，但嵌套容器层次中各层的值数量可能被改变。</p>







    
    
    
    
    
    
    
    <p><b><code class="literal">SizeList</code> 的要求：</b><code class="literal">SizeList</code> 必须符合
    <a href="../../utility/Collection.html" target="_top">Collection</a>.</p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b>
    </p>







    
    
    
    
    
    
    
    <pre class="programlisting">std::accumulate(sizes.begin(),sizes.end(),size_type(1),std::times&lt;size_type&gt;()) == this-&gt;num_elements();<br>sizes.size() == NumDims;<br></pre>







    
    
    
    
    
    
    
    <p><b>后续条件：</b><code class="literal">std::equal(sizes.begin(),sizes.end(),this-&gt;shape) == true;</code>
    </p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">template &lt;typename BaseList&gt;<br>void reindex(const BaseList&amp; values);<br><br>    </pre>








    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该操作根据 <code class="literal">values</code> 的值修改 <code class="literal">multi_array</code> 的索引基数。</p>







    
    
    
    
    
    
    
    <p><b><code class="literal">BaseList</code> 的要求：</b><code class="literal">BaseList</code> 必须符合 <a href="../../utility/Collection.html" target="_top">Collection</a>.</p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b><code class="literal">values.size() == NumDims;</code></p>







    
    
    
    
    
    
    
    <p><b>后续条件：</b><code class="literal">std::equal(values.begin(),values.end(),this-&gt;index_bases());
    </code></p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">void reindex(index value);<br>        <br>    该操作将<br>    <code class="literal">multi_array</code> 所有维度的索引基数改为 <code class="literal">value</code>.</pre>








    </span></dt>







  <dd>





    
    
    
    
    
    
    
    <p><b>后续条件：</b>
    </p>







    
    
    
    
    
    
    
    <pre class="programlisting">std::count_if(this-&gt;index_bases(),this-&gt;index_bases()+this-&gt;num_dimensions(),<br>              std::bind_2nd(std::equal_to&lt;index&gt;(),value)) == <br>              this-&gt;num_dimensions();<br><br>    </pre>







    
    
    
    
    
    
    
    <p>
    </p>







  </dd>







</dl>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="multi_array"></a><code class="literal">multi_array</code></h3>







</div>







</div>







</div>







<p>
<code class="literal">multi_array</code> 是一个支持随机访问迭代的多维容器。它的维数在编译期是固定的，但它的形状和所包含的元素数量可以在构造时指定。元素的数量在
<code class="literal">multi_array</code> 的生命周期内是固定的，但容器的形状可以改变。<code class="literal">multi_array</code> 用一个可替换的分配器(allocator)来管理其数据元素。
</p>







<p><b>符合的概念：</b><a href="#MultiArray" title="MultiArray Concept">MultiArray</a>,
<a href="../../../libs/utility/CopyConstructible.html" target="_top">可复制构造</a>。根据其元素类型，也可能符合 <a href="http://www.sgi.com/tech/stl/EqualityComparable.html" target="_top">相等性可比较</a> 和 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html" target="_top">小于关系可比较</a>。 
</p>







<p><b>摘要：</b></p>







<pre class="programlisting">namespace boost {<br><br>template &lt;typename ValueType, <br>          std::size_t NumDims, <br>          typename Allocator = std::allocator&lt;ValueType&gt; &gt;<br>class multi_array {<br>public:<br>// types:<br>  typedef ValueType                             element;<br>  typedef *unspecified*                         value_type;<br>  typedef *unspecified*                         reference;<br>  typedef *unspecified*                         const_reference;<br>  typedef *unspecified*                         difference_type;<br>  typedef *unspecified*                         iterator;<br>  typedef *unspecified*                         const_iterator;<br>  typedef *unspecified*                         reverse_iterator;<br>  typedef *unspecified*                         const_reverse_iterator;<br>  typedef multi_array_types::size_type          size_type;<br>  typedef multi_array_types::index              index;<br>  typedef multi_array_types::index_gen          index_gen;<br>  typedef multi_array_types::index_range        index_range;<br>  typedef multi_array_types::extent_gen         extent_gen;<br>  typedef multi_array_types::extent_range       extent_range;<br>  typedef *unspecified*                         storage_order_type;<br>  <br><br>  // template typedefs<br>  template &lt;std::size_t Dims&gt; struct            subarray;<br>  template &lt;std::size_t Dims&gt; struct            const_subarray;<br>  template &lt;std::size_t Dims&gt; struct            array_view;<br>  template &lt;std::size_t Dims&gt; struct            const_array_view;<br>  <br><br>  // constructors and destructors<br><br>  multi_array();<br><br>  template &lt;typename ExtentList&gt;<br>  explicit multi_array(const ExtentList&amp; sizes,<br>                       const storage_order_type&amp; store = c_storage_order(),<br>                       const Allocator&amp; alloc = Allocator());<br>  explicit multi_array(const extents_tuple&amp; ranges,<br>                       const storage_order_type&amp; store = c_storage_order(),<br>	               const Allocator&amp; alloc = Allocator());<br>  multi_array(const multi_array&amp; x);<br>  multi_array(const const_multi_array_ref&lt;ValueType,NumDims&gt;&amp; x);<br>  multi_array(const const_subarray&lt;NumDims&gt;::type&amp; x);<br>  multi_array(const const_array_view&lt;NumDims&gt;::type&amp; x);<br><br>  multi_array(const multi_array_ref&lt;ValueType,NumDims&gt;&amp; x);<br>  multi_array(const subarray&lt;NumDims&gt;::type&amp; x);<br>  multi_array(const array_view&lt;NumDims&gt;::type&amp; x);<br><br>  ~multi_array();<br><br>  // modifiers<br><br>  multi_array&amp; operator=(const multi_array&amp; x);<br>  template &lt;class Array&gt; multi_array&amp; operator=(const Array&amp; x);<br><br>  // iterators:<br>  iterator				begin();<br>  iterator				end();<br>  const_iterator			begin() const;<br>  const_iterator			end() const;<br>  reverse_iterator			rbegin();<br>  reverse_iterator			rend();<br>  const_reverse_iterator		rbegin() const;<br>  const_reverse_iterator		rend() const;<br><br>  // capacity:<br>  size_type				size() const;<br>  size_type				num_elements() const;<br>  size_type				num_dimensions() const;<br> <br>  // element access:<br>  template &lt;typename IndexList&gt; <br>    element&amp;			operator()(const IndexList&amp; indices);<br>  template &lt;typename IndexList&gt;<br>    const element&amp;		operator()(const IndexList&amp; indices) const;<br>  reference			operator[](index i);<br>  const_reference		operator[](index i) const;<br>  array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r);<br>  const_array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r) const;<br><br>  // queries<br>  element*			data();<br>  const element*		data() const;<br>  element*			origin();<br>  const element*		origin() const;<br>  const size_type*		shape() const;<br>  const index*			strides() const;<br>  const index*			index_bases() const;<br>  const storage_order_type&amp;     storage_order() const;<br><br>  // comparators<br>  bool operator==(const multi_array&amp; rhs);<br>  bool operator!=(const multi_array&amp; rhs);<br>  bool operator&lt;(const multi_array&amp; rhs);<br>  bool operator&gt;(const multi_array&amp; rhs);<br>  bool operator&gt;=(const multi_array&amp; rhs);<br>  bool operator&lt;=(const multi_array&amp; rhs);<br><br>  // modifiers:<br>  template &lt;typename InputIterator&gt;<br>    void			assign(InputIterator begin, InputIterator end);<br>  template &lt;typename SizeList&gt;<br>    void			reshape(const SizeList&amp; sizes)<br>  template &lt;typename BaseList&gt;	void reindex(const BaseList&amp; values);<br>    void			reindex(index value);<br>  template &lt;typename ExtentList&gt;<br>    multi_array&amp;		resize(const ExtentList&amp; extents);<br>  multi_array&amp;                  resize(extents_tuple&amp; extents);<br>};<br><br></pre>







<p><b>构造函数</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">template &lt;typename ExtentList&gt;<br>explicit multi_array(const ExtentList&amp; sizes,<br>                     const storage_order_type&amp; store = c_storage_order(),<br>                     const Allocator&amp; alloc = Allocator());<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>用给定参数构造一个 <code class="literal">multi_array</code>.  <code class="literal">sizes</code> 指定了被构造 <code class="literal">multi_array</code> 的形状。<code class="literal">store</code>
指定了存储的顺序或各维度的内存布局。<code class="literal">alloc</code> 用于分配被包含的元素。
    </p>







    
    
    
    
    
    
    
    <p><b><code class="literal">ExtentList</code> 的要求：</b><code class="literal">ExtentList</code> 必须符合 <a href="../../utility/Collection.html" target="_top">Collection</a>.
    </p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b><code class="literal">sizes.size() == NumDims;</code></p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">explicit multi_array(extent_gen::gen_type&lt;NumDims&gt;::type ranges,<br>                     const storage_order_type&amp; store = c_storage_order(),<br>                     const Allocator&amp; alloc = Allocator());<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>用给定参数构造一个 <code class="literal">multi_array</code>.  <code class="literal">ranges</code> 指定了被构造 multi_array 的形状和索引基数。它是对 
    <code class="literal">extent_gen::operator[]</code> 进行 
    <code class="literal">NumDims</code> 次链式调用所得到的结果。<code class="literal">store</code>
指定了存储的顺序或各维度的内存布局。<code class="literal">alloc</code> 用于分配存储在 <code class="literal">multi_array</code>
中的元素的内存。
    </p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">multi_array(const multi_array&amp; x);<br>multi_array(const const_multi_array_ref&lt;ValueType,NumDims&gt;&amp; x);<br>multi_array(const const_subarray&lt;NumDims&gt;::type&amp; x);<br>multi_array(const const_array_view&lt;NumDims&gt;::type&amp; x);<br>multi_array(const multi_array_ref&lt;ValueType,NumDims&gt;&amp; x);<br>multi_array(const subarray&lt;NumDims&gt;::type&amp; x);<br>multi_array(const array_view&lt;NumDims&gt;::type&amp; x);<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>这些构造函数都是用于构造一个 <code class="literal">multi_array</code> 并执行一次对 <code class="literal">x</code> 的深拷贝。 
    </p>







    
    
    
    
    
    
    
    <p><b>复杂度：</b>执行 O(<code class="literal">x.num_elements()</code>) 次
    <code class="literal">element</code> 的复制构造函数。
    </p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">multi_array();<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>构造一个 <code class="literal">multi_array</code>，其形状为 (0,...,0)，不包含任何元素。
    </p>







  </dd>







</dl>







</div>







<p><b>关于构造函数的补充说明：</b><code class="literal">multi_array</code> 构造表达式
</p>







<pre class="programlisting">     multi_array&lt;int,3&gt; A(boost::extents[5][4][3]);<br></pre>







<p>和
</p>







<pre class="programlisting">     boost::array&lt;multi_array_base::index,3&gt; my_extents = {{5, 4, 3}};<br>     multi_array&lt;int,3&gt; A(my_extents);<br></pre>







<p>是等价的。
</p>







<p><b>修改操作</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">multi_array&amp; operator=(const multi_array&amp; x);<br>template &lt;class Array&gt; multi_array&amp; operator=(const Array&amp; x);<br></pre>








    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>将&nbsp;<code class="literal">x</code>
的各个元素的复制到当前的 <code class="literal">multi_array</code>.</p>







    
    
    
    
    
    
    
    <p><b><code class="literal">Array</code> 的要求：</b><code class="literal">Array</code> 必须符合 MultiArray. 
    </p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b>
    </p>







    
    
    
    
    
    
    
    <pre class="programlisting">std::equal(this-&gt;shape(),this-&gt;shape()+this-&gt;num_dimensions(),<br>x.shape());</pre>







    
    
    
    
    
    
    
    <p><b>后续条件：</b>
    </p>







    
    
    
    
    
    
    
    <pre class="programlisting">(*.this) == x;</pre>







    
    
    
    
    
    





    
    
    
    
    
    
    
    <p><b>复杂度：</b>赋值操作执行 
O(<code class="literal">x.num_elements()</code>) 次 <code class="literal">element</code> 的复制构造函数。</p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">template &lt;typename InputIterator&gt;<br>void assign(InputIterator begin, InputIterator end);<br>    </pre>








    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>将区间 
    <code class="literal">[begin,end)</code> 中的元素复制到数组中。等价于 
    <code class="literal">std::copy(begin,end,this-&gt;data())</code>.
    </p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b><code class="literal">std::distance(begin,end) == this-&gt;num_elements();</code>
    </p>







    
    
    
    
    
    
    
    <p><b>复杂度：</b><code class="literal">assign</code> 成员函数执行
O(<code class="literal">this-&gt;num_elements()</code>) 次
    <code class="literal">ValueType</code> 的复制构造函数。
    </p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">multi_array&amp; resize(extent_gen::gen_type&lt;NumDims&gt;::type extents);<br>template &lt;typename ExtentList&gt;<br>  multi_array&amp; resize(const ExtentList&amp; extents);<br><br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该函数将数组的大小修改为由
    <code class="literal">extents</code> 指定的形状，<code class="literal">extents</code> 可以是生成的长度列表或符合 <code class="literal">Collection</code> 概念。数组中的内容尽可能保持不变；如果新的数组大小变小了，则会丢失部分数据。因数组大小改变而新创建的元素均由
    <code class="literal">element</code> 的缺省构造函数进行初始化。
    </p>







  </dd>







</dl>







</div>







<p><b>查询</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">storage_order_type&amp; storage_order() const;<br></pre>








    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该查询返回与 
    <code class="literal">multi_array</code> 相关联的存储顺序对象。它可以用于构造另一个具有相同存储顺序的新数组。</p>







  </dd>







</dl>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="multi_array_ref"></a><code class="literal">multi_array_ref</code></h3>







</div>







</div>







</div>







<p>
<code class="literal">multi_array_ref</code> 是一个多维容器适配器。它为任意存储了某种元素的连续内存块提供 MultiArray 的接口。<code class="literal">multi_array_ref</code> 给出了与 <code class="literal">multi_array</code> 相同的接口，除了构造函数以外。
</p>







<p><b>符合的概念：</b><code class="literal">multi_array_ref</code> 符合 
<a href="#MultiArray" title="MultiArray Concept">MultiArray</a>,
<a href="../../../libs/utility/CopyConstructible.html" target="_top">可复制构造</a>，并且依据其元素类型，还可能符合
<a href="http://www.sgi.com/tech/stl/EqualityComparable.html" target="_top">相等性可比较</a> 和 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html" target="_top">小于关系可比较</a>。这里只对在 <code class="literal">multi_array</code>&nbsp;中没有的操作给出详细说明。
</p>







<p><b>摘要</b></p>







<pre class="programlisting">namespace boost {<br><br>template &lt;typename ValueType, <br>          std::size_t NumDims, <br>          typename Allocator = std::allocator&lt;ValueType&gt; &gt;<br>class multi_array_ref {<br>public:<br>// types:<br>  typedef ValueType                             element;<br>  typedef *unspecified*                         value_type;<br>  typedef *unspecified*                         reference;<br>  typedef *unspecified*                         const_reference;<br>  typedef *unspecified*                         difference_type;<br>  typedef *unspecified*                         iterator;<br>  typedef *unspecified*                         const_iterator;<br>  typedef *unspecified*                         reverse_iterator;<br>  typedef *unspecified*                         const_reverse_iterator;<br>  typedef multi_array_types::size_type          size_type;<br>  typedef multi_array_types::index              index;<br>  typedef multi_array_types::index_gen          index_gen;<br>  typedef multi_array_types::index_range        index_range;<br>  typedef multi_array_types::extent_gen         extent_gen;<br>  typedef multi_array_types::extent_range       extent_range;<br>  typedef *unspecified*                         storage_order_type;<br>  <br>  // template typedefs<br>  template &lt;std::size_t Dims&gt; struct            subarray;<br>  template &lt;std::size_t Dims&gt; struct            const_subarray;<br>  template &lt;std::size_t Dims&gt; struct            array_view;<br>  template &lt;std::size_t Dims&gt; struct            const_array_view;<br>  <br><br>  // structors<br><br>  template &lt;typename ExtentList&gt;<br>  explicit multi_array_ref(element* data, const ExtentList&amp; sizes,<br>                       const storage_order_type&amp; store = c_storage_order());<br>  explicit multi_array_ref(element* data, const extents_tuple&amp; ranges,<br>                       const storage_order_type&amp; store = c_storage_order());<br>  multi_array_ref(const multi_array_ref&amp; x);<br>  ~multi_array_ref();<br><br>  // modifiers<br><br>  multi_array_ref&amp; operator=(const multi_array_ref&amp; x);<br>  template &lt;class Array&gt; multi_array_ref&amp; operator=(const Array&amp; x);<br><br>  // iterators:<br>  iterator				begin();<br>  iterator				end();<br>  const_iterator			begin() const;<br>  const_iterator			end() const;<br>  reverse_iterator			rbegin();<br>  reverse_iterator			rend();<br>  const_reverse_iterator		rbegin() const;<br>  const_reverse_iterator		rend() const;<br><br>  // capacity:<br>  size_type				size() const;<br>  size_type				num_elements() const;<br>  size_type				num_dimensions() const;<br> <br>  // element access:<br>  template &lt;typename IndexList&gt; <br>    element&amp;			operator()(const IndexList&amp; indices);<br>  template &lt;typename IndexList&gt;<br>    const element&amp;		operator()(const IndexList&amp; indices) const;<br>  reference			operator[](index i);<br>  const_reference		operator[](index i) const;<br>  array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r);<br>  const_array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r) const;<br><br>  // queries<br>  element*			data();<br>  const element*		data() const;<br>  element*			origin();<br>  const element*		origin() const;<br>  const size_type*		shape() const;<br>  const index*			strides() const;<br>  const index*			index_bases() const;<br>  const storage_order_type&amp;     storage_order() const;<br><br>  // comparators<br>  bool operator==(const multi_array_ref&amp; rhs);<br>  bool operator!=(const multi_array_ref&amp; rhs);<br>  bool operator&lt;(const multi_array_ref&amp; rhs);<br>  bool operator&gt;(const multi_array_ref&amp; rhs);<br>  bool operator&gt;=(const multi_array_ref&amp; rhs);<br>  bool operator&lt;=(const multi_array_ref&amp; rhs);<br><br>  // modifiers:<br>  template &lt;typename InputIterator&gt;<br>    void			assign(InputIterator begin, InputIterator end);<br>  template &lt;typename SizeList&gt;<br>    void			reshape(const SizeList&amp; sizes)<br>  template &lt;typename BaseList&gt;	void reindex(const BaseList&amp; values);<br>  void				reindex(index value);<br>};<br><br></pre>







<p><b>构造函数</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">template &lt;typename ExtentList&gt;<br>explicit multi_array_ref(element* data, <br>                     const ExtentList&amp; sizes,<br>                     const storage_order&amp; store = c_storage_order());<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>以给定参数构造一个 <code class="literal">multi_array_ref</code>.  <code class="literal">sizes</code> 指定了被构造 <code class="literal">multi_array_ref</code> 的形状。<code class="literal">store</code>
指定了存储顺序或数组各维度的内存布局。<code class="literal">（译注：原文中有一个alloc参数，应为笔误）</code>
    </p>







    
    
    
    
    
    
    
    <p><b><code class="literal">ExtentList</code> 的要求：</b><code class="literal">ExtentList</code> 必须符合 <a href="../../utility/Collection.html" target="_top">Collection</a>.
    </p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b><code class="literal">sizes.size() == NumDims;</code></p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">explicit multi_array_ref(element* data,<br>                     extent_gen::gen_type&lt;NumDims&gt;::type ranges,<br>                     const storage_order&amp; store = c_storage_order());<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>以给定参数构造一个 <code class="literal">multi_array_ref</code>.  <code class="literal">ranges</code> 指定了被构造 <code class="literal">multi_array_ref</code> 的形状和索引基数。它是对 
    <code class="literal">extent_gen::operator[]</code><code class="literal"></code> 进行 
    <code class="literal">NumDims</code> 次链式调用所得到的结果。<code class="literal">store</code>
指定了存储顺序或数组各维度的内存布局。 
    </p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">multi_array_ref(const multi_array_ref&amp; x);<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>构造 <code class="literal">x</code> 的一个浅拷贝。
    </p>







    
    
    
    
    
    
    
    <p><b>复杂度：</b>常量时间(作为对比，将其与 <code class="literal">multi_array</code> 类的复制构造函数进行比较)。
    </p>







  </dd>







</dl>







</div>







<p><b>修改操作</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">multi_array_ref&amp; operator=(const multi_array_ref&amp; x);<br>template &lt;class Array&gt; multi_array_ref&amp; operator=(const Array&amp; x);<br></pre>








    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>将 <code class="literal">x</code>
中的元素复制到当前的 <code class="literal">multi_array_ref</code>.</p>







    
    
    
    
    
    
    
    <p><b><code class="literal">Array</code> 的要求：</b><code class="literal">Array</code> 必须符合 MultiArray. 
    </p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b>
    </p>







    
    
    
    
    
    
    
    <pre class="programlisting">std::equal(this-&gt;shape(),this-&gt;shape()+this-&gt;num_dimensions(),<br>x.shape());</pre>







    
    
    
    
    
    
    
    <p><b>后续条件：</b>
    </p>







    
    
    
    
    
    
    
    <pre class="programlisting">(*.this) == x;</pre>







    
    
    
    
    
    





    
    
    
    
    
    
    
    <p><b>复杂度：</b>赋值操作执行 
O(<code class="literal">x.num_elements()</code>) 次 <code class="literal">element</code> 的复制构造函数。</p>







  </dd>







</dl>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="const_multi_array_ref"></a><code class="literal">const_multi_array_ref</code></h3>







</div>







</div>







</div>







<p>
<code class="literal">const_multi_array_ref</code> 是一个多维容器适配器。它为任意存储了某种元素的连续内存块提供 MultiArray 的接口。给出了与 <code class="literal">multi_array</code> 相同的接口，除了构造函数以外。&nbsp;
</p>







<p><b>符合的概念：</b><code class="literal">const_multi_array_ref</code> 符合 <a title="MultiArray Concept" href="#MultiArray">MultiArray</a>, <a href="../../../libs/utility/CopyConstructible.html" target="_top">可复制构造</a>，并且依据其元素类型，还可能符合 <a href="http://www.sgi.com/tech/stl/EqualityComparable.html" target="_top">相等性可比较</a> 和 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html" target="_top">小于关系可比较</a>。这里只对在 <code class="literal">multi_array</code>&nbsp;中没有的操作给出详细说明。
</p>







<p><b>摘要</b></p>







<pre class="programlisting">namespace boost {<br><br>template &lt;typename ValueType, <br>          std::size_t NumDims, <br>          typename Allocator = std::allocator&lt;ValueType&gt; &gt;<br>class const_multi_array_ref {<br>public:<br>// types:<br>  typedef ValueType                             element;<br>  typedef *unspecified*                         value_type;<br>  typedef *unspecified*                         reference;<br>  typedef *unspecified*                         const_reference;<br>  typedef *unspecified*                         difference_type;<br>  typedef *unspecified*                         iterator;<br>  typedef *unspecified*                         const_iterator;<br>  typedef *unspecified*                         reverse_iterator;<br>  typedef *unspecified*                         const_reverse_iterator;<br>  typedef multi_array_types::size_type          size_type;<br>  typedef multi_array_types::index              index;<br>  typedef multi_array_types::index_gen          index_gen;<br>  typedef multi_array_types::index_range        index_range;<br>  typedef multi_array_types::extent_gen         extent_gen;<br>  typedef multi_array_types::extent_range       extent_range;<br>  typedef *unspecified*                         storage_order_type;<br>  <br>  // template typedefs<br>  template &lt;std::size_t Dims&gt; struct            subarray;<br>  template &lt;std::size_t Dims&gt; struct            const_subarray;<br>  template &lt;std::size_t Dims&gt; struct            array_view;<br>  template &lt;std::size_t Dims&gt; struct            const_array_view;<br>  <br><br>  // structors<br><br>  template &lt;typename ExtentList&gt;<br>  explicit const_multi_array_ref(const element* data, const ExtentList&amp; sizes,<br>                       const storage_order_type&amp; store = c_storage_order());<br>  explicit const_multi_array_ref(const element* data, const extents_tuple&amp; ranges,<br>                       const storage_order_type&amp; store = c_storage_order());<br>  const_multi_array_ref(const const_multi_array_ref&amp; x);<br>  ~const_multi_array_ref();<br><br><br><br>  // iterators:<br>  const_iterator			begin() const;<br>  const_iterator			end() const;<br>  const_reverse_iterator		rbegin() const;<br>  const_reverse_iterator		rend() const;<br><br>  // capacity:<br>  size_type				size() const;<br>  size_type				num_elements() const;<br>  size_type				num_dimensions() const;<br> <br>  // element access:<br>  template &lt;typename IndexList&gt;<br>    const element&amp;		operator()(const IndexList&amp; indices) const;<br>  const_reference		operator[](index i) const;<br>  const_array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r) const;<br><br>  // queries<br>  const element*		data() const;<br>  const element*		origin() const;<br>  const size_type*		shape() const;<br>  const index*			strides() const;<br>  const index*			index_bases() const;<br>  const storage_order_type&amp;     storage_order() const;<br><br>  // comparators<br>  bool operator==(const const_multi_array_ref&amp; rhs);<br>  bool operator!=(const const_multi_array_ref&amp; rhs);<br>  bool operator&lt;(const const_multi_array_ref&amp; rhs);<br>  bool operator&gt;(const const_multi_array_ref&amp; rhs);<br>  bool operator&gt;=(const const_multi_array_ref&amp; rhs);<br>  bool operator&lt;=(const const_multi_array_ref&amp; rhs);<br><br>  // modifiers:<br>  template &lt;typename SizeList&gt;<br>  void			reshape(const SizeList&amp; sizes)<br>  template &lt;typename BaseList&gt;	void reindex(const BaseList&amp; values);<br>  void				reindex(index value);<br>};<br><br></pre>







<p><b>构造函数</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">template &lt;typename ExtentList&gt;<br>explicit const_multi_array_ref(const element* data, <br>                     const ExtentList&amp; sizes,<br>                     const storage_order&amp; store = c_storage_order());<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>以给定参数构造一个 <code class="literal">const_multi_array_ref</code>.  <code class="literal">sizes</code> 指定了被构造 <code class="literal">const_</code><code class="literal">multi_array_ref</code> 的形状。<code class="literal">store</code> 
指定了存储顺序或数组各维度的内存布局。
    </p>







    
    
    
    
    
    
    
    <p><b><code class="literal">ExtentList</code> 的要求：</b><code class="literal">ExtentList</code> 必须符合 <a href="../../utility/Collection.html" target="_top">Collection</a>.
    </p>







    
    
    
    
    
    
    
    <p><b>前提条件：</b><code class="literal">sizes.size() == NumDims;</code></p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">explicit const_multi_array_ref(const element* data,<br>                     extent_gen::gen_type&lt;NumDims&gt;::type ranges,<br>                     const storage_order&amp; store = c_storage_order());<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p><b>作用：</b>以给定参数构造一个 <code class="literal">const_</code><code class="literal">multi_array_ref</code>. <code class="literal">ranges</code> 指定了被构造 <code class="literal">const_</code><code class="literal">multi_array_ref</code> 
的形状和索引基数。它是对 <code class="literal">extent_gen::operator[]</code> 进行 <code class="literal">NumDims</code> 
次链式调用所得到的结果。<code class="literal">store</code> 指定了存储顺序或数组各维度的内存布局。 
    </p>







  </dd>







  <dt><span class="term">
    
    
    
    
    
    
    
    <pre class="programlisting">const_multi_array_ref(const const_multi_array_ref&amp; x);<br></pre>







    </span></dt>







  <dd>
    
    
    
    
    
    
    
    <p><b>作用：</b>构造 <code class="literal">x</code> 的一个浅拷贝。
    </p>







  </dd>







</dl>







</div>







</div>







</div>







<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="auxiliary"></a>辅助组件</h2>







</div>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="multi_array_types"></a><code class="literal">multi_array_types</code></h3>







</div>







</div>







</div>







<pre class="programlisting">namespace multi_array_types {<br>  typedef *unspecified* index;<br>  typedef *unspecified* size_type;<br>  typedef *unspecified* difference_type;<br>  typedef *unspecified* index_range;<br>  typedef *unspecified* extent_range;<br>  typedef *unspecified* index_gen;<br>  typedef *unspecified* extent_gen;<br>}<br></pre>







<p>名字空间 <code class="literal">multi_array_types</code> 定义了一些与 <code class="literal">multi_array</code>,
<code class="literal">multi_array_ref</code>, 和
<code class="literal">const_multi_array_ref</code> 相关的类型，这些类型不依赖于模板参数。这些类型被所有 Boost.Multiarray 组件共同使用。它们被定义在一个可以方便访问的名字空间中。除了 <code class="literal">extent_gen</code> 和 
<code class="literal">extent_range</code> 以外，这些类型遵循 MultiArray 所要求且在其概念定义中被描述的同名规则。<code class="literal">extent_gen</code> 和
<code class="literal">extent_range</code> 则描述如下。
</p>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="extent_range"></a><code class="classname">extent_range</code></h3>







</div>







</div>







</div>







<p><code class="classname">extent_range</code> 对象定义了一个半开区间。它为
<code class="literal">multi_array</code>, <code class="literal">multi_array_ref</code>, 和 <code class="literal">const_multi_array_ref</code> 的构造函数提供形状和索引的信息。多个 <code class="classname">extent_range</code> 被聚集起来传递给数组的构造函数(详细说明请见
<code class="classname">extent_gen</code>)。
</p>







<p><b>摘要</b></p>







<pre class="programlisting">class extent_range {<br>public:<br>  typedef multi_array_types::index      index;<br>  typedef multi_array_types::size_type  size_type;<br><br>  // Structors<br>  extent_range(index start, index finish);<br>  extent_range(index finish);<br>  ~extent_range();<br><br>  // Queries<br>  index start();<br>  index finish();<br>  size_type size();<br>};</pre>







<p><b>符合的概念：</b>可缺省构造，可复制构造</p>







<p><b>方法与类型</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term"><code class="function">extent_range(index start, index finish)</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该构造函数定义一个半开区间
    <code class="literal">[start,finish)</code>. 表达式
    <code class="literal">finish</code> 必须大于 <code class="literal">start</code>.
    </p>







  </dd>







  <dt><span class="term"><code class="function">extent_range(index finish)</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该构造函数定义一个半开区间
    <code class="literal">[0,finish)</code>.&nbsp;<code class="literal">finish</code>
的值必须为正。</p>







  </dd>







  <dt><span class="term"><code class="function">index start()</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该函数返回表示该区间的第一个索引。</p>







  </dd>







  <dt><span class="term"><code class="function">index finish()</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该函数返回半开区间的上界值。注意，该区间不包含该值。</p>







  </dd>







  <dt><span class="term"><code class="function">size_type size()</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该函数返回指定区间的大小。它等价于 <code class="literal">finish()-start()</code>.</p>







  </dd>







</dl>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="extent_gen"></a><code class="classname">extent_gen</code></h3>







</div>







</div>







</div>







<p><code class="classname">extent_gen</code> 类定义了一个接口，用于聚集数组的形状和索引信息，以传递给 <code class="literal">multi_array</code>, 
<code class="literal">multi_array_ref</code>, 或 <code class="literal">const_multi_array_ref</code> 的构造函数。该接口模仿了C++中声明内建数组类型的语法。例如，在C++中，一个3维 <code class="classname">int</code> 数组声明如下：
</p>







<pre class="programlisting">int A[3][4][5],</pre>







<p>类似的 <code class="classname">multi_array</code> 则声明如下：
</p>







<pre class="programlisting">multi_array&lt;int,3&gt; A(extents[3][4][5]).</pre>







<p>
</p>







<p><b>摘要</b></p>







<pre class="programlisting">template &lt;std::size_t NumRanges&gt;<br>class *implementation_defined* {<br>public:<br>  typedef multi_array_types::index index;<br>  typedef multi_array_types::size_type size_type;<br><br>  template &lt;std::size_t NumRanges&gt; class gen_type;<br><br>  gen_type&lt;NumRanges+1&gt;::type  operator[](const range&amp; a_range) const;<br>  gen_type&lt;NumRanges+1&gt;::type  operator[](index idx) const;<br>};<br><br>typedef *implementation_defined*&lt;0&gt; extent_gen;<br></pre>







<p><b>方法与类型</b></p>







<div class="variablelist">
<dl>







  <dt><span class="term"><code class="function">template gen_type::&lt;Ranges&gt;::type</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该类型生成器用于指定对
    <code class="literal">extent_gen::operator[]</code> 的 
    <code class="literal">Ranges</code> 次链式调用的结果。<span style="font-family: monospace;">类型</span>
    <code class="classname">extent_gen</code> 与
    <code class="classname">gen_type&lt;0&gt;::type</code> 相同。</p>







  </dd>







  <dt><span class="term"><code class="function">gen_type&lt;NumRanges+1&gt;::type  
operator[](const extent_range&amp; a_range) const;</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该函数返回一个新的对象，包含所有以前的
    <code class="classname">extent_range</code> 对象并加上
    <code class="literal">a_range.</code> <code class="classname">extent_range</code>
对象通过对
    <code class="function">operator[]</code> 的链式调用来聚集。</p>







  </dd>







  <dt><span class="term"><code class="function">gen_type&lt;NumRanges+1&gt;::type
operator[](index idx) const;</code></span></dt>







  <dd>
    
    
    
    
    
    
    
    <p>该函数返回一个新的对象，包含所有以前的 <code class="classname">extent_range</code> 对象并加上
    <code class="literal">extent_range(0,idx).</code> 该函数使得数组构造函数具有与传统C的多维数组声明类似的语法。</p>







  </dd>







</dl>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id862083"></a>全局对象</h3>







</div>







</div>







</div>







<p>为了语法上的方便，Boost.MultiArray 定义了两个全局对象作为其接口的一部分。这些对象扮演了对象生成器的角色；包含它们的表达式可以创建其它所需的对象。
</p>







<p>在某些情形下，这两个全局对象可能被认为开销太大。可以通过在包含
<code class="filename">boost/multi_array.hpp</code> 之前定义预处理符号
<code class="literal">BOOST_MULTI_ARRAY_NO_GENERATORS</code> 来禁止它们的构造。<code class="filename"></code></p>







<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="extents"></a><code class="literal">extents</code></h4>







</div>







</div>







</div>







<pre class="programlisting">namespace boost {<br>  multi_array_base::extent_gen extents;<br>}<br></pre>







<p>Boost.MultiArray 的数组类使用
<code class="literal">extents</code> 全局对象来在构造时指定数组的形状。例如，一个 3 乘 3 乘 3 的 <code class="classname">multi_array</code> 构造如下：
</p>







<pre class="programlisting">multi_array&lt;int,3&gt; A(extents[3][3][3]);</pre>







<p>同样的数组也可以通过显式一个局部的 <code class="literal">extent_gen</code> 
对象来创建，不过使用全局对象可以不需要进行声明。  
</p>







</div>







<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="indices"></a><code class="literal">indices</code></h4>







</div>







</div>







</div>







<pre class="programlisting">namespace boost {<br>  multi_array_base::index_gen  indices;<br>}<br></pre>







<p>MultiArray 概念给出了一个
<code class="literal">index_gen</code> 相关类型用于创建视图。<code class="literal">indices</code> 是一个全局对象，担任了本库所提供的所有数组组件及其相关子数组和视图的
<code class="literal">index_gen</code> 角色。 
</p>







<p>例如，使用 <code class="literal">indices</code> 对象，数组 <code class="literal">A</code> 的一个视图可以构造如下：
</p>







<pre class="programlisting">A[indices[index_range(0,5)][2][index_range(2,4)]];<br></pre>







<p>
</p>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="generators"></a>视图与子数组生成器</h3>







</div>







</div>







</div>







<p>
Boost.MultiArray 提供了 traits 类 <code class="literal">subarray_gen</code>,
<code class="literal">const_subarray_gen</code>,
<code class="literal">array_view_gen</code>, 和 <code class="literal">const_array_view_gen</code>, 用于在函数模板中表示数组的各个相关类型。通常，没有比使用嵌套类型生成器更为方便的方法了，不过本库的作者发现，有些C++编译器不能正确处理嵌套在函数模板的参数类型中的模板。为此，这些生成器需要另外的解决方法。以下代码片断示范了 <code class="literal">array_view_gen</code>
traits 类和相关数组的 <code class="literal">array_view</code> 类型之间的对应关系：

</p>







<pre class="programlisting">template &lt;typename Array&gt;<br>void my_function() {<br>  typedef typename Array::template array_view&lt;3&gt;::type view1_t;<br>  typedef typename boost::array_view_gen&lt;Array,3&gt;::type view2_t;<br>  // ...<br>}<br></pre>







<p>

在上例中，<code class="literal">view1_t</code> 和
<code class="literal">view2_t</code> 具有相同类型。
</p>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="memory_layout"></a>内存布局指示符</h3>







</div>







</div>







</div>







<p>多维数组表示了由多个元素容器组成的层次结构，而这些元素必须被置于内存中。所以，一个多维数组可以用多种方法在内存中表示。
</p>







<p>例如，有以下矩阵所表示的一个2维数组：

</p>







<div><img src="matrix.gif"></div>







<p>这个数组在C++中可以表示为：
</p>







<pre class="programlisting">int a[3][4] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };<br></pre>







<p>这是一个行优先存储的例子，每行的元素被连续存储。除了让C++来处理对数组元素的访问以外，你也可以自己手工管理这个数组以及它的索引。其中一种方法可能是这样：
</p>







<pre class="programlisting">int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };<br>int s[] = { 4, 1 };<br></pre>







<p>在声明了 <code class="literal">a</code> 和步幅 <code class="literal">s</code> 之后，数组的元素 <code class="literal">a(i,j)</code>
可以用以下表达式来访问： 
</p>







<pre class="programlisting">*a+i*s[0]+j*s[1]</pre>







<p>.
</p>







<p>同一个2维数组也可以按列存储如下：

</p>







<pre class="programlisting">int a[] = { 0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11 };<br>int s[] = { 3, 1 };<br></pre>







<p>注意，这里的步幅有所不同。所以，前面给出的访问元素的表达式必须与该数据和步幅一起使用。
</p>







<p>除了维度的顺序，还有可能以降序方式保存某个维度。例如，回到第一个例子，数组的第一个维度，即行，可能以相反的顺序保存如下：

</p>







<pre class="programlisting">int data[] = { 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3 };<br>int *a = data + 8;<br>int s[] = { -4, 1 };<br></pre>







<p>注意，在这个例子中，<code class="literal">a</code> 必须显式地设置为原点。在前面的例子中，保存在内存中的第一个元素即为原点；而这里不再是如此了。 
</p>







<p>另外，第二个维度，即列，也可能以相反的顺序保存，而行则以升序保存：

</p>







<pre class="programlisting">int data[] = { 3, 2, 1, 0,  7, 6, 5, 4, 11, 10, 9, 8 };<br>int *a = data + 3;<br>int s[] = { 4, -1 };<br></pre>







<p>
</p>







<p>最后，也可能两个维度均以降序保存：

</p>







<pre class="programlisting">int data[] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};<br>int *a = data + 11;<br>int s[] = { -4, -1 };<br></pre>







<p>
<code class="literal">
</code>
</p>







<p>以上各个数组都是等价的。前面给出的访问 <code class="literal">a(i,j)</code> 的表达式在各种内存布局下均得到相同的值。Boost.MultiArray 数组可以按以上所说的各种定制的存储参数来创建。因此，已有的数据可以被适配(通过 <code class="literal">multi_array_ref</code> 或
<code class="literal">const_multi_array_ref</code>)以适应数组的抽象。该特性的一个常见用法是，包装一个需要与Fortran程序交互的数组，使它可以被C++和Fortran同时操作。下面几节将讲述用于指定内存布局的 Boost.MultiArray 组件。
</p>







<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="c_storage_order"></a><code class="literal">c_storage_order</code></h4>







</div>







</div>







</div>







<pre class="programlisting">class c_storage_order {<br>  c_storage_order();<br>};<br></pre>







<p><code class="literal">c_storage_order</code> 用于指定一个数组以与原生C++多维数组相同的内存布局来存储其元素，即从最后一维到第一维。这是本库所提供的各种数组的缺省存储顺序。</p>







</div>







<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="fortran_storage_order"></a><code class="literal">fortran_storage_order</code></h4>







</div>







</div>







</div>







<pre class="programlisting">class fortran_storage_order {<br>  fortran_storage_order();<br>};<br></pre>







<p><code class="literal">fortran_storage_order</code> 用于指定一个数组以与Fortran多维数组相同的内存布局来存储其元素，即从第一维到最后一维。</p>







</div>







<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="general_storage_order"></a><code class="literal">general_storage_order</code></h4>







</div>







</div>







</div>







<pre class="programlisting">template &lt;std::size_t NumDims&gt; <br>class general_storage_order {<br><br>  template &lt;typename OrderingIter, typename AscendingIter&gt;<br>  general_storage_order(OrderingIter ordering, AscendingIter ascending);<br>};<br></pre>







<p><code class="literal">general_storage_order</code> 允许用户为一个数组中的内容指定各种不同的内存布局。构造出来的对象将被传递给数组的构造函数，以指定存储顺序。</p>







<p>
<code class="literal">OrderingIter</code> 和 <code class="literal">AscendingIter</code>
必须符合 <code class="literal">InputIterator</code> 概念。这两个迭代器都必须引向包含 <code class="literal">NumDims</code>
个元素的区间。<code class="literal">AscendingIter</code> 指向一组可转换为 <code class="literal">bool</code> 的对象。对象值为
<code class="literal">true</code> 代表该维以升序存储，为 <code class="literal">false</code> 则代表该维以降序存储。<code class="literal">OrderingIter</code> 则指定保存各个维度的顺序。
</p>







</div>







</div>







<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="range_checking"></a>范围检查</h3>







</div>







</div>







</div>







<p>缺省情况下，数组访问方法 <code class="literal">operator()</code> 和
<code class="literal">operator[]</code> 都执行范围检查。如果给定的索引值超出了数组所定义的范围，将引发一个断言并退出程序。要关闭范围检查(为了产品发布版本的性能原因)，请在应用程序包含 multi_array.hpp 之前定义 <code class="literal">BOOST_DISABLE_ASSERTS</code> 预处理器宏。
</p>







</div>







</div>







</div>







</body>
</html>

<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta name="translator" content="xuwaters@qq.com" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Boost Parameter 库 Python 绑定文档</title>
<meta name="authors" content="Daniel Wallin" />
<meta name="organization" content="Boost Consulting" />
<meta name="date" content="2006-09-21" />
<meta name="copyright" content="Copyright David Abrahams, Daniel Wallin 2005. Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)" />
<link rel="stylesheet" href="rst.css" type="text/css" />
</head>
<body>
<div class="document" id="the-boost-parameter-library-python-binding-documentation">
<h1 class="title">Boost Parameter 库 Python 绑定文档</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">作者:</th>
<td>Daniel Wallin</td></tr>
<tr><th class="docinfo-name">联系方式:</th>
<td><a class="first last reference" href="mailto:dalwan01&#64;student.umu.se">dalwan01&#64;student.umu.se</a></td></tr>
<tr><th class="docinfo-name">组织:</th>
<td><a class="first last reference" href="http://www.boost-consulting.com">Boost Consulting</a></td></tr>
<tr><th class="docinfo-name">日期:</th>
<td>2006-09-21</td></tr>
<tr><th class="docinfo-name">版权:</th>
<td>Copyright David Abrahams, Daniel Wallin
2005. Distributed under the Boost Software License,
Version 1.0. (See accompanying file LICENSE_1_0.txt
or copy at <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</td></tr>
</tbody>
</table>
<div class="abstract topic">
<p class="topic-title first">摘要</p>
<p>Makes it possible to bind Boost.Parameter-enabled
functions, operators and constructors to Python.
使我们可以将 Boost.Parameter 式 (Boost.Parameter-enabled) 的函数，操作符和构造函数绑定到 Python。
</p>
</div>
<p><a class="reference" href="../../../../index.htm"><img alt="Boost" src="../../../../boost.png" /></a></p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents 目录</a></p>
<ul class="simple">
<li><a class="reference" href="#introduction" id="id8" name="id8">Introduction 介绍</a></li>
<li><a class="reference" href="#tutorial" id="id9" name="id9">Tutorial 教程</a></li>
<li><a class="reference" href="#concept-parameterspec" id="id10" name="id10">concept <span class="concept">ParameterSpec</span>
概念 <span class="concept">ParameterSpec</span></a></li>
<li><a class="reference" href="#special-keywords" id="id11" name="id11"><em>special</em> keywords <em>特殊的</em> 关键字</a></li>
<li><a class="reference" href="#class-template-init" id="id12" name="id12">class template <tt class="docutils literal"><span class="pre">init</span></tt>
类模板 <tt class="docutils literal"><span class="pre">init</span></tt> </a></li>
<li><a class="reference" href="#class-template-call" id="id13" name="id13">class template <tt class="docutils literal"><span class="pre">call</span></tt>
类模板 <tt class="docutils literal"><span class="pre">call</span></tt> </a></li>
<li><a class="reference" href="#class-template-function" id="id14" name="id14">class template <tt class="docutils literal"><span class="pre">function</span></tt>
类模板 <tt class="docutils literal"><span class="pre">function</span></tt> </a></li>
<li><a class="reference" href="#function-template-def" id="id15" name="id15">function template <tt class="docutils literal"><span class="pre">def</span></tt>
函数模板 <tt class="docutils literal"><span class="pre">def</span></tt> </a></li>
<li><a class="reference" href="#portability" id="id16" name="id16">Portability 可移植性</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="introduction" name="introduction">Introduction 介绍</a></h1>
<p><tt class="docutils literal"><span class="pre">boost/parameter/python.hpp</span></tt> introduces a group of <a class="reference" href="../../../python/doc/v2/def_visitor.html"><tt class="docutils literal"><span class="pre">def_visitors</span></tt></a> that can
be used to easily expose Boost.Parameter-enabled member functions to Python with
Boost.Python. It also provides a function template <tt class="docutils literal"><span class="pre">def()</span></tt> that can be used
to expose Boost.Parameter-enabled free functions.
</p>
<p>
<tt class="docutils literal"><span class="pre">boost/parameter/python.hpp</span></tt> 引入了一
组 <a class="reference" href="../../../python/doc/v2/def_visitor.html"><tt class="docutils literal"><span class="pre">def_visitors</span></tt></a>，
使用 Boost.Python 库，它们可以被用来狠方便的将 Boost.Parameter式 的成员函数暴露给 Python。也提供了一个函数模
板 <tt class="docutils literal"><span class="pre">def()</span></tt>，可以用来暴露那些 Boost.Parameter式 的自由函数（译注：非成员函数）。
</p>

<p>When binding a Boost.Parameter enabled function, the keyword tags
must be specified.  Additionally, because Boost.Parameter enabled
functions are templates, the desired function signature must be
specified.</p>

<p>
在绑定一个 Boost.Parameter式 的函数时，关键字标签(keyword tag)必须被指定。进一步讲，由于 Boost.Parameter式 的函数是模板形式的，
期望的函数签名(function signature)也必须被指定。
</p>
<!-- The keyword tags are specified as an `MPL Sequence`_, using the
pointer qualifications described in |ParameterSpec|_ below.  The
signature is also specifid as an `MPL sequence`_ of parameter
types. Additionally, ``boost::parameter::python::function`` and
``boost::parameter::python::def`` requires a class with forwarding
overloads. We will take a closer look at how this is done in the
tutorial section below. 
-->

<p>The keyword tags and associated argument types are specified as an <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL
Sequence</a>, using the function type syntax described in <a class="reference" href="#concept-parameterspec"><span class="concept">ParameterSpec</span></a>
below. Additionally, <tt class="docutils literal"><span class="pre">boost::parameter::python::function</span></tt> and
<tt class="docutils literal"><span class="pre">boost::parameter::python::def</span></tt> requires a class with forwarding overloads.
We will take a closer look at how this is done in the tutorial section below.</p>

<p>
关键字标签和与其相关的参数类型都是由一个 <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL Sequence</a> 指定的，
指定函数类型的语法在下面的 <a class="reference" href="#concept-parameterspec"><span class="concept">ParameterSpec</span></a> 中有讲到。
进一步讲，<tt class="docutils literal"><span class="pre">boost::parameter::python::function</span></tt> 和
<tt class="docutils literal"><span class="pre">boost::parameter::python::def</span></tt> 都要求一个带有 转交重载函数(forwarding overload) 的类。
我们会在下面的教程章节中仔细讲解这些是如何做到的。
</p>

<!-- The last two sentences are terribly vague.  Which namespace is -->
<!-- ``function`` in?  Isn't the return type always needed?  What -->
<!-- else are we going to do other than pass these sequences to -->
<!-- function? -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="tutorial" name="tutorial">Tutorial 教程</a></h1>
<p>In this section we will outline the steps needed to bind a simple
Boost.Parameter-enabled member function to Python. Knowledge of the
Boost.Parameter <a class="reference" href="index.html">macros</a> are required to understand this section.</p>

<p>
在这一节中，我们列出绑定一个简单 Boost.Parameter式 的成员函数到 Python 的步骤。要理解这一节，你需要
了解 Boost.Parameter 库的 <a class="reference" href="index.html">一些相关宏</a> 的知识。
</p>

<p>The class and member function we are interested in binding looks
like this:</p>

<p>
在绑定中过程，我们感兴趣的类和成员函数看起来是这样的：
</p>

<pre class="literal-block">
#include &lt;boost/parameter/keyword.hpp&gt;
#include &lt;boost/parameter/preprocessor.hpp&gt;
#include &lt;boost/parameter/python.hpp&gt;
#include &lt;boost/python.hpp&gt;

// First the keywords 首先是关键字
BOOST_PARAMETER_KEYWORD(tag, title)
BOOST_PARAMETER_KEYWORD(tag, width)
BOOST_PARAMETER_KEYWORD(tag, height)

class window
{
public:
    BOOST_PARAMETER_MEMBER_FUNCTION(
      (void), open, tag,
      (required (title, (std::string)))
      (optional (width, (unsigned), 400)
                (height, (unsigned), 400))
    )
    {
        <em>… function implementation 函数实现 …</em>
    }
};
</pre>
<!-- @example.prepend('#include <cassert>') -->
<!-- @example.replace_emphasis('''
assert(title == "foo");
assert(height == 20);
assert(width == 400);
''') -->

<p>It defines a set of overloaded member functions called <tt class="docutils literal"><span class="pre">open</span></tt> with one
required parameter and two optional ones. To bind this member function to
Python we use the binding utility <tt class="docutils literal"><span class="pre">boost::parameter::python::function</span></tt>.
<tt class="docutils literal"><span class="pre">boost::parameter::python::function</span></tt> is a <a class="reference" href="../../../python/doc/v2/def_visitor.html"><tt class="docutils literal"><span class="pre">def_visitor</span></tt></a> that we'll instantiate
and pass to <tt class="docutils literal"><span class="pre">boost::python::class_::def()</span></tt>.</p>

<p>
它定义了一组叫做 <tt class="docutils literal"><span class="pre">open</span></tt> 的重载成员函数，带有一个 必选参变量(required parameter) 和
两个 可选参变量(optional paramter)。要将这个成员函数绑定到 Python，我们使用绑定工具 <tt class="docutils literal"><span class="pre">boost::parameter::python::function</span></tt>。
</p>

<p>To use <tt class="docutils literal"><span class="pre">boost::parameter::python::function</span></tt> we first need to define
a class with forwarding overloads.</p>

<p>
要使用 <tt class="docutils literal"><span class="pre">boost::parameter::python::function</span></tt>，我们首先需要定义一个带有 转交重载函数(forwarding overload) 的类。
</p>

<pre class="literal-block">
struct open_fwd
{
    template &lt;class A0, class A1, class A2&gt;
    void operator()(
        boost::type&lt;void&gt;, window&amp; self
      , A0 const&amp; a0, A1 const&amp; a1, A2 const&amp; a2
    )
    {
        self.open(a0, a1, a2);
    }
};
</pre>

<p>The first parameter, <tt class="docutils literal"><span class="pre">boost::type&lt;void&gt;</span></tt>, tells the forwarding overload
what the return type should be. In this case we know that it's always void
but in some cases, when we are exporting several specializations of a
Boost.Parameter-enabled template, we need to use that parameter to
deduce the return type.</p>

<p>
第一个参变量，<tt class="docutils literal"><span class="pre">boost::type&lt;void&gt;</span></tt>，告诉 转交重载函数(forwarding overload) 返
回值的类型是什么。在这里，我们知道它就是 void，但是在某些情况下，当我们导出一个 Boost.Parameter式 模板的 特化版本(speicialization) 时，我们
需要使用这个参变量来推导返回类型。
</p>

<p><tt class="docutils literal"><span class="pre">window::open()</span></tt> takes a total of 3 parameters, so the forwarding function
needs to take three parameters as well.</p>

<p>
<tt class="docutils literal"><span class="pre">window::open()</span></tt> 一共带三个参变量，因此 转接函数(forwarding function) 也需要带有三个参变量。
</p>

<div class="note">
<p class="first admonition-title">Note 注意</p>
<p class="last">We only need one overload in the forwarding class, despite the
fact that there are two optional parameters. There are special
circumstances when several overload are needed; see
<a class="reference" href="#special-keywords">special keywords</a>.</p>

<p>
尽管有两个可选参变量(parameter)，在 转交类(forwarding class) 中我们只需要一个 重载函数(overload)。在某些特殊的环境下，会需要多个重载函数；
参见 <a class="reference" href="#special-keywords">特殊关键字(special keywords)</a>。
</p>
</div>
<p>Next we'll define the module and export the class:</p>
<p>接下来，我们就可以定义模块并导出类了：</p>
<pre class="literal-block">
BOOST_PYTHON_MODULE(my_module)
{
    using namespace boost::python;
    namespace py = boost::parameter::python;
    namespace mpl = boost::mpl;

    class_&lt;window&gt;(&quot;window&quot;)
        .def(
            &quot;open&quot;, py::function&lt;
                open_fwd
              , mpl::vector&lt;
                    void
                  , tag::title(std::string)
                  , tag::width*(unsigned)
                  , tag::height*(unsigned)
                &gt;
            &gt;()
        );
}
</pre>
<!-- @jam_prefix.append('import python ;') -->
<!-- @jam_prefix.append('stage . : my_module /boost/python//boost_python ;') -->
<!-- @my_module = build(
    output = 'my_module'
  , target_rule = 'python-extension'
  , input = '/boost/python//boost_python'
  , howmany = 'all'
) -->
<!-- @del jam_prefix[:] -->
<p><tt class="docutils literal"><span class="pre">py::function</span></tt> is passed two parameters. The first one is the class with
forwarding overloads that we defined earlier. The second one is an <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL
Sequence</a> with the keyword tag types and argument types for the function
specified as function types. The pointer syntax used in <tt class="docutils literal"><span class="pre">tag::width*</span></tt> and
<tt class="docutils literal"><span class="pre">tag::height*</span></tt> means that the parameter is optional. The first element of
the <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL Sequence</a> is the return type of the function, in this case <tt class="docutils literal"><span class="pre">void</span></tt>.</p>

<p>
有两个参变量传给了 <tt class="docutils literal"><span class="pre">py::function</span></tt>。第一个是我们早先定义的带
有 转交重载函数(forwarding overload) 的类。第二个是一带有 关键字标签类型(keyword tag type) 和 参数类型（被声明为函数类型）
的 <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL Sequence</a>。
在 <tt class="docutils literal"><span class="pre">tag::width*</span></tt> 和 <tt class="docutils literal"><span class="pre">tag::height*</span></tt> 中
使用的指针(pointer)语法表示这个 参变量(parameter) 是可选的。<a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL Sequence</a> 中
的第一个元素是这个函数的返回类型，在这里就是 <tt class="docutils literal"><span class="pre">void</span></tt>。
</p>
<!-- The
pointer syntax means that the parameter is optional, so in this case
``width`` and ``height`` are optional parameters. The third parameter
is an `MPL Sequence`_ with the desired function signature. The return type comes first, and
then the parameter types:

.. parsed-literal::

    mpl::vector<void,        std::string, unsigned, unsigned>
                *return type*  *title*        *width*     *height*

.. @ignore() -->
<p>That's it! This class can now be used in Python with the expected syntax:</p>
<p>好啦！现在这个类就可以在 Python 中用我们期望的语法使用了：</p>
<pre class="literal-block">
&gt;&gt;&gt; w = my_module.window()
&gt;&gt;&gt; w.open(title = &quot;foo&quot;, height = 20)
</pre>
<!-- @example.prepend('import my_module') -->
<!-- @run_python(module_path = my_module) -->
<!-- Sorry to say this at such a late date, but this syntax really -->
<!-- strikes me as cumbersome.  Couldn't we do something like:

 class_<window>("window")
       .def(
           "open",
           (void (*)(
               tag::title(std::string),
               tag::width*(unsigned),
               tag::height*(unsigned))
           )0
       );

or at least:

   class_<window>("window")
       .def(
           "open",
           mpl::vector<
               void,
               tag::title(std::string),
               tag::width*(unsigned),
               tag::height*(unsigned)
           >()
       );

assuming, that is, that we will have to repeat the tags (yes,
users of broken compilers will have to give us function pointer
types instead). -->
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id10" id="concept-parameterspec" name="concept-parameterspec">概念 <span class="concept">ParameterSpec</span></a></h1>
<p>A <span class="concept">ParameterSpec</span> is a function type <tt class="docutils literal"><span class="pre">K(T)</span></tt> that describes both the keyword tag,
<tt class="docutils literal"><span class="pre">K</span></tt>, and the argument type, <tt class="docutils literal"><span class="pre">T</span></tt>, for a parameter.</p>

<p>
<span class="concept">ParameterSpec</span> 是一个 <tt class="docutils literal"><span class="pre">K(T)</span></tt> 式的函数类型，它描述
了一个参变量(parameter)的 关键字标签(keyword tag) <tt class="docutils literal"><span class="pre">K</span></tt>，和
参数类型 <tt class="docutils literal"><span class="pre">T</span></tt>。
</p>

<p><tt class="docutils literal"><span class="pre">K</span></tt> is either:</p>
<p><tt class="docutils literal"><span class="pre">K</span></tt> 是下面之一：</p>

<ul class="simple">
<li>A <em>required</em> keyword of the form <tt class="docutils literal"><span class="pre">Tag</span></tt></li>
<li>一个 <tt class="docutils literal"><span class="pre">Tag</span></tt> 形式的 <em>必选</em> 关键字</li>
<li><strong>or</strong>, an <em>optional</em> keyword of the form <tt class="docutils literal"><span class="pre">Tag*</span></tt></li>
<li><strong>或者</strong>，一个 <tt class="docutils literal"><span class="pre">Tag*</span></tt> 形式的 <em>可选的</em> 关键字</li>
<li><strong>or</strong>, a <em>special</em> keyword of the form <tt class="docutils literal"><span class="pre">Tag**</span></tt></li>
<li><strong>或者</strong>，一个 <tt class="docutils literal"><span class="pre">Tag**</span></tt> 形式的 <em>特殊</em> 关键字</li>
</ul>

<p>where <tt class="docutils literal"><span class="pre">Tag</span></tt> is a keyword tag type, as used in a specialization
of <a class="reference" href="../../../parameter/doc/html/reference.html#keyword"><tt class="docutils literal"><span class="pre">boost::parameter::keyword</span></tt></a>.</p>

<p>
这里 <tt class="docutils literal"><span class="pre">Tag</span></tt> 是一个关键字标签类型(keyword tag type)，就像
在 <a class="reference" href="../../../parameter/doc/html/reference.html#keyword"><tt class="docutils literal"><span class="pre">boost::parameter::keyword</span></tt></a> 里规范的那样使用。
</p>

<p>The <strong>arity range</strong> for an <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL Sequence</a> of <span class="concept">ParameterSpec</span>'s is
defined as the closed range:</p>

<p>
一个 <span class="concept">ParameterSpec</span> 的 <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL Sequence</a> 的 <strong>元数区间(arity range)</strong> 是由下面的全闭区间定义的：
</p>

<pre class="literal-block">
[ mpl::size&lt;S&gt; - number of <em>special</em> keyword tags in <tt class="docutils literal"><span class="pre">S</span></tt>, mpl::size&lt;S&gt; ]
</pre>
<pre class="literal-block">
[ mpl::size&lt;S&gt; - <tt class="docutils literal"><span class="pre">S</span></tt> 中<em>特殊</em>关键字标签(keyword tag)的个数 , mpl::size&lt;S&gt; ]
（译注：也就是 [ 非特殊关键字标签的个数 , 关键字标签的个数 ] ）
</pre>

<p>For example, the <strong>arity range</strong> of <tt class="docutils literal"><span class="pre">mpl::vector2&lt;x(int),y(int)&gt;</span></tt> is <tt class="docutils literal"><span class="pre">[2,2]</span></tt>,
the <strong>arity range</strong> of <tt class="docutils literal"><span class="pre">mpl::vector2&lt;x(int),y*(int)&gt;</span></tt> is <tt class="docutils literal"><span class="pre">[2,2]</span></tt> and the
<strong>arity range</strong> of <tt class="docutils literal"><span class="pre">mpl::vector2&lt;x(int),y**(int)&gt;</span></tt> is <tt class="docutils literal"><span class="pre">[1,2]</span></tt>.</p>

<p>
比如，<tt class="docutils literal"><span class="pre">mpl::vector2&lt;x(int),y(int)&gt;</span></tt> 的 <strong>元数区间(arity range)</strong> 是 <tt class="docutils literal"><span class="pre">[2,2]</span></tt>，<tt class="docutils literal"><span class="pre">mpl::vector2&lt;x(int),y*(int)&gt;</span></tt> 的 <strong>元数区间(arity range)</strong> 是 <tt class="docutils literal"><span class="pre">[2,2]</span></tt>，<tt class="docutils literal"><span class="pre">mpl::vector2&lt;x(int),y**(int)&gt;</span></tt> 的 <strong>元数区间(arity range)</strong> 是 <tt class="docutils literal"><span class="pre">[1,2]</span></tt>。
</p>

</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="special-keywords" name="special-keywords"><em>special</em> keywords <em>特殊</em> 关键字</a></h1>
<p>Sometimes it is desirable to have a default value for a parameter that differ
in type from the parameter. This technique is useful for doing simple tag-dispatching
based on the presence of a parameter. An <a class="reference" href="index.html#dispatching-based-on-the-presence-of-a-default">example</a> of this is given in the Boost.Parameter
docs. The example uses a different technique, but could also have been written like this:</p>

<p>
有时候，我们希望能够为参变量(parameter)赋一个默认值，但是这个默认值的类型不是参变量(parameter)的类型。
这种技术在基于现有参变量做一些简单的 标签分发(tag-dispatching) 的时候非常有用。
在 Boost.Parameter 的文档里面有一个这样的 <a class="reference" href="index.html#dispatching-based-on-the-presence-of-a-default">例子</a>。
</p>

<pre class="literal-block">
namespace core
{
  template &lt;class ArgumentPack&gt;
  void dfs_dispatch(ArgumentPack const&amp; args, mpl::false_)
  {
      <em>…compute and use default color map 计算并使用默认的 color map …</em>
  }

  template &lt;class ArgumentPack, class ColorMap&gt;
  void dfs_dispatch(ArgumentPack const&amp; args, ColorMap colormap)
  {
      <em>…use colormap 使用 colormap …</em>
  }
}

template &lt;class ArgumentPack&gt;
void depth_first_search(ArgumentPack const&amp; args)
{
    core::dfs_dispatch(args, args[color | mpl::false_()]);
}
</pre>
<!-- @example.prepend('''
#include <boost/parameter/keyword.hpp>
#include <boost/parameter/parameters.hpp>
#include <boost/mpl/bool.hpp>
#include <cassert>

BOOST_PARAMETER_KEYWORD(tag, color);

typedef boost::parameter::parameters<tag::color> params;

namespace mpl = boost::mpl;
''') -->
<!-- @example.replace_emphasis('''
assert(args[color | 1] == 1);
''') -->
<!-- @example.replace_emphasis('''
assert(args[color | 1] == 0);
''') -->
<!-- @example.append('''
int main()
{
    depth_first_search(params()());
    depth_first_search(params()(color = 0));
}''') -->
<!-- @build() -->
<p>In the above example the type of the default for <tt class="docutils literal"><span class="pre">color</span></tt> is <tt class="docutils literal"><span class="pre">mpl::false_</span></tt>, a
type that is distinct from any color map that the user might supply.</p>
<p>
在上面的这个例子里面，<tt class="docutils literal"><span class="pre">color</span></tt> 默认值的类型是 <tt class="docutils literal"><span class="pre">mpl::false_</span></tt>，而这个类型是跟任何可能提供的 color map 的类型都不相同的。
</p>
<p>When binding the case outlined above, the default type for <tt class="docutils literal"><span class="pre">color</span></tt> will not
be convertible to the parameter type. Therefore we need to tag the <tt class="docutils literal"><span class="pre">color</span></tt>
keyword as a <em>special</em> keyword. By doing this we tell the binding functions
that it needs to generate two overloads, one with the <tt class="docutils literal"><span class="pre">color</span></tt> parameter
present and one without. Had there been two <em>special</em> keywords, four
overloads would need to be generated. The number of generated overloads is
equal to 2<sup>N</sup>, where <tt class="docutils literal"><span class="pre">N</span></tt> is the number of <em>special</em> keywords.</p>

<p>
在绑定上面列出的情况时，<tt class="docutils literal"><span class="pre">color</span></tt> 的默认值类型将不能转化成参变量的类型。因此我们需要
将 <tt class="docutils literal"><span class="pre">color</span></tt> 标记为一个 <em>特殊</em> 关键字。这样做之后，我们就是告诉绑定函数它可能需要
生成两个重载函数，一个是带有 <tt class="docutils literal"><span class="pre">color</span></tt> 参变量的，一个是没有的。
要是有两个 <em>特殊</em> 关键字，就需要生成四个重载函数。生成的重载函数的个数等于 2<sup>N</sup>，这
里 <tt class="docutils literal"><span class="pre">N</span></tt> 是 <em>特殊</em> 关键字的个数。
</p>

</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id12" id="class-template-init" name="class-template-init">class template <tt class="docutils literal"><span class="pre">init</span></tt> 类模板 <tt class="docutils literal"><span class="pre">init</span></tt> </a></h1>
<p>Defines a named parameter enabled constructor.</p>
<p>定义一个有名的 Parameter式 的构造函数。</p>
<pre class="literal-block">
template &lt;class ParameterSpecs&gt;
struct init : python::def_visitor&lt;init&lt;ParameterSpecs&gt; &gt;
{
    template &lt;class Class&gt;
    void def(Class&amp; class_);

    template &lt;class CallPolicies&gt;
    <em>def_visitor</em> operator[](CallPolicies const&amp; policies) const;
};
</pre>
<!-- @ignore() -->
<div class="section">
<h2><a id="init-requirements" name="init-requirements"><tt class="docutils literal"><span class="pre">init</span></tt> requirements 
<tt class="docutils literal"><span class="pre">init</span></tt> 约束条件</a></h2>
<ul>
<li>
<p class="first"><tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> is an <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a> where each element is a
model of <span class="concept">ParameterSpec</span>.

<tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> 是其每一元素都是 <span class="concept">ParameterSpec</span> 模型 的 <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a>。
</p>
</li>

<li><p class="first">For every <tt class="docutils literal"><span class="pre">N</span></tt> in <tt class="docutils literal"><span class="pre">[U,V]</span></tt>, where <tt class="docutils literal"><span class="pre">[U,V]</span></tt> is the <strong>arity
range</strong> of <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt>, <tt class="docutils literal"><span class="pre">Class</span></tt> must support these
expressions:

对于 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 里的每一个 <tt class="docutils literal"><span class="pre">N</span></tt>，
这里 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 是 <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> 的
<strong>元数区间(arity range)</strong>，<tt class="docutils literal"><span class="pre">Class</span></tt> 必须支持下面的这些表达式：
</p>
<table border="1" class="docutils table">
<colgroup>
<col width="30%" />
<col width="17%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p class="first last">Expression 表达式</p>
</th>
<th class="head"><p class="first last">Return type 返回类型</p>
</th>
<th class="head"><p class="first last">Requirements 约束条件</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">Class(a0,</span> <span class="pre">…,</span> <span class="pre">aN)</span></tt></p>
</td>
<td><p class="first last">-</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> are tagged arguments.
<tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> 必须是带标签的参数(tagged arguments)。
</p>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div class="section">
<h2><a id="template-class-callpolicies-operator-callpolicies-const" name="template-class-callpolicies-operator-callpolicies-const"><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">CallPolicies&gt;</span> <span class="pre">operator[](CallPolicies</span> <span class="pre">const&amp;)</span></tt></a></h2>
<p>Returns a <tt class="docutils literal"><span class="pre">def_visitor</span></tt> equivalent to <tt class="docutils literal"><span class="pre">*this</span></tt>, except that it
uses CallPolicies when creating the binding.</p>
<p>
返回一个跟 <tt class="docutils literal"><span class="pre">*this</span></tt> 相等的 <tt class="docutils literal"><span class="pre">def_visitor</span></tt>，只是在创建绑定的时候它使用的是 CallPolicies。
</p>
</div>
<div class="section">
<h2><a id="id3" name="id3">Example 例子</a></h2>
<pre class="literal-block">
#include &lt;boost/parameter/keyword.hpp&gt;
#include &lt;boost/parameter/preprocessor.hpp&gt;
#include &lt;boost/parameter/python.hpp&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;

BOOST_PARAMETER_KEYWORD(tag, x)
BOOST_PARAMETER_KEYWORD(tag, y)

struct base
{
    template &lt;class ArgumentPack&gt;
    base(ArgumentPack const&amp; args)
    {
        <em>… use args 使用这些参数 …</em>
    }
};

class X : base
{
public:
    BOOST_PARAMETER_CONSTRUCTOR(X, (base), tag,
        (required (x, *))
        (optional (y, *))
    )
};

BOOST_PYTHON_MODULE(<em>module name</em>)
{
    using namespace boost::python;
    namespace py = boost::parameter::python;
    namespace mpl = boost::mpl;

    class_&lt;X&gt;(&quot;X&quot;, no_init)
        .def(
            py::init&lt;
                mpl::vector&lt;tag::x(int), tag::y*(int)&gt;
            &gt;()
        );
}
</pre>
<!-- @example.replace_emphasis('''
assert(args[x] == 0);
assert(args[y | 1] == 1);
''') -->
<!-- @example.replace_emphasis('my_module') -->
<!-- @jam_prefix.append('import python ;') -->
<!-- @jam_prefix.append('stage . : my_module /boost/python//boost_python ;') -->
<!-- @my_module = build(
    output = 'my_module'
  , target_rule = 'python-extension'
  , input = '/boost/python//boost_python'
) -->
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id13" id="class-template-call" name="class-template-call">class template <tt class="docutils literal"><span class="pre">call</span></tt> 
类模板 <tt class="docutils literal"><span class="pre">call</span></tt> </a></h1>
<p>Defines a <tt class="docutils literal"><span class="pre">__call__</span></tt> operator, mapped to <tt class="docutils literal"><span class="pre">operator()</span></tt> in C++.</p>
<p>
定义了一个 <tt class="docutils literal"><span class="pre">__call__</span></tt> 操作符，映射到 C++ 里面的 <tt class="docutils literal"><span class="pre">operator()</span></tt> 操作符。
</p>
<pre class="literal-block">
template &lt;class ParameterSpecs&gt;
struct call : python::def_visitor&lt;call&lt;ParameterSpecs&gt; &gt;
{
    template &lt;class Class&gt;
    void def(Class&amp; class_);

    template &lt;class CallPolicies&gt;
    <em>def_visitor</em> operator[](CallPolicies const&amp; policies) const;
};
</pre>
<!-- @ignore() -->
<div class="section">
<h2><a id="call-requirements" name="call-requirements"><tt class="docutils literal"><span class="pre">call</span></tt> requirements 
<tt class="docutils literal"><span class="pre">call</span></tt> 约束条件</a></h2>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> is an <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a> where each element
except the first models <span class="concept">ParameterSpec</span>. The first element
is the result type of <tt class="docutils literal"><span class="pre">c(…)</span></tt>.

<tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> 是其除了第一个元素外的每一元素都是 <span class="concept">ParameterSpec</span> 模型 的 <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a>。
第一个元素是 <tt class="docutils literal"><span class="pre">c(…)</span></tt> 的结果类型(result type)。
</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Class</span></tt> must support these expressions, where <tt class="docutils literal"><span class="pre">c</span></tt> is an
instance of <tt class="docutils literal"><span class="pre">Class</span></tt>:

<tt class="docutils literal"><span class="pre">Class</span></tt> 必须支持一下这些表达式，其中 <span class="pre">c</span></tt> 是 <tt class="docutils literal"><span class="pre">Class</span></tt> 的一个实例：
</p>
<table border="1" class="docutils table">
<colgroup>
<col width="24%" />
<col width="26%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p class="first last">Expression 表达式</p>
</th>
<th class="head"><p class="first last">Return type 返回类型</p>
</th>
<th class="head"><p class="first last">Requirements 约束条件</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">c(a0,</span> <span class="pre">…,</span> <span class="pre">aN)</span></tt></p>
</td>
<td><p class="first last">Convertible to <tt class="docutils literal"><span class="pre">R</span></tt>
能够转化成 <tt class="docutils literal"><span class="pre">R</span></tt> </p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> are tagged arguments.
<tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> 是带标签的参数(tagged arguments)。
</p>
</td>
</tr>
</tbody>
</table>
<p>For every <tt class="docutils literal"><span class="pre">N</span></tt> in <tt class="docutils literal"><span class="pre">[U,V]</span></tt>, where <tt class="docutils literal"><span class="pre">[U,V]</span></tt> is the <strong>arity range</strong> of <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt>.</p>
<p>
对于 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 里的每一个 <tt class="docutils literal"><span class="pre">N</span></tt>，
这里 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 是 <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> 的
<strong>元数区间(arity range)</strong>。
</p>
</li>
</ul>
</div>
<div class="section">
<h2><a id="id4" name="id4"><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">CallPolicies&gt;</span> <span class="pre">operator[](CallPolicies</span> <span class="pre">const&amp;)</span></tt></a></h2>
<p>Returns a <tt class="docutils literal"><span class="pre">def_visitor</span></tt> equivalent to <tt class="docutils literal"><span class="pre">*this</span></tt>, except that it
uses CallPolicies when creating the binding.</p>
<p>
返回一个跟 <tt class="docutils literal"><span class="pre">*this</span></tt> 相等的 <tt class="docutils literal"><span class="pre">def_visitor</span></tt>，只是在创建绑定的时候它使用的是 CallPolicies。
</p>
</div>
<div class="section">
<h2><a id="id5" name="id5">Example 例子</a></h2>
<pre class="literal-block">
#include &lt;boost/parameter/keyword.hpp&gt;
#include &lt;boost/parameter/preprocessor.hpp&gt;
#include &lt;boost/parameter/python.hpp&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;

BOOST_PARAMETER_KEYWORD(tag, x)
BOOST_PARAMETER_KEYWORD(tag, y)

namespace parameter = boost::parameter;

typedef parameter::parameters&lt;
    parameter::required&lt;tag::x&gt;
  , parameter::optional&lt;tag::y&gt;
&gt; call_parameters;

class X
{
public:
    template &lt;class ArgumentPack&gt;
    int call_impl(ArgumentPack const&amp; args)
    {
        <em>… use args 使用这些参数 …</em>
    }

    template &lt;class A0&gt;
    int operator()(A0 const&amp; a0)
    {
        return call_impl(call_parameters()(a0));
    }

    template &lt;class A0, class A1&gt;
    int operator()(A0 const&amp; a0, A1 const&amp; a1)
    {
        return call_impl(call_parameters()(a0,a1));
    }
};

BOOST_PYTHON_MODULE(<em>module name</em>)
{
    using namespace boost::python;
    namespace py = parameter::python;
    namespace mpl = boost::mpl;

    class_&lt;X&gt;(&quot;X&quot;)
        .def(
            py::call&lt;
                mpl::vector&lt;int, tag::x(int), tag::y*(int)&gt;
            &gt;()
        );
}
</pre>
<!-- @example.replace_emphasis('''
assert(args[x] == 0);
assert(args[y | 1] == 1);
return 0;
''') -->
<!-- @example.replace_emphasis('my_module') -->
<!-- @my_module = build(
    output = 'my_module'
  , target_rule = 'python-extension'
  , input = '/boost/python//boost_python'
) -->
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id14" id="class-template-function" name="class-template-function">class template <tt class="docutils literal"><span class="pre">function</span></tt> 类模板 <tt class="docutils literal"><span class="pre">function</span></tt> 
</a></h1>
<p>Defines a named parameter enabled member function.</p>
<p>定义一个有名的 parameter式的 成员函数。</p>
<pre class="literal-block">
template &lt;class Fwd, class ParameterSpecs&gt;
struct function : python::def_visitor&lt;function&lt;Fwd, ParameterSpecs&gt; &gt;
{
    template &lt;class Class, class Options&gt;
    void def(Class&amp; class_, char const* name, Options const&amp; options);
};
</pre>
<!-- @ignore() -->
<div class="section">
<h2><a id="function-requirements" name="function-requirements"><tt class="docutils literal"><span class="pre">function</span></tt> requirements
<tt class="docutils literal"><span class="pre">function</span></tt> 约束条件</a></h2>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> is an <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a> where each element
except the first models <span class="concept">ParameterSpec</span>. The first element
is the result type of <tt class="docutils literal"><span class="pre">c.f(…)</span></tt>, where <tt class="docutils literal"><span class="pre">f</span></tt> is the member
function.</p>

<p class="first">
<tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> 是其除了第一个元素外的每一个元素都
是 <span class="concept">ParameterSpec</span> 模型的一个 <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a>。
第一个元素是 <tt class="docutils literal"><span class="pre">c.f(…)</span></tt> 的结果类型(result type)，其
中 <tt class="docutils literal"><span class="pre">f</span></tt> 是成员函数。
</p>
</li>
<li><p class="first">An instance of <tt class="docutils literal"><span class="pre">Fwd</span></tt> must support this expression:
一个 <tt class="docutils literal"><span class="pre">Fwd</span></tt> 实例必须支持以下的表达式：
</p>
<table border="1" class="docutils table">
<colgroup>
<col width="39%" />
<col width="18%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p class="first last">Expression 表达式</p>
</th>
<th class="head"><p class="first last">Return type 返回类型</p>
</th>
<th class="head"><p class="first last">Requirements 约束条件</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">fwd(boost::type&lt;R&gt;(),</span> <span class="pre">self,</span> <span class="pre">a0,</span> <span class="pre">…,</span> <span class="pre">aN)</span></tt></p>
</td>
<td><p class="first last">Convertible to <tt class="docutils literal"><span class="pre">R</span></tt>
可以转化成 <tt class="docutils literal"><span class="pre">R</span></tt> 
</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">self</span></tt> is a reference to the object on which
the function should be invoked. <tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> are tagged arguments.

<tt class="docutils literal"><span class="pre">self</span></tt> 是指向被调用的成员函数所作用的对象的引用。
<tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> 都是带标签的参数(tagged argument)。
</p>
</td>
</tr>
</tbody>
</table>
<p>For every <tt class="docutils literal"><span class="pre">N</span></tt> in <tt class="docutils literal"><span class="pre">[U,V]</span></tt>, where <tt class="docutils literal"><span class="pre">[U,V]</span></tt> is the <strong>arity range</strong> of <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt>.</p>
<p>
对于 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 里的每一个 <tt class="docutils literal"><span class="pre">N</span></tt>，
这里 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 是 <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> 的
<strong>元数区间(arity range)</strong>。
</p>
</li>
</ul>
</div>
<div class="section">
<h2><a id="id6" name="id6">Example 例子</a></h2>
<p>This example exports a member function <tt class="docutils literal"><span class="pre">f(int</span> <span class="pre">x,</span> <span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">…)</span></tt> to Python. The
sequence of <span class="concept">ParameterSpec</span>'s <tt class="docutils literal"><span class="pre">mpl::vector2&lt;tag::x(int),</span> <span class="pre">tag::y*(int)&gt;</span></tt> has
an <strong>arity range</strong> of [2,2], so we only need one forwarding overload.</p>

<p>
这个例子导出了一个成员函数 <tt class="docutils literal"><span class="pre">f(int</span> <span class="pre">x,</span> <span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">…)</span></tt> 到 Python。
<span class="concept">ParameterSpec</span> 的 <tt class="docutils literal"><span class="pre">mpl::vector2&lt;tag::x(int),</span> <span class="pre">tag::y*(int)&gt;</span></tt> 序列的 <strong>元数区间(arity range)</strong> 是 <span class="pre">[2,2]</span>，因此我们只需要一个 转交重载函数(forwarding overload)。
</p>

<pre class="literal-block">
#include &lt;boost/parameter/keyword.hpp&gt;
#include &lt;boost/parameter/preprocessor.hpp&gt;
#include &lt;boost/parameter/python.hpp&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;

BOOST_PARAMETER_KEYWORD(tag, x)
BOOST_PARAMETER_KEYWORD(tag, y)

class X
{
public:
    BOOST_PARAMETER_MEMBER_FUNCTION((void), f, tag,
        (required (x, *))
        (optional (y, *, 1))
    )
    {
        <em>…</em>
    }
};

struct f_fwd
{
    template &lt;class A0, class A1&gt;
    void operator()(boost::type&lt;void&gt;, X&amp; self, A0 const&amp; a0, A1 const&amp; a1)
    {
        self.f(a0, a1);
    }
};

BOOST_PYTHON_MODULE(<em>module name</em>)
{
    using namespace boost::python;
    namespace py = boost::parameter::python;
    namespace mpl = boost::mpl;

    class_&lt;X&gt;(&quot;X&quot;)
        .def(&quot;f&quot;,
            py::function&lt;
                f_fwd
              , mpl::vector&lt;void, tag::x(int), tag::y*(int)&gt;
            &gt;()
        );
}
</pre>
<!-- @example.replace_emphasis('''
assert(x == 0);
assert(y == 1);
''') -->
<!-- @example.replace_emphasis('my_module') -->
<!-- @my_module = build(
    output = 'my_module'
  , target_rule = 'python-extension'
  , input = '/boost/python//boost_python'
) -->
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id15" id="function-template-def" name="function-template-def">function template <tt class="docutils literal"><span class="pre">def</span></tt>
函数模板 <tt class="docutils literal"><span class="pre">def</span></tt>
</a></h1>
<p>Defines a named parameter enabled free function in the current Python scope.</p>
<p>在当前的 Python 空间(scope)中定义一个有名的 Parameter式 的自由函数。</p>
<pre class="literal-block">
template &lt;class Fwd, class ParameterSpecs&gt;
void def(char const* name);
</pre>
<!-- @ignore() -->
<div class="section">
<h2><a id="def-requirements" name="def-requirements"><tt class="docutils literal"><span class="pre">def</span></tt> requirements
<tt class="docutils literal"><span class="pre">def</span></tt> 约束条件
</a></h2>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> is an <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a> where each element
except the first models <span class="concept">ParameterSpec</span>. The first element
is the result type of <tt class="docutils literal"><span class="pre">f(…)</span></tt>, where <tt class="docutils literal"><span class="pre">f</span></tt> is the function.</p>
<p class="first">
<span class="pre">ParameterSpecs</span></tt> 是其除了第一个元素外的每一个元素都是 <span class="concept">ParameterSpec</span> 模型的一
个 <a class="reference" href="../../../mpl/doc/refmanual/sequences.html">MPL sequence</a>。第一个元素
是 <tt class="docutils literal"><span class="pre">f(…)</span></tt> 的结果类型，这里 <tt class="docutils literal"><span class="pre">f</span></tt> 是
一个函数。
</p>
</li>
<li>
<p class="first">An instance of <tt class="docutils literal"><span class="pre">Fwd</span></tt> must support this expression:</p>
<p class="first">一个 <tt class="docutils literal"><span class="pre">Fwd</span></tt> 的实例必须支持这个表达式：</p>
<table border="1" class="docutils table">
<colgroup>
<col width="39%" />
<col width="21%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p class="first last">Expression 表达式</p>
</th>
<th class="head"><p class="first last">Return type 返回类型</p>
</th>
<th class="head"><p class="first last">Requirements 约束条件</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p class="first last"><tt class="docutils literal"><span class="pre">fwd(boost::type&lt;R&gt;(),</span> <span class="pre">a0,</span> <span class="pre">…,</span> <span class="pre">aN)</span></tt></p>
</td>
<td>
<p class="first last">Convertible to <tt class="docutils literal"><span class="pre">R</span></tt></p>
<p class="first last">可以转化成 <tt class="docutils literal"><span class="pre">R</span></tt> 的</p>
</td>
<td>
<p class="first last"><tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> are tagged arguments.</p>
<p class="first last"><tt class="docutils literal"><span class="pre">a0</span></tt>…<tt class="docutils literal"><span class="pre">aN</span></tt> 都是带标签的参数(tagged argument)。</p>
</td>
</tr>
</tbody>
</table>
<p>For every <tt class="docutils literal"><span class="pre">N</span></tt> in <tt class="docutils literal"><span class="pre">[U,V]</span></tt>, where <tt class="docutils literal"><span class="pre">[U,V]</span></tt> is the <strong>arity range</strong> of <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt>.</p>

<p>对于 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 中的每一个 <tt class="docutils literal"><span class="pre">N</span></tt>，
其中 <tt class="docutils literal"><span class="pre">[U,V]</span></tt> 是 <tt class="docutils literal"><span class="pre">ParameterSpecs</span></tt> 的 <strong>元数区间(arity range)</strong>。</p>
</li>
</ul>
</div>
<div class="section">
<h2><a id="id7" name="id7">Example 例子</a></h2>
<p>This example exports a function <tt class="docutils literal"><span class="pre">f(int</span> <span class="pre">x,</span> <span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">…)</span></tt> to Python. The
sequence of <span class="concept">ParameterSpec</span>'s <tt class="docutils literal"><span class="pre">mpl::vector2&lt;tag::x(int),</span> <span class="pre">tag::y*(int)&gt;</span></tt> has
an <strong>arity range</strong> of [2,2], so we only need one forwarding overload.</p>

<p>
这个例子导出了一个成员函数 <tt class="docutils literal"><span class="pre">f(int</span> <span class="pre">x,</span> <span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">…)</span></tt> 到 Python。
<span class="concept">ParameterSpec</span> 的 <tt class="docutils literal"><span class="pre">mpl::vector2&lt;tag::x(int),</span> <span class="pre">tag::y*(int)&gt;</span></tt> 序列的 <strong>元数区间(arity range)</strong> 是 <span class="pre">[2,2]</span>，因此我们只需要一个 转交重载函数(forwarding overload)。
</p>

<pre class="literal-block">
BOOST_PARAMETER_FUNCTION((void), f, tag,
    (required (x, *))
    (optional (y, *, 1))
)
{
    <em>…</em>
}

struct f_fwd
{
    template &lt;class A0, class A1&gt;
    void operator()(boost::type&lt;void&gt;, A0 const&amp; a0, A1 const&amp; a1)
    {
        f(a0, a1);
    }
};

BOOST_PYTHON_MODULE(…)
{
    def&lt;
        f_fwd
      , mpl::vector&lt;
            void, tag::x(int), tag::y*(int)
        &gt;
    &gt;(&quot;f&quot;);
}
</pre>
<!-- @ignore() -->
<!-- again, the undefined ``fwd`` identifier. -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id16" id="portability" name="portability">Portability 可移植性</a></h1>
<p>The Boost.Parameter Python binding library requires <em>partial template
specialization</em>.</p>

<p>Boost.Parameter Python 绑定库需要用到 <em>偏特化(partial template specialization)</em> 特性。</p>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2007-01-03 17:02 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

本文档是由来自于 <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> 的 <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> 从源代码生成的。
</div>
</body>
</html>

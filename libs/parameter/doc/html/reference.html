<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />

<title>Boost Parameter 库参考文档</title><meta name="translator" content="xuwaters@qq.com" />
<meta name="authors" content="David Abrahams  Daniel Wallin" />
<meta name="organization" content="Boost Consulting" />
<meta name="date" content="2005-07-17" />
<meta name="copyright" content="Copyright David Abrahams, Daniel Wallin 2005. Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)" />
<link rel="stylesheet" href="rst.css" type="text/css" /></head>


<body>
<div class="document" id="the-boost-parameter-library-reference-documentation">
<h1 class="title">Boost Parameter 库参考文档</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">作者:</th>
<td>David Abrahams
<br />Daniel Wallin</td></tr>
<tr><th class="docinfo-name">联系方式:</th>
<td><a class="first reference" href="mailto:dave@boost-consulting.com">dave@boost-consulting.com</a>, <a class="last reference" href="mailto:dalwan01@student.umu.se">dalwan01@student.umu.se</a></td></tr>
<tr><th class="docinfo-name">组织:</th>
<td><a class="first last reference" href="http://www.boost-consulting.com">Boost Consulting</a></td></tr>
<tr><th class="docinfo-name">日期:</th>
<td>2005-07-17</td></tr>
<tr><th class="docinfo-name">版权:</th>
<td>Copyright David Abrahams, Daniel Wallin
2005. Distributed under the Boost Software License,
Version 1.0. (See accompanying file LICENSE_1_0.txt
or copy at <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</td></tr>
</tbody>
</table>
<p><a class="reference" href="../../../../index.htm"><img alt="Boost" src="../../../../boost.png" /></a></p>
<hr class="docutils" />
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">目录</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#preliminaries" id="id30" name="id30">1&nbsp;&nbsp;&nbsp;Preliminaries 预备知识</a><ul class="auto-toc">
<li><a class="reference" href="#namespaces" id="id31" name="id31">1.1&nbsp;&nbsp;&nbsp;Namespaces 名字空间</a></li>
<li><a class="reference" href="#exceptions" id="id32" name="id32">1.2&nbsp;&nbsp;&nbsp;Exceptions 异常</a></li>
<li><a class="reference" href="#thread-safety" id="id33" name="id33">1.3&nbsp;&nbsp;&nbsp;Thread Safety 线程安全</a></li>
<li><a class="reference" href="#typography" id="id34" name="id34">1.4&nbsp;&nbsp;&nbsp;Typography 印刷风格</a></li>
</ul>
</li>
<li><a class="reference" href="#terminology" id="id35" name="id35">2&nbsp;&nbsp;&nbsp;Terminology 术语</a></li>
<li><a class="reference" href="#concepts" id="id36" name="id36">3&nbsp;&nbsp;&nbsp;Concepts 概念</a><ul class="auto-toc">
<li><a class="reference" href="#argumentpack" id="id37" name="id37">3.1&nbsp;&nbsp;&nbsp;<span class="concept">ArgumentPack 参数包(ArgumentPack)</span></a></li>
<li><a class="reference" href="#id5" id="id38" name="id38">3.2&nbsp;&nbsp;&nbsp;<span class="concept">ParameterSpec</span></a></li>
</ul>
</li>
<li><a class="reference" href="#class-templates" id="id39" name="id39">4&nbsp;&nbsp;&nbsp;Class Templates 类模板</a><ul class="auto-toc">
<li><a class="reference" href="#id7" id="id40" name="id40">4.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">keyword</span></tt></a></li>
<li><a class="reference" href="#parameters" id="id41" name="id41">4.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">parameters</span></tt></a></li>
<li><a class="reference" href="#optional-required" id="id42" name="id42">4.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">optional</span></tt>, <tt class="docutils literal"><span class="pre">required</span></tt></a></li>
<li><a class="reference" href="#deduced" id="id43" name="id43">4.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">deduced</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#metafunctions" id="id44" name="id44">5&nbsp;&nbsp;&nbsp;Metafunctions 元函数</a><ul class="auto-toc">
<li><a class="reference" href="#binding" id="id45" name="id45">5.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">binding</span></tt></a></li>
<li><a class="reference" href="#lazy-binding" id="id46" name="id46">5.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">lazy_binding</span></tt></a></li>
<li><a class="reference" href="#value-type" id="id47" name="id47">5.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">value_type</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#code-generation-macros" id="id48" name="id48">6&nbsp;&nbsp;&nbsp;Code Generation Macros 代码生成宏</a><ul class="auto-toc">
<li><a class="reference" href="#boost-parameter-function-result-name-tag-namespace-arguments" id="id49" name="id49">6.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)</span></tt></a></li>
<li><a class="reference" href="#boost-parameter-member-function-result-name-tag-namespace-arguments" id="id50" name="id50">6.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MEMBER_FUNCTION(result,name,tag_namespace,arguments)</span></tt></a></li>
<li><a class="reference" href="#boost-parameter-constructor-cls-impl-tag-namespace-arguments" id="id51" name="id51">6.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_CONSTRUCTOR(cls,</span> <span class="pre">impl,</span> <span class="pre">tag_namespace,</span> <span class="pre">arguments)</span></tt></a></li>
<li><a class="reference" href="#boost-parameter-name-name" id="id52" name="id52">6.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_NAME(name)</span></tt></a></li>
<li><a class="reference" href="#boost-parameter-template-keyword-name" id="id53" name="id53">6.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_TEMPLATE_KEYWORD(name)</span></tt></a></li>
<li><a class="reference" href="#boost-parameter-fun-r-n-l-h-p" id="id54" name="id54">6.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUN(r,n,l,h,p)</span></tt></a></li>
<li><a class="reference" href="#boost-parameter-keyword-n-k" id="id55" name="id55">6.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_KEYWORD(n,k)</span></tt></a></li>
<li><a class="reference" href="#boost-parameter-match-p-a-x" id="id56" name="id56">6.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MATCH(p,a,x)</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#configuration-macros" id="id57" name="id57">7&nbsp;&nbsp;&nbsp;Configuration Macros 配置宏</a><ul class="auto-toc">
<li><a class="reference" href="#boost-parameter-max-arity" id="id58" name="id58">7.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MAX_ARITY</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#tutorial" id="id59" name="id59">8&nbsp;&nbsp;&nbsp;Tutorial 教程</a></li>
</ul>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id30" id="preliminaries" name="preliminaries">1&nbsp;&nbsp;&nbsp;Preliminaries 预备知识</a></h1>
<p>This section covers some basic information you'll need to know in
order to understand this reference</p>
<p>这一节涵盖了你需要知道的一些基本信息，这样你才能理解这份参考文档。
</p>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="namespaces" name="namespaces">1.1&nbsp;&nbsp;&nbsp;Namespaces 名字空间</a></h2>
<p>In this document, all unqualified identifiers should be assumed to
be defined in namespace <tt class="docutils literal"><span class="pre">boost::parameter</span></tt> unless otherwise
specified.</p>
<p>在这个文档中，除非我们特别指出，所有非完全路径引用的(unqualified)标识符都假定是在 <tt class="docutils literal"><span class="pre">boost::parameter</span></tt> 名字空间中定义的。</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id32" id="exceptions" name="exceptions">1.2&nbsp;&nbsp;&nbsp;Exceptions 异常</a></h2>
<p>No operation described in this document
throws an exception unless otherwise specified.</p>
<p>除非我们特别指出，这个文档中描述的所有操作都不抛出异常。</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="thread-safety" name="thread-safety">1.3&nbsp;&nbsp;&nbsp;Thread Safety 线程安全</a></h2>
<p>All components of this library can be used safely from multiple
threads without synchronization.<a class="footnote-reference" href="#thread" id="id2" name="id2"><sup>1</sup></a></p>
<p>这个库的所有组件都可以安全的用在多线程环境中，而不需要同步(synchronization)。<a class="footnote-reference" href="#thread" id="A1" name="id2"><sup>1</sup></a></p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="typography" name="typography">1.4&nbsp;&nbsp;&nbsp;Typography 印刷风格</a></h2>
<p>Names written in <span class="concept">sans serif type</span> represent <a class="reference" href="http://www.boost.org/more/generic_programming.html#concept">concepts</a>.</p>
<p>用 <span class="concept">sans serif type</span> 字体印刷的名字表示 <a class="reference" href="http://www.boost.org/more/generic_programming.html#concept">概念</a>.</p>
<p>In code blocks, <em>italic type</em> represents unspecified text that
satisfies the requirements given in the detailed description that
follows the code block.</p>
<p>在代码段中，<em>斜体(italic type)</em> 的字体表示不详细给出的代码，他们满足在代码段文本中详细描述的要求。</p>
<p>In a specification of the tokens generated by a macro, <strong>bold
type</strong> is used to highlight the position of the expanded macro
argument in the result.</p>
<p>在关于宏(macro)生成的符号(token)的文档规范中，<strong>粗体(bold type)</strong> 字体用来突出显示宏参数在展开后的结果中的位置。</p>
<p>The special character β represents the value of <a class="reference" href="#boost-parameter-max-arity"><tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MAX_ARITY</span></tt></a>.</p>
<p>特殊字符 β 表示 <a class="reference" href="#boost-parameter-max-arity"><tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MAX_ARITY</span></tt></a> 宏的值。</p>
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id35" id="terminology" name="terminology">2&nbsp;&nbsp;&nbsp;Terminology 术语</a></h1>
<dl class="docutils" id="kw">
<dt>keyword 关键字</dt>
<dd>The name of a function parameter.</dd>
<dd>函数参变量的名字.</dd>
</dl>
<span class="target" id="keyword-tag-type"></span><dl class="docutils">
<dt>keyword tag type 关键字标记类型</dt>
<dd>A type used to uniquely identify a function parameter.  Typically
its name will be the same as that of the parameter.</dd>
<dd>用来唯一标识一个函数参变量的类型。通常它的名字和参变量的名字一样。</dd>
</dl>
<span class="target" id="positional"></span><dl class="docutils">
<dt>positional argument 位置相关的参数</dt>
<dd>An argument passed with no explicit keyword.  Its parameter is
determined in the usual C++ way: by position with respect to a
parameter list.</dd>
<dd>不使用显式关键字传递的参数。它的参变量是以 C++ 的方式来确定的：根据在参变量列表中的位置（来确定参数属于哪一参变量）</dd>
</dl>
<span class="target" id="tag-type"></span><dl class="docutils">
<dt>tag type 标签类型</dt>
<dd>Shorthand for “<a class="reference" href="#keyword-tag-type">keyword tag type</a>.”</dd>
<dd>“<a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a>” 的缩写</dd>
</dl>
<span class="target" id="keyword-object"></span><dl class="docutils">
<dt>keyword object 关键字对象</dt>
<dd>An instance of <a class="reference" href="#keyword"><tt class="docutils literal"><span class="pre">keyword</span></tt></a> <tt class="docutils literal"><span class="pre">&lt;T&gt;</span></tt> for some <a class="reference" href="#tag-type">tag type</a> <tt class="docutils literal"><span class="pre">T</span></tt>.</dd>
<dd>某个关键字类型 <tt class="docutils literal"><span class="pre">T</span></tt> 的 <a class="reference" href="#keyword"><tt class="docutils literal"><span class="pre">keyword</span></tt></a> <tt class="docutils literal"><span class="pre">&lt;T&gt;</span></tt> 实例。</dd>
</dl>
<span class="target" id="tagged-reference"></span><dl class="docutils">
<dt>tagged reference 带标签的引用</dt>
<dd>
<p class="first">An object whose type is associated with a <a class="reference" href="#keyword-tag-type">keyword tag type</a> (the
object's <em>keyword</em>), and that holds a reference (to the object's
<em>value</em>).</p>
<p>
一个保存了指向目标对象值引用的对象，其类型是跟 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a> 相关联的。
</p>
<p class="last">As a shorthand, a “tagged reference to <tt class="docutils literal"><span class="pre">x</span></tt>” means a tagged
reference whose <em>value</em> is <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p class="last">作为简写形式, 一个 “对 <tt class="docutils literal"><span class="pre">x</span></tt> 的带标签的引用” 表示其 <em>值</em> 为 <tt class="docutils literal"><span class="pre">x</span></tt> 的一个带标签的引用。</p>
</dd>
</dl>
<span class="target" id="tagged-default"></span><dl class="docutils">
<dt>tagged default 带标签的默认值</dt>
<dd>A <a class="reference" href="#tagged-reference">tagged reference</a> whose <em>value</em> represents the value of a
default argument.</dd>
<dd>一个 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a>，其 <em>值</em> 表示一个参数的默认值。</dd>
</dl>
<span class="target" id="tagged-lazy-default"></span><dl class="docutils">
<dt>tagged lazy default 延迟计算的带标签的默认值</dt>
<dd>A <a class="reference" href="#tagged-reference">tagged reference</a> whose <em>value</em>, when invoked with no
arguments, computes a default argument value.</dd>
<dd>一个 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a>，如果在调用的时候没有传入参数，其 <em>值</em> 被计算出来作为这个参数的默认值。</dd>
</dl>
<span class="target" id="intended-argument-type"></span><dl class="docutils">
<dt>intended argument type 预计的参数类型</dt>
<dd>The <em>intended argument type</em> of a single-element <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> is the
type of its element's <em>value</em>.  The intended argument type of any other
type <tt class="docutils literal"><span class="pre">X</span></tt> is <tt class="docutils literal"><span class="pre">X</span></tt> itself.</dd>
<dd>含有单一元素的<a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a> 的 <em>预计的参数类型(intended argument type)</em> 就是这个单一元素的 <em>值</em> 的类型。
其他任何一个类型 <tt class="docutils literal"><span class="pre">X</span></tt> 的 预计的参数类型(intended argument type) 就是 <tt class="docutils literal"><span class="pre">X</span></tt> 本身。</dd>
</dl>
<div class="note">
<p class="first admonition-title">Note 注意</p>
<p class="last">In this reference, we will use concept names (and other names)
to describe both types and objects, depending on context.  So
for example, “an <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a>” can refer to a type that
models <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> <em>or</em> an object of such a type.</p>

<p class="last">在这一份参考文档中，我们将使用概念的名字（和其他的名字）来描述类型和对象，其含义取决于不同的上下文。
所以，比如说，“一个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a>” 就可以指代一
个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a> 模式的类型，<em>或者</em> 一个这种类型的对象。</p>

</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id36" id="concepts" name="concepts">3&nbsp;&nbsp;&nbsp;Concepts 概念</a></h1>
<p>This section describes the generic type <a class="reference" href="http://www.boost.org/more/generic_programming.html#concept">concepts</a> used by the Parameter library.</p>
<p>这一节描述了 Parameter 库使用到的一般性的类型的 <a class="reference" href="http://www.boost.org/more/generic_programming.html#concept">概念(concept)</a> </p>
<div class="section">
<h2><a class="toc-backref" href="#id37" id="argumentpack" name="argumentpack">3.1&nbsp;&nbsp;&nbsp;<span class="concept">ArgumentPack 参数包(ArgumentPack)</span></a></h2>
<p>An <span class="concept">ArgumentPack</span> is a collection of <a class="reference" href="#tagged-reference">tagged reference</a>s to the
actual arguments passed to a function.  Every <span class="concept">ArgumentPack</span> is
also a valid MPL <a class="reference" href="../../../mpl/doc/refmanual/forward-sequence.html"><span class="concept">Forward Sequence</span></a> consisting of the <a class="reference" href="#keyword-tag-type">keyword tag type</a>s in its <a class="reference" href="#tagged-reference">tagged reference</a>s.</p>
<p><span class="concept">参数包(ArgumentPack)</span> 是一组 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a>，它们指向传递给函数的真实参数。
每一个 <span class="concept">参数包(ArgumentPack)</span> 都是一个正确的 MPL <a class="reference" href="../../../mpl/doc/refmanual/forward-sequence.html"><span class="concept">Forward Sequence</span></a>，它由 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a> 中的 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a> 组成。</p>
<div class="section">
<h3><a id="requirements" name="requirements">Requirements 约束条件</a></h3>
<p>In the table below,</p>
<p>在下表中，</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">A</span></tt> is a model of <span class="concept">ArgumentPack</span></li>
<li><tt class="docutils literal"><span class="pre">A</span></tt> 是 <span class="concept">参数包(ArgumentPack)</span> 一个模式(model)</li>

<li><tt class="docutils literal"><span class="pre">x</span></tt> is an instance of <tt class="docutils literal"><span class="pre">A</span></tt></li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> 是 <tt class="docutils literal"><span class="pre">A</span> 的一个实例</tt></li>

<li><tt class="docutils literal"><span class="pre">u</span></tt> is a <a class="reference" href="#keyword-object">keyword object</a> of type <tt class="docutils literal"><span class="pre">K</span></tt></li>
<li><tt class="docutils literal"><span class="pre">u</span></tt> 是类型 <tt class="docutils literal"><span class="pre">K</span></tt> 的一个 <a class="reference" href="#keyword-object">关键字对象(keyword object)</a></li>

<li><tt class="docutils literal"><span class="pre">v</span></tt> is a <a class="reference" href="#tagged-default">tagged default</a> with <a class="reference" href="#tag-type">tag type</a> <tt class="docutils literal"><span class="pre">L</span></tt> and <em>value</em> of type <tt class="docutils literal"><span class="pre">D</span></tt></li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> 是一个 <a class="reference" href="#tagged-default">带标签的默认值(tagged default)</a>，其中 <a class="reference" href="#tag-type">标签类型(tag type)</a> 是 <tt class="docutils literal"><span class="pre">L</span></tt> 并且 <em>值(value)</em> 的类型是 <tt class="docutils literal"><span class="pre">D</span></tt></li>

<li><tt class="docutils literal"><span class="pre">w</span></tt> is a <a class="reference" href="#tagged-lazy-default">tagged lazy default</a> with <a class="reference" href="#tag-type">tag type</a> <tt class="docutils literal"><span class="pre">M</span></tt> and <em>value</em> of type <tt class="docutils literal"><span class="pre">E</span> <span class="pre">const</span></tt></li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> 是一个 <a class="reference" href="#tagged-lazy-default">延迟计算的带标签的默认值(tagged lazy default)</a>，其中 <a class="reference" href="#tag-type">标签类型(tag type)</a> 是 <tt class="docutils literal"><span class="pre">M</span></tt> 并且 <em>值</em> 的类型是 <tt class="docutils literal"><span class="pre">E</span> <span class="pre">const</span></tt></li>

<li><tt class="docutils literal"><span class="pre">z</span></tt> is an <span class="concept">ArgumentPack</span> containing a single element (as created by <a class="reference" href="#keyword"><tt class="docutils literal"><span class="pre">keyword</span></tt></a><tt class="docutils literal"><span class="pre">&lt;…&gt;::operator=</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">z</span></tt> 是只包含单一元素（由 <a class="reference" href="#keyword"><tt class="docutils literal"><span class="pre">keyword</span></tt></a><tt class="docutils literal"><span class="pre">&lt;…&gt;::operator=</span></tt> 操作符创建的）的一个 <span class="concept">参数包(ArgumentPack)</span></li>

</ul>
<p>Any exceptions are thrown from the invocation of <tt class="docutils literal"><span class="pre">w</span></tt>'s <em>value</em>
will be propagated to the caller.</p>
<p>在计算 <tt class="docutils literal"><span class="pre">w</span></tt> 的 <em>值</em> 的过程中抛出的任何异常都会被继续抛出给调用者。
</p>

<table class="docutils" border="1">
<caption><span class="concept">ArgumentPack</span> requirements 
<span class="concept">参数包(ArgumentPack)</span> 的约束条件</caption>
<colgroup><col width="10%" /><col width="20%" /><col width="30%" /><col width="40%" /></colgroup>
<thead valign="bottom">
<tr><th class="head">Expression 表达式</th>
<th class="head">Type 类型</th>
<th class="head">Requirements 约束条件</th>
<th class="head">Semantics/Notes 语义/备注</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p><tt class="docutils literal"><span class="pre">x[u]</span></tt></p></td>
<td><p><tt class="docutils literal"><span class="pre">binding&lt;A,K&gt;::type</span></tt></p></td>
<td><p><tt class="docutils literal"><span class="pre">x</span></tt> contains an
element <em>b</em> whose
<a class="reference" href="#kw">keyword</a> is <tt class="docutils literal"><span class="pre">K</span></tt>
</p>
<p>
<tt class="docutils literal"><span class="pre">x</span></tt> 包含一个元素 <em>b</em>，它的 <a class="reference" href="#kw">关键字(keyword)</a> 是 <tt class="docutils literal"><span class="pre">K</span></tt>
</p>
</td>
<td>
<p>Returns <em>b</em>'s <em>value</em> (by reference).</p>
<p>通过引用的方式返回 <em>b</em> 的值</p>
</td>
</tr>
<tr><td><p><tt class="docutils literal"><span class="pre">x[u]</span></tt></p></td>
<td><p><tt class="docutils literal"><span class="pre">binding&lt;A,L,D&gt;::type</span></tt></p></td>
<td><p><em>none</em></p></td>
<td>
<p>
If <tt class="docutils literal"><span class="pre">x</span></tt> contains an element <em>b</em> whose
<a class="reference" href="#kw">keyword</a> is the same as <tt class="docutils literal"><span class="pre">u</span></tt>'s,
returns <em>b</em>'s <em>value</em> (by
reference).  Otherwise, returns <tt class="docutils literal"><span class="pre">u</span></tt>'s <em>value</em>.
</p>
<p>
如果 <tt class="docutils literal"><span class="pre">x</span></tt> 包含一个元素 <em>b</em>，其
<a class="reference" href="#kw">关键字(keyword)</a> 跟 <tt class="docutils literal"><span class="pre">u</span></tt> 的一样，
就通过引用返回 <em>b</em> 的 <em>值</em>。反之，返回 <tt class="docutils literal"><span class="pre">u</span></tt> 的 <em>值</em>.
</p>
</td>
</tr>
<tr><td><p><tt class="docutils literal"><span class="pre">x[w]</span></tt></p></td>
<td><p><tt class="docutils literal"><span class="pre">lazy_binding&lt;A,M,E&gt;::type</span></tt></p></td>
<td><p><em>none</em></p></td>
<td>
<p>If <tt class="docutils literal"><span class="pre">x</span></tt> contains an element <em>b</em> whose
<a class="reference" href="#kw">keyword</a> is the same as <tt class="docutils literal"><span class="pre">w</span></tt>'s,
returns <em>b</em>'s <em>value</em> (by
reference).  Otherwise, invokes <tt class="docutils literal"><span class="pre">w</span></tt>'s <em>value</em> and returns the result.
</p>
<p>如果 <tt class="docutils literal"><span class="pre">x</span></tt> 包含一个元素 <em>b</em>，其
<a class="reference" href="#kw">关键字(keyword)</a> 跟 <tt class="docutils literal"><span class="pre">w</span></tt> 的一样，
就通过引用返回 <em>b</em> 的 <em>值</em>。反之，计算 <tt class="docutils literal"><span class="pre">w</span></tt> 的 <em>值</em> 并返回结果。
</p>

</td>
</tr>
<tr><td><p><tt class="docutils literal"><span class="pre">x,</span> <span class="pre">z</span></tt></p></td>
<td>
<p>Model of <span class="concept">ArgumentPack</span></p>
<p><span class="concept">参数包(ArgumentPack)</span> 的模式</p>
</td>
<td><p><em>none</em></p></td>
<td>
<p>Returns an <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> containing
all the elements of both <tt class="docutils literal"><span class="pre">x</span></tt> and
<tt class="docutils literal"><span class="pre">z</span></tt>.
</p>
<p>返回一个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a>，其所有元素就包括 <tt class="docutils literal"><span class="pre">x</span></tt> 和 <tt class="docutils literal"><span class="pre">z</span></tt>。
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id38" id="id5" name="id5"><span id="parameterspec"></span>3.2&nbsp;&nbsp;&nbsp;<span class="concept">ParameterSpec</span> 参变量描述子(ParameterSpec)</a></h2>
<p>A <span class="concept">ParameterSpec</span> describes the type requirements for arguments
corresponding to a given <a class="reference" href="#kw">keyword</a> and indicates whether the argument
is optional or required.  The table below details the allowed forms
and describes their condition for satisfaction by an actual
argument type. In each row,</p>
<p>一个 <span class="concept">参变量描述子(ParameterSpec)</span> 描述了对于给定 <a class="reference" href="#kw">关键字(keyword)</a> 所需参数的类型并且
指明这个参数是 可选的(optional) 还是 必选的(required)。下表详细列出了允许的形式并描述了当一个实际参数传递过来时它们必须满足的条件。在每一行中，</p>
<ul class="simple" id="conditions">

<li><tt class="docutils literal"><span class="pre">K</span></tt> is the <span class="concept">ParameterSpec</span>'s <a class="reference" href="#keyword-tag-type">keyword tag type</a></li>
<li><tt class="docutils literal"><span class="pre">K</span></tt> 是 <span class="concept">参变量描述子(ParameterSpec)</span> 的 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a></li>

<li><tt class="docutils literal"><span class="pre">A</span></tt> is an <a class="reference" href="#intended-argument-type">intended argument type</a> associated with <tt class="docutils literal"><span class="pre">K</span></tt>, if any</li>
<li><tt class="docutils literal"><span class="pre">A</span></tt> 是一个跟 <tt class="docutils literal"><span class="pre">K</span></tt> 相关联的 <a class="reference" href="#intended-argument-type">预计的参数类型(intended argument type)</a>，如果存在的话</li>

<li><tt class="docutils literal"><span class="pre">F</span></tt> is a unary <a class="reference" href="../../../mpl/doc/refmanual/lambda-expression.html">MPL lambda expression</a></li>
<li><tt class="docutils literal"><span class="pre">F</span></tt> 是一个一元的 <a class="reference" href="../../../mpl/doc/refmanual/lambda-expression.html">MPL lambda 表达式</a></li>

</ul>
<table class="docutils" border="1">
<caption>
<span class="concept">ParameterSpec</span> allowed forms and conditions of satisfaction
<span class="concept">参变量描述子(ParameterSpec)</span> 允许的形式以及满足的条件 
</caption>
<colgroup><col width="32%" /><col width="21%" /><col width="47%" /></colgroup>
<thead valign="bottom">
<tr><th class="head">Type 类型</th>
<th class="head"><tt class="docutils literal"><span class="pre">A</span></tt> required 
<tt class="docutils literal"><span class="pre">A</span></tt> 是否为必须的
</th>
<th class="head">
Condition <tt class="docutils literal"><span class="pre">A</span></tt> must satisfy
<tt class="docutils literal"><span class="pre">A</span></tt> 必须满足的条件
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">K</span></tt></td>
<td>no 否</td>
<td><em>n/a</em> <em>无</em></td>
</tr>
<tr><td><a class="reference" href="#optional"><tt class="docutils literal"><span class="pre">optional</span></tt></a><tt class="docutils literal"><span class="pre">&lt;K,F&gt;</span></tt></td>
<td>no 否</td>
<td><tt class="docutils literal"><span class="pre">mpl::apply&lt;F,A&gt;::type::value</span></tt>
为 <tt class="docutils literal"><span class="pre">true</span></tt>.</td>
</tr>
<tr><td><a class="reference" href="#required"><tt class="docutils literal"><span class="pre">required</span></tt></a><tt class="docutils literal"><span class="pre">&lt;K,F&gt;</span></tt></td>
<td>yes 是</td>
<td><tt class="docutils literal"><span class="pre">mpl::apply&lt;F,A&gt;::type::value</span></tt>
为 <tt class="docutils literal"><span class="pre">true</span></tt>.</td>
</tr>
</tbody>
</table>
<p>The information in a <span class="concept">ParameterSpec</span> is used to <a class="reference" href="index.html#controlling-overload-resolution">limit</a> the
arguments that will be matched by <a class="reference" href="index.html#forwarding-functions">forwarding functions</a>.</p>
<p> <span class="concept">参变量描述子(ParameterSpec)</span> 中的信息是用来 <a class="reference" href="index.html#controlling-overload-resolution">限制</a> 被 <a class="reference" href="index.html#forwarding-functions">转接函数(forwarding functions)</a> 匹配到的参数的。</p>

</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id39" id="class-templates" name="class-templates">4&nbsp;&nbsp;&nbsp;Class Templates 类模板</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id40" id="id7" name="id7"><span id="keyword"></span>4.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">keyword</span></tt></a></h2>
<p>The type of every <a class="reference" href="#keyword-object">keyword object</a> is a specialization of <tt class="docutils literal"><span class="pre">keyword</span></tt>.</p>
<p>每一个 <a class="reference" href="#keyword-object">关键字对象(keyword object)</a> 的类型都是 <tt class="docutils literal"><span class="pre">keyword</span></tt> 类模板的一个特化。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/keyword.hpp">boost/parameter/keyword.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">template &lt;class Tag&gt;<br />struct keyword<br />{<br />    template &lt;class T&gt; <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> <a class="reference" href="#operator">operator=</a>(T&amp; value) const;<br />    template &lt;class T&gt; <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> <a class="reference" href="#operator">operator=</a>(T const&amp; value) const;<br /><br />    template &lt;class T&gt; <em>tagged default</em> <a class="reference" href="#id9">operator|</a>(T&amp; x) const;<br />    template &lt;class T&gt; <em>tagged default</em> <a class="reference" href="#id9">operator|</a>(T const&amp; x) const;<br /><br />    template &lt;class F&gt; <em>tagged lazy default</em> <a class="reference" href="#id10">operator||</a>(F const&amp;) const;<br /><br />    static keyword&lt;Tag&gt;&amp; <a class="reference" href="#get">get</a>();<br />};<br /></pre>
<dl class="docutils" id="operator">
<dt><tt class="docutils literal"><span class="pre">operator=</span></tt></dt>
<dd><pre class="first literal-block">template &lt;class T&gt; <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> operator=(T&amp; value) const;<br />template &lt;class T&gt; <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> operator=(T const&amp; value) const;<br /></pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body">无</td>
</tr>
<tr class="field"><th class="field-name">返回：</th>
<!--
<td class="field-body">an <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a>  containing a single <a class="reference" href="#tagged-reference">tagged reference</a> to
<tt class="docutils literal"><span class="pre">value</span></tt> with <a class="reference" href="#kw">keyword</a> <tt class="docutils literal"><span class="pre">Tag</span></tt></td> -->
<td class="field-body">一个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a>，它只包含一个 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a>，其引用指向一个 <a class="reference" href="#kw">关键字(keyword)</a> 为 <tt class="docutils literal"><span class="pre">Tag</span></tt> 的 <tt class="docutils literal"><span class="pre">值</span></tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="docutils" id="id9">
<dt><tt class="docutils literal"><span class="pre">operator|</span></tt></dt>
<dd><pre class="first literal-block">template &lt;class T&gt; <em>tagged default</em> operator|(T&amp; x) const;<br />template &lt;class T&gt; <em>tagged default</em> operator|(T const&amp; x) const;<br /></pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">返回：</th>
<!-- <td class="field-body">a <a class="reference" href="#tagged-default">tagged default</a> with <em>value</em> <tt class="docutils literal"><span class="pre">x</span></tt> and <a class="reference" href="#kw">keyword</a> <tt class="docutils literal"><span class="pre">Tag</span></tt>.</td> -->
<td class="field-body">一个 <a class="reference" href="#tagged-default">带标签的默认值(tagged default)</a>，其 <em>值</em> 为 <tt class="docutils literal"><span class="pre">x</span></tt> 并且 <a class="reference" href="#kw">关键字(keyword)</a> 为 <tt class="docutils literal"><span class="pre">Tag</span></tt>。</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="docutils" id="id10">
<dt><tt class="docutils literal"><span class="pre">operator||</span></tt></dt>
<dd><pre class="first literal-block">template &lt;class F&gt; <em>tagged lazy default</em> operator||(F const&amp; g) const;<br /></pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">约束条件：</th>
<td class="field-body"><tt class="docutils literal"><span class="pre">g()</span></tt> is valid, with type <tt class="docutils literal"><span class="pre">boost::</span></tt><a class="reference" href="../../../utility/utility.htm#result_of"><tt class="docutils literal"><span class="pre">result_of</span></tt></a><tt class="docutils literal"><span class="pre">&lt;F()&gt;::type</span></tt>.<a class="footnote-reference" href="#no-result-of" id="id11" name="id11"><sup>2</sup></a></td>
<td class="field-body">表达式 <tt class="docutils literal"><span class="pre">g()</span></tt> 是正确的，并且其类型是 <tt class="docutils literal"><span class="pre">boost::</span></tt><a class="reference" href="../../../utility/utility.htm#result_of"><tt class="docutils literal"><span class="pre">result_of</span></tt></a><tt class="docutils literal"><span class="pre">&lt;F()&gt;::type</span></tt>.<a class="footnote-reference" href="#no-result-of" id="A2" name="id11"><sup>2</sup></a></td>
</tr>
<tr class="field"><th class="field-name">返回：</th>
<td class="field-body">a <a class="reference" href="#tagged-lazy-default">tagged lazy default</a> with <em>value</em> <tt class="docutils literal"><span class="pre">g</span></tt> and <a class="reference" href="#kw">keyword</a> <tt class="docutils literal"><span class="pre">Tag</span></tt>.</td>
<td class="field-body">一个 <a class="reference" href="#tagged-lazy-default">延迟计算的带标签的默认值(tagged lazy default)</a>，其 <em>值</em> 为 <tt class="docutils literal"><span class="pre">g</span></tt> 并且 <a class="reference" href="#kw">关键字(keyword)</a> 为 <tt class="docutils literal"><span class="pre">Tag</span></tt>。</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="docutils" id="get">
<dt><tt class="docutils literal"><span class="pre">get</span></tt></dt>
<dd><pre class="first literal-block">static keyword&lt;Tag&gt;&amp; get();<br /></pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">返回：</th>
<td class="field-body">a “singleton instance”: the same object will be
returned on each invocation of <tt class="docutils literal"><span class="pre">get()</span></tt>.</td>
<td class="field-body">一个 “单件实例”： 每次调用 <tt class="docutils literal"><span class="pre">get()</span></tt> 都会返回同一个对象。</td>
</tr>
<tr class="field"><th class="field-name">线程安全：</th>
<td class="field-body"><tt class="docutils literal"><span class="pre">get()</span></tt> can be called from multiple threads simultaneously.</td>
<td class="field-body"><tt class="docutils literal"><span class="pre">get()</span></tt> 可以从不同的线程中被同时调用。</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id41" id="parameters" name="parameters">4.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">parameters</span></tt></a></h2>
<p>Provides an interface for assembling the actual arguments to a
<cite>forwarding function</cite> into an <span class="concept">ArgumentPack</span>, in which any
<a class="reference" href="#positional">positional</a> arguments will be tagged according to the
corresponding template argument to <tt class="docutils literal"><span class="pre">parameters</span></tt>.</p>
<p>提供一个将传给 <cite>转接函数(forwarding function)</cite> 的实际参数打包成一个 <span class="concept">参数包(ArgumentPack)</span> 的接口，在这个 <span class="concept">参数包(ArgumentPack)</span> 里面，任何一个 <a class="reference" href="#positional">位置相关的(positional)</a> 参数都会根据它们相应的模板参数被打标签为 <tt class="docutils literal"><span class="pre">parameters</span></tt>。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/parameters.hpp">boost/parameter/parameters.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">template &lt;class P0 = <em>unspecified</em>, class P1 = <em>unspecified</em>, …class Pβ = <em>unspecified</em>&gt;<br />struct parameters<br />{<br />    template &lt;class A0, class A1 = <em>unspecified</em>, …class Aβ = <em>unspecified</em>&gt;<br />    struct <a class="reference" href="#match">match</a>
    {
        typedef … type;
    };

    template &lt;class A0&gt;
    <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> <a class="reference" href="#id13">operator()</a>(A0&amp; a0) const;<br /><br />    template &lt;class A0, class A1&gt;<br />    <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> <a class="reference" href="#id13">operator()</a>(A0&amp; a0, A1&amp; a1) const;<br /><br />    <span class="vellipsis">⋮</span>

    template &lt;class A0, class A1, …class Aβ&gt;
    <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> <a class="reference" href="#id13">operator()</a>(A0&amp; a0, A1&amp; a1, …Aβ&amp; aβ) const;<br />};<br /></pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">约束条件：</th>
<td class="field-body"><tt class="docutils literal"><span class="pre">P0</span></tt>, <tt class="docutils literal"><span class="pre">P1</span></tt>, … <tt class="docutils literal"><span class="pre">P</span></tt>β are models of <a class="reference" href="#parameterspec"><span class="concept">ParameterSpec</span></a>.</td>
<td class="field-body"><tt class="docutils literal"><span class="pre">P0</span></tt>, <tt class="docutils literal"><span class="pre">P1</span></tt>, … <tt class="docutils literal"><span class="pre">P</span></tt>β 都是 <a class="reference" href="#parameterspec"><span class="concept">参变量描述子(ParameterSpec)</span></a> 的模式(model)。</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note 注意</p>
<p>In this section, <tt class="docutils literal"><span class="pre">R</span></tt><em>i</em> and <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> are defined as
follows, for any argument type <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em>:</p>
<p>在这一节中，<tt class="docutils literal"><span class="pre">R</span></tt><em>i</em> 和 <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> 定义如下，对任何一个参数类型 <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em>：</p>
<blockquote class="last">
<div class="line-block">

<div class="line">let <tt class="docutils literal"><span class="pre">D0</span></tt> the set [d0, …, d<em>j</em>] of all <strong>deduced</strong> <em>parameter specs</em> in [<tt class="docutils literal"><span class="pre">P0</span></tt>, …, <tt class="docutils literal"><span class="pre">P</span></tt>β]</div>
<div class="line">将 <tt class="docutils literal"><span class="pre">D0</span></tt> 赋值为集合 [d0, …, d<em>j</em>]，它是 [<tt class="docutils literal"><span class="pre">P0</span></tt>, …, <tt class="docutils literal"><span class="pre">P</span></tt>β] 中所有 <strong>推导的(deduced)</strong> <em>参变量描述子(parameter specs)</em> 的集合</div>

<div class="line"><tt class="docutils literal"><span class="pre">R</span></tt><em>i</em> is <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em>'s <a class="reference" href="#intended-argument-type">intended argument type</a></div>
<div class="line"><tt class="docutils literal"><span class="pre">R</span></tt><em>i</em> 是 <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em> 的 <a class="reference" href="#intended-argument-type">预计的参数类型(intended argument type)</a></div>

<div class="line"><br /></div>
<div class="line">if <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em> is a result type of <tt class="docutils literal"><span class="pre">keyword&lt;T&gt;::</span></tt><a class="reference" href="#operator"><tt class="docutils literal"><span class="pre">operator=</span></tt></a></div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em> 是 <tt class="docutils literal"><span class="pre">keyword&lt;T&gt;::</span></tt><a class="reference" href="#operator"><tt class="docutils literal"><span class="pre">operator=</span></tt></a> 的结果类型</div>

<div class="line">then</div>
<div class="line">那么</div>

<div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> is <tt class="docutils literal"><span class="pre">T</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> 是 <tt class="docutils literal"><span class="pre">T</span></tt></div>
</div>
<div class="line">else</div>
<div class="line">反之</div>
<div class="line-block">
<div class="line">if some <tt class="docutils literal"><span class="pre">A</span></tt><em>j</em> where <em>j</em>≤<em>i</em> is a result type of <tt class="docutils literal"><span class="pre">keyword&lt;T&gt;::</span></tt><a class="reference" href="#operator"><tt class="docutils literal"><span class="pre">operator=</span></tt></a></div>
<div class="line">如果某个 <tt class="docutils literal"><span class="pre">A</span></tt><em>j</em> ( <em>j</em>≤<em>i</em> ) 是 <tt class="docutils literal"><span class="pre">keyword&lt;T&gt;::</span></tt><a class="reference" href="#operator"><tt class="docutils literal"><span class="pre">operator=</span></tt></a> 的结果类型</div>

<div class="line"><em>or</em> some <tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> in <em>j</em>≤<em>i</em> is <strong>deduced</strong></div>
<div class="line"><em>或者</em> 某个 <tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> in <em>j</em>≤<em>i</em> 是 <strong>推导的(deduced)</strong></div>

<div class="line">then</div>
<div class="line">那么</div>

<div class="line-block">
<div class="line">if some <em>parameter spec</em> <tt class="docutils literal"><span class="pre">d</span></tt><em>j</em> in <tt class="docutils literal"><span class="pre">D</span></tt><em>i</em> matches <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em></div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">D</span></tt><em>i</em> 中的某个 <em>参变量描述子(parameter spec)</em> <tt class="docutils literal"><span class="pre">d</span></tt><em>j</em> 匹配到了 <tt class="docutils literal"><span class="pre">A</span></tt><em>i</em></div>

<div class="line">then</div>
<div class="line">那么</div>

<div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> is <tt class="docutils literal"><span class="pre">d</span></tt><em>j</em>'s <a class="reference" href="#keyword-tag-type">keyword tag type</a>.</div>
<div class="line"><tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> 就是 <tt class="docutils literal"><span class="pre">d</span></tt><em>j</em> 的 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a>.</div>

<div class="line"><tt class="docutils literal"><span class="pre">D</span></tt><sub>i+1</sub> is <tt class="docutils literal"><span class="pre">D</span></tt><em>i</em> - [<tt class="docutils literal"><span class="pre">d</span></tt><em>j</em>]</div>
<div class="line"><tt class="docutils literal"><span class="pre">D</span></tt><sub>i+1</sub> 是 <tt class="docutils literal"><span class="pre">D</span></tt><em>i</em> - [<tt class="docutils literal"><span class="pre">d</span></tt><em>j</em>]</div>

</div>
</div>

<div class="line">else</div>
<div class="line">反之</div>

<div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> 是 <tt class="docutils literal"><span class="pre">P</span></tt><em>i</em> 的 <a class="reference" href="#keyword-tag-type">关键字标签规范(keyword tag type)</a>.</div>
</div>
</div>
</div>
</blockquote>
</div>
<dl class="docutils" id="match">
<dt><tt class="docutils literal"><span class="pre">match</span></tt></dt>
<dd><p class="first">A <a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept">Metafunction</span></a> used to remove a <a class="reference" href="index.html#forwarding-functions">forwarding function</a> from overload resolution.</p>
<p class="first">一个用于将 <a class="reference" href="index.html#forwarding-functions">转接函数(forwarding function)</a> 从 重载解析(overload resolution) 中移除的 <a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept">元函数(Metafunction)</span></a>。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">返回：</th>
<td class="field-body">if <tt class="docutils literal"><span class="pre">P0</span></tt>, <tt class="docutils literal"><span class="pre">P1</span></tt>, …<tt class="docutils literal"><span class="pre">P</span></tt>β are <em>satisfied</em> (see
below), then <tt class="docutils literal"><span class="pre">parameters&lt;P0,P1,…Pβ&gt;</span></tt>.  Otherwise,
<tt class="docutils literal"><span class="pre">match&lt;A0,A1,…Aβ&gt;::type</span></tt> is not defined.</td>
<td class="field-body">如果 <tt class="docutils literal"><span class="pre">P0</span></tt>, <tt class="docutils literal"><span class="pre">P1</span></tt>, …<tt class="docutils literal"><span class="pre">P</span></tt>β 是 <em>满足的(satisfied)</em> （见下面），
那么返回 <tt class="docutils literal"><span class="pre">parameters&lt;P0,P1,…Pβ&gt;</span></tt>。 反之，
<tt class="docutils literal"><span class="pre">match&lt;A0,A1,…Aβ&gt;::type</span></tt> 是没有定义的。</td>

</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">P0</span></tt>, <tt class="docutils literal"><span class="pre">P1</span></tt>, …<tt class="docutils literal"><span class="pre">P</span></tt>β are <strong>satisfied</strong> if, for every <em>j</em> in 0…β, either:</p>
<p><tt class="docutils literal"><span class="pre">P0</span></tt>, <tt class="docutils literal"><span class="pre">P1</span></tt>, …<tt class="docutils literal"><span class="pre">P</span></tt>β 是 <strong>满足的(satisfied)</strong> 如果，对于在 0…β 中的每一个 <em>j</em>，满足以下条件之一：</p>

<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> is the <em>unspecified</em> default</li>
<li><tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> 是 <em>未指定的(unspecified)</em> 默认值</li>

<li><strong>or</strong>, <tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> is a <em>keyword tag type</em></li>
<li><strong>或者</strong>，<tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> 是一个 <em>关键字标签类型(keyword tag type)</em></li>

<li><strong>or</strong>, <tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> is <a class="reference" href="#optional"><tt class="docutils literal"><span class="pre">optional</span></tt></a> <tt class="docutils literal"><span class="pre">&lt;X,F&gt;</span></tt> and either<ul>
<li><tt class="docutils literal"><span class="pre">X</span></tt> is not <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> for any <em>i</em>,</li>
<li><strong>or</strong> <tt class="docutils literal"><span class="pre">X</span></tt> is some <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em>  and <tt class="docutils literal"><span class="pre">mpl::apply&lt;F,R</span></tt><em>i</em><tt class="docutils literal"><span class="pre">&gt;::type::value</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt></li>
</ul>
</li>
<li><strong>或者</strong>，<tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> 是 <a class="reference" href="#optional"><tt class="docutils literal"><span class="pre">optional</span></tt></a> <tt class="docutils literal"><span class="pre">&lt;X,F&gt;</span></tt> 并且
<ul>
<li>对于任何 <em>i</em>，<tt class="docutils literal"><span class="pre">X</span></tt> 都不是 <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em></li>
<li><strong>或者</strong> <tt class="docutils literal"><span class="pre">X</span></tt> 是某个 <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em>  并且 <tt class="docutils literal"><span class="pre">mpl::apply&lt;F,R</span></tt><em>i</em><tt class="docutils literal"><span class="pre">&gt;::type::value</span></tt> 为 <tt class="docutils literal"><span class="pre">true</span></tt></li>
</ul>
</li>

<li><strong>or</strong>, <tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> is <a class="reference" href="#required"><tt class="docutils literal"><span class="pre">required</span></tt></a> <tt class="docutils literal"><span class="pre">&lt;X,F&gt;</span></tt>, and<ul>
<li><tt class="docutils literal"><span class="pre">X</span></tt> is some <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em>, <strong>and</strong></li>
<li><tt class="docutils literal"><span class="pre">mpl::apply&lt;F,R</span></tt><em>i</em><tt class="docutils literal"><span class="pre">&gt;::type::value</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt></li>
</ul>
</li>
<li><strong>或者</strong>，<tt class="docutils literal"><span class="pre">P</span></tt><em>j</em> 是 <a class="reference" href="#required"><tt class="docutils literal"><span class="pre">required</span></tt></a> <tt class="docutils literal"><span class="pre">&lt;X,F&gt;</span></tt>，并且 <ul>
<li><tt class="docutils literal"><span class="pre">X</span></tt> 是某个 <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em>, <strong>并且</strong></li>
<li><tt class="docutils literal"><span class="pre">mpl::apply&lt;F,R</span></tt><em>i</em><tt class="docutils literal"><span class="pre">&gt;::type::value</span></tt> 为 <tt class="docutils literal"><span class="pre">true</span></tt></li>
</ul>
</li>

</ul>
</dd>
</dl>
<dl class="docutils" id="id13">
<dt><tt class="docutils literal"><span class="pre">operator()</span></tt></dt>
<dd><pre class="first literal-block">template &lt;class A0&gt; <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> operator()(A0 const&amp; a0) const;<br /><br /><span class="vellipsis">⋮</span>

template &lt;class A0, …class Aβ&gt; <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> <a class="reference" href="#id13">operator()</a>(A0 const&amp; a0, …Aβ const&amp; aβ) const;<br /></pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">返回：</th>
<td class="field-body"><p class="first">An <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a> containing, for each <tt class="docutils literal"><span class="pre">a</span></tt><em>i</em>,</p>
<ul class="last simple">
<li>if <tt class="docutils literal"><span class="pre">a</span></tt><em>i</em>,  is a single-element <span class="concept">ArgumentPack</span>, its element</li>
<li>Otherwise, a <a class="reference" href="#tagged-reference">tagged reference</a> with <a class="reference" href="#kw">keyword</a> <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> and <em>value</em> <tt class="docutils literal"><span class="pre">a</span></tt><em>i</em></li>
</ul>
</td>
<td class="field-body"><p class="first">一个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a>，它包含，对每一个 <tt class="docutils literal"><span class="pre">a</span></tt><em>i</em>，</p>
<ul class="last simple">
<li>如果 <tt class="docutils literal"><span class="pre">a</span></tt><em>i</em> 是一个单元素 <span class="concept">参数包(ArgumentPack)</span>，这个单元素</li>
<li>否则，一个 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a>，其 <a class="reference" href="#kw">关键字(keyword)</a> 为 <tt class="docutils literal"><span class="pre">K</span></tt><em>i</em> 且 <em>值(value)</em> 为 <tt class="docutils literal"><span class="pre">a</span></tt><em>i</em></li>
</ul>
</td>

</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id42" id="optional-required" name="optional-required"><span id="required"></span><span id="optional"></span>4.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">optional</span></tt>, <tt class="docutils literal"><span class="pre">required</span></tt></a></h2>
<p>These templates describe the requirements on a function parameter.</p>
<p>这些模版描述了对一个函数参变量的约束条件。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/parameters.hpp">boost/parameter/parameters.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/parameters.hpp">boost/parameter/parameters.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Specializations model:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><a class="reference" href="#parameterspec"><span class="concept">ParameterSpec</span></a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">特化模式(model):</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><a class="reference" href="#parameterspec"><span class="concept">参变量描述子(ParameterSpec)</span></a></td>
</tr>

</tbody>
</table>
<pre class="literal-block">template &lt;class Tag, class Predicate = <em>unspecified</em>&gt;<br />struct optional;<br /><br />template &lt;class Tag, class Predicate = <em>unspecified</em>&gt;<br />struct required;<br /></pre>
<p>The default value of <tt class="docutils literal"><span class="pre">Predicate</span></tt> is an unspecified <a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept">Metafunction</span></a> that returns
<tt class="docutils literal"><span class="pre">mpl::true_</span></tt> for any argument.</p>
<p><tt class="docutils literal"><span class="pre">Predicate</span></tt> 的默认值是一个 unspecified <a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept">元函数(Metafunction)</span></a>，它对任何参数都返回 <tt class="docutils literal"><span class="pre">mpl::true_</span></tt>。</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id43" id="deduced" name="deduced">4.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">deduced</span></tt></a></h2>
<p>This template is used to wrap the <em>keyword tag</em> argument to
<tt class="docutils literal"><span class="pre">optional</span></tt> or <tt class="docutils literal"><span class="pre">required</span></tt>.</p>
<p>这个模版用来将 <em>关键字标签(keyword tag)</em> 参数封装成 <tt class="docutils literal"><span class="pre">optional</span></tt> 或者 <tt class="docutils literal"><span class="pre">required</span></tt>。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/parameters.hpp">boost/parameter/parameters.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/parameters.hpp">boost/parameter/parameters.hpp</a></td>
</tr>

</tbody>
</table>
<pre class="literal-block">template &lt;class Tag&gt;<br />struct deduced;<br /></pre>
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id44" id="metafunctions" name="metafunctions">5&nbsp;&nbsp;&nbsp;Metafunctions 元函数</a></h1>
<p>A <a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept">Metafunction</span></a> is conceptually a function that operates on, and returns, C++ types.</p>
<p><a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="concept">元函数(Metafunction)</span></a> 在概念上是函数，只是它操作和返回的都是 C++ 类型。</p>

<div class="section">
<h2><a class="toc-backref" href="#id45" id="binding" name="binding">5.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">binding</span></tt></a></h2>
<p>Returns the result type of indexing an argument pack with a
<a class="reference" href="#keyword-tag-type">keyword tag type</a> or with a <a class="reference" href="#tagged-default">tagged default</a>.</p>
<p>返回以 <a class="reference" href="#keyword-tag-type">关键字标记类型(keyword tag type)</a> 或者 <a class="reference" href="#tagged-default">带标记的默认值(tagged default)</a> 为索引，在参数包中查找到的结果类型。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/binding.hpp">boost/parameter/binding.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/binding.hpp">boost/parameter/binding.hpp</a></td>
</tr>

</tbody>
</table>
<pre class="literal-block">template &lt;class A, class K, class D = void&gt;<br />struct binding<br />{<br />    typedef … type;<br />};<br /></pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><tt class="docutils literal"><span class="pre">A</span></tt> is a model of <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a>.</td>
</tr>
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body"><tt class="docutils literal"><span class="pre">A</span></tt> 是一个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a> 模式(model)。</td>
</tr>

<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the reference type of the <a class="reference" href="#tagged-reference">tagged reference</a> in <tt class="docutils literal"><span class="pre">A</span></tt>
having <a class="reference" href="#keyword-tag-type">keyword tag type</a> <tt class="docutils literal"><span class="pre">K</span></tt>, if any.  If no such <a class="reference" href="#tagged-reference">tagged reference</a> exists, returns <tt class="docutils literal"><span class="pre">D</span></tt>.</td>
</tr>
<tr class="field"><th class="field-name">返回：</th><td class="field-body"><tt class="docutils literal"><span class="pre">A</span></tt> 中 其 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a> 为 <tt class="docutils literal"><span class="pre">K</span></tt> 的 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a> 的引用类型。如果不存在这样的 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a>，返回 <tt class="docutils literal"><span class="pre">D</span></tt>。</td>
</tr>

</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id46" id="lazy-binding" name="lazy-binding">5.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">lazy_binding</span></tt></a></h2>
<p>Returns the result type of indexing an argument pack with a <a class="reference" href="#tagged-lazy-default">tagged lazy default</a>.</p>
<p>返回以 <a class="reference" href="#tagged-lazy-default">延迟计算的带标签的默认值(tagged lazy default)</a> 为索引，在参数包中查找到的结果类型。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/binding.hpp">boost/parameter/binding.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/binding.hpp">boost/parameter/binding.hpp</a></td>
</tr>
</tbody>
</table>
<pre class="literal-block">template &lt;class A, class K, class F&gt;<br />struct lazy_binding<br />{<br />    typedef … type;<br />};<br /></pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><tt class="docutils literal"><span class="pre">A</span></tt> is a model of <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a>.</td>
</tr>
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body"><tt class="docutils literal"><span class="pre">A</span></tt> 是一个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a> 模式(model)。</td>
</tr>

<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the reference type of the <a class="reference" href="#tagged-reference">tagged reference</a> in <tt class="docutils literal"><span class="pre">A</span></tt>
having <a class="reference" href="#keyword-tag-type">keyword tag type</a> <tt class="docutils literal"><span class="pre">K</span></tt>, if any.  If no such <a class="reference" href="#tagged-reference">tagged reference</a> exists, returns <tt class="docutils literal"><span class="pre">boost::</span></tt><a class="reference" href="../../../utility/utility.htm#result_of"><tt class="docutils literal"><span class="pre">result_of</span></tt></a><tt class="docutils literal"><span class="pre">&lt;F()&gt;::type</span></tt>.<a class="footnote-reference" href="#no-result-of" id="id18" name="id18"><sup>2</sup></a></td>
</tr>
<tr class="field"><th class="field-name">返回：</th><td class="field-body"><tt class="docutils literal"><span class="pre">A</span></tt> 中 其 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a> 为 <tt class="docutils literal"><span class="pre">K</span></tt> 的 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a> 的引用类型。如果不存在这样的 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a>，返回 <tt class="docutils literal"><span class="pre">boost::</span></tt><a class="reference" href="../../../utility/utility.htm#result_of"><tt class="docutils literal"><span class="pre">result_of</span></tt></a><tt class="docutils literal"><span class="pre">&lt;F()&gt;::type</span></tt>.<a class="footnote-reference" href="#no-result-of" id="A3" name="id18"><sup>2</sup></a></td>
</tr>

</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id47" id="value-type" name="value-type">5.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">value_type</span></tt></a></h2>
<p>Returns the result type of indexing an argument pack with a
<a class="reference" href="#keyword-tag-type">keyword tag type</a> or with a <a class="reference" href="#tagged-default">tagged default</a>.</p>
<p>返回以 <a class="reference" href="#keyword-tag-type">关键字标记类型(keyword tag type)</a> 或者 <a class="reference" href="#tagged-default">带标记的默认值(tagged default)</a> 为索引，在参数包中查找到的结果类型。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/value_type.hpp">boost/parameter/value_type.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/value_type.hpp">boost/parameter/value_type.hpp</a></td>
</tr>

</tbody>
</table>
<pre class="literal-block">template &lt;class A, class K, class D = void&gt;<br />struct value_type<br />{<br />    typedef … type;<br />};<br /></pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">A</span></tt> is a model of <a class="reference" href="#argumentpack"><span class="concept">ArgumentPack</span></a>.</p>
</td>
</tr>
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">A</span></tt> 是一个 <a class="reference" href="#argumentpack"><span class="concept">参数包(ArgumentPack)</span></a> 模式。</p>
</td>
</tr>

<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the type of the <a class="reference" href="#tagged-reference">tagged reference</a> in <tt class="docutils literal"><span class="pre">A</span></tt>
having <a class="reference" href="#keyword-tag-type">keyword tag type</a> <tt class="docutils literal"><span class="pre">K</span></tt>, if any.  If no such <a class="reference" href="#tagged-reference">tagged reference</a> exists, returns <tt class="docutils literal"><span class="pre">D</span></tt>. Equivalent to:</p>
<pre class="literal-block">typename remove_reference&lt;<br />  typename binding&lt;A, K, D&gt;::type<br />&gt;::type<br /></pre>
<p class="last">… when <tt class="docutils literal"><span class="pre">D</span></tt> is not a reference type.</p>
</td>
</tr>
<tr class="field"><th class="field-name">返回：</th><td class="field-body"><span class="pre">A</span> 中 其 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a> 为 <tt class="docutils literal"><span class="pre">K</span></tt> 的 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a> 的类型。如果没有这样的 <a class="reference" href="#tagged-reference">带标签的引用(tagged reference)</a> 存在，返回 <tt class="docutils literal"><span class="pre">D</span></tt>。等价于：
<pre class="literal-block">typename remove_reference&lt;<br />  typename binding&lt;A, K, D&gt;::type<br />&gt;::type<br /></pre>
<p class="last">… 当 <tt class="docutils literal"><span class="pre">D</span></tt> 不是引用类型时。</p>
</td>
</tr>

</tbody>
</table>
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="toc-backref" href="#id48" id="code-generation-macros" name="code-generation-macros">6&nbsp;&nbsp;&nbsp;Code Generation Macros 代码生成宏</a></h1>
<p>Macros in this section can be used to ease the writing of code using the Parameter libray by eliminating repetitive boilerplate.</p>
<p>这一节中讲到的宏通过提供经常使用到的模版来减轻使用 Parameter 库时写代码的负担。</p>

<div class="section">
<h2><a class="toc-backref" href="#id49" id="boost-parameter-function-result-name-tag-namespace-arguments" name="boost-parameter-function-result-name-tag-namespace-arguments">6.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)</span></tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/preprocessor.hpp">boost/parameter/preprocessor.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/preprocessor.hpp">boost/parameter/preprocessor.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">result</span></tt> is the parenthesized return type of the function.
<tt class="docutils literal"><span class="pre">name</span></tt> is the base name of the function, this is the name of the
generated forwarding functions. <tt class="docutils literal"><span class="pre">tag_namespace</span></tt> is the namespace in
which the keywords used by the function resides. <tt class="docutils literal"><span class="pre">arguments</span></tt> is
a list of <em>argument specifiers</em>, as defined below.</p>
</td>
</tr>
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">result</span></tt> 是用括号括起来的函数返回类型。
<tt class="docutils literal"><span class="pre">name</span></tt> 是函数的基名字，这是生成的转接函数(forwarding function)的名字。<tt class="docutils literal"><span class="pre">tag_namespace</span></tt> 是函数使用的关键字所在的命名空间。<tt class="docutils literal"><span class="pre">arguments</span></tt> 是一组 <em>参数描述子(argument specifiers)</em>，定义如下。</p>
</td>
</tr>

<tr class="field"><th class="field-name" colspan="2">Argument specifiers syntax:</th></tr>
<tr class="field"><th class="field-name" colspan="2">参数描述子语法：</th></tr>

<tr><td>&nbsp;</td><td class="field-body"><pre class="first literal-block">argument-specifiers ::= <em>specifier-group</em> {<em>specifier-group</em>}<br /><br />specifier-group0 ::= <em>specifier-group1</em> |<br />                     ( '<strong>(</strong>' '<strong>deduced</strong>' <em>specifier-group1</em> {<em>specifier-group1</em>} '<strong>)</strong>' )<br /><br />specifier-group1 ::= ( '<strong>(</strong>' '<strong>optional</strong>' <em>optional-specifier</em> {<em>optional-specifier</em>} '<strong>)</strong>' ) |<br />                     ( '<strong>(</strong>' '<strong>required</strong>' <em>required-specifier</em> {<em>required-specifier</em>} '<strong>)</strong>' )<br /><br />optional-specifier ::= '<strong>(</strong>' <em>name</em> '<strong>,</strong>' <em>restriction</em> '<strong>,</strong>' <em>default-value</em> ')'<br />required-specifier ::= '<strong>(</strong>' <em>name</em> '<strong>,</strong>' <em>restriction</em> ')'<br /><br />restriction ::= ('<strong>*</strong>' '<strong>(</strong>' <em>lambda-expression</em> '<strong>)</strong>' ) |<br />                ( '<strong>(</strong>' <em>typename</em> '<strong>)</strong>' ) |<br />                '<strong>*</strong>'<br /></pre>
<p class="last"><tt class="docutils literal"><span class="pre">name</span></tt> is any valid C++ identifier. <tt class="docutils literal"><span class="pre">default-value</span></tt> is any valid
C++ expression. <tt class="docutils literal"><span class="pre">typename</span></tt> is the name of a type.
<tt class="docutils literal"><span class="pre">lambda-expression</span></tt> is an <a class="reference" href="../../../mpl/doc/refmanual/lambda-expression.html">MPL lambda expression</a>.</p>
<p class="last"><tt class="docutils literal"><span class="pre">name</span></tt> 是任何合法的 C++ 标识符。<tt class="docutils literal"><span class="pre">default-value</span></tt> 是任何合法的 C++ 表达式。<tt class="docutils literal"><span class="pre">typename</span></tt> 是类型的名字。<tt class="docutils literal"><span class="pre">lambda-expression</span></tt> 是 <a class="reference" href="../../../mpl/doc/refmanual/lambda-expression.html">MPL lambda 表达式(MPL lambda expression)</a>。</p>

</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Generated names in enclosing scope:</th></tr>
<tr class="field"><th class="field-name" colspan="2">生成的在封闭作用域中的名字：</th></tr>

<tr><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">boost_param_result_</span> <span class="pre">##</span> <span class="pre">__LINE__</span> <span class="pre">##</span> <span class="pre">name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">boost_param_params_</span> <span class="pre">##</span> <span class="pre">__LINE__</span> <span class="pre">##</span> <span class="pre">name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">boost_param_parameters_</span> <span class="pre">##</span> <span class="pre">__LINE__</span> <span class="pre">##</span> <span class="pre">name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">boost_param_impl</span> <span class="pre">##</span> <span class="pre">name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">boost_param_default_</span> <span class="pre">##</span> <span class="pre">__LINE__</span> <span class="pre">##</span> <span class="pre">name</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dt>近似展开：</dt>

<dd>
<p class="first"><strong>Where</strong>:</p>
<p class="first"><strong>其中</strong>：</p>

<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> denotes the <em>minimum</em> arity, as determined from <tt class="docutils literal"><span class="pre">arguments</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> 表示 <em>最小(minimum)</em> 元数(arity)，由 <tt class="docutils literal"><span class="pre">arguments</span></tt> 决定。</li>

<li><tt class="docutils literal"><span class="pre">m</span></tt> denotes the <em>maximum</em> arity, as determined from <tt class="docutils literal"><span class="pre">arguments</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">m</span></tt> 表示 <em>最大(maximum)</em> 元数(arity), 由 <tt class="docutils literal"><span class="pre">arguments</span></tt> 决定。</li>

</ul>
<pre class="last literal-block">template &lt;class T&gt;<br />struct boost_param_result_ ## __LINE__ ## <strong>name</strong>
{
    typedef <strong>result</strong> type;<br />};<br /><br />struct boost_param_params_ ## __LINE__ ## <strong>name</strong>
  : boost::parameter::parameters&lt;
        <em>list of parameter specifications, based on arguments</em>
    &gt;
{};

typedef boost_param_params_ ## __LINE__ ## <strong>name</strong>
  boost_param_parameters_ ## __LINE__ ## <strong>name</strong>;<br /><br />template &lt;class A0, …, class A<strong>n</strong>&gt;<br /><em>result type</em> <strong>name</strong>(<br />    A0 <em>cv</em>&amp; a0, …, A<strong>n</strong> <em>cv</em>&amp; a<strong>n</strong>
  , typename boost_param_parameters_ ## __LINE__ ## <strong>name</strong>::match&lt;<br />      A0 <em>cv</em>, …, A<strong>n</strong> <em>cv</em>
    &gt;::type = boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()<br />)<br />{<br />    <em>… forward to implementation …</em>
}

<span class="vellipsis">⋮</span>

template &lt;class A0, …, class A<strong>m</strong>&gt;<br /><em>result type</em> <strong>name</strong>(<br />    A0 <em>cv</em>&amp; a0, …, A<strong>m</strong> <em>cv</em>&amp; a<strong>m</strong>
  , typename boost_param_parameters_ ## __LINE__ ## <strong>name</strong>::match&lt;<br />      A0 <em>cv</em>, …, A<strong>m</strong> <em>cv</em>
    &gt;::type = boost_param_parameters_ ## __LINE__ ## <strong>name</strong>()<br />)<br />{<br />    <em>… forward to implementation …</em>
}

template &lt;
    class ResultType
  , class <em>argument name</em><strong>0</strong> ## _type<br />    …<br />  , class <em>argument name</em><strong>m</strong> ## _type<br />&gt;<br />ResultType boost_param_default_ ## __LINE__ ## <strong>name</strong>(<br />    (ResultType(*)())<br />  , <em>argument name</em><strong>0</strong> ## _type&amp; <em>argument name</em><strong>0</strong>
    …
  , <em>argument name</em><strong>m</strong> ## _type&amp; <em>argument name</em><strong>m</strong>
)
</pre>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="boost-parameter-member-function-result-name-tag-namespace-arguments" name="boost-parameter-member-function-result-name-tag-namespace-arguments">6.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MEMBER_FUNCTION(result,name,tag_namespace,arguments)</span></tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/preprocessor.hpp">boost/parameter/preprocessor.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/preprocessor.hpp">boost/parameter/preprocessor.hpp</a></td>
</tr>

</tbody>
</table>
<p>See <tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)</span></tt></p>
<p>见 <tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)</span></tt></p>

</div>
<div class="section">
<h2><a class="toc-backref" href="#id51" id="boost-parameter-constructor-cls-impl-tag-namespace-arguments" name="boost-parameter-constructor-cls-impl-tag-namespace-arguments">6.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_CONSTRUCTOR(cls,</span> <span class="pre">impl,</span> <span class="pre">tag_namespace,</span> <span class="pre">arguments)</span></tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/preprocessor.hpp">boost/parameter/preprocessor.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/preprocessor.hpp">boost/parameter/preprocessor.hpp</a></td>
</tr>

</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">cls</span></tt> is the name of this class. <tt class="docutils literal"><span class="pre">impl</span></tt> is the
parenthesized implementation base class for <tt class="docutils literal"><span class="pre">cls</span></tt>.
<tt class="docutils literal"><span class="pre">tag_namespace</span></tt> is the namespace in which the keywords
used by the function resides. <tt class="docutils literal"><span class="pre">arguments</span></tt> is
a list of <em>argument specifiers</em>, as defined in
<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)</span></tt>.</p>
</td>
</tr>
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">cls</span></tt> 是类的名字。<tt class="docutils literal"><span class="pre">impl</span></tt> 是用括号括起来的 <tt class="docutils literal"><span class="pre">cls</span></tt> 的实现基类。
<tt class="docutils literal"><span class="pre">tag_namespace</span></tt> 是函数使用的关键字所在的命名空间。<tt class="docutils literal"><span class="pre">arguments</span></tt> 是一组 <em>参数描述子(argument specifiers)</em>，跟定义在 <tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)</span></tt> 中的一样。</p>
</td>
</tr>

<tr class="field"><th class="field-name" colspan="2">Generated names in enclosing scope:</th></tr>
<tr class="field"><th class="field-name" colspan="2">生成的在封闭作用域中的名字：</th></tr>

<tr><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">boost_param_params_</span> <span class="pre">##</span> <span class="pre">__LINE__</span> <span class="pre">##</span> <span class="pre">ctor</span></tt></li>
<li><tt class="docutils literal"><span class="pre">constructor_parameters</span> <span class="pre">##</span> <span class="pre">__LINE__</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Approximate expansion:</dt>
<dt>近似展开：</dt>

<dd>
<p class="first"><strong>Where</strong>:</p>
<p class="first"><strong>其中</strong>：</p>

<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> denotes the <em>minimum</em> arity, as determined from <tt class="docutils literal"><span class="pre">arguments</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> 表示 <em>最小(minimum)</em> 元数(arity)，由 <tt class="docutils literal"><span class="pre">arguments</span></tt> 决定。</li>

<li><tt class="docutils literal"><span class="pre">m</span></tt> denotes the <em>maximum</em> arity, as determined from <tt class="docutils literal"><span class="pre">arguments</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">m</span></tt> 表示 <em>最大(maximum)</em> 元数(arity), 由 <tt class="docutils literal"><span class="pre">arguments</span></tt> 决定。</li>

</ul>

<pre class="last literal-block">struct boost_param_params_ ## __LINE__ ## ctor<br />  : boost::parameter::parameters&lt;<br />        <em>list of parameter specifications, based on arguments</em>
    &gt;
{};

typedef boost_param_params_ ## __LINE__ ## <strong>name</strong>
  constructor_parameters ## __LINE__;

template &lt;class A0, …, class A<strong>n</strong>&gt;<br /><em>cls</em>(A0 const&amp; a0, …, A<strong>n</strong> const&amp; a<strong>n</strong>)<br />  : <em>impl</em>(constructor_parameters ## __LINE__(a0, …, a<strong>n</strong>))<br />{}<br /><br /><span class="vellipsis">⋮</span>

template &lt;class A0, …, class A<strong>m</strong>&gt;<br /><em>cls</em>(A0 const&amp; a0, …, A<strong>n</strong> const&amp; a<strong>m</strong>)<br />  : <em>impl</em>(constructor_parameters ## __LINE__(a0, …, a<strong>m</strong>))<br />{}<br /></pre>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="boost-parameter-name-name" name="boost-parameter-name-name">6.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_NAME(name)</span></tt></a></h2>
<p>Declares a tag-type and keyword object.</p>
<p>声明一个 标签类型(tag-type) 和 关键字(keyword) 对象。</p>
<p>Expands to:</p>
<p>展开成：</p>
<p><strong>If</strong> <em>name</em> is of the form:</p>
<p><strong>如果</strong> <em>name</em> 是这样形式：</p>
<pre class="literal-block">(<em>tag-name</em>, <em>namespace-name</em>) <em>object-name</em>
</pre>
<p><strong>then</strong></p>
<p><strong>那么</strong></p>
<pre class="literal-block">namespace <em>namespace-name</em>
{
  struct <em>tag-name</em>
  {
      static char const* keyword_name()
      {
          return ##<em>tag-name</em>;<br />      }<br /><br />      typedef <em>implementation defined</em> _;<br />      typedef <em>implementation defined</em> _1;<br />  };<br />}<br /><br />::boost::parameter::keyword&lt;<em>tag-namespace</em>::<em>tag-name</em>&gt; const&amp; <em>object-name</em>
    = ::boost::parameter::keyword&lt;<em>tag-namespace</em>::<em>tag-name</em>&gt;::instance;<br /></pre>
<p><strong>Else</strong></p>
<p><strong>反之</strong></p>
<pre class="literal-block">namespace tag<br />{<br />  struct <em>name</em>
  {
      static char const* keyword_name()
      {
          return ##<em>name</em>;<br />      }<br /><br />      typedef <em>implementation defined</em> _;<br />      typedef <em>implementation defined</em> _1;<br />  };<br />}<br /><br />::boost::parameter::keyword&lt;tag::<em>name</em>&gt; const&amp; _<em>name</em>
    = ::boost::parameter::keyword&lt;tag::<em>name</em>&gt;::instance;<br /></pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id53" id="boost-parameter-template-keyword-name" name="boost-parameter-template-keyword-name">6.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_TEMPLATE_KEYWORD(name)</span></tt></a></h2>
<p>Expands to:</p>
<p>展开成：</p>
<pre class="literal-block">namespace tag<br />{<br />  struct <em>name</em>;<br />}<br /><br />template &lt;class T&gt;<br />struct <em>name</em>
  : ::boost::parameter::template_keyword&lt;tag::<em>name</em>, T&gt;<br />{};<br /></pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id54" id="boost-parameter-fun-r-n-l-h-p" name="boost-parameter-fun-r-n-l-h-p">6.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUN(r,n,l,h,p)</span></tt></a></h2>
<div class="admonition-deprecated admonition">
<p class="first admonition-title">Deprecated</p>
<p class="first admonition-title">不赞成使用</p>
<p class="last">This macro has been deprecated in favor of <tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION</span></tt>.</p>
<p class="last">这个宏已经过时，请使用 <tt class="docutils literal"><span class="pre">BOOST_PARAMETER_FUNCTION</span></tt>。</p>
</div>
<p>Generates a sequence of <a class="reference" href="index.html#forwarding-functions">forwarding function</a> templates named
<tt class="docutils literal"><span class="pre">n</span></tt>, with arities ranging from <tt class="docutils literal"><span class="pre">l</span></tt> to <tt class="docutils literal"><span class="pre">h</span></tt> , returning <tt class="docutils literal"><span class="pre">r</span></tt>,
and using <tt class="docutils literal"><span class="pre">p</span></tt> to control overload resolution and assign tags to
positional arguments.</p>
<p>生成一组叫作 <tt class="docutils literal"><span class="pre">n</span></tt> 的 <a class="reference" href="index.html#forwarding-functions">转接函数(forwarding function)</a> 模版，其元数(arity)范围是从 <tt class="docutils literal"><span class="pre">l</span></tt> 到 <tt class="docutils literal"><span class="pre">h</span></tt>，返回 <tt class="docutils literal"><span class="pre">r</span></tt>，使用 <tt class="docutils literal"><span class="pre">p</span></tt> 来控制 重载解析(overload resolution) 并将标签(tag)赋给 位置相关的参数(positional argument)。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/macros.hpp">boost/parameter/macros.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/macros.hpp">boost/parameter/macros.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><tt class="docutils literal"><span class="pre">l</span></tt> and <tt class="docutils literal"><span class="pre">h</span></tt> are nonnegative integer tokens such
that <tt class="docutils literal"><span class="pre">l</span></tt> &lt; <tt class="docutils literal"><span class="pre">h</span></tt></td>
</tr>
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body"><tt class="docutils literal"><span class="pre">l</span></tt> 和 <tt class="docutils literal"><span class="pre">h</span></tt> 是非负整数，且 <tt class="docutils literal"><span class="pre">l</span></tt> &lt; <tt class="docutils literal"><span class="pre">h</span></tt></td>
</tr>

</tbody>
</table>
<dl class="docutils">
<dt>Generates</dt>
<dd><pre class="first last literal-block">template &lt;class A1, class A2, …class A##<strong>l</strong>&gt;<br />r name(<br />    A1 const&amp; a1, A2 const&amp; a2, …A<strong>l</strong> const&amp; x<strong>l</strong>
  , typename <strong>p</strong>::match&lt;A1,A2,…A<strong>l</strong>&gt;::type p = <strong>p</strong>())<br />{<br />   return <strong>name</strong>_with_named_params(<strong>p</strong>(x1,x2,…x<strong>l</strong>));<br />}<br /><br />template &lt;class A1, class A2, …class A<strong>l</strong>, class A##<a class="reference" href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong>l</strong>)&gt;<br />r name(<br />    A1 const&amp; a1, A2 const&amp; a2, …A<strong>l</strong> const&amp; x<strong>l</strong>
  , A##<a class="reference" href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong>l</strong>) const&amp; x##<a class="reference" href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong>l</strong>)<br />  , typename <strong>p</strong>::match&lt;A1,A2,…A<strong>l</strong>,A##<a class="reference" href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong>l</strong>)&gt;::type p = <strong>p</strong>())<br />{<br />   return <strong>name</strong>_with_named_params(<strong>p</strong>(x1,x2,…x<strong>l</strong>,x##<a class="reference" href="../../../preprocessor/doc/ref/inc.html">BOOST_PP_INC</a>(<strong>l</strong>)));<br />}<br /><br /><span class="vellipsis">⋮</span>

template &lt;class A1, class A2, …class A<strong>h</strong>&gt;<br />r name(<br />    A1 const&amp; a1, A2 const&amp; a2, …A<strong>h</strong> const&amp; x<strong>h</strong>
  , typename <strong>p</strong>::match&lt;A1,A2,…A<strong>h</strong>&gt;::type p = <strong>p</strong>())<br />{<br />   return <strong>name</strong>_with_named_params(<strong>p</strong>(a1,a2,…a<strong>h</strong>));<br />}<br /></pre>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="boost-parameter-keyword-n-k" name="boost-parameter-keyword-n-k">6.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_KEYWORD(n,k)</span></tt></a></h2>
<div class="admonition-deprecated admonition">
<p class="first admonition-title">Deprecated</p>
<p class="first admonition-title">不赞成使用</p>
<p class="last">This macro has been deprecated in favor of <tt class="docutils literal"><span class="pre">BOOST_PARAMETER_NAME</span></tt>.</p>
<p class="last">这个宏已经过时，请使用 <tt class="docutils literal"><span class="pre">BOOST_PARAMETER_NAME</span></tt>。</p>
</div>
<p>Generates the declaration of a <a class="reference" href="#keyword-tag-type">keyword tag type</a> named <tt class="docutils literal"><span class="pre">k</span></tt> in namespace <tt class="docutils literal"><span class="pre">n</span></tt>, and a corresponding <a class="reference" href="#keyword-object">keyword object</a> definition in the enclosing namespace.</p>
<p>生成在名字空间 <tt class="docutils literal"><span class="pre">n</span></tt> 中叫作 <tt class="docutils literal"><span class="pre">k</span></tt> 的 <a class="reference" href="#keyword-tag-type">关键字标签类型(keyword tag type)</a>，和一个定义在封闭名字空间中的 <a class="reference" href="#keyword-object">关键字对象(keyword object)</a>。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/keyword.hpp">boost/parameter/keyword.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/keyword.hpp">boost/parameter/keyword.hpp</a></td>
</tr>

</tbody>
</table>
<dl class="docutils">
<dt>Generates</dt>
<dd><pre class="first last literal-block">namespace <strong>n</strong> { struct <strong>k</strong>; }<br />namespace {<br />  boost::parameter::keyword&lt;<em>tag-namespace</em>::<strong>k</strong>&gt;&amp; <strong>k</strong>
  = boost::parameter::keyword&lt;<em>tag-namespace</em>::<strong>k</strong>&gt;::get();<br />}<br /></pre>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id56" id="boost-parameter-match-p-a-x" name="boost-parameter-match-p-a-x">6.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MATCH(p,a,x)</span></tt></a></h2>
<p>Generates a defaulted parameter declaration for a <a class="reference" href="index.html#forwarding-functions">forwarding function</a>.</p>
<p>为 <a class="reference" href="index.html#forwarding-functions">转接函数(forwarding function)</a> 生成默认的参变量声明。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/match.hpp">boost/parameter/match.hpp</a></td>
</tr>
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/match.hpp">boost/parameter/match.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">a</span></tt> is a <a class="reference" href="http://www.boost.org/libs/preprocessor/doc/data.html">Boost.Preprocessor sequence</a>
of the form</p>
<pre class="last literal-block">(A0)(A1)…(A<em>n</em>)<br /></pre>
</td>
</tr>
<tr class="field"><th class="field-name">约束条件：</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">a</span></tt> 是一个 如下形式的 <a class="reference" href="http://www.boost.org/libs/preprocessor/doc/data.html">Boost.Preprocessor 序列</a>：</p>
<pre class="last literal-block">(A0)(A1)…(A<em>n</em>)<br /></pre>
</td>
</tr>

</tbody>
</table>
<dl class="docutils">
<dt>Generates</dt>
<dt>生成</dt>
<dd><pre class="first last literal-block">typename <strong>p</strong>::match&lt;<strong>A0</strong>,<strong>A1</strong>…,<strong>A</strong><em>n</em>&gt;::type <strong>x</strong> = <strong>p</strong>()<br /></pre>
</dd>
</dl>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id57" id="configuration-macros" name="configuration-macros">7&nbsp;&nbsp;&nbsp;Configuration Macros 配置宏</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id58" id="boost-parameter-max-arity" name="boost-parameter-max-arity">7.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">BOOST_PARAMETER_MAX_ARITY</span></tt></a></h2>
<p>Determines the maximum number of arguments supported by the
library.  Will only be <tt class="docutils literal"><span class="pre">#defined</span></tt> by the library if it is not
already <tt class="docutils literal"><span class="pre">#defined</span></tt>.</p>
<p>设置这个库支持的最大参数个数。只有在没有被 <tt class="docutils literal"><span class="pre">定义(#defined)</span></tt> 时，库才会 <tt class="docutils literal"><span class="pre">定义(#defined)</span></tt> 它。</p>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">定义在：</th><td class="field-body"><a class="reference" href="../../../../boost/parameter/config.hpp">boost/parameter/config.hpp</a></td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">默认值：</th><td class="field-body"><tt class="docutils literal"><span class="pre">5</span></tt></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id59" id="tutorial" name="tutorial">8&nbsp;&nbsp;&nbsp;Tutorial 教程</a></h1>
<p>Follow <a class="reference" href="index.html#tutorial">this link</a> to the Boost.Parameter tutorial
documentation.</p>
<p>点击 <a class="reference" href="index.html#tutorial">这个链接</a> 到 Boost.Parameter 库的教程文档。</p>

<hr class="docutils" />
<table class="docutils footnote" id="thread" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="thread">[1]</a></td><td>References to tag objects may be initialized multiple
times.  This scenario can only occur in the presence of
threading.  Because the C++ standard doesn't consider threading,
it doesn't explicitly allow or forbid multiple initialization of
references.  That said, it's hard to imagine an implementation
where it could make a difference.</td>

<td>标签对象(tag object)的引用可能会被初始化多次。这种场景只有在多线程情况下才会发生。
C++ 标准没有考虑多线程，因此它没有显式地允许或者禁止引用的多次初始化。也就是说，难以想象实现有什么不同。</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" id="no-result-of" frame="void" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="no-result-of">[2]</a></td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id18">2</a>)</em> Where <a class="reference" href="../../../utility/utility.htm#BOOST_NO_RESULT_OF"><tt class="docutils literal"><span class="pre">BOOST_NO_RESULT_OF</span></tt></a> is <tt class="docutils literal"><span class="pre">#defined</span></tt>,
<tt class="docutils literal"><span class="pre">boost::</span></tt><a class="reference" href="../../../utility/utility.htm#result_of"><tt class="docutils literal"><span class="pre">result_of</span></tt></a><tt class="docutils literal"><span class="pre">&lt;F()&gt;::type</span></tt> is replaced by
<tt class="docutils literal"><span class="pre">F::result_type</span></tt>.</td>

<td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id18">2</a>)</em> 如果 <a class="reference" href="../../../utility/utility.htm#BOOST_NO_RESULT_OF"><tt class="docutils literal"><span class="pre">BOOST_NO_RESULT_OF</span></tt></a> 被 <tt class="docutils literal"><span class="pre">定义(#define)</span></tt> 过，
<tt class="docutils literal"><span class="pre">boost::</span></tt><a class="reference" href="../../../utility/utility.htm#result_of"><tt class="docutils literal"><span class="pre">result_of</span></tt></a><tt class="docutils literal"><span class="pre">&lt;F()&gt;::type</span></tt> 就等价于 <tt class="docutils literal"><span class="pre">F::result_type</span></tt>。</td>

</tr>
</tbody>
</table>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2008-06-26 21:51 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

本文档是由来自于 <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> 的 <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> 从源代码生成的。
</div>
</body></html>
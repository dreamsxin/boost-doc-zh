<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Copyright (c) Jeremy Siek and Andrew Lumsdaine 2000 --><!-- Distributed under the Boost --><!-- Software License, Version 1.0. (See accompanying --><!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
  
  <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1 September 2005), see www.w3.org" />

  
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  
  <link rel="stylesheet" href="../../rst.css" type="text/css" />


  
  <title>Boost Concept Checking Reference</title>
</head>








<body alink="#ff0000" bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b">

  <img src="../../boost.png" alt="C++ Boost" height="86" width="277" /><br clear="none" />


  
<h2><a name="reference" id="reference">Reference 参考</a></h2>


  
<ol>

    <li><a href="#macros">Macros 宏</a></li>


    <li><a href="#basic-concepts">Basic Concept Checking Classes 基本的概念检查类</a></li>


    <li><a href="#iterator-concepts">Iterator Concept Checking
    Classes 迭代器概念检查类</a></li>


    <li><a href="#function-object-concepts">Function Object Concept Checking
    Classes 函数对象概念检查类</a></li>


    <li><a href="#container-concepts">Container Concept Checking
    Classes 容器概念检查类</a></li>


    <li><a href="#basic-archetype">Basic Archetype Classes 基本的原型类</a></li>


    <li><a href="#iterator-archetype">Iterator Archetype Classes 迭代器原型类</a></li>


    <li><a href="#function-object-archetype">Function Object Archetype
    Classes 函数对象原型类</a></li>


    <li><a href="#container-archetype">Container Archetype Classes 容器原型类</a></li>


    <li><a href="#deprecated-functions">Deprecated Functions 不推荐使用的函数</a></li>


    <li><a href="#deprecated-macros">Deprecated Macros 不推荐使用的宏</a></li>


    <li><a href="#deprecated-concept-checking-classes">Deprecated Concept
    Checking Classes 不推荐使用的概念检查类</a></li>

  
</ol>


  
<h3><a name="macros" id="macros">Macros 宏</a></h3>

  
<pre>#include "boost/concept/assert.hpp"<br /><br />BOOST_CONCEPT_ASSERT((<em>concept checking class template specialization</em>));<br /></pre>


  
<p><strong>作用：</strong>如果概念不满足，引发一个编译错误。<br />

  <strong>说明：</strong>该宏可以在全局范围、类范围或函数范围中使用。</p>


  
<pre>#include "boost/concept/requires.hpp"<br /><br /><font color="gray">template &lt;&hellip;<em>template parameters</em>&hellip;&gt;</font>
BOOST_CONCEPT_REQUIRES(
  ((<em>concept checking class template specialization<sub>1</sub></em>)) <br />  ((<em>concept checking class template specialization<sub>2</sub></em>))&hellip; <br />  ((<em>concept checking class template specialization<sub>n</sub></em>))<strong>,</strong>
  (<em>function return type</em>)<br />) <font color="gray"><em>function_template_name</em>(&hellip;<em>function parameters</em>&hellip;)</font>
</pre>


  
<p><strong>作用：</strong>如果给定的概念不被满足，引发一个编译错误。<br />

  <strong>说明：</strong>该宏被规定为用于替代一个函数模板的返回类型。</p>


  
<h3><a name="basic-concepts" id="basic-concepts">Basic Concept Checking
  Classes 基本的概念检查类&nbsp;</a></h3>

  
<pre>#include "boost/concept_check.hpp"<br /><br />template &lt;class T&gt;<br />struct Integer; // T 是内建的整数类型吗？<br /><br />template &lt;class T&gt;<br />struct SignedInteger; // T 是内建的有符号整数类型吗？<br /><br />template &lt;class T&gt;<br />struct UnsignedInteger; // T 是内建的无符号整数类型吗？<br /><br />template &lt;class X, class Y&gt;<br />struct Convertible; // X 可以转换为 Y 吗？<br /><br />template &lt;class T&gt;<br />struct <a href="../utility/Assignable.html">Assignable</a>; // 参考标准 23.1<br /><br />template &lt;class T&gt;<br />struct SGI<a href="http://www.sgi.com/tech/stl/Assignable.html">Assignable</a>;<br /><br />template &lt;class T&gt;<br />struct <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">DefaultConstructible</a>;<br /><br />template &lt;class T&gt; <br />struct <a href="../utility/CopyConstructible.html">CopyConstructible</a>; // 参考标准 20.1.3<br /><br />template &lt;class T&gt; <br />struct <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">EqualityComparable</a>; // 参考标准 20.1.1<br /><br />template &lt;class T&gt;<br />struct <a href="../utility/LessThanComparable.html">LessThanComparable</a>; // 参考标准 20.1.2<br /><br />template &lt;class T&gt;<br />struct Comparable; // SGI STL 的 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">LessThanComparable</a> 概念<br /></pre>


  
<h3><a name="iterator-concepts" id="iterator-concepts">Iterator Concept
  Checking Classes 迭代器概念检查类&nbsp;</a></h3>

  
<pre>template &lt;class Iter&gt;<br />struct <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>; // 参考标准 24.1.1 表 72<br /><br />template &lt;class Iter, class T&gt; <br />struct <a href="http://www.sgi.com/tech/stl/OutputIterator.html">OutputIterator</a>; // 参考标准 24.1.2 表 73<br /><br />template &lt;class Iter&gt; <br />struct <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">ForwardIterator</a>; // 参考标准 24.1.3 表 74<br /><br />template &lt;class Iter&gt; <br />struct Mutable_ForwardIterator;<br /><br />template &lt;class Iter&gt; <br />struct <a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">BidirectionalIterator</a>; // 参考标准 24.1.4 表 75<br /><br />template &lt;class Iter&gt; <br />struct Mutable_BidirectionalIterator;<br /><br />template &lt;class Iter&gt; <br />struct <a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">RandomAccessIterator</a>; // 参考标准 24.1.5 表 76<br /><br />template &lt;class Iter&gt; <br />struct Mutable_RandomAccessIterator;<br /></pre>


  
<h3><a name="function-object-concepts" id="function-object-concepts">Function Object Concept Checking
  Classes 函数对象概念检查类</a></h3>

  
<pre>#include "boost/concept_check.hpp"<br /><br />template &lt;class Func, class Return&gt;<br />struct <a href="http://www.sgi.com/tech/stl/Generator.html">Generator</a>;<br /><br />template &lt;class Func, class Return, class Arg&gt;<br />struct <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">UnaryFunction</a>;<br /><br />template &lt;class Func, class Return, class First, class Second&gt;<br />struct <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">BinaryFunction</a>;<br /><br />template &lt;class Func, class Arg&gt;<br />struct Unary<a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>;<br /><br />template &lt;class Func, class First, class Second&gt;<br />struct <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">BinaryPredicate</a>;<br /><br />template &lt;class Func, class First, class Second&gt;<br />struct Const_BinaryPredicate;<br /><br />template &lt;class Func, class Return&gt;<br />struct <a href="http://www.sgi.com/tech/stl/AdaptableGenerator.html">AdaptableGenerator</a>;<br /><br />template &lt;class Func, class Return, class Arg&gt;<br />struct <a href="http://www.sgi.com/tech/stl/AdaptableUnaryFunction.html">AdaptableUnaryFunction</a>;<br /><br />template &lt;class Func, class First, class Second&gt;<br />struct <a href="http://www.sgi.com/tech/stl/AdaptableBinaryFunction.html">AdaptableBinaryFunction</a>;<br /><br />template &lt;class Func, class Arg&gt;<br />struct <a href="http://www.sgi.com/tech/stl/AdaptablePredicate.html">AdaptablePredicate</a>;<br /><br />template &lt;class Func, class First, class Second&gt;<br />struct <a href="http://www.sgi.com/tech/stl/AdaptableBinaryPredicate.html">AdaptableBinaryPredicate</a>;<br /></pre>


  
<h3><a name="container-concepts" id="container-concepts">Container Concept
  Checking Classes 容器概念检查类</a></h3>

  
<pre>#include "boost/concept_check.hpp"<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/Container.html">Container</a>; // 参考标准 23.1 表 65<br /><br />template &lt;class C&gt;<br />struct Mutable_Container;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/ForwardContainer.html">ForwardContainer</a>;<br /><br />template &lt;class C&gt;<br />struct Mutable_ForwardContainer;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">ReversibleContainer</a>; // 参考标准 23.1 表 66<br /><br />template &lt;class C&gt;<br />struct Mutable_ReversibleContainer;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">RandomAccessContainer</a>;<br /><br />template &lt;class C&gt;<br />struct Mutable_RandomAccessContainer;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>; // 参考标准 23.1.1<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/FrontInsertionSequence.html">FrontInsertionSequence</a>;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/BackInsertionSequence.html">BackInsertionSequence</a>;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/AssociativeContainer.html">AssociativeContainer</a>; // 参考标准 23.1.2 表 69<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">UniqueAssociativeContainer</a>;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/MultipleAssociativeContainer.html">MultipleAssociativeContainer</a>;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html">SimpleAssociativeContainer</a>;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/PairAssociativeContainer.html">PairAssociativeContainer</a>;<br /><br />template &lt;class C&gt;<br />struct <a href="http://www.sgi.com/tech/stl/SortedAssociativeContainer.html">SortedAssociativeContainer</a>;<br /></pre>


  
<h3><a name="basic-archetype" id="basic-archetype">Basic Archetype
  Classes 基本的原型类</a></h3>

  
<pre>#include "boost/concept_archetype.hpp"<br /><br />template &lt;class T = int&gt;<br />class null_archetype; // 没有概念的类型<br /><br />template &lt;class Base = null_archetype&gt;<br />class default_constructible_archetype;<br /><br />template &lt;class Base = null_archetype&gt;<br />class assignable_archetype;<br /><br />template &lt;class Base = null_archetype&gt;<br />class copy_constructible_archetype;<br /><br />template &lt;class Base = null_archetype&gt;<br />class equality_comparable_archetype;<br /><br />template &lt;class T, class Base = null_archetype&gt;<br />class convertible_to_archetype;<br /></pre>


  
<h3><a name="iterator-archetype" id="iterator-archetype">Iterator Archetype
  Classes 迭代器原型类</a></h3>

  
<pre>#include "boost/concept_archetype.hpp"<br /><br />template &lt;class ValueType&gt;<br />class trivial_iterator_archetype;<br /><br />template &lt;class ValueType&gt;<br />class mutable_trivial_iterator_archetype;<br /><br />template &lt;class ValueType&gt;<br />class input_iterator_archetype;<br /><br />template &lt;class ValueType&gt;<br />class forward_iterator_archetype;<br /><br />template &lt;class ValueType&gt;<br />class bidirectional_iterator_archetype;<br /><br />template &lt;class ValueType&gt;<br />class random_access_iterator_archetype;<br /></pre>


  
<h3><a name="function-object-archetype" id="function-object-archetype">Function Object Archetype Classes 函数对象原型类</a></h3>

  
<pre>#include "boost/concept_archetype.hpp"<br /><br />template &lt;class Arg, class Return&gt;<br />class unary_function_archetype;<br /><br />template &lt;class Arg1, class Arg2, class Return&gt;<br />class binary_function_archetype;<br /><br />template &lt;class Arg&gt;<br />class predicate_archetype;<br /><br />template &lt;class Arg1, class Arg2&gt;<br />class binary_predicate_archetype;<br /></pre>


  
<h3><a name="container-archetype" id="container-archetype">Container
  Archetype Classes 容器原型类</a></h3>

  
<pre>UNDER CONSTRUCTION<br /></pre>


  
<h3><a name="deprecated-functions" id="deprecated-functions">Deprecated
  Functions 不推荐使用的函数</a></h3>

  
<pre>#include "boost/concept_check.hpp"<br /><br />template &lt;class Concept&gt;<br />void function_requires();<br /></pre>


  
<h3><a name="deprecated-macros" id="deprecated-macros">Deprecated
  Macros 不推荐使用的宏</a></h3>

  
<pre>#include "boost/concept_check.hpp"<br /><br />// 在类定义中使用概念检查<br />BOOST_CLASS_REQUIRE(<i>type</i>, <i>namespace-of-concept</i>, <i>concept</i>);<br />BOOST_CLASS_REQUIRE2(<i>type1</i>, <i>type2</i>, <i>namespace-of-concept</i>, <i>concept</i>);<br />BOOST_CLASS_REQUIRE3(<i>type1</i>, <i>type2</i>, <i>type3</i>, <i>namespace-of-concept</i>, <i>concept</i>);<br />BOOST_CLASS_REQUIRE4(<i>type1</i>, <i>type2</i>, <i>type3</i>, <i>type4</i>, <i>namespace-of-concept</i>, <i>concept</i>);<br /><br />// 在类定义中使用概念检查<br />BOOST_CLASS_REQUIRES(<i>type</i>, <i>concept</i>);<br />BOOST_CLASS_REQUIRES2(<i>type1</i>, <i>type2</i>, <i>concept</i>);<br />BOOST_CLASS_REQUIRES3(<i>type1</i>, <i>type2</i>, <i>type3</i>, <i>concept</i>);<br />BOOST_CLASS_REQUIRES4(<i>type1</i>, <i>type2</i>, <i>type3</i>, <i>type4</i>, <i>concept</i>);<br /></pre>


  
<h3><a name="deprecated-concept-checking-classes" id="deprecated-concept-checking-classes">Deprecated Concept Checking
  Classes 不推荐使用的概念检查类</a></h3>


  
<p>对于本文档中所列出的每一个概念，本库包含了一个相同的概念检查类，其名字以&ldquo;<code>Concept</code>&rdquo;结尾。例如，除了 <code>RandomAccessIterator</code>, 本库还定义了一个
  <code>RandomAccessIteratorConcept</code> 类模板。</p>


  
<p><a href="./concept_check.htm">Back to Introduction 返回到简介</a><br />

  <a href="./implementation.htm">Prev: Implementation 实现</a><br />
</p>

  
<hr />

  
<table>

    <tbody>
    <tr valign="top">

      <td nowrap="nowrap">Copyright &copy; 2000</td>


      <td><a href="http://www.boost.org/people/jeremy_siek.htm">Jeremy Siek</a>(<a href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>) Andrew
      Lumsdaine(<a href="mailto:lums@osl.iu.edu">lums@osl.iu.edu</a>), 2007
      <a href="mailto:dave@boost-consulting.com">David Abrahams</a>.</td>

    </tr>

  
  </tbody>
</table>

</body>
</html>

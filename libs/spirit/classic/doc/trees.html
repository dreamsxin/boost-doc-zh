<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Trees</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="theme/style.css" type="text/css"></head>
<body>
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr>
    <td width="10">
    <br>
</td>
    <td width="85%"> <font face="Verdana, Arial, Helvetica, sans-serif" size="6"><b>Trees 树</b></font>
    </td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0" height="48" width="112"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr>
    <td width="10"><br>
</td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="symbols.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="multi_pass.html"><img src="theme/r_arr.gif" border="0"></a></td>
   </tr>
</tbody></table>
<h2>Why use parse trees 为什么要用分析树</h2>
<p> Parse trees are an in-memory representation of the input with a structure
  that conforms to the grammar.<br>分析树是输入在内存中的一个表示法，它带有与语法相符合的结构。</p>
<p> The advantages of using parse trees instead of semantic actions:<br>使用分析树替代语义动作的优点：</p>
<ul>
  <li>You can make multiple passes over the data without having to re-parse the
    input.<br>你可以多次遍历数据，而无需对输入进行重新分析。</li>
  <li>You can perform transformations on the tree.<br>你可以在树上执行变换。</li>
  <li>You can evaluate things in any order you want, whereas with attribute schemes
    you have to process in a begin to end fashion.<br>你可以按任意顺序对你想要的东西求值，而使用属性机制则你必须从头到尾来处理。</li>
  <li>You do not have to worry about backtracking and action side effects that
    may occur with an ambiguous grammar.<br>你不需要担心一个模糊语法可能的回溯和动作的副作用。</li>
</ul>
<p> <b>Example 例子</b></p>
<p> Now that you think you may want to use trees, I'll give an example of how
  to use them and you can see how easy they are to use. So, following with tradition
  (and the rest of the documentation) we'll do a calculator. Here's the grammar:<br>现在假设你想使用分析树，我将给出一个关于如何使用它们的例子，你会看到使用它们是多容易。嗯，根据传统(以及本文档的其余部分)，我们要实现一个计算器。以下是语法：</p>
<pre>    <code><span class="identifier">integer </span><span class="special">
        =   </span><span class="identifier"><font color="#ff0000"><b>token_node_d</b></font></span><span class="special">[ (!</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'-'</span><span class="special">) &gt;&gt; +</span><span class="identifier">digit_p</span><span class="special">) ]<br>        ;<br><br>    </span><span class="identifier">factor<br>        </span><span class="special">=   </span><span class="identifier">integer<br>        </span><span class="special">|   </span><span class="literal">'(' </span><span class="special">&gt;&gt; </span><span class="identifier">expression </span><span class="special">&gt;&gt; </span><span class="literal">')'<br>        </span><span class="special">|   (</span><span class="literal">'-' </span><span class="special">&gt;&gt; </span><span class="identifier">factor</span><span class="special">)<br>        ;<br><br>    </span><span class="identifier">term<br>        </span><span class="special">=   </span><span class="identifier">factor </span><span class="special">
            &gt;&gt; *(   (</span><span class="literal">'*' </span><span class="special">&gt;&gt; </span><span class="identifier">factor</span><span class="special">)<br>                |   (</span><span class="literal">'/' </span><span class="special">&gt;&gt; </span><span class="identifier">factor</span><span class="special">)<br>                )<br>        ;<br><br>    </span><span class="identifier">expression<br>        </span><span class="special">=   </span><span class="identifier">term<br>            </span><span class="special">&gt;&gt; *(   (</span><span class="literal">'+' </span><span class="special">&gt;&gt; </span><span class="identifier">term</span><span class="special">)<br>                |   (</span><span class="literal">'-' </span><span class="special">&gt;&gt; </span><span class="identifier">term</span><span class="special">)<br>                )<br>        ;</span></code></pre>
<p> Now, you'll notice the only thing different in this grammar is the <tt>token_node_d</tt>
  directive. This causes the match of the integer rule to end up in one node.
  Without <tt>token_node_d</tt>, each character would get it's own node. 
  Further note that <tt>token_node_d</tt> is an implicit lexeme (that means
  no <tt>lexeme_d</tt> is needed to switch to character level parsing).
  As you'll soon see, it's easier to convert the input into an int when all 
  the characters are in one node. Here is how the parse is done to create a tree:<br>现在，你会留意到，在这个语法中不同的仅仅是 <tt>token_node_d</tt>
  指示符。它导致这个 integer 规则在一个节点处结束。没有 <tt>token_node_d</tt>，则每个字符都会有自己的节点。进一步，留意 <tt>token_node_d</tt> 是一个隐式的词位(这意味着，不需要 <tt>lexeme_d</tt> 来切换至字符层面的分析)。正如你即将看到的，如果所有字符在一个节点中，则更容易将输入转换为一个 int。以下是如何在分析完成后创建一棵树：</p>
<pre>    <code><span class="identifier">tree_parse_info</span><span class="special">&lt;&gt; </span><span class="identifier">info </span><span class="special">= </span><span class="identifier"><font color="#ff0000"><b>pt_parse</b></font></span><span class="special">(</span><span class="identifier">first</span><span class="special">, </span><span class="identifier">expression</span><span class="special">);</span></code></pre>
<p> <tt>pt_parse()</tt> is similar to <tt>parse()</tt>. There are four overloads:
  two for pairs of first and last iterators and two for character strings. Two
  of the functions take a skipper parser and the other two do not.<br><tt>pt_parse()</tt> 类似于 <tt>parse()</tt>。它有四个重载：两个使用 first 和 last 迭代器对，两个使用字符串。两个接受一个跳过分析器，另两个则不接受。</p>
<p> The <tt>tree_parse_info</tt> struct contains the same information as a <tt>parse_info</tt>
  struct as well as one extra data member called trees. When the parse finishes,
  trees will contain the parse tree.<br>结构&nbsp;<tt>tree_parse_info</tt> 包含与 <tt>parse_info</tt>
  结构相同的信息，以及一个额外的数据成员，名为 trees。当分析完成时，trees 中将包含该分析树。</p>
<p> Here is how you can use the tree to evaluate the input:<br>以下是如何使用这棵树来对输入求值：</p>
<pre>    <code><span class="keyword">if </span><span class="special">(</span><span class="identifier">info</span><span class="special">.</span><span class="identifier">full</span><span class="special">)<br>    {<br>        </span><span class="identifier">cout </span><span class="special">&lt;&lt; </span><span class="string">"parsing succeeded\n"</span><span class="special">;<br>        </span><span class="identifier">cout </span><span class="special">&lt;&lt; </span><span class="string">"result = " </span><span class="special">&lt;&lt; </span><span class="identifier"><font color="#ff0000"><b>evaluate</b></font></span><span class="special">(</span><span class="identifier">info</span><span class="special">) &lt;&lt; </span><span class="string">"\n\n"</span><span class="special">;<br>    }</span></code></pre>
<p> Now you ask, where did <tt>evaluate()</tt> come from? Is it part of spirit?
  Unfortunately, no, <tt>evaluate()</tt> is only a part of the sample. Here it
  is:<br>现在你会问，<tt>evaluate()</tt> 是从哪来的？它是spirit的一部分吗？很不幸，它不是，<tt>evaluate()</tt> 只是本例的一部分。以下就是它：</p>
<pre>    <code><span class="keyword">long </span><span class="identifier">evaluate</span><span class="special">(</span><span class="keyword">const </span><span class="identifier">tree_parse_info</span><span class="special">&lt;&gt;&amp; </span><span class="identifier">info</span><span class="special">)<br>    </span><span class="special">{<br>        </span><span class="keyword">return </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">info</span><span class="special">.</span><span class="identifier">trees</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());<br>    </span><span class="special">}</span></code></pre>
<p> So here you see evaluate() simply calls <tt>eval_expression()</tt> passing
  the begin() iterator of info.trees. Now here's the rest of the example:<br>你可以看到 evaluate() 只是调用 <tt>eval_expression()</tt> 而已，传入&nbsp;info.trees 的 begin() 迭代器。以下是该例子的其它部分：</p>
<pre>    <code><span class="comment">// Here's some typedefs to simplify things 这是一些typedef，用于简化<br>    </span><span class="keyword">typedef char const</span><span class="special">*                              </span><span class="identifier">iterator_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">tree_match</span><span class="special">&lt;</span><span class="identifier">iterator_t</span><span class="special">&gt;             </span><span class="identifier">      parse_tree_match_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">parse_tree_match_t</span><span class="special">::</span><span class="identifier">const_tree_iterator  iter_t</span><span class="special">;<br><br>    </span><span class="comment">// Here's the function prototypes that we'll use.  One function for each<br>    // grammar rule</span><span class="special">. <span style="font-style: italic;">这是要用的函数原型。每个语法规则一个函数。</span><br>    </span><span class="keyword">long </span><span class="identifier">evaluate</span><span class="special">(</span><span class="keyword">const </span><span class="identifier">tree_parse_info</span><span class="special">&lt;&gt;&amp; </span><span class="identifier">info</span><span class="special">);<br>    </span><span class="keyword">long </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">);<br>    </span><span class="keyword">long </span><span class="identifier">eval_term</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">);<br>    </span><span class="keyword">long </span><span class="identifier">eval_factor</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">);<br>    </span><span class="keyword">long </span><span class="identifier">eval_integer</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">);<br><br>    </span><span class="comment">// i should be pointing to a node created by the expression rule<br>    // i 应指向一个由expression规则创建的节点<br>    </span><span class="keyword">long </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">)<br>    {<br>        </span><span class="comment">// first child points to a term, so call eval_term on it 第一个子节点指向一个term，因此对它调用eval_term<br>        </span><span class="identifier">iter_t chi </span><span class="special">= </span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();<br>        </span><span class="keyword">long </span><span class="identifier">lhs </span><span class="special">= </span><span class="identifier">eval_term</span><span class="special">(</span><span class="identifier">chi</span><span class="special">);<br>        </span><span class="keyword">for </span><span class="special">(++</span><span class="identifier">chi</span><span class="special">; </span><span class="identifier">chi </span><span class="special">!= </span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">end</span><span class="special">(); ++</span><span class="identifier">chi</span><span class="special">)<br>        {<br>            </span><span class="comment">// next node points to the operator.  The text of the operator is<br>            // stored in value (a vector&lt;char&gt;) 下一个节点指向操作符。操作符的文本保存在vector&lt;char&gt;中<br>            </span><span class="keyword">char </span><span class="identifier">op </span><span class="special">= *(</span><span class="identifier">chi</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());<br>            ++</span><span class="identifier">chi</span><span class="special">;<br>            </span><span class="keyword">long </span><span class="identifier">rhs </span><span class="special">= </span><span class="identifier">eval_term</span><span class="special">(</span><span class="identifier">chi</span><span class="special">);<br>            </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">op </span><span class="special">== </span><span class="literal">'+'</span><span class="special">)<br>                </span><span class="identifier">lhs </span><span class="special">+= </span><span class="identifier">rhs</span><span class="special">;<br>            </span><span class="keyword">else if </span><span class="special">(</span><span class="identifier">op </span><span class="special">== </span><span class="literal">'-'</span><span class="special">)<br>                </span><span class="identifier">lhs </span><span class="special">-= </span><span class="identifier">rhs</span><span class="special">;<br>            </span><span class="keyword">else<br>                </span><span class="identifier">assert</span><span class="special">(</span><span class="number">0</span><span class="special">);<br>        }<br>        </span><span class="keyword">return </span><span class="identifier">lhs</span><span class="special">;<br>    }<br><br>    </span><span class="keyword">long </span><span class="identifier">eval_term</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">)<br>    {<br>        </span><span class="comment">//  ... see <a href="../example/fundamental/parse_tree_calc1.cpp">parse_tree_calc1.cpp</a> for complete example<br>        //  (it's rather similar to eval_expression() ) ...<br></span></code><code><span class="special">        </span><span class="comment">//  ... 完整的例子见 <a href="../example/fundamental/parse_tree_calc1.cpp">parse_tree_calc1.cpp</a>, (与eval_expression()相似)<br></span></code><code><span class="comment">    </span><span class="special">}<br><br>    </span><span class="keyword">long </span><span class="identifier">eval_factor</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">)<br>    {<br>        </span><span class="comment">//  ... again, see <a href="../example/fundamental/parse_tree_calc1.cpp">parse_tree_calc1.cpp</a> if you want all the details ...<br>        //  ... 同样，如果想知道细节，请见</span></code><code><span class="comment"> <a href="../example/fundamental/parse_tree_calc1.cpp">parse_tree_calc1.cpp</a> </span></code><code><span class="comment"> <br>    </span><span class="special">}<br><br>    </span><span class="keyword">long </span><span class="identifier">eval_integer</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">)<br>    </span><span class="special">{<br>        </span><span class="comment">// use the range constructor for a string 对字符串使用区间构造器<br>        </span><span class="identifier">string </span><span class="identifier">integer</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(), </span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">end</span><span class="special">());<br>        </span><span class="comment">// convert the string to an integer 将字符串转换为整数<br>        </span><span class="keyword">return </span><span class="identifier">strtol</span><span class="special">(</span><span class="identifier">integer</span><span class="special">.</span><span class="identifier">c_str</span><span class="special">(), </span><span class="number">0</span><span class="special">, </span><span class="number">10</span><span class="special">);<br>    </span><span class="special">}<br></span></code></pre>

<p>  <img src="theme/lens.gif" height="16" width="15"> The full source code can be <a href="../example/fundamental/parse_tree_calc1.cpp">viewed here</a>. This is part of the Spirit distribution.<br><img src="theme/lens.gif" height="16" width="15"> 完整的源代码可以 <a href="../example/fundamental/parse_tree_calc1.cpp">在此查看</a>。这是Spirit发布包的一部分。</p><p>So, you like what you see, but maybe you think that the parse tree is too
    hard to process? With a few more directives you can generate an abstract syntax
    tree (ast) and cut the amount of evaluation code by at least <b>50%</b>. So
    without any delay, here's the ast calculator grammar:<br>就象你所看到的，也许你认为这个分析树很难处理？只要一点点指示符，你就可以生成一个抽象语法树(ast)并缩减至少<b>50%</b>的求值代码数量。因此，不要拖延了，以下就是这个 ast 计算器语法：</p>
<pre>    <code><span class="identifier">integer<br>        </span><span class="special">=   </span><span class="identifier"><font color="#ff0000"><b>leaf_node_d</b></font></span><span class="special">[ </span><span class="special">(!</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'-'</span><span class="special">) &gt;&gt; +</span><span class="identifier">digit_p</span><span class="special">) ]<br>        ;<br><br>    </span><span class="identifier">factor<br>        </span><span class="special">=   </span><span class="identifier">integer<br>        </span><span class="special">|   </span><span class="identifier"><font color="#ff0000"><b>inner_node_d</b></font></span><span class="special">[</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'('</span><span class="special">) &gt;&gt; </span><span class="identifier">expression </span><span class="special">&gt;&gt; </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">')'</span><span class="special">)]<br>        |   (</span><span class="identifier"><font color="#ff0000"><b>root_node_d</b></font></span><span class="special">[</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'-'</span><span class="special">)] &gt;&gt; </span><span class="identifier">factor</span><span class="special">)<br>        ;<br><br>    </span><span class="identifier">term<br>        </span><span class="special">=   </span><span class="identifier">factor </span><span class="special">
            &gt;&gt; *(  (</span><span class="identifier"><font color="#ff0000"><b>root_node_d</b></font></span><span class="special">[</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'*'</span><span class="special">)] &gt;&gt; </span><span class="identifier">factor</span><span class="special">)<br>                |  (</span><span class="identifier"><font color="#ff0000"><b>root_node_d</b></font></span><span class="special">[</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'/'</span><span class="special">)] &gt;&gt; </span><span class="identifier">factor</span><span class="special">)<br>                )<br>        ;<br><br>    </span><span class="identifier">expression<br>        </span><span class="special">=   </span><span class="identifier">term<br>            </span><span class="special">&gt;&gt; *(  (</span><span class="identifier"><font color="#ff0000"><b>root_node_d</b></font></span><span class="special">[</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'+'</span><span class="special">)] &gt;&gt; </span><span class="identifier">term</span><span class="special">)<br>                | (</span><span class="identifier"><font color="#ff0000"><b>root_node_d</b></font></span><span class="special">[</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'-'</span><span class="special">)] &gt;&gt; </span><span class="identifier">term</span><span class="special">)<br>                )<br>        ;</span></code></pre>
<p> The differences from the parse tree grammar are hi-lighted in <b><font color="#ff0000">bold-red</font></b>.
  The <tt>inner_node_d</tt> directive causes the first and last nodes generated
  by the enclosed parser to be discarded, since we don't really care about the
  parentheses when evaluating the expression. The <tt>root_node_d</tt> directive
  is the key to ast generation. A node that is generated by the parser inside
  of <tt>root_node_d</tt> is marked as a root node. When a root node is created,
  it becomes a root or parent node of the other nodes generated by the same rule.<br>与分析树语法的差异用 <b><font color="#ff0000">bold-red</font></b> 高亮显示。指示符 <tt>inner_node_d</tt> 令内层分析器生成的第一个和最后一个节点被忽略，因为我们在对表达式求值时不关心其括号。指示符 <tt>root_node_d</tt> 是生成 ast 的关键。由 <tt>root_node_d</tt>&nbsp;内部的分析器所生成的节点被标记为根节点。当一个根节点被创建时，它会成为同一个规则所生成的其它节点的根节点或父节点。</p>
<p> To start the parse and generate the ast, you must use the ast_parse functions,
  which are similar to the pt_parse functions.<br>要开始分析和生成 ast，你必须使用 ast_parse 函数，它类似于 pt_parse 函数。</p>
<pre>    <code><span class="identifier">tree_parse_info</span><span class="special">&lt;&gt; </span><span class="identifier">info </span><span class="special">= </span><span class="identifier">ast_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">, </span><span class="identifier">expression</span><span class="special">);</span></code></pre>
<p> Here is the eval_expression function (note that to process the ast we only
  need one function instead of four):<br>以下是 eval_expression 函数(注意，处理 ast 我们只需要一个函数，而不是四个)：</p>
<pre>    <code><span class="keyword">long </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">iter_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">i</span><span class="special">)<br>    </span><span class="special">{<br>        </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">id</span><span class="special">() </span><span class="special">== </span><span class="identifier">parser_id</span><span class="special">(&amp;</span><span class="identifier">integer</span><span class="special">))<br>        </span><span class="special">{<br>            </span><span class="comment">// convert string to integer 将字符串转换为整数<br>            </span><span class="identifier">string </span><span class="identifier">integer</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(), </span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">end</span><span class="special">());<br>            </span><span class="keyword">return </span><span class="identifier">strtol</span><span class="special">(</span><span class="identifier">integer</span><span class="special">.</span><span class="identifier">c_str</span><span class="special">(), </span><span class="number">0</span><span class="special">, </span><span class="number">10</span><span class="special">);<br>        </span><span class="special">}<br>        </span><span class="keyword">else </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">id</span><span class="special">() </span><span class="special">== </span><span class="identifier">parser_id</span><span class="special">(&amp;</span><span class="identifier">factor</span><span class="special">))<br>        </span><span class="special">{<br>            </span><span class="comment">// factor can only be unary minus   factor只能是单参减法<br>            </span><span class="keyword">return </span><span class="special">- </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());<br>        </span><span class="special">}<br>        </span><span class="keyword">else </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">id</span><span class="special">() </span><span class="special">== </span><span class="identifier">parser_id</span><span class="special">(&amp;</span><span class="identifier">term</span><span class="special">))<br>        </span><span class="special">{<br>            </span><span class="keyword">if </span><span class="special">(*</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">begin</span><span class="special">() </span><span class="special">== </span><span class="literal">'*'</span><span class="special">)<br>            </span><span class="special">{<br>                </span><span class="keyword">return </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()) </span><span class="special">*<br>                    </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()+</span><span class="number">1</span><span class="special">);<br>            </span><span class="special">}<br>            </span><span class="keyword">else </span><span class="keyword">if </span><span class="special">(*</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">begin</span><span class="special">() </span><span class="special">== </span><span class="literal">'/'</span><span class="special">)<br>            </span><span class="special">{<br>                </span><span class="keyword">return </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()) </span><span class="special">/<br>                    </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()+</span><span class="number">1</span><span class="special">);<br>            </span><span class="special">}<br>        </span><span class="special">}<br>        </span><span class="keyword">else </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">id</span><span class="special">() </span><span class="special">== </span><span class="identifier">parser_id</span><span class="special">(&amp;</span><span class="identifier">expression</span><span class="special">))<br>        </span><span class="special">{<br>            </span><span class="keyword">if </span><span class="special">(*</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">begin</span><span class="special">() </span><span class="special">== </span><span class="literal">'+'</span><span class="special">)<br>            </span><span class="special">{<br>                </span><span class="keyword">return </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()) </span><span class="special">+<br>                    </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()+</span><span class="number">1</span><span class="special">);<br>            </span><span class="special">}<br>            </span><span class="keyword">else </span><span class="keyword">if </span><span class="special">(*</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">begin</span><span class="special">() </span><span class="special">== </span><span class="literal">'-'</span><span class="special">)<br>            </span><span class="special">{<br>                </span><span class="keyword">return </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()) </span><span class="special">-<br>                    </span><span class="identifier">eval_expression</span><span class="special">(</span><span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">children</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()+</span><span class="number">1</span><span class="special">);<br>            </span><span class="special">}<br>        </span><span class="special">}<br><br>        </span><span class="keyword">return </span><span class="number">0</span><span class="special">;<br>    </span><span class="special">}<br></span></code></pre>
<p> <img src="theme/lens.gif" height="16" width="15"> An entire working example is <a href="../example/fundamental/ast_calc.cpp">ast_calc.cpp</a>. Hopefully this example has been enough to whet your appetite for 
  trees. For more nitty-gritty details, keep on reading the rest of this chapter.<br><img src="theme/lens.gif" height="16" width="15"> 整个可用的例子在 <a href="../example/fundamental/ast_calc.cpp">ast_calc.cpp</a>。希望该例子足以满足你对分析树的欲望。更具体的细节，请继续阅读本章剩余部分。</p>
<a name="usage"></a>
<h2>Usage 用法</h2>
<a name="pt_parse"></a>
<h3>pt_parse</h3>
<p> To create a parse tree, you can call one of the five free functions:<br>要创建一个分析树，你可以调用以下五个自由函数之一：</p>
<pre>    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">FactoryT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">SkipT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">, </span><span class="identifier">FactoryT</span><span class="special">&gt;    <br>    </span><span class="identifier">pt_parse</span><span class="special">(        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">first_</span><span class="special">,        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">last_</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">,        <br>        </span><span class="identifier">SkipT </span><span class="keyword">const</span><span class="special">&amp;            </span><span class="identifier">skip_</span><span class="special">,<br>        </span><span class="identifier">FactoryT</span><span class="special"> </span><span class="keyword">const</span><span class="special"> &amp;        </span><span class="identifier">factory_</span><span class="special"> = </span><span class="identifier">FactoryT</span><span class="special">());    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">SkipT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">&gt;    <br>    </span><span class="identifier">pt_parse</span><span class="special">(        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">first_</span><span class="special">,        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">last_</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">,        <br>        </span><span class="identifier">SkipT </span><span class="keyword">const</span><span class="special">&amp;            </span><span class="identifier">skip_</span><span class="special">);    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">&gt;    <br>    </span><span class="identifier">pt_parse</span><span class="special">(        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">first_</span><span class="special">,        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">last_</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">);    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">CharT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">SkipT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*&gt;    <br>    </span><span class="identifier">pt_parse</span><span class="special">(        <br>        </span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*            </span><span class="identifier">str</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">,        <br>        </span><span class="identifier">SkipT </span><span class="keyword">const</span><span class="special">&amp;            </span><span class="identifier">skip</span><span class="special">);    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">CharT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*&gt;    <br>    </span><span class="identifier">pt_parse</span><span class="special">(        <br>        </span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*            </span><span class="identifier">str</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">);<br></span></pre>
<a name="ast_parse"></a>
<h3>ast_parse</h3>
<p> To create an abstract syntax tree (ast for short) you call one of the five
  free functions:<br>要创建一个抽象语法树(缩写为ast)，你可以调用以下五个自由函数之一：</p>
<pre>    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">FactoryT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">SkipT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">, </span><span class="identifier">FactoryT</span><span class="special">&gt;    <br>    </span><span class="identifier">ast_parse</span><span class="special">(        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">first_</span><span class="special">,        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">last_</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">,        <br>        </span><span class="identifier">SkipT </span><span class="keyword">const</span><span class="special">&amp;            </span><span class="identifier">skip_</span><span class="special">,<br>       </span><span class="identifier"> FactoryT</span><span class="special"> </span><span class="keyword">const</span><span class="special"> &amp;        </span><span class="identifier">factory_</span><span class="special"> = </span><span class="identifier">FactoryT</span><span class="special">()</span><span class="special">);    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">SkipT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">&gt;    <br>    </span><span class="identifier">ast_parse</span><span class="special">(        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">first_</span><span class="special">,        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">last_</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">,        <br>        </span><span class="identifier">SkipT </span><span class="keyword">const</span><span class="special">&amp;            </span><span class="identifier">skip_</span><span class="special">);    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">&gt;    <br>    </span><span class="identifier">ast_parse</span><span class="special">(        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">first_</span><span class="special">,        <br>        </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp;        </span><span class="identifier">last</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">);    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">CharT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">SkipT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*&gt;    <br>    </span><span class="identifier">ast_parse</span><span class="special">(        <br>        </span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*            </span><span class="identifier">str</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">,        <br>        </span><span class="identifier">SkipT </span><span class="keyword">const</span><span class="special">&amp;            </span><span class="identifier">skip</span><span class="special">);    <br>    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">CharT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">ParserT</span><span class="special">&gt;    <br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*&gt;    <br>    </span><span class="identifier">ast_parse</span><span class="special">(        <br>        </span><span class="identifier">CharT </span><span class="keyword">const</span><span class="special">*            </span><span class="identifier">str</span><span class="special">,        <br>        </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">ParserT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;  </span><span class="identifier">parser</span><span class="special">);<br></span></pre>
<a name="tree_parse_info"></a> 
<h3>tree_parse_info</h3>
<p> The <tt>tree_parse_info</tt> struct returned from pt_parse and ast_parse contains 
  information about the parse:<br>从 pt_parse 和 ast_parse 返回的 <tt>tree_parse_info</tt> 结构含有本次分析的信息：</p>
<pre>    <code><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT </span><span class="special">= </span><span class="keyword">char </span><span class="keyword">const</span><span class="special">*&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">tree_parse_info<br>    </span><span class="special">{<br>        </span><span class="identifier">IteratorT   </span><span class="identifier">stop</span><span class="special">;<br>        </span><span class="keyword">bool        </span><span class="identifier">match</span><span class="special">;<br>        </span><span class="keyword">bool        </span><span class="identifier">full</span><span class="special">;<br>        </span><span class="keyword">std::size_t </span><span class="identifier">length</span><span class="special">;<br><br>        </span><span class="keyword">typename </span><span class="identifier">tree_match</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">&gt;::</span><span class="identifier">container_t </span><span class="identifier">trees</span><span class="special">;<br>    </span><span class="special">};<br></span></code></pre>
<table align="center" border="0" width="90%">
  <tbody><tr>
    <td class="table_title" colspan="10"> tree_parse_info </td>
  </tr>
  <tr>
  </tr><tr>
    <td class="table_cells"><b>stop</b></td>
    <td class="table_cells">points to the final parse position (i.e. parsing processed
      the input up to this point).<br>指向最后的分析位置(即此点之前的输入已完成分析)</td>
  </tr>
  <tr><td class="table_cells"><b>match</b></td>
  <td class="table_cells">true if parsing is successful. This may be full (the
    parser consumed all the input), or partial (the parser consumed only a portion
    of the input.)<br>如果分析成功则为 true。可能是完整的(分析器消耗了所有输入)，或部分的(分析器只消耗了部分输入)。</td>
  </tr>
  <tr><td class="table_cells"><b>full</b></td>
  <td class="table_cells">true when we have a full match (when the parser consumed
    all the input).<br>完全匹配(分析器消耗了所有输入)时为 true。</td>
  </tr>
  <tr><td class="table_cells"><b>length</b></td>
  <td class="table_cells">The number of characters consumed by the parser. This
    is valid only if we have a successful match (either partial or full).<br>分析器所消耗的字符数量。仅当匹配成功(部分或全部)时有效。</td>
  </tr>
  <tr><td class="table_cells"><b>trees</b></td>
  <td class="table_cells">Contains the root node(s) of the tree.<br>包含树的根节点。</td>
  </tr>
</tbody></table>
<a name="tree_match"></a>
<h3>tree_match</h3>
<p> When Spirit is generating a tree, the parser's parse() member function will 
  return a tree_match object, instead of a match object. tree_match has three 
  template parameters. The first is the Iterator type which defaults to <tt>char 
  const*</tt>. The second is the node factory, which defaults to <a href="trees.html#node_val_data_factory">node_val_data_factory</a>. 
  The third is the attribute type stored in the match. A tree_match has a member 
  variable which is a container (a <tt>std::vector</tt>) of <a href="trees.html#tree_node">tree_node</a> 
  objects named trees. For efficiency reasons, when a tree_match is copied, the 
  trees are <b>not</b> copied, they are moved to the new object, and the source 
  object is left with an empty tree container. tree_match supports the same interface 
  as the match class: it has an operator bool() so you can test it for a sucessful 
  match: if (matched), and you can query the match length via the length() function. 
  The class has this interface:<br>当Spirit生成一棵树时，分析器的 parse() 成员函数将返回一个 tree_match 对象，而不是一个 match 对象。tree_match 有三个模板参数。第一个是 Iterator 类型，缺省为 <tt>char 
  const*</tt>。第二个是节点工厂，缺省为 <a href="#node_val_data_factory">node_val_data_factory</a>。第三个是保存在匹配中的属性类型。tree_match 有一个名为 trees 的成员变量，它是一个 <a href="#tree_node">tree_node</a> 
  容器(一个 <tt>std::vector</tt>)。
由于效率原因，当一个 tree_match 被复制时，将不复制这个
trees，而是把它移至新对象中，而源对象中则只留下一个空的树容器。tree_match 支持与 match 类相同的接口：它有一个
operator bool()，因此你可以测试它是否一个成功的匹配：如果是(已匹配的)，则你可以通过 length()
函数查询该匹配的长度。该类具有以下接口：</p>
<pre>    <code><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT </span><span class="special">= </span><span class="keyword">char </span><span class="keyword">const</span><span class="special">*, </span><span class="keyword">typename </span><span class="identifier">NodeFactoryT </span><span class="special">= </span><span class="identifier">node_val_data_factory</span><span class="special">&lt;&gt; </span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">tree_match<br>    </span><span class="special">{<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">NodeFactoryT</span><span class="special">::</span><span class="keyword">template </span><span class="identifier">factory</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">&gt; </span><span class="identifier">node_factory_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">node_factory_t</span><span class="special">::</span><span class="identifier">node_t                    </span><span class="identifier">parse_node_t</span><span class="special">;<br>        </span><span class="keyword">typedef          </span><span class="identifier">tree_node</span><span class="special">&lt;</span><span class="identifier">parse_node_t</span><span class="special">&gt;                   </span><span class="identifier">node_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">node_t</span><span class="special">::</span><span class="identifier">children_t                        </span><span class="identifier">container_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">iterator                     </span><span class="identifier">tree_iterator</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">const_iterator               </span><span class="identifier">const_tree_iterator</span><span class="special">;<br><br>        </span><span class="identifier">tree_match</span><span class="special">();<br>        </span><span class="identifier">tree_match</span><span class="special">(</span><span class="keyword">std::size_t </span><span class="identifier">length</span><span class="special">, </span><span class="identifier">parse_node_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">n</span><span class="special">);<br>        </span><span class="identifier">tree_match</span><span class="special">(</span><span class="identifier">tree_match </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>        </span><span class="keyword">explicit </span><span class="identifier">tree_match</span><span class="special">(</span><span class="identifier">match </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>        </span><span class="identifier">tree_match</span><span class="special">&amp; </span><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">tree_match </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>        </span><span class="keyword">void </span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">tree_match</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>        </span><span class="keyword">operator </span><span class="keyword">bool</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="keyword">int </span><span class="identifier">length</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br><br>        </span><span class="identifier">container_t </span><span class="identifier">trees</span><span class="special">;<br>    </span><span class="special">};</span></code></pre>
<p> When a parse has sucessfully completed, the trees data member will contain 
  the root node of the tree.<br>当一次分析成功完成，数据成员 trees 将包含树的根节点。 </p>
<table align="center" border="0" width="80%">
  <tbody><tr> 
    <td class="note_box"><img src="theme/lens.gif" height="16" width="15"> <b>vector?</b><br>
      <br>
      You may wonder, why is it a vector then? The answer is that it is partly 
      for implementation purposes, and also if you do not use any rules in your 
      grammar, then trees will contain a sequence of nodes that will not have 
      any children.<br>你可能会奇怪，为什么要用vector？答案是，这部分是为了实现的目的，而且如果你在你的语法中没有使用任何规则，那么 trees 将包含一系列没有子节点的节点。</td>
  </tr>
</tbody></table>
<p> Having spirit create a tree is similar to how a normal parse is done:<br>spirit 创建分析树类似于进行普通的分析：</p>
<pre>    <code><span class="identifier">tree_match</span><span class="special">&lt;&gt; </span><span class="identifier">hit </span><span class="special">= </span><span class="identifier">expression</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">tree_scanner</span><span class="special">);<br><br>    </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">hit</span><span class="special">)<br>        </span><span class="identifier">process_tree_root</span><span class="special">(</span><span class="identifier">hit</span><span class="special">.</span><span class="identifier">trees</span><span class="special">[</span><span class="number">0</span><span class="special">]); </span><span class="comment">// do something with the tree 对分析树做操作</span></code></pre>
<a name="tree_node"></a>
<h3>tree_node</h3>
<p> Once you have created a tree by calling <a href="trees.html#pt_parse">pt_parse</a>
  or <a href="trees.html#ast_parse">ast_parse</a>, you have a <a href="trees.html#tree_parse_info">tree_parse_info</a>
  which contains the root node of the tree, and now you need to do something with
  the tree. The data member trees of <a href="trees.html#tree_parse_info">tree_parse_info</a>
  is a std::vector&lt;tree_node&gt;. tree_node provides the tree structure. The
  class has one template parameter named T. tree_node contains an instance of
  type T. It also contains a std::vector&lt;tree_node&lt;T&gt; &gt; which are
  the node's children. The class looks like this:<br>一旦你通过调用 <a href="#pt_parse">pt_parse</a> 或 <a href="#ast_parse">ast_parse</a> 创建了分析树，你就有了一个 <a href="#tree_parse_info">tree_parse_info</a>，它包含了树的根节点，而现在你需要对这棵树做一些操作。<a href="#tree_parse_info">tree_parse_info</a>
的数据成员 tress 是一个 std::vector&lt;tree_node&gt;。tree_node
提供了这个树结构。这个类有一个名为 T 的模板参数。tree_node 包含一个类型为 T 的实例。它还包含有一个
std::vector&lt;tree_node&lt;T&gt; &gt; 作为该节点的子节点。该类看起来就象：</p>
<pre>    <code><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">tree_node<br>    </span><span class="special">{<br>        </span><span class="keyword">typedef </span><span class="identifier">T </span><span class="identifier">parse_node_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">tree_node</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt; </span><span class="special">&gt; </span><span class="identifier">children_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">children_t</span><span class="special">::</span><span class="identifier">iterator </span><span class="identifier">tree_iterator</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">children_t</span><span class="special">::</span><span class="identifier">const_iterator </span><span class="identifier">const_tree_iterator</span><span class="special">;<br><br>        </span><span class="identifier">T </span><span class="identifier">value</span><span class="special">;<br>        </span><span class="identifier">children_t </span><span class="identifier">children</span><span class="special">;<br><br>        </span><span class="identifier">tree_node</span><span class="special">();<br>        </span><span class="keyword">explicit </span><span class="identifier">tree_node</span><span class="special">(</span><span class="identifier">T </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">v</span><span class="special">);<br>        </span><span class="identifier">tree_node</span><span class="special">(</span><span class="identifier">T </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">v</span><span class="special">, </span><span class="identifier">children_t </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">c</span><span class="special">);<br>        </span><span class="keyword">void </span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">tree_node</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp; </span><span class="identifier">x</span><span class="special">);<br>    </span><span class="special">};</span></code></pre>
<p> This class is simply used to separate the tree framework from the data stored 
  in the tree. It is a generic node and any type can be stored inside it and acessed 
  via the data member value. The default type for T is <tt>node_val_data</tt>.<br>该类只是被用于将分析树框架与树中所存数据分离开。它是一个泛型的节点，任意类型都可以保存在其之内且通过数据成员 value 来访问。T 的缺省类型是 <tt>node_val_data</tt>.</p>
<a name="node_val_data"></a>
<h3>node_val_data</h3>
<p> The <tt>node_val_data</tt> class contains the actual information about each 
  node. This includes the text or token sequence that was parsed, an <tt>id</tt> 
  that indicates which rule created the node, a boolean flag that indicates whether 
  the node was marked as a root node, and an optional user-specified value. This 
  is the interface:<br>类 <tt>node_val_data</tt> 包含了关于每个节点的实际信息。其中包含被分析的文本或记号序列，一个 <tt>id</tt> 
  用于表示是哪个规则创建了该节点，一个布尔 flag 表示该节点是否被标记为根节点，以及一个可选的用户指定的值。接口如下：</p>
<pre>    <code><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT </span><span class="special">= </span><span class="keyword">char </span><span class="keyword">const</span><span class="special">*, </span><span class="keyword">typename </span><span class="identifier">ValueT </span><span class="special">= </span><span class="identifier">nil_t</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">node_val_data<br>    </span><span class="special">{<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator_traits</span><span class="special">&lt;</span><span class="identifier">IteratorT</span><span class="special">&gt;::</span><span class="identifier">value_type </span><span class="identifier">value_type</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt; </span><span class="identifier">container_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">iterator </span><span class="identifier">iterator_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">const_iterator </span><span class="identifier">const_iterator_t</span><span class="special">;<br><br>        </span><span class="identifier">node_val_data</span><span class="special">();<br>        </span><span class="identifier">node_val_data</span><span class="special">(</span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">_first</span><span class="special">, </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">_last</span><span class="special">);<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT2</span><span class="special">&gt;<br>        </span><span class="identifier">node_val_data</span><span class="special">(</span><span class="identifier">IteratorT2 </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">_first</span><span class="special">, </span><span class="identifier">IteratorT2 </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">_last</span><span class="special">);<br>        </span><span class="keyword">void </span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">node_val_data</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br><br>        </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">iterator </span><span class="identifier">begin</span><span class="special">();<br>        </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">const_iterator </span><span class="identifier">begin</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">iterator </span><span class="identifier">end</span><span class="special">();<br>        </span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">const_iterator </span><span class="identifier">end</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br><br>        </span><span class="keyword">bool </span><span class="identifier">is_root</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="keyword">void </span><span class="identifier">is_root</span><span class="special">(</span><span class="keyword">bool </span><span class="identifier">b</span><span class="special">);<br><br>        </span><span class="identifier">parser_id </span><span class="identifier">id</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="keyword">void </span><span class="identifier">id</span><span class="special">(</span><span class="identifier">parser_id </span><span class="identifier">r</span><span class="special">);<br><br>        </span><span class="identifier">ValueT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">value</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="keyword">void </span><span class="identifier">value</span><span class="special">(</span><span class="identifier">ValueT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">v</span><span class="special">);<br>    </span><span class="special">};<br></span></code></pre>
<a name="parser_id__checking_and_setting"></a>
<h3>parser_id, checking and setting 检查与设置</h3>
<p> If a node is generated by a rule, it will have an <tt>id</tt> set. Each rule 
  has an id that it sets of all nodes generated by that rule. The id is of type 
  <tt><a href="rule.html#tag">parser_id</a></tt>. The default id of each rule 
  is set to the address of that rule (converted to an integer). This is not always 
  the most convenient, since the code that processes the tree may not have access 
  to the rules, and may not be able to compare addresses. So, you can override 
  the default id used by each rule by <a href="rule.html#tag">giving it a specific 
  ID</a>. Then, when processing the tree you can call <tt>node_val_data::id()</tt> 
  to see which rule created that node.<br>如果一个节点由一个规则生成了，它将具有一个 <tt>id</tt> 集。每个规则都有一个 id，它将被设入由该规则生成的所有规则。id 的类型为 
  <tt><a href="rule.html#tag">parser_id</a></tt>。每个规则的缺省 id 被设置为该规则的地址(转换为一个整数)。这并不总是最方便的，因为处理该分析树的代码并不能访问该规则，也不可能比较该地址。因此，你可以通过 <a href="rule.html#tag">指定特定ID</a> 来重载每个规则所使用的缺省 id。然后，在处理该分析树时，你就可以调用 <tt>node_val_data::id()</tt> 
  来查看是哪个规则创建了该节点。</p>
<a name="structure_layout_of_a_parse_tree"></a>
<h2>structure/layout of a parse tree 分析树的结构/布局</h2>
<a name="parse_tree_layout"></a>
<h3>parse tree layout 分析树的布局</h3>
<p> The tree is organized by the rules. Each rule creates a new level in the tree.
  All parsers attached to a rule create a node when a sucessful match is made.
  These nodes become children of a node created by the rule. So, the following
  code:<br>分析树由规则组成。每个规则在树中创建一个新的层级。附加至某个规则的所有分析器在成功匹配时创建一个节点。这些节点成为由该规则所创建的一个节点的子节点。因此，以下代码：</p>
<pre>    <code><span class="identifier">rule_t </span><span class="identifier">myrule </span><span class="special">= </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'a'</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="literal">',' </span><span class="special">&gt;&gt; </span><span class="special">*</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'b'</span><span class="special">);<br>    </span><span class="keyword">char </span><span class="keyword">const</span><span class="special">* </span><span class="identifier">input </span><span class="special">= </span><span class="string">"a,bb"</span><span class="special">;<br>    </span><span class="identifier">scanner_t </span><span class="identifier">scanner</span><span class="special">(</span><span class="identifier">input</span><span class="special">, </span><span class="identifier">input </span><span class="special">+ </span><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">input</span><span class="special">));<br>    </span><span class="identifier">tree_match</span><span class="special">&lt;&gt; </span><span class="identifier">m </span><span class="special">= </span><span class="identifier">myrule</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scanner</span><span class="special">);<br></span></code></pre>
<p> When executed, this code would return a tree_match, m. <tt>m.trees[0]</tt> 
  would contain a tree like this:<br>在执行时，该代码将返回一个 tree_match，m. <tt>m.trees[0]</tt> 
  将包含如下的一棵树：</p>
<table align="center" border="0">
  <tbody><tr>
    <td><img src="theme/trees1.png" height="151" width="253"></td>
  </tr>
</tbody></table>
<p> The root node would not contain any text, and it's id would be set to the
  address of myrule. It would have four children. Each child's id would be set
  to the address of myrule, would contain the text as shown in the diagram, and
  would have no children.<br>根节点不包含任何文本，其 id 被设为 myrule 的地址。它有四个子节点。每个子节点的 id 都被设为 myrule 的地址，每个子节点包含如图所示的文本，且不带子节点。</p>
<a name="ast_layout"></a>
<h2>ast layout &nbsp;ast的布局</h2>
<p> When calling <a href="trees.html#ast_parse">ast_parse</a>, the tree gets generated differently.
  It mostly works the same as when generating a parse tree. The difference happens
  when a rule only generated one sub-node. Instead of creating a new level, <a href="trees.html#ast_parse">ast_parse</a>
  will not create a new level, it will just leave the existing node. So, this
  code:<br>调用 <a href="#ast_parse">ast_parse</a> 时，将以不同的方式生成分析树。该函数与生成一棵分析树几乎一样。差别在于，一个规则只生成一个子节点。<a href="#ast_parse">ast_parse</a>
  不会创建新的层级，它只会保留已有节点。因此，以下代码：</p>
<pre>    <code><span class="identifier">rule_t </span><span class="identifier">myrule </span><span class="special">= </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'a'</span><span class="special">);<br>    </span><span class="keyword">char </span><span class="keyword">const</span><span class="special">* </span><span class="identifier">input </span><span class="special">= </span><span class="string">"a"</span><span class="special">;<br>    </span><span class="identifier">ast_scanner_t </span><span class="identifier">scanner</span><span class="special">(</span><span class="identifier">input</span><span class="special">, </span><span class="identifier">input</span><span class="special">+</span><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">input</span><span class="special">));<br>    </span><span class="identifier">tree_match</span><span class="special">&lt;&gt; </span><span class="identifier">m </span><span class="special">= </span><span class="identifier">myrule</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scanner</span><span class="special">);<br></span></code></pre>
<p> will generate a single node that contains 'a'. If <tt>tree_match_policy</tt> 
  had been used instead of <tt>ast_match_policy</tt>, the tree would have looked 
  like this:<br>将生成一个包含 'a' 的单节点为。如果使用了 <tt>tree_match_policy</tt> 
  来替代 <tt>ast_match_policy</tt>，则分析树看起来如下：</p>
<table align="center" border="0">
  <tbody><tr>
    <td><img src="theme/trees2.png" height="151" width="139"></td>
  </tr>
</tbody></table>
<p> ast_match_policy has the effect of eliminating intermediate rule levels which
  are simply pass-through rules. This is not enough to generate abstract syntax
  trees, <a href="trees.html#root_node_d_and_ast_generation">root_node_d</a> is also needed. <a href="trees.html#root_node_d_and_ast_generation">root_node_d</a>
  will be explained later.<br>ast_match_policy 的作用是消除中间那些只是传递规则的规则层。这不足以生成抽象语法树，<a href="#root_node_d_and_ast_generation">root_node_d</a> 也是需要的。<a href="#root_node_d_and_ast_generation">root_node_d</a>
  将在稍后解释。</p>
<a name="switching__gen_pt_node_d____amp__gen_ast_node_d__"></a>
<h2>switching: gen_pt_node_d[] &amp; gen_ast_node_d[]</h2>
<p> If you want to mix and match the parse tree and ast behaviors in your application, 
  you can use the <tt>gen_pt_node_d[]</tt> and <tt>gen_ast_node_d[]</tt> directives. 
  When parsing passes through the <tt>gen_pt_node_d</tt> directive, parse tree 
  creation behavior is turned on. When the <tt>gen_ast_node_d</tt>
directive is    used, the enclosed parser will generate a tree using the
ast behavior. Note    that you must pay attention to how your rules are declared
if you use a rule inside of these    directives. &nbsp;The match policy of
the scanner will have to correspond to the desired behavior. &nbsp;If you
avoid rules and use primitive parsers or grammars, then you will not have
problems.<br>如果你想在你的应用中混用并匹配分析树和 ast 的行为，你可以使用 <tt>gen_pt_node_d[]</tt> 和 <tt>gen_ast_node_d[]</tt> 指示符。当通过 <tt>gen_pt_node_d</tt> 指示符进行分析时，分析树创建的行为被打开。当使用 <tt>gen_ast_node_d</tt>
指示符时，内部的分析器将生成一棵使用
ast 行为的树。注意，如果你在这些指示符内部使用规则，你必须留意你的规则是如何声明的。扫描器的匹配策略必须与想要的行为相对应。如果你避过规则而使用基本分析器或语法，则你没有此问题。</p>
<a name="directives"></a>
<h2>Directives 指示符</h2>
<p> There are a few more directives that can be used to control the generation 
  of trees. These directives only effect tree generation. Otherwise, they have 
  no effect.<br>还有几个指示符可用于控制树的生成。这些指示符仅对树的生成起作用。其它情况下，它们没有影响。<br>
</p>
<a name="no_node_d"></a>
<h3>no_node_d</h3>
<p> This directive is similar to <tt>gen_pt_node_d</tt> and <tt>gen_ast_node_d</tt>, 
  in that is modifies the scanner's match policy used by the enclosed parser. As it's name 
  implies, it does no tree generation, it turns it off completely. This is useful 
  if there are parts of your grammar which are not needed in the tree. For instance: 
  keywords, operators (<tt>*</tt>, <tt>-</tt>, <tt>&amp;&amp;</tt>, etc.) By eliminating 
  these from the tree, both memory usage and parsing time can be lowered. This 
  directive has the same requirements with respect to rules as <tt>gen_pt_node_d</tt> 
  and <tt>gen_ast_node_d</tt> do. See the example file xml_grammar.hpp (in libs/spirit/example/application/xml 
  directory) for example 
  usage of <tt>no_node_d[]</tt>.<br>这个指示符类似于 <tt>gen_pt_node_d</tt> 和 <tt>gen_ast_node_d</tt>，修改内部分析器所用的扫描器匹配策略。顾名思义，它不进行树生成，完全关闭。如果你的语法中有一部分不需要出现在树中，这就很有用了。例如：关键字、操作符(<tt>*</tt>, <tt>-</tt>, <tt>&amp;&amp;</tt>, 等等)。通过从树中消除掉这些，可以同时降低内存耗用和分析时间。这个指示符对规则的要求与 <tt>gen_pt_node_d</tt> 和 <tt>gen_ast_node_d</tt> 一样。有关 <tt>no_node_d[]</tt> 的用例，请见例程 xml_grammar.hpp (位于目录 libs/spirit/example/application/xml)。</p>
<a name="discard_node_d"></a>
<h3>discard_node_d</h3>
<p> This directive has a similar purpose to <tt>no_node_d</tt>, but works differently. 
  It does not switch the scanner's match policy, so the enclosed parser still generates 
  nodes. The generated nodes are discarded and do not appear in the tree. Using 
  <tt>discard_node_d</tt> is slower than <tt>no_node_d</tt>, but it does not suffer 
  from the drawback of having to specify a different rule type for any rule inside 
  it.<br>这个指示符的目的与 <tt>no_node_d</tt> 类似，但工作方式不同。它不改变扫描器的匹配策略，因此内层的分析器仍旧生成节点。生成的节点被忽略，不会出现在树中。使用 
  <tt>discard_node_d</tt> 要慢于 <tt>no_node_d</tt>，但它不会遇到必须为内部规则指定不同规则类型的问题。</p>
<a name="leaf_node_d_token_node_d"></a>
<h3>leaf_node_d/token_node_d</h3>
<p> Both <tt>leaf_node_t</tt> and <tt>token_node_d</tt> work the same. They 
    create a single node for the match generated by the enclosed parser. 
    Unlike with earlier versions of Spirit, this directive is an implicit
    lexeme and alters the scanner (see 
    <a href="faq.html#scanner_business">Scanner Business</a>).<br><tt>leaf_node_t</tt> 和 <tt>token_node_d</tt> 作用相同。它们为内层分析器所生成的匹配创建单个节点。与Spirit早期的版本不同，这个指示符是一个隐式词位，并修改了扫描器(见 
    <a href="faq.html#scanner_business">扫描器业务</a>)。 </p>
<h3>reduced_node_d</h3>
<p> This directive groups together all the nodes generated by the enclosed parser. 
    For earlier versions of Spirit <tt>leaf_node_d</tt> and <tt>token_node_d</tt>
    were implemented this way. The new implementation of those directives is a
    lot faster, so <tt>reduced_node_d</tt> is primarily provided for portability
    and can be useful when using a custom node factory (see advanced tree 
    generation, below).<br>这个指示符将内层分析器所生成的所有节点组到一起。对于早期版本的Spirit，<tt>leaf_node_d</tt> 和 <tt>token_node_d</tt>
    也是以此方式实现。这些指示符的新实现要快不少，因此 <tt>reduced_node_d</tt> 主要是为可移植性而提供，使用定制节点工厂时(见下文的 高级树生成)可以使用。</p>
<h3>infix_node_d</h3>
<p> This is useful for removing separators from lists. It discards all the nodes
  in even positions. Thus this rule:<br>用于从列表中去掉分隔符。它略过偶数位置上的所有节点。因此，以下规则：</p>
<pre>    <code><span class="identifier">rule_t </span><span class="identifier">intlist </span><span class="special">= </span><span class="identifier">infix_node_d</span><span class="special">[ </span><span class="identifier">integer </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="literal">',' </span><span class="special">&gt;&gt; </span><span class="identifier">integer</span><span class="special">) </span><span class="special">];</span></code></pre>
<p> would discard all the comma nodes and keep all the integer nodes.<br>将略过所有逗号节点而保存所有整数节点。</p>
<a name="discard_first_node_d"></a>
<h3>discard_first_node_d</h3>
<p> This discards the first node generated.<br>略过生成的第一个节点。</p>
<a name="discard_last_node_d"></a>
<h3>discard_last_node_d</h3>
<p> This discards the last node generated.<br>略过生成的最后一个节点。</p>
<a name="inner_node_d"></a>
<h3>inner_node_d</h3>
<p> This discards the first and last node generated.<br>略过生成的第一个和最后一个节点。</p>
<a name="root_node_d_and_ast_generation"></a> 
<h2>root_node_d and ast generation &nbsp;root_node_d和ast的生成</h2>
<p> The <tt>root_node_d</tt> directive is used to help out ast generation. It 
  has no effect when generating a parse tree. When a parser is enclosed in <tt>root_node_d</tt>, 
  the node it generates is marked as a root. This affects the way it is treated 
  when it's added to the list of nodes being generated. Here's an example:<br>指示符 <tt>root_node_d</tt> 用于协助 ast 的生成。在生成一个分析树时没有影响。当一个分析器用 <tt>root_node_d</tt> 括起时，它生成的节点被标记为根。当它被添加到所生成的节点列表中时，这会影响它被对待的方式。以下是一个例子：</p>
<pre>    <code><span class="identifier">rule_t </span><span class="identifier">add </span><span class="special">= </span><span class="identifier">integer </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="identifier">root_node_d</span><span class="special">[ </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'+'</span><span class="special">) </span><span class="special">] </span><span class="special">&gt;&gt; </span><span class="identifier">integer</span><span class="special">);</span></code></pre>
<p> When parsing 5+6 the following tree will be generated:<br>在分析 5+6 时，将生成以下树：</p>
<table align="center" border="0">
  <tbody><tr>
    <td><img src="theme/trees3.png"></td>
  </tr>
</tbody></table>
<p> When parsing 1+2+3 the following will be generated:<br>当分析 1+2+3 时，将生成以下树：</p>
<table align="center" border="0">
  <tbody><tr>
    <td><img src="theme/trees4.png"></td>
  </tr>
</tbody></table>
<p> When a new node is created the following rules are used to determine how the
  tree will be generated:<br>当创建一个新节点时，以下规则将被用于确定如何生成该树：</p>
<pre><code>    Let a be the previously generated node.  令a为之前生成的节点。<br>    Let b be the new node.  令b为新节点。<br><br>    If b is a root node then  如果b是根节点，则<br><br>        b's children become a + b's previous children.  b的子节点变为a+b的前一个子节点。<br>        a is the new first child of b.  a为b的新的首子节点。<br><br>    else if a is a root node and b is not, then  否则，如果a是根节点而b不是，则<br><br>        b becomes the last child of a.  b成为a的尾子节点。<br><br>    else  否则<br><br>        a and b become siblings.  a和b变为兄弟</code></pre>
<p> After parsing leaves the current rule, the root node flag on the top node
  is turned off. This means that the root_node_d directive only affects the current
  rule.<br>在分析了当前规则的其余部分后，顶部节点的根节点标志被关闭。这意味着 root_node_d 指示符仅作用于当前规则。</p>
<p> <img src="theme/lens.gif" height="16" width="15"> The example <a href="../example/fundamental/ast_calc.cpp">ast_calc.cpp</a>  demonstrates the use of root_node_d and <a href="#ast_parse">ast_parse</a>. The full source code can be <a href="../example/fundamental/ast_calc.cpp">viewed here</a>. This is part of the Spirit distribution.<br><img src="theme/lens.gif" height="16" width="15"> 例子 <a href="../example/fundamental/ast_calc.cpp">ast_calc.cpp</a>  示范了 root_node_d 和 <a href="trees.html#ast_parse">ast_parse</a> 的使用。完整的源代码可 <a href="../example/fundamental/ast_calc.cpp">在此查看</a>。这是Spirit发布包的一部分。</p>
<a name="parse_tree_iterator"></a>
<h2>parse_tree_iterator</h2>
<p> The <tt>parse_tree_iterator</tt> class allows you to parse a tree using spirit. 
  The class iterates over the tokens in the leaf nodes in the same order they 
  were created. The <tt>parse_tree_iterator</tt> is templated on <tt>ParseTreeMatchT</tt>. 
  It is constructed with a container of trees, and a position to start. Here is 
  an example usage:<br>类 <tt>parse_tree_iterator</tt> 允许你用spirit分析一棵树。该类以创建时的相同顺序迭代叶子节点中的记号。<tt>parse_tree_iterator</tt> 按 <tt>ParseTreeMatchT</tt> 模板化。它以一个树容器和一个开始位置进行构造。以下是一个用例：</p>
<pre>    <code><span class="identifier">rule_t </span><span class="identifier">myrule </span><span class="special">= </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'a'</span><span class="special">);<br>    </span><span class="keyword">char </span><span class="keyword">const</span><span class="special">* </span><span class="identifier">input </span><span class="special">= </span><span class="string">"a"</span><span class="special">;<br><br>    </span><span class="comment">// generate parse tree 生成分析树<br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;&gt; </span><span class="identifier">i </span><span class="special">= </span><span class="identifier">pt_parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">, </span><span class="identifier">myrule</span><span class="special">);<br><br>    </span><span class="keyword">typedef </span><span class="identifier">parse_tree_iterator</span><span class="special">&lt;</span><span class="identifier">tree_match</span><span class="special">&lt;&gt; </span><span class="special">&gt; </span><span class="identifier">parse_tree_iterator_t</span><span class="special">;<br><br>    </span><span class="comment">// create a first and last iterator to work off the tree 创建首尾迭代器，以处理该树<br>    </span><span class="identifier">parse_tree_iterator_t </span><span class="identifier">first</span><span class="special">(</span><span class="identifier">i</span><span class="special">.</span><span class="identifier">trees</span><span class="special">, </span><span class="identifier">i</span><span class="special">.</span><span class="identifier">trees</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());<br>    </span><span class="identifier">parse_tree_iterator_t </span><span class="identifier">last</span><span class="special">;<br><br>    </span><span class="comment">// parse the tree 分析该树<br>    </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">parse_tree_iterator_t</span><span class="special">&gt; </span><span class="identifier">tree_parser </span><span class="special">=...<br>    </span><span class="identifier">tree_parser</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">, </span><span class="identifier">last</span><span class="special">);<br></span></code></pre>
<p> <a name="advanced_tree_generation"></a>
</p>
<h2>advanced tree generation 高级树生成</h2>
<a name="node_value"></a>
<h3>node value 节点值</h3>
<p> The <tt>node_val_data</tt> can contain a value. By default it contains a <tt>void_t</tt>, 
  which is an empty class. You can specify the type, using a template parameter, 
  which will then be stored in every node. The type must be default constructible, 
  and assignable. You can get and set the value using<br><tt>node_val_data</tt> 可以包含一个值。缺省情况下，它包含一个空类 <tt>void_t</tt>。你可以用模板参数指定新的类型，该类型将被保存在每个节点中。该类型必须是可缺省构造和可赋值的。要获取或设置该值，你可以用</p>
<pre>    <code><span class="identifier">ValueT </span><span class="identifier">node_val_data</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span></code></pre>
<p> and<br>和</p>
<pre>    <code><span class="keyword">void </span><span class="identifier">node_val_data</span><span class="special">::</span><span class="identifier">value</span><span class="special">(</span><span class="identifier">Value </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">value</span><span class="special">);</span></code></pre>
<p> To specify the value type, you must use a different <a href="trees.html#node_val_data">node_val_data 
  </a>factory than the default. The following example shows how to modify the factory to store and retrieve a double inside each <span class="identifier">node_val_data</span>.<br>要指定这个值类型，你必须使用一个不同与缺省值的 <a href="#node_val_data">node_val_data 
  </a>工厂。以下例子示范了如何修改该工厂以保存并取出每个 <span class="identifier">node_val_data</span> 中的 double 值。
</p><pre>    <span class="keyword">typedef </span><span class="identifier">node_val_data_factory</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="identifier">factory_t</span><span class="special">;<br>    </span><span class="identifier">my_grammar </span><span class="identifier">gram</span><span class="special">;<br>    </span><span class="identifier">my_skip_grammar </span><span class="identifier">skip</span><span class="special">;<br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">iterator_t</span><span class="special">, </span><span class="identifier">factory_t</span><span class="special">&gt; </span><span class="identifier">i </span><span class="special">= <br>        </span><span class="identifier">ast_parse</span><span class="special">&lt;</span><span class="identifier">factory_t</span><span class="special">&gt;(</span><span class="identifier">first</span><span class="special">, </span><span class="identifier">last</span><span class="special">, </span><span class="identifier">gram</span><span class="special">, </span><span class="identifier">skip</span><span class="special">);<br>    // access the double in the root node 访问根节点中的double<br>    </span><span class="keyword">double </span><span class="identifier">d </span><span class="special">= </span><span class="identifier">i</span><span class="special">.</span><span class="identifier">trees</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()-&gt;</span><span class="identifier">value</span><span class="special">;<br></span></pre>
<p></p>
<a name="access_node_d"></a>
<h3>access_node_d</h3>
<p> Now, you may be wondering, "What good does it do to have a value I can 
  store in each node, but not to have any way of setting it?" Well, that's 
  what <tt>access_node_d</tt> is for. <tt>access_node_d</tt> is a directive. It 
  allows you to attach an action to it, like this:<br>现在，你可能会奇怪，“如果我只能保存一个值到每个节点中，而没有方法设置它，有什么好处？”。好的，所以需要 <tt>access_node_d</tt>。<tt>access_node_d</tt> 是一个指示符。它允许你附加一个动作，如：</p>
<pre>    <code><span class="identifier">access_node_d</span><span class="special">[...</span><span class="identifier">some </span><span class="identifier">parsers</span><span class="special">...][</span><span class="identifier">my_action</span><span class="special">()]</span></code></pre>
<p> The attached action will be passed 3 parameters: A reference to the root node
  of the tree generated by the parser, and the current first and last iterators.
  The action can set the value stored in the node.<br>附加的动作有3个参数：由该分析器生成的树的根节点的一个引用、当前的 first 和 last 迭代器。该动作可以设置保存在节点中的值。</p>
<a name="tree_node_factories"></a>
<h3>Tree node factories 树节点工厂</h3>
<p> By setting the factory, you can control what type of nodes are created and 
  how they are created. There are 3 predefined factories: <tt>node_val_data_factory</tt>, 
  <tt>node_all_val_data_factory</tt>, and <tt>node_iter_data_factory</tt>. You 
  can also create your own factory to support your own node types.<br>通过设置工厂，你可以控制创建何种类型的节点以及如何创建它们。有3个预定义的工厂：<tt>node_val_data_factory</tt>, 
  <tt>node_all_val_data_factory</tt>, 和 <tt>node_iter_data_factory</tt>。你也可以创建你自己的工厂以支持你自己的节点类型。</p><p> Using factories with grammars is quite easy, you just need to
specify the factory type as explicit template parameter to the free
ast_parse function:<br>和语法一起使用工厂非常容易，你只需要指定工厂类型为自由函数 ast_parse 显式的模板参数：</p>
<pre>    <span class="keyword">typedef </span><span class="identifier">node_iter_data_factory</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt; </span><span class="identifier">factory_t</span><span class="special">;<br>    </span><span class="identifier">my_grammar </span><span class="identifier">gram</span><span class="special">;<br>    </span><span class="identifier">my_skip_grammar </span><span class="identifier">skip</span><span class="special">;<br>    </span><span class="identifier">tree_parse_info</span><span class="special">&lt;</span><span class="identifier">iterator_t</span><span class="special">, </span><span class="identifier">factory_t</span><span class="special">&gt; </span><span class="identifier">i </span><span class="special">= <br>        </span><span class="identifier">ast_parse</span><span class="special">&lt;</span><span class="identifier">factory_t</span><span class="special">&gt;(</span><span class="identifier">first</span><span class="special">, </span><span class="identifier">last</span><span class="special">, </span><span class="identifier">gram</span><span class="special">, </span><span class="identifier">skip</span><span class="special">);<br></span></pre>
<p> Instead, using the factory directly with rules is slightly harder because the 
  factory is a template parameter to the scanner match policy, so you must use a 
  custom scanner:<br>相反，直接与规则一起使用工厂会稍难一些，因为工厂是扫描器匹配策略的一个模板参数，因此你必须使用定制扫描器：</p>
<pre>    <code><span class="keyword">typedef </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">void_t </span><span class="identifier">value_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">node_val_data_factory</span><span class="special">&lt;</span><span class="identifier">value_t</span><span class="special">&gt; </span><span class="identifier">factory_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">tree_match</span><span class="special">&lt;</span><span class="identifier">iterator_t</span><span class="special">, </span><span class="identifier">factory_t</span><span class="special">&gt; </span><span class="identifier">match_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">ast_match_policy</span><span class="special">&lt;</span><span class="identifier">iterator_t</span><span class="special">, </span><span class="identifier">factory_t</span><span class="special">&gt; </span><span class="identifier">match_policy_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">scanner</span><span class="special">&lt;</span><span class="identifier">iterator_t</span></code><code><span class="special">,</span></code><code><span class="identifier"> scanner_policies</span></code><code><span class="identifier"></span><span class="special">&lt;</span></code><code><span class="identifier">iter_policy_t</span></code><code><span class="special">,</span></code><code><span class="identifier"> match_policy_t</span><span class="special">&gt;</span></code><code><span class="identifier"></span><span class="special"> &gt;</span></code><code><span class="special"> </span><span class="identifier">scanner_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">scanner_t</span><span class="special"></span><span class="identifier"></span><span class="special">&gt; </span><span class="identifier">rule_t</span><span class="special">;<br><br>    </span><span class="identifier">rule_t </span><span class="identifier">r </span><span class="special">=...;<br><br></span></code><code><span class="special">    </span><span class="identifier">scanner_t </span><span class="identifier">scan </span><span class="special">= </span><span class="identifier">scanner_t</span><span class="special"></span><span class="identifier"></span><span class="special">(</span><span class="identifier">first</span><span class="special">, </span><span class="identifier">last</span><span class="special"></span><span class="identifier"></span><span class="special">);<br></span></code><code><span class="special"></span></code><code><span class="special">    </span><span class="identifier">match_t </span><span class="identifier">hit </span><span class="special">= </span><span class="identifier">r</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier"></span><span class="special"></span><span class="identifier"></span><span class="special"></span><span class="identifier">scan</span><span class="special">);</span></code></pre>
<a name="node_val_data_factory"></a>
<h3>node_val_data_factory</h3>
<p> This is the default factory. It creates <tt>node_val_data</tt> nodes. Leaf 
  nodes contain a copy of the matched text, and intermediate nodes don't. <tt>node_val_data_factory</tt> 
  has one template parameter: <tt>ValueT</tt>. <tt>ValueT</tt> specifies the type 
  of value that will be stored in the <tt>node_val_data</tt>.<br>这是缺省的工厂。它创建 <tt>node_val_data</tt> 节点。叶节点包含被匹配文本的拷贝，而中间节点则不包含。<tt>node_val_data_factory</tt> 
  有一个模板参数：<tt>ValueT</tt>. <tt>ValueT</tt> 指定保存在 <tt>node_val_data</tt> 中的值的类型。</p>
<a name="node_val_data_factory"></a>
<h3>node_all_val_data_factory</h3>
<p> This factory also creates <tt>node_val_data</tt>. The difference between it 
  and <tt>node_val_data_factory</tt> is that <b>every</b> node contains all the 
  text that spans it. This means that the root node will contain a copy of the 
  entire parsed input sequence. <tt>node_all_val_data_factory</tt> has one template 
  parameter: <tt>ValueT</tt>. <tt>ValueT</tt> specifies the type of value that 
  will be stored in the <tt>node_val_data</tt>.<br>这个工厂也创建 <tt>node_val_data</tt>。与 <tt>node_val_data_factory</tt> 不同的是，<b>每个</b>节点都包含与之相关的所有文本。这意味着根节点将包含整个被分析的输入序列的拷贝。<tt>node_all_val_data_factory</tt> 有一个模板参数：<tt>ValueT</tt>. <tt>ValueT</tt> 指定保存在 <tt>node_val_data</tt> 中的值的类型。</p>
<a name="node_iter_data_factory"></a>
<h3>node_iter_data_factory</h3>
<p> This factory creates the <tt>parse_tree_iter_node</tt>. This node stores iterators 
  into the input sequence instead of making a copy. It can use a lot less memory. 
  However, the input sequence must stay valid for the life of the tree, and it's 
  not a good idea to use the <tt>multi_pass</tt> iterator with this type of node. 
  All levels of the tree will contain a begin and end iterator. <tt>node_iter_data_factory</tt> 
  has one template parameter: <tt>ValueT</tt>. <tt>ValueT</tt> specifies the type 
  of value that will be stored in the node_val_data.<br>这个工厂创建 <tt>parse_tree_iter_node</tt>。这个节点保存输入序列的迭代器而不是拷贝。它可以占用更少的内存。但是，输入序列必须在树的整个生命周期中保存可用，而且将 <tt>multi_pass</tt> 迭代器与这种节点类型一起使用也不是好的主意。树的所有层级都将包含一个 begin 和 end 迭代器。 <tt>node_iter_data_factory</tt> 
  有一个模板参数：<tt>ValueT</tt>. <tt>ValueT</tt> 指定保存在 <tt>node_val_data</tt> 中的值的类型。</p>
<a name="custom"></a>
<h3>custom 定制</h3>
<p> You can create your own factory. It should look like this:<br>你可以创建自己的工厂。它应该看起来如下：</p>
<pre>    <code><span class="keyword">class </span><span class="identifier">my_factory<br>    </span><span class="special">{<br>    </span><span class="keyword">public</span><span class="special">:<br><br>        </span><span class="comment">// This inner class is so that the factory can simulate 内层类令工厂可以模仿<br>        // a template template parameter                        一个模板模板参数<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">&gt;<br>        </span><span class="keyword">class </span><span class="identifier">factory<br>        </span><span class="special">{<br>        </span><span class="keyword">public</span><span class="special">:<br><br>            </span><span class="comment">// This is your node type 这是你的节点类型<br>            </span><span class="keyword">typedef </span><span class="identifier">my_node_type </span><span class="identifier">node_t</span><span class="special">;<br><br>            </span><span class="keyword">static </span><span class="identifier">node_t </span><span class="identifier">create_node</span><span class="special">(<br>                </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">first</span><span class="special">, </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">last</span><span class="special">, </span><span class="keyword">bool </span><span class="identifier">is_leaf_node</span><span class="special">)<br>            </span><span class="special">{<br>                </span><span class="comment">// create a node and return it. 创建一个节点并返回它。<br>            </span><span class="special">}<br><br>            </span><span class="comment">// This function is used by the reduced_node directive.<br>            // If you don't use it, then you can leave this function<br>            // unimplemented. 这个函数由reduced_node指示符使用。如果你不用它，<br>            // 那么你可以不实现该函数。<br><br>            </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ContainerT</span><span class="special">&gt;<br>            </span><span class="keyword">static </span><span class="identifier">node_t </span><span class="identifier">group_nodes</span><span class="special">(</span><span class="identifier">ContainerT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">nodes</span><span class="special">)<br>            </span><span class="special">{<br>                </span><span class="comment">// Group all the nodes into one and return it. 将所有节点组成一群并返回它。<br>            </span><span class="special">}<br>        </span><span class="special">};<br>    </span><span class="special">};<br><br><br>    </span><span class="comment">// Typedefs to use my_factory<br>    </span><span class="keyword">typedef </span><span class="identifier">my_factory </span><span class="identifier">factory_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">tree_match</span><span class="special">&lt;</span><span class="identifier">iterator_t</span><span class="special">, </span><span class="identifier">factory_t</span><span class="special">&gt; </span><span class="identifier">match_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">tree_match_policy</span><span class="special">&lt;</span><span class="identifier">iterator_t</span><span class="special">, </span><span class="identifier">factory_t</span><span class="special">&gt; </span><span class="identifier">match_policy_t</span><span class="special">;<br></span></code><code><span class="special"><br>    </span><span class="comment">// Typedefs if you are using rules instead of grammars 如果你用规则替代语法<br></span></code><code><span class="special">    </span><span class="keyword">typedef </span><span class="identifier">scanner</span><span class="special">&lt;</span><span class="identifier">iterator_t</span></code><code><span class="special">,</span></code><code><span class="identifier"> scanner_policies</span></code><code><span class="identifier"></span><span class="special">&lt;</span></code><code><span class="identifier">iter_policy_t</span></code><code><span class="special">,</span></code><code><span class="identifier"> match_policy_t</span><span class="special">&gt;</span></code><code><span class="identifier"></span><span class="special"> &gt;</span></code><code><span class="special"> </span><span class="identifier">scanner_t</span><span class="special">;<br>    </span><span class="keyword">typedef </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">scanner_t</span><span class="special"></span><span class="identifier"></span><span class="special">&gt; </span><span class="identifier">rule_t</span><span class="special">;<br></span></code><code><span class="special"></span><span class="special"><br></span></code></pre><table border="0"><tbody><tr><td width="10"><br>
</td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="symbols.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="multi_pass.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<hr size="1">
<p class="copyright">Copyright © 2001-2002 Daniel C. Nuffer<br>Revised 2007 Copyright © Tobias Schwinger<br>
  <br>
  <font size="2">Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)</font></p>
<p class="copyright">&nbsp;</p>
<br>
</body></html>
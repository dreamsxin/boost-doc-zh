<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<title>List Parsers</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="theme/style.css" rel="stylesheet" type="text/css"></head>

<body>
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr> 
    <td width="10"> <font face="Verdana, Arial, Helvetica, sans-serif" size="6"><b>&nbsp;</b></font></td>
    <td width="85%"> <font face="Verdana, Arial, Helvetica, sans-serif" size="6"><b>List Parsers 列表分析器</b></font></td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0" height="48" width="112"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="confix.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="functor_parser.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<p>List Parsers are generated by the special predefined parser generator object 
  <tt>list_p</tt>, which generates parsers recognizing list structures 
  of the type<br>列表分析器生成自特殊的预定义分析器生成器对象 
  <tt>list_p</tt><span style="font-family: Courier New;">，所生成的分析器识别如下类型的列表</span> </p>
<pre><span class="identifier">    item </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="identifier">delimiter </span><span class="special">&gt;&gt; </span><span class="identifier">item</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="special">!</span><span class="identifier">end</span></pre>
<p>where <tt>item</tt> is an expression, delimiter is a delimiter and end is an 
  optional closing expression. As you can see, the <tt>list_p</tt> generated parser 
  does not recognize empty lists, i.e. the parser must find at least one item 
  in the input stream to return a successful match. If you wish to also match 
  an empty list, you can make your list_p optional with operator! An example where 
  this utility parser is helpful is parsing comma separated C/C++ strings, which 
  can be easily formulated as:<br>这里 <tt>item</tt> 是一个表达式，delimiter 是一个分隔符而 end 是一个可选的结尾表达式。正如你所见，<tt>list_p</tt>
所
生成的分析器并不识别空列表，比如，只有在输入中匹配了至少一项，分析器才会返回成功匹配。如果希望能同时识别空列表，可以为 list_p
加上!（可选）操作符。下面的例子是这一工具分析器对分析逗号分隔的C/C++字符串助益良多的例子，可以很轻易的列出这个表达式：</p>
<pre><span class="special">    </span><span class="identifier">rule</span><span class="special">&lt;&gt; </span><span class="identifier">list_of_c_strings_rule<br>        </span><span class="special">=   </span><span class="identifier">list_p</span><span class="special">(</span><span class="identifier">confix_p</span><span class="special">(</span><span class="literal">'\"'</span><span class="special">, </span><span class="special">*</span><span class="identifier">c_escape_char_p</span><span class="special">, </span><span class="literal">'\"'</span><span class="special">), </span><span class="literal">','</span><span class="special">)<br>        </span><span class="special">;</span></pre>
<p>The <tt>confix_p</tt> and <tt>c_escape_char_p</tt> parser generators 
  are described <a href="confix.html">here</a> and <a href="escape_char_parser.html">here</a>.<br><tt>confix_p</tt>&nbsp;和 <tt>c_escape_char_p</tt> 分析器可以在&nbsp; <a href="confix.html">这里</a> and <a href="escape_char_parser.html">这里</a> 查阅。</p>
<p>The <tt>list_p</tt> parser generator object can be used to generate the following 
  different types of List Parsers:<br><tt>list_p</tt><span style="font-family: Courier New;">&nbsp;</span>分析器生成器对象可用于生成下列类型的列表分析器：</p>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td colspan="2" class="table_title"><b>List Parsers 列表分析器</b></td>
  </tr>
  <tr> 
    <td class="table_cells" height="27" width="29%"><b>list_p</b></td>
    <td class="table_cells" width="71%"><p><tt>list_p</tt> used by itself parses 
        comma separated lists without special item formatting, i.e. everything 
        in between two commas is matched as an <tt>item</tt>, no <tt>end</tt> 
        of list token is matched</p><p><tt>list_p</tt><span style="font-family: Courier New;">&nbsp;</span>这一形式用于识别没有特殊格式的列表项的逗号分隔列表，比如，两个逗号之间的所有东西都被匹配为一个 <tt>item</tt>，而列表标记的 <tt>end</tt>&nbsp;则不会匹配</p></td>
  </tr>
  <tr> 
    <td class="table_cells" height="27"><strong>list_p(delimiter)</strong></td>
    <td class="table_cells"><p>generates a list parser, which recognizes lists 
        with the given <tt>delimiter</tt> and matches everything in between them 
        as an <tt>item</tt>, no <tt>end</tt> of list token is matched</p><p>生成一个列表分析器，它识别以给定的 <tt>delimiter</tt>&nbsp;作为分隔符的列表，且把两个分隔符之间的任意内容识别为一个 <tt>item</tt>，而列表标记的 <tt>end</tt>&nbsp;则不会匹配</p></td>
  </tr>
  <tr> 
    <td class="table_cells" height="27"><strong>list_p(item, delimiter)</strong></td>
    <td class="table_cells"><p>generates a list parser, which recognizes lists 
        with the given <tt>delimiter</tt> and matches items based on the given 
        item parser, no <tt>end</tt> of list token is matched</p><p>生成一个列表分析器，它识别拥有给定的 <tt>delimiter</tt>&nbsp;作为分隔符，且把给定的item分析器的匹配作为列表项，而列表标记的 <tt>end</tt>&nbsp;则不会匹配。</p></td>
  </tr>
  <tr>
    <td class="table_cells" height="27"><strong>list_p(item, delimiter, end)</strong></td>
    <td class="table_cells"><p>generates a list parser, which recognizes lists 
        with the given <tt>delimiter</tt> and matches items based on the given 
        <tt>item</tt> parser and additionally recognizes an optional <tt>end</tt> 
        expression</p><p>生成一个列表分析器，它识别拥有给定的 <tt>delimiter</tt>&nbsp;作为分隔符，且把给定的 <tt>item</tt>&nbsp;分析器的匹配作为列表项，最后，它还以一个可选的 <tt>end</tt>&nbsp;表达式作为列表的结尾</p></td>
  </tr>
</tbody></table>
<p>All of the parameters to list_p can be single characters, strings 
  or, if more complex parsing logic is required, auxiliary parsers, each of which 
  is automatically converted to the corresponding parser type needed for successful 
  parsing.<br>list_p 的所有参数可以是单独的字符、字符串、或者，如果需要更复杂的分析逻辑的话，任意的分析器，这些东西都被自动的转化为成功分析所需要的分析器的类型。</p>
<p>If the <tt>item</tt> parser is an <tt>action_parser_category</tt> type (parser 
  with an attached semantic action) we have to do something special. This happens, 
  if the user wrote something like:<br>如果 <tt>item</tt>&nbsp;分析器属于 <tt>action_parser_category</tt>&nbsp;类型（挂接语义动作的分析器），则需要特殊处理。这发生在用户写出类似如下的代码：</p>
<pre><span class="special">    </span><span class="identifier">list_p</span><span class="special">(</span><span class="identifier">item</span><span class="special">[</span><span class="identifier">func</span><span class="special">], </span><span class="identifier">delim</span><span class="special">)</span></pre>
<p> where <tt>item</tt> is the parser matching one item of the list sequence and 
  <tt>func</tt> is a functor to be called after matching one item. If we would 
  do nothing, the resulting code would parse the sequence as follows:<br>这里 <tt>item</tt>&nbsp;列表项分析器而 <tt>func</tt>&nbsp;是在匹配列表项之后被调用的仿函数。如果我们什么都不做，所产生的代码就会以如下的方式进行分析：</p>
<pre><span class="special">    </span><span class="special">(</span><span class="identifier">item</span><span class="special">[</span><span class="identifier">func</span><span class="special">] </span><span class="special">- </span><span class="identifier">delim</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="identifier">delim </span><span class="special">&gt;&gt; </span><span class="special">(</span><span class="identifier">item</span><span class="special">[</span><span class="identifier">func</span><span class="special">] </span><span class="special">- </span><span class="identifier">delim</span><span class="special">))</span></pre>
<p> what in most cases is not what the user expects. (If this <u>is</u> what you've 
  expected, then please use one of the <tt>list_p</tt> generator 
  functions <tt>direct()</tt>, which will inhibit refactoring of the <tt>item</tt> 
  parser). To make the list parser behave as expected:<br>大多数情况下这并未所期望的。（如果这的确是你想要的，那么请用 <tt>list_p</tt>&nbsp;生成器函数 <tt>direct()</tt>,它会集成 <tt>item</tt>&nbsp;分析器的重构后的产物）。要使列表分析器的行为如你所愿：</p>
<pre><span class="special">    </span><span class="special">(</span><span class="identifier">item </span><span class="special">- </span><span class="identifier">delim</span><span class="special">)[</span><span class="identifier">func</span><span class="special">] </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="identifier">delim </span><span class="special">&gt;&gt; </span><span class="special">(</span><span class="identifier">item </span><span class="special">- </span><span class="identifier">delim</span><span class="special">)[</span><span class="identifier">func</span><span class="special">])</span></pre>
<p> the actor attached to the item parser has to be re-attached to the <tt>(item 
  - delim)</tt> parser construct, which will make the resulting list parser 'do 
  the right thing'. This refactoring is done by the help of the <a href="refactoring.html">Refactoring 
  Parsers</a>. Additionally special care must be taken, if the item parser is 
  a <tt>unary_parser_category</tt> type parser as for instance:<br>挂接到 item 分析器上的动作器必须重新挂接到 <tt>(item 
  - delim)</tt>&nbsp;分析器结构上，才能使得所产生的分析器"行为正确"。这一重构在<a href="refactoring.html">重构分析器</a>的帮助下完成。需要额外注意的是，如果列表项分析器是一个 <tt>unary_parser_category</tt>&nbsp;<span style="font-family: Courier New;">类型的分析器，就像下面的：</span></p>
<pre><span class="special">    </span><span class="identifier">list_p</span><span class="special">(*</span><span class="identifier">anychar_p</span><span class="special">, </span><span class="literal">','</span><span class="special">)</span></pre>
<p> which without any refactoring would result in<br>这如果不重构就变成 </p>
<pre><span class="special">        </span><span class="special">(*</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">))<br>    </span><span class="special">&gt;&gt; </span><span class="special">*( </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="special">(*</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">)) </span><span class="special">)</span></pre>
<p> and will not give the expected result (the first <tt>*anychar_p</tt> will 
  eat up all the input up to the end of the input stream). So we have to refactor 
  this into:<br>而这将不会得到所期望的结果（第一个 <tt>*anychar_p</tt> <span style="font-family: Courier New;">将把输入流里的直到末尾的输入全部吃掉</span>）。所以我们需要把它重构为：</p>
<pre><span class="special">       </span><span class="special">*(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">))<br>    </span><span class="special">&gt;&gt; </span><span class="special">*( </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">)) </span><span class="special">)</span></pre>
<p> what will give the correct result.<br>这将得到正确的结果</p>
<p> The case, where the item parser is a combination of the two mentioned problems 
  (i.e. the item parser is a unary parser with an attached action), is handled 
  accordingly too:<br>列表分析器混合了上面提到的两个问题的情况（比如列表分析器是一个带着语义动作的一元分析器），也将以一致的方式被处理：</p>
<pre><span class="special">    </span><span class="identifier">list_p</span><span class="special">((*</span><span class="identifier">anychar_p</span><span class="special">)[</span><span class="identifier">func</span><span class="special">], </span><span class="literal">','</span><span class="special">)</span></pre>
<p> will be parsed as expected:<br>将会被如所期望的那样变为：</p>
<pre><span class="special">        </span><span class="special">(*(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">)))[</span><span class="identifier">func</span><span class="special">]<br>    </span><span class="special">&gt;&gt; </span><span class="special">*( </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="special">(*(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">)))[</span><span class="identifier">func</span><span class="special">] </span><span class="special">)</span></pre>
<p>The required refactoring is implemented with the help of the <a href="refactoring.html">Refactoring 
  Parsers</a>.<br>所需要的重构都是借由<a href="refactoring.html">重构分析器</a>的帮助来实现的。</p>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td colspan="2" class="table_title"><b>Summary of List Parser refactorings 列表分析器重构概览</b></td>
  </tr>
  <tr class="table_title"> 
    <td width="34%"><b>You write it as: 源代码：</b></td>
    <td width="66%"><code><font face="Verdana, Arial, Helvetica, sans-serif">It 
      is refactored to: 重构为：</font></code></td>
  </tr>
  <tr> 
    <td class="table_cells" width="34%"><code><span class="identifier">list_p</span><span class="special">(</span><span class="identifier">item</span><span class="special">, 
      </span><span class="identifier">delimiter</span><span class="special">)</span></code></td>
    <td class="table_cells" width="66%"> <code><span class="special"> (</span><span class="identifier">item 
      </span><span class="special">- </span><span class="identifier">delimiter</span><span class="special">) 
      <br>
      &gt;&gt; *(</span><span class="identifier">delimiter </span><span class="special"> 
      &gt;&gt; (</span><span class="identifier">item </span><span class="special">- 
      </span><span class="identifier">delimiter</span><span class="special">))</span></code></td>
  </tr>
  <tr> 
    <td class="table_cells" width="34%"><code><span class="identifier">list_p</span><span class="special">(</span><span class="identifier">item</span><span class="special">[</span><span class="identifier">func</span><span class="special">], 
      </span><span class="identifier">delimiter</span><span class="special">)</span></code></td>
    <td class="table_cells" width="66%"> <code><span class="special"> (</span><span class="identifier">item 
      </span><span class="special"> - </span><span class="identifier">delimiter</span><span class="special">)[</span><span class="identifier">func</span><span class="special">] 
      <br>
      &gt;&gt; *(</span><span class="identifier">delimiter </span><span class="special">&gt;&gt; 
      (</span><span class="identifier">item </span><span class="special">- </span><span class="identifier">delimiter</span><span class="special">)[</span><span class="identifier">func</span><span class="special">])</span></code></td>
  </tr>
  <tr> 
    <td class="table_cells" width="34%"><code><span class="identifier">list_p</span><span class="special">(*</span><span class="identifier">item</span><span class="special">, 
      </span><span class="identifier">delimiter</span><span class="special">)</span></code></td>
    <td class="table_cells" width="66%"> <code><span class="special">*(</span><span class="identifier">item 
      </span><span class="special">- </span><span class="identifier">delimiter</span><span class="special">) 
      <br>
      &gt;&gt; *(</span><span class="identifier">delimiter </span><span class="special">&gt;&gt; 
      *(</span><span class="identifier">item </span><span class="special">- </span><span class="identifier">delimiter</span><span class="special">))</span></code></td>
  </tr>
  <tr> 
    <td class="table_cells" width="34%"><code><span class="identifier">list_p</span><span class="special">((*</span><span class="identifier">item</span><span class="special">)[</span><span class="identifier">func</span><span class="special">], 
      </span><span class="identifier">delimiter</span><span class="special">)</span></code></td>
    <td class="table_cells" width="66%"> <code><span class="special">(*(</span><span class="identifier">item 
      </span><span class="special">- </span><span class="identifier">delimiter</span><span class="special">))[</span><span class="identifier">func</span><span class="special">] 
      <br>
      &gt;&gt; *(</span><span class="identifier">delimiter </span><span class="special">&gt;&gt; 
      (*(</span><span class="identifier">item </span><span class="special">- </span><span class="identifier">delimiter</span><span class="special">))[</span><span class="identifier">func</span><span class="special">])</span></code></td>
  </tr>
</tbody></table>
<p> <img src="theme/lens.gif" height="16" width="15"> <a href="../example/fundamental/list_parser.cpp">list_parser.cpp </a> sample shows the usage of the list_p utility parser:<br><img src="theme/lens.gif" height="16" width="15"> <a href="../example/fundamental/list_parser.cpp">list_parser.cpp&nbsp;</a>里的例子展示了list_p工具分析器的使用方法：</p>
<ol>
  <li>parsing a simple ',' delimited list w/o item formatting<br>分析一个简单的","分隔列表，带/不带列表项格式化</li>
  <li> parsing a CSV list (comma separated values - strings, integers or reals)<br>分析一个CVS列表（逗号分隔值表--字符串、整数或者实数）</li>
  <li>parsing
a token list (token separated values - strings, integers or reals) with
an action parser directly attached to the item part of the list_p
generated parser<br>分析一个标记表（标记分隔列表--字符串、整数或者实数）并且把一个动作分析器直接挂接到 list_p 所生成的分析器的列表项部分上</li>
</ol>
<p>This is part of the Spirit distribution.<br>这是Spirit发布包的组成部分。</p>
<table border="0">
  <tbody><tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="confix.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="functor_parser.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<br>
<hr size="1">
<p class="copyright">Copyright © 2001-2003 Hartmut Kaiser<br>
  <br>
  <font size="2">Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt) </font> </p>
</body></html>
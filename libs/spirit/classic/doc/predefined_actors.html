<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->


<title>predefined_actors</title><link rel="stylesheet" href="theme/style.css" type="text/css"></head>
<body>
<table background="theme/bkd2.gif" border="0" cellspacing="2" height="48" width="100%">
  <tbody><tr>
    <td width="10">
    </td>
    <td width="85%"> <font face="Verdana, Arial, Helvetica, sans-serif" size="6"><b>Predefined 
      Actors 预定义动作器</b></font></td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="indepth_the_parser_context.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="20"><a href="parametric_parsers.html"><img src="theme/r_arr.gif" border="0" height="19" width="20"></a></td>
  </tr>
</tbody></table>
<h2>Actors 动作器</h2><p>
The framework has a number of predefined semantic action functors.
Experience shows that these functors are so often used that they were included 
as part of the core framework to spare the user from having to reinvent the 
same functionality over and over again.<br>本框架包含了一系列预定义的语义动作仿函数。经验表明这些仿函数的使用是如此频繁，因此在库中包含这些仿函数可以把用户从反复实现相同的功能中解放出来。</p>
<h2>Quick example: <tt>assign_a</tt> actor 快速例子：<tt>assign_a</tt> 动作器</h2>
<code>
</code><pre>    <span class="keyword">int </span><span class="identifier">i</span><span class="special">,</span><span class="identifier"> j</span><span class="special">;<br>    </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string </span><span class="identifier">s</span><span class="special">;<br>    </span><span class="identifier">r </span><span class="special">= </span><span class="identifier">int_p</span><span class="special">[</span><span class="identifier">assign_a</span><span class="special">(</span><span class="identifier">i</span><span class="special">)] &gt;&gt; (+</span><span class="identifier">alpha_p</span><span class="special">)[</span><span class="identifier">assign_a</span><span class="special">(</span><span class="identifier">s</span><span class="special">)] &gt;&gt; </span><span class="identifier">int_p</span><span class="special">[</span><span class="identifier">assign_a</span><span class="special">(</span><span class="identifier">j</span><span class="special">,</span><span class="identifier">i</span><span class="special">)];</span></pre>

<p>
Given an input <tt>123456 Hello 789</tt>,<br>给定一个输入 <tt>123456 Hello 789</tt>, </p>
<ol><li><tt>assign_a(i)</tt> will extract the number <tt>123456</tt> and assign it to <tt>i</tt>,<br><tt>assign_a(i)</tt> 将取出数字 <tt>123456</tt> 并将其赋值给 <tt>i</tt>, </li><li><tt>assign_a(s)</tt> will extract the string <tt>"Hello"</tt> and assign it to <tt>s</tt>,<br><tt>assign_a(s)</tt> 将取出字符串 <tt>"Hello"</tt> 并将其赋值给 <tt>s</tt>,</li><li><tt>assign_a(j,i)</tt> will assign i to j, j=i, without using the parse result.<br><tt>assign_a(j,i)</tt> 将 i 赋值给 j, j=i, 不使用分析的结果。</li></ol>
<p> Technically, the expression <tt>assign_a(v)</tt> is a template function that 
  generates a semantic action. In fact, actor instances are not created directly 
  since they usually involve a number of template parameters. Instead generator 
  functions ("helper functions") are provided to generate actors from 
  their arguments. All helper functions have the "_a" suffix. For example, 
  <tt>append_actor</tt> is created using the <tt>append_a</tt> function.<br>技术上，表达式 <tt>assign_a(v)</tt> 是一个生成语义动作的模板函数。事实上，动作器实例都不是直接创建的，因为它们通常需要多个模板参数。取而代之的是一些生成器函数("辅助函数")，用于从它们的参数生成动作器。所有辅助函数都带有"_a"后缀。例如，<tt>append_actor</tt> 就是用 <tt>append_a</tt> 函数生成的。 </p>
<p>
The semantic action generated is polymorphic and should work with any 
type as long as it is compatible with the arguments received from the parser. 
It might not be obvious, but a string can accept the iterator first and last 
arguments that are passed into a generic semantic action (see above). In fact, 
any STL container that has an <tt>assign(first, last)</tt> member function can be 
used.<br>所生成的语意动作是多态的，并且应能够处理任何兼容于传递自分析器的参数类型的类型。这可能很绕口，但比如一个 string 可以接受一个传入所产生的语义动作的 first, last 迭代器对（见上）。实际上，任何有 <tt>assign(first, last)</tt> 成员函数的标准库容器都可以使用。<tt></tt></p>
<h2>Actors summary 动作器概要</h2><p>
Below are tables summarizing the "built-in" actors with the 
conventions given below.<br>后面的表格概括了符合下述约定的“内建”动作器。</p>
<ul>
  <li><tt>ref</tt> is a <b>reference</b> to an object stored in a policy holder 
    actor<br><tt>ref</tt>&nbsp;是一个对对象的<span style="font-weight: bold;">引用</span>，储存于策略持有者动作器</li>
  <li><tt>value_ref</tt> and <tt>key_ref</tt> are <b>const reference</b>s stored 
    in a policy holder actor<br><tt>value_ref</tt> 和 <tt>key_ref</tt> 是<b>常量引用</b>，储存于策略持有者动作器</li>
  <li><tt>value</tt> is the <b>parse result</b>. This could be the result for 
    the single argument () operator or the two argument () operator<br><tt>value</tt> 是<b>分析结果</b>。这可以是适用于单参数或双参数的()操作符</li>
  <li><tt>vt</tt> stands for the <tt>value_type</tt> type: <tt>type&amp; ref; 
    // vt is type::value_type</tt>.<br><tt>vt</tt> 即 <tt>value_type</tt> 类型：<tt>type&amp; ref; 
    // vt is type::value_type</tt>.</li>
</ul>
<p> Note that examples are provided after the tables.<br>留意表格后面的例子。</p>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td class="table_title" colspan="8"> Unary operator actors 单参动作器</td>
  </tr>
    <tr><td class="table_cells" width="30%">++ref</td>  <td class="table_cells" width="70%"><b>increment_a</b>(ref)</td>
  </tr>
    <tr><td class="table_cells">--ref</td>  <td class="table_cells"><b>decrement_a</b>(ref)</td>
  </tr>
</tbody></table>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td class="table_title" colspan="26"> Assign actors 赋值动作器</td>
  </tr>
  <tr>
    <td class="table_cells">ref = value</td>
    <td class="table_cells"><b>assign_a</b>(ref)</td>
  </tr>
    <tr><td class="table_cells" width="30%">ref = value_ref</td>
    <td class="table_cells" width="70%"><b>assign_a</b>(ref, value_ref)</td>
  </tr>
</tbody></table>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td class="table_title" colspan="30"> Container actors 容器动作器 </td>
  </tr>
  <tr> 
    <td class="table_cells" width="30%">ref.push_back(value)</td>
    <td class="table_cells" width="70%"><b>push_back_a</b>(ref)</td>
  </tr>
  <tr><td class="table_cells">ref.push_back(value_ref)</td>
  <td class="table_cells"><b>push_back_a</b>(ref, value_ref)</td>
  </tr>
  <tr><td class="table_cells">ref.push_front(value)</td>
  <td class="table_cells"><b>push_front_a</b>(ref)</td>
  </tr>
  <tr><td class="table_cells">ref.push_front(value_ref)</td>
  <td class="table_cells"><b>push_front_a</b>(ref, value_ref)</td>
  </tr>
  <tr><td class="table_cells">ref.clear()</td>
  <td class="table_cells"><b>clear_a</b>(ref)</td>
  </tr>
</tbody></table>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td class="table_title" colspan="14"> Associative container actors 关联容器动作器 </td>
  </tr>
    <tr><td class="table_cells" width="30%">ref.insert(vt(value, value_ref))</td>  <td class="table_cells" width="70%"><b>insert_key_a</b>(ref, value_ref)</td>
  </tr>  <tr>
      <td class="table_cells"> ref.insert(vt(key_ref,value_ref)) </td>
      <td class="table_cells"> <strong>insert_at_a</strong>(ref, key_ref_, value_ref)</td>
    </tr>
    <tr>
      <td class="table_cells"> ref.insert(vt(key_ref,value)) </td>
      <td class="table_cells"> <strong>insert_at_a</strong>(ref, key_ref) </td>
    </tr>
    <tr><td class="table_cells">ref[value] = value_ref</td>
    <td class="table_cells"><b>assign_key_a</b>(ref, value_ref)</td>
  </tr>
  <tr><td class="table_cells">ref.erase(ref,value)</td>
  <td class="table_cells"><b>erase_a</b>(ref)</td>
  </tr>
  <tr><td class="table_cells">ref.erase(ref,key_ref)</td>
    <td class="table_cells"><b>erase_a</b>(ref, key_ref)</td>
  </tr>
</tbody></table>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td class="table_title" colspan="8"> Miscellanous actors 杂项动作器 </td>
  </tr>
  <tr> 
    <td class="table_cells" width="30%">swaps aref and bref<br>交换&nbsp;aref 和 bref</td>
    <td class="table_cells" width="70%"><strong>swap_a</strong>(aref, bref)</td>
  </tr>
</tbody></table>
<h3>Include Files 包含文件</h3>
<p>The header files for the predefined actors are located in <tt>boost/spirit/actor</tt>. 
  The file <tt>actors.hpp</tt> contains all the includes for all the actors. You 
  may include just the specific header files that you need. The list below enumerates 
  the header files.<br>预定义动作器的头文件位于<tt>boost/spirit/actor。</tt>文件&nbsp;<tt>actors.hpp</tt> 包含了所有动作器的头文件。你也可以仅仅包含你所需要的特定头文件。下面列出这些头文件。</p>
<pre>    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">assign_actor</span><span class="special">.</span>hpp<span class="special">&gt;<br></span>    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>assign_key_actor<span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">clear_actor</span><span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">decrement_actor</span><span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">erase_actor</span><span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span> <br>    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">increment_actor</span><span class="special">.</span>hpp<span class="special">&gt;<br></span>    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">insert_key_actor</span><span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>insert_at_actor.hpp<span class="special">&gt;</span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">push_back_actor</span><span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">push_front_actor</span><span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span><span class="identifier">swap_actor</span><span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span></pre>
<h3>Examples 例子</h3>
<h4>Increment a value 递增某个值</h4>
<p>
Suppose that your input string is<br>假设你的输入串为 </p>
<code>
</code><pre>    1,2,-3,4,...<br></pre>
<p>
and we want to count the number of ints. The actor <tt>increment_a</tt> applies <tt>++</tt> to its reference:<br>而你想统计整数的个数。动作器 <tt>increment_a</tt> 对其引用的对象使用 <tt>++:</tt></p>
<code>
</code><pre>    <span class="keyword">int </span><span class="identifier">count </span><span class="special">= </span><span class="number">0</span><span class="special">;    <br>    </span><span class="identifier">rule</span><span class="special">&lt;&gt; </span><span class="identifier">r </span><span class="special">= </span><span class="identifier">list_p</span><span class="special">.</span><span class="identifier">direct</span><span class="special">(</span><span class="identifier">int_p</span><span class="special">[</span><span class="identifier">increment_a</span><span class="special">(</span><span class="identifier">count</span><span class="special">)], </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">));</span></pre>
 
<h4>Append values to a vector (or other container) 将某些值添加到vector(或其它容器)</h4>
<p> Here, you want to fill a <tt>vector&lt;int&gt;</tt> with the numbers. The 
  actor <tt>push_back_a</tt> can be used to insert the integers at the back of 
  the vector:<br>这里，你想向一个 <tt>vector&lt;int&gt;</tt>&nbsp;填充数值。那么动作器 <tt>push_back_a</tt> 可以用来向&nbsp;<tt>vector</tt> 的后端插入整数：</p>
<code>
</code><pre>    <span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt; </span><span class="identifier">v</span><span class="special">;<br>    </span><span class="identifier">rule</span><span class="special">&lt;&gt; </span><span class="identifier">r </span><span class="special">= </span><span class="identifier">list_p</span><span class="special">.</span><span class="identifier">direct</span><span class="special">(</span><span class="identifier">int_p</span><span class="special">[</span><span class="identifier">push_back_a</span><span class="special">(</span><span class="identifier">v</span><span class="special">)], </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">','</span><span class="special">));</span></pre>

<h4>insert key-value pairs into a map 将键-值对插入到一个map</h4><p>
Suppose that your input string is<br>假设你输入的字符串为 </p>
<code> 
</code><pre>    (1,2) (3,4) ... <br></pre>

<p> and you want to parse the pair into a <tt>map&lt;int,int&gt;</tt>. <tt>assign_a</tt> 
  can be used to store key and values in a temporary key variable, while <tt>insert_a</tt> 
  is used to insert it into the map:<br>且你想分析这些数值并成对插入一个 <tt>map&lt;int,int&gt;</tt>。这里 <tt>assign_a</tt> 可以用来将键-值对保存在一个临时变量中，同时&nbsp;<tt>insert_a</tt> 可以用来把它插入到 map：<tt></tt></p>
<pre>    <code><span class="identifier">map</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">, </span><span class="keyword">int</span><span class="special">&gt;::</span>value_type<span class="keyword"> </span>k<span class="special">;<br>    </span><span class="identifier">map</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">, </span><span class="keyword">int</span><span class="special">&gt; </span><span class="identifier">m</span><span class="special">;<br>    <br>    </span><span class="identifier">rule</span><span class="special">&lt;&gt; </span><span class="identifier">pair </span><span class="special">= </span><span class="identifier">
        confix_p</span><span class="special">(<br>            </span><span class="literal">'('</span><span class="special">
          , </span><span class="identifier">int_p</span><span class="special">[</span><span class="identifier">assign_a</span><span class="special">(</span>k.first<span class="special">)] &gt;&gt; </span><span class="literal">','</span><span class="special"> &gt;&gt; </span><span class="identifier">int_p</span><span class="special">[</span><span class="identifier">assign_a</span><span class="special">(</span>k.second<span class="special">)]<br>          ,</span><span class="literal"> ')'<br>        </span><span class="special">)<br>        [</span><span class="identifier">insert_at_a</span><span class="special">(</span><span class="identifier">m</span><span class="special">, </span><span class="identifier">k</span><span class="identifier"></span><span class="special">)]<br>        ;</span></code></pre> 
<h2>Policy holder actors and policy actions 策略持有者动作器和策略动作</h2>
<p> The action takes place through a call to the <tt>()</tt> operator: single 
  argument <tt>()</tt> operator call for character parsers and two argument (first, 
  last) call for phrase parsers. Actors should implement at least one of the two 
  <tt>()</tt> operator.<br>语意动作通过对<tt>()</tt>操作符的调用被激活：单参数的<tt>()</tt>操作符适用于字符分析器而双参数(first,last)的适用于句子分析器。</p>
<p>
A lot of actors need to store reference to one or more objects. For 
example, actions on container need to store a reference to the container.<br>很多动作器需要储存一个或者更多的对象引用。比如，作用于容器的动作需要储存这个容器的引用。</p>
<p> Therefore, this kind of actor have been broken down into <strong>a)</strong> 
  an action policy that does the action (act member function), <strong>b)</strong> 
  policy holder actor that stores the references and feeds the act member function.<br>因此，这类动作器被分割成<strong>a)</strong>一个实际执行动作(act成员函数)的动作策略，<strong>b)</strong>持有传递给act成员函数的对象引用的策略持有者动作器。</p>
<h3>Policy holder actors 策略持有者动作器</h3>
<p> The available policy holders are enumerated below.<br>可用的策略持有者动作器列于下表：</p>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td class="table_title" colspan="24"> Policy holders 策略持有者 </td>
  </tr>
  <tr>
    <td class="table_cells">Name 名字</td>
    <td class="table_cells">Stored variables 保存的变量</td>
    <td class="table_cells">Act signature &nbsp;Act函数签名</td>
  </tr>
  <tr><td class="table_cells">ref_actor</td>
  <td class="table_cells">1 reference</td>
  <td class="table_cells"><tt>act(ref)</tt></td>
  </tr>
  <tr><td class="table_cells">ref_value_actor</td>
  <td class="table_cells">1 ref</td>
    <td class="table_cells"> <tt>act(ref, value)</tt> or <tt>act(ref, first, last)</tt></td>
  </tr>
    <tr><td class="table_cells">ref_const_ref_actor</td>
  <td class="table_cells">1 ref and 1 const ref</td>
  <td class="table_cells"><tt>act(ref, const_ref)</tt></td>
  </tr>
    <tr><td class="table_cells">ref_const_ref_value_actor</td>
  <td class="table_cells">1 ref</td>
    <td class="table_cells"><tt>act(ref, value)</tt> or <tt>act(ref, first, last)</tt></td>
  </tr>
    <tr><td class="table_cells">ref_const_ref_const_ref_actor</td>
  <td class="table_cells">1 ref, 2 const ref</td>
  <td class="table_cells"><tt>act(ref, const_ref1, const_ref2)</tt></td>
  </tr>
</tbody></table>
<h3>Include Files 包含文件</h3>
<p>The predefined policy header files are located in <tt>boost/spirit/actor</tt>:<br>预定义的策略持有者动作器的头文件位于 <tt>boost/spirit/actor：</tt></p>
<pre>    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>ref_actor<span class="special">.</span>hpp<span class="special">&gt;<br></span>    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>ref_value_actor<span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>ref_const_ref<span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>ref_const_ref_value<span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>ref_const_ref_value<span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span>boost<span class="special">/</span>spirit<span class="special">/</span>actor<span class="special">/</span>ref_const_ref_const_ref<span class="special">.</span>hpp<span class="special">&gt;</span><span class="special"></span></pre>
<h3>Holder naming convention 持有者命名约定</h3>
<p> Policy holder have the following naming convention:<br>策略持有者有如下的命名约定：</p>
<pre>    <code>&lt;member&gt;_ &gt;&gt; *&lt;member&gt; &gt;&gt; !value &gt;&gt; actor</code></pre>
<p> where <tt>member</tt> is the action policy member which can be of type:<br>这里 <tt>member</tt> 是动作策略成员，它的类型可以是：</p>
<ul>
  <li>ref, a reference<br>ref, 一个引用</li>
  <li>const_ref, a const reference<br>const_ref, 一个常量引用</li>
  <li>value, by value<br>value, 传值方式</li>
  <li>empty, no stored members<br>empty，无存储成员</li>
</ul>
<p> and <tt>value</tt> states if the policy uses the parse result or not.<br>而 <tt>value</tt>&nbsp;标明策略是否使用分析结果。</p>
<h3>Holder example: <tt>ref_actor</tt> class 持有者例子：<tt>ref_actor</tt> 类</h3>
<pre><code>    <span class="comment">// this is the building block for action that  <br>    // take a reference and the parse result<br><br>    </span><span class="keyword">template</span><span class="special">&lt;<br>        </span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">,</span><span class="comment"> // reference type</span><span class="identifier">
        </span><span class="keyword">typename </span><span class="identifier">ActionT </span><span class="comment">// action policy<br>    </span><span class="special">&gt;<br>    </span><span class="keyword">class </span><span class="identifier">ref_value_actor </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">ActionT<br>    </span><span class="special">{<br></span>    <span class="keyword">public</span><span class="special">:<br><br>        </span><span class="keyword">explicit </span><span class="identifier">ref_value_actor</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">ref_</span><span class="special">)<br>        : </span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">ref_</span><span class="special">){}<br><br>        </span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T2</span><span class="special">&gt;<br>        </span><span class="keyword">void operator</span><span class="special">()(</span><span class="identifier">T2 </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">val</span><span class="special">) </span><span class="keyword">const<br>        </span><span class="special">{<br>            </span><span class="identifier">act</span><span class="special">(</span><span class="identifier">ref</span><span class="special">, </span><span class="identifier">val</span><span class="special">);</span><span class="comment"> // defined in ActionT</span><span class="identifier">
        </span><span class="special">}<br><br>        </span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">&gt;<br>        </span><span class="keyword">void operator</span><span class="special">()(<br>            </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">first</span><span class="special">,<br>            </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">last</span><span class="special">) </span><span class="keyword">const<br>        </span><span class="special">{<br>            </span><span class="identifier">act</span><span class="special">(</span><span class="identifier">ref</span><span class="special">,</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">last</span><span class="special">);</span><span class="comment"> // defined in ActionT</span><span class="identifier">
        </span><span class="special">}<br><br>    </span><span class="keyword">private</span><span class="special">: <br><br></span><span class="identifier">       T</span><span class="special">&amp; </span><span class="identifier">ref</span><span class="special">;<br>    };</span></code></pre> 
<h3>Actor example: <tt>assign_actor</tt> &nbsp;动作器例子：<tt>assign_actor</tt></h3>
<code>
</code><pre>    <span class="comment">// assign_action assigns the parse result to the reference<br><br>    </span><span class="keyword">struct </span><span class="identifier">assign_action<br>    </span><span class="special">{<br>        </span><span class="keyword">template</span><span class="special">&lt;<br>            </span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">,<br>            </span><span class="keyword">typename </span><span class="identifier">ValueT<br>        </span><span class="special">&gt;<br>        </span><span class="keyword">void </span><span class="identifier">act</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">ref</span><span class="special">, </span><span class="identifier">ValueT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">value</span><span class="special">) </span><span class="keyword">const<br>        </span><span class="special">{<br>            </span><span class="identifier">ref</span><span class="special"> = </span><span class="special"></span><span class="identifier">value</span><span class="special">;<br>        }<br>        <br>        </span><span class="keyword">template</span><span class="special">&lt;<br>            </span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">,<br>            </span><span class="keyword">typename </span><span class="identifier">IteratorT<br>        </span><span class="special">&gt;<br>        </span><span class="keyword">void </span><span class="identifier">act</span><span class="special">(<br>            </span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">ref</span><span class="special">, <br>            </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">first</span><span class="special">, <br>            </span><span class="identifier">IteratorT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">last</span><span class="special">) </span><span class="keyword">const<br>        </span><span class="special">{<br>            </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">::</span><span class="identifier">value_type </span><span class="identifier">value_type</span><span class="special">;<br>            </span><span class="identifier">value_type </span><span class="identifier">vt</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span><span class="identifier"> last</span><span class="special">);<br>            </span><span class="identifier">ref</span><span class="special"> = </span><span class="special"></span><span class="identifier">vt</span><span class="special">;<br>        }<br>    };</span></pre>
 
<h3>Helper function example: <tt>assign_a</tt> function &nbsp;辅助函数例子：<tt>assign_a</tt> 函数</h3>
<code> 
</code><pre>    <span class="comment">// assign_a is a polymorphic helper function that generators an<br>    // assign_actor based on ref_value_actor, assign_action and the <br>    // type of its argument.<br><br>    </span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="keyword">inline </span><span class="identifier">ref_value_actor</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">, </span>assign<span class="identifier">_action</span><span class="special">&gt;</span><span class="identifier">
    assign_a</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp; </span><span class="identifier">ref</span><span class="special">)<br>    {<br>        </span><span class="keyword">return </span><span class="identifier">ref_value_actor</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier"> assign_action</span><span class="special">&gt;(</span><span class="identifier">ref</span><span class="special">);<br>    }</span></pre>

<table border="0">
  <tbody><tr>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="indepth_the_parser_context.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="20"><a href="parametric_parsers.html"><img src="theme/r_arr.gif" border="0" height="19" width="20"></a></td>
  </tr>
</tbody></table>
<br>
<hr size="1">
<p class="copyright">Copyright © 2003 <font color="#666666">Jonathan de Halleux</font><font size="2"><font size="2"><font color="#666666"> 
  </font></font> </font><br>
  Copyright © 2003 Joel de Guzman<br>
  <br>
  <font size="2">Use,
modification and distribution is subject to the Boost Software License,
Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt) </font>  </p>
</body></html>
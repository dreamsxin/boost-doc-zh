<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<title>Techniques</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="theme/style.css" type="text/css"></head>
<body>
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr> 
    <td width="10"> 
    </td>
    <td width="85%"> <font face="Verdana, Arial, Helvetica, sans-serif" size="6"><b>Techniques 技术</b></font></td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0" height="48" width="112"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr>
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="style_guide.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="faq.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<ul>
  <li><a href="#templatized_functors">Templatized Functors 模板化仿函数</a></li>
  <li><a href="#multiple_scanner_support">Rule With Multiple Scanners 带多个扫描器的规则</a></li>
  <li><a href="#no_rules">Look Ma' No Rules!</a></li>
  <li><a href="#typeof">typeof</a></li>
  <li><a href="#nabialek_trick">Nabialek trick</a></li>
</ul>
<h3><a name="templatized_functors"></a> Templatized Functors 模板化仿函数</h3>
<p>For the sake of genericity, it is often better to make the functor's member 
  <tt>operator()</tt> a template. That way, we do not have to concern ourselves 
  with the type of the argument to expect as long as the behavior is appropriate. 
  For instance, rather than hard-coding <tt>char const*</tt> as the argument of 
  a generic semantic action, it is better to make it a template member function. 
  That way, it can accept any type of iterator:<br>从泛型的角度看，令仿函数的 
  <tt>operator()</tt> 成员模板化往往是较好的做法。这样，我们不必关心参数的类型，只要其行为是适当的即可。例如，不要硬编码 <tt>char const*</tt>&nbsp;作为一个通用的语义动作的参数，最好是使它成为一个模板成员函数。这样，它就可以接受任意的迭代器类型：</p>
<pre><code><font color="#000000"><span class="special">    </span><span class="keyword">struct </span><span class="identifier">my_functor<br>    </span><span class="special">{<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">IteratorT</span><span class="special">&gt;<br>        </span><span class="keyword">void </span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">IteratorT </span><span class="identifier">first</span><span class="special">, </span><span class="identifier">IteratorT </span><span class="identifier">last</span><span class="special">) </span><span class="keyword">const</span><span class="special">;<br>    </span><span class="special">};</span></font></code></pre>
<p>Take note that this is only possible with functors. It is not possible to pass 
  in template functions as semantic actions unless you cast it to the correct 
  function signature; in which case, you <em>monomorphize</em> the function. This 
  clearly shows that functors are superior to plain functions.<br>注意，这只对仿函数是可能的。不可能将模板函数作为语义动作传入，除非您将它转换为正确的函数签名；在这种情况下，你monomorphize了该函数。这清楚地表明了，仿函数优于普通的函数。</p>
<h3><b><a name="multiple_scanner_support" id="multiple_scanner_support"></a> Rule 
  With Multiple Scanners 带多个扫描器的规则</b></h3>
<p>As of v1.8.0, rules can use one or more scanner types. There are cases, for 
  instance, where we need a rule that can work on the phrase and character levels. 
  Rule/scanner mismatch has been a source of confusion and is the no. 1 <a href="faq.html#scanner_business">FAQ</a>. 
  To address this issue, we now have <a href="rule.html#multiple_scanner_support">multiple 
  scanner support</a>.<br>截至 v1.8.0，规则可以使用一个或多个扫描器类型。在某些情况下，例如，我们需要一个可以工作于短语和字符层面的规则时。规则/扫描器间的失配已一直是混乱的源头，也是首当其冲的 <a href="faq.html#scanner_business">FAQ</a>。为解决此问题，我们需要 <a href="rule.html#multiple_scanner_support">多扫描器支持</a>。 </p>
<p>Here is an example of a grammar with a rule <tt>r</tt> that can be called with 
  3 types of scanners (phrase-level, lexeme, and lower-case). See the <a href="rule.html">rule</a>, 
  <a href="grammar.html">grammar</a>, <a href="scanner.html#lexeme_scanner">lexeme_scanner</a> 
  and <a href="scanner.html#as_lower_scanner">as_lower_scanner </a>for more information.<br>以下是一个语法例子，其中有一个规则 <tt>r</tt> 可用3个扫描器类型调用(短语级别的、词位的和小写的)。更多信息请见 <a href="rule.html">规则</a>, 
  <a href="grammar.html">语法</a>, <a href="scanner.html#lexeme_scanner">lexeme_scanner</a> 和 <a href="scanner.html#as_lower_scanner">as_lower_scanner</a>。 
</p>
<p>Here's the grammar (see <a href="../example/techniques/multiple_scanners.cpp">multiple_scanners.cpp</a>):<br>以下就是这个语法(见 <a href="../example/techniques/multiple_scanners.cpp">multiple_scanners.cpp</a>): 
</p>
<pre><span class="special">    </span><span class="keyword">struct </span><span class="identifier">my_grammar </span><span class="special">: </span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">my_grammar</span><span class="special">&gt;<br>    </span><span class="special">{<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">struct </span><span class="identifier">definition<br>        </span><span class="special">{<br>            </span><span class="identifier">definition</span><span class="special">(</span><span class="identifier">my_grammar </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">self</span><span class="special">)<br>            </span><span class="special">{<br>                </span><span class="identifier">r </span><span class="special">= </span><span class="identifier">lower_p</span><span class="special">;<br>                </span><span class="identifier">rr </span><span class="special">= </span><span class="special">+(</span><span class="identifier">lexeme_d</span><span class="special">[</span><span class="identifier">r</span><span class="special">] </span><span class="special">&gt;&gt; </span><span class="identifier">as_lower_d</span><span class="special">[</span><span class="identifier">r</span><span class="special">] </span><span class="special">&gt;&gt; </span><span class="identifier">r</span><span class="special">);<br>            </span><span class="special">}<br><br>            </span><span class="keyword">typedef </span><span class="identifier">scanner_list</span><span class="special">&lt;<br>                </span><span class="identifier">ScannerT<br>              </span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">lexeme_scanner</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>              </span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">as_lower_scanner</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>            </span><span class="special">&gt; </span><span class="identifier">scanners</span><span class="special">;<br><br>            </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">scanners</span><span class="special">&gt; </span><span class="identifier">r</span><span class="special">;<br>            </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt; </span><span class="identifier">rr</span><span class="special">;<br>            </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">start</span><span class="special">() </span><span class="keyword">const </span><span class="special">{ </span><span class="keyword">return </span><span class="identifier">rr</span><span class="special">; </span><span class="special">}<br>        </span><span class="special">};<br>    </span><span class="special">};</span></pre>
<p>By default support for multiple scanners is disabled.  The macro
  <tt>BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT</tt> must be defined to the
  maximum number of scanners allowed in a scanner_list.  The value must
  be greater than 1 to enable multiple scanners.  Given the
  example above, to define a limit of three scanners for the list, the
  following line must be inserted into the source file before the
  inclusion of Spirit headers:<br>缺省情况下，多扫描器支持是关闭的。宏
  <tt>BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT</tt> 必须被定义为在一个 scanner_list 中允许的最大扫描器数量。该值必须大于1才能激活多扫描器。在以上例子中，要定义扫描器列表中最多可有3个扫描器，以下一行必须插入到源文件中包含Spirit头文件之前：
</p>
<pre><span class="special">    </span><span class="preprocessor">#define </span><span class="identifier">BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT</span> <span class="literal">3</span></pre>
<h3><span class="special"></span><b> <a name="no_rules" id="no_rules"></a> Look 
  Ma' No Rules 看，不使用规则</b></h3>
<p>You use grammars and you use lots of 'em? Want a fly-weight, no-cholesterol, 
  super-optimized grammar? Read on...<br>你使用语法且经常使用吗？想要一个轻量级的、没有多余部分、超级优化的语法吗？继续读下去...</p>
<p>I have a love-hate relationship with rules. I guess you know the reasons why. 
  A lot of problems stem from the limitation of rules. Dynamic polymorphism and 
  static polymorphism in C++ do not mix well. There is no notion of virtual template 
  functions in C++; at least not just yet. Thus, the <strong>rule is tied to a 
  specific scanner type</strong>. This results in problems such as the <a href="faq.html#scanner_business">scanner 
  business</a>, our no. 1 FAQ. Apart from that, the virtual functions in rules 
  slow down parsing, kill all meta-information, and kills inlining, hence bloating 
  the generated code, especially for very tiny rules such as:<br>我对规则是又爱又恨。我猜你应该知道其中的原因。许多问题是源于对规则的限制。动态多态性和静态多态性在C++中未能很好地混合。在C++中，没有虚拟模板函数的概念；至少目前还没有。因此，<strong>规则是针对某一特定的扫描器类型的</strong>。这导致了 <a href="faq.html#scanner_business">扫描器事务</a> 此类问题，我们第一的FAQ。此外，规则中的虚拟函数降低了分析的速度，消灭了所有元信息，也消灭了内联，因此生成的代码极度膨胀，尤其是对于非常微型的规则，如：</p>
<pre>    r <span class="special">=</span> ch_p<span class="special">(</span><span class="quotes">'x'</span><span class="special">) &gt;&gt;</span> uint_p<span class="special">;</span></pre>
<p> The rule's limitation is the main reason why the grammar is designed the way 
  it is now, with a nested template definition class. The rule's limitation is 
  also the reason why subrules exists. But do we really need rules? Of course! 
  Before C++ adopts some sort of auto-type deduction, such as that proposed by 
  David Abrahams in clc++m:<br>这个规则的限制是语法为何以现有方式，嵌套模板定义类，来设计的主要原因。这个规则的限制也是子规则为何存在的原因。但是，我们真的需要规则吗？当然！在C++采用某各种自动类型推演，正如 
  David Abrahams 在 clc++m 中所建议的那样：</p>
<pre>    <code><span class="keyword">auto </span><span class="identifier">r </span><span class="special">= ...</span><span class="identifier">definition </span><span class="special">...</span></code></pre>
<p> we are tied to the rule as RHS placeholders. However.... in some occasions 
  we can get by without rules! For instance, rather than writing:<br>之前，我们只能绑定在规则上，作为RHS占位符。但是....在某些场合，我们可以不需要规则！例如，与其这样写：</p>
<pre>    <code><span class="identifier">rule</span><span class="special">&lt;&gt; </span><span class="identifier">x </span><span class="special">= </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'x'</span><span class="special">);</span></code></pre>
<p> It's better to write:<br>不如这样写更好：</p>
<pre>    <code><span class="identifier">chlit</span><span class="special">&lt;&gt; </span><span class="identifier">x </span><span class="special">= </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'x'</span><span class="special">);</span></code></pre>
<p> That's trivial. But what if the rule is rather complicated? Ok, let's proceed 
  stepwise... I'll investigate a simple skip_parser based on the C grammar from 
  Hartmut Kaiser. Basically, the grammar is written as (see <a href="../example/techniques/no_rules/no_rule1.cpp">no_rule1.cpp</a>):<br>这很平常。不过，如果规则比较复杂呢？好的，我们继续向前... 我将探讨一个基于C语法的简单 skip_parser，它来自 
  Hartmut Kaiser。基本上，这个语法可以写成(见 <a href="../example/techniques/no_rules/no_rule1.cpp">no_rule1.cpp</a>)：</p>
<pre><code>    <span class="keyword">struct </span><span class="identifier">skip_grammar </span><span class="special">: </span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">skip_grammar</span><span class="special">&gt;<br>    {<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">struct </span><span class="identifier">definition<br>        </span><span class="special">{<br>            </span><span class="identifier">definition</span><span class="special">(</span><span class="identifier">skip_grammar </span><span class="keyword">const</span><span class="special">&amp; /*</span><span class="identifier">self</span><span class="special">*/)<br>            {<br>                </span><span class="identifier">skip<br>                    </span><span class="special">=   </span><span class="identifier">space_p<br>                    </span><span class="special">|   </span><span class="string">"//" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="literal">'\n'</span><span class="special">) &gt;&gt; </span><span class="literal">'\n'<br>                    </span><span class="special">|   </span><span class="string">"/*" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="string">"*/"</span><span class="special">) &gt;&gt; </span><span class="string">"*/"<br>                    </span><span class="special">;<br>            }<br><br>            </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt; </span><span class="identifier">skip</span><span class="special">;<br><br>            </span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt; </span><span class="keyword">const</span><span class="special">&amp;<br>            </span><span class="identifier">start</span><span class="special">() </span><span class="keyword">const </span><span class="special">{ </span><span class="keyword">return </span><span class="identifier">skip</span><span class="special">; }<br>        };<br>    };</span></code></pre>
<p> Ok, so far so good. Can we do better? Well... since there are no recursive 
  rules there (in fact there's only one rule), you can expand the type of rule's 
  RHS as the rule type (see <a href="../example/techniques/no_rules/no_rule2.cpp">no_rule2.cpp</a>):<br>好的，不错。我们可以做得更好吗？嗯... 由于这里没有递归的规则(事实上只有一个规则)，你可以将规则的RHS类型扩展为规则的类型(见 <a href="../example/techniques/no_rules/no_rule2.cpp">no_rule2.cpp</a>)：</p>
<pre><code><span class="special">    </span><span class="keyword">struct </span><span class="identifier">skip_grammar </span><span class="special">: </span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">skip_grammar</span><span class="special">&gt;<br>    {<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">struct </span><span class="identifier">definition<br>        </span><span class="special">{<br></span>            <span class="identifier">definition</span><span class="special">(</span><span class="identifier">skip_grammar </span><span class="keyword">const</span><span class="special">&amp; /*</span><span class="identifier">self</span><span class="special">*/)<br>            : </span><span class="identifier">skip</span><span class="special">
                (       </span><span class="identifier">space_p<br>                    </span><span class="special">|   </span><span class="string">"//" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="literal">'\n'</span><span class="special">) &gt;&gt; </span><span class="literal">'\n'<br>                    </span><span class="special">|   </span><span class="string">"/*" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="string">"*/"</span><span class="special">) &gt;&gt; </span><span class="string">"*/"<br>                </span><span class="special">)<br>            {<br>            }<br><br>            </span><span class="keyword">typedef<br>               </span><span class="identifier">alternative</span><span class="special">&lt;</span><span class="identifier">alternative</span><span class="special">&lt;</span><span class="identifier">space_parser</span><span class="special">, </span><span class="identifier">sequence</span><span class="special">&lt;</span><span class="identifier">sequence</span><span class="special">&lt;<br>               </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt;, </span><span class="identifier">kleene_star</span><span class="special">&lt;</span><span class="identifier">difference</span><span class="special">&lt;</span><span class="identifier">anychar_parser</span><span class="special">,<br>               </span><span class="identifier">chlit</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt; &gt; &gt; &gt;, </span><span class="identifier">chlit</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt; &gt; &gt;, </span><span class="identifier">sequence</span><span class="special">&lt;</span><span class="identifier">sequence</span><span class="special">&lt;<br>               </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt;, </span><span class="identifier">kleene_star</span><span class="special">&lt;</span><span class="identifier">difference</span><span class="special">&lt;</span><span class="identifier">anychar_parser</span><span class="special">,<br>               </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt; &gt; &gt; &gt;, </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt; &gt; &gt;<br>            </span><span class="identifier">skip_t</span><span class="special">;<br></span><span class="special">            </span><span class="identifier">skip_t </span><span class="identifier">skip</span><span class="special">;<br><br>            </span><span class="identifier">skip_t </span><span class="keyword">const</span><span class="special">&amp;<br>            </span><span class="identifier">start</span><span class="special">() </span><span class="keyword">const </span><span class="special">{ </span><span class="keyword">return </span><span class="identifier">skip</span><span class="special">; }<br>        };<br>    };</span></code></pre>
<p> Ughhh! How did I do that? How was I able to get at the complex typedef? Am 
  I insane? Well, not really... there's a trick! What you do is define the typedef 
  <tt>skip_t</tt> first as int:<br>Ughhh! 我是怎么做的呢？我怎么能得到这个复杂的 typedef? 我疯了吗？嗯，这不是真的... 这里有个诀窍！你要做的就是首先定义 typedef 
  <tt>skip_t</tt> 为 int:</p>
<pre>    <code><span class="keyword">typedef </span><span class="keyword">int </span><span class="identifier">skip_t</span><span class="special">;</span></code></pre>
<p> Try to compile. Then, the compiler will generate an obnoxious error message 
  such as:<br>试着编译一下。然后，编译器会生成一个可恶的错误信息如下：</p>
<pre>    <code><span class="string">"cannot convert boost::spirit::alternative&lt;... blah blah...to int"</span><span class="special">.</span></code></pre>
<p> <strong>THERE YOU GO!</strong> You got it's type! I just copy and paste the 
  correct type (removing explicit qualifications, if preferred).<br><strong>做到了！</strong>你得到了它的类型！我只需复制并粘贴这个正确的类型即可(删去显式的限定符，如果愿意的话)。</p>
<p> Can we still go further? Yes. Remember that the grammar was designed for rules. 
  The nested template definition class is needed to get around the rule's limitations. 
  Without rules, I propose a new class called <tt>sub_grammar</tt>, the grammar's 
  low-fat counterpart:<br>我们还可以走得更远吗？是的。记住，语法是为规则而设计的。内嵌的模板定义类是必需的，以绕过规则的限制。没有规则，我提议一个名为 <tt>sub_grammar</tt> 的新类，该语法的轻量级方式：</p>
<pre><code><span class="special">    </span><span class="keyword">namespace </span><span class="identifier">boost </span><span class="special">{ </span><span class="keyword">namespace </span><span class="identifier">spirit<br>    </span><span class="special">{<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">DerivedT</span><span class="special">&gt;<br>        </span><span class="keyword">struct </span><span class="identifier">sub_grammar </span><span class="special">: </span><span class="identifier">parser</span><span class="special">&lt;</span><span class="identifier">DerivedT</span><span class="special">&gt;<br>        {<br>            </span><span class="keyword">typedef </span><span class="identifier">sub_grammar </span><span class="identifier">self_t</span><span class="special">;<br>            </span><span class="keyword">typedef </span><span class="identifier">DerivedT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">embed_t</span><span class="special">;<br><br>            </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>            </span><span class="keyword">struct </span><span class="identifier">result<br>            </span><span class="special">{<br>                </span><span class="keyword">typedef </span><span class="keyword">typename </span><span class="identifier">parser_result</span><span class="special">&lt;<br>                    </span><span class="keyword">typename </span><span class="identifier">DerivedT</span><span class="special">::</span><span class="identifier">start_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>                </span><span class="identifier">type</span><span class="special">;<br>            };<br><br>            </span><span class="identifier">DerivedT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">derived</span><span class="special">() </span><span class="keyword">const<br>            </span><span class="special">{ </span><span class="keyword">return </span><span class="special">*</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">DerivedT </span><span class="keyword">const</span><span class="special">*&gt;(</span><span class="keyword">this</span><span class="special">); }<br><br>            </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>            </span><span class="keyword">typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">self_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>            </span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">ScannerT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">) </span><span class="keyword">const<br>            </span><span class="special">{<br>                </span><span class="keyword">return </span><span class="identifier">derived</span><span class="special">().</span><span class="identifier">start</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">);<br>            }<br>        };<br>    }}</span></code></pre>
<p>With the <tt>sub_grammar</tt> class, we can define our skipper grammar this 
  way (see <a href="../example/techniques/no_rules/no_rule3.cpp">no_rule3.cpp</a>):<br>有了这个 <tt>sub_grammar</tt> 类，我们可以按以下方式定义我们的跳读语法(见 <a href="../example/techniques/no_rules/no_rule3.cpp">no_rule3.cpp</a>)：</p>
<pre><code><span class="special">    </span><span class="keyword">struct </span><span class="identifier">skip_grammar </span><span class="special">: </span><span class="identifier">sub_grammar</span><span class="special">&lt;</span><span class="identifier">skip_grammar</span><span class="special">&gt;<br>    {<br>        </span><span class="keyword">typedef<br>           </span><span class="identifier">alternative</span><span class="special">&lt;</span><span class="identifier">alternative</span><span class="special">&lt;</span><span class="identifier">space_parser</span><span class="special">, </span><span class="identifier">sequence</span><span class="special">&lt;</span><span class="identifier">sequence</span><span class="special">&lt;<br>           </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt;, </span><span class="identifier">kleene_star</span><span class="special">&lt;</span><span class="identifier">difference</span><span class="special">&lt;</span><span class="identifier">anychar_parser</span><span class="special">,<br>           </span><span class="identifier">chlit</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt; &gt; &gt; &gt;, </span><span class="identifier">chlit</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt; &gt; &gt;, </span><span class="identifier">sequence</span><span class="special">&lt;</span><span class="identifier">sequence</span><span class="special">&lt;<br>           </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt;, </span><span class="identifier">kleene_star</span><span class="special">&lt;</span><span class="identifier">difference</span><span class="special">&lt;</span><span class="identifier">anychar_parser</span><span class="special">,<br>           </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt; &gt; &gt; &gt;, </span><span class="identifier">strlit</span><span class="special">&lt;</span><span class="keyword">const </span><span class="keyword">char</span><span class="special">*&gt; &gt; &gt;<br>        </span><span class="identifier">start_t</span><span class="special">;<br><br>        </span><span class="identifier">skip_grammar</span><span class="special">()<br>        : </span><span class="identifier">start<br>            </span><span class="special">(<br>                </span><span class="identifier">space_p<br>            </span><span class="special">|   </span><span class="string">"//" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="literal">'\n'</span><span class="special">) &gt;&gt; </span><span class="literal">'\n'<br>            </span><span class="special">|   </span><span class="string">"/*" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="string">"*/"</span><span class="special">) &gt;&gt; </span><span class="string">"*/"<br>            </span><span class="special">)<br>        {}<br><br>        </span><span class="identifier">start_t </span><span class="identifier">start</span><span class="special">;<br>    };</span></code></pre>
<p>But what for, you ask? You can simply use the <tt>start_t</tt> type above as-is. 
  It's already a parser! We can just type:<br>但是这该怎么用，你会问？你可以如上只使用 <tt>start_t</tt> 类型。它已经是一个分析器了！我们可以只输入：</p>
<pre>    <code><span class="identifier">skipper_t </span><span class="identifier">skipper </span><span class="special">=<br>        </span><span class="identifier">space_p<br>        </span><span class="special">|   </span><span class="string">"//" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="literal">'\n'</span><span class="special">) &gt;&gt; </span><span class="literal">'\n'     </span><br>        <span class="special">|   </span><span class="string">"/*" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="string">"*/"</span><span class="special">) &gt;&gt; </span><span class="string">"*/"</span>
    <span class="special">    ;</span></code></pre>
<p> and use <tt>skipper</tt> just as we would any parser? Well, a subtle difference 
  is that <tt>skipper</tt>, used this way will be embedded <strong>by value </strong>when<strong> 
  </strong>you compose more complex parsers using it. That is, if we use <tt>skipper</tt> 
  inside another production, the whole thing will be stored in the composite. 
  Heavy!<br>仅将 <tt>skipper</tt> 用作我们所需的分析器？那么，一个微妙的区别在于，以该方式使用 <tt>skipper</tt>，当你用它组成更复杂的分析器时它是<strong>以值方式</strong>嵌入的。即，如果我们在另一个分析器中使用 <tt>skipper</tt>，整个东西都将被保存在组合物中。这有点太沉重了！</p>
<p> The proposed <tt>sub_grammar</tt> OTOH will be held by reference. Note:<br>另一方面，这个建议的 <tt>sub_grammar</tt> 应该以引用方式保存。如：</p>
<pre><code>    <span class="keyword">typedef </span><span class="identifier">DerivedT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">embed_t</span><span class="special">;</span></code></pre>
<p>The proposed <tt>sub_grammar</tt> does not have the inherent limitations of 
  rules, is very lighweight, and should be blazingly fast (can be fully inlined 
  and does not use virtual functions). Perhaps this class will be part of a future 
  spirit release.<br>这个建议的 <tt>sub_grammar</tt> 没有规则的固有限制，非常轻量，也应极其快速(完全可以内联且不使用虚拟函数)。也许这个类会是未来版本的spirit的一部分。 </p>
<table align="center" border="0" width="80%">
  <tbody><tr> 
    <td class="note_box"><img src="theme/note.gif" height="16" width="16"> <strong>The 
      no-rules result 无规则的结果</strong><br> <br>
      So, how much did we save? On MSVCV7.1, the original code: <a href="../example/techniques/no_rules/no_rule1.cpp">no_rule1.cpp</a> 
      compiles to <strong>28k</strong>. Eliding rules, <a href="../example/techniques/no_rules/no_rule2.cpp">no_rule2.cpp</a>, 
      we got <strong>24k</strong>. Not bad, we shaved off 4k amounting to a 14% 
      reduction. But you'll be in for a surprise. The last version, using the 
      sub-grammar: <a href="../example/techniques/no_rules/no_rule3.cpp">no_rule3.cpp</a>, 
      compiles to <strong>5.5k</strong>! That's a whopping 80% reduction.<br>那么，我们节省了多少呢？在MSVCV7.1上，原来的代码 <a href="../example/techniques/no_rules/no_rule1.cpp">no_rule1.cpp</a> 
      编译后有 <strong>28k</strong>。不用规则的&nbsp;<a href="../example/techniques/no_rules/no_rule2.cpp">no_rule2.cpp</a> 则是 <strong>24k</strong>。不错，我们砍掉了4k，减小了14%。不过你会更加惊讶。最后一个版本，使用子语法的 <a href="../example/techniques/no_rules/no_rule3.cpp">no_rule3.cpp</a> 
      编译后只有 <strong>5.5k</strong>! 高达80%的缩减。<br>
      <br>
      <table border="1" width="100%">
        <tbody><tr> 
          <td><a href="../example/techniques/no_rules/no_rule1.cpp">no_rule1.cpp</a></td>
          <td><strong>28k</strong></td>
          <td>standard rule and grammar 标准规则和语法</td>
        </tr>
        <tr> 
          <td><a href="../example/techniques/no_rules/no_rule2.cpp">no_rule2.cpp</a></td>
          <td><strong>24k</strong></td>
          <td>standard grammar, no rule 标准语法，无规则</td>
        </tr>
        <tr> 
          <td><a href="../example/techniques/no_rules/no_rule3.cpp">no_rule3.cpp</a></td>
          <td><strong>5.5k</strong></td>
          <td>sub_grammar, no rule, no grammar 子语法，无规则，无语法</td>
        </tr>
      </tbody></table> </td>
  </tr>
</tbody></table>
<h3><b> <a name="typeof" id="typeof"></a> typeof</b></h3>
<p>Some compilers already support the <tt>typeof</tt> keyword. Examples are g++ 
  and Metrowerks CodeWarrior. Someday, <tt>typeof</tt> will become commonplace. 
  It is worth noting that we can use <tt>typeof</tt> to define non-recursive rules 
  without using the rule class. To give an example, we'll use the skipper example 
  above; this time using <tt>typeof</tt>. First, to avoid redundancy, we'll introduce 
  a macro <tt>RULE</tt>:<br>有些编译器已经支持 <tt>typeof</tt> 关键字。例如 g++ 和 Metrowerks CodeWarrior。迟早，<tt>typeof</tt> 会被广泛支持。值得注意的是，我们可以用 <tt>typeof</tt> 来定义非递归规则而无需使用规则类。举个例子，我们将使用前面的跳读器例子；这次使用 <tt>typeof</tt>。首先，为了避免重复，我们引入一个宏 <tt>RULE</tt>: </p>
<pre><code>    <span class="preprocessor">#define </span><span class="identifier">RULE</span><span class="special">(</span><span class="identifier">name</span><span class="special">, </span><span class="identifier">definition</span><span class="special">) </span><span class="keyword">typeof</span><span class="special">(</span><span class="identifier">definition</span><span class="special">) </span><span class="identifier">name </span><span class="special">= </span><span class="identifier">definition</span></code></pre>
<p>Then, simply:<br>然后，只需：</p>
<pre><code><span class="identifier">    </span><span class="identifier">RULE</span><span class="special">(<br>        </span><span class="identifier">skipper</span><span class="special">,<br>        (       </span><span class="identifier">space_p<br>            </span><span class="special">|   </span><span class="string">"//" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="literal">'\n'</span><span class="special">) &gt;&gt; </span><span class="literal">'\n'<br>            </span><span class="special">|   </span><span class="string">"/*" </span><span class="special">&gt;&gt; *(</span><span class="identifier">anychar_p </span><span class="special">- </span><span class="string">"*/"</span><span class="special">) &gt;&gt; </span><span class="string">"*/"<br>        </span><span class="special">)<br>    );</span></code></pre>
<p>(see <a href="../example/techniques/typeof.cpp">typeof.cpp</a>)<br>(见 <a href="../example/techniques/typeof.cpp">typeof.cpp</a>)</p>
<p>That's it! Now you can use skipper just as you would any parser. Be reminded, 
    however, that <tt>skipper</tt> above will be embedded by value when<strong> 
  </strong>you compose more complex parsers using it (see <tt>sub_grammar</tt> rationale above). You can use the <tt>sub_grammar</tt> class to avoid this problem.<br>就是这样！现在你可以象任意分析器那样使用 skipper。不过要记住，当你使用以上的 <tt>skipper</tt> 来合成更为复杂的分析器时，它是以值方式嵌入的(见前文的 <tt>sub_grammar</tt> 原理)。你可以使用 <tt>sub_grammar</tt> 类来避免这个问题。</p>
<h3><a name="nabialek_trick"></a> Nabialek trick</h3>
<p>This technique, I'll call the <strong><em>"Nabialek trick" </em></strong>(from
the name of its inventor, Sam Nabialek), can improve the rule dispatch
from linear non-deterministic to deterministic. The trick applies to
grammars where a keyword (operator, etc), precedes a production. There
are lots of grammars similar to this:<br>这个技术我称之为<strong><em>"Nabialek诀窍" </em></strong>(来自它的发明者 Sam Nabialek)，可以将规则的分派由线性非确定性改进为确定性的。该诀窍适用于关键字(操作符等)语法，生成一个结果。有许多语法类似于：</p>
<pre>    <span class="identifier">r </span><span class="special">=<br>            </span><span class="identifier">keyword1 </span><span class="special">&gt;&gt; </span><span class="identifier">production1<br>        </span><span class="special">|   </span><span class="identifier">keyword2 </span><span class="special">&gt;&gt; </span><span class="identifier">production2<br>        </span><span class="special">|   </span><span class="identifier">keyword3 </span><span class="special">&gt;&gt; </span><span class="identifier">production3<br>        </span><span class="special">|   </span><span class="identifier">keyword4 </span><span class="special">&gt;&gt; </span><span class="identifier">production4<br>        </span><span class="special">|   </span><span class="identifier">keyword5 </span><span class="special">&gt;&gt; </span><span class="identifier">production5<br>        </span><span class="comment">/*** etc ***/<br>        </span><span class="special">;</span></pre>
<p>The cascaded alternatives are tried one at a time through trial and
error until something matches. The Nabialek trick takes advantage of
the <a href="symbols.html">symbol table</a>'s search properties to optimize the dispatching of the alternatives. For an example, see <a href="../example/techniques/nabialek.cpp">nabialek.cpp</a>. The grammar works as follows. There are two rules (<tt>one</tt> and <tt>two</tt>). When "one" is recognized, rule <tt>one</tt> is invoked. When "two" is recognized, rule <tt>two</tt> is invoked.  Here's  the grammar:<br>这个级联的多选是通过反复的试错，直至有某个选项匹配。Nabialek诀窍利用 <a href="symbols.html">符号表</a> 的查找特性来优化多个选项的分派。相关例子请见 <a href="../example/techniques/nabialek.cpp">nabialek.cpp</a>. 该语法工作如下。有两个规则(<tt>one</tt> 和 <tt>two</tt>)。当识别出 "one" 时，调用规则 <tt>one</tt>。当识别出 "two" 时，则调用规则 <tt>two</tt>。语法如下：</p>
<pre><span class="special">    </span><span class="identifier">one </span><span class="special">= </span><span class="identifier">name</span><span class="special">;<br>    </span><span class="identifier">two </span><span class="special">= </span><span class="identifier">name </span><span class="special">&gt;&gt; </span><span class="literal">',' </span><span class="special">&gt;&gt; </span><span class="identifier">name</span><span class="special">;<br>    <br>    </span><span class="identifier">continuations</span><span class="special">.</span><span class="identifier">add<br>        </span><span class="special">(</span><span class="string">"one"</span><span class="special">, &amp;</span><span class="identifier">one</span><span class="special">)<br>        </span><span class="special">(</span><span class="string">"two"</span><span class="special">, &amp;</span><span class="identifier">two</span><span class="special">)<br>    </span><span class="special">;<br>    <br>    </span><span class="identifier">line </span><span class="special">= </span><span class="identifier">continuations</span><span class="special">[</span><span class="identifier">set_rest</span><span class="special">&lt;</span><span class="identifier">rule_t</span><span class="special">&gt;(</span><span class="identifier">rest</span><span class="special">)] </span><span class="special">&gt;&gt; </span><span class="identifier">rest</span><span class="special">;</span></pre>
<p>where continuations is a <a href="symbols.html">symbol table</a> with pointer to rule_t  slots. one, two, name, line and rest are rules:<br>其中 continuations 是一个 <a href="symbols.html">符号表</a>，带有指向 rule_t  项的指针。one, two, name, line 和 rest 均为规则：</p>
<pre><span class="special">    </span><span class="identifier">rule_t </span><span class="identifier">name</span><span class="special">;<br>    </span><span class="identifier">rule_t </span><span class="identifier">line</span><span class="special">;<br>    </span><span class="identifier">rule_t </span><span class="identifier">rest</span><span class="special">;<br>    </span><span class="identifier">rule_t </span><span class="identifier">one</span><span class="special">;<br>    </span><span class="identifier">rule_t </span><span class="identifier">two</span><span class="special">;<br>    <br>    </span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="identifier">rule_t</span><span class="special">*&gt; </span><span class="identifier">continuations</span><span class="special">;</span></pre>
<p>set_rest, the semantic action attached to continuations is:<br>set_rest 是附加至 continuations 的语义动作，如下：</p>
<pre><span class="special">    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">Rule</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">set_rest<br>    </span><span class="special">{<br>        </span><span class="identifier">set_rest</span><span class="special">(</span><span class="identifier">Rule</span><span class="special">&amp; </span><span class="identifier">the_rule</span><span class="special">)<br>        </span><span class="special">: </span><span class="identifier">the_rule</span><span class="special">(</span><span class="identifier">the_rule</span><span class="special">) </span><span class="special">{}<br><br>        </span><span class="keyword">void </span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Rule</span><span class="special">* </span><span class="identifier">newRule</span><span class="special">) </span><span class="keyword">const<br>        </span><span class="special">{ </span><span class="identifier">m_theRule </span><span class="special">= </span><span class="special">*</span><span class="identifier">newRule</span><span class="special">; </span><span class="special">}<br><br>        </span><span class="identifier">Rule</span><span class="special">&amp; </span><span class="identifier">the_rule</span><span class="special">;<br>    </span><span class="special">};</span></pre>
<p>Notice how the rest <tt>rule</tt> gets set dynamically when the set_rule action is called. The dynamic grammar parses inputs such as:<br>注意，在 set_rule 动作被调用时，rest <tt>rule</tt> 是如何被动态设置。该动态语法分析如下的输入：</p>
<p> "one only"<br>
"one again"<br>
"two first, second"</p>
<p>The cool part is that the <tt>rest</tt> rule is set (by the <tt>set_rest</tt> action) depending on what the symbol table got. If it got a <em>"one"</em> then rest = one. If it got <em>"two"</em>,
then rest = two. Very nifty! This technique should be very fast,
especially when there are lots of keywords. It would be nice to add
special facilities to make this easy to use. I imagine:<br>最酷的部分是，<tt>rest</tt> 规则被依据所获得的符号表而设置(通过 <tt>set_rest</tt> 动作)。如果它获得一个 <em>"one"</em> 则 rest = one。如果它获得 <em>"two"</em>,
则 rest = two。1多漂亮！这种技术应该非常快，尤其是有大量关键字的时候。应该增加一些特殊的工具令之更为易用。我想：</p>
<pre><span class="special">    </span><span class="identifier">r </span><span class="special">= </span><span class="identifier">keywords </span><span class="special">&gt;&gt; </span><span class="identifier">rest</span><span class="special">;</span></pre>
<p>where <tt>keywords</tt> is a special parser (based on the symbol
table) that automatically sets its RHS (rest) depending on the acquired
symbol. This, I think, is mighty cool! Someday perhaps...<br>其中 <tt>keywords</tt> 是一个特殊的分析器(基于符号符)，它自动根据所获得的符号设置其右操作数(rest)。我想，这真的很酷！也许有一天... </p>
<p><img src="theme/note.gif" height="16" width="16"> Also, see the <a href="switch_parser.html">switch parser</a> for another deterministic parsing trick for character/token prefixes.<br><img src="theme/note.gif" height="16" width="16"> 另外，还有一个用于字符/记号前缀的确定性分析技巧，请见 <a href="switch_parser.html">跳转分析器</a>。 </p>
<span class="special"></span>
<table border="0">
  <tbody><tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="style_guide.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="faq.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<br>
<hr size="1">
<p class="copyright">Copyright © 1998-2003 Joel de Guzman<br>
  <br>
<font size="2">Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)</font></p>
<p class="copyright">&nbsp;</p>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>System Library Reference</title><link rel="stylesheet" type="text/css" href="../../../doc/html/minimal.css"></head>
<body>

<table style="border-collapse: collapse;" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0" width="637">
  <tbody><tr>
    <td width="277">
<a href="../../../index.htm">
<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" border="0" height="86" width="277"></a></td>
    <td align="center" width="337">
    <font size="7">System 库</font></td>
  </tr>
</tbody></table>

<table style="border-collapse: collapse;" bgcolor="#d7eeff" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">
  <tbody><tr>
    <td><a href="../../../index.htm">Boost Home</a>&nbsp;&nbsp;&nbsp; <a href="index.html">
    Library Home</a>&nbsp;&nbsp; Tutorial&nbsp;&nbsp; <a href="reference.html">
    Reference</a></td>
  </tr>
</tbody></table>

<table style="border-collapse: collapse;" align="right" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0">
  <tbody><tr>
    <td align="center" bgcolor="#d7eeff" width="100%">
      <i><b>Contents 目录</b></i></td>
  </tr>
  <tr>
    <td bgcolor="#e8f5ff" width="100%">
      <a href="#Introduction">Introduction 简介</a><br>
      <a href="#Macros">Macros 宏</a><br>
      <a href="#Deprecated-names">Deprecated names 不再使用的名字</a><br><a href="#Header-error_code">Header 头文件 &lt;boost/system/error_code.hpp&gt;</a><br>
      <a href="#Class-error_category">Class <code>error_category</code></a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_category-synopsis">Class <code>error_category</code> synopsis 概要</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_category-virtual-members">Class <code>error_category</code> virtual members 虚拟成员</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_category-non-virtual-members">Class <code>error_category</code> non-virtual members 非虚拟成员</a><br>
&nbsp;&nbsp; <a href="#Class-error_category-non-member-functions">Class <code>error_category</code> 
      non-member functions 非成员函数</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_category-predefined-objects">Class <code>error_category</code> predefined objects 预定义对象</a><br>
      <a href="#Class-error_code">Class <code>error_code</code></a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_code-synopsis">Class <code>error_code</code> synopsis 概要</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_code-constructors">Class <code>error_code</code> constructors 构造函数</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_code-modifiers">Class <code>error_code</code> modifiers 修改器</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_code-observers">Class <code>error_code</code> observers 观察器</a><br>
      <a href="#Class-error_condition%3C/code%3E">Class <code>error_condition</code></a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_condition-synopsis">Class <code>error_condition</code> synopsis 概要</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_condition-constructors">Class <code>error_condition</code> constructors 构造函数</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_condition-modifiers">Class <code>error_condition</code> modifiers 修改器</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-error_condition-observers">Class <code>error_condition</code> observers 观察器</a><br>
      <a href="#throws-object"><code>throws</code> 对象</a><br><a href="#Semantics-of-throws"><code>throws</code> 对象的语义</a><br><a href="#Non-member-functions">Non-member functions 非成员函数</a><br>
      <a href="#Header-system_error">Header 头文件 &lt;boost/system/system_error.hpp&gt;</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Class-system_error">Class <code>system_error</code></a><br>
    </td>
  </tr>
</tbody></table>

<h2><a name="Introduction">Introduction 简介</a></h2>

<p>This reference documentation describes components that&nbsp; 
programs may use to report error conditions originating from the operating 
system or other low-level application program interfaces.</p>
<p>本参考文档描述了程序员可能用于报告由操作系统或其它底层API所产生的错误条件的组件。</p>
<p>Boost.System library components never change the value of <code>
errno</code>.</p><p>Boost.System 库的组件不会修改 <code>
errno</code> 的值。</p>
<h2><a name="Macros">Macros 宏</a></h2>
<p>Users may defined the following macros if desired. Sensible defaults are 
provided, so users may ignore these macros if they prefer.</p>

  
    <p>如果需要，用户可以定义以下宏。库提供了合适的缺省值，所以只有用户愿意，也可以忽略这些宏。</p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0">
  <tbody><tr>
    <td><b><i>Macro Name 宏名</i></b></td>
    <td><b><i>Default 缺省值</i></b></td>
    <td><b><i>Effect if defined 定义后的作用</i></b></td>
  </tr>
  <tr>
    <td valign="top"><code>BOOST_WINDOWS_API</code></td>
    <td valign="top">Defined if Windows is detected by Boost.System's automatic configuration 
    code, otherwise not defined.<br>如果 Boost.System 的自动配置代码检测出系统为 Windows，则定义该宏，否则不定义。</td>
    <td valign="top">Implementation uses the Microsoft Windows native 
    application program interface (API).<br>具体实现使用 Microsoft Windows 的原生API。</td>
  </tr>
  <tr>
    <td valign="top"><code>BOOST_POSIX_API</code></td>
    <td valign="top">Defined if Windows is not detected by Boost.System's automatic configuration 
    code.<br>如果 Boost.System 的自动配置代码检测出系统不是 Windows，则定义该宏。</td>
    <td valign="top">Implementation uses the POSIX native 
    application program interface (API).<br>具体实现使用 POSIX 原生API。</td>
  </tr>
  <tr>
    <td valign="top"><code>BOOST_SYSTEM_DYN_LINK</code></td>
    <td valign="top">Defined if <code>BOOST_ALL_DYN_LINK</code> is defined, 
    otherwise not defined.<br>如果定义了 <code>BOOST_ALL_DYN_LINK</code>，则定义该宏，否则不定义。</td>
    <td valign="top">Boost.System library is dynamically linked. If not defined, 
    static linking is assumed.<br>Boost.System 库将动态链接的。如果未定义该宏，则假设是静态链接。</td>
  </tr>
  <tr>
    <td valign="top"><code>BOOST_SYSTEM_NO_LIB</code></td>
    <td valign="top">Defined if <code>BOOST_ALL_NO_LIB</code> is defined, 
    otherwise not defined.<br><code>如果定义了 BOOST_ALL_NO_LIB</code>，则定义该宏，否则不定义。</td>
    <td valign="top">Boost.System library does not use the Boost auto-link 
    facility.<br>Boost.System 库不使用 Boost 的自动链接工具。</td>
  </tr>
  <tr>
    <td valign="top"><code>BOOST_SYSTEM_NO_DEPRECATED</code></td>
    <td valign="top">Not defined.<br>不定义。</td>
    <td valign="top">Deprecated features are excluded.<br>将不建议使用的特性排除在外。</td>
  </tr>
</tbody></table>
<h2><a name="Deprecated-names">Deprecated names 不再使用的名字</a></h2>
<p>In the process of adding Boost.System to C++0x standard library, some of the 
names are being changed. To ease transition, Boost.System deprecates the old 
names, but continues to provide them unless macro 
<code>BOOST_SYSTEM_NO_DEPRECATED</code> is defined.<br>在将 Boost.System 增加到 C++0x 标准库的过程中，有些名字发生了变化。为了易于转变，Boost.System 不建议再使用旧的名字，不过会继续提供它们，除非定义了宏 
<code>BOOST_SYSTEM_NO_DEPRECATED</code>。</p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="1">
<tbody>
<tr>
<td><b><i>Old name, now deprecated<br>旧名字，现已不再使用</i></b></td>
<td><b><i>New name<br>新名字</i></b></td></tr>
<tr>
<td><code>namespace posix</code></td>
<td><code>namespace errc</code></td></tr>
<tr>
<td><code>namespace posix_error</code></td>
<td><code>namespace errc</code></td></tr>
<tr>
<td><code>enum posix_errno</code></td>
<td><code>enum errc_t</code></td></tr>
<tr>
<td><code>get_posix_category()</code></td>
<td><code>get_generic_category()</code></td></tr>
<tr>
<td><code>posix_category</code></td>
<td><code>generic_category</code></td></tr>
<tr>
<td><code>errno_ecat</code></td>
<td><code>generic_category</code></td></tr>
<tr>
<td><code>native_ecat</code></td>
<td><code>system_category</code></td></tr></tbody></table><h2><a name="Header-error_code">Header 头文件 &lt;boost/system/error_code.hpp&gt;</a></h2>
<h3>&lt;boost/system/error_code.hpp&gt; synopsis 概要</h3>
<blockquote>
<pre>namespace boost<br>{<br>  namespace system<br>  {<br>    class <a href="#Class-error_category">error_category</a>;<br>    class <a href="#Class-error_code">error_code</a>;<br>    class <a href="#Class-error_condition">error_condition</a>;<br><br>    //  "Concept" helpers<br>    template&lt; class T="" &gt;<br>      struct is_error_code_enum { static const bool value = false; };<br><br>    template&lt; class T="" &gt;<br>      struct is_error_condition_enum { static const bool value = false; };<br><br>    //  generic error_conditions<br>    namespace errc<br>    {<br>      enum errc_t<br>      {<br>        success = 0,<br>        address_family_not_supported,   //EAFNOSUPPORT<br>        address_in_use,                 //EADDRINUSE<br>        address_not_available,          //EADDRNOTAVAIL<br>        already_connected,              //EISCONN<br>        argument_list_too_long,         //E2BIG<br>        argument_out_of_domain,         //EDOM<br>        bad_address,                    //EFAULT<br>        bad_file_descriptor,            //EBADF<br>        bad_message,                    //EBADMSG<br>        broken_pipe,                    //EPIPE<br>        connection_aborted,             //ECONNABORTED<br>        connection_already_in_progress, //EALREADY<br>        connection_refused,             //ECONNREFUSED<br>        connection_reset,               //ECONNRESET<br>        cross_device_link,              //EXDEV<br>        destination_address_required,   //EDESTADDRREQ<br>        device_or_resource_busy,        //EBUSY<br>        directory_not_empty,            //ENOTEMPTY<br>        executable_format_error,        //ENOEXEC<br>        file_exists,                    //EEXIST<br>        file_too_large,                 //EFBIG<br>        filename_too_long,              //ENAMETOOLONG<br>        function_not_supported,         //ENOSYS<br>        host_unreachable,               //EHOSTUNREACH<br>        identifier_removed,             //EIDRM<br>        illegal_byte_sequence,          //EILSEQ<br>        inappropriate_io_control_operation,//ENOTTY<br>        interrupted,                    //EINTR<br>        invalid_argument,               //EINVAL<br>        invalid_seek,                   //ESPIPE<br>        io_error,                       //EIO<br>        is_a_directory,                 //EISDIR<br>        message_size,                   //EMSGSIZE<br>        network_down,                   //ENETDOWN<br>        network_reset,                  //ENETRESET<br>        network_unreachable,            //ENETUNREACH<br>        no_buffer_space,                //ENOBUFS<br>        no_child_process,               //ECHILD<br>        no_link,                        //ENOLINK<br>        no_lock_available,              //ENOLCK<br>        no_message_available,           //ENODATA<br>        no_message,                     //ENOMSG<br>        no_protocol_option,             //ENOPROTOOPT<br>        no_space_on_device,             //ENOSPC<br>        no_stream_resources,            //ENOSR<br>        no_such_device_or_address,      //ENXIO<br>        no_such_device,                 //ENODEV<br>        no_such_file_or_directory,      //ENOENT<br>        no_such_process,                //ESRCH<br>        not_a_directory,                //ENOTDIR<br>        not_a_socket,                   //ENOTSOCK<br>        not_a_stream,                   //ENOSTR<br>        not_connected,                  //ENOTCONN<br>        not_enough_memory,              //ENOMEM<br>        not_supported,                  //ENOTSUP<br>        operation_canceled,             //ECANCELED<br>        operation_in_progress,          //EINPROGRESS<br>        operation_not_permitted,        //EPERM<br>        operation_not_supported,        //EOPNOTSUPP<br>        operation_would_block,          //EWOULDBLOCK<br>        owner_dead,                     //EOWNERDEAD<br>        permission_denied,              //EACCES<br>        protocol_error,                 //EPROTO<br>        protocol_not_supported,         //EPROTONOSUPPORT<br>        read_only_file_system,          //EROFS<br>        resource_deadlock_would_occur,  //EDEADLK<br>        resource_unavailable_try_again, //EAGAIN<br>        result_out_of_range,            //ERANGE<br>        state_not_recoverable,          //ENOTRECOVERABLE<br>        stream_timeout,                 //ETIME<br>        text_file_busy,                 //ETXTBSY<br>        timed_out,                      //ETIMEDOUT<br>        too_many_files_open_in_system,  //ENFILE<br>        too_many_files_open,            //EMFILE<br>        too_many_links,                 //EMLINK<br>        too_many_synbolic_link_levels,  //ELOOP<br>        value_too_large,                //EOVERFLOW<br>        wrong_protocol_type             //EPROTOTYPE<br>      };<br><br>    } // namespace errc<br><br>    template&lt;&gt; struct is_error_condition_enum<posix::posix_errno>&lt;errc::errc_t&gt;<br>      { static const bool value = true; };<br><br>    bool operator==( const error_code &amp; lhs, const error_code &amp; rhs );<br>    bool operator==( const error_code &amp; code, const error_condition &amp; condition );<br>    bool operator==( const error_condition &amp; condition, const error_code &amp; code );<br>    bool operator==( const error_condition &amp; lhs, const error_condition &amp; rhs );<br><br>    bool operator!=( const error_code &amp; lhs, const error_code &amp; rhs );<br>    bool operator!=( const error_code &amp; code, const error_condition &amp; condition );<br>    bool operator!=( const error_condition &amp; condition, const error_code &amp; code );<br>    bool operator!=( const error_condition &amp; lhs, const error_condition &amp; rhs );<br><br>    bool operator&lt;( const error_code &amp; lhs, const error_code &amp; rhs );<br>    bool operator&lt;( const error_condition &amp; lhs, const error_condition &amp; rhs );<br><br>    error_code make_error_code( errc::errc_t e );<br>    error_condition make_error_condition( errc::errc_t e );<br><br>    template &lt;class charT, class traits&gt;<br>      std::basic_ostream&lt;charT,traits&gt;&amp;<br>        operator&lt;&lt;( basic_ostream&lt;charT,traits&gt;&amp; os, const error_code &amp; ec );<br><br>    size_t hash_value( const error_code &amp; ec );<br>  }<br>}</posix::posix_errno><posix::posix_errno></posix::posix_errno></pre>
</blockquote>
<p>The value of each<code> errc_t</code> constant shall be the same as the value 
of the <code>&lt;cerrno&gt;</code> macro shown in the above synopsis.<br>每个<code>&nbsp;</code><code>errc_t</code> 常量的值应该与以上概要中的 <code>&lt;cerrno&gt;</code> 宏的值相同。</p>
<p>Users may specialize <code>is_error_code_enum</code> and <code>
is_error_condition_enum</code> templates to indicate that a type is eligible for 
class <code>error_code</code> and <code>error_condition</code> automatic 
conversions respectively.<br>用户可以特化 <code>is_error_code_enum</code> 和 <code>
is_error_condition_enum</code> 模板，以表示某种符合条件的类型，可以分别自动转换为类 <code>error_code</code> 和 <code>error_condition</code>.</p>

<h2><a name="Class-error_category">Class <code>error_category</code></a></h2>
<p>The class <code>error_category</code> defines the base class for types used 
to identify the source and encoding of a particular category of error code.</p>
<p>类 <code>error_category</code> 定义了一个基类，用作标识某种特定的错误代码类别的源和编码的类型的基类。</p>
<p><i>[Note:</i> Classes may be derived from <code>error_category</code> 
to support additional categories of errors. <i>--end note]</i></p>
<p><i>[注:</i> 可以从 <code>error_category</code> 
派生出其它类，以支持其它错误类别。<i>--注完]</i></p>
<p>The class <code>error_category</code> serves as a base class for types used 
to identify the source and encoding of a particular category of error code. 
Classes may be derived from <code>error_category</code> to support categories of 
errors in addition to those defined in the Boost System library. Such classes 
shall behave as specified in this subclause. [<i> Note:</i> <code>error_category</code> 
objects are passed by reference, and two such objects are equal if they have the 
same address. This means that applications using custom <code>error_category</code> 
types should create a single object of each such type. <i>—end note</i> ]</p><p>类&nbsp;<code>error_category</code> 被用作标识某种特定的错误代码类别的源和编码的类型的基类。可以从 <code>error_category</code> 派生出其它类，以支持除了已在 Boost System 库中定义的错误类别之外错误。这些类应该遵守本条款中所规定的行为。[<i> 注:</i> <code>error_category</code> 
对象是按引用传递的，两个同类对象如果具有相同地址，就是相等的。这意味着使用客户化 <code>error_category</code> 类型的应用程序应该为每一种类型创建单一个对象。<i>—注完</i>]</p>
<h3><a name="Class-error_category-synopsis">Class <code>error_category</code> synopsis 概要</a></h3>
<blockquote>
<pre>namespace boost<br>{<br>  namespace system<br>  {<br>    class error_category : public noncopyable<br>    {<br>    public:<br>      virtual ~error_category();<br><br>      virtual const char *     name() const = 0;<br>      virtual string           message( error_code::value_type ev ) const = 0;<br>      virtual error_condition  default_error_condition( int ev ) const;<br>      virtual bool             equivalent( int code, const error_condition &amp; condition ) const;<br>      virtual bool             equivalent( const error_code &amp; code, int condition ) const;<br><br>      bool operator==( const error_category &amp; rhs ) const;<br>      bool operator!=( const error_category &amp; rhs ) const;<br>      bool operator&lt; ( const error_category &amp; rhs ) const;<br>    };<br><br>    const error_category &amp;  get_system_category();<br>    const error_category &amp;  get_generic_category();<br><br>    static const error_category &amp;  system_category = get_system_category();<br>    static const error_category &amp;  generic_category = get_generic_category();<br>  }<br>}</pre>
</blockquote>
<h3><a name="Class-error_category-virtual-members">Class <code>error_category</code> virtual members 虚拟成员</a></h3>
<p>Classes derived from <code>error_category</code> shall behave as specified in 
this subclause.</p>
<p><span style="font-family: monospace;">派生自</span> <code>error_category</code> 的类应该遵守本条款的行为。</p>
<pre>virtual const char * name() const=0;</pre>
<blockquote>
  <p><i>Returns: </i>a string naming the error category.</p>
  <p><i>返回: </i>错误类别的字符串名字。</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>virtual string message( error_code::value_type ev ) const=0;</pre>
<blockquote>
  <p><i>Returns:</i> A string that describes the error denoted by
  <code>ev</code>.</p>
  <p><i>返回:</i> 描述由
  <code>ev</code> 表示的错误的字符串。</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<p><code>virtual error_condition default_error_condition( int ev ) const;</code></p>
<blockquote>
  <p><i>Returns:</i>&nbsp; <code>error_condition( ev, *this )</code>.</p><p><i>返回:</i>&nbsp; <code>error_condition( ev, *this )</code>.</p>
  <blockquote>
    <p>[<i>--Note:</i> Derived classes will typically convert <code>ev</code> 
    to some portable <code>error_category</code>, such as&nbsp;<code>generic</code><code>_category</code>, 
    and return it as an <code>error_condition</code> for that category. <i>--end 
    note</i>]</p><p>[<i>--注:</i> 派生类通常会将 <code>ev</code> 
    转换为某个可移植的 <code>error_category</code>, 如&nbsp;<code>generic</code><code>_category</code>, 
    并将它作为该类别的 <code>error_condition</code> 返回。<i>--注完</i>]</p>
  </blockquote>
  <p><i>Throws:</i> Nothing.<i></i></p><p><i>抛出:</i> 无。</p>
</blockquote>
<p><code>virtual bool equivalent( int code, const error_condition &amp; 
condition ) 
const;</code></p>
<blockquote>
  <p><i>Returns:</i> <code>default_error_condition( code ) == condition</code>.</p>
  <p><i>返回:</i> <code>default_error_condition( code ) == condition</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<p><code>virtual bool equivalent( const error_code &amp; code, int condition ) const;</code></p>
<blockquote>
  <p><i>Returns:</i> <code>*this == code.category() &amp;&amp; code.value() == condition</code>.</p>
  <p><i>返回:</i> <code>*this == code.category() &amp;&amp; code.value() == condition</code>.</p>
  <p><i>Throws:</i> Nothing.<i></i></p><p><i>抛出:</i> 无。</p>
</blockquote>
<h3><a name="Class-error_category-non-virtual-members">Class <code>error_category</code> non-virtual members 非虚拟成员</a></h3>
<p><code>bool operator==( const error_category &amp; rhs ) const;</code></p>
<blockquote>
<p><i>Returns:</i> <code>this == &amp;rhs</code>.<i></i></p><p><i>返回:</i> <code>this == &amp;rhs</code>.</p>
</blockquote>
<p><code>bool operator!=( const error_category &amp; rhs ) const;</code></p>
<blockquote>
<p><i>Returns:</i> <code>this != &amp;rhs</code>.<i></i></p><p><i>返回:</i> <code>this != &amp;rhs</code>.</p>
</blockquote>

<pre>bool operator&lt;( const error_category &amp; rhs ) const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>std::less&lt;const error_category*&gt;()( this, &amp;rhs )</code>.</p><p><i>返回:</i> <code>std::less&lt;const error_category*&gt;()( this, &amp;rhs )</code>.</p>
  <blockquote>
    <p><i>[Note:</i> <code>std::less</code> provides a total ordering for 
    pointers. <i>--end note]<br>[注:</i> <code>std::less</code> 提供了对指针的全序关系。<i>--注完]</i></p>
  </blockquote>
  <p><i>Throws:</i> Nothing.<i></i></p><p><i>抛出:</i> 无。</p>
</blockquote>
<h3><a name="Class-error_category-non-member-functions">Class <code>error_category</code> 
non-member functions 非成员函数</a></h3>
<pre>const error_category &amp; get_system_category();</pre>
<blockquote>
  <p><i>Returns:</i> A reference to a <code>error_category</code> object 
  identifying errors originating from the operating system.</p>
  <p><i>返回:</i> 某个 <code>error_category</code> 对象的引用，表示错误来自于操作系统。</p>
  <p><i>Throws:</i> Nothing.<i></i></p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>const error_category &amp; get_generic_category();</pre>
<blockquote>
  <p><i>Returns:</i> A reference to a <code>error_category</code> object 
  identifying portable error conditions.</p>
  <p><i>返回:</i> 某个 <code>error_category</code> 对象的引用，表示可移植的错误条件。</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<h3><a name="Class-error_category-predefined-objects">Class <code>error_category</code> 
predefined objects 预定义对象</a></h3>
<p>Predefined objects <code>system_category</code> 
and&nbsp;generic<code>_category</code> identify operating system error codes and portable error conditions, respectively.</p><p>预定义对象 <code>system_category</code> 和&nbsp;generic<code>_category</code> 分别表示操作系统错误代码和可移植错误条件。</p>
<h2><a name="Class-error_code">Class <code>
error_code</code></a></h2>
<p>The class <code>error_code</code> describes an object used to hold error code 
values, such as those originating from the operating system or other low-level application program interfaces. <i>[ Note: </i>Class
<code>error_code</code> is an adjunct to error reporting by exception. <i>—end note ]</i></p><p>类 <code>error_code</code> 描述了一个对象，它用于保存错误代码值，这些错误代码来自于操作系统或其它底层API。<i>[ 注: </i>类
<code>error_code</code> 是以异常方式报告错误的辅助手段。<i>—注完 ]</i></p>
<h3><a name="Class-error_code-synopsis">Class <code>
error_code</code> synopsis 概要</a></h3>
<blockquote>
<pre>namespace boost<br>{<br>  namespace system<br>  {<br>    class error_code {<br>    public:<br><br>      // constructors: 构造函数<br>      error_code();<br>      error_code( val, const error_category &amp; cat );<br>      template &lt;class <code>ErrorCodeEnum</code>&gt;<br>        error_code(<code> errorCodeEnum</code> e,<br>         typename enable_if&lt;is_error_code_enum&lt;<code>ErrorCodeEnum</code>&gt; &gt;::type* = 0);<br><br>      // modifiers: 修改器<br>      void assign( int val, const error_category &amp; cat );<br>      template&lt;typename <code>ErrorCodeEnum</code>&gt;<br>        typename enable_if&lt;is_error_code_enum&lt;<code>ErrorCodeEnum</code>&gt;, error_code&gt;::type &amp;<br>          operator=( <code>ErrorCodeEnum</code> val );;<br>      void clear();<br><br>      // observers: 观察器<br>      int                    value() const;<br>      cont error_category &amp;  category() const;<br>      error_condition        default_error_condition() const;<br>      string                 message() const;<br>      operator unspecified-bool-type() const;<br><br>    private:<br>      int val_;                     // <i>exposition only 仅用于说明</i>
      const error_category &amp; cat_;  // <i>exposition only 仅用于说明</i>
    };
  }
}</pre>
</blockquote>
<h3><a name="Class-error_code-constructors">Class <code>
error_code</code> constructors 构造函数</a></h3>
<pre>error_code();</pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type <code>error_code</code>.</p>
  <p><i>作用: </i>构造类型 <code>error_code</code> 的一个对象。</p>
  <p><i>Postconditions:</i> <code>val_ == 0 &amp;&amp; cat_ == &amp;system_category</code>.</p>
  <p><i>后置条件:</i> <code>val_ == 0 &amp;&amp; cat_ == &amp;system_category</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>error_code( int val, const error_category &amp; cat );</pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type <code>error_code</code>.</p>
  <p><i>作用: </i>构造类型 <code>error_code</code> 的一个对象。</p>
  <p><i>Postconditions:</i> <code>val_ == val &amp;&amp; cat_ == &amp;cat</code>.</p>
  <p><i>后置条件:</i> <code>val_ == val &amp;&amp; cat_ == &amp;cat</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>template &lt;class <code>ErrorCodeEnum</code>&gt;<br>  error_code(<code> errorCodeEnum</code> val,<br>    typename enable_if&lt;is_error_code_enum&lt;<code>ErrorCodeEnum</code>&gt; &gt;::type* = 0);</pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type <code>error_code</code>.</p>
  <p><i>作用: </i>构造类型 <code>error_code</code> 的一个对象。</p>
  <p><i>Postconditions:</i> <code>*this == make_error_code( val )</code>.</p>
  <p><i>后置条件:</i> <code>*this == make_error_code( val )</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<h3><a name="Class-error_code-modifiers">Class <code>
error_code</code> modifiers 修改器</a></h3>
<pre>void assign( int val, const error_category &amp; cat );</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>val_ == val &amp;&amp; cat_ == cat</code>.</p>
  <p><i>后置条件:</i> <code>val_ == val &amp;&amp; cat_ == cat</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>template&lt;typename <code>ErrorCodeEnum</code>&gt;<br>  typename enable_if&lt;is_error_code_enum&lt;<code>ErrorCodeEnum</code>&gt;, error_code&gt;::type &amp;<br>    operator=( <code>ErrorCodeEnum</code> val );</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>*this == make_error_code( val )</code>.</p>
  <p><i>后置条件:</i> <code>*this == make_error_code( val )</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<p><code>void clear();</code></p>
<blockquote>
  <p><i>postcondition:</i> <code>value() == 0 &amp;&amp; category() == posix_category</code><br><i>后置条件:</i> <code>value() == 0 &amp;&amp; category() == posix_category</code></p>
</blockquote>
  <h3><a name="Class-error_code-observers">Class <code>
error_code</code> observers 观察器</a></h3>
  <p><code>int value() const;</code></p>
<blockquote>
<p><i>Returns:</i> <code>val_</code>.</p>
  <p><i>返回:</i> <code>val_</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
  <p><code>error_category category() const;</code></p>
<blockquote>
<p><i>Returns:</i> <code>cat_</code>.</p>
  <p><i>返回:</i> <code>cat_</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
  <pre>error_condition default_error_condition() const;</pre>
<blockquote>
<p><i>Returns:</i>&nbsp; <code>category().default_error_condition( value())</code>.</p>
  <p><i>返回:</i>&nbsp; <code>category().default_error_condition( value())</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
  <p><code>string message() const;</code></p>
<blockquote>
<p><i>Returns:</i>&nbsp; <code>category().message( value())</code>.</p>
  <p><i>返回:</i>&nbsp; <code>category().message( value())</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<p><code>operator <i>unspecified-bool-type</i>() const;</code></p>
<blockquote>
<p><i>Returns:</i> if <code>value() != value_type()</code>, returns a value that will evaluate
<code>true</code> in a boolean context; otherwise, returns a value that will 
evaluate <code>false</code> in a boolean context. The value type returned shall 
not be convertible to <code>int</code>.</p>
<p><i>返回:</i> 如果 <code>value() != value_type()</code>, 则返回一个在布尔上下文中被求值为
<code>true</code> 的值，否则返回一个在布尔上下文中被求值为 <code>false</code> 的值。被返回的值类型不应可转换为 <code>int</code>.</p>
<p><i>Throws:</i> nothing.</p><p><i>抛出:</i> 无。</p>
<p><i>[Note: </i>This conversion can be used in contexts where a <code>bool</code> 
is expected ( e.g., an <code>if</code> condition ); however, implicit conversions 
( e.g., to <code>int</code>) that can occur with <code>bool</code> are not 
allowed, eliminating some sources of user error. One possible implementation 
choice for this type is pointer-to-member. <i>--end note ]</i></p><p><i>[注: </i>该转换可用于需要一个 <code>bool</code> 
值的上下文中(如一个 <code>if</code> 条件中); 但是，又不允许隐式转换(如转换为 <code>int</code>)发生在 <code>bool</code> 值上，以消除某些用户错误源。该类型的一个可能的实现选择是成员指针。<i>--注完]</i></p>
</blockquote>
<h2><a name="Class-error_condition">Class <code>error_condition</code></a></h2>
<p>The class <code>error_condition</code> describes an object used to hold 
values identifying error conditions. <i>[ Note: </i><code>error_condition</code> 
values are portable abstractions, while <code>error_code</code> values are 
implementation specific. <i>--end note ]</i></p><p>类 <code>error_condition</code> 描述一个对象，用于保存表示错误条件的值。<i>[ 注: </i><code>error_condition</code> 
值是可移植的抽象值，而 <code>error_code</code> 值则是实现指定的。<i>--注完 ]</i></p>
<h3><a name="Class-error_condition-synopsis">Class <code>error_condition</code> synopsis 概要</a></h3>
<blockquote>
<pre>namespace boost<br>{<br>  namespace system<br>  {<br>    class error_condition<br>    {<br>    public:<br><br>      // constructors: 构造函数<br>      error_condition();<br>      error_condition( int val, const error_category &amp; cat );<br>      template &lt;class ErrorConditionEnum&gt;<br>        error_condition( errorConditionEnum val,<br>          typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt; &gt;::type* = 0 );<br><br>      // modifiers: 修改器<br>      void assign( int val, const error_category &amp; cat );<br>      template&lt;typename ErrorConditionEnum&gt;<br>        typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;, error_code&gt;::type &amp;<br>          operator=( ErrorConditionEnum val );<br>      void clear();<br><br>      // observers: 观察器<br>      int value() const;<br>      const error_category &amp; category() const;<br>      string message() const;<br>      operator unspecified-bool-type () const;<br><br>    private:<br>      int val_;                     // <i>exposition only 仅用于说明</i>
      const error_category &amp; cat_;   // <i>exposition only 仅用于说明</i>
    };
  }
}</pre>
</blockquote>
<h3><a name="Class-error_condition-constructors">Class <code>error_condition</code> 
constructors 构造函数</a></h3>
<pre>error_condition(); </pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of type <code>error_condition</code>.</p>
  <p><i>作用:</i> 构造类型 <code>error_condition</code> 的一个对象。</p>
  <p><i>Postconditions:</i> <code>val_ == 0 and cat_ ==&nbsp;</code>generic<code>_category</code>.</p>
  <p><i>后置条件:</i> <code>val_ == 0 且 cat_ ==&nbsp;</code>generic<code>_category</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>error_condition( value_type val, const error_category &amp; cat );</pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type error_condition.</p>
  <p><i>作用: </i>构造类型 error_condition 的一个对象。</p>
  <p><i>Postconditions:</i> <code>val_ == val and cat_ == cat</code>.</p>
  <p><i>后置条件:</i> <code>val_ == val 且 cat_ == cat</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>template &lt;class ErrorConditionEnum&gt;<br>  error_condition( errorConditionEnum val,<br>    typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt; &gt;::type* = 0 );</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of type <code>error_condition</code>.</p>
  <p><i>作用:</i> 构造类型 <code>error_condition</code> 的一个对象。</p>
  <p><i>Postconditions:</i> <code>*this == make_error_condition( val )</code>.</p>
  <p><i>后置条件:</i> <code>*this == make_error_condition( val )</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<h3><a name="Class-error_condition-modifiers">Class <code>error_condition</code> 
modifiers 修改器</a></h3>
<pre>void assign( value_type val, const error_category &amp; cat ); </pre>
<blockquote>
  <p><i>Postconditions:</i> <code>val_ == val and cat_ == cat</code>. </p>
  <p><i>后置条件:</i> <code>val_ == val 且 cat_ == cat</code>. </p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>template&lt;typename ErrorConditionEnum&gt;<br>  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;, error_code&gt;::type &amp;<br>    operator=( ErrorConditionEnum val );</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>*this == make_error_condition( val )</code>.</p>
  <p><i>后置条件:</i> <code>*this == make_error_condition( val )</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<p><code>void clear();</code></p>
<blockquote>
  <p><i>postcondition:</i> <code>value() == 0 &amp;&amp; category() ==&nbsp;</code>generic<code>_category</code><br><i>后置条件:</i> <code>value() == 0 &amp;&amp; category() ==&nbsp;</code>generic<code>_category</code></p>
</blockquote>
<h3><a name="Class-error_condition-observers">Class <code>error_condition</code> 
observers 观察器</a></h3>
<pre>value_type value() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>val_</code>.</p>
  <p><i>返回:</i> <code>val_</code>.</p>
  <p><i>Throws:</i> Nothing</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>const error_category &amp; category() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>cat_</code>.</p>
  <p><i>返回:</i> <code>cat_</code>.</p>
  <p>Throws: Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>string message() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>category().message( value() )</code>.</p>
  <p><i>返回:</i> <code>category().message( value() )</code>.</p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>operator unspecified-bool-type () const;</pre>
<blockquote>
  <p><i>Returns: </i>If <code>value() != 0</code>, returns a value that will 
  evaluate <code>true</code> in a boolean context; otherwise, returns a value 
  that will evaluate <code>false</code>. The return type shall not be 
  convertible to <code>int</code>. </p>
  <p><i>返回: </i>如果 <code>value() != 0</code>, 则返回一个在布尔上下文中被求值为 <code>true</code> 的值，否则返回一个在布尔上下文中被求值为 <code>false</code> 的值。返回的类型应不可转换为 <code>int</code>. </p>
  <p><i>Throws:</i> Nothing.</p><p><i>抛出:</i> 无。</p>
  <p><i>&nbsp;[ Note:</i> This conversion can be used in contexts where a <code>bool</code> 
  is expected ( e.g., an if condition ); however, implicit conversions ( e.g., to
  <code>int</code>) that can occur with <code>bool</code> are not allowed, 
  eliminating some sources of user error. One possible implementation choice for 
  this type is pointer to member. <i>--end note</i> <i>]</i></p><p><i>[注: </i>该转换可用于需要一个 <code>bool</code> 
值的上下文中(如一个 <code>if</code> 条件中); 但是，又不允许隐式转换(如转换为 <code>int</code>)发生在 <code>bool</code> 值上，以消除某些用户错误源。该类型的一个可能的实现选择是成员指针。<i>--注完]</i></p>
</blockquote>
  <h2><a name="throws-object"><code>throws</code> 对象</a></h2><pre>extern error_code throws;</pre>
<p>The predefined <code>error_code</code> object <code>throws</code> is supplied 
for use as a "throw on error" tag.<br>预定义的 <code>error_code</code> 对象 <code>throws</code> 被提供作为一个"错误时抛出"的标签使用。</p>
<h2><a name="Semantics-of-throws"><code>throws</code></a> 对象的语义</h2>
<p>Functions that specify an argument in the form <code>error_code&amp; 
ec=throws</code>, with appropriate namespace qualifiers, have the following 
error handling semantics:<br>以 <code>error_code&amp; 
ec=throws</code> 形式指定一个参数并带有适当的名字空间限定符的函数，具有以下错误处理语义：</p>
<blockquote>
<p><i>Postconditions:<br>后验条件：</i></p>
<blockquote>
<p>If <code>&amp;ec != &amp;throws</code> and an error occurred:<br>如果 <code>&amp;ec != &amp;throws</code> 且发生了错误：</p>
<ul><li><code>ec.value()</code> returns the implementation specific error number for 
the particular error that occurred.<br><code>ec.value()</code> 返回与所发生的特定错误相应的错误码。 
</li><li><code>ec.category()</code> returns the <code><a href="#Class-error_category">error_category</a></code> for 
<code>ec.value()</code>.<br><code>ec.category()</code> 返回
<code>ec.value()</code> 的 <code><a href="reference.html#Class-error_category">error_category</a></code>&nbsp;。 </li></ul>
<p>if <code>&amp;ec != &amp;throws</code> and an error did not occur, 
<code>ec.clear()</code>.<br>如果 <code>&amp;ec != &amp;throws</code> 且没有发生错误，则 
<code>ec.clear()</code>。</p></blockquote>
<p><i>Throws:<br>抛出：</i></p>
<blockquote>
<p>If an error occurs and <code>&amp;ec == &amp;throws</code>, throws an 
exception of type <code><a href="#Class-system_error">system_error</a></code> or 
of a type derived from <code><a href="#Class-system_error">system_error</a></code>. The exception's 
<code>code()</code> member function returns a reference to an 
<code>error_code</code> object with the behavior specified in 
<i>Postconditions</i>.<br>如果发生了错误且 <code>&amp;ec == &amp;throws</code>，则抛出一个类型为 <code><a href="reference.html#Class-system_error">system_error</a></code> 或派生自 <code><a href="reference.html#Class-system_error">system_error</a></code> 的异常。该异常的
<code>code()</code> 成员函数将返回一个 
<code>error_code</code> 对象的引用，该对象具有在 
<i>后验条件</i> 中所说的行为。</p></blockquote></blockquote><h2><a name="Non-member-functions">Non-member functions 非成员函数</a></h2>
  <pre>bool operator==( const error_code &amp; lhs, const error_code &amp; rhs );</pre>
<blockquote>
  <p><i>Returns:</i> <code>lhs.category() == rhs.category() &amp;&amp; lhs.value() == 
  rhs.value()</code>.</p>
  <p><i>返回:</i> <code>lhs.category() == rhs.category() &amp;&amp; lhs.value() == 
  rhs.value()</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>bool operator==( const error_code &amp; code, const error_condition &amp; condition );<br>bool operator==( const error_condition &amp; condition, const error_code &amp; code );</pre>
<blockquote>
  <p><i>Returns:</i> <code>code.category().equivalent( code.value(), condition )<br>
  || condition.category().equivalent( code, condition.value() )</code>.</p>
  <p><i>返回:</i> <code>code.category().equivalent( code.value(), condition )<br>
  || condition.category().equivalent( code, condition.value() )</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>bool operator==( const error_condition &amp; lhs, const error_condition &amp; rhs );</pre>
<blockquote>
  <p><i>Returns:</i> <code>lhs.category() == rhs.category() &amp;&amp; lhs.value() == 
  rhs.value()</code>.</p>
  <p><i>返回:</i> <code>lhs.category() == rhs.category() &amp;&amp; lhs.value() == 
  rhs.value()</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>bool operator!=( const error_code &amp; lhs, const error_code &amp; rhs );</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs == rhs )</code>.</p>
  <p><i>返回:</i> <code>!(lhs == rhs )</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>bool operator!=( const error_code &amp; code, const error_condition &amp; condition );<br>bool operator!=( const error_condition &amp; condition, const error_code &amp; code );</pre>
<blockquote>
  <p><i>Returns:</i><code> !( code ==&nbsp; condition )</code>.</p>
  <p><i>返回:</i><code> !( code ==&nbsp; condition )</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>bool operator!=( const error_condition &amp; lhs, const error_condition &amp; rhs );</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs == rhs )</code>.</p>
  <p><i>返回:</i> <code>!(lhs == rhs )</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>bool operator&lt;( const error_code &amp; lhs, const error_code &amp; rhs );</pre>
<blockquote>
  <p><i>Returns:</i> <code>lhs.category() &lt; rhs.category()<br>
  &nbsp; || (lhs.category() == rhs.category() &amp;&amp; lhs.value() &lt; rhs.value())</code>.</p>
  <p><i>返回:</i> <code>lhs.category() &lt; rhs.category()<br>
  &nbsp; || (lhs.category() == rhs.category() &amp;&amp; lhs.value() &lt; rhs.value())</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>bool operator&lt;( const error_condition &amp; lhs, const error_condition &amp; rhs );</pre>
<blockquote>
  <p><i>Returns:</i> <code>lhs.category() &lt; rhs.category()<br>
  &nbsp; || (lhs.category() == rhs.category() &amp;&amp; lhs.value() &lt; rhs.value())</code>.</p>
  <p><i>返回:</i> <code>lhs.category() &lt; rhs.category()<br>
  &nbsp; || (lhs.category() == rhs.category() &amp;&amp; lhs.value() &lt; rhs.value())</code>.</p>
  <p><i>Throws: </i>Nothing.</p><p><i>抛出:</i> 无。</p>
</blockquote>
<pre>error_code make_error_code( errc::errc_t e );</pre>
<blockquote>
  <p><i>Returns:</i> <code>error_code( e,&nbsp;</code>generic<code>_category)</code>.</p><p><i>返回:</i> <code>error_code( e,&nbsp;</code>generic<code>_category)</code>.</p>
</blockquote>
<pre>error_condition make_error_condition( errc::errc_t e );</pre>
<blockquote>
  <p><i>Returns:</i> <code>error_condition( e,&nbsp;</code>generic<code>_category)</code>.</p><p><i>返回:</i> <code>error_condition( e,&nbsp;</code>generic<code>_category)</code>.</p>
</blockquote>

<pre>template &lt;class charT, class traits&gt;<br>  std::basic_ostream&lt;charT,traits&gt;&amp;<br>    operator&lt;&lt;( basic_ostream&lt;charT,traits&gt;&amp; os, const error_code &amp; ec );</pre>
<blockquote>
<p><i>Effects:</i> <code>os &lt;&lt; ec.category().name() &lt;&lt; ':' &lt;&lt; ec.value()</code>.</p>
<p><i>作用:</i> <code>os &lt;&lt; ec.category().name() &lt;&lt; ':' &lt;&lt; ec.value()</code>.</p>
<p><i>Returns:</i> <code>os</code>.</p><p><i>返回:</i> <code>os</code>.</p>
</blockquote>
<pre>size_t <a name="hash_value">hash_value</a>( const error_code &amp; ec );</pre>
<blockquote>
  <p><i>Returns: </i>&nbsp;A hash value representing <code>ec</code>.</p><p><i>返回: </i>&nbsp;一个表示 <code>ec</code> 的散列值。</p>
</blockquote>

<h2><a name="Header-system_error">Header 头文件 &lt;boost/system/system_error.hpp&gt;</a></h2>

<h3><a name="Class-system_error">Class <code>
system_error</code></a></h3>
<p>The class <code>system_error</code> describes an exception object used to 
report error conditions that have an associated error code. Such error 
conditions typically originate from the operating system or other low-level 
application program interfaces.</p>

<p>类&nbsp;<code>system_error</code> 描述了一个异常对象，用于报告具有关联错误代码的错误条件。这类错误条件通常来自于操作系统或其它底层API。</p>
<blockquote>
<pre>namespace boost<br>{<br>  namespace system<br>  {<br>    class system_error : public std::runtime_error<br>    {<br>    public:<br>      system_error( error_code ec );<br>      system_error( error_code ec, const char * what_arg );<br>      system_error( error_code ec, const std::string &amp; what_arg );<br>      system_error( error_code::value_type ev, const error_category &amp; ecat,<br>                    const char * what_arg );<br>      system_error( error_code::value_type ev, const error_category &amp; ecat,<br>                    const std::string &amp; what_arg );<br>      system_error( error_code::value_type ev, const error_category &amp; ecat);<br><br>      const error_code &amp; code() const throw();<br>      const char *       what() const throw();<br>    };<br>  }<br>}</pre>
</blockquote>
<pre>system_error( error_code ec );</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of class <code>system_error</code>.</p>
  <p><i>作用:</i> 构造一个 <code>system_error</code> 类的对象。</p>
  <p><i>Postcondition:</i> <code>code() == ec <br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), "" ) == 0</code></p><p><i>后置条件:</i> <code>code() == ec <br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), "" ) == 0</code></p>
</blockquote>
<pre>system_error( error_code ec, const char * what_arg );<br></pre><blockquote>

<p><i>Effects:</i> Constructs an object of class <code>system_error</code>.<br><i>作用:</i> 构造一个 <code>system_error</code> 类的对象。</p><p><i>Postcondition:</i> <code>code() == ec <br>&nbsp; &amp;&amp; std::strcmp( 
this-&gt;runtime_error::what(), what_arg ) == 0</code></p><p><i>后置条件:</i> <code>code() == ec <br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), what_arg ) == 0</code></p></blockquote><pre>system_error( error_code ec, const std::string &amp; what_arg );</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of class <code>system_error</code>.</p>
  <p><i>作用:</i> 构造一个 <code>system_error</code> 类的对象。</p>
  <p><i>Postcondition:</i> <code>code() == ec <br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), what_arg.c_str() ) == 0</code></p><p><i>后置条件:</i> <code>code() == ec <br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), what_arg.c_str() ) == 0</code></p>
</blockquote>
<pre>system_error( error_code::value_type ev, const error_category &amp; ecat,<br>             const char * what_arg );<br></pre><blockquote>
<p><i>Effects:</i> Constructs an object of class <code>system_error</code>.<i></i></p><p><i>作用:</i> 构造一个 <code>system_error</code> 类的对象。</p>
<p><i>Postcondition:</i> <code>code() == error_code( ev, ecat )<br>&nbsp; &amp;&amp; 
std::strcmp( this-&gt;runtime_error::what(), what_arg ) == 
0</code></p><p><i>后置条件:</i> <code>code() == error_code( ev, ecat )<br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), what_arg ) == 0</code></p></blockquote><pre>system_error( error_code::value_type ev, const error_category &amp; ecat,<br>             const std::string &amp; what_arg );</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of class <code>system_error</code>.</p>
  <p><i>作用:</i> 构造一个 <code>system_error</code> 类的对象。</p>
  <p><i>Postcondition:</i> <code>code() == error_code( ev, ecat )<br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), what_arg.c_str() ) == 0</code></p><p><i>后置条件:</i> <code>code() == error_code( ev, ecat )<br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), what_arg.c_str() ) == 0</code></p>
</blockquote>
<pre>system_error( error_code::value_type ev, const error_category &amp; ecat );</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of class <code>system_error</code>.</p>
  <p><i>作用:</i> 构造一个 <code>system_error</code> 类的对象。</p>
  <p><i>Postcondition:</i> <code>code() == error_code( ev, ecat )<br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), "" ) == 0</code></p><p><i>后置条件:</i> <code>code() == error_code( ev, ecat )<br>
&nbsp; &amp;&amp; std::strcmp( this-&gt;runtime_error::what(), "" ) == 0</code></p>
</blockquote>
<pre>const error_code &amp; code() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>ec</code> or <code>error_code( ev, ecat )</code>, from 
  the constructor, as appropriate.</p><p><i>返回:</i> <code>ec</code> 或 <code>error_code( ev, ecat )</code>, 来自于构造函数。</p>
</blockquote>
<pre>const char * what() const;</pre>
<blockquote>
  <p><i>Returns: </i>A string incorporating <code>
  this-&gt;runtime_error::what()</code> and <code>
  code.message()</code>.</p><p><i>返回: </i>一个合并了 <code>
  this-&gt;runtime_error::what()</code> 和 <code>
  code.message()</code> 的字符串。</p>
</blockquote>
<hr><p>Revised <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%B %d, %Y" startspan -->October 
11, 2008<!--webbot bot="Timestamp" endspan i-checksum="30976" --> </p>
<p>© Copyright Beman Dawes, 2006, 2007, 2008</p>
<p>Distributed under the Boost Software License, Version 1.0. See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p></body></html>
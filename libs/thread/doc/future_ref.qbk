[/
  (C) Copyright 2008-9 Anthony Williams.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:reference Futures Reference  Futures参考手册]

[section:future_state `state` enum]

    namespace future_state
    {
        enum state {uninitialized, waiting, ready};
    }

[endsect]

[section:unique_future `unique_future` class template]

    template <typename R>
    class unique_future
    {
        unique_future(unique_future & rhs);// = delete;
        unique_future& operator=(unique_future& rhs);// = delete;

    public:
        typedef future_state::state state;

        unique_future();
        ~unique_future();

        // move support
        unique_future(unique_future && other);
        unique_future& operator=(unique_future && other);

        void swap(unique_future& other);

        // retrieving the value
        R&& get();        

        // functions to check state
        state get_state() const;
        bool is_ready() const;        
        bool has_exception() const;        
        bool has_value() const;        

        // waiting for the result to be ready
        void wait() const;        
        template<typename Duration>
        bool timed_wait(Duration const& rel_time) const;
        bool timed_wait_until(boost::system_time const& abs_time) const;
    };

[section:default_constructor Default Constructor 缺省构造函数]

    unique_future();

[variablelist

[[Effects:] [Constructs an uninitialized future.\n
构造一个未初始化的期货。]]

[[Postconditions:] [[unique_future_is_ready_link `this->is_ready`] returns `false`. [unique_future_get_state_link
`this->get_state()`] returns __uninitialized__.\n
[unique_future_is_ready_link `this->is_ready`] 返回 `false`。
[unique_future_get_state_link `this->get_state()`] 返回 __uninitialized__。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:destructor Destructor 析构函数]

    ~unique_future();

[variablelist

[[Effects:] [Destroys `*this`.\n
销毁 `*this`。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:move_constructor Move Constructor 转移构造函数]

    unique_future(unique_future && other);

[variablelist

[[Effects:] [Constructs a new future, and transfers ownership of the asynchronous result associated with `other` to `*this`.\n
构造一个新期货，并将与 `other` 相关联的异步结果的所有权转移给 `*this`。]]

[[Postconditions:] [[unique_future_get_state_link `this->get_state()`] returns the value of `other->get_state()` prior to the
call. `other->get_state()` returns __uninitialized__. If `other` was associated with an asynchronous result, that result is now
associated with `*this`. `other` is not associated with any asynchronous result.\n
[unique_future_get_state_link `this->get_state()`] 返回调用之前的 `other->get_state()` 的值。`other->get_state()` 返回
__uninitialized__。如果 `other` 与某个异步结果相关联，则该结果现在关联至 `*this`。`other` 不再关联任何异步结果。]]

[[Throws:] [Nothing.\n
无。]]

[[Notes:] [If the compiler does not support rvalue-references, this is implemented using the boost.thread move emulation.\n
如果编译器不支持右值引用，则使用 boost.thread 的转移仿真来实现。]]

]

[endsect]

[section:move_assignment Move Assignment Operator 转移赋值操作符]

    unique_future& operator=(unique_future && other);

[variablelist

[[Effects:] [Transfers ownership of the asynchronous result associated with `other` to `*this`.\n
将与 `other` 相关联的异步结果的所有权转移至 `*this`。]]

[[Postconditions:] [[unique_future_get_state_link `this->get_state()`] returns the value of `other->get_state()` prior to the
call. `other->get_state()` returns __uninitialized__. If `other` was associated with an asynchronous result, that result is now
associated with `*this`. `other` is not associated with any asynchronous result. If `*this` was associated with an asynchronous
result prior to the call, that result no longer has an associated __unique_future__ instance.\n
[unique_future_get_state_link `this->get_state()`] 返回调用之前的 `other->get_state()` 的值。`other->get_state()` 返回
__uninitialized__。如果 `other` 与某个异步结果相关联，则该结果现在关联至 `*this`。`other` 不再关联任何异步结果。
如果在调用之前 `*this` 与某个异步结果相关联，则该结果不再有相关联的 __unique_future__ 实例。]]

[[Throws:] [Nothing.\n
无。]]

[[Notes:] [If the compiler does not support rvalue-references, this is implemented using the boost.thread move emulation.\n
如果编译器不支持右值引用，则使用 boost.thread 的转移仿真来实现。]]

]

[endsect]

[section:swap Member function `swap()`]

    void swap(unique_future & other);

[variablelist

[[Effects:] [Swaps ownership of the asynchronous results associated with `other` and `*this`.\n
交换 `other` 和 `*this` 所关联的异步结果的所有权。]]

[[Postconditions:] [[unique_future_get_state_link `this->get_state()`] returns the value of `other->get_state()` prior to the
call. `other->get_state()` returns the value of `this->get_state()` prior to the call. If `other` was associated with an
asynchronous result, that result is now associated with `*this`, otherwise `*this` has no associated result. If `*this` was
associated with an asynchronous result, that result is now associated with `other`, otherwise `other` has no associated result.\n
[unique_future_get_state_link `this->get_state()`] 返回调用之前的 `other->get_state()` 的值。`other->get_state()` 返回调用之前的
`this->get_state()` 的值。如果 `other` 与某个异步结果相关联，则该结果现在关联至 `*this`，否则 `*this` 没有所关联的结果。
如果 `*this` 之前与某个异步结果相关联，则该结果现在关联至 `other`，否则 `other` 没有所关联的结果。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]


[section:get Member function `get()`]

    R&& get();
    R& unique_future<R&>::get();
    void unique_future<void>::get();

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready as-if by a call to
__unique_future_wait__, and retrieves the result (whether that is a value or an exception).\n
如果 `*this` 关联于某个异步结果，则等待至该结果准备好，就如调用 __unique_future_wait__，并取出该结果(不论是一个值还是一个异常)。]]

[[Returns:] [If the result type `R` is a reference, returns the stored reference. If `R` is `void`, there is no return
value. Otherwise, returns an rvalue-reference to the value stored in the asynchronous result.\n
如果结果类型 `R` 是一个引用，则返回所保存的引用。如果 `R` 为 `void`，则没有返回值。否则，返回保存在异步结果中的值的右值引用。]]

[[Postconditions:] [[unique_future_is_ready_link `this->is_ready()`] returns `true`. [unique_future_get_state_link
`this->get_state()`] returns __ready__.\n
[unique_future_is_ready_link `this->is_ready()`] 返回 `true`。[unique_future_get_state_link `this->get_state()`] 返回 __ready__。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the result
associated with `*this` is not ready at the point of the call, and the current thread is interrupted. Any exception stored in the
asynchronous result in place of a value.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。任何异常均被保存在异步结果中，替代结果值。]]

[[Notes:] [`get()` is an ['interruption point].\n
`get()` 是一个 ['中断点]。]]

]

[endsect]

[section:wait Member function `wait()`]

    void wait();

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready. If the result is not ready on
entry, and the result has a ['wait callback] set, that callback is invoked prior to waiting.\n
如果 `*this` 关联于某个异步结果，则等待直至该结果准备好。如果在入口处结果未准备好，且该结果有一个['等待回调]集合，
则在等待之前执行回调。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the result
associated with `*this` is not ready at the point of the call, and the current thread is interrupted. Any exception thrown by the
['wait callback] if such a callback is called.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。如果某个回调被调用，则任何由['等待回调]抛出的异常也会被抛出。]]

[[Postconditions:] [[unique_future_is_ready_link `this->is_ready()`] returns `true`. [unique_future_get_state_link
`this->get_state()`] returns __ready__.\n
[unique_future_is_ready_link `this->is_ready()`] 返回 `true`. [unique_future_get_state_link `this->get_state()`] 返回 __ready__。]]

[[Notes:] [`wait()` is an ['interruption point].\n
`wait()` 是一个 ['中断点]。]]

]

[endsect]

[section:timed_wait_duration Member function `timed_wait()`]

    template<typename Duration>
    bool timed_wait(Duration const& wait_duration);

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready, or the time specified by
`wait_duration` has elapsed. If the result is not ready on entry, and the result has a ['wait callback] set, that callback is
invoked prior to waiting.\n
如果 `*this` 关联于某个异步结果，则等待直至该结果准备好，或是达到由 `wait_duration` 给定的时间。如果在入口处结果未准备好，
且该结果有一个['等待回调]集合，则在等待之前执行回调。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, and that result is ready before the specified time has
elapsed, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且在指定时间到达之前结果准备好，则返回 `true`，否则返回 `false`。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the result
associated with `*this` is not ready at the point of the call, and the current thread is interrupted. Any exception thrown by the
['wait callback] if such a callback is called.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。如果某个回调被调用，则任何由['等待回调]抛出的异常也会被抛出。]]

[[Postconditions:] [If this call returned `true`, then [unique_future_is_ready_link `this->is_ready()`] returns `true` and
[unique_future_get_state_link `this->get_state()`] returns __ready__.\n
[unique_future_is_ready_link `this->is_ready()`] 返回 `true`. [unique_future_get_state_link `this->get_state()`] 返回 __ready__。]]

[[Notes:] [`timed_wait()` is an ['interruption point]. `Duration` must be a type that meets the Boost.DateTime time duration requirements.\n
`timed_wait()` 是一个 ['中断点]。`Duration` 必须是一个满足 Boost.DateTime 时间长度要求的类型。]]

]

[endsect]

[section:timed_wait_absolute Member function `timed_wait()`]

    bool timed_wait(boost::system_time const& wait_timeout);

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready, or the time point specified by
`wait_timeout` has passed. If the result is not ready on entry, and the result has a ['wait callback] set, that callback is invoked
prior to waiting.\n
如果 `*this` 关联于某个异步结果，则等待直至该结果准备好，或是由 `wait_timeout` 给定的时间点已过。如果在入口处结果未准备好，
且该结果有一个['等待回调]集合，则在等待之前执行回调。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, and that result is ready before the specified time has
passed, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且在指定时间到达之前结果准备好，则返回 `true`，否则返回 `false`。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the result
associated with `*this` is not ready at the point of the call, and the current thread is interrupted. Any exception thrown by the
['wait callback] if such a callback is called.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。如果某个回调被调用，则任何由['等待回调]抛出的异常也会被抛出。]]

[[Postconditions:] [If this call returned `true`, then [unique_future_is_ready_link `this->is_ready()`] returns `true` and
[unique_future_get_state_link `this->get_state()`] returns __ready__.\n
如果该调用返回 `true`，则 [unique_future_is_ready_link `this->is_ready()`] 返回 `true` 且 
[unique_future_get_state_link `this->get_state()`] 返回 __ready__。]]

[[Notes:] [`timed_wait()` is an ['interruption point].\n
`timed_wait()` 是一个 ['中断点]。]]

]

[endsect]


[section:is_ready Member function `is_ready()`]

    bool is_ready();

[variablelist

[[Effects:] [Checks to see if the asynchronous result associated with `*this` is set.\n
检查与 `*this` 相关联的异步结果是否被设置。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, and that result is ready for retrieval, `false`
otherwise.\n
如果 `*this` 关联于某个异步结果且该结果已准备好被提取，则返回 `true`，否则返回 `false`。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:has_value Member function `has_value()`]

    bool has_value();

[variablelist

[[Effects:] [Checks to see if the asynchronous result associated with `*this` is set with a value rather than an exception.\n
检查与 `*this` 相关联的异步结果是否被设置为一个值而不是一个异常。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, that result is ready for retrieval, and the result is a
stored value, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且该结果已准备好被提取且结果为一个值，则返回 `true`，否则返回 `false`。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:has_exception Member function `has_exception()`]

    bool has_exception();

[variablelist

[[Effects:] [Checks to see if the asynchronous result associated with `*this` is set with an exception rather than a value.\n
检查与 `*this` 相关联的异步结果是否被设置为一个异常而不是一个值。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, that result is ready for retrieval, and the result is a
stored exception, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且该结果已准备好被提取且结果为一个异常，则返回 `true`，否则返回 `false`。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:get_state Member function `get_state()`]

    future_state::state get_state();

[variablelist

[[Effects:] [Determine the state of the asynchronous result associated with `*this`, if any.\n
判断与 `*this` 相关联的异步结果的状态，如果有的话。]]

[[Returns:] [__uninitialized__ if `*this` is not associated with an asynchronous result. __ready__ if the asynchronous result
associated with `*this` is ready for retrieval, __waiting__ otherwise.\n
如果 `*this` 不关联于某个异步结果，则返回 __uninitialized__。如果关联于 `*this` 的异步结果已准备好被提取，则返回 __ready__，
否则返回 __waiting__。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]


[endsect]

[section:shared_future `shared_future` class template]

    template <typename R>
    class shared_future
    {
    public:
        typedef future_state::state state;

        shared_future();
        ~shared_future();

        // copy support
        shared_future(shared_future const& other);
        shared_future& operator=(shared_future const& other);

        // move support
        shared_future(shared_future && other);
        shared_future(unique_future<R> && other);
        shared_future& operator=(shared_future && other);
        shared_future& operator=(unique_future<R> && other);

        void swap(shared_future& other);

        // retrieving the value
        R get();
        
        // functions to check state, and wait for ready
        state get_state() const;
        bool is_ready() const;
        bool has_exception() const;
        bool has_value() const;

        // waiting for the result to be ready
        void wait() const;        
        template<typename Duration>
        bool timed_wait(Duration const& rel_time) const;
        bool timed_wait_until(boost::system_time const& abs_time) const;        
    };

[section:default_constructor Default Constructor 缺省构造函数]

    shared_future();

[variablelist

[[Effects:] [Constructs an uninitialized future.\n
构造一个未初始化的期货。]]

[[Postconditions:] [[shared_future_is_ready_link `this->is_ready`] returns `false`. [shared_future_get_state_link
`this->get_state()`] returns __uninitialized__.\n
[shared_future_is_ready_link `this->is_ready`] 返回 `false`。
[shared_future_get_state_link `this->get_state()`] 返回 __uninitialized__。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:get Member function `get()`]

    const R& get();

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready as-if by a call to
__shared_future_wait__, and returns a `const` reference to the result.\n
如果 `*this` 关联于某个异步结果，则等待至该结果准备好，就如调用 __shared_future_wait__，并返回该结果的一个 `const` 引用。]]

[[Returns:] [If the result type `R` is a reference, returns the stored reference. If `R` is `void`, there is no return
value. Otherwise, returns a `const` reference to the value stored in the asynchronous result.\n
如果结果类型 `R` 是一个引用，则返回所保存的引用。如果 `R` 为 `void`，则没有返回值。否则，返回保存在异步结果中的值的 `const` 引用。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the
result associated with `*this` is not ready at the point of the call, and the current thread is interrupted.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。]]

[[Notes:] [`get()` is an ['interruption point].\n
`get()` 是一个 ['中断点]。]]

]

[endsect]

[section:wait Member function `wait()`]

    void wait();

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready. If the result is not ready on
entry, and the result has a ['wait callback] set, that callback is invoked prior to waiting.\n
如果 `*this` 关联于某个异步结果，则等待直至该结果准备好。如果在入口处结果未准备好，且该结果有一个['等待回调]集合，
则在等待之前执行回调。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the result
associated with `*this` is not ready at the point of the call, and the current thread is interrupted. Any exception thrown by the
['wait callback] if such a callback is called.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。如果某个回调被调用，则任何由['等待回调]抛出的异常也会被抛出。]]

[[Postconditions:] [[shared_future_is_ready_link `this->is_ready()`] returns `true`. [shared_future_get_state_link
`this->get_state()`] returns __ready__.\n
[shared_future_is_ready_link `this->is_ready()`] 返回 `true`. [shared_future_get_state_link `this->get_state()`] 返回 __ready__。]]

[[Notes:] [`wait()` is an ['interruption point].\n
`wait()` 是一个 ['中断点]。]]

]

[endsect]

[section:timed_wait_duration Member function `timed_wait()`]

    template<typename Duration>
    bool timed_wait(Duration const& wait_duration);

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready, or the time specified by
`wait_duration` has elapsed. If the result is not ready on entry, and the result has a ['wait callback] set, that callback is
invoked prior to waiting.\n
如果 `*this` 关联于某个异步结果，则等待直至该结果准备好，或是达到由 `wait_duration` 给定的时间。如果在入口处结果未准备好，
且该结果有一个['等待回调]集合，则在等待之前执行回调。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, and that result is ready before the specified time has
elapsed, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且在指定时间到达之前结果准备好，则返回 `true`，否则返回 `false`。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the result
associated with `*this` is not ready at the point of the call, and the current thread is interrupted. Any exception thrown by the
['wait callback] if such a callback is called.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。如果某个回调被调用，则任何由['等待回调]抛出的异常也会被抛出。]]

[[Postconditions:] [If this call returned `true`, then [shared_future_is_ready_link `this->is_ready()`] returns `true` and
[shared_future_get_state_link `this->get_state()`] returns __ready__.\n
[shared_future_is_ready_link `this->is_ready()`] 返回 `true`. [shared_future_get_state_link `this->get_state()`] 返回 __ready__。]]

[[Notes:] [`timed_wait()` is an ['interruption point]. `Duration` must be a type that meets the Boost.DateTime time duration requirements.\n
`timed_wait()` 是一个 ['中断点]。`Duration` 必须是一个满足 Boost.DateTime 时间长度要求的类型。]]

]

[endsect]

[section:timed_wait_absolute Member function `timed_wait()`]

    bool timed_wait(boost::system_time const& wait_timeout);

[variablelist

[[Effects:] [If `*this` is associated with an asynchronous result, waits until the result is ready, or the time point specified by
`wait_timeout` has passed. If the result is not ready on entry, and the result has a ['wait callback] set, that callback is invoked
prior to waiting.\n
如果 `*this` 关联于某个异步结果，则等待直至该结果准备好，或是由 `wait_timeout` 给定的时间点已过。如果在入口处结果未准备好，
且该结果有一个['等待回调]集合，则在等待之前执行回调。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, and that result is ready before the specified time has
passed, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且在指定时间到达之前结果准备好，则返回 `true`，否则返回 `false`。]]

[[Throws:] [__future_uninitialized__ if `*this` is not associated with an asynchronous result. __thread_interrupted__ if the result
associated with `*this` is not ready at the point of the call, and the current thread is interrupted. Any exception thrown by the
['wait callback] if such a callback is called.\n
如果 `*this` 不关联异步结果，则抛出 __future_uninitialized__。如果与 `*this` 关联的结果在调用时未准备好，则抛出 __thread_interrupted__，
且当前线程被中断。如果某个回调被调用，则任何由['等待回调]抛出的异常也会被抛出。]]

[[Postconditions:] [If this call returned `true`, then [shared_future_is_ready_link `this->is_ready()`] returns `true` and
[shared_future_get_state_link `this->get_state()`] returns __ready__.\n
如果该调用返回 `true`，则 [unique_future_is_ready_link `this->is_ready()`] 返回 `true` 且 
[unique_future_get_state_link `this->get_state()`] 返回 __ready__。]]

[[Notes:] [`timed_wait()` is an ['interruption point].\n
`timed_wait()` 是一个 ['中断点]。]]

]

[endsect]

[section:is_ready Member function `is_ready()`]

    bool is_ready();

[variablelist

[[Effects:] [Checks to see if the asynchronous result associated with `*this` is set.\n
检查与 `*this` 相关联的异步结果是否被设置。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, and that result is ready for retrieval, `false`
otherwise.\n
如果 `*this` 关联于某个异步结果且该结果已准备好被提取，则返回 `true`，否则返回 `false`。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:has_value Member function `has_value()`]

    bool has_value();

[variablelist

[[Effects:] [Checks to see if the asynchronous result associated with `*this` is set with a value rather than an exception.\n
检查与 `*this` 相关联的异步结果是否被设置为一个值而不是一个异常。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, that result is ready for retrieval, and the result is a
stored value, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且该结果已准备好被提取且结果为一个值，则返回 `true`，否则返回 `false`。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:has_exception Member function `has_exception()`]

    bool has_exception();

[variablelist

[[Effects:] [Checks to see if the asynchronous result associated with `*this` is set with an exception rather than a value.\n
检查与 `*this` 相关联的异步结果是否被设置为一个异常而不是一个值。]]

[[Returns:] [`true` if `*this` is associated with an asynchronous result, that result is ready for retrieval, and the result is a
stored exception, `false` otherwise.\n
如果 `*this` 关联于某个异步结果且该结果已准备好被提取且结果为一个异常，则返回 `true`，否则返回 `false`。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:get_state Member function `get_state()`]

    future_state::state get_state();

[variablelist

[[Effects:] [Determine the state of the asynchronous result associated with `*this`, if any.\n
判断与 `*this` 相关联的异步结果的状态，如果有的话。]]

[[Returns:] [__uninitialized__ if `*this` is not associated with an asynchronous result. __ready__ if the asynchronous result
associated with `*this` is ready for retrieval, __waiting__ otherwise.\n
如果 `*this` 不关联于某个异步结果，则返回 __uninitialized__。如果关联于 `*this` 的异步结果已准备好被提取，则返回 __ready__，
否则返回 __waiting__。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]


[endsect]

[section:promise `promise` class template]

    template <typename R>
    class promise
    {
        promise(promise & rhs);// = delete;
        promise & operator=(promise & rhs);// = delete;
    public:
        // template <class Allocator> explicit promise(Allocator a);

        promise();
        ~promise();

        // Move support
        promise(promise && rhs);
        promise & operator=(promise&& rhs);
        
        void swap(promise& other);
        // Result retrieval
        unique_future<R> get_future();

        // Set the value
        void set_value(R& r);
        void set_value(R&& r);
        void set_exception(boost::exception_ptr e);

        template<typename F>
        void set_wait_callback(F f);        
    };

[section:default_constructor Default Constructor 缺省构造函数]

    promise();

[variablelist

[[Effects:] [Constructs a new __promise__ with no associated result.\n
构造一个不带关联结果的新 __promise__。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:move_constructor Move Constructor 转移构造函数]

    promise(promise && other);

[variablelist

[[Effects:] [Constructs a new __promise__, and transfers ownership of the result associated with `other` to `*this`, leaving `other`
with no associated result.\n
构造一个新的 __promise__，并将与 `other` 关联的结果的所有权转移至 `*this`，`other` 则不再关联结果。]]

[[Throws:] [Nothing.\n
无。]]

[[Notes:] [If the compiler does not support rvalue-references, this is implemented using the boost.thread move emulation.\n
如果编译器不支持右值引用，则使用 boost.thread 的转移仿真来实现。]]

]

[endsect]

[section:move_assignment Move Assignment Operator 转移赋值操作符]

    promise& operator=(promise && other);

[variablelist

[[Effects:] [Transfers ownership of the result associated with `other` to `*this`, leaving `other` with no associated result. If there
was already a result associated with `*this`, and that result was not ['ready], sets any futures associated with that result to
['ready] with a __broken_promise__ exception as the result. \n
将与 `other` 关联的结果的所有权转移至 `*this`，`other` 不再关联结果。如果 `*this` 已经带有关联结果，则该结果不再['准备好]，
将与该结果相关联的任何期货设置为['准备好]，以 __broken_promise__ 异常作为结果。]]

[[Throws:] [Nothing.\n
无。]]

[[Notes:] [If the compiler does not support rvalue-references, this is implemented using the boost.thread move emulation.\n
如果编译器不支持右值引用，则使用 boost.thread 的转移仿真来实现。]]

]

[endsect]

[section:destructor Destructor 析构函数]

    ~promise();

[variablelist

[[Effects:] [Destroys `*this`. If there was a result associated with `*this`, and that result is not ['ready], sets any futures
associated with that task to ['ready] with a __broken_promise__ exception as the result.\n
销毁 `*this`。如果有某个结果关联于 `*this`，则该结果不再['准备好]，将与该结果相关联的任何期货设置为['准备好]，
以 __broken_promise__ 异常作为结果。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:get_future Member Function `get_future()`]

    unique_future<R> get_future();

[variablelist

[[Effects:] [If `*this` was not associated with a result, allocate storage for a new asynchronous result and associate it with
`*this`. Returns a __unique_future__ associated with the result associated with `*this`. \n
如果 `*this` 不关联于某个结果，则分配一个新的异步结果的内存并将它关联至 `*this`。返回一个关联了与 `*this` 相关联的结果的
__unique_future__。]]

[[Throws:] [__future_already_retrieved__ if the future associated with the task has already been retrieved. `std::bad_alloc` if any
memory necessary could not be allocated.\n
如果与该任务相关联的期货已被取出，则抛出 __future_already_retrieved__。如果没有内存可分配，则抛出 `std::bad_alloc`。]]

]

[endsect]

[section:set_value Member Function `set_value()`]

    void set_value(R&& r);
    void set_value(const R& r);
    void promise<R&>::set_value(R& r);
    void promise<void>::set_value();

[variablelist

[[Effects:] [If `*this` was not associated with a result, allocate storage for a new asynchronous result and associate it with
`*this`. Store the value `r` in the asynchronous result associated with `*this`. Any threads blocked waiting for the asynchronous
result are woken.\n
如果 `*this` 没有关联至某个结果，则分配一个新的异步结果的内存并将它关联至 `*this`。将值 `r` 保存到与 `*this` 相关联的异步结果中。
所有因等待该异步结果而阻塞的线程被唤醒。]]

[[Postconditions:] [All futures waiting on the asynchronous result are ['ready] and __unique_future_has_value__ or
__shared_future_has_value__ for those futures shall return `true`.\n
所有在该异步结果上等待的期货变为['准备好]，且这些期货的 __unique_future_has_value__ 或 __shared_future_has_value__ 返回 `true`。]]

[[Throws:] [__promise_already_satisfied__ if the result associated with `*this` is already ['ready]. `std::bad_alloc` if the memory
required for storage of the result cannot be allocated. Any exception thrown by the copy or move-constructor of `R`.\n
如果关联于 `*this` 的结果已['准备好]，则抛出 __promise_already_satisfied__。如果没有内存可分配，则抛出 `std::bad_alloc`。
由 `R` 的复制或转移构造函数所抛出的任何异常都会被抛出。]]

]

[endsect]

[section:set_exception Member Function `set_exception()`]

    void set_exception(boost::exception_ptr e);

[variablelist

[[Effects:] [If `*this` was not associated with a result, allocate storage for a new asynchronous result and associate it with
`*this`. Store the exception `e` in the asynchronous result associated with `*this`. Any threads blocked waiting for the asynchronous
result are woken.\n
如果 `*this` 没有关联至某个结果，则分配一个新的异步结果的内存并将它关联至 `*this`。将异常 `e` 保存到与 `*this` 相关联的异步结果中。
所有因等待该异步结果而阻塞的线程被唤醒。]]

[[Postconditions:] [All futures waiting on the asynchronous result are ['ready] and __unique_future_has_exception__ or
__shared_future_has_exception__ for those futures shall return `true`.\n
所有在该异步结果上等待的期货变为['准备好]，且这些期货的 __unique_future_has_exception__ 或 __shared_future_has_exception__ 返回 `true`。]]

[[Throws:] [__promise_already_satisfied__ if the result associated with `*this` is already ['ready]. `std::bad_alloc` if the memory
required for storage of the result cannot be allocated.\n
如果关联于 `*this` 的结果已['准备好]，则抛出 __promise_already_satisfied__。如果没有内存可分配，则抛出 `std::bad_alloc`。]]

]

[endsect]

[section:set_wait_callback Member Function `set_wait_callback()`]

    template<typename F>
    void set_wait_callback(F f);

[variablelist

[[Preconditions:] [The expression `f(t)` where `t` is a lvalue of type __packaged_task__ shall be well-formed. Invoking a copy of
`f` shall have the same effect as invoking `f`\n
表达式 `f(t)` 有良好定义，其中 `t` 是 __packaged_task__ 类型的左值。执行 `f` 的拷贝与执行 `f` 有相同的效果。]]

[[Effects:] [Store a copy of `f` with the asynchronous result associated with `*this` as a ['wait callback]. This will replace any
existing wait callback store alongside that result. If a thread subsequently calls one of the wait functions on a __unique_future__
or __shared_future__ associated with this result, and the result is not ['ready], `f(*this)` shall be invoked.\n
将 `f` 的一份拷贝保存为与 `*this` 相关联的异步结果的一个['等待回调]。它将替代任何已保存在该结果中的等待回调。
如果此后一个线程在与此结果相关联的一个 __unique_future__ 或 __shared_future__ 上调用该等待回调，且该结果未['准备好]，
则 `f(*this)` 被执行。]]

[[Throws:] [`std::bad_alloc` if memory cannot be allocated for the required storage.\n
如果没有内存可分配，则抛出 `std::bad_alloc`。]]

]

[endsect]

[endsect]

[section:packaged_task `packaged_task` class template]

    template<typename R>
    class packaged_task
    {
        packaged_task(packaged_task&);// = delete;
        packaged_task& operator=(packaged_task&);// = delete;
        
    public:
        // construction and destruction
        template <class F>
        explicit packaged_task(F const& f);

        explicit packaged_task(R(*f)());
        
        template <class F>
        explicit packaged_task(F&& f);

        // template <class F, class Allocator>
        // explicit packaged_task(F const& f, Allocator a);
        // template <class F, class Allocator>
        // explicit packaged_task(F&& f, Allocator a);

        ~packaged_task()
        {}

        // move support
        packaged_task(packaged_task&& other);
        packaged_task& operator=(packaged_task&& other);

        void swap(packaged_task& other);
        // result retrieval
        unique_future<R> get_future();        

        // execution
        void operator()();

        template<typename F>
        void set_wait_callback(F f);        
    };

[section:task_constructor Task Constructor 任务构造函数]

    template<typename F>
    packaged_task(F const &f);

    packaged_task(R(*f)());

    template<typename F>
    packaged_task(F&&f);

[variablelist

[[Preconditions:] [`f()` is a valid expression with a return type convertible to `R`. Invoking a copy of `f` shall behave the same
as invoking `f`.\n
`f()` 是一个返回类型可转换为 `R` 的有效表达式。执行 `f` 的拷贝与执行 `f` 有相同的行为。]]

[[Effects:] [Constructs a new __packaged_task__ with a copy of `f` stored as the associated task.\n
构造一个新的 __packaged_task__，将 `f` 的拷贝保存为关联任务。]]

[[Throws:] [Any exceptions thrown by the copy (or move) constructor of `f`. `std::bad_alloc` if memory for the internal data
structures could not be allocated.\n
由 `f` 的复制(转移)构造函数所抛出的任何异常都会被抛出。如果没有内存可分配给内部数据结构，则抛出 `std::bad_alloc`。]]

]

[endsect]

[section:move_constructor Move Constructor 转移构造函数]

    packaged_task(packaged_task && other);

[variablelist

[[Effects:] [Constructs a new __packaged_task__, and transfers ownership of the task associated with `other` to `*this`, leaving `other`
with no associated task.\n
构造一个新的 __packaged_task__，并将与 `other` 相关联的任务的所有权转移至 `*this`，`other` 则不再有关联任务。]]

[[Throws:] [Nothing.\n
无。]]

[[Notes:] [If the compiler does not support rvalue-references, this is implemented using the boost.thread move emulation.\n
如果编译器不支持右值引用，则使用 boost.thread 的转移仿真来实现。]]

]

[endsect]

[section:move_assignment Move Assignment Operator 转移赋值操作符]

    packaged_task& operator=(packaged_task && other);

[variablelist

[[Effects:] [Transfers ownership of the task associated with `other` to `*this`, leaving `other` with no associated task. If there
was already a task associated with `*this`, and that task has not been invoked, sets any futures associated with that task to
['ready] with a __broken_promise__ exception as the result. \n
将与 `other` 关联的任务的所有权转移至 `*this`，`other` 不再关联任务。如果 `*this` 已经带有关联任务，则该任务不再被执行，
将与该任务相关联的任何期货设置为['准备好]，以 __broken_promise__ 异常作为结果。]]

[[Throws:] [Nothing.\n
无。]]

[[Notes:] [If the compiler does not support rvalue-references, this is implemented using the boost.thread move emulation.\n
如果编译器不支持右值引用，则使用 boost.thread 的转移仿真来实现。]]

]

[endsect]

[section:destructor Destructor 析构函数]

    ~packaged_task();

[variablelist

[[Effects:] [Destroys `*this`. If there was a task associated with `*this`, and that task has not been invoked, sets any futures
associated with that task to ['ready] with a __broken_promise__ exception as the result.\n
销毁 `*this`。如果有某个任务关联于 `*this`，则该任务不再被执行，将与该任务相关联的任何期货设置为['准备好]，
以 __broken_promise__ 异常作为结果。]]

[[Throws:] [Nothing.\n
无。]]

]

[endsect]

[section:get_future Member Function `get_future()`]

    unique_future<R> get_future();

[variablelist

[[Effects:] [Returns a __unique_future__ associated with the result of the task associated with `*this`. \n
返回一个关联了与 `*this` 相关联的任务的 __unique_future__。]]

[[Throws:] [__task_moved__ if ownership of the task associated with `*this` has been moved to another instance of
__packaged_task__. __future_already_retrieved__ if the future associated with the task has already been retrieved.\n
如果与 `*this` 相关联的任务的所有权已经转移至另一个 __packaged_task__ 实例，则抛出 __task_moved__。
如果与该任务相关联的期货已被取出，则抛出 __future_already_retrieved__。]]

]

[endsect]

[section:call_operator Member Function `operator()()`]

    void operator()();

[variablelist

[[Effects:] [Invoke the task associated with `*this` and store the result in the corresponding future. If the task returns normally,
the return value is stored as the asynchronous result, otherwise the exception thrown is stored. Any threads blocked waiting for the
asynchronous result associated with this task are woken.\n
执行与 `*this` 相关联的任务，并将结果保存在对应的期货中。如果该任务正常返回，则返回值被保存为异步结果，否则保存被抛出的异常。
所有因等待与该任务相关联的异步结果而阻塞的线程被唤醒。]]

[[Postconditions:] [All futures waiting on the asynchronous result are ['ready]\n
所有在该异步结果上等待的期货变为['准备好]。]]

[[Throws:] [__task_moved__ if ownership of the task associated with `*this` has been moved to another instance of
__packaged_task__. __task_already_started__ if the task has already been invoked.\n
如果与 `*this` 相关联的任务的所有权已经转移至另一个 __packaged_task__ 实例，则抛出 __task_moved__。
如果该任务已被执行，则抛出 __task_already_started__。]]

]

[endsect]

[section:set_wait_callback Member Function `set_wait_callback()`]

    template<typename F>
    void set_wait_callback(F f);

[variablelist

[[Preconditions:] [The expression `f(t)` where `t` is a lvalue of type __packaged_task__ shall be well-formed. Invoking a copy of
`f` shall have the same effect as invoking `f`\n
表达式 `f(t)` 有良好定义，其中 `t` 是 __packaged_task__ 类型的左值。执行 `f` 的拷贝与执行 `f` 有相同的效果。]]

[[Effects:] [Store a copy of `f` with the task associated with `*this` as a ['wait callback]. This will replace any existing wait
callback store alongside that task. If a thread subsequently calls one of the wait functions on a __unique_future__ or
__shared_future__ associated with this task, and the result of the task is not ['ready], `f(*this)` shall be invoked.\n
将 `f` 的一份拷贝以及与 `*this` 相关联的任务保存为一个['等待回调]。它将替代任何已保存在该任务中的等待回调。
如果此后一个线程在与此任务相关联的一个 __unique_future__ 或 __shared_future__ 上调用该等待回调，且该任务的结果未['准备好]，
则 `f(*this)` 被执行。]]

[[Throws:] [__task_moved__ if ownership of the task associated with `*this` has been moved to another instance of
__packaged_task__.\n
如果与 `*this` 相关联的任务的所有权已被转移至另一个 __packaged_task__ 实例，则抛出 __task_moved__。]]

]

[endsect]


[endsect]

[section:wait_for_any Non-member function `wait_for_any()`]

    template<typename Iterator>
    Iterator wait_for_any(Iterator begin,Iterator end);

    template<typename F1,typename F2>
    unsigned wait_for_any(F1& f1,F2& f2);

    template<typename F1,typename F2,typename F3>
    unsigned wait_for_any(F1& f1,F2& f2,F3& f3);

    template<typename F1,typename F2,typename F3,typename F4>
    unsigned wait_for_any(F1& f1,F2& f2,F3& f3,F4& f4);

    template<typename F1,typename F2,typename F3,typename F4,typename F5>
    unsigned wait_for_any(F1& f1,F2& f2,F3& f3,F4& f4,F5& f5);

[variablelist

[[Preconditions:] [The types `Fn` shall be specializations of
__unique_future__ or __shared_future__, and `Iterator` shall be a
forward iterator with a `value_type` which is a specialization of
__unique_future__ or __shared_future__.\n
类型 `Fn` 应是 __unique_future__ 或 __shared_future__ 的特化，`Iterator` 应是一个 `value_type` 为 __unique_future__ 或 
__shared_future__ 的特化类型的前向迭代器。]]

[[Effects:] [Waits until at least one of the specified futures is ['ready].\n
等待直至至少一个给定的期货变为['准备好]。]]

[[Returns:] [The range-based overload returns an `Iterator` identifying the first future in the range that was detected as
['ready]. The remaining overloads return the zero-based index of the first future that was detected as ['ready] (first parameter =>
0, second parameter => 1, etc.).\n
基于区间的重载版本将返回一个 `Iterator`，标识在区间中被测定为['准备好]的第一个期货。其它重载版本则返回从零起计的索引，
指向被测定为['准备好]的第一个期货(第一个参数 => 0, 第二个参数 => 1, 等等)。]]

[[Throws:] [__thread_interrupted__ if the current thread is interrupted. Any exception thrown by the ['wait callback] associated
with any of the futures being waited for.  `std::bad_alloc` if memory could not be allocated for the internal wait structures.\n
如果当前线程被中断，则抛出 __thread_interrupted__。由任一正在被等待的期货相关联的['等待回调]所抛出的任何异常都会被抛出。
如果不能为内部等待结构分配内存，则抛出 `std::bad_alloc`。]]

[[Notes:] [`wait_for_any()` is an ['interruption point].\n
`wait_for_any()` 是一个 ['中断点]。]]

]


[endsect]

[section:wait_for_all Non-member function `wait_for_all()`]

    template<typename Iterator>
    void wait_for_all(Iterator begin,Iterator end);

    template<typename F1,typename F2>
    void wait_for_all(F1& f1,F2& f2);

    template<typename F1,typename F2,typename F3>
    void wait_for_all(F1& f1,F2& f2,F3& f3);

    template<typename F1,typename F2,typename F3,typename F4>
    void wait_for_all(F1& f1,F2& f2,F3& f3,F4& f4);

    template<typename F1,typename F2,typename F3,typename F4,typename F5>
    void wait_for_all(F1& f1,F2& f2,F3& f3,F4& f4,F5& f5);

[variablelist

[[Preconditions:] [The types `Fn` shall be specializations of
__unique_future__ or __shared_future__, and `Iterator` shall be a
forward iterator with a `value_type` which is a specialization of
__unique_future__ or __shared_future__.\n
类型 `Fn` 应是 __unique_future__ 或 __shared_future__ 的特化，`Iterator` 应是一个 `value_type` 为 __unique_future__ 或 
__shared_future__ 的特化类型的前向迭代器。]]

[[Effects:] [Waits until all of the specified futures are ['ready].\n
等待直至所有给定的期货变为['准备好]。]]

[[Throws:] [Any exceptions thrown by a call to `wait()` on the specified futures.\n
由在给定期货上调用 `wait()` 所抛出的任何异常。]]

[[Notes:] [`wait_for_all()` is an ['interruption point].\n
`wait_for_all()` 是一个 ['中断点]。]]

]


[endsect]


[endsect]

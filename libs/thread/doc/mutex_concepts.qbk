[/
  (C) Copyright 2007-8 Anthony Williams.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:mutex_concepts Mutex Concepts 互斥量概念]

A mutex object facilitates protection against data races and allows thread-safe synchronization of data between threads. A thread
obtains ownership of a mutex object by calling one of the lock functions and relinquishes ownership by calling the corresponding
unlock function. Mutexes may be either recursive or non-recursive, and may grant simultaneous ownership to one or many
threads. __boost_thread__ supplies recursive and non-recursive mutexes with exclusive ownership semantics, along with a shared
ownership (multiple-reader / single-writer) mutex.\n
互斥量对象简化了线程间数据竟态保护和数据同步。一个线程通过一个锁定函数取得一个互斥量的所有权，通过一个对应的解锁函数释放所有权。
互斥量可以是支持递归所有权的或非递归所有权的，也可以同时属于多个线程。__boost_thread__ 库提供递归和非递归互斥量, 
支持排他型的所有权和共享所有权(多读/单写)。 

__boost_thread__ supports four basic concepts for lockable objects: __lockable_concept_type__, __timed_lockable_concept_type__,
__shared_lockable_concept_type__ and __upgrade_lockable_concept_type__. Each mutex type implements one or more of these concepts, as
do the various lock types.\n
__boost_thread__ 库支持四种基本的可所有权概念: __lockable_concept_type__, __timed_lockable_concept_type__, 
__shared_lockable_concept_type__ 和 __upgrade_lockable_concept_type__。每种互斥量依据自己的目标实现一种或多种概念。

[section:lockable `Lockable` Concept  `Lockable`概念]

The __lockable_concept__ models exclusive ownership. A type that implements the __lockable_concept__ shall provide the following
member functions:\n
__lockable_concept__ 对排他型所有权建模。实现 __lockable_concept__ 需要提供下面的成员函数: 

* [lock_ref_link `void lock();`]
* [try_lock_ref_link `bool try_lock();`]
* [unlock_ref_link `void unlock();`]

Lock ownership acquired through a call to __lock_ref__ or __try_lock_ref__ must be released through a call to __unlock_ref__.\n
通过 函数 __lock_ref__ 或函数 __try_lock_ref__ 获取的所有权需要通过 __unlock_ref__ 来释放。

[section:lock `void lock()`]

[variablelist

[[Effects:] [The current thread blocks until ownership can be obtained for the current thread.\n
当前线程阻塞直到取得互斥量的所有权。]]

[[Postcondition:] [The current thread owns `*this`.\n
`*this` 线程拥有该互斥量。]]

[[Throws:] [__thread_resource_error__ if an error occurs.\n
如果出错抛出 __thread_resource_error__ 异常。]]

]
[endsect]

[section:try_lock `bool try_lock()`]

[variablelist

[[Effects:] [Attempt to obtain ownership for the current thread without blocking.\n
尝试取得互斥量所有权，线程不会被阻塞。]]

[[Returns:] [`true` if ownership was obtained for the current thread, `false` otherwise.\n
如果取得所有权返回 `true`, 否则返回 `false`。]]

[[Postcondition:] [If the call returns `true`, the current thread owns the `*this`.\n
如果返回 `true`, 当前线程拥有 `*this`。 ]]

[[Throws:] [__thread_resource_error__ if an error occurs.\n
如果出错抛出 __thread_resource_error__ 异常。]]

]
[endsect]

[section:unlock `void unlock()`]

[variablelist

[[Precondition:] [The current thread owns `*this`.\n
当前线程拥有 `*this`。]]

[[Effects:] [Releases ownership by the current thread.\n
当前线程释放互斥量所有权。]]

[[Postcondition:] [The current thread no longer owns `*this`.\n
当前线程拥不拥有 `*this`。]]

[[Throws:] [Nothing\n
无]]
]
[endsect]
[endsect]

[section:timed_lockable `TimedLockable` Concept  `TimedLockable`概念]

The __timed_lockable_concept__ refines the __lockable_concept__ to add support for
timeouts when trying to acquire the lock.\n
__timed_lockable_concept__ 细化了 __lockable_concept__，支持尝试获取所有权时超时放弃。

A type that implements the __timed_lockable_concept__ shall meet the requirements
of the __lockable_concept__. In addition, the following member functions must be
provided:\n
实现 __timed_lockable_concept__ 的类型需要符合 __lockable_concept__ 的要求。除此以外，还需要提供下面的成员函数：

* [timed_lock_ref_link `bool timed_lock(boost::system_time const& abs_time);`]
* [timed_lock_duration_ref_link `template<typename DurationType> bool timed_lock(DurationType const& rel_time);`]

Lock ownership acquired through a call to __timed_lock_ref__ must be released through a call to __unlock_ref__.\n
通过 __timed_lock_ref__ 获取的所有权需要通过 __unlock_ref__ 来释放。

[section:timed_lock `bool timed_lock(boost::system_time const& abs_time)`]

[variablelist

[[Effects:] [Attempt to obtain ownership for the current thread. Blocks until ownership can be obtained, or the specified time is
reached. If the specified time has already passed, behaves as __try_lock_ref__.\n
当前线程尝试取得该互斥量所有权。线程阻塞直到它获得所有权, 或等待超过指定的时间点。如果等待时间点已过, 
函数的行为和 __try_lock_ref__ 一样。]]

[[Returns:] [`true` if ownership was obtained for the current thread, `false` otherwise.\n
如果取得所有权返回 `true`, 否则返回 `false`。]]

[[Postcondition:] [If the call returns `true`, the current thread owns `*this`.\n
如果返回 `true`, 当前线程拥有 `*this`。]]

[[Throws:] [__thread_resource_error__ if an error occurs.\n
如果出错抛出 __thread_resource_error__ 异常。]]
]
[endsect]

[section:timed_lock_duration `template<typename DurationType> bool
timed_lock(DurationType const& rel_time)`]

[variablelist

[[Effects:] [As-if [timed_lock_ref_link
`timed_lock(boost::get_system_time()+rel_time)`].\n
同 [timed_lock_ref_link `timed_lock(boost::get_system_time()+rel_time)`]。]]

]
[endsect]

[endsect]

[section:shared_lockable `SharedLockable` Concept  `SharedLockable`概念]

The __shared_lockable_concept__ is a refinement of the __timed_lockable_concept__ that
allows for ['shared ownership] as well as ['exclusive ownership]. This is the
standard multiple-reader / single-write model: at most one thread can have
exclusive ownership, and if any thread does have exclusive ownership, no other threads
can have shared or exclusive ownership. Alternatively, many threads may have
shared ownership.\n
__shared_lockable_concept__ 细化了 __timed_lockable_concept__ 允许['共享所有权]和['排他型所有权]。
适用于标准的"多读/单写"模型: 最多一个线程可以获取排他型所有权, 如果任一线程获得排他型所有权，
则其他线程不能获取到排他型所有权和共享型所有权。相反的, 多个线程可以同时获得共享所有权。

For a type to implement the __shared_lockable_concept__, as well as meeting the
requirements of the __timed_lockable_concept__, it must also provide the following
member functions:\n
如果一个类型要实现 __shared_lockable_concept__, 除了需要满足 __timed_lockable_concept__ 的要求, 还需要提供下面的成员函数:

* [lock_shared_ref_link `void lock_shared();`]
* [try_lock_shared_ref_link `bool try_lock_shared();`]
* [unlock_shared_ref_link `bool unlock_shared();`]
* [timed_lock_shared_ref_link `bool timed_lock_shared(boost::system_time const& abs_time);`]

Lock ownership acquired through a call to __lock_shared_ref__, __try_lock_shared_ref__ or __timed_lock_shared_ref__ must be released
through a call to __unlock_shared_ref__.\n
通过 __lock_shared_ref__, __try_lock_shared_ref__ 或 __timed_lock_shared_ref__ 获取的所有权需要通过 __unlock_shared_ref__ 来释放。

[section:lock_shared `void lock_shared()`]

[variablelist

[[Effects:] [The current thread blocks until shared ownership can be obtained for the current thread.\n
当前线程阻塞直到取得互斥量的共享所有权。]]

[[Postcondition:] [The current thread has shared ownership of `*this`.\n
当前线程取得 `*this` 的共享所有权。]]

[[Throws:] [__thread_resource_error__ if an error occurs.\n
如果出错抛出 __thread_resource_error__ 异常。]]

]
[endsect]

[section:try_lock_shared `bool try_lock_shared()`]

[variablelist

[[Effects:] [Attempt to obtain shared ownership for the current thread without blocking.\n
当前线程尝试取得该互斥量的共享所有权，线程不阻塞。]]

[[Returns:] [`true` if shared ownership was obtained for the current thread, `false` otherwise.\n
如果取得互斥量的共享所有权返回 `true`, 否则返回 `false`。]]

[[Postcondition:] [If the call returns `true`, the current thread has shared ownership of `*this`.\n
如果返回 `true`,  当前线程取得 `*this` 的共享所有权。]]

[[Throws:] [__thread_resource_error__ if an error occurs.\n
如果出错抛出 __thread_resource_error__ 异常。]]

]
[endsect]

[section:timed_lock_shared `bool timed_lock_shared(boost::system_time const& abs_time)`]

[variablelist

[[Effects:] [Attempt to obtain shared ownership for the current thread. Blocks until shared ownership can be obtained, or the
specified time is reached. If the specified time has already passed, behaves as __try_lock_shared_ref__.\n
当前线程尝试取得该互斥量的共享所有权。线程阻塞直到它获得所有权, 或等待超过指定的时间点。如果等待时间点已过, 
函数的行为和 __try_lock_shared_ref__ 一样。]]

[[Returns:] [`true` if shared ownership was acquired for the current thread, `false` otherwise.\n
如果取得互斥量的共享所有权返回 `true`, 否则返回 `false`。]]

[[Postcondition:] [If the call returns `true`, the current thread has shared
ownership of `*this`.\n
如果返回 `true`, 当前线程取得互斥量的共享所有权。]]

[[Throws:] [__thread_resource_error__ if an error occurs.\n
如果出错抛出 __thread_resource_error__ 异常。]]

]
[endsect]

[section:unlock_shared `void unlock_shared()`]

[variablelist

[[Precondition:] [The current thread has shared ownership of `*this`.\n
当前线程拥有 `*this` 的共享所有权。]]

[[Effects:] [Releases shared ownership of `*this` by the current thread.\n
释放当前线程拥有的 `*this` 共享所有权。]]

[[Postcondition:] [The current thread no longer has shared ownership of `*this`.\n
当前线程不在拥有 `*this` 的共享所有权。]]

[[Throws:] [Nothing\n
无]]

]
[endsect]


[endsect]

[section:upgrade_lockable `UpgradeLockable` Concept  `UpgradeLockable`概念]

The __upgrade_lockable_concept__ is a refinement of the __shared_lockable_concept__ that allows for ['upgradable ownership] as well
as ['shared ownership] and ['exclusive ownership]. This is an extension to the multiple-reader / single-write model provided by the
__shared_lockable_concept__: a single thread may have ['upgradable ownership] at the same time as others have ['shared
ownership]. The thread with ['upgradable ownership] may at any time attempt to upgrade that ownership to ['exclusive ownership]. If
no other threads have shared ownership, the upgrade is completed immediately, and the thread now has ['exclusive ownership], which
must be relinquished by a call to __unlock_ref__, just as if it had been acquired by a call to __lock_ref__.\n
__upgrade_lockable_concept__ 是 __shared_lockable_concept__ 的细化，特点在于允许['可升级所有权]，和['共享所有权]和['排他型所有权]一样。
这是对 __shared_lockable_concept__ 所提供的"多读/单写"模型的一个扩展：一个线程可以拥有['可升级所有权]而同时其他线程拥有['共享所有权]。
带有['可升级所有权]的线程可以在任何时候试图升级其所有权为['排他型所有权]。如果此时没有其他线程拥有共享所有权，升级立即完成, 
该线程就会拥有['排他型所有权], 这个所有权需要通过 __unlock_ref__ 来释放, 就像这个所有权是通过 __lock_ref__ 取得一样。

If a thread with ['upgradable ownership] tries to upgrade whilst other threads have ['shared ownership], the attempt will fail and
the thread will block until ['exclusive ownership] can be acquired.\n
如果一个带有['可升级所有权]线程试图升级而其他线程拥有['共享所有权], 升级会失败，该线程阻塞直到其获得['排他型所有权]。

Ownership can also be ['downgraded] as well as ['upgraded]: exclusive ownership of an implementation of the
__upgrade_lockable_concept__ can be downgraded to upgradable ownership or shared ownership, and upgradable ownership can be
downgraded to plain shared ownership.\n
和['升级]一样，所有权也可以['降级]: __upgrade_lockable_concept__ 实现的独占式所有权可以降级为可升级所有权或者共享所有权, 而可升级所有权可以降级为一般共享所有权。

For a type to implement the __upgrade_lockable_concept__, as well as meeting the
requirements of the __shared_lockable_concept__, it must also provide the following
member functions:\n
如果一个类型要实现 __upgrade_lockable_concept__，除了需要符合 __shared_lockable_concept__ 的要求之外, 它还需要提供下面的成员函数: 

* [lock_upgrade_ref_link `void lock_upgrade();`]
* [unlock_upgrade_ref_link `bool unlock_upgrade();`]
* [unlock_upgrade_and_lock_ref_link `void unlock_upgrade_and_lock();`]
* [unlock_and_lock_upgrade_ref_link `void unlock_and_lock_upgrade();`]
* [unlock_upgrade_and_lock_shared_ref_link `void unlock_upgrade_and_lock_shared();`]

Lock ownership acquired through a call to __lock_upgrade_ref__ must be released through a call to __unlock_upgrade_ref__. If the
ownership type is changed through a call to one of the `unlock_xxx_and_lock_yyy()` functions, ownership must be released through a
call to the unlock function corresponding to the new level of ownership.\n
通过 __lock_upgrade_ref__ 取得的所有权需要通过函数 __unlock_upgrade_ref__ 来释放。如果所有权类型通过某一个 `unlock_xxx_and_lock_yyy()` 
函数改变的, 则所有权必须通过新所有权对应的释放函数来释放。

[section:lock_upgrade `void lock_upgrade()`]

[variablelist

[[Effects:] [The current thread blocks until upgrade ownership can be obtained for the current thread.\n
当前线程阻塞知道它获得可升级所有权。]]

[[Postcondition:] [The current thread has upgrade ownership of `*this`.\n
当前线程取得 `*this` 的可升级所有权。]]

[[Throws:] [__thread_resource_error__ if an error occurs.\n
如果出错抛出 __thread_resource_error__ 异常。]]

]
[endsect]

[section:unlock_upgrade `void unlock_upgrade()`]

[variablelist

[[Precondition:] [The current thread has upgrade ownership of `*this`.\n
当前线程拥有 `*this` 的可升级所有权。]]

[[Effects:] [Releases upgrade ownership of `*this` by the current thread.\n
释放当前线程拥有的 `*this` 的可升级所有权。]]

[[Postcondition:] [The current thread no longer has upgrade ownership of `*this`.\n
当前线程不在拥有 `*this` 的可升级所有权。]]

[[Throws:] [Nothing\n
无]]

]
[endsect]

[section:unlock_upgrade_and_lock `void unlock_upgrade_and_lock()`]

[variablelist

[[Precondition:] [The current thread has upgrade ownership of `*this`.\n
当前线程拥有 `*this` 的可升级所有权。]]

[[Effects:] [Atomically releases upgrade ownership of `*this` by the current thread and acquires exclusive ownership of `*this`. If
any other threads have shared ownership, blocks until exclusive ownership can be acquired.\n
当前线程自动释放拥有的 `*this` 可升级所有权，并试图取得 `*this` 的独占所有权。如果其它线程拥有共享所有权，
则线程阻塞直到其获得独占所有权。]]

[[Postcondition:] [The current thread has exclusive ownership of `*this`.\n
当前线程拥有 `*this` 的独占所有权。]]

[[Throws:] [Nothing\n
无]]

]
[endsect]

[section:unlock_upgrade_and_lock_shared `void unlock_upgrade_and_lock_shared()`]

[variablelist

[[Precondition:] [The current thread has upgrade ownership of `*this`.\n
当前线程拥有 `*this` 的可升级所有权。]]

[[Effects:] [Atomically releases upgrade ownership of `*this` by the current thread and acquires shared ownership of `*this` without
blocking.\n
当前线程自动释放拥有的 `*this` 可升级所有权，取得 `*this` 共享所有权，该函数会立即返回。]]

[[Postcondition:] [The current thread has shared ownership of `*this`.\n
当前线程拥有 `*this` 的共享所有权。]]

[[Throws:] [Nothing\n
无]]

]
[endsect]

[section:unlock_and_lock_upgrade `void unlock_and_lock_upgrade()`]

[variablelist

[[Precondition:] [The current thread has exclusive ownership of `*this`.\n
当前线程拥有 `*this` 的独占所有权。]]

[[Effects:] [Atomically releases exclusive ownership of `*this` by the current thread and acquires upgrade ownership of `*this`
without blocking.\n
当前线程自动释放拥有的 `*this` 独占级所有权，取得 `*this` 的可升级所有权，该函数会立即返回。]]

[[Postcondition:] [The current thread has upgrade ownership of `*this`.\n
当前线程自动拥有 `*this` 可升级所有权。]]

[[Throws:] [Nothing\n
无]]

]
[endsect]

[endsect]

[endsect]

[section:locks Lock Types 锁定类型]

[section:lock_guard Class template `lock_guard`]

    #include <boost/thread/locks.hpp>

    template<typename Lockable>
    class lock_guard
    {
    public:
        explicit lock_guard(Lockable& m_);
        lock_guard(Lockable& m_,boost::adopt_lock_t);

        ~lock_guard();
    };

__lock_guard__ is very simple: on construction it
acquires ownership of the implementation of the __lockable_concept__ supplied as
the constructor parameter. On destruction, the ownership is released. This
provides simple RAII-style locking of a __lockable_concept_type__ object, to facilitate exception-safe
locking and unlocking. In addition, the [link
thread.synchronization.locks.lock_guard.constructor_adopt `lock_guard(Lockable &
m,boost::adopt_lock_t)` constructor] allows the __lock_guard__ object to
take ownership of a lock already held by the current thread.\n
__lock_guard__ 非常简单: 构造函数传入一个 __lockable_concept__ 对象，构造函数取得该对象的所有权。析构时释放所有权。 
这样为 __lockable_concept_type__ 对象提供了一个 RAII 风格的外观, 方便实现异常安全的锁定和解锁。 
额外的, [link thread.synchronization.locks.lock_guard.constructor_adopt `lock_guard(Lockable &m,boost::adopt_lock_t)` 构造函数] 
允许 __lock_guard__ 对象取得当前线程已拥有锁定的所有权。

[section:constructor `lock_guard(Lockable & m)`]

[variablelist

[[Effects:] [Stores a reference to `m`. Invokes [lock_ref_link `m.lock()`].\n
存储对 `m` 的引用，调用 [lock_ref_link `m.lock()`]。]]

[[Throws:] [Any exception thrown by the call to [lock_ref_link `m.lock()`].\n
调用 [lock_ref_link `m.lock()`] 可能抛出的异常。]]

]

[endsect]

[section:constructor_adopt `lock_guard(Lockable & m,boost::adopt_lock_t)`]

[variablelist

[[Precondition:] [The current thread owns a lock on `m` equivalent to one
obtained by a call to [lock_ref_link `m.lock()`].\n
当前线程拥有 `m` 的所有权, 等同于函数 [lock_ref_link `m.lock()`] 调用所获得的。]]

[[Effects:] [Stores a reference to `m`. Takes ownership of the lock state of
`m`.\n
存储对 `m` 的引用，接管 `m` 的锁定状态的所有权。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:destructor `~lock_guard()`]

[variablelist

[[Effects:] [Invokes [unlock_ref_link `m.unlock()`] on the __lockable_concept_type__
object passed to the constructor.\n
调用传入至构造函数的 __lockable_concept_type__ 对象的 [unlock_ref_link `m.unlock()`]。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[endsect]

[section:unique_lock Class template `unique_lock`]

    #include <boost/thread/locks.hpp>

    template<typename Lockable>
    class unique_lock
    {
    public:
        unique_lock();
        explicit unique_lock(Lockable& m_);
        unique_lock(Lockable& m_,adopt_lock_t);
        unique_lock(Lockable& m_,defer_lock_t);
        unique_lock(Lockable& m_,try_to_lock_t);
        unique_lock(Lockable& m_,system_time const& target_time);

        ~unique_lock();

        unique_lock(detail::thread_move_t<unique_lock<Lockable> > other);
        unique_lock(detail::thread_move_t<upgrade_lock<Lockable> > other);

        operator detail::thread_move_t<unique_lock<Lockable> >();
        detail::thread_move_t<unique_lock<Lockable> > move();
        unique_lock& operator=(detail::thread_move_t<unique_lock<Lockable> > other);
        unique_lock& operator=(detail::thread_move_t<upgrade_lock<Lockable> > other);

        void swap(unique_lock& other);
        void swap(detail::thread_move_t<unique_lock<Lockable> > other);

        void lock();
        bool try_lock();

        template<typename TimeDuration>
        bool timed_lock(TimeDuration const& relative_time);
        bool timed_lock(::boost::system_time const& absolute_time);

        void unlock();

        bool owns_lock() const;
        operator ``['unspecified-bool-type]``() const;
        bool operator!() const;

        Lockable* mutex() const;
        Lockable* release();
    };

__unique_lock__ is more complex than __lock_guard__: not only does it provide for RAII-style locking, it also allows for deferring
acquiring the lock until the __lock_ref__ member function is called explicitly, or trying to acquire the lock in a non-blocking
fashion, or with a timeout. Consequently, __unlock_ref__ is only called in the destructor if the lock object has locked the
__lockable_concept_type__ object, or otherwise adopted a lock on the __lockable_concept_type__ object.\n
__unique_lock__ 比 __lock_guard__ 复杂许多: 不仅提供RAII风格的外观, 它还允许推迟获得锁定, 直到 __lock_ref__ 函数显式调用, 
或者试图以非阻塞方式或超时方式获得锁定。最后, 析构函数在 __lockable_concept_type__ 对象被其锁定的情况下调用 __unlock_ref__ 函数, 
否则取得可锁定对象的一个锁。

Specializations of __unique_lock__ model the __timed_lockable_concept__ if the supplied __lockable_concept_type__ type itself models
__timed_lockable_concept__ (e.g. `boost::unique_lock<boost::timed_mutex>`), or the __lockable_concept__ otherwise
(e.g. `boost::unique_lock<boost::mutex>`). \n
__unique_lock__ 的特化如果提供了实现 __timed_lockable_concept__ 的 __lockable_concept_type__，就实现了 __timed_lockable_concept__
(如 boost::unique_lock<boost::timed_mutex>), 否则为 __lockable_concept__ (如 boost::unique_lock<boost::mutex>)。

An instance of __unique_lock__ is said to ['own] the lock state of a __lockable_concept_type__ `m` if __mutex_func_ref__ returns a
pointer to `m` and __owns_lock_ref__ returns `true`. If an object that ['owns] the lock state of a __lockable_concept_type__ object
is destroyed, then the destructor will invoke [unlock_ref_link `mutex()->unlock()`].\n
如果 __mutex_func_ref__ 返回指向的 `m` 的指针并且 __owns_lock_ref__ 返回 `true`，则称该 __unique_lock__ 实例['拥有]一个 
__lockable_concept_type__ 对象 `m` 的锁定状态。如果一个['拥有] __lockable_concept_type__ 对象的锁定状态的对象被销毁, 
其析构函数会调用函数 [unlock_ref_link `mutex()->unlock()`]。

The member functions of __unique_lock__ are not thread-safe. In particular, __unique_lock__ is intended to model the ownership of a
__lockable_concept_type__ object by a particular thread, and the member functions that release ownership of the lock state
(including the destructor) must be called by the same thread that acquired ownership of the lock state.\n
__unique_lock__ 的成员函数不是线程安全的。特别的, __unique_lock__ 是针对单一线程对 __lockable_concept_type__ 对象所有权建立模型的, 
这样一个对象的成员函数（包括析构函数）必须在同一个线程内调用。

[section:defaultconstructor `unique_lock()`]

[variablelist

[[Effects:] [Creates a lock object with no associated mutex.\n
创建一个锁对象，没有关联到任何互斥量。]]

[[Postcondition:] [__owns_lock_ref__ returns `false`. __mutex_func_ref__ returns `NULL`.\n
__owns_lock_ref__ 返回 `false`，__mutex_func_ref__ 返回 `NULL`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor `unique_lock(Lockable & m)`]

[variablelist

[[Effects:] [Stores a reference to `m`. Invokes [lock_ref_link `m.lock()`].\n
存储 `m` 的引用. 调用 [lock_ref_link `m.lock()`]。 ]]

[[Postcondition:] [__owns_lock_ref__ returns `true`. __mutex_func_ref__ returns `&m`.\n
__owns_lock_ref__ 返回 `true`，__mutex_func_ref__ 返回 `&m`。]]

[[Throws:] [Any exception thrown by the call to [lock_ref_link `m.lock()`].\n
调用 [lock_ref_link `m.lock()`] 可能抛出的异常。]]

]

[endsect]

[section:constructor_adopt `unique_lock(Lockable & m,boost::adopt_lock_t)`]

[variablelist

[[Precondition:] [The current thread owns an exclusive lock on `m`.\n
当前线程拥有对 `m` 的独占锁。]]

[[Effects:] [Stores a reference to `m`. Takes ownership of the lock state of `m`.\n
存储 `m` 的引用。接管 `m` 的所有权。]]

[[Postcondition:] [__owns_lock_ref__ returns `true`. __mutex_func_ref__ returns `&m`.\n
__owns_lock_ref__ 返回 `true`。__mutex_func_ref__ 返回 `&m`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor_defer `unique_lock(Lockable & m,boost::defer_lock_t)`]

[variablelist

[[Effects:] [Stores a reference to `m`.\n
存储 `m` 的引用。]]

[[Postcondition:] [__owns_lock_ref__ returns `false`. __mutex_func_ref__ returns `&m`.\n
__owns_lock_ref__ 返回 `false`。__mutex_func_ref__ 返回 `&m`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor_try `unique_lock(Lockable & m,boost::try_to_lock_t)`]

[variablelist

[[Effects:] [Stores a reference to `m`. Invokes [try_lock_ref_link
`m.try_lock()`], and takes ownership of the lock state if the call returns
`true`.\n
存储 `m` 的引用. 调用 [try_lock_ref_link `m.try_lock()`], 如果调回返回 `true` 则接管锁状态的所有权。]]

[[Postcondition:] [__mutex_func_ref__ returns `&m`. If the call to __try_lock_ref__
returned `true`, then __owns_lock_ref__ returns `true`, otherwise __owns_lock_ref__
returns `false`.\n
__mutex_func_ref__ 返回 `&m`。如果对 __try_lock_ref__ 的调用返回 `true`, 那么 __owns_lock_ref__ 返回 `true`, 
否则 __owns_lock_ref__ 返回 `false`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor_abs_time `unique_lock(Lockable & m,boost::system_time const& abs_time)`]

[variablelist

[[Effects:] [Stores a reference to `m`. Invokes [timed_lock_ref_link
`m.timed_lock(abs_time)`], and takes ownership of the lock state if the call
returns `true`.\n
存储 `m` 的引用。调用 [timed_lock_ref_link `m.timed_lock(abs_time)`], 如果调回返回 `true` 则接管锁状态的所有权。]]

[[Postcondition:] [__mutex_func_ref__ returns `&m`. If the call to __timed_lock_ref__
returned `true`, then __owns_lock_ref__ returns `true`, otherwise __owns_lock_ref__
returns `false`.\n
__mutex_func_ref__ 返回 `&m`。如果调用 __timed_lock_ref__ 返回 `true`, 那么 __owns_lock_ref__ 返回 `true`, 
否则 __owns_lock_ref__ 返回 `false`。]]

[[Throws:] [Any exceptions thrown by the call to [timed_lock_ref_link `m.timed_lock(abs_time)`].\n
调用 [timed_lock_ref_link `m.timed_lock(abs_time)`] 可能抛出的异常。]]

]

[endsect]

[section:destructor `~unique_lock()`]

[variablelist

[[Effects:] [Invokes __mutex_func_ref__`->`[unlock_ref_link `unlock()`] if
__owns_lock_ref__ returns `true`.\n
如果 __owns_lock_ref__ 返回 `true`，调用 __mutex_func_ref__->[unlock_ref_link `unlock()`]。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:owns_lock `bool owns_lock() const`]

[variablelist

[[Returns:] [`true` if the `*this` owns the lock on the __lockable_concept_type__
object associated with `*this`.\n
如果 `*this` 拥有其关联 __lockable_concept_type__ 对象的锁定，返回 `true`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:mutex `Lockable* mutex() const`]

[variablelist

[[Returns:] [A pointer to the __lockable_concept_type__ object associated with
`*this`, or `NULL` if there is no such object.\n
返回 `*this` 关联的 __lockable_concept_type__ 对象指针, 如果没有返回 `NULL`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:bool_conversion `operator unspecified-bool-type() const`]

[variablelist

[[Returns:] [If __owns_lock_ref__ would return `true`, a value that evaluates to
`true` in boolean contexts, otherwise a value that evaluates to `false` in
boolean contexts.\n
如果 __owns_lock_ref__ 返回 `true`, 该操作符返回逻辑上的 `true`, 否则为 `false`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:operator_not `bool operator!() const`]

[variablelist

[[Returns:] [`!` __owns_lock_ref__.]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:release `Lockable* release()`]

[variablelist

[[Effects:] [The association between `*this` and the __lockable_concept_type__ object is removed, without affecting the lock state
of the __lockable_concept_type__ object. If __owns_lock_ref__ would have returned `true`, it is the responsibility of the calling
code to ensure that the __lockable_concept_type__ is correctly unlocked.\n
移除 `*this` 和 __lockable_concept_type__ 对象的关联, 不改变 __lockable_concept_type__ 对象的锁定状态。
如果在这个函数调用前 __owns_lock_ref__ 返回 `true`, 后续代码需要保证 __lockable_concept_type__ 对象被正确解锁。]]

[[Returns:] [A pointer to the __lockable_concept_type__ object associated with `*this` at the point of the call, or `NULL` if there
is no such object.\n
`*this` 关联的 __lockable_concept_type__ 对象指针, 如果没有关联，则为 `NULL`。]]

[[Throws:] [Nothing.\n
无]]

[[Postcondition:] [`*this` is no longer associated with any __lockable_concept_type__ object. __mutex_func_ref__ returns `NULL` and
__owns_lock_ref__ returns `false`.\n
`*this` 不再和 __lockable_concept_type__ 对象关联。__mutex_func_ref__ 返回 `NULL` 并且 __owns_lock_ref__ 返回 `false`。]]

]

[endsect]

[endsect]

[section:shared_lock Class template `shared_lock`]

    #include <boost/thread/locks.hpp>

    template<typename Lockable>
    class shared_lock
    {
    public:
        shared_lock();
        explicit shared_lock(Lockable& m_);
        shared_lock(Lockable& m_,adopt_lock_t);
        shared_lock(Lockable& m_,defer_lock_t);
        shared_lock(Lockable& m_,try_to_lock_t);
        shared_lock(Lockable& m_,system_time const& target_time);
        shared_lock(detail::thread_move_t<shared_lock<Lockable> > other);
        shared_lock(detail::thread_move_t<unique_lock<Lockable> > other);
        shared_lock(detail::thread_move_t<upgrade_lock<Lockable> > other);

        ~shared_lock();

        operator detail::thread_move_t<shared_lock<Lockable> >();
        detail::thread_move_t<shared_lock<Lockable> > move();

        shared_lock& operator=(detail::thread_move_t<shared_lock<Lockable> > other);
        shared_lock& operator=(detail::thread_move_t<unique_lock<Lockable> > other);
        shared_lock& operator=(detail::thread_move_t<upgrade_lock<Lockable> > other);
        void swap(shared_lock& other);

        void lock();
        bool try_lock();
        bool timed_lock(boost::system_time const& target_time);
        void unlock();

        operator ``['unspecified-bool-type]``() const;
        bool operator!() const;
        bool owns_lock() const;
    };

Like __unique_lock__, __shared_lock__ models the __lockable_concept__, but rather than acquiring unique ownership of the supplied
__lockable_concept_type__ object, locking an instance of __shared_lock__ acquires shared ownership.\n
和 __unique_lock__ 一样, __shared_lock__ 对 __lockable_concept__ 建模, 但是不仅支持 __lockable_concept_type__ 对象的唯一所有权获取, 
还支持 __shared_lock__ 的共享所有权获取。

Like __unique_lock__, not only does it provide for RAII-style locking, it also allows for deferring acquiring the lock until the
__lock_ref__ member function is called explicitly, or trying to acquire the lock in a non-blocking fashion, or with a
timeout. Consequently, __unlock_ref__ is only called in the destructor if the lock object has locked the __lockable_concept_type__
object, or otherwise adopted a lock on the __lockable_concept_type__ object.\n
和 __unique_lock__ 一样，不仅提供RAII风格的外观, 它也允许推迟获得锁定, 直到 __lock_ref__ 函数被显式调用, 或者支持非阻塞方式获得锁定, 
或者是支持超时锁定。最后, 析构函数在 __lockable_concept_type__ 对象被其锁定的情况下调用 __unlock_ref__ 函数, 
否则取得 __lockable_concept_type__ 对象上的一个锁。

An instance of __shared_lock__ is said to ['own] the lock state of a __lockable_concept_type__ `m` if __mutex_func_ref__ returns a
pointer to `m` and __owns_lock_ref__ returns `true`. If an object that ['owns] the lock state of a __lockable_concept_type__ object
is destroyed, then the destructor will invoke [unlock_shared_ref_link `mutex()->unlock_shared()`].\n
如果函数 __mutex_func_ref__ 返回指向 `m` 的指针并且 __owns_lock_ref__ 返回 `true`，就说该 __shared_lock__ 实例['拥有]一个 
__lockable_concept_type__ 对象的锁定状态。如果一个['拥有] __lockable_concept_type__ 对象的锁定状态的实例被销毁, 
则析构函数会调用 [unlock_shared_ref_link `mutex()->unlock_shared()`]。 

The member functions of __shared_lock__ are not thread-safe. In particular, __shared_lock__ is intended to model the shared
ownership of a __lockable_concept_type__ object by a particular thread, and the member functions that release ownership of the lock
state (including the destructor) must be called by the same thread that acquired ownership of the lock state.\n
__shared_lock__ 的成员函数不是线程安全的。特别的, __shared_lock__ 是针对单一线程对 __lockable_concept_type__ 对象所有权建立模型的, 
这样一个对象的成员函数（包含构造析构函数）必须在同一个线程内调用。


[section:defaultconstructor `shared_lock()`]

[variablelist

[[Effects:] [Creates a lock object with no associated mutex.\n
创建一个不关联到任何互斥量的锁定对象。]]

[[Postcondition:] [__owns_lock_ref__ returns `false`. __mutex_func_ref__ returns `NULL`.\n
__owns_lock_ref__ 返回 `false`. __mutex_func_ref__ 返回 `NULL`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor `shared_lock(Lockable & m)`]

[variablelist

[[Effects:] [Stores a reference to `m`. Invokes [lock_shared_ref_link `m.lock_shared()`].\n
存储 `m` 的引用，并调用 [lock_shared_ref_link `m.lock_shared()`]。 ]]

[[Postcondition:] [__owns_lock_shared_ref__ returns `true`. __mutex_func_ref__ returns `&m`.\n
__owns_lock_shared_ref__ 返回 `true`. __mutex_func_ref__ 返回 `&m`。]]

[[Throws:] [Any exception thrown by the call to [lock_shared_ref_link `m.lock_shared()`].\n
调用 [lock_shared_ref_link `m.lock_shared()`] 可能抛出的异常。]]

]

[endsect]

[section:constructor_adopt `shared_lock(Lockable & m,boost::adopt_lock_t)`]

[variablelist

[[Precondition:] [The current thread owns an exclusive lock on `m`.\n
当前线程拥有对 `m` 独占锁定。]]

[[Effects:] [Stores a reference to `m`. Takes ownership of the lock state of `m`.\n
存储 `m` 的引用，接管 `m` 锁定状态。]]

[[Postcondition:] [__owns_lock_shared_ref__ returns `true`. __mutex_func_ref__ returns `&m`.\n
__owns_lock_shared_ref__ 返回 `true`. __mutex_func_ref__ 返回 `&m`。 ]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor_defer `shared_lock(Lockable & m,boost::defer_lock_t)`]

[variablelist

[[Effects:] [Stores a reference to `m`.\n
存储 `m` 的引用。]]

[[Postcondition:] [__owns_lock_shared_ref__ returns `false`. __mutex_func_ref__ returns `&m`.\n
__owns_lock_shared_ref__ 返回 `false`. __mutex_func_ref__ 返回 `&m`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor_try `shared_lock(Lockable & m,boost::try_to_lock_t)`]

[variablelist

[[Effects:] [Stores a reference to `m`. Invokes [try_lock_shared_ref_link
`m.try_lock_shared()`], and takes ownership of the lock state if the call returns
`true`.\n
存储 `m` 的引用，调用 [try_lock_shared_ref_link `m.try_lock_shared()`]，如果调用返回 `true` 则接管锁定状态。]]

[[Postcondition:] [__mutex_func_ref__ returns `&m`. If the call to __try_lock_shared_ref__
returned `true`, then __owns_lock_shared_ref__ returns `true`, otherwise __owns_lock_shared_ref__
returns `false`.\n
__mutex_func_ref__ 返回 `&m`，如果调用 __try_lock_shared_ref__ 返回 `true`，那么 __owns_lock_shared_ref__ 返回 `true`，
否则 __owns_lock_shared_ref__ 返回 `false`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:constructor_abs_time `shared_lock(Lockable & m,boost::system_time const& abs_time)`]

[variablelist

[[Effects:] [Stores a reference to `m`. Invokes [timed_lock_shared_ref_link
`m.timed_lock(abs_time)`], and takes ownership of the lock state if the call
returns `true`.\n
存储 `m` 的引用，调用 [timed_lock_shared_ref_link `m.timed_lock(abs_time)`]，如果调用返回 `true` 则接管锁定状态。]]

[[Postcondition:] [__mutex_func_ref__ returns `&m`. If the call to __timed_lock_shared_ref__
returned `true`, then __owns_lock_shared_ref__ returns `true`, otherwise __owns_lock_shared_ref__
returns `false`.\n
__mutex_func_ref__ 返回 `&m`. 如果调用 __timed_lock_shared_ref__ 返回 `true`，那么 __owns_lock_shared_ref__ 返回 `true`，
否则 __owns_lock_shared_ref__ 返回 `false`。]]

[[Throws:] [Any exceptions thrown by the call to [timed_lock_shared_ref_link `m.timed_lock(abs_time)`].\n
调用函数 [timed_lock_shared_ref_link `m.timed_lock(abs_time)`] 可能抛出的异常。]]

]

[endsect]

[section:destructor `~shared_lock()`]

[variablelist

[[Effects:] [Invokes __mutex_func_ref__`->`[unlock_shared_ref_link `unlock_shared()`] if
__owns_lock_shared_ref__ returns `true`.\n
如果 __owns_lock_shared_ref__ 返回 `true` 则调用 __mutex_func_ref__`->`[unlock_shared_ref_link `unlock_shared()`]。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:owns_lock `bool owns_lock() const`]

[variablelist

[[Returns:] [`true` if the `*this` owns the lock on the __lockable_concept_type__
object associated with `*this`.\n
如果 `*this` 拥有所关联的 __lockable_concept_type__ 对象的锁定，返回 `true`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:mutex `Lockable* mutex() const`]

[variablelist

[[Returns:] [A pointer to the __lockable_concept_type__ object associated with
`*this`, or `NULL` if there is no such object.\n
返回 `*this` 关联的 __lockable_concept_type__ 对象指针, 如果没有返回 `NULL`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:bool_conversion `operator unspecified-bool-type() const`]

[variablelist

[[Returns:] [If __owns_lock_shared_ref__ would return `true`, a value that evaluates to
`true` in boolean contexts, otherwise a value that evaluates to `false` in
boolean contexts.\n
如果 __owns_lock_shared_ref__ 返回 `true`, 该操作符返回逻辑上的 `true`, 否则为 `false`。]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:operator_not `bool operator!() const`]

[variablelist

[[Returns:] [`!` __owns_lock_shared_ref__.]]

[[Throws:] [Nothing.\n
无]]

]

[endsect]

[section:release `Lockable* release()`]

[variablelist

[[Effects:] [The association between `*this` and the __lockable_concept_type__ object is removed, without affecting the lock state
of the __lockable_concept_type__ object. If __owns_lock_shared_ref__ would have returned `true`, it is the responsibility of the calling
code to ensure that the __lockable_concept_type__ is correctly unlocked.\n
移除 `*this` 和 __lockable_concept_type__ 对象的关联, 不改变 __lockable_concept_type__ 对象的锁定状态。
如果在这个函数调用前 __owns_lock_shared_ref__ 返回 `true`, 则后续代码需要保证 __lockable_concept_type__ 对象被正确解锁。]]

[[Returns:] [A pointer to the __lockable_concept_type__ object associated with `*this` at the point of the call, or `NULL` if there
is no such object.\n
返回 `*this` 关联的 __lockable_concept_type__ 对象指针, 如果没有返回 `NULL`。]]

[[Throws:] [Nothing.\n
无]]

[[Postcondition:] [`*this` is no longer associated with any __lockable_concept_type__ object. __mutex_func_ref__ returns `NULL` and
__owns_lock_shared_ref__ returns `false`.\n
`*this` 不再和 __lockable_concept_type__ 对象关联。__mutex_func_ref__ 返回 `NULL` 且 __owns_lock_shared_ref__ 返回 `false`。]]

]

[endsect]

[endsect]

[section:upgrade_lock Class template `upgrade_lock`]

    #include <boost/thread/locks.hpp>

    template<typename Lockable>
    class upgrade_lock
    {
    public:
        explicit upgrade_lock(Lockable& m_);

        upgrade_lock(detail::thread_move_t<upgrade_lock<Lockable> > other);
        upgrade_lock(detail::thread_move_t<unique_lock<Lockable> > other);

        ~upgrade_lock();

        operator detail::thread_move_t<upgrade_lock<Lockable> >();
        detail::thread_move_t<upgrade_lock<Lockable> > move();

        upgrade_lock& operator=(detail::thread_move_t<upgrade_lock<Lockable> > other);
        upgrade_lock& operator=(detail::thread_move_t<unique_lock<Lockable> > other);

        void swap(upgrade_lock& other);

        void lock();
        void unlock();

        operator ``['unspecified-bool-type]``() const;
        bool operator!() const;
        bool owns_lock() const;
    };

Like __unique_lock__, __upgrade_lock__ models the __lockable_concept__, but rather than acquiring unique ownership of the supplied
__lockable_concept_type__ object, locking an instance of __upgrade_lock__ acquires upgrade ownership.\n
和 __unique_lock__ 一样，__upgrade_lock__ 对 __lockable_concept__ 建模，但是不仅限于 __lockable_concept__ 对象提供的独占锁定，
还可锁定一个 __upgrade_lock__ 实例以获取升级的所有权。

Like __unique_lock__, not only does it provide for RAII-style locking, it also allows for deferring acquiring the lock until the
__lock_ref__ member function is called explicitly, or trying to acquire the lock in a non-blocking fashion, or with a
timeout. Consequently, __unlock_ref__ is only called in the destructor if the lock object has locked the __lockable_concept_type__
object, or otherwise adopted a lock on the __lockable_concept_type__ object.\n
和 __unique_lock__ 一样，不仅提供RAII风格的外观, 它也允许推迟获得锁定, 直到 __lock_ref__ 函数被显式调用, 或者支持非阻塞方式获得锁定, 
或者是支持超时锁定。最后, 析构函数在 __lockable_concept_type__ 对象被其锁定的情况下调用 __unlock_ref__ 函数, 
否则取得 __lockable_concept_type__ 对象上的一个锁。

An instance of __upgrade_lock__ is said to ['own] the lock state of a __lockable_concept_type__ `m` if __mutex_func_ref__ returns a
pointer to `m` and __owns_lock_ref__ returns `true`. If an object that ['owns] the lock state of a __lockable_concept_type__ object
is destroyed, then the destructor will invoke [unlock_upgrade_ref_link `mutex()->unlock_upgrade()`].\n
如果函数 __mutex_func_ref__ 返回指向 `m` 的指针并且 __owns_lock_ref__ 返回 `true`，就说该 __upgrade_lock__ 实例['拥有]一个 
__lockable_concept_type__ 对象的锁定状态。如果一个['拥有] __lockable_concept_type__ 对象的锁定状态的实例被销毁, 
则析构函数会调用 [unlock_upgrade_ref_link `mutex()->unlock_upgrade()`]。

The member functions of __upgrade_lock__ are not thread-safe. In particular, __upgrade_lock__ is intended to model the upgrade
ownership of a __lockable_concept_type__ object by a particular thread, and the member functions that release ownership of the lock
state (including the destructor) must be called by the same thread that acquired ownership of the lock state.\n
__upgrade_lock__ 的成员函数不是线程安全的。特别的, __upgrade_lock__ 是针对单一线程对 __lockable_concept_type__ 对象所有权建立模型的, 
这样一个对象的成员函数（包含构造析构函数）必须在同一个线程内调用。

[endsect]

[section:upgrade_to_unique_lock Class template `upgrade_to_unique_lock`]

    #include <boost/thread/locks.hpp>

    template <class Lockable>
    class upgrade_to_unique_lock
    {
    public:
        explicit upgrade_to_unique_lock(upgrade_lock<Lockable>& m_);

        ~upgrade_to_unique_lock();

        upgrade_to_unique_lock(detail::thread_move_t<upgrade_to_unique_lock<Lockable> > other);
        upgrade_to_unique_lock& operator=(detail::thread_move_t<upgrade_to_unique_lock<Lockable> > other);
        void swap(upgrade_to_unique_lock& other);

        operator ``['unspecified-bool-type]``() const;
        bool operator!() const;
        bool owns_lock() const;
    };

__upgrade_to_unique_lock__ allows for a temporary upgrade of an __upgrade_lock__ to exclusive ownership. When constructed with a
reference to an instance of __upgrade_lock__, if that instance has upgrade ownership on some __lockable_concept_type__ object, that
ownership is upgraded to exclusive ownership. When the __upgrade_to_unique_lock__ instance is destroyed, the ownership of the
__lockable_concept_type__ is downgraded back to ['upgrade ownership].\n
__upgrade_to_unique_lock__ 允许临时从 __upgrade_lock__ 升级到独占锁定。在以一个 __upgrade_lock__ 对象的引用进行构造时，
如果该实例具有某个 __lockable_concept_type__ 对象的升级所有权，则所有权将升级为独占所有权。
当这个 __upgrade_to_unique_lock__ 对象被销毁时，__lockable_concept_type__ 对象恢复为['升级所有权]。

[endsect]

[section:scoped_try_lock Mutex-specific class `scoped_try_lock`]

    class MutexType::scoped_try_lock
    {
    private:
        MutexType::scoped_try_lock(MutexType::scoped_try_lock<MutexType>& other);
        MutexType::scoped_try_lock& operator=(MutexType::scoped_try_lock<MutexType>& other);
    public:
        MutexType::scoped_try_lock();
        explicit MutexType::scoped_try_lock(MutexType& m);
        MutexType::scoped_try_lock(MutexType& m_,adopt_lock_t);
        MutexType::scoped_try_lock(MutexType& m_,defer_lock_t);
        MutexType::scoped_try_lock(MutexType& m_,try_to_lock_t);

        MutexType::scoped_try_lock(MutexType::scoped_try_lock<MutexType>&& other);
        MutexType::scoped_try_lock& operator=(MutexType::scoped_try_lock<MutexType>&& other);

        void swap(MutexType::scoped_try_lock&& other);

        void lock();
        bool try_lock();
        void unlock();
        bool owns_lock() const;

        MutexType* mutex() const;
        MutexType* release();
        bool operator!() const;

        typedef ``['unspecified-bool-type]`` bool_type;
        operator bool_type() const;
    };

The member typedef `scoped_try_lock` is provided for each distinct
`MutexType` as a typedef to a class with the preceding definition. The
semantics of each constructor and member function are identical to
those of [unique_lock_link `boost::unique_lock<MutexType>`] for the same `MutexType`, except
that the constructor that takes a single reference to a mutex will
call [try_lock_ref_link `m.try_lock()`] rather than `m.lock()`.\n
成员类型 `scoped_try_lock` 为已定义的不同的 `MutexType` 提供了一个类型定义。
其所有的函数与 [unique_lock_link `boost::unique_lock<MutexType>`] 中的 `MutexType` 类型相同，
除了带参数构造函数会调用 [try_lock_ref_link `m.try_lock()`] 而不是调用 `m.lock()`。


[endsect]

[endsect]

[section:lock_functions Lock functions]

[section:lock_multiple Non-member function `lock(Lockable1,Lockable2,...)`]

    template<typename Lockable1,typename Lockable2>
    void lock(Lockable1& l1,Lockable2& l2);

    template<typename Lockable1,typename Lockable2,typename Lockable3>
    void lock(Lockable1& l1,Lockable2& l2,Lockable3& l3);

    template<typename Lockable1,typename Lockable2,typename Lockable3,typename Lockable4>
    void lock(Lockable1& l1,Lockable2& l2,Lockable3& l3,Lockable4& l4);

    template<typename Lockable1,typename Lockable2,typename Lockable3,typename Lockable4,typename Lockable5>
    void lock(Lockable1& l1,Lockable2& l2,Lockable3& l3,Lockable4& l4,Lockable5& l5);

[variablelist

[[Effects:] [Locks the __lockable_concept_type__ objects supplied as
arguments in an unspecified and indeterminate order in a way that
avoids deadlock. It is safe to call this function concurrently from
multiple threads with the same mutexes (or other lockable objects) in
different orders without risk of deadlock. If any of the __lock_ref__
or __try_lock_ref__ operations on the supplied
__lockable_concept_type__ objects throws an exception any locks
acquired by the function will be released before the function exits.\n
锁定参数提供的 __lockable_concept_type__ 对象，并避免死锁。该函数在多个线程并发调用锁定同一组互斥量（或其他可锁定对象）是安全的，
并且不用指定锁定顺序，也不用担心死锁。如果所提供的 __lockable_concept_type__ 对象上的任一 __lock_ref__ 或 __try_lock_ref__ 操作抛出异常，
那么在函数退出前，该函数此次调用已锁定的对象也会被释放。]]

[[Throws:] [Any exceptions thrown by calling __lock_ref__ or
__try_lock_ref__ on the supplied __lockable_concept_type__ objects.\n
所提供的 __lockable_concept_type__ 对象上所调用的 __lock_ref__ 或 __try_lock_ref__ 操作所抛出的任何异常。]]

[[Postcondition:] [All the supplied __lockable_concept_type__ objects
are locked by the calling thread.\n
参数中提供的所有 __lockable_concept_type__ 对象都被当前调用线程加锁。]]

]

[endsect]

[section:lock_range Non-member function `lock(begin,end)`]

    template<typename ForwardIterator>
    void lock(ForwardIterator begin,ForwardIterator end);

[variablelist

[[Preconditions:] [The `value_type` of `ForwardIterator` must implement the __lockable_concept__\n
`ForwardIterator` 的 `value_type` 需要实现 __lockable_concept__。]]

[[Effects:] [Locks all the __lockable_concept_type__ objects in the
supplied range in an unspecified and indeterminate order in a way that
avoids deadlock. It is safe to call this function concurrently from
multiple threads with the same mutexes (or other lockable objects) in
different orders without risk of deadlock. If any of the __lock_ref__
or __try_lock_ref__ operations on the __lockable_concept_type__
objects in the supplied range throws an exception any locks acquired
by the function will be released before the function exits.\n
锁定迭代区间的 __lockable_concept_type__ 对象，并避免死锁。 该函数在多个线程并发调用锁定同一组互斥量（或其他可锁定对象）是安全的，
并且不用指定锁定顺序，也不用担心死锁。如果在 __lockable_concept_type__ 对象上的任一 __lock_ref__ 或 __try_lock_ref__ 操作抛出异常，
那么在函数退出前，该函数此次调用已锁定的对象也会被释放。]]

[[Throws:] [Any exceptions thrown by calling __lock_ref__ or
__try_lock_ref__ on the supplied __lockable_concept_type__ objects.\n
所提供的 __lockable_concept_type__ 对象上所调用的 __lock_ref__ 或 __try_lock_ref__ 操作所抛出的任何异常。]]

[[Postcondition:] [All the __lockable_concept_type__ objects in the
supplied range are locked by the calling thread.\n
所提供区间中的所有 __lockable_concept_type__ 对象都被当前调用线程加锁。]]

]

[endsect]

[section:try_lock_multiple Non-member function `try_lock(Lockable1,Lockable2,...)`]

    template<typename Lockable1,typename Lockable2>
    int try_lock(Lockable1& l1,Lockable2& l2);

    template<typename Lockable1,typename Lockable2,typename Lockable3>
    int try_lock(Lockable1& l1,Lockable2& l2,Lockable3& l3);

    template<typename Lockable1,typename Lockable2,typename Lockable3,typename Lockable4>
    int try_lock(Lockable1& l1,Lockable2& l2,Lockable3& l3,Lockable4& l4);

    template<typename Lockable1,typename Lockable2,typename Lockable3,typename Lockable4,typename Lockable5>
    int try_lock(Lockable1& l1,Lockable2& l2,Lockable3& l3,Lockable4& l4,Lockable5& l5);

[variablelist

[[Effects:] [Calls __try_lock_ref__ on each of the
__lockable_concept_type__ objects supplied as arguments. If any of the
calls to __try_lock_ref__ returns `false` then all locks acquired are
released and the zero-based index of the failed lock is returned.\n
对参数中的 __lockable_concept_type__ 对象依次调用 __try_lock_ref__  函数。如果有一个 __try_lock_ref__ 调用返回 `false`，
那么已经获得的锁定就会被释放，并返回这个锁定失败对象在参数中的序号（从0起计）。

If any of the __try_lock_ref__ operations on the supplied
__lockable_concept_type__ objects throws an exception any locks
acquired by the function will be released before the function exits.\n
如果提供的 __lockable_concept_type__ 对象中有一个 __try_lock_ref__ 调用抛出异常，那么已经获得的锁定会在函数退出前释放。]]

[[Returns:] [`-1` if all the supplied __lockable_concept_type__ objects
are now locked by the calling thread, the zero-based index of the
object which could not be locked otherwise.\n
如果所有 __lockable_concept_type__ 对象都成功加锁，返回 `-1`，否则返回第一个失败对象的序号（从0起计）。]]

[[Throws:] [Any exceptions thrown by calling __try_lock_ref__ on the
supplied __lockable_concept_type__ objects.\n
在所提供的 __lockable_concept_type__ 对象上调用 __try_lock_ref__ 可能抛出的异常。]]

[[Postcondition:] [If the function returns `-1`, all the supplied
__lockable_concept_type__ objects are locked by the calling
thread. Otherwise any locks acquired by this function will have been
released.\n
如果函数返回 `-1`, 所有 __lockable_concept_type__ 对象都被加锁，否则参数中的对象都不会加锁。]]

]

[endsect]

[section:try_lock_range Non-member function `try_lock(begin,end)`]

    template<typename ForwardIterator>
    ForwardIterator try_lock(ForwardIterator begin,ForwardIterator end);

[variablelist

[[Preconditions:] [The `value_type` of `ForwardIterator` must implement the __lockable_concept__\n
`ForwardIterator` 的 `value_type` 需要实现 __lockable_concept__。]]

[[Effects:] [Calls __try_lock_ref__ on each of the
__lockable_concept_type__ objects in the supplied range. If any of the
calls to __try_lock_ref__ returns `false` then all locks acquired are
released and an iterator referencing the failed lock is returned.\n
对所提供区间中的 __lockable_concept_type__ 对象依次调用 __try_lock_ref__  函数。如果有一个 __try_lock_ref__ 调用返回 `false`，
那么已经获得的锁定就会被释放，并返回这个锁定失败对象的迭代器。

If any of the __try_lock_ref__ operations on the supplied
__lockable_concept_type__ objects throws an exception any locks
acquired by the function will be released before the function exits.\n
如果提供的 __lockable_concept_type__ 对象中有一个 __try_lock_ref__ 调用抛出异常，那么已经获得的锁定会在函数退出前释放。]]

[[Returns:] [`end` if all the supplied __lockable_concept_type__
objects are now locked by the calling thread, an iterator referencing
the object which could not be locked otherwise.\n
如果所有 __lockable_concept_type__ 对象都成功加锁，返回 `end`，否则返回锁定失败对象的迭代器。]]

[[Throws:] [Any exceptions thrown by calling __try_lock_ref__ on the
supplied __lockable_concept_type__ objects.\n
在所提供的 __lockable_concept_type__ 对象上调用 __try_lock_ref__ 可能抛出的异常。]]

[[Postcondition:] [If the function returns `end` then all the
__lockable_concept_type__ objects in the supplied range are locked by
the calling thread, otherwise all locks acquired by the function have
been released.\n
如果函数返回 `end`, 所有 __lockable_concept_type__ 对象都被加锁，否则参数中的对象都不会加锁。]]

]

[endsect]


[endsect]

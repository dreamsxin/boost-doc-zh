<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  -->


  
  <title>Boost Graph Library: Graph Theory Review</title></head>

<body alink="#ff0000" bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b">

 
<img src="../../../boost.png" alt="C++ Boost" height="86" width="277"> 

<br clear="">



<h1>图论基础复习<br>
</h1>



<p>

</p>

<p>本章将复习一下图论的基本理论。如果读者以前接触过图算法，那么可以便可以马上开始本章的学习；如果读者以前没有相关图算法背景知识，我们建议最好还是对其有一个了解，可以去看Cormen, Leiserson, 和Rivest写的<a href="http://toc.lcs.mit.edu/%7Eclr/">Introduction to Algorithms</a>(《算法导论》)。

</p>

<p>

</p>

<h1>图简介<br>
</h1>
图是用来解决各种实际问题的数学抽象。从根本上说，一个图是由一组顶点集合和一组边集合组成的，其中，一条边连接图中两个顶点。更准确的描述是，一个组是
一个（V，E）对，V是一个有限集，e是表示V的二元关系。V被称作顶点集,其中的元素统称为vertices。E是边的集合，一条边是一个(u,v)
对，u,v分别是顶点集V中的元素。在一个有向图中，边是一个连接源点和目标点的有序对。在一个无向图中，边是一个无序对，仅仅连接两个顶点，因此五项途
中（u，v）和（v，u）含义相同。<br>
<br>
<br>
以上对于图的定义在某些方面有点含糊不清，例如，没有说清顶点和边到底表示什么。他们可能是城市和连接城市的公路；亦或是网页和链接网页的超链接。这些细
节不被考虑到定义中是有原因的，它们不属于图抽象的部分。通过省略这些细节，我们能够建立一个可复用的原理，它能够帮我们解决各种不同的问题。<br>
<br>
<br>
切回到我们的定义：图是一组顶点和边的集合。演示一下，我们来建立一个图，该图顶点已经用字母标好，因此边可以简单的写成一个字母对。现在我们可以写出一个有向图，如下：<br>
<div align="center">
<table>

  <tbody>

    <tr>

      <td><tt>
V = {v, b, x, z, a, y } <br>


E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } <br>


G = (V, E)
      </tt></td>

    </tr>

  
  </tbody>
</table>


</div>


<br clear="all">

<p></p>




<p>
<a href="#fig:directed-graph">图一</a> 是该图的图示版。边（x，x）叫做闭包。边（b，y）和另一条（b，y）边是平行边，平行变仅仅出现在多重图中（一般有向图和无向图是不允许出现的）。

</p>

<p>

</p>

<p></p>


<div align="center"><a name="fig:directed-graph"></a><a name="1509"></a>
<table>


  <caption align="bottom"><strong>图 1:</strong>
一个有向图的例子</caption>
  <tbody>

    <tr>

      <td><img src="./figs/digraph.gif" height="163" width="124"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>
下面我们将演示一个与图一相似的图，不过这次是无向的。<a href="graph_theory_review.html#fig:undirected-graph">图二</a>是该图的图示。闭包是不允许出现在无向图中的。该图是边（b，y）的无向版本，相同的顶点和去除方向的边。相同的边被删除，有些边被合并，比如（a，z）和（z，a）。无向图的有向版本是把其中每条边换成两条，每一条指向一个方向。<br>
<div align="center">
<table>

  <tbody>

    <tr>

      <td><tt>
V = {v, b, x, z, a, y }<br>


E = { (b,y), (y,v), (z,a), (b,x), (x,v) }<br>


G = (V, E)
      </tt></td>

    </tr>

  
  </tbody>
</table>


</div>


<a name="def:directed-version"><br clear="all">

</a>
<p></p>



<p>

</p>

<p></p>


<div align="center"><a name="fig:undirected-graph"></a><a name="1524"></a>
<table>


  <caption align="bottom"><strong>图 2:</strong> 一个无向图的例子</caption>
  <tbody>

    <tr>

      <td><img src="./figs/undigraph.gif" height="163" width="103"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>
现在开始讲讲图的专业术语吧。如果边（u，v）属于一个图，那么顶点v是顶点u的邻接点。在一个有向图中，边（u，v）是顶点u的出边、顶点v的入边。在一个无向图中，边（u，v）是与u，v关联的。<br>
<p>在<a href="graph_theory_review.html#fig:directed-graph">图一</a>中，顶点y是顶点b的邻接点（但是b不是y的邻接）。边（b，y）是b的出边，是y的入边。在&nbsp;<a href="graph_theory_review.html#fig:undirected-graph">图二</a>中，y是b的临界点，反之亦然。边（y，b）是与y和b关联的。<br>
<br>
</p>
在有向图中，一个顶点出边的数量叫做该点的出度，入边的数量叫做该点的入度。无向图中，点关联的边的数量叫做该点的度。在<a href="graph_theory_review.html#fig:directed-graph">图一</a>中，顶点的出度是3，入度是0。在<a href="graph_theory_review.html#fig:undirected-graph">图二</a>中，顶点b仅仅是度为2。<br>
<br>
<br>
路径是图中边的序列，该序列中，每条边的目标顶点是下一条边的源顶点。如果一条路径起始于顶点u终止于顶点v，那么我们便说v是从u可到达的。如果一条路
径中没有重复顶点，我们便称该路径是简单的。路径&lt;(b,x),(x,v)&gt;是简单的，但是&lt;(a,z),(z,a)&gt;不是。路
径&lt;(a,z),(z,a)&gt;叫做环，因为路径中起点和终点是同一个点。一个没有环的图被称作无环的。<br>
<br>
<br>
可平面图是一个图能够被画到一个平面上，并且其中没有边相互交叉。能够用上面方法画出的图叫做平面图。一个平面图的面是被边环绕的平面的连通区域。可平面
图的一个重要性质是：面、边和顶点的数量关系遵循欧拉公式：|F|-|E|+|V|=2。这意味着简单的可平面图最多有O(|V|)条边。<br>
<p>

</p>

<h1>图相关数据结构<br>
</h1>
在图中，考虑使用什么数据结构时，最重要的一个属性是稀疏性，稀疏性指边的数量相对于点的数量。一个图中，边的数量接近于顶点平方，该图是稠密图，反之，
一个图中E=α×V，并且α比V小得多的时候称该图为稀疏图。表示稠密图，邻接矩阵表示法是最佳选择；邻接列表表示
法是稀疏图的最佳选择。某些情况下，对于稀疏图，边-表表示法在空间效率选择上更加合适。<br>
<h2>邻接矩阵表示法<br>
</h2>



<p>图的邻接矩阵表示的就是一个V×V的2维数组。数组中的每一个元素auv存储一个布尔值，该值表示边（u，v）是否出现在图中。<a href="graph_theory_review.html#fig:adj-matrix">图三</a>表示的是<a href="graph_theory_review.html#fig:directed-graph">图一</a>的邻接矩阵（删除了平行边（b，y））。存储一个邻接矩阵需要的空间是O(V2)。访问、增加、删除一条边的复杂度是O(1)。增加或者删除一个顶点需要重新分配空间并且拷贝整张图到新的空间，负责度是O(V2)。&nbsp;<a href="adjacency_matrix.html"><tt>adjacency_matrix</tt></a> 类实现了按照BGL的图接口规范实现了邻接矩阵数据结构。<br>
</p>


<div align="center"><a name="fig:adj-matrix"></a><a name="1701"></a>
<table>


  <caption align="bottom"><strong>图 3:</strong>
图的邻接矩阵表示法</caption>
  <tbody>

    <tr>

      <td><img src="./figs/adj_matrix.gif" height="135" width="136"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>



<p>

</p>

<h2><a name="sec:adjacency-list-representation"></a>&nbsp;邻接表表示法
</h2>



<p>图的邻接列表表示的是每个顶点的出边序列。对于一个稀疏图来讲，该表示法节省了空间，因为仅需了O(V +
E)大小的内存。而且，访问顶点出边更加有效率。边得插入操作复杂度是O(1)，但是访问制定边的效率是O(α)，α表示矩阵的
稀疏因子（稀疏因子等于最大的顶点出度）。<a href="graph_theory_review.html#fig:adj-list">图四</a>表示的是<a href="graph_theory_review.html#fig:directed-graph">图一</a>的邻接列表。
<a href="adjacency_list.html"><tt>adjacency_list</tt></a> 类是邻接列表表示法的一个实现。<br>
<br>
</p>
<p></p>


<div align="center"><a name="fig:adj-list"></a><a name="1713"></a>
<table>


  <caption align="bottom"><strong>图 4:</strong>
图的邻接表表示法</caption>
  <tbody>

    <tr>

      <td><img src="./figs/adj_list.gif" height="122" width="108"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>



<p>

</p>

<h2>边列表表示法<br>
</h2>



<p>图的边列表表示就是一个边的序列，其中每条边使用一个顶点ID对来表示的。该表示法仅需要O(E)大小的内存。边插入复杂度是O(1)，但是访问一个指定边的复杂度是O(E)（效率低下）。<a href="graph_theory_review.html#fig:edge-list">图五</a>表示了&nbsp;<a href="graph_theory_review.html#fig:directed-graph">图一</a>的边列表表示。
<a href="edge_list.html"><tt>edge_list</tt></a>适配器类内被用来实现边列表表示。<br>
</p>


<div align="center"><a name="fig:edge-list"></a><a name="1724"></a>
<table>


  <caption align="bottom"><strong>图 5:</strong>
图的边列表表示法</caption>
  <tbody>

    <tr>

      <td><img src="./figs/edge_list.gif" height="22" width="322"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>




<p>

</p>

<h1>图相关算法<br>
</h1>



<p>

</p>

<h2>图搜索算法<br>
</h2>



<p>
树边是通过图搜索算法遍历一个图时所建立的搜索树的边。如果遍历边（调用<a href="visitor_concepts.html"> visitor </a>的explore
()方法）（u，v）时，点v首先被遍历到，那么边（u，v）就是一条树边。在搜索树中，后向边连接顶点到他们的祖先。所以边（u，v）中，点v一定是点
u的祖先。闭包被认为是反向边。前向边是非树边，搜索树中（u，v）连接点u到它的子孙节点v。交叉边是不属于前面三种定义的边。<br>
<i></i></p>
<br>
<h2><a name="sec:bfs-algorithm"></a> 广度优先搜索</h2>



<p>广度优先搜索（BFS）是指从某点开始遍历整张图，遍历顺序是首先遍历该点的邻居结点会，然后是它邻居节点的邻居节点优先遍历到，直至遍历完整张
图。可以把深度优先遍历想像成石子落入水中时激起的涟漪，在相同波浪的顶点和源点的距离是相同的。发现点是该算法浏览时首先遇到的点，结束点是遍历完它所
有邻居的最后一个点。下面有一个例子将帮助你理解。<a href="graph_theory_review.html#fig:bfs-example">图六</a>中展示了一幅图，并且在图下面列出了BFS（深度优先算法）的算法中顶点的发现和结束顺序。</p>
<p></p>


<div align="center"><a name="fig:bfs-example"></a><a name="1826"></a>
<table>


  <caption align="bottom"><strong>图 6:</strong> 图遍历的广度优先搜索</caption>
  <tbody>

    <tr>

      <td><img src="./figs/bfs_example.gif" height="143" width="242"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>



<p>
</p>

<pre>  order of discovery: s r w v t x u y <br>  order of finish: s r w v t x u y<br></pre>
我们从s点开始，首先访问的是r和w（s的两个邻居）。它的两个邻居都被访问过后，我们将访问r的邻居（顶点v），然后访问w的邻居（r和w的发现顺序无所谓）t和x。最后，我们访问t和x的邻居u和y。
<p>为了能够知道我们在图中的位置以及知道将要访问的下一个点，BFS算法需要对顶点进行染色（color）（请参考 <a href="using_property_maps.html">Property Maps</a>一节来了解更多关于图属性的细节）。颜色值既可以放在图结构内，也可以作为算法的参数传进去。<br>
</p>
<br>
<h2><a name="sec:dfs-algorithm"></a> 深度优先搜索
</h2>
<br>
深度优先搜索（DFS）访问图中所有顶点的方法是，我们依据边来进行遍历，该算法会始终选择图中较深一层的边来遍历。也就是说，DFS会首先访问它未被访
问的邻接顶点，然后邻接顶点访问该邻接顶点的邻接顶点，直到一点没有邻接顶点时，再回溯到前面顶点继续沿着未被访问的边来遍历顶点。DFS算法从一点遍历
完所有能够到达的顶点后，它将选择仍未被发现的顶点来进行搜索。搜索的过程建立了一组深度优先树（depth-first
trees），这些树合起来就成了深度优先森林（depth-first
forest）。DFS把图中的边分为三类：树边，反向边和正向边（或称交叉边）。根据一些典型的深度优先森林，边还有一些其它的分类方法。<br>
<p>DFS一个比较有意思的特性是按点的发现和结束顺序插入到括号中，方法是：把发现一点放到左括号，把结束一点放到右括号，最后形成了一个嵌套的括号集合。<a href="graph_theory_review.html#fig:dfs-example">图七</a>展示了DFS对于一个无向图的应用，该图边上已经标好了遍历的顺序。下面我们列出了发现和结束的顺序，以及嵌套的括号集合。DFS是其他一些算法的核心，比如托普排序和连通分量算法。DFS算法还能检测是图中是否存在环（参考文件依赖例子中的<a href="file_dependency_example.html#sec:cycles">Cylic Dependencies</a>（循环依赖）一节）。<br>
</p>


<div align="center"><a name="fig:dfs-example"></a><a name="1841"></a>
<table>


  <caption align="bottom"><strong>图 7:</strong>
无向图的深度优先搜索</caption>
  <tbody>

    <tr>

      <td><img src="./figs/dfs.gif" height="204" width="141"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>



<p>
</p>

<pre>  order of discovery: a b e d c f g h i<br>  order of finish: d f c e b a<br>  parenthesis: (a (b (e (d d) (c (f f) c) e) b) a) (g (h (i i) h) g)<br></pre>



<p>

</p>

<h2><a name="sec:minimum-spanning-tree">最小生成树问题</a></h2>
最小生成树（minimum-spanning-tree）定义如下：从E中找到一个无环子集T，E是连接这图中所有顶点，要求T权值是最小的，权值计算法法如下：<br>
<div align="left">
<div align="left"><i>w(T)</i> = sum of <i>w(u,v)</i> over all <i>(u,v)</i> in 
<i>T</i>, where <i>w(u,v)</i> is the weight on the edge <i>(u,v)</i> </div>

</div>


<br clear="all">


这样的T称为最小生成树。&nbsp;<!--
<P>
Kruskal's algorithm&nbsp;[<A
 HREF="bibliography.html#kruskal56">18</A>]
for solving the minimum spanning tree problem. This is a greedy
algorithm to calculate the minimum spanning tree for an undirected
graph with weighted edges. 

<P>
This is Prim's algorithm&nbsp;[<A
 HREF="bibliography.html#prim57:_short">25</A>] for solving the
 minimum spanning tree problem for an undirected graph with weighted
 edges. The implementation is simply a call to <a
 href="./dijkstra_shortest_paths.html"><TT>dijkstra_shortest_paths()</TT></a>
 with the appropriate choice of comparison and combine functors.
-->

<p>

</p>

<h2><a name="sec:shortest-paths-algorithms">最短路径算法</a></h2>
图论中的一个经典问题是找出两点之间的最短路径。在图G中，一条路径是一个顶点序列&lt;v0,v1,....,Vk&gt;，使得序列中的每个顶点都
和下一个顶点相连(边（vi，vi+1）i=0,1,....k属于边集E)。在最短路径问题中，每条边都会给出一个值作为权值。因此，我们可以说一条路
径的权值是：<br>
<div align="left">
<i>w(p) = sum from i=1..k of w(v<sub>i-1</sub>,v<sub>i</sub>)</i>
</div>


<br clear="all">

<p></p>
顶点u到v的最短路径的权值是：<br>


<p></p>


<div align="left">
<i>delta (u,v) = min { w(p) : u --&gt; v }</i> if there is a path from
<i>u</i> to <i>v</i> <br>


<i>delta (u,v) = infinity</i> otherwise.
</div>


<br clear="all">

<p></p>
最短路径可以是权值等于最短路径权值的任何一条路径。<br>
<br>
<br>
还有一些最短路径的衍生问题。上面我们定义了single-pair问题，但是还有一个single-source问题，该问题等效于单目标single
-destination问题和all-pairs问题。没有解决single-pair问题比解决single-source问题还快的算法。<br>
<br>
<br>
在图G=(V,E)中，以某点为根的最短路径树是该图的一个有向子图G'=(V',E')，其中V'是V的子集，E'是E的子集，而且V'还是该点能够到
到达顶点的集合。G'是一颗以顶点为根的有根树，因而，从V'中一点v到G'中一点u的唯一简单路径就是从v到u的最短路径。single-source
算法的结果就是一颗最短路径树。<br>
<h2><a name="sec:network-flow-algorithms">网络流算法</a></h2>



<p>
<a name="sec:network-flow-algorithms">一个网络流是一个以顶点s为源点，以顶点t为接受点的有向图G=(V,E)。每条边e均具有一个非负容量（capacity ）c(e)而且每个顶点对还有一个流f(e)。流一定要满足下面三个条件：

</a></p>

<p>
<a name="sec:network-flow-algorithms"><i>容量约束(Capacity constraint)：对于V*V中所有顶点对(u, v)有：f(u,v) &lt;= c(u,v)<br>
斜对称性(Skew symmetry):对于V*V中所有顶点对(u, v)有：f(u,v) = - f(v,u)<br>
流守恒(Flow conservation)：f(u,v) = 0<br>
</i>

</a></p>

<p>
<a name="sec:network-flow-algorithms">网络流是指流向接收点t的流（等效于流出源点s的流）。</a></p>

<p>

<a name="sec:network-flow-algorithms"><i>|f| = sum<sub>u in V</sub> f(u,t) = sum<sub>v in V</sub> f(s,v)</i>

</a></p>

<p>
<a name="sec:network-flow-algorithms">一条边的剩余容量为：r(u,v) = c(u,v) - f(u,v)。如果r(u,v)&gt;0则该边是有余量的，包含该边的图为有余量图。如果r(u,v)=0，则该边为饱和的。

</a></p>

<p>
<a name="sec:network-flow-algorithms">最大流问题是指确定|f|的最大值和图中每个顶点对相应的流是多少。

</a></p>

<p>
<a name="sec:network-flow-algorithms"> </a><a href="graph_theory_review.html#fig:max-flow">图八</a><a name="sec:network-flow-algorithms">表示一个流网络，顶点A为源点，顶点H为终点。</a>

</p>

<p></p>


<div align="center"><a name="fig:max-flow"></a><a name="1509"></a>
<table>


  <caption align="bottom"><strong>Figure 8:</strong>&nbsp;一个最大流网络<br>
边已经被标上流和容量值</caption>
  <tbody>

    <tr>

      <td><img src="./figs/max-flow.gif" height="240" width="578"></td>

    </tr>


  
  </tbody>
</table>


</div>

<p></p>
<p>解决最大流问题算法已经有很长历史了，首先提出解决该问题的算法是&nbsp; <a href="bibliography.html#ford56:_maxim">Ford 和 Fulkerson</a>.对于数据最通用的算法是<a href="bibliography.html#goldberg85:_new_max_flow_algor">Goldberg</a>提出的push-relabel算法，该算法基于<a href="bibliography.html#karzanov74:_deter">Karzanov</a>提出的前向(preflow)概念。</p>




<hr>
<table>


  <tbody>

    <tr valign="top">


      <td nowrap="nowrap">Copyright © 2000-2001</td>

      <td>
      <a href="../../../people/jeremy_siek.htm">Jeremy Siek</a>, Indiana University (<a href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)
      </td>

    </tr>

  
  </tbody>
</table>



</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Adjacency Iterator Adaptor Documentation</title></head>


<body bgcolor="#ffffff" text="#000000">

<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">

<h1>Adjacency Iterator Adaptor 邻接迭代器适配器</h1>定义于头文件
<a href="../../../boost/graph/adjacency_iterator.hpp">boost/graph/adjacency_iterator.hpp</a>

<p>邻接迭代器适配器将一个
<tt>out_edge_iterator</tt> 转换为邻接迭代器。即，它接受一个对边进行遍历的迭代器，并创建一个对这些边的<b><i>目标</i></b>顶点进行遍历的迭代器。有了这个适配器，就可以非常简单地接受一个 <a href="IncidenceGraph.html">关联图Incidence Graph</a> 的图类型并加入 <a href="AdjacencyGraph.html">邻接图Adjacency
Graph</a> 所要求的能力。


</p><h2>Synopsis 概要</h2>

<pre>namespace boost {<br>  template &lt;class Graph, class VertexDescriptor, class OutEdgeIter&gt;<br>  class adjacency_iterator_generator {<br>  public:<br>    typedef <a href="../../iterator/doc/iterator_adaptor.html">iterator_adaptor</a>&lt;...&gt; type;<br>  };<br>}<br></pre>

<hr>

<h3>Example 示例</h3>

<p>以下是一个如何使用
<tt>adjacency_iterator_generator</tt> 类的例子。

</p><pre>#include &lt;boost/graph/adjacency_iterator.hpp&gt;<br><br>class my_graph {<br>  // ...<br>  typedef ... out_edge_iterator;<br>  typedef ... vertex_descriptor;<br>  typedef boost::adjacency_iterator_generator&lt;my_graph, vertex_descriptor, out_edge_iterator&gt;::type adjacency_iterator;<br>  // ...<br>};<br><br></pre>

<h3>Template Parameters 模板参数</h3>

<table border="1">
<tbody><tr>
<th>Parameter</th><th>Description</th>
</tr>

<tr>
<td><tt>Graph</tt></td>
<td>图类型，必须符合 <a href="./IncidenceGraph.html">关联图Incidence Graph</a>。</td>
</tr>

<tr>
<td><tt>VertexDescriptor</tt></td>
<td>必须是与
<tt>graph_traits&lt;Graph&gt;::vertex_descriptor</tt> 相同的类型。将此作为一个模板参数的原因是，<tt>adjacency_iterator_generator</tt> 的主要用途是在图类定义的<b><i>内部</i></b>，而在这样的上下文中我们不能对尚未完整定义的图类使用
<tt>graph_traits</tt>。<br>
<b>缺省值：</b><tt>graph_traits&lt;Graph&gt;::vertex_descriptor</tt></td>
</tr>

<tr>
<td><tt>OutEdgeIter</tt></td>
<td>必须是与
<tt>graph_traits&lt;Graph&gt;::out_edge_iterator</tt> 相同的类型。<br>
<b>缺省值：</b><tt>graph_traits&lt;Graph&gt;::out_edge_iterator
</tt></td>
</tr>

</tbody></table>

<h3>Model of 以...为模型</h3>邻接迭代器适配器(类型
<tt>adjacency_iterator_generator&lt;...&gt;::type</tt>)是 <a href="../../utility/MultiPassInputIterator.html">多遍输入迭代器</a>。


<h3>Members 成员</h3>邻接迭代器类型实现了 <a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">随机访问迭代器</a>
概念所要求的成员函数和操作符，除了其引用类型与 <tt>value_type</tt>
相同，因此 <tt>operator*()</tt> 是以值方式返回的。此外它还有以下构造函数：

<pre>adjacency_iterator_generator::type(const OutEdgeIter&amp; it, const Graph* g)<br></pre>

<hr>
<p>Revised <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %b %Y" startspan -->19 Aug 2001<!--webbot bot="Timestamp" endspan i-checksum="14767" --></p>
<p>© Copyright Jeremy Siek 2000. Permission to copy, use,
modify, sell and distribute this document is granted provided this copyright
notice appears in all copies. This document is provided "as is"
without express or implied warranty, and with no claim as to its suitability for
any purpose.</p>

</body></html>
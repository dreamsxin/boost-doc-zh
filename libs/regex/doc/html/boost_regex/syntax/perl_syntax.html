<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Perl Regular Expression Syntax</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_2006-12-17_0120">
<link rel="start" href="../../index.html" title="Boost.Regex">
<link rel="up" href="../syntax.html" title="Regular Expression Syntax">
<link rel="prev" href="../syntax.html" title="Regular Expression Syntax">
<link rel="next" href="basic_extended.html" title="POSIX Extended Regular Expression Syntax">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../syntax.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../syntax.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="basic_extended.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_regex.syntax.perl_syntax"></a><a href="perl_syntax.html" title="Perl Regular Expression Syntax"> Perl Regular Expression
      Syntax</a>
</h3></div></div></div>
<a name="boost_regex.syntax.perl_syntax.synopsis"></a><h4>
<a name="id507610"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.synopsis">Synopsis</a>
      </h4>
<p>
        The Perl regular expression syntax is based on that used by the programming
        language Perl . Perl regular expressions are the default behavior in Boost.Regex
        or you can pass the flag <code class="computeroutput"><span class="identifier">perl</span></code>
        to the <a href="../ref/basic_regex.html" title="basic_regex"><code class="computeroutput"><span class="identifier">basic_regex</span></code></a>
        constructor, for example:
        <br />
        Perl正则表达式语法基于编程语言Perl的使用。
        Perl正则表达式是Boost.Regex的默认行为，或者你可以将<code class="computeroutput"><span class="identifier">perl</span></code>标记传入<a href="../ref/basic_regex.html" title="basic_regex"><code class="computeroutput"><span class="identifier">basic_regex</span></code></a>的构造，例如：
      </p>
<pre class="programlisting"><span class="comment">// e1 is a case sensitive Perl regular expression: 
</span><span class="comment">// since Perl is the default option there's no need to explicitly specify the syntax used here:
</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">e1</span><span class="special">(</span><span class="identifier">my_expression</span><span class="special">);</span>
<span class="comment">// e2 a case insensitive Perl regular expression:
</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">e2</span><span class="special">(</span><span class="identifier">my_expression</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span><span class="special">::</span><span class="identifier">perl</span><span class="special">|</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span><span class="special">::</span><span class="identifier">icase</span><span class="special">);</span>
</pre>
<a name="boost_regex.syntax.perl_syntax.perl_regular_expression_syntax"></a><h4>
<a name="id507832"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.perl_regular_expression_syntax">Perl
        Regular Expression Syntax</a>
      </h4>
<p>
        In Perl regular expressions, all characters match themselves except for the
        following special characters:
        <br />
        在Perl正则表达式中，除了下面的特殊字符外，所有的字符都匹配自己：
      </p>
<pre class="programlisting">.[{()\*+?|^$</pre>
<a name="boost_regex.syntax.perl_syntax.wildcard"></a><h5>
<a name="id507869"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.wildcard">Wildcard 通配符</a>
      </h5>
<p>
        The single character '.' when used outside of a character set will match
        any single character except:
        <br />
        单字符'.'在字符集(character set)外使用时可以匹配任意单字符除了：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          The NULL character when the <a href="../ref/match_flag_type.html" title="match_flag_type">flag
          <code class="computeroutput"><span class="identifier">match_not_dot_null</span></code></a>
          is passed to the matching algorithms.
          <br />
          NULL字符当<a href="../ref/match_flag_type.html" title="match_flag_type">标记(flag)<code class="computeroutput"><span class="identifier">match_not_dot_null</span></code></a>被传入匹配算法中。
        </li>
<li>
          The newline character when the <a href="../ref/match_flag_type.html" title="match_flag_type">flag
          <code class="computeroutput"><span class="identifier">match_not_dot_newline</span></code></a>
          is passed to the matching algorithms.
          <br />
          换行字符当<a href="../ref/match_flag_type.html" title="match_flag_type">标记(flag)<code class="computeroutput"><span class="identifier">>match_not_dot_newline</span></code></a>被传入匹配算法中。
        </li>
</ul></div>
<a name="boost_regex.syntax.perl_syntax.anchors"></a><h5>
<a name="id507950"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.anchors">Anchors 锚点</a>
      </h5>
<p>
        A '^' character shall match the start of a line.
        <br />
        '^'字符会匹配行的起始。
      </p>
<p>
        A '$' character shall match the end of a line.
        <br />
        '$'字符会匹配行的终止。
      </p>
<a name="boost_regex.syntax.perl_syntax.marked_sub_expressions"></a><h5>
<a name="id507984"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.marked_sub_expressions">Marked
        sub-expressions 标记子表达式</a>
      </h5>
<p>
        A section beginning <code class="computeroutput"><span class="special">(</span></code> and ending
        <code class="computeroutput"><span class="special">)</span></code> acts as a marked sub-expression.
        Whatever matched the sub-expression is split out in a separate field by the
        matching algorithms. Marked sub-expressions can also repeated, or referred
        to by a back-reference.
        <br />
        开始的<code class="computeroutput"><span class="special">(</span></code>和终止的<code class="computeroutput"><span class="special">)</span></code>部分是标记子表达式。
        匹配算法会将子表达式匹配的部分分离成独立的部分。
        标记子表达式也可以被重复，或后向引用(back-reference)。
      </p>
<a name="boost_regex.syntax.perl_syntax.non_marking_grouping"></a><h5>
<a name="id508040"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.non_marking_grouping">Non-marking
        grouping 非标记组</a>
      </h5>
<p>
        A marked sub-expression is useful to lexically group part of a regular expression,
        but has the side-effect of spitting out an extra field in the result. As
        an alternative you can lexically group part of a regular expression, without
        generating a marked sub-expression by using <code class="computeroutput"><span class="special">(?:</span></code>
        and <code class="computeroutput"><span class="special">)</span></code> , for example <code class="computeroutput"><span class="special">(?:</span><span class="identifier">ab</span><span class="special">)+</span></code>
        will repeat <code class="computeroutput"><span class="identifier">ab</span></code> without splitting
        out any separate sub-expressions.
        <br />
        标记子表达式对于正则表达式中的成组文字部分是非常有用的，但将结果分组是有副作用的。
        作为选择，可以通过<code class="computeroutput"><span class="special">(?:</span></code>和<code class="computeroutput"><span class="special">)</span></code>产生文字分组，但不产生标记子表达式，
        例如<code class="computeroutput"><span class="special">(?:</span><span class="identifier">ab</span><span class="special">)+</span></code>会重复<code class="computeroutput"><span class="identifier">ab</span></code>但并不分隔出单独的子表达式。
      </p>
<a name="boost_regex.syntax.perl_syntax.repeats"></a><h5>
<a name="id508128"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.repeats">Repeats 重复</a>
      </h5>
<p>
        Any atom (a single character, a marked sub-expression, or a character class)
        can be repeated with the <code class="computeroutput"><span class="special">*</span></code>,
        <code class="computeroutput"><span class="special">+</span></code>, <code class="computeroutput"><span class="special">?</span></code>,
        and <code class="computeroutput"><span class="special">{}</span></code> operators.
        <br />
        任意原子(单个字符，一个标记子表达式或一个字符组)可以通过<code class="computeroutput"><span class="special">*</span></code>、<code class="computeroutput"><span class="special">+</span></code><code class="computeroutput"><span class="special">?</span></code>和<code class="computeroutput"><span class="special">{}</span></code>操作符重复。
      </p>
<p>
        The <code class="computeroutput"><span class="special">*</span></code> operator will match the
        preceding atom zero or more times, for example the expression <code class="computeroutput"><span class="identifier">a</span><span class="special">*</span><span class="identifier">b</span></code>
        will match any of the following:
        <br />
        <code class="computeroutput"><span class="special">*</span></code>操作符会匹配前面的原子零次或多次，
        例如表达式<code class="computeroutput"><span class="identifier">a</span><span class="special">*</span><span class="identifier">b</span></code>可以匹配下面的：
      </p>
<pre class="programlisting"><span class="identifier">b</span>
<span class="identifier">ab</span>
<span class="identifier">aaaaaaaab</span>
</pre>
<p>
        The <code class="computeroutput"><span class="special">+</span></code> operator will match the
        preceding atom one or more times, for example the expression <code class="computeroutput"><span class="identifier">a</span><span class="special">+</span><span class="identifier">b</span></code>
        will match any of the following:
        <br />
        <code class="computeroutput"><span class="special">+</span></code>操作符会匹配前面的原子一次或多次，
        例如表达式<code class="computeroutput"><span class="identifier">a</span><span class="special">+</span><span class="identifier">b</span></code>可以匹配下面的：
      </p>
<pre class="programlisting"><span class="identifier">ab</span>
<span class="identifier">aaaaaaaab</span>
</pre>
<p>
        But will not match:
        <br />
        但不会匹配：
      </p>
<pre class="programlisting"><span class="identifier">b</span>
</pre>
<p>
        The <code class="computeroutput"><span class="special">?</span></code> operator will match the
        preceding atom zero or one times, for example the expression ca?b will match
        any of the following:
        <br />
        <code class="computeroutput"><span class="special">?</span></code>操作符会匹配前面的原子零次或一次，
        例如表达式ca?b会匹配下面的：
      </p>
<pre class="programlisting"><span class="identifier">cb</span>
<span class="identifier">cab</span>
</pre>
<p>
        But will not match:
        <br />
        但不会匹配：
      </p>
<pre class="programlisting"><span class="identifier">caab</span>
</pre>
<p>
        An atom can also be repeated with a bounded repeat:
        <br />
        原子同样可以被重复有界次数：
      </p>
<p>
        <code class="computeroutput"><span class="identifier">a</span><span class="special">{</span><span class="identifier">n</span><span class="special">}</span></code> Matches
        'a' repeated exactly n times.
        <br />
        <code class="computeroutput"><span class="identifier">a</span><span class="special">{</span><span class="identifier">n</span><span class="special">}</span></code>匹配'a'重复n次。
      </p>
<p>
        <code class="computeroutput"><span class="identifier">a</span><span class="special">{</span><span class="identifier">n</span><span class="special">,}</span></code> Matches
        'a' repeated n or more times.
        <br />
        <code class="computeroutput"><span class="identifier">a</span><span class="special">{</span><span class="identifier">n</span><span class="special">,}</span></code>匹配'a'重复n次或更多次。
      </p>
<p>
        <code class="computeroutput"><span class="identifier">a</span><span class="special">{</span><span class="identifier">n</span><span class="special">,</span> <span class="identifier">m</span><span class="special">}</span></code> Matches 'a' repeated between n and m times
        inclusive.
      <br />
      <code class="computeroutput"><span class="identifier">a</span><span class="special">{</span><span class="identifier">n</span><span class="special">,</span> <span class="identifier">m</span><span class="special">}</span></code>匹配'a'重复n次到m次之间。
      </p>
<p>
        For example:
      </p>
<pre class="programlisting">^a{2,3}$</pre>
<p>
        Will match either of:
        <br />
        会匹配如下：
      </p>
<pre class="programlisting"><span class="identifier">aa</span>
<span class="identifier">aaa</span>
</pre>
<p>
        But neither of:
        <br />
        但不会匹配：
      </p>
<pre class="programlisting"><span class="identifier">a</span>
<span class="identifier">aaaa</span>
</pre>
<p>
        It is an error to use a repeat operator, if the preceding construct can not
        be repeated, for example:
        <br />
        如果前面的结构不能被重复，那么使用重复操作符是一个错误，例如：
      </p>
<pre class="programlisting"><span class="identifier">a</span><span class="special">(*)</span>
</pre>
<p>
        Will raise an error, as there is nothing for the <code class="computeroutput"><span class="special">*</span></code>
        operator to be applied to.
        <br />
        但报告一个错误，因为<code class="computeroutput"><span class="special">*</span></code>操作符没有可以应用的对象。
      </p>
<a name="boost_regex.syntax.perl_syntax.non_greedy_repeats"></a><h5>
<a name="id508601"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.non_greedy_repeats">Non greedy
        repeats 非贪婪重复</a>
      </h5>
<p>
        The normal repeat operators are "greedy", that is to say they will
        consume as much input as possible. There are non-greedy versions available
        that will consume as little input as possible while still producing a match.
        <br />
        通常的重复是"贪婪的"，也说明说它们会消耗尽可能多的输入。
        同样存在非贪婪版本，生成匹配时会消耗尽可能少的输入。
      </p>
<p>
        <code class="computeroutput"><span class="special">*?</span></code> Matches the previous atom
        zero or more times, while consuming as little input as possible.
        <br />
        <code class="computeroutput"><span class="special">*?</span></code>匹配前面的原子零次或多次，但尽可能少地消耗输入。
      </p>
<p>
        <code class="computeroutput"><span class="special">+?</span></code> Matches the previous atom
        one or more times, while consuming as little input as possible.
        <br />
        <code class="computeroutput"><span class="special">+?</span></code>匹配前面的原子一次或多次，但尽可能少地消耗输入。
      </p>
<p>
        <code class="computeroutput"><span class="special">??</span></code> Matches the previous atom
        zero or one times, while consuming as little input as possible.
        <br />
        <code class="computeroutput"><span class="special">??</span></code>匹配前面的原子零次或一次，但尽可能少地消耗输入。
      </p>
<p>
        <code class="computeroutput"><span class="special">{</span><span class="identifier">n</span><span class="special">,}?</span></code> Matches the previous atom n or more times,
        while consuming as little input as possible.
        <br />
        <code class="computeroutput"><span class="special">{</span><span class="identifier">n</span><span class="special">,}?</span></code>匹配前面的原子n次或更多次，但尽可能少地消耗输入。
      </p>
<p>
        <code class="computeroutput"><span class="special">{</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">}?</span></code>
        Matches the previous atom between n and m times, while consuming as little
        input as possible.
        <br />
        <code class="computeroutput"><span class="special">{</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">}?</span></code>匹配前面的原子n次到m次，但尽可能少地消耗输入。
      </p>
<a name="boost_regex.syntax.perl_syntax.back_references"></a><h5>
<a name="id508746"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.back_references">Back references 后向引用</a>
      </h5>
<p>
        An escape character followed by a digit <span class="emphasis"><em>n</em></span>, where <span class="emphasis"><em>n</em></span>
        is in the range 1-9, matches the same string that was matched by sub-expression
        <span class="emphasis"><em>n</em></span>. For example the expression:
        <br />
        一个转义字符跟着一个数字<span class="emphasis"><em>n</em></span>，<span class="emphasis"><em>n</em></span>的范围是1-9，匹配被子表达式<span class="emphasis"><em>n</em></span>匹配的相同字符串。
        例如表达式：
      </p>
<pre class="programlisting">^(a*).*\1$</pre>
<p>
        Will match the string:
        <br />
        匹配字符串：
      </p>
<pre class="programlisting"><span class="identifier">aaabbaaa</span>
</pre>
<p>
        But not the string:
        <br />
        但不匹配：
      </p>
<pre class="programlisting"><span class="identifier">aaabba</span>
</pre>
<a name="boost_regex.syntax.perl_syntax.alternation"></a><h5>
<a name="id508829"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.alternation">Alternation 选择</a>
      </h5>
<p>
        The <code class="computeroutput"><span class="special">|</span></code> operator will match either
        of its arguments, so for example: <code class="computeroutput"><span class="identifier">abc</span><span class="special">|</span><span class="identifier">def</span></code> will
        match either "abc" or "def".
        <br />
        <code class="computeroutput"><span class="special">|</span></code>操作符匹配它的参数之一，
        例如：<code class="computeroutput"><span class="identifier">abc</span><span class="special">|</span><span class="identifier">def</span></code>会匹配"abc"或"def"。
      </p>
<p>
        Parenthesis can be used to group alternations, for example: <code class="computeroutput"><span class="identifier">ab</span><span class="special">(</span><span class="identifier">d</span><span class="special">|</span><span class="identifier">ef</span><span class="special">)</span></code>
        will match either of "abd" or "abef".
        <br />
        括号可以用来对选择进行分组，例如<code class="computeroutput"><span class="identifier">ab</span><span class="special">(</span><span class="identifier">d</span><span class="special">|</span><span class="identifier">ef</span><span class="special">)</span></code>会匹配"abd"或"abef"。
      </p>
<p>
        Empty alternatives are not allowed (these are almost always a mistake), but
        if you really want an empty alternative use <code class="computeroutput"><span class="special">(?:)</span></code>
        as a placeholder, for example:
        <br />
        空的选择是不允许的(这通常都是错误)，但如果你真的需要一个空的选择，可以使用<code class="computeroutput"><span class="special">(?:)</span></code>作为占位符，例如：
      </p>
<p>
        <code class="computeroutput"><span class="special">|</span><span class="identifier">abc</span></code>
        is not a valid expression, but
        <br />
        <code class="computeroutput"><span class="special">|</span><span class="identifier">abc</span></code>不是有效的表达式，但
      </p>
<p>
        <code class="computeroutput"><span class="special">(?:)|</span><span class="identifier">abc</span></code>
        is and is equivalent, also the expression:
        <br />
        <code class="computeroutput"><span class="special">(?:)|</span><span class="identifier">abc</span></code>是有效的表达式，并且等价于表达式：
      </p>
<p>
        <code class="computeroutput"><span class="special">(?:</span><span class="identifier">abc</span><span class="special">)??</span></code> has exactly the same effect.
        <br />
        <code class="computeroutput"><span class="special">(?:</span><span class="identifier">abc</span><span class="special">)??</span></code>有完全相同的作用。
      </p>
<a name="boost_regex.syntax.perl_syntax.character_sets"></a><h5>
<a name="id509018"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_sets">Character sets 字符集</a>
      </h5>
<p>
        A character set is a bracket-expression starting with <code class="computeroutput"><span class="special">[</span></code>
        and ending with <code class="computeroutput"><span class="special">]</span></code>, it defines
        a set of characters, and matches any single character that is a member of
        that set.
        <br />
        字符集是一个以<code class="computeroutput"><span class="special">[</span></code>开始，以<code class="computeroutput"><span class="special">]</span></code>结束的方括号表达式，
        字定义了一个字符的集合，匹配集合中的任意单个字符。
      </p>
<p>
        A bracket expression may contain any combination of the following:
        <br />
        方括号表达式可以包含下面的组合：
      </p>
<a name="boost_regex.syntax.perl_syntax.single_characters"></a><h6>
<a name="id509077"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.single_characters">Single characters 单个字符</a>
      </h6>
<p>
        For example <code class="computeroutput"><span class="special">[</span><span class="identifier">abc</span><span class="special">]</span></code>, will match any of the characters 'a', 'b',
        or 'c'.
        <br />
        例如<code class="computeroutput"><span class="special">[</span><span class="identifier">abc</span><span class="special">]</span></code>可以匹配'a'、'b'或'c'。
      </p>
<a name="boost_regex.syntax.perl_syntax.character_ranges"></a><h6>
<a name="id509127"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_ranges">Character
        ranges 字符范围</a>
      </h6>
<p>
        For example <code class="computeroutput"><span class="special">[</span><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span><span class="special">]</span></code>
        will match any single character in the range 'a' to 'c'. By default, for
        Perl regular expressions, a character x is within the range y to z, if the
        code point of the character lies within the codepoints of the endpoints of
        the range. Alternatively, if you set the <a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions"><code class="computeroutput"><span class="identifier">collate</span></code> flag</a> when constructing the
        regular expression, then ranges are locale sensitive.
        <br />
        例如<code class="computeroutput"><span class="special">[</span><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span><span class="special">]</span></code>可以匹配'a'到'c'范围内的任意单个字符。
        对于缺省的Perl正则表达式，字符x在y到z的范围中间(这个地方是不是搞错了？译者注)，如果字符的码点(code point)在范围的码点之间。
        另外，如果在构造正则表达式时设置了<a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions"><code class="computeroutput"><span class="identifier">collate</span></code>标记</a>，那范围就是地区(locale)相关的。
      </p>
<a name="boost_regex.syntax.perl_syntax.negation"></a><h6>
<a name="id509207"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.negation">Negation 否定</a>
      </h6>
<p>
        If the bracket-expression begins with the ^ character, then it matches the
        complement of the characters it contains, for example <code class="computeroutput"><span class="special">[^</span><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span><span class="special">]</span></code> matches any character that is not in the
        range <code class="computeroutput"><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span></code>.
        <br />
        如果方括号表达式以^字符开始，那么它匹配包含字符的补集，
        例如<code class="computeroutput"><span class="special">[^</span><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span><span class="special">]</span></code>匹配不在<code class="computeroutput"><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span></code>范围内的任意字符。
      </p>
<a name="boost_regex.syntax.perl_syntax.character_classes"></a><h6>
<a name="id509290"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_classes">Character
        classes 字符类</a>
      </h6>
<p>
        An expression of the form <code class="computeroutput"><span class="special">[[:</span><span class="identifier">name</span><span class="special">:]]</span></code>
        matches the named character class "name", for example <code class="computeroutput"><span class="special">[[:</span><span class="identifier">lower</span><span class="special">:]]</span></code> matches any lower case character. See
        <a href="character_classes.html" title="Character Class Names">character class names</a>.
        <br />
        <code class="computeroutput"><span class="special">[[:</span><span class="identifier">name</span><span class="special">:]]</span></code>形式的表达式匹配命名字符类"name"，
        例如<code class="computeroutput"><span class="special">[[:</span><span class="identifier">lower</span><span class="special">:]]</span></code>任意小写字符。
        参见<a href="character_classes.html" title="Character Class Names">character class names</a>。
      </p>
<a name="boost_regex.syntax.perl_syntax.collating_elements"></a><h6>
<a name="id509373"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.collating_elements">Collating
        Elements 对照元素</a>
      </h6>
<p>
        An expression of the form <code class="computeroutput"><span class="special">[[.</span><span class="identifier">col</span><span class="special">.]</span></code> matches
        the collating element <span class="emphasis"><em>col</em></span>. A collating element is any
        single character, or any sequence of characters that collates as a single
        unit. Collating elements may also be used as the end point of a range, for
        example: <code class="computeroutput"><span class="special">[[.</span><span class="identifier">ae</span><span class="special">.]-</span><span class="identifier">c</span><span class="special">]</span></code>
        matches the character sequence "ae", plus any single character
        in the range "ae"-c, assuming that "ae" is treated as
        a single collating element in the current locale.
        <br />
        <code class="computeroutput"><span class="special">[[.</span><span class="identifier">col</span><span class="special">.]</span></code>形式的表达式匹配对照元素<span class="emphasis"><em>col</em></span>。
        对照元素是任意的单个字符，或对应于某个单个单元的字符序列。
        对照还可以用作范围的端点，例如<code class="computeroutput"><span class="special">[[.</span><span class="identifier">ae</span><span class="special">.]-</span><span class="identifier">c</span><span class="special">]</span></code>匹配1字符序列"ae"，和任意的单个字符在范围"ae"到c之间，其中"ae"被当前区域(locale)处理为单个对照元素。
      </p>
<p>
        As an extension, a collating element may also be specified via it's <a href="collating_names.html" title="Collating Names">symbolic name</a>, for example:
        <br />
        作为扩展，对照元素可以通过其<a href="collating_names.html" title="Collating Names">符号名字(symbolic name)</a>指定，例如：
      </p>
<pre class="programlisting"><span class="special">[[.</span><span class="identifier">NUL</span><span class="special">.]]</span>
</pre>
<p>
        matches a <code class="computeroutput"><span class="special">\</span><span class="number">0</span></code>
        character.
        <br />
        匹配<code class="computeroutput"><span class="special">\</span><span class="number">0</span></code>字符。
      </p>
<a name="boost_regex.syntax.perl_syntax.equivalence_classes"></a><h6>
<a name="id509521"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.equivalence_classes">Equivalence
        classes 等价类</a>
      </h6>
<p>
        An expression of the form <code class="computeroutput"><span class="special">[[=</span><span class="identifier">col</span><span class="special">=]]</span></code>,
        matches any character or collating element whose primary sort key is the
        same as that for collating element <span class="emphasis"><em>col</em></span>, as with collating
        elements the name <span class="emphasis"><em>col</em></span> may be a <a href="collating_names.html" title="Collating Names">symbolic
        name</a>. A primary sort key is one that ignores case, accentation, or
        locale-specific tailorings; so for example <code class="computeroutput"><span class="special">[[=</span><span class="identifier">a</span><span class="special">=]]</span></code> matches
        any of the characters: a, À, Á, Â, Ã, Ä, Å, A, à, á, â, ã, ä and å. Unfortunately implementation
        of this is reliant on the platform's collation and localisation support;
        this feature can not be relied upon to work portably across all platforms,
        or even all locales on one platform.
        <br />
        <code class="computeroutput"><span class="special">[[=</span><span class="identifier">col</span><span class="special">=]]</span></code>的表达式匹配主排序关键字等同于对照元素<span class="emphasis"><em>col</em></span>的任意字符或对照元素，其中名字为<span class="emphasis"><em>col</em></span>的对照元素可以是一个<a href="collating_names.html" title="Collating Names">符号名称(symbolic name)</a>。
        主排序关键字忽略大小写、重音或特定区域(locale)的裁剪(tailorings)；
        所以如<code class="computeroutput"><span class="special">[[=</span><span class="identifier">a</span><span class="special">=]]</span></code>匹配下面的字符：a, À, Á, Â, Ã, Ä, Å, A, à, á, â, ã, ä and å。
        不幸的是这个实现依赖于平台的对照(collation)和地区(localization)支持；
        这个特性并不能很好地可移植工作于所有的平台，甚至一个平台上的所有区域(locale)。
      </p>
<a name="boost_regex.syntax.perl_syntax.escaped_characters"></a><h6>
<a name="id509624"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.escaped_characters">Escaped
        Characters 转义字符</a>
      </h6>
<p>
        All the escape sequences that match a single character, or a single character
        class are permitted within a character class definition. For example <code class="computeroutput"><span class="special">[\[\]]</span></code> would match either of <code class="computeroutput"><span class="special">[</span></code> or <code class="computeroutput"><span class="special">]</span></code>
        while <code class="computeroutput"><span class="special">[\</span><span class="identifier">W</span><span class="special">\</span><span class="identifier">d</span><span class="special">]</span></code>
        would match any character that is either a "digit", <span class="emphasis"><em>or</em></span>
        is <span class="emphasis"><em>not</em></span> a "word" character.
        <br />
        任意匹配单个字符或单个字符类的转义序列都可以定义在字符类中。
        例如<code class="computeroutput"><span class="special">[\[\]]</span></code>可以匹配<code class="computeroutput"><span class="special">[</span></code>或<code class="computeroutput"><span class="special">]</span></code>，
        而<code class="computeroutput"><span class="special">[\</span><span class="identifier">W</span><span class="special">\</span><span class="identifier">d</span><span class="special">]</span></code>可以匹配任何不是"数字"或不是"单词"的字符。
      </p>
<a name="boost_regex.syntax.perl_syntax.combinations"></a><h6>
<a name="id509730"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.combinations">Combinations 组合</a>
      </h6>
<p>
        All of the above can be combined in one character set declaration, for example:
        <code class="computeroutput"><span class="special">[[:</span><span class="identifier">digit</span><span class="special">:]</span><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span><span class="special">[.</span><span class="identifier">NUL</span><span class="special">.]]</span></code>.
        <br />
        所有上面的都可以在一个字符类声明中被组合，
        例如<code class="computeroutput"><span class="special">[[:</span><span class="identifier">digit</span><span class="special">:]</span><span class="identifier">a</span><span class="special">-</span><span class="identifier">c</span><span class="special">[.</span><span class="identifier">NUL</span><span class="special">.]]</span></code>。
      </p>
<a name="boost_regex.syntax.perl_syntax.escapes"></a><h5>
<a name="id509808"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.escapes">Escapes 转义符</a>
      </h5>
<p>
        Any special character preceded by an escape shall match itself.
        <br />
        任意特殊字符前面加转义符都匹配自己。
      </p>
<p>
        The following escape sequences are all synonyms for single characters:
        <br />
        下面的转义序列都和单个字符同义：
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Escape
              </p>
              </th>
<th>
              <p>
                Character
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">a</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">a</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">e</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="number">0x1B</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">f</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">f</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">n</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">n</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">r</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">r</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">t</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">t</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">v</span>
                </code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">v</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">b</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">b</span></code>
                (but only inside a character class declaration).
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">cX</span></code>
              </p>
              </td>
<td>
              <p>
                An ASCII escape sequence - the character whose code point is X %
                32
                <br />
                一个ASCII转义序列 - 字符码点为X % 32
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">xdd</span></code>
              </p>
              </td>
<td>
              <p>
                A hexadecimal escape sequence - matches the single character whose
                code point is 0xdd.
                <br />
                一个十六进制转义序列 - 匹配码点为0xdd的单个字符。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">x</span><span class="special">{</span><span class="identifier">dddd</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                A hexadecimal escape sequence - matches the single character whose
                code point is 0xdddd.
                <br />
                一个十六进制转义序列 - 匹配码点为0xdddd的单个字符。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="number">0ddd</span></code>
              </p>
              </td>
<td>
              <p>
                An octal escape sequence - matches the single character whose code
                point is 0ddd.
                <br />
                八进制转义序列 - 匹配码点为0ddd的单个字符。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">N</span><span class="special">{</span><span class="identifier">name</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                Matches the single character which has the <a href="collating_names.html" title="Collating Names">symbolic
                name</a> <span class="emphasis"><em>name</em></span>. For example <code class="computeroutput"><span class="special">\</span><span class="identifier">N</span><span class="special">{</span><span class="identifier">newline</span><span class="special">}</span></code> matches the single character \n.
                <br />
                匹配<a href="collating_names.html" title="Collating Names">符号名称(symbolic name)</a>为<span class="emphasis"><em>name</em></span>的单个字符。
                例如<code class="computeroutput"><span class="special">\</span><span class="identifier">N</span><span class="special">{</span><span class="identifier">newline</span><span class="special">}</span></code>匹配单个字符\n。
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.syntax.perl_syntax._quot_single_character_quot__character_classes_"></a><h6>
<a name="id510521"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax._quot_single_character_quot__character_classes_">"Single
        character" character classes: "单字符"字符类：</a>
      </h6>
<p>
        Any escaped character <span class="emphasis"><em>x</em></span>, if <span class="emphasis"><em>x</em></span> is
        the name of a character class shall match any character that is a member
        of that class, and any escaped character <span class="emphasis"><em>X</em></span>, if <span class="emphasis"><em>x</em></span>
        is the name of a character class, shall match any character not in that class.
        <br />
        任意被转义的字符<span class="emphasis"><em>x</em></span>，如果<span class="emphasis"><em>x</em></span>是一个字符类的名称，会匹配这个字符类成员的任意字符。
        任意被转义的字符<span class="emphasis"><em>X</em></span>, 如果<span class="emphasis"><em>x</em></span>是一个字符类的名称，则会匹配不在这个类中的任意字符。
      </p>
<p>
        The following are supported by default:
        <br />
        下面是默认支持的：
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Escape sequence
              </p>
              </th>
<th>
              <p>
                Equivalent to
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">d</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">digit</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">l</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">lower</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">s</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">space</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">u</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">upper</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">w</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">word</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">D</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">digit</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">L</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">lower</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">S</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">space</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">U</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">upper</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">W</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">word</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.syntax.perl_syntax.character_properties"></a><h6>
<a name="id511153"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_properties">Character
        Properties 字符属性</a>
      </h6>
<p>
        The character property names in the following table are all equivalent to
        the <a href="character_classes.html" title="Character Class Names">names used in character
        classes</a>.
        <br />
        下面表格中的字符属性名称都等价于<a href="character_classes.html" title="Character Class Names">字符类中使用的名字(names used in character classes)</a>。
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Form
              </p>
              </th>
<th>
              <p>
                Description
              </p>
              </th>
<th>
              <p>
                Equivalent character set form
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">pX</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that has the property X.
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">X</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">p</span><span class="special">{</span><span class="identifier">Name</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that has the property Name.
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">Name</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">PX</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that does not have the property X.
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">X</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">P</span><span class="special">{</span><span class="identifier">Name</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that does not have the property Name.
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">Name</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        For example <code class="computeroutput"><span class="special">\</span><span class="identifier">pd</span></code>
        matches any "digit" character, as does <code class="computeroutput"><span class="special">\</span><span class="identifier">p</span><span class="special">{</span><span class="identifier">digit</span><span class="special">}</span></code>.
        <br />
        例如<code class="computeroutput"><span class="special">\</span><span class="identifier">pd</span></code>匹配任意的"数字"字符，和<code class="computeroutput"><span class="special">\</span><span class="identifier">p</span><span class="special">{</span><span class="identifier">digit</span><span class="special">}</span></code>作用是一样的。
      </p>
<a name="boost_regex.syntax.perl_syntax.word_boundaries"></a><h6>
<a name="id511562"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.word_boundaries">Word Boundaries 单词边界</a>
      </h6>
<p>
        The following escape sequences match the boundaries of words:
        <br />
        下面的转义序列匹配单词的边界：
      </p>
<p>
        <code class="computeroutput"><span class="special">\&lt;</span></code> Matches the start of a
        word.
        <br />
        <code class="computeroutput"><span class="special">\&lt;</span></code>匹配单词的起点。
      </p>
<p>
        <code class="computeroutput"><span class="special">\&gt;</span></code> Matches the end of a word.
        <br />
        <code class="computeroutput"><span class="special">\&gt;</span></code>匹配单词的终点。
      </p>
<p>
        <code class="computeroutput"><span class="special">\</span><span class="identifier">b</span></code>
        Matches a word boundary (the start or end of a word).
        <br />
        <code class="computeroutput"><span class="special">\</span><span class="identifier">b</span></code>匹配单词的边界(起点或终点)。
      </p>
<p>
        <code class="computeroutput"><span class="special">\</span><span class="identifier">B</span></code>
        Matches only when not at a word boundary.
        <br />
        <code class="computeroutput"><span class="special">\</span><span class="identifier">B</span></code>只有不在单词边界时才匹配。
      </p>
<a name="boost_regex.syntax.perl_syntax.buffer_boundaries"></a><h6>
<a name="id511664"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.buffer_boundaries">Buffer boundaries 缓冲区边界</a>
      </h6>
<p>
        The following match only at buffer boundaries: a "buffer" in this
        context is the whole of the input text that is being matched against (note
        that ^ and $ may match embedded newlines within the text).
        <br />
        下面的转义序列匹配缓冲区边界：这里的"缓冲区"指用于匹配的全部输入文本，(^和$可以用于匹配文本中的行)。
      </p>
<p>
        \` Matches at the start of a buffer only.
        <br />
        \`匹配缓冲区的起点。
      </p>
<p>
        \' Matches at the end of a buffer only.
        <br />
        \'匹配缓冲区的终点
      </p>
<p>
        \A Matches at the start of a buffer only (the same as \`).
        <br />
        \A匹配缓冲区的起点(同\`一样)。
      </p>
<p>
        \z Matches at the end of a buffer only (the same as \').
        <br />
        \z匹配缓冲区的终点(同\'一样)。
      </p>
<p>
        \Z Matches an optional sequence of newlines at the end of a buffer: equivalent
        to the regular expression <code class="computeroutput"><span class="special">\</span><span class="identifier">n</span><span class="special">*\</span><span class="identifier">z</span></code>
        \Z匹配缓冲区结尾可能存在的空行：等价于正则表达式<code class="computeroutput"><span class="special">\</span><span class="identifier">n</span><span class="special">*\</span><span class="identifier">z</span></code>
      </p>
<a name="boost_regex.syntax.perl_syntax.continuation_escape"></a><h6>
<a name="id511747"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.continuation_escape">Continuation
        Escape 持续转义</a>
      </h6>
<p>
        The sequence <code class="computeroutput"><span class="special">\</span><span class="identifier">G</span></code>
        matches only at the end of the last match found, or at the start of the text
        being matched if no previous match was found. This escape useful if you're
        iterating over the matches contained within a text, and you want each subsequence
        match to start where the last one ended.
        <br />
        序列<code class="computeroutput"><span class="special">\</span><span class="identifier">G</span></code>只在上次匹配结尾或匹配文本的起点(如果前面没有匹配)。
        当你要迭代文本中所有的匹配，并且每个子序列都从上一次结束时开始匹配的话，这个转义是很有用的。
      </p>
<a name="boost_regex.syntax.perl_syntax.quoting_escape"></a><h6>
<a name="id511798"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.quoting_escape">Quoting escape 引用转义</a>
      </h6>
<p>
        The escape sequence <code class="computeroutput"><span class="special">\</span><span class="identifier">Q</span></code>
        begins a "quoted sequence": all the subsequent characters are treated
        as literals, until either the end of the regular expression or \E is found.
        For example the expression: <code class="computeroutput"><span class="special">\</span><span class="identifier">Q</span><span class="special">\*+\</span><span class="identifier">Ea</span><span class="special">+</span></code> would match either of:
        <br />
        转义序列<code class="computeroutput"><span class="special">\</span><span class="identifier">Q</span></code>开始一个"被引用序列"：
        所有后面的字符都被当作字面(literal)对待，除非正则表达式结束或碰到\E。
        例如，表达式：<code class="computeroutput"><span class="special">\</span><span class="identifier">Q</span><span class="special">\*+\</span><span class="identifier">Ea</span><span class="special">+</span></code>可以匹配如下：
      </p>
<pre class="programlisting"><span class="special">\*+</span><span class="identifier">a</span>
<span class="special">\*+</span><span class="identifier">aaa</span>
</pre>
<a name="boost_regex.syntax.perl_syntax.unicode_escapes"></a><h6>
<a name="id511904"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.unicode_escapes">Unicode escapes Unicode转义</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">\</span><span class="identifier">C</span></code>
        Matches a single code point: in Boost regex this has exactly the same effect
        as a "." operator. <code class="computeroutput"><span class="special">\</span><span class="identifier">X</span></code> Matches a combining character sequence:
        that is any non-combining character followed by a sequence of zero or more
        combining characters.
        <br />
        <code class="computeroutput"><span class="special">\</span><span class="identifier">C</span></code>匹配一个单一的码表：在Boost.Regex中这和"."操作符的作用是完全相同的。
        <code class="computeroutput"><span class="special">\</span><span class="identifier">X</span></code>匹配一个组合字符序列：任意非组合字符跟上一个零或多个组合字符的序列(???)。
      </p>
<a name="boost_regex.syntax.perl_syntax.any_other_escape"></a><h6>
<a name="id511968"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.any_other_escape">Any other
        escape 其它转义</a>
      </h6>
<p>
        Any other escape sequence matches the character that is escaped, for example
        \@ matches a literal '@'.
        <br />
        其它转义序列匹配被转义的字符，例如\@匹配'@'。
      </p>
<a name="boost_regex.syntax.perl_syntax.perl_extended_patterns"></a><h5>
<a name="id511997"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.perl_extended_patterns">Perl
        Extended Patterns Perl扩展模式</a>
      </h5>
<p>
        Perl-specific extensions to the regular expression syntax all start with
        <code class="computeroutput"><span class="special">(?</span></code>.
        <br />
        Perl扩展的正则表达式语法都以<code class="computeroutput"><span class="special">(?</span></code>开始。
      </p>
<a name="boost_regex.syntax.perl_syntax.comments"></a><h6>
<a name="id512038"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.comments">Comments 注释</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">(?</span># <span class="special">...</span>
        <span class="special">)</span></code> is treated as a comment, it's contents
        are ignored.
        <br />
        <code class="computeroutput"><span class="special">(?</span># <span class="special">...</span> <span class="special">)</span></code>作为注释，里面的内容被忽略。
      </p>
<a name="boost_regex.syntax.perl_syntax.modifiers"></a><h6>
<a name="id512091"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.modifiers">Modifiers 修饰</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">(?</span><span class="identifier">imsx</span><span class="special">-</span><span class="identifier">imsx</span> <span class="special">...</span> <span class="special">)</span></code> alters
        which of the perl modifiers are in effect within the pattern, changes take
        effect from the point that the block is first seen and extend to any enclosing
        <code class="computeroutput"><span class="special">)</span></code>. Letters before a '-' turn
        that perl modifier on, letters afterward, turn it off.
        <br />
        <code class="computeroutput"><span class="special">(?</span><span class="identifier">imsx</span><span class="special">-</span><span class="identifier">imsx</span> <span class="special">...</span> <span class="special">)</span></code>改变在模式中perl修饰符是否起作用，
        从块第一次被遇到的点开始起作用，直到遇到结束<code class="computeroutput"><span class="special">)</span></code>。
        'a'前的字母打开perl修饰符，后面的字母关闭。
      </p>
<p>
        <code class="computeroutput"><span class="special">(?</span><span class="identifier">imsx</span><span class="special">-</span><span class="identifier">imsx</span><span class="special">:</span><span class="identifier">pattern</span><span class="special">)</span></code>
        applies the specified modifiers to pattern only.
        <br />
        <code class="computeroutput"><span class="special">(?</span><span class="identifier">imsx</span><span class="special">-</span><span class="identifier">imsx</span><span class="special">:</span><span class="identifier">pattern</span><span class="special">)</span></code>只将特定的修饰符应用于指定的模式。
      </p>
<a name="boost_regex.syntax.perl_syntax.non_marking_groups"></a><h6>
<a name="id512218"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.non_marking_groups">Non-marking
        groups 非标记分组</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">(?:</span><span class="identifier">pattern</span><span class="special">)</span></code> lexically groups pattern, without generating
        an additional sub-expression.
        <br />
        <code class="computeroutput"><span class="special">(?:</span><span class="identifier">pattern</span><span class="special">)</span></code>进行字面分组，但不产生额外的子表达式。
      </p>
<a name="boost_regex.syntax.perl_syntax.lookahead"></a><h6>
<a name="id512269"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.lookahead">Lookahead 前向匹配</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">(?=</span><span class="identifier">pattern</span><span class="special">)</span></code> consumes zero characters, only if pattern
        matches.
        <br />
        <code class="computeroutput"><span class="special">(?=</span><span class="identifier">pattern</span><span class="special">)</span></code>当模式匹配时成功，但不消耗字符。
      </p>
<p>
        <code class="computeroutput"><span class="special">(?!</span><span class="identifier">pattern</span><span class="special">)</span></code> consumes zero characters, only if pattern
        does not match.
        <br />
        <code class="computeroutput"><span class="special">(?!</span><span class="identifier">pattern</span><span class="special">)</span></code>当模式不匹配时成功，但不消耗字符。
      </p>
<p>
        Lookahead is typically used to create the logical AND of two regular expressions,
        for example if a password must contain a lower case letter, an upper case
        letter, a punctuation symbol, and be at least 6 characters long, then the
        expression:
        <br />
        前向匹配典型用法是创建两个正则表达式的逻辑与，
        例如一个密码必须包含一个小写字符，一个大写字符，一个标点符号，长度至少6个字符，那么表达式是：
      </p>
<pre class="programlisting"><span class="special">(?=.*[[:</span><span class="identifier">lower</span><span class="special">:]])(?=.*[[:</span><span class="identifier">upper</span><span class="special">:]])(?=.*[[:</span><span class="identifier">punct</span><span class="special">:]]).{</span><span class="number">6</span><span class="special">,}</span>
</pre>
<p>
        could be used to validate the password.
        <br />
        能被用来验证密码。
      </p>
<a name="boost_regex.syntax.perl_syntax.lookbehind"></a><h6>
<a name="id512410"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.lookbehind">Lookbehind 后向匹配</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">(?&lt;=</span><span class="identifier">pattern</span><span class="special">)</span></code> consumes zero characters, only if pattern
        could be matched against the characters preceding the current position (pattern
        must be of fixed length).
        <br />
        <code class="computeroutput"><span class="special">(?&lt;=</span><span class="identifier">pattern</span><span class="special">)</span></code>只有当模式能够被当前位置之前的字符匹配时才成功(模式必须是固定长度)，但并不消耗字符。
      </p>
<p>
        <code class="computeroutput"><span class="special">(?&lt;!</span><span class="identifier">pattern</span><span class="special">)</span></code> consumes zero characters, only if pattern
        could not be matched against the characters preceding the current position
        (pattern must be of fixed length).
        <br />
        <code class="computeroutput"><span class="special">(?&lt;!</span><span class="identifier">pattern</span><span class="special">)</span></code>只有当模式不能够被当前位置之前的字符匹配时才成功(模式必须是固定长度)，但并不消耗字符。
      </p>
<a name="boost_regex.syntax.perl_syntax.independent_sub_expressions"></a><h6>
<a name="id512489"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.independent_sub_expressions">Independent
        sub-expressions 独立子表达式</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">(?&gt;</span><span class="identifier">pattern</span><span class="special">)</span></code> <span class="emphasis"><em>pattern</em></span> is matched
        independently of the surrounding patterns, the expression will never backtrack
        into <span class="emphasis"><em>pattern</em></span>. Independent sub-expressions are typically
        used to improve performance; only the best possible match for pattern will
        be considered, if this doesn't allow the expression as a whole to match then
        no match is found at all.
        <br />
        <code class="computeroutput"><span class="special">(?&gt;</span><span class="identifier">pattern</span><span class="special">)</span></code> <span class="emphasis"><em>pattern</em></span>独立于外围模式地被匹配，表达式决不会被回溯到<span class="emphasis"><em>pattern</em></span>中。
        独立子表达式通常用于改善性能；只有最好可能的匹配才会被考虑，如果表达式不能作为整体被匹配，那就没有匹配。
      </p>
<a name="boost_regex.syntax.perl_syntax.conditional_expressions"></a><h6>
<a name="id512553"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.conditional_expressions">Conditional
        Expressions 条件表达式</a>
      </h6>
<p>
        <code class="computeroutput"><span class="special">(?(</span><span class="identifier">condition</span><span class="special">)</span><span class="identifier">yes</span><span class="special">-</span><span class="identifier">pattern</span><span class="special">|</span><span class="identifier">no</span><span class="special">-</span><span class="identifier">pattern</span><span class="special">)</span></code> attempts to match <span class="emphasis"><em>yes-pattern</em></span>
        if the <span class="emphasis"><em>condition</em></span> is true, otherwise attempts to match
        <span class="emphasis"><em>no-pattern</em></span>.
        <br />
        <code class="computeroutput"><span class="special">(?(</span><span class="identifier">condition</span><span class="special">)</span><span class="identifier">yes</span><span class="special">-</span><span class="identifier">pattern</span><span class="special">|</span><span class="identifier">no</span><span class="special">-</span><span class="identifier">pattern</span><span class="special">)</span></code>当<span class="emphasis"><em>condition</em></span>成立时试图匹配<span class="emphasis"><em>yes-pattern</em></span>，否则试图匹配<span class="emphasis"><em>no-pattern</em></span>。
      </p>
<p>
        <code class="computeroutput"><span class="special">(?(</span><span class="identifier">condition</span><span class="special">)</span><span class="identifier">yes</span><span class="special">-</span><span class="identifier">pattern</span><span class="special">)</span></code>
        attempts to match <span class="emphasis"><em>yes-pattern</em></span> if the <span class="emphasis"><em>condition</em></span>
        is true, otherwise fails.
        <br />
        <code class="computeroutput"><span class="special">(?(</span><span class="identifier">condition</span><span class="special">)</span><span class="identifier">yes</span><span class="special">-</span><span class="identifier">pattern</span><span class="special">)</span></code>当<span class="emphasis"><em>condition</em></span>成立时试图匹配<span class="emphasis"><em>yes-pattern</em></span>，否则直接失败。
      </p>
<p>
        <span class="emphasis"><em>condition</em></span> may be either a forward lookahead assert,
        or the index of a marked sub-expression (the condition becomes true if the
        sub-expression has been matched).
        <br />
        <span class="emphasis"><em>condition</em></span>可以是一个前向匹配断言，
        或者是一个标记子表达式序号(当子表达式匹配时条件为真)。
      </p>
<a name="boost_regex.syntax.perl_syntax.operator_precedence"></a><h5>
<a name="id512722"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.operator_precedence">Operator
        precedence 操作符优先级</a>
      </h5>
<p>
        The order of precedence for of operators is as follows:
        <br />
        操作符优先级如下：
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Collation-related bracket symbols <code class="computeroutput"><span class="special">[==]</span>
          <span class="special">[::]</span> <span class="special">[..]</span></code>
          <br />
          对照相关的方括号字符 <code class="computeroutput"><span class="special">[==]</span>
          <span class="special">[::]</span> <span class="special">[..]</span></code>
</li>
<li>
          Escaped characters <code class="computeroutput"><span class="special">\</span></code>
          <br />
          转义字符 <code class="computeroutput"><span class="special">\</span></code>
</li>
<li>
          Character set (bracket expression) <code class="computeroutput"><span class="special">[]</span></code>
          <br />
          字符集(方括号表达式) <code class="computeroutput"><span class="special">[]</span></code>
</li>
<li>
          Grouping <code class="computeroutput"><span class="special">()</span></code>
          <br />
          分组 <code class="computeroutput"><span class="special">()</span></code>
</li>
<li>
          Single-character-ERE duplication <code class="computeroutput"><span class="special">*</span>
          <span class="special">+</span> <span class="special">?</span> <span class="special">{</span><span class="identifier">m</span><span class="special">,</span><span class="identifier">n</span><span class="special">}</span></code>
          <br />
          单字符重复(Single-character-ERE ???) <code class="computeroutput"><span class="special">*</span>
          <span class="special">+</span> <span class="special">?</span> <span class="special">{</span><span class="identifier">m</span><span class="special">,</span><span class="identifier">n</span><span class="special">}</span></code>
</li>
<li>
          Concatenation
          <br />
          连接
        </li>
<li>
          Anchoring ^$
          <br />
          锚点
        </li>
<li>
          Alternation |
          <br />
          选择
        </li>
</ol></div>
<a name="boost_regex.syntax.perl_syntax.what_gets_matched"></a><h4>
<a name="id512900"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.what_gets_matched">What gets
        matched 什么被匹配</a>
      </h4>
<p>
        If you view the regular expression as a directed (possibly cyclic) graph,
        then the best match found is the first match found by a depth-first-search
        performed on that graph, while matching the input text.
        <br />
        如果你将正则表达式当作有向(可能循环)图，那么最优匹配就是在匹配输入文本过程中按照深度优先搜索找到的第一个匹配。
      </p>
<p>
        Alternatively:
        <br />
        或者说：
      </p>
<p>
        The best match found is the <a href="leftmost_longest_rule.html" title="The Leftmost Longest Rule">leftmost
        match</a>, with individual elements matched as follows;
        <br />
        或者说最优匹配就是当单个元素如下匹配时找到的<a href="leftmost_longest_rule.html" title="The Leftmost Longest Rule">最左匹配(leftmost match)</a>。
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Construct
              </p>
              </th>
<th>
              <p>
                What gets matched
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">AtomA</span> <span class="identifier">AtomB</span></code>
              </p>
              </td>
<td>
              <p>
                Locates the best match for <span class="emphasis"><em>AtomA</em></span> that has a
                following match for <span class="emphasis"><em>AtomB</em></span>.
                <br />
                最佳匹配定位于<span class="emphasis"><em>AtomA</em></span>后跟<span class="emphasis"><em>AtomB</em></span>的匹配。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">Expression1</span> <span class="special">|</span>
                <span class="identifier">Expression2</span></code>
              </p>
              </td>
<td>
              <p>
                If <span class="emphasis"><em>Expresion1</em></span> can be matched then returns that
                match, otherwise attempts to match <span class="emphasis"><em>Expression2</em></span>.
                <br />
                如果<span class="emphasis"><em>Expresion1</em></span>能够匹配就返回这个匹配，否则试图匹配<span class="emphasis"><em>Expression2</em></span>。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="identifier">N</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                Matches <span class="emphasis"><em>S</em></span> repeated exactly N times.
                <br />
                匹配<span class="emphasis"><em>S</em></span>精确重复N次。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">M</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                Matches S repeated between N and M times, and as many times as possible.
                <br />
                匹配S重复N到M次之间，并尽可能多地重复。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">M</span><span class="special">}?</span></code>
              </p>
              </td>
<td>
              <p>
                Matches S repeated between N and M times, and as few times as possible.
                <br />
                匹配S重复N到M次之间，并尽可能少地重复。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">S</span><span class="special">?,</span>
                <span class="identifier">S</span><span class="special">*,</span>
                <span class="identifier">S</span><span class="special">+</span></code>
              </p>
              </td>
<td>
              <p>
                The same as <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">}</span></code>,
                <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="number">0</span><span class="special">,</span><span class="identifier">UINT_MAX</span><span class="special">}</span></code>,
                <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="number">1</span><span class="special">,</span><span class="identifier">UINT_MAX</span><span class="special">}</span></code>
                respectively.
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">S</span><span class="special">??,</span>
                <span class="identifier">S</span><span class="special">*?,</span>
                <span class="identifier">S</span><span class="special">+?</span></code>
              </p>
              </td>
<td>
              <p>
                The same as <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">}?</span></code>,
                <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="number">0</span><span class="special">,</span><span class="identifier">UINT_MAX</span><span class="special">}?</span></code>,
                <code class="computeroutput"><span class="identifier">S</span><span class="special">{</span><span class="number">1</span><span class="special">,</span><span class="identifier">UINT_MAX</span><span class="special">}?</span></code>
                respectively.
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">(?&gt;</span><span class="identifier">S</span><span class="special">)</span></code>
              </p>
              </td>
<td>
              <p>
                Matches the best match for <span class="emphasis"><em>S</em></span>, and only that.
                <br />
                匹配且只匹配<span class="emphasis"><em>S</em></span>的最佳匹配。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">(?=</span><span class="identifier">S</span><span class="special">),</span> <span class="special">(?&lt;=</span><span class="identifier">S</span><span class="special">)</span></code>
              </p>
              </td>
<td>
              <p>
                Matches only the best match for <span class="emphasis"><em>S</em></span> (this is only
                visible if there are capturing parenthesis within <span class="emphasis"><em>S</em></span>).
                <br />
                只匹配<span class="emphasis"><em>S</em></span>的最佳匹配(只有当<span class="emphasis"><em>S</em></span>中有捕获用括号时才可见)。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">(?!</span><span class="identifier">S</span><span class="special">),</span> <span class="special">(?&lt;!</span><span class="identifier">S</span><span class="special">)</span></code>
              </p>
              </td>
<td>
              <p>
                Considers only whether a match for S exists or not.
                <br />
                只有当S匹配或不匹配时才继续考虑。
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">(?(</span><span class="identifier">condition</span><span class="special">)</span><span class="identifier">yes</span><span class="special">-</span><span class="identifier">pattern</span>
                <span class="special">|</span> <span class="identifier">no</span><span class="special">-</span><span class="identifier">pattern</span><span class="special">)</span></code>
              </p>
              </td>
<td>
              <p>
                If condition is true, then only yes-pattern is considered, otherwise
                only no-pattern is considered.
                <br />
                如果条件为真，只有yes-pattern被考虑，否则只有no-pattern被考虑。
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.syntax.perl_syntax.variations"></a><h4>
<a name="id513815"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.variations">Variations 变化</a>
      </h4>
<p>
        The <a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions">options
        <code class="computeroutput"><span class="identifier">normal</span></code>, <code class="computeroutput"><span class="identifier">ECMAScript</span></code>,
        <code class="computeroutput"><span class="identifier">JavaScript</span></code> and <code class="computeroutput"><span class="identifier">JScript</span></code></a> are all synonyms for <code class="computeroutput"><span class="identifier">perl</span></code>.
    <br />
    <a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions">选项(options)<code class="computeroutput"><span class="identifier">normal</span></code>，<code class="computeroutput"><span class="identifier">ECMAScript</span></code>，<code class="computeroutput"><span class="identifier">JavaScript</span></code>和<code class="computeroutput"><span class="identifier">JScript</span></code></a>都是<code class="computeroutput"><span class="identifier">perl</span></code>的同义词。
      </p>
<a name="boost_regex.syntax.perl_syntax.options"></a><h4>
<a name="id513910"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.options">Options 选项</a>
      </h4>
<p>
        There are a <a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions">variety
        of flags</a> that may be combined with the <code class="computeroutput"><span class="identifier">perl</span></code>
        option when constructing the regular expression, in particular note that
        the <code class="computeroutput"><span class="identifier">newline_alt</span></code> option alters
        the syntax, while the <code class="computeroutput"><span class="identifier">collate</span></code>,
        <code class="computeroutput"><span class="identifier">nosubs</span></code> and <code class="computeroutput"><span class="identifier">icase</span></code> options modify how the case and locale
        sensitivity are to be applied.
        <br />
        构造正则表达式时有<a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions">一系列标签</a>可以和<code class="computeroutput"><span class="identifier">perl</span></code>选项组合使用，
        尤其注意的是<code class="computeroutput"><span class="identifier">newline_alt</span></code>选项更改语法，
        而<code class="computeroutput"><span class="identifier">collate</span></code>、<code class="computeroutput"><span class="identifier">nosubs</span></code>和<code class="computeroutput"><span class="identifier">icase</span></code>选项影响大小写和区域(locale)敏感内容如何被应用。
      </p>
<a name="boost_regex.syntax.perl_syntax.pattern_modifiers"></a><h4>
<a name="id514011"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.pattern_modifiers">Pattern
        Modifiers 模式修饰符</a>
      </h4>
<p>
        The perl <code class="computeroutput"><span class="identifier">smix</span></code> modifiers can
        either be applied using a <code class="computeroutput"><span class="special">(?</span><span class="identifier">smix</span><span class="special">-</span><span class="identifier">smix</span><span class="special">)</span></code> prefix to the regular expression, or with
        one of the <a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions">regex-compile
        time flags <code class="computeroutput"><span class="identifier">no_mod_m</span></code>, <code class="computeroutput"><span class="identifier">mod_x</span></code>, <code class="computeroutput"><span class="identifier">mod_s</span></code>,
        and <code class="computeroutput"><span class="identifier">no_mod_s</span></code></a>.
    <br />
    perl的<code class="computeroutput"><span class="identifier">smix</span></code>修饰符可以通过往正则表达式中添加<code class="computeroutput"><span class="special">(?</span><span class="identifier">smix</span><span class="special">-</span><span class="identifier">smix</span><span class="special">)</span></code>前缀，
    或使用<a href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions">regex编译时标签(regex-compile time flags) <code class="computeroutput"><span class="identifier">no_mod_m</span></code>, <code class="computeroutput"><span class="identifier">mod_x</span></code>、<code class="computeroutput"><span class="identifier">mod_s</span></code>和<code class="computeroutput"><span class="identifier">no_mod_s</span></code></a>之一。
      </p>
<a name="boost_regex.syntax.perl_syntax.references"></a><h4>
<a name="id514138"></a>
        <a href="perl_syntax.html#boost_regex.syntax.perl_syntax.references">References</a>
      </h4>
<p>
        <a href="http://perldoc.perl.org/perlre.html" target="_top">Perl 5.8</a>.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 1998 -2007 John Maddock<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../syntax.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../syntax.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="basic_extended.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

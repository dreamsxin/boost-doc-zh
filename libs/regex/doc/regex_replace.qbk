[/ 
  Copyright 2006-2007 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]


[section:regex_replace regex_replace]

   #include <boost/regex.hpp> 

The algorithm [regex_replace] searches through a string finding all the 
matches to the regular expression: for each match it then calls 
[match_results_format] to format the string and sends the result to the 
output iterator. Sections of text that do not match are copied to the 
output unchanged only if the /flags/ parameter does not have the 
flag `format_no_copy` set. If the flag `format_first_only` is set then 
only the first occurrence is replaced rather than all occurrences. \n
算法 [regex_replace] 在字符串搜索正则表达式的所有匹配： 对于每个匹配，调用 [match_results_format] 
来格式化字符串并将结果送到输出迭代器中。如果 /flags/ 参数没有设置标签 `format_no_copy`，
那么没有匹配的文本部分将被原封不动地拷贝到输出。如果设置了标签 `format_first_only`，
那么只有第一个匹配被替换，而不是所有匹配的地方。

   template <class OutputIterator, class BidirectionalIterator, class traits, class Formatter>
   OutputIterator regex_replace(OutputIterator out,
                                BidirectionalIterator first,
                                BidirectionalIterator last,
                                const basic_regex<charT, traits>& e,
                                Formatter fmt,
                                match_flag_type flags = match_default);

   template <class traits, class Formatter>
   basic_string<charT> regex_replace(const basic_string<charT>& s,
                                     const basic_regex<charT, traits>& e,
                                     Formatter fmt,
                                     match_flag_type flags = match_default);


[h4 Description 说明]

   template <class OutputIterator, class BidirectionalIterator, class traits, class Formatter>
   OutputIterator regex_replace(OutputIterator out,
                                BidirectionalIterator first,
                                BidirectionalIterator last,
                                const basic_regex<charT, traits>& e,
                                Formatter fmt,
                                match_flag_type flags = match_default);

Enumerates all the occurences of expression /e/ in the sequence \[first, last), 
replacing each occurence with the string that results by merging the 
match found with the format string /fmt/, and copies the resulting string to /out/. 
In the case that /fmt/ is a unary, binary or ternary function object, then the
character sequence generated by that object is copied unchanged to the output when performing
a substitution.\n
遍历表达式 /e/ 在序列 \[first,last) 中的所有匹配，对于每个匹配，用匹配的字符串和格式化字符串 /fmt/ 
合并的结果替换，并将结果字符串拷贝到 /out/。如果 /fmt/ 是一个单参、双参或三参数的函数对象，
则由该函数对象生成的字符序列将被原样复制到输出来执行替换。

If the flag `format_no_copy` is set in /flags/ then unmatched sections of 
text are not copied to output. \n
如果在 /flags/ 中设置了标签 `format_no_copy`，那么未匹配的文本部分不被拷贝到输出。

If the flag `format_first_only` is set in flags then only the first 
occurence of /e/ is replaced. \n
如果设置了标签 `format_first_only`，那么只有 /e/ 第一个出现的地方被替换。

The manner in which the format string /fmt/ is interpretted, along with the 
rules used for finding matches, are determined by the flags set in /flags/:
see [match_flag_type].\n
格式化字符串 /fmt/ 如何被解释，以及搜索匹配的原则，都由设置在 /flags/ 的标签决定：参见 [match_flag_type]。

[*Requires]
The type `Formatter` must be either a pointer to a null-terminated string
of type `char_type[]`, or be a container of `char_type`'s (for example
`std::basic_string<char_type>`) or be a unary, binary or ternary functor
that computes the replacement string from a function call: either 
`fmt(what)` which must return a container of `char_type`'s to be used as the
replacement text, or either `fmt(what, out)` or `fmt(what, out, flags)`, both of
which write the replacement text to `*out`, and then return the new
OutputIterator position.  In each case `what` is the [match_results] object
that represents the match found.  Note that if the formatter is a functor, then it is
['passed by value]: users that want to pass function objects with internal state
might want to use [@../../../../doc/html/ref.html Boost.Ref] to wrap the object so 
that it's passed by reference.\n
[*要求]：类型 `Formatter` 必须是一个指向类型为 `char_type[]` 的null结尾字符串的指针，或是一个
`char_type` 的容器(例如为 `std::basic_string<char_type>`)，或是一个单参、双参或三参数的函数对象，
通过函数调用可以计算得到替换的字符串：要么是 `fmt(what)` 返回一个用作替换文本的 `char_type` 容器，
要么是 `fmt(what, out)` 或 `fmt(what, out, flags)`，它们均将替换文本写出至 `*out`，然后返回新的输出迭代器位置。
这种情况下，`what` 为表示所找到的匹配的 [match_results] 对象。注意，如果格式化器是一个函数对象，则它是 ['按值方式传递的]：
用户如果想传递带有内部状态的函数对象，就要使用 [@../../../../doc/html/ref.html Boost.Ref] 来包装该对象，以使得它按引用方式传递。

[*Effects]: Constructs an [regex_iterator] object:\n
[*效果]：构造一个 [regex_iterator] 对象：

   regex_iterator<BidirectionalIterator, charT, traits, Allocator> 
                                             i(first, last, e, flags), 

and uses /i/ to enumerate through all of the matches /m/ of type 
[match_results] `<BidirectionalIterator>` that occur within the sequence 
\[first, last).\n
并使用 /i/ 来迭代在序列 \[first, last) 内的所有类型为 [match_results] `<BidirectionalIterator>` 的匹配 /m/。

If no such matches are found and\n
如果没有找到这样的匹配，且

   !(flags & format_no_copy) 

then calls\n
则调用

   std::copy(first, last, out). 

Otherwise, for each match found, if\n
否则，对于每一个找到的匹配，如果

   !(flags & format_no_copy) 

calls\n
则调用

   std::copy(m.prefix().first, m.prefix().last, out), 

and then calls\n
然后调用

   m.format(out, fmt, flags). 

Finally if\n
最后，如果

   !(flags & format_no_copy) 

calls\n
则调用

   std::copy(last_m.suffix().first, last_m,suffix().last, out) 

where /last_m/ is a copy of the last match found.\n
其中 /last_m/ 为最后找到的匹配的一份拷贝。

If `flags & format_first_only` is non-zero then only the first match found 
is replaced.\n
如果 `flags & format_first_only` 为非零，则只有找到的第一个匹配被替换。

[*Throws]: `std::runtime_error` if the complexity of matching the expression 
against an N character string begins to exceed O(N[super 2]), or if the 
program runs out of stack space while matching the expression (if Boost.Regex is 
configured in recursive mode), or if the matcher exhausts its permitted 
memory allocation (if Boost.Regex is configured in non-recursive mode).\n
[*抛出]：如果对于N字符长度表达式匹配的复杂度超过O(N[super 2])，或者表达式匹配时发生栈空间溢出
(如果 Boost.Regex 设置为递归模式)，或者匹配器耗尽了所允许申请的内存(如果 Boost.Regex 设置为非递归模式)时， 
会抛出 `std::runtime_error` 异常。

[*Returns]: out.
[*返回]：out.

   template <class traits, class Formatter>
   basic_string<charT> regex_replace(const basic_string<charT>& s,
                                     const basic_regex<charT, traits>& e,
                                     Formatter fmt,
                                     match_flag_type flags = match_default);

[*Requires]
The type `Formatter` must be either a pointer to a null-terminated string
of type `char_type[]`, or be a container of `char_type`'s (for example
`std::basic_string<char_type>`) or be a unary, binary or ternary functor
that computes the replacement string from a function call: either 
`fmt(what)` which must return a container of `char_type`'s to be used as the
replacement text, or either `fmt(what, out)` or `fmt(what, out, flags)`, both of
which write the replacement text to `*out`, and then return the new
OutputIterator position.  In each case `what` is the [match_results] object
that represents the match found.\n
[*要求]：类型 `Formatter` 必须是一个指向类型为 `char_type[]` 的null结尾字符串的指针，或是一个
`char_type` 的容器(例如为 `std::basic_string<char_type>`)，或是一个单参、双参或三参数的函数对象，
通过函数调用可以计算得到替换的字符串：要么是 `fmt(what)` 返回一个用作替换文本的 `char_type` 容器，
要么是 `fmt(what, out)` 或 `fmt(what, out, flags)`，它们均将替换文本写出至 `*out`，然后返回新的输出迭代器位置。
这种情况下，`what` 为表示所找到的匹配的 [match_results] 对象。

[*Effects]: Constructs an object `basic_string<charT> result`, calls 
`regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags)`, 
and then returns `result`.\n
[*效果]：构造一个对象 `basic_string<charT> result`, 调用 `regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags)`, 
然后返回 `result`.

[h4 Examples 示例]

The following example takes C/C++ source code as input, and outputs 
syntax highlighted HTML code.\n
以下例子以 C/C++ 源代码为输入，输出语法高亮的HTML代码。

   #include <fstream>
   #include <sstream>
   #include <string>
   #include <iterator>
   #include <boost/regex.hpp>
   #include <fstream>
   #include <iostream>

   // purpose:
   // takes the contents of a file and transform to
   // syntax highlighted code in html format

   boost::regex e1, e2;
   extern const char* expression_text;
   extern const char* format_string;
   extern const char* pre_expression;
   extern const char* pre_format;
   extern const char* header_text;
   extern const char* footer_text;

   void load_file(std::string& s, std::istream& is)
   {
      s.erase();
      s.reserve(is.rdbuf()->in_avail());
      char c;
      while(is.get(c))
      {
         if(s.capacity() == s.size())
            s.reserve(s.capacity() * 3);
         s.append(1, c);
      }
   }

   int main(int argc, const char** argv)
   {
      try{
      e1.assign(expression_text);
      e2.assign(pre_expression);
      for(int i = 1; i < argc; ++i)
      {
         std::cout << "Processing file " << argv[i] << std::endl;
         std::ifstream fs(argv[i]);
         std::string in;
         load_file(in, fs);
         std::string out_name(std::string(argv[i]) + std::string(".htm"));
         std::ofstream os(out_name.c_str());
         os << header_text;
         // strip '<' and '>' first by outputting to a
         // temporary string stream
         std::ostringstream t(std::ios::out | std::ios::binary);
         std::ostream_iterator<char, char> oi(t);
         boost::regex_replace(oi, in.begin(), in.end(),
         e2, pre_format, boost::match_default | boost::format_all);
         // then output to final output stream
         // adding syntax highlighting:
         std::string s(t.str());
         std::ostream_iterator<char, char> out(os);
         boost::regex_replace(out, s.begin(), s.end(),
         e1, format_string, boost::match_default | boost::format_all);
         os << footer_text;
      }
      }
      catch(...)
      { return -1; }
      return 0;
   }

   extern const char* pre_expression = "(<)|(>)|(&)|\\r";
   extern const char* pre_format = "(?1&lt;)(?2&gt;)(?3&amp;)";


   const char* expression_text = 
      // preprocessor directives: index 1
      "(^[[:blank:]]*#(?:[^\\\\\\n]|\\\\[^\\n[:punct:][:word:]]*[\\n[:punct:][:word:]])*)|"
      // comment: index 2
      "(//[^\\n]*|/\\*.*?\\*/)|"
      // literals: index 3
      "\\<([+-]?(?:(?:0x[[:xdigit:]]+)|(?:(?:[[:digit:]]*\\.)?[[:digit:]]+"
      "(?:[eE][+-]?[[:digit:]]+)?))u?(?:(?:int(?:8|16|32|64))|L)?)\\>|"
      // string literals: index 4
      "('(?:[^\\\\']|\\\\.)*'|\"(?:[^\\\\\"]|\\\\.)*\")|"
      // keywords: index 5
      "\\<(__asm|__cdecl|__declspec|__export|__far16|__fastcall|__fortran|__import"
      "|__pascal|__rtti|__stdcall|_asm|_cdecl|__except|_export|_far16|_fastcall"
      "|__finally|_fortran|_import|_pascal|_stdcall|__thread|__try|asm|auto|bool"
      "|break|case|catch|cdecl|char|class|const|const_cast|continue|default|delete"
      "|do|double|dynamic_cast|else|enum|explicit|extern|false|float|for|friend|goto"
      "|if|inline|int|long|mutable|namespace|new|operator|pascal|private|protected"
      "|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_cast"
      "|struct|switch|template|this|throw|true|try|typedef|typeid|typename|union|unsigned"
      "|using|virtual|void|volatile|wchar_t|while)\\>"
      ;

   const char* format_string = "(?1<font color=\"#008040\">$&</font>)"
                              "(?2<I><font color=\"#000080\">$&</font></I>)"
                              "(?3<font color=\"#0000A0\">$&</font>)"
                              "(?4<font color=\"#0000FF\">$&</font>)"
                              "(?5<B>$&</B>)";

   const char* header_text = 
      "<HTML>\n<HEAD>\n"
      "<TITLE>Auto-generated html formated source</TITLE>\n"
      "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=windows-1252\">\n"
      "</HEAD>\n"
      "<BODY LINK=\"#0000ff\" VLINK=\"#800080\" BGCOLOR=\"#ffffff\">\n"
      "<P> </P>\n<PRE>";

   const char* footer_text = "</PRE>\n</BODY>\n\n";
         

[endsect]


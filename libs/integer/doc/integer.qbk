[article Boost.Integer
    [quickbook 1.5]
    [copyright 2001-2009 Beman Dawes, Daryle Walker, Gennaro Prota, John Maddock]
    [purpose Integer Type Selection]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [Dawes, Beman], [Walker, Daryle], [Prota, Gennaro], [Maddock, John]]
    [/last-revision $Date: 2008-02-21 12:58:15 +0000 (Thu, 21 Feb 2008) $]
]

[template super[x]'''<superscript>'''[x]'''</superscript>''']

[section:overview Overview 简介]

Boost.Integer provides integer type support, particularly helpful in generic programming.  It provides standard 
C99 integer types, such as might be found in <stdint.h>, without requiring that header.  
It provides the means to select an integer type based upon its properties, like the number of bits or 
the maximum supported value, as well as compile-time bit mask selection.  There is a derivative of
std::numeric_limits that provides integral constant expressions for `min` and `max`.  
Finally, it provides two compile-time algorithms: determining the highest power of two in a 
compile-time value; and computing min and max of constant expressions.\n
Boost.Integer 提供了整数类型的支持，在泛型编程中特别有帮助。它提供了标准的C99整数类型，即 <stdint.h> 中的类型，而不需要那个头文件。
它提供了基于整数的特性来选择某个整数类型的能力，如基于二进制位数或可支持的最大值，以及编译期的位掩码选定。
还有了一个 std::numeric_limits 的洐生物，为 `min` 和 `max` 提供整型常量表达式。最后，它提供了两个编译期算法：
用编译期值来确定2的最高幂次；以及计算某个常量表达式的 min 和 max。

[table 
   [[Component 组件][Header 头文件][Purpose 目的]]
   [
      [Forward Declarations.\n
      前向声明]
      [[^[@../../../../boost/integer_fwd.hpp <boost/integer_fwd.hpp>]]]
      [Forward declarations of classes and class templates - for use when just the name of a class is needed.\n
      类与类模板的前向声明 - 在只需要类名时使用]
   ]
   [
      [[link boost_integer.cstdint Standard Integer Types\n
      标准整数类型].]
      [[^[@../../../../boost/cstdint.hpp <boost/cstdint.hpp>]]]
      [Provides typedef's based on the 1999 C Standard header `<stdint.h>`, wrapped in namespace boost. 
      This implementation may #include the compiler supplied `<stdint.h>`, if present.\n
      提供基于 1999 C 标准头文件 <stdint.h> 的typedef, 包装在名字空间 boost 中。可能 #include 编译器提供的 <stdint.h>, 如果有的话。]
   ]
   [
      [[link boost_integer.traits Integer Traits].]
      [[^[@../../../../boost/integer_traits.hpp <boost/integer_traits.hpp>]]]
      [Class template [^boost::integer_traits], derives from [^std::numeric_limits] and adds [^const_min] and [^const_max] members.\n
      类模板 [^boost::integer_traits], 派生自 [^std::numeric_limits] 并增加了 [^const_min] 和 [^const_max] 成员。]
   ]
   [
      [[link boost_integer.integer Integer Type Selection\n
      整数类型选择].]
      [[^[@../../../../boost/hpp <boost/integer.hpp>]]]
      [Templates for integer type selection based on properties such as maximum value or number of bits: 
      Use to select the type of an integer when some property such as maximum value or number of bits is known. 
      Useful for generic programming. \n
      基于最大值或二进制位数等特性来选择整数类型的模板：用于在知道某些特性如最大值或位数时，选择某个整数类型。对于泛型编程非常有用。]
   ]
   [
      [[link boost_integer.mask Integer Masks].]
      [[^[@../../../../boost/integer/integer_mask.hpp <boost/integer/integer_mask.hpp>]]]
      [Templates for the selection of integer masks, single or lowest group, based on the number of bits: 
      Use to select a particular mask when the bit position(s) are based on a compile-time variable. Useful for generic programming. \n
      基于二进制位数选择整数的单个或最低位元组 mask 的模板：用于在位元位置由编译期变量确定的情况下，选择特定的 mask. 
      对于泛型编程非常有用。]
   ]
   [
      [[link boost_integer.log2 Compile time log2 Calculation\n
      编译期的 log2 计算].]
      [[^[@../../../../boost/integer/static_log2.hpp <boost/integer/static_log2.hpp>]]]
      [Template for finding the highest power of two in a number: 
      Use to find the bit-size/range based on a maximum value. Useful for generic programming. \n
      用于在某个数字之内查找最大的2的整数幂的模板：基于某个最大值查找位元数/范围。对于泛型编程非常有用。]
   ]
   [
      [[link boost_integer.minmax Compile time min/max calculation\n
      编译期的 min/max 计算].]
      [[^[@../../../../boost/integer/static_min_max.hpp <boost/integer/static_min_max.hpp>]]]
      [Templates for finding the extrema of two numbers: 
      Use to find a bound based on a minimum or maximum value. Useful for generic programming. \n
      用于查找两个数字的最大最小值的模板：用于查找最小或最大值。对于泛型编程非常有用。]
   ]
]

[endsect]

[section:cstdint Standard Integer Types 标准整数类型]

[section:overview Overview 简介]

The header [^[@../../../../boost/cstdint.hpp <boost/cstdint.hpp>]] provides the typedef's useful 
for writing portable code that requires certain integer widths. All typedef's are in namespace boost.\n
头文件 [^[@../../../../boost/cstdint.hpp <boost/cstdint.hpp>]] 提供了用于编写要求指定整数宽度的可移植代码的 typedef. 
所有 typedef 均位于名字空间 boost.

The specifications for these types are based on the ISO/IEC 9899:1999 C Language standard header <stdint.h>.  
The 64-bit types required by the C standard are ['not required] in the boost header, 
and may not be supplied for all platforms/compilers, because [^long long] is not [yet] included in the C++ standard.\n
本规范是基于 ISO/IEC 9899:1999 C 语言标准的头文件 <stdint.h> 的。C标准所要求的64位类型在 boost 头文件中['并不要求]，
也可能不被实现支持，因为 [^long long] ['还未]被包含在 C++ 标准中。

See [@../../test/cstdint_test.cpp cstdint_test.cpp] for a test program.\n
测试程序请见 [@../../test/cstdint_test.cpp cstdint_test.cpp].

[endsect]

[section:rationale Rationale 原理]

The organization of the Boost.Integer headers and classes is designed to take advantage of <stdint.h> types from the 
1999 C standard without causing undefined behavior in terms of the 1998 C++ standard. 
The header <boost/cstdint.hpp> makes the standard integer types safely available in namespace [^boost] 
without placing any names in namespace [^std]. The intension is to complement rather than compete 
with the C++ Standard Library. Should some future C++ standard include <stdint.h> and <cstdint>, 
then <boost/cstdint.hpp> will continue to function, but will become redundant and may be safely deprecated.\n
Boost.Integer 头文件和类的组织结构在设计上利用了来自 1999 C 标准的 <stdint.h> 类型，而没有采用 1998 C++ 标准的未定义行为。
头文件 <boost/cstdint.hpp> 使得标准的整数类型安全地位于名字空间 [^boost] 中，没有往名字空间 [^std] 中增加任何东西。
目的是要对C++标准库作出补充，而不是与之竞争。如果将来的C++标准包含了 <stdint.h> 和 <cstdint>, 则 <boost/cstdint.hpp> 仍可使用，
不过那时就是多余的了，可以被安全地去掉。

Because these are boost headers, their names conform to boost header naming conventions rather than 
C++ Standard Library header naming conventions.\n
由于这些是 boost 头文件，所以它们的名字遵照 boost 头文件命名规则，而不是 C++ 标准库头文件的命名规则。

[endsect]

[section:ce ['Caveat emptor 需要小心的]]

As an implementation artifact, certain C <limits.h> macro names may possibly be 
visible to users of <boost/cstdint.hpp>. Don't use these macros; they are not part of 
any Boost-specified interface. Use [^boost::integer_traits<>] or [^std::numeric_limits<>] instead.\n
由于实现的原因，某些 C <limits.h> 宏名字可能会被 <boost/cstdint.hpp> 的用户看到。不要使用这些宏；它们不属于 Boost-规范接口中的部分。
请使用 [^boost::integer_traits<>] 或 [^std::numeric_limits<>] 来代替。

As another implementation artifact, certain C <stdint.h> typedef names may possibly be visible 
in the global namespace to users of <boost/cstdint.hpp>. Don't use these names, they are not part of 
any Boost-specified interface. Use the respective names in namespace [^boost] instead.\n
由于实现的原因，某些 C <stdint.h> typedef 名字可能会被 <boost/cstdint.hpp> 的用户在全局名字空间中看到。
不要使用这些名字，它们不属于 Boost-规范接口中的部分。请使用名字空间 [^boost] 中的相应名字代替。

[endsect]

[section:exact_width_integer_types Exact-width integer types 精确宽度的整数类型]

The typedef [^int#_t], with # replaced by the width, designates a signed integer type of exactly # bits; 
for example [^int8_t] denotes an 8-bit signed integer type.  Similarly, the typedef [^uint#_t] designates an unsigned 
integer type of exactly # bits.\n
typedef [^int#_t], 其中 # 代表宽度，表示一个宽度恰好为 # 位的有符号整数类型；如 [^int8_t] 表示8-位的有符号整数类型。
同样，typedef [^uint#_t] 表示一个宽度恰好为 # 位的无符号整数类型。

These types are optional. However, if a platform supports integer types with widths of 
8, 16, 32, 64, or any combination thereof, then <boost/cstdint.hpp> does provide the 
corresponding typedefs.\n
这些类型是可选的。不过，如果一个平台支持宽度为 8, 16, 32, 64 或其它组合位数的整数类型，则 <boost/cstdint.hpp> 就会提供相应的 typedef.

The absence of int64_t and uint64_t is indicated by the macro `BOOST_NO_INT64_T`.\n
宏 `BOOST_NO_INT64_T` 表示缺少 int64_t 和 uint64_t.

[endsect] 

[section:minimum_width_integer_types Minimum-width integer types 最小宽度的整数类型]

The typedef [^int_least#_t], with # replaced by the width,  designates a signed integer type with a width 
of at least # bits, such that no signed integer type with lesser size has at least the specified width. 
Thus, [^int_least32_t] denotes the smallest signed integer type with a width of at least 32 bits. 
Similarly, the typedef name [^uint_least#_t] designates an unsigned integer type with a width of at least # bits, 
such that no unsigned integer type with lesser size has at least the specified width.\n
typedef [^int_least#_t], 其中 # 代表宽度，表示一个宽度至少为 # 位的有符号整数类型，且没有位数更少的有符号整数类型至少具有给定的宽度。
因此，[^int_least32_t] 表示一个至少32位的有符号整数类型。同样，typedef [^uint_least#_t] 表示一个宽度至少为 # 位的无符号整数类型，
且没有位数更少的无符号整数类型至少具有给定的宽度。

The following minimum-width integer types are provided for all platforms:\n
以下最小宽度整数类型在所有平台上均提供：

* [^int_least8_t]
* [^int_least16_t]
* [^int_least32_t]
* [^uint_least8_t]
* [^uint_least16_t]
* [^uint_least32_t]

The following types are available only if, after including <boost/cstdint.hpp>, the macro BOOST_NO_INT64_T is not defined:\n
以下类型则仅当包含了 <boost/cstdint.hpp> 且未定义 BOOST_NO_INT64_T 宏时可用：

* [^int_least64_t]
* [^uint_least64_t]


All other minimum-width integer types are optional.\n
其它所有最小宽度整数类型都是可选的。

[endsect] 

[section:fastest_minimum_width_integer_types Fastest minimum-width integer types 最快最小宽度整数类型]

The typedef [^int_fast#_t], with # replaced by the width, designates the fastest signed integer type 
with a width of at least # bits. Similarly, the typedef name [^uint_fast#_t] designates the fastest 
unsigned integer type with a width of at least # bits.\n
typedef [^int_fast#_t], 其中 # 代表宽度，表示宽度至少为 # 位的且速度最快的有符号整数类型。
同样 typedef [^uint_fast#_t] 表示宽度至少为 # 位的且速度最快的无符号整数类型。

There is no guarantee that these types are fastest for all purposes.  In any case, however, they satisfy  
the signedness and width requirements.\n
不能保证这些类型对于所有用途都是最快的。不过在任何情况下，它们都满足符号和宽度的要求。

The following fastest minimum-width integer types are provided for all platforms:\n
以下最快最小宽度整数类型在所有平台上均提供：

* [^int_fast8_t]
* [^int_fast16_t]
* [^int_fast32_t]
* [^uint_fast8_t]
* [^uint_fast16_t]
* [^uint_fast32_t]

The following types are available only if, after including <boost/cstdint.hpp>, the macro BOOST_NO_INT64_T is not defined:\n
以下类型则仅当包含了 <boost/cstdint.hpp> 且未定义 BOOST_NO_INT64_T 宏时可用：

* [^int_fast64_t]
* [^uint_fast64_t]

All other fastest minimum-width integer types are optional.\n
其它所有最快最小宽度整数类型都是可选的。

[endsect] 

[section:greatest_width_integer_types Greatest-width integer types 最大宽度整数类型]

The typedef [^intmax_t ]designates a signed integer type capable of representing any value of any signed integer type.\n
typedef [^intmax_t] 表示一个有符号整数类型，它可以表示任意有符号整数类型的值。

The typedef [^uintmax_t] designates an unsigned integer type capable of representing any value of any unsigned integer type.\n
typedef [^uintmax_t] 表示一个无符号整数类型，它可以表示任意无符号整数类型的值。

These types are provided for all platforms.\n
这两个类型在所有平台上均提供。

[endsect]

[section:integer_constant_macros Integer Constant Macros 整数常量宏]

The following macros are always defined after inclusion of this header, these allow
integer constants of at least the specified width to be declared:  
INT8_C, UINT8_C, INT16_C, UINT16_C, INT32_C, UINT32_C, INTMAX_C, UINTMAX_C.\n
以下宏在包含了本头文件后将被定义，它们声明了至少具有指定宽度的各个整数常量：
INT8_C, UINT8_C, INT16_C, UINT16_C, INT32_C, UINT32_C, INTMAX_C, UINTMAX_C.

The macros INT64_C and UINT64_C are also defined if the the macro BOOST_NO_INT64_T is not defined.\n
宏 INT64_C 和 UINT64_C 也会被定义，如果宏 BOOST_NO_INT64_T 未定义。

The C99 macro __STDC_CONSTANT_MACROS is also defined as an artifact of the implementation.\n
C99宏 __STDC_CONSTANT_MACROS 也会依实现定义。

For example:\n
例如：

   #include <boost/cstdint.hpp>
   
   // Here the constant 0x1FFFFFFFF has the correct suffix applied:
   // 以下常量 0x1FFFFFFFF 将被赋以正确的后缀：
   static const boost::uint64_t c = INT64_C(0x1FFFFFFFF); 

[endsect]

[endsect]

[section:traits Integer Traits]

[section:motivation Motivation 动机]

The C++ Standard Library <limits> header supplies a class template `numeric_limits<>` with specializations for each fundamental type.\n
C++ 标准库的 <limits> 头文件提供了一个类模板 `numeric_limits<>`，它对每种基本类型进行了特化。

For integer types, the interesting members of `std::numeric_limits<>` are: \n
对于整数类型，要关注的 `std::numeric_limits<>` 成员有：

   static const bool is_specialized;      // Will be true for integer types. 对于整数类型为true。
   static T min() throw();                // Smallest representable value. 可表示的最小值。
   static T max() throw();                // Largest representable value. 可表示的最大值。
   static const int digits;               // For integers, the number of value bits. 对于整数，为二进制位数。
   static const int digits10;             // The number of base 10 digits that can be represented. 可表示的十进制位数。
   static const bool is_signed;           // True if the type is signed. 如果类型带符号则为true。
   static const bool is_integer;          // Will be true for all integer types. 对所有整数类型为true。

For many uses, these are sufficient. 
But min() and max() are problematical because they are not constant expressions (std::5.19), 
yet some usages require constant expressions. \n
对于多数应用为说，这些已经足够了。但是对于 min() 和 max() 就有问题，因为它们不是常量表达式(std::5.19)，还有一些应用也需要常量表达式。

The template class [^integer_traits] addresses this problem. \n
类模板 [^integer_traits] 解决了这个问题。

[endsect] 

[section:synopsis Synopsis 摘要]

   namespace boost {
     template<class T>
     class integer_traits : public std::numeric_limits<T>
     {
     public:
        static const bool is_integral = false;
        //
        // These members are defined only if T is a built-in
        // integal type:
        // 以下成员仅当T为内建整数类型时被定义
        //
        static const T const_min = ``['implementation-defined]``;
        static const T const_max = ``['implementation-defined]``;
     };
   }

[endsect] 

[section:description Description 说明]

Template class [^integer_traits] is derived from [^std::numeric_limits]. The primary specialization adds the single 
[^bool] member [^is_integral] with the compile-time constant value [^false]. 
However, for all integral types [^T] (std::3.9.1/7 [basic.fundamental]), there are specializations 
provided with the following compile-time constants defined: \n
类模板 [^integer_traits] 派生自 [^std::numeric_limits]. 对于主模板，它增加了单个 [^bool] 成员 [^is_integral]，具有编译期常量值 [^false]. 
不过，对于所有整数类型 [^T] (std::3.9.1/7 [basic.fundamental]), 都提供了特化版本，定义了以下编译期常量：

[table 
   [[member 成员][type 类型][value 值]]
   [[[^is_integral]][bool][[^true]]]
   [[[^const_min]][[^T]][equivalent to [^std::numeric_limits<T>::min()]\n
   相当于 [^std::numeric_limits<T>::min()]]]
   [[[^const_max]][[^T]][equivalent to [^std::numeric_limits<T>::max()]\n
   相当于 [^std::numeric_limits<T>::max()]]]
]

Note: The /is_integral/ flag is provided, because a user-defined integer class should specialize 
[^std::numeric_limits<>::is_integer = true], while compile-time constants 
[^const_min] and [^const_max] are not provided for that user-defined class, unless boost::integer_traits is also specialized. \n
注意：这里提供了一个标志 /is_integral/, 因为虽然用户自定义的整数类会特化 [^std::numeric_limits<>::is_integer = true], 
但是对于用户自定义类，编译期常量 [^const_min] 和 [^const_max] 仍然是没有提供的。

[endsect] 

[section:test_program Test Program 测试程序]

The program [^[@../../test/integer_traits_test.cpp integer_traits_test.cpp]] exercises the [^integer_traits] class. \n
程序 [^[@../../test/integer_traits_test.cpp integer_traits_test.cpp]] 检验了 [^integer_traits] 类。

[endsect] 

[section:acknowledgements Acknowledgements 鸣谢]

Beman Dawes, Ed Brey, Steve Cleary, and Nathan Myers discussed the integer traits idea on the boost mailing list in August 1999.

[endsect]
[endsect]

[section:integer Integer Type Selection 整数类型选择]

The [@../../../../boost/integer.hpp <boost/integer.hpp>] type selection templates allow 
integer types to be selected based on desired characteristics such as number of bits or maximum value. 
This facility is particularly useful for solving generic programming problems.\n
[@../../../../boost/integer.hpp <boost/integer.hpp>] 的类型选择模板可以基于特定的属性，如位数或最大值，选择相应的整数类型。
在解决泛型编程的问题时，这一工具特别有用。

[section:synopsis Synopsis 摘要]

   namespace boost
   {
     //  fast integers from least integers 从最小整数得到快速整数
     template<typename LeastInt>
     struct int_fast_t
     {
         typedef ``['implementation-defined-type]``  type;
     };

     //  signed 有符号的
     template<int Bits>
     struct int_t 
     {
         /* Member exact may or may not be defined depending upon Bits */
         typedef ``['implementation-defined-type]``  exact;
         typedef ``['implementation-defined-type]``  least;
         typedef int_fast_t<least>::fast      fast;
     };

     //  unsigned 无符号的
     template<int Bits>
     struct uint_t 
     {
         /* Member exact may or may not be defined depending upon Bits */
         typedef ``['implementation-defined-type]``  exact;
         typedef ``['implementation-defined-type]``  least;
         typedef int_fast_t<least>::fast      fast;
     };

     //  signed 有符号的
     template<long long MaxValue>
     struct int_max_value_t 
     {
         typedef ``['implementation-defined-type]``  least;
         typedef int_fast_t<least>::fast      fast;
     };

     template<long long MinValue>
     struct int_min_value_t 
     {
         typedef ``['implementation-defined-type]``  least;
         typedef int_fast_t<least>::fast      fast;
     };

     //  unsigned 无符号的
     template<unsigned long long Value>
     struct uint_value_t 
     {
         typedef ``['implementation-defined-type]``  least;
         typedef int_fast_t<least>::fast      fast;
     };
   } // namespace boost

[endsect]

[section:easiest Easiest-to-Manipulate Types 最容易操作的类型]

The [^int_fast_t] class template maps its input type to the next-largest type that the processor 
can manipulate the easiest, or to itself if the input type is already an easy-to-manipulate type. 
For instance, processing a bunch of [^char] objects may go faster if they were converted to [^int] objects before processing. 
The input type, passed as the only template parameter, must be a built-in integral type, except [^bool]. 
Unsigned integral types can be used, as well as signed integral types. 
The output type is given as the nested type [^fast].\n
[^int_fast_t] 类模板将它的输入类型映射为处理器最容易操作的稍大的类型，或者如果输入类型已经是易于操作的就返回它本身。
例如，在处理一串 [^char] 时，如果先将它们转换为 [^int] 则会处理得更快。唯一的模板参数，即输入类型，必须是除了 [^bool] 
以外的内建整数类型。可以象有符号整数类型一样使用无符号整数类型。输出类型由类成员 [^fast] 给出。

[*Implementation Notes 实现说明:] 
By default, the output type is identical to the input type. Eventually, this code's implementation should 
be customized for each platform to give accurate mappings between the built-in types and the easiest-to-manipulate 
built-in types. Also, there is no guarantee that the output type actually is easier to manipulate than the input type.\n
缺省地，输出类型等同于输入类型。最后，该代码的实现要对每个平台进行特化，在内建类型和最易操作类型之间给出精确的映射。
此外，并不保证输出类型确实比输入类型更容易操作。

[endsect]

[section:sized Sized Types 指定大小的类型]

The [^int_t], [^uint_t], [^int_max_value_t], [^int_min_value_t], and [^uint_value_t] class templates find 
the most appropiate built-in integral type for the given template parameter. This type is given by the 
nested type [^least]. The easiest-to-manipulate version of that type is given by the nested type [^fast]. 
The following table describes each template's criteria.\n
[^int_t], [^uint_t], [^int_max_value_t], [^int_min_value_t], 和 [^uint_value_t] 类模板根据给定的模板参数查找最合适的内建整数类型。
该类型由类成员 [^least] 给出。该类型的最易操作类型由类成员 [^fast] 给出。下表描述了各个模板的标准。

[table Criteria for the Sized Type Class Templates 固定大小类型的类模板标准
   [
      [Class Template 类模板][Template Parameter Mapping 模板参数映射]
   ]
   [
      [[^boost::int_t<N>::least]]
      [The smallest, built-in, signed integral type with at least /N/ bits, including the sign bit. 
      The parameter should be a positive number. A compile-time error results if the parameter is 
      larger than the number of bits in the largest integer type.\n
      至少具有 /N/ 位数的最小内建有符号整数类型，给定位数包含符号位。模板参数应为一个正数。
      如果参数大于最大整数类型的位数，将导致编译错误。]
   ]
   [
      [[^boost::int_t<N>::fast]]
      [The easiest-to-manipulate, built-in, signed integral type with at least /N/ bits, including the sign bit. 
      The parameter should be a positive number. A compile-time error results if the parameter is 
      larger than the number of bits in the largest integer type.\n
      至少具有 /N/ 位数的最易操作的内建有符号整数类型，给定位数包含符号位。模板参数应为一个正数。
      如果参数大于最大整数类型的位数，将导致编译错误。]
   ]
   [
      [[^boost::int_t<N>::exact]]
      [A built-in, signed integral type with exactly /N/ bits, including the sign bit. 
      The parameter should be a positive number.  Note that the member /exact/ is defined
      [*only] if there exists a type with exactly /N/ bits.\n
      恰好具有 /N/ 位数的最小内建有符号整数类型，给定位数包含符号位。模板参数应为一个正数。
      注意，成员 /exact/ [*仅]当存在一个恰好为 /N/ 位的类型时被定义。]
   ]
   [
      [[^boost::uint_t<N>::least]]
      [The smallest, built-in, unsigned integral type with at least /N/ bits. 
      The parameter should be a positive number. A compile-time error results if the 
      parameter is larger than the number of bits in the largest integer type.\n
      至少具有 /N/ 位数的最小内建无符号整数类型。模板参数应为一个正数。如果参数大于最大整数类型的位数，将导致编译错误。]
   ]
   [
      [[^boost::uint_t<N>::fast]]
      [The easiest-to-manipulate, built-in, unsigned integral type with at least /N/ bits. 
      The parameter should be a positive number. A compile-time error results if the 
      parameter is larger than the number of bits in the largest integer type.\n
      至少具有 /N/ 位数的最易操作的内建无符号整数类型。模板参数应为一个正数。如果参数大于最大整数类型的位数，将导致编译错误。]
   ]
   [
      [[^boost::uint_t<N>::exact]]
      [A built-in, unsigned integral type with exactly /N/ bits. 
      The parameter should be a positive number. A compile-time error results if the 
      parameter is larger than the number of bits in the largest integer type.  
      Note that the member /exact/ is defined
      [*only] if there exists a type with exactly N bits.\n
      恰好具有 /N/ 位数的最小内建无符号整数类型。模板参数应为一个正数。如果参数大于最大整数类型的位数，将导致编译错误。
      注意，成员 /exact/ [*仅]当存在一个恰好为 /N/ 位的类型时被定义。]
   ]
   [
      [[^boost::int_max_value_t<V>::least]]
      [The smallest, built-in, signed integral type that can hold all the values in the inclusive range ['0 - V]. 
      The parameter should be a positive number.\n
      可以表示闭区间 ['0 - V] 中所有值的最小内建有符号整数类型。模板参数应为一个正数。]
   ]
   [
      [[^boost::int_max_value_t<V>::fast]]
      [The easiest-to-manipulate, built-in, signed integral type that can hold all the values in the inclusive range ['0 - V]. 
      The parameter should be a positive number.\n
      可以表示闭区间 ['0 - V] 中所有值的最易操作的内建有符号整数类型。模板参数应为一个正数。]
   ]
   [
      [[^boost::int_min_value_t<V>::least]]
      [The smallest, built-in, signed integral type that can hold all the values in the inclusive range ['V - 0]. 
      The parameter should be a negative number.\n
      可以表示闭区间 ['V - 0] 中所有值的最小内建有符号整数类型。模板参数应为一个正数。]
   ]
   [
      [[^boost::int_min_value_t<V>::fast]]
      [The easiest-to-manipulate, built-in, signed integral type that can hold all the values in the inclusive range ['V - 0]. 
      The parameter should be a negative number.\n
      可以表示闭区间 ['V - 0] 中所有值的最易操作的内建有符号整数类型。模板参数应为一个正数。]
   ]
   [
      [[^boost::uint_value_t<V>::least]]
      [The smallest, built-in, unsigned integral type that can hold all positive values
      up to and including /V/. The parameter should be a positive number.\n
      可以表示最大的 /V/ 的所有正值的最小内建无符号整数类型。模板参数应为一个正数。]
   ]
   [
      [[^boost::uint_value_t<V>::fast]]
      [The easiest-to-manipulate, built-in, unsigned integral type that can hold all positive values
      up to and including /V/. The parameter should be a positive number.\n
      可以表示最大的 /V/ 的所有正值的最易操作的内建无符号整数类型。模板参数应为一个正数。]
   ]
]

[endsect]

[section:example Example 例子]

   #include <boost/integer.hpp>

   //...

   int main()
   {
       boost::int_t<24>::least my_var;  // my_var has at least 24-bits  my_var为最少24位
       //...
       // This one is guarenteed not to be truncated:  保证不会被截断：
       boost::int_max_value_t<1000>::least my1000 = 1000;
       //...
       // This one is guarenteed not to be truncated, and as fast
       // to manipulate as possible, its size may be greater than
       // that of my1000:
       // 保证不会被截断，且可以尽可能快地操作，大小可能会大于my1000:
       boost::int_max_value_t<1000>::fast my_fast1000 = 1000;
   }

[endsect]

[section:demonstration_program Demonstration Program 示范程序]

The program [@../../test/integer_test.cpp integer_test.cpp] is a simplistic demonstration of the results from instantiating 
various examples of the sized type class templates.\n
程序 [@../../test/integer_test.cpp integer_test.cpp] 简单地示范了对各种 sized type 类模板的实例化结果。

[endsect]

[section:rationale Rationale 原理]

The rationale for the design of the templates in this header includes:\n
该头文件中的模板的设计原理包括：

* Avoid recursion because of concern about C++'s limited guaranteed recursion depth (17).\n
  避免递归，因为这关系到 C++ 对递归深度的限制(17). 
* Avoid macros on general principles.\n
  避免使用宏，因为众所周知的原因。
* Try to keep the design as simple as possible.\n
  使设计尽可能地简单。

[endsect]

[section:alternative Alternative 其它选择]

If the number of bits required is known beforehand, it may be more appropriate to use the types supplied 
in [@../../../../boost/cstdint.hpp <boost/cstdint.hpp>].\n
如果可以预先知道位数，则更适合使用 [@../../../../boost/cstdint.hpp <boost/cstdint.hpp>] 所提供的类型。

[endsect]

[section:credits Credits 鸣谢]

The author of most of the Boost integer type choosing templates is 
[@http://www.boost.org/people/beman_dawes.html Beman Dawes]. 
He gives thanks to Valentin Bonnard and [@http://www.boost.org/people/kevlin_henney.htm Kevlin Henney] 
for sharing their designs for similar templates. 
[@http://www.boost.org/people/daryle_walker.html Daryle Walker] designed the value-based sized templates.

[endsect]
[endsect]



[section:mask Integer Masks 整数位掩码模板]

[section:overview Overview 简介]

The class templates in [@../../../../boost/integer/integer_mask.hpp <boost/integer/integer_mask.hpp>] 
provide bit masks for a certain bit position or a contiguous-bit pack of a certain size. 
The types of the masking constants come from the [link boost_integer.integer integer type selection templates] header.\n
[@../../../../boost/integer/integer_mask.hpp <boost/integer/integer_mask.hpp>] 
中的类模板为特定的位元位置或特定大小的连续位元提供了位掩码。掩码常量的类型来自于 [link boost_integer.integer 整数类型选择模板] 头文件。

[endsect]

[section:synopsis Synopsis 摘要]

   #include <cstddef>  // for std::size_t

   namespace boost
   {

   template <std::size_t Bit>
   struct high_bit_mask_t
   {
       typedef ``['implementation-defined-type]``  least;
       typedef ``['implementation-defined-type]``  fast;

       static const least       high_bit       = ``['implementation-defined]``;
       static const fast        high_bit_fast  = ``['implementation-defined]``;

       static const std::size_t bit_position   = Bit;
   };

   template <std::size_t Bits>
   struct low_bits_mask_t
   {
       typedef ``['implementation-defined-type]``  least;
       typedef ``['implementation-defined-type]``  fast;

       static const least       sig_bits       = ``['implementation-defined]``;
       static const fast        sig_bits_fast  = ``['implementation-defined]``;

       static const std::size_t bit_count      = Bits;
   };

   // Specializations for low_bits_mask_t exist for certain bit counts.
   // 针对 low_bits_mask_t 的特化，用于特定的位数

   }  // namespace boost

[endsect] 

[section:single_bit_mask_class_template Single Bit-Mask Class Template 单位元掩码类模板]

The [^boost::high_bit_mask_t] class template provides constants for bit masks representing the bit at a 
certain position. The masks are equivalent to the value 2[super Bit], where [^Bit] is the template parameter. 
The bit position must be a nonnegative number from zero to ['Max], where Max is one less than the 
number of bits supported by the largest unsigned built-in integral type. The following table describes 
the members of an instantiation of [^high_bit_mask_t].\n
[^boost::high_bit_mask_t] 类模板提供了表示特定位置的单个位元的掩码常数。该掩码等于 2[super Bit], 其中 [^Bit] 为模板参数。
位元的位置必须是从零到 ['Max] 的非负数字，其中 Max 最大的内建无符号整数类型所支持的位数减一。下表描述了 [^high_bit_mask_t] 实例的成员。

[table Members of the `boost::high_bit_mask_t` Class Template  `boost::high_bit_mask_t`类模板的成员
   [[Member 成员][Meaning 意义]]
   [[[^least]][The smallest, unsigned, built-in type that supports the given bit position.\n
   支持给定位元位置的最小无符号内建类型。]]
   [[[^fast]][The easiest-to-manipulate analog of [^least].\n
   快速操作的 [^least] 类似物。]]
   [[[^high_bit]][A [^least] constant of the value 2[super Bit].\n
   值为 2[super Bit] 的 [^least] 常数值。]]
   [[[^high_bit_fast]][A [^fast] analog of [^high_bit].\n
   [^high_bit] 的 [^fast] 类似物。]]
   [[[^bit_position]][The value of the template parameter, in case its needed from a renamed instantiation of the class template.\n
   模板参数的值，可用于该类模板的改名实例。]]
]

[endsect] 

[section:group_bit_mask_class_template Group Bit-Mask Class Template 位元组掩码类模板]

The [^boost::low_bits_mask_t] class template provides constants for bit masks 
equivalent to the value (2[super Bits] - 1), where [^Bits] is the template parameter. 
The parameter [^Bits] must be a non-negative integer from 
zero to ['Max], where Max is the number of bits supported by the largest, unsigned, built-in integral type. 
The following table describes the members of [^low_bits_mask_t].\n
[^boost::low_bits_mask_t] 类模板提供了值为 (2[super Bits] - 1) 的掩码常数，其中 [^Bits] 为模板参数。
参数 [^Bits] 必须是从零到 ['Max] 的非负数字，其中 Max 最大的内建无符号整数类型所支持的位数。下表描述了 [^low_bits_mask_t] 实例的成员。

[table Members of the [^boost::low_bits_mask_t] Class Template  [^boost::low_bits_mask_t]类模板的成员
[[Member 成员][Meaning 意义]]
[[[^least]][The smallest, unsigned built-in type that supports the given bit count.\n
支持给定位元数的最小无符号内建类型]]
[[[^fast]][The easiest-to-manipulate analog of [^least].\n
快速操作的 [^least] 类似物]]
[[[^sig_bits]][A [^least] constant of the desired bit-masking value.\n
想要的位掩码值的 [^least] 常数值。]]
[[[^sig_bits_fast]][A [^fast] analog of [^sig_bits].\n
[^sig_bits] 的 [^fast] 类似物。]]
[[[^bit_count]][The value of the template parameter, in case its needed from a renamed instantiation of the class template.\n
模板参数的值，可用于该类模板的改名实例]]
]

[endsect]

[section:implementation_notes Implementation Notes 实现说明]

When [^Bits] is the exact size of a built-in unsigned type, the implementation has to change to 
prevent undefined behavior. Therefore, there are specializations of [^low_bits_mask_t] at those bit counts.\n
如果 [^Bits] 恰好为一个内建无符号类型的大小，该实现必须修改以防止未定义行为。因此，针对这些位元数对 [^low_bits_mask_t] 进行特化。

[endsect]

[section:example Example 例子]

   #include <boost/integer/integer_mask.hpp>

   //...

   int main()
   {
       typedef boost::high_bit_mask_t<29>  mask1_type;
       typedef boost::low_bits_mask_t<15>  mask2_type;

       mask1_type::least  my_var1;
       mask2_type::fast   my_var2;
       //...

       my_var1 |= mask1_type::high_bit;
       my_var2 &= mask2_type::sig_bits_fast;

       //...
   }

[endsect] 

[section:demonstration_program Demonstration Program 示范程序]

The program [@../../test/integer_mask_test.cpp integer_mask_test.cpp] is a simplistic demonstration of the 
results from instantiating various examples of the bit mask class templates.\n
程序 [@../../test/integer_mask_test.cpp integer_mask_test.cpp] 简单地示范了对各种位元掩码类模板例子的实例化结果。

[endsect] 

[section:rationale Rationale 原理]

The class templates in this header are an extension of the [link boost_integer.integer integer type selection class templates]. 
The new class templates provide the same sized types, but also convenient masks to use when extracting the 
highest or all the significant bits when the containing built-in type contains more bits. 
This prevents contamination of values by the higher, unused bits.\n
该头文件中的类模板是 [link boost_integer.integer 整数类型选择类模板] 的扩展。
新的类模板提供了相同大小但更方便的掩码，用于在所含内建类型包含更多位元时取出最高或所有重要位元。这防止了被更高位的无用位元污染。

[endsect] 

[section:credits Credits 鸣谢]

The author of the Boost bit mask class templates is [@http://www.boost.org/people/daryle_walker.html Daryle Walker].

[endsect]
[endsect]

[section:log2 Compile Time log2 Calculation 二进制对数模板]

The class template in [@../../../../boost/integer/static_log2.hpp <boost/integer/static_log2.hpp>] 
determines the position of the highest bit in a given value. This facility is useful for solving generic programming problems.\n
[@../../../../boost/integer/static_log2.hpp <boost/integer/static_log2.hpp>] 中的类模板用于确定一个给定值中最高位的位置。
该工具可用于解决泛型编程的问题。

[section:synopsis Synopsis 摘要]

   namespace boost
   {

     typedef ``['implementation-defined]`` static_log2_argument_type;
     typedef ``['implementation-defined]`` static_log2_result_type;

     template <static_log2_argument_type arg>
     struct static_log2
     {
       static const static_log2_result_type value = ``['implementation-defined]``;
     };


     template < >
     struct static_log2< 0 >
     {
       // The logarithm of zero is undefined. 零的对数无定义
     };


   }  // namespace boost

[endsect] 

[section:usage Usage 用法]

The [^boost::static_log2] class template takes one template parameter, a value of type 
[^static_log2_argument_type]. The template only defines one member, [^value], which gives the 
truncated, base-two logarithm of the template argument.\n
[^boost::static_log2] 类模板带一个模板参数，类型为 [^static_log2_argument_type] 的值。
该模板只定义了一个成员 [^value], 它给出了模板参数的幂2对数向下取整后的值。

Since the logarithm of zero, for any base, is undefined, there is a specialization of [^static_log2] 
for a template argument of zero. This specialization has no members, so an attempt to use the base-two 
logarithm of zero results in a compile-time error.\n
由于零对于任何基数的对数都是无定义的，所以 [^static_log2] 有一个模板参数为零的特化。
该特化版没有成员，因此试图使用零的对数将引发一个编译期错误。

Note: \n
注：

* [^static_log2_argument_type] is an ['unsigned integer type] (C++ standard, 3.9.1p3).\n
  [^static_log2_argument_type] 是一个 ['无符号整数类型] (C++ 标准，3.9.1p3). 
* [^static_log2_result_type] is an ['integer type] (C++ standard, 3.9.1p7).\n
  [^static_log2_result_type] 是一个 ['整数类型] (C++ 标准，3.9.1p7). 

[endsect] 

[section:demonstration_program Demonstration Program 示例程序]

The program [@../../test/static_log2_test.cpp static_log2_test.cpp] is a simplistic 
demonstration of the results from instantiating various examples of the binary logarithm class template.\n
程序 [@../../test/static_log2_test.cpp static_log2_test.cpp] 简单地示范了对多个二进制对数类模板例子的实例化结果。

[endsect]

[section:rationale Rationale 原理]

The base-two (binary) logarithm, abbreviated lb, function is occasionally used to give order-estimates 
of computer algorithms. The truncated logarithm can be considered the highest power-of-two in a value, 
which corresponds to the value's highest set bit (for binary integers). Sometimes the highest-bit position 
could be used in generic programming, which requires the position to be available statically (['i.e.] at compile-time).\n
底数为二的(二进制)对数函数，缩写为 lb, 有时候被用于给出计算机算法的阶数估算(order-estimates)。
向下取整后的对数可被视为一个值中的最高的2的幂，对应于该值的最高一个被置位的位(对于二进制整数)。
有时这个最高位元的位置可以用于泛型编程，它要求该位置是静态(['即]在编译期)可用的。

[endsect] 

[section:credits Credits 鸣谢]

The original version of the Boost binary logarithm class template was 
written by [@http://www.boost.org/people/daryle_walker.html Daryle Walker] and then 
enhanced by Giovanni Bajo with support for compilers without partial template specialization. 
The current version was suggested, together with a reference implementation, by Vesa Karvonen. 
Gennaro Prota wrote the actual source file.

[endsect]
[endsect]

[section:minmax Compile time min/max calculation 编译期min/max模板]

The class templates in [@../../../../boost/integer/static_min_max.hpp <boost/integer/static_min_max.hpp>] 
provide a compile-time evaluation of the minimum or maximum of two integers. These facilities are useful 
for generic programming problems.\n
[@../../../../boost/integer/static_min_max.hpp <boost/integer/static_min_max.hpp>] 
中的类模板提供了在编译期计算两个整数的最小或最大值的方法。在解决泛型编程的问题时，这一工具特别有用。

[section:synopsis Synopsis 摘要]

   namespace boost
   {
   
   typedef ``['implementation-defined]`` static_min_max_signed_type;
   typedef ``['implementation-defined]`` static_min_max_unsigned_type;

   template <static_min_max_signed_type Value1, static_min_max_signed_type Value2 >
       struct static_signed_min;

   template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
       struct static_signed_max;

   template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
       struct static_unsigned_min;

   template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
       struct static_unsigned_max;

   }

[endsect] 

[section:usage Usage 用法]

The four class templates provide the combinations for finding the minimum or maximum of two [^signed] or 
[^unsigned] ([^long]) parameters, /Value1/ and /Value2/, at compile-time. Each template has a single static data member, 
[^value], which is set to the respective minimum or maximum of the template's parameters.\n
以上四个类模板提供了在编译期查找两个 [^signed] 或 [^unsigned] ([^long])参数的最小或最大值的方法，这两个参数分别为 /Value1/ 和 /Value2/. 
每个模板有一个静态数据成员 [^value], 它分别被设置为模板参数的最小或最大值。

[endsect] 

[section:example Example 例子]

   #include <boost/integer/static_min_max.hpp>

   template < unsigned long AddendSize1, unsigned long AddendSize2 >
   class adder
   {
   public:
       static  unsigned long  const  addend1_size = AddendSize1;
       static  unsigned long  const  addend2_size = AddendSize2;
       static  unsigned long  const  sum_size = boost::static_unsigned_max<AddendSize1, AddendSize2>::value + 1;

       typedef int  addend1_type[ addend1_size ];
       typedef int  addend2_type[ addend2_size ];
       typedef int  sum_type[ sum_size ];

       void  operator ()( addend1_type const &a1, addend2_type const &a2, sum_type &s ) const;
   };

   //...

   int main()
   {
       int const   a1[] = { 0, 4, 3 };  // 340
       int const   a2[] = { 9, 8 };     //  89
       int         s[ 4 ];
       adder<3,2>  obj;

       obj( a1, a2, s );  // 's' should be 429 or { 9, 2, 4, 0 }
       //...
   }

[endsect]

[section:demonstration_program Demonstration Program 示范程序]

The program [@../../test/static_min_max_test.cpp static_min_max_test.cpp] is a simplistic demonstration of 
various comparisons using the compile-time extrema class templates.\n
程序 [@../../test/static_min_max_test.cpp static_min_max_test.cpp] 是一个简单的示范，使用编译器界限类模板进行了多次比较。

[endsect] 

[section:rationale Rationale 原理]

Sometimes the minimum or maximum of several values needs to be found for later compile-time processing, 
['e.g.] for a bound for another class template.\n
有时需要为后续的编译期处理，['如]另一个类模板的界限，而计算多个值的最小或最大值。

[endsect]

[section:credits Credits 鸣谢]

The author of the Boost compile-time extrema class templates is [@http://www.boost.org/people/daryle_walker.html Daryle Walker].

[endsect]
[endsect]

[section:history History 历史]

[h4 1.42.0]

* Reverted Trunk to release branch state (i.e. a "known good state").\n
  将主干版本恢复为发布分支状态(即"已知可用的状态")。
* Fixed issues: [@https://svn.boost.org/trac/boost/ticket/653 653], 
[@https://svn.boost.org/trac/boost/ticket/3084 3084], 
[@https://svn.boost.org/trac/boost/ticket/3177 3177], 
[@https://svn.boost.org/trac/boost/ticket/3180 3180], 
[@https://svn.boost.org/trac/boost/ticket/3548 3568], 
[@https://svn.boost.org/trac/boost/ticket/3657 3657], 
[@https://svn.boost.org/trac/boost/ticket/2134 2134].\n
修复问题：[@https://svn.boost.org/trac/boost/ticket/653 653], 
[@https://svn.boost.org/trac/boost/ticket/3084 3084], 
[@https://svn.boost.org/trac/boost/ticket/3177 3177], 
[@https://svn.boost.org/trac/boost/ticket/3180 3180], 
[@https://svn.boost.org/trac/boost/ticket/3548 3568], 
[@https://svn.boost.org/trac/boost/ticket/3657 3657], 
[@https://svn.boost.org/trac/boost/ticket/2134 2134].
* Added long long support to [^boost::static_log2], [^boost::static_signed_min], [^boost::static_signed_max], 
[^boost::static_unsigned_min], [^boost::static_unsigned_max], when available.\n
为 [^boost::static_log2], [^boost::static_signed_min], [^boost::static_signed_max], [^boost::static_unsigned_min], 
[^boost::static_unsigned_max] 增加对 long long 的支持，在可能的情况下。
* The argument type and the result type of [^boost::static_signed_min] etc are now typedef'd. 
Formerly, they were hardcoded as [^unsigned long] and [^int] respectively. Please, use the 
provided typedefs in new code (and update old code as soon as possible).\n
[^boost::static_signed_min] 等的参数类型和结果类型现在是 typedef 的。以前，它们分别被硬编码为 ['unsigned long] 和 ['int]. 
请在新代码中使用所提供的 typedefs (并尽可能更新旧的代码)。

[h4 1.32.0]

* The argument type and the result type of [^boost::static_log2] are now typedef'd. 
Formerly, they were hardcoded as [^unsigned long] and [^int] respectively. Please, use the 
provided typedefs in new code (and update old code as soon as possible).\n
[^boost::static_log2] 的参数类型和结果类型现在是 typedef 的。以前，它们分别被硬编码为 ['unsigned long] 和 ['int]. 
请在新代码中使用所提供的 typedefs (并尽可能更新旧的代码)。

[endsect]


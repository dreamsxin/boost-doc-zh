<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Boost Macro Reference</title>

<link rel="stylesheet" href="../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="Boost.Config">
<link rel="up" href="../index.html" title="Boost.Config">
<link rel="prev" href="../index.html" title="Boost.Config">
<link rel="next" href="guidelines_for_boost_authors.html" title="Guidelines for Boost Authors"></head>
<body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="../index.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="guidelines_for_boost_authors.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a></div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="boost_config.boost_macro_reference"></a><a class="link" href="boost_macro_reference.html" title="Boost Macro Reference">Boost 宏参考</a>
</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_defects">描
述缺陷的宏</a></span></dt>
<dt><span class="section"><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_optional_features">描
述可选特性的宏</a></span></dt>
<dt><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_c__0x_features"><span class="section"></span></a><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_possible_c__0x_features">描
述可能的 C++0x 特性的宏</a></dt>
<dt><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_c__0x_features"><span class="section"></span></a><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_c__0x_features_not_supported">描
述不被支持的 C++0x 特性的宏</a></dt>
<dt><span class="section"><a href="boost_macro_reference.html#boost_config.boost_macro_reference.boost_helper_macros">Boost
辅助宏</a></span></dt>
<dt><span class="section"><a href="boost_macro_reference.html#boost_config.boost_macro_reference.boost_informational_macros">Boost
信息宏</a></span></dt>
<dt><span class="section"><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code">用
于分隔源代码的宏</a></span></dt>
</dl>
</div>
<a name="config_defects"></a>
<p> </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_config.boost_macro_reference.macros_that_describe_defects"></a><a class="link" href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_defects" title="Macros that describe defects">描述缺陷的宏</a>
</h3>
</div>
</div>
</div>
<p>以下宏都是用于描述C++标准所要求的某个特性的，如果下面当中的某一个宏被定义，则表示该编译器存在一个与标准不符的缺陷。</p>
<div class="informaltable">
<table class="table">
<colgroup><col><col><col></colgroup> <thead><tr>
<th>
<p>宏 </p>
</th>
<th>
<p> 节 </p>
</th>
<th>
<p>说明 </p>
</th>
</tr>
</thead> <tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_BCB_PARTIAL_SPECIALIZATION_BUG</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器存在某些偏特化方面的缺陷 - 很可能是 Borland C++ Builder. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>如果在当前域中有对被查找符号的 using 声明，则ADL查找失败。例如，<code>using
boost::get_pointer;</code> 将阻止使用 ADL 在 boost
内部的名字空间中(但是可以在其它地方)查找 <code>get_pointer</code> 的重载。可能是
Borland 的特殊方式。 </p>
</td>
</tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_ADL_BARRIER</span></code>
</p>
</td>
<td> 编译器</td>
<td>
<p>编译器定位并查找那些在执行参数相关查找时实际上不应查找的名字空间。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器没有实现ADL(又称Koenig查找); 请见 std::3.4.2
[basic.koenig.lookup] </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_AUTO_PTR</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>如果编译器/标准库提供非标准或有问题的&nbsp; <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">auto_ptr</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_CTYPE_FUNCTIONS</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台不提供字符分类操作的函数 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">ctype</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>
和 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">cctype</span><span class="special">&gt;</span></code>,
只提供了相应的宏。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_CV_SPECIALIZATIONS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>如果针对cv-限定类型的模板特化与针对非cv-限定类型的特化冲突。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_CV_VOID_SPECIALIZATIONS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>如果针对cv-void类型的模板特化与针对void的特化冲突。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_CWCHAR</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台不提供&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">wchar</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>
和 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">cwchar</span><span class="special">&gt;</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_CWCTYPE</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台不提供 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">wctype</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code> 和 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">cwctype</span><span class="special">&gt;</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_DEPENDENT_NESTED_DERIVATIONS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不能编译带有受限基类的嵌套类：&nbsp; </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">:</span> <span class="special">{</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">bar</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">U</span> <span class="special">{};</span>
</pre>
<p> }; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>模板值参数不能为受限类型，例如：&nbsp; </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">::</span><span class="identifier">type</span> <span class="identifier">value</span><span class="special">&gt;</span> <br><span class="keyword">class</span> <span class="identifier">X</span> <span class="special">{</span> <span class="special">...</span> <span class="special">};</span>
</pre>
<p> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_EXCEPTION_STD_NAMESPACE</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库未将&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">exception</span><span class="special">&gt;</span></code>
的一些或全部内容置于名字空间 std 中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_EXCEPTIONS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不支持异常处理(多数嵌入式平台的C++编译器都要求这一设置)。注意，并不要求 boost
库一定要遵守这一配置设置 - 在某些情形下这样做是不可能的。遵守这一设置的库通常在发生严重错误时会退出 - 已经警告你了！ </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>在调用函数模板实例时只能使用被推导的模板参数。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_FUNCTION_TEMPLATE_ORDERING</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不执行函数模板分类(function template
ordering)或执行的方法不正确。&nbsp; </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="comment">// #1<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">);</span><br><span class="comment">// #2<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span><span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">(*)(</span><span class="identifier">U</span><span class="special">));</span><br><span class="keyword">void</span> <span class="identifier">bar</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span><br><span class="identifier">f</span><span class="special">(&amp;</span><span class="identifier">bar</span><span class="special">);</span> <span class="comment">// 应选择 #2.<br></span></pre>
<p> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_INCLASS_MEMBER_INITIALIZATION</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器违犯 std::9.4.2/4. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_INTRINSIC_WCHAR_T</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>C++实现不提供&nbsp;<code class="computeroutput"><span class="keyword">wchar_t</span></code>,
或者它只是另一个整型类型的别名。使用这一符号来决定在已经有一个针对该整型类型的特化时是否适合再定义针对&nbsp;<code class="computeroutput"><span class="keyword">wchar_t</span></code>
的特化。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_IOSFWD</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库缺少 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">iosfwd</span><span class="special">&gt;</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_IOSTREAM</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库缺少 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span></code>, <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">istream</span><span class="special">&gt;</span></code> 或 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">ostream</span><span class="special">&gt;</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_IS_ABSTRACT</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p> C++编译器不支持抽象类型的 SFINAE, 见 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#337">Core
Language DR337</a>, 不过它当前还未加入标准。幸好多数编译器支持 SFINAE 也支持这份 DR. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_LIMITS</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>C++实现不提供&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">limits</span><span class="special">&gt;</span></code>
头文件。在库代码中从不检查该符号；它总是包含&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">limits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>, 以保证提供 <code>std::numeric_limits</code>.&nbsp;
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>在编译期，象 <code class="computeroutput"><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">is_signed</span></code>
这样的常量不可用。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_LONG_LONG_NUMERIC_LIMITS</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>没有&nbsp;<code class="computeroutput"><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">long</span>
<span class="keyword">long</span><span class="special">&gt;</span></code>
和&nbsp;<code class="computeroutput"><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">unsigned</span>
<span class="keyword">long</span> <span class="keyword">long</span><span class="special">&gt;</span></code>
的特化。仅当编译器支持&nbsp;<code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
类型时，<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">limits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>&nbsp;会
将这两个特化作为标准库的"修正"。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不支持模板类的单独成员函数特化。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_MEMBER_TEMPLATE_KEYWORD</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>如果编译器支持成员模板，但是在访问成员模板类时不使用 template 关键字。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_MEMBER_TEMPLATE_FRIENDS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p> 不支持C++标准 14.5.3 所描述的成员模板友元语法 (<code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span>
<span class="identifier">P</span><span class="special">&gt;</span> <span class="keyword">friend</span> <span class="keyword">class</span>
<span class="identifier">frd</span><span class="special">;</span></code>) </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_MEMBER_TEMPLATES</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>不完全支持成员模板函数。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_MS_INT64_NUMERIC_LIMITS</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>没有&nbsp;<code class="computeroutput"><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">__int64</span><span class="special">&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">unsigned</span>
<span class="identifier">__int64</span><span class="special">&gt;</span></code>
的特化。仅当编译器支持&nbsp;<code class="computeroutput"><span class="identifier">__int64</span></code> 类型时，<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">limits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>&nbsp;会
将这两个特化作为标准库的"修正"。 </p>
</td>
</tr>
<tr><td><p><code class="computeroutput"><span class="identifier">BOOST_NO_NESTED_FRIENDSHIP</span></code> </p></td><td> 编译器</td><td><p>编译器不允许外层类访问其所包含的类的私有成员。可能专用于 Borland/CodeGear. </p></td></tr><tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_OPERATORS_IN_NAMESPACE</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器要求继承的操作符友元函数在名字空间域中定义，然后 using 给 boost. 可能是 GCC
的特殊方式。相关例子请见&nbsp;<a href="../../../../../boost/operators.hpp" target="_top"><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">operators</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code></a>.&nbsp;
</p>
</td>
</tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_PARTIAL_SPECIALIZATION_IMPLICIT_DEFAULT_ARGS</span></code>
</p>
</td>
<td> 编译器</td>
<td>
<p>编译器不能正确处理那些依赖于主模板中的缺省参数的偏特化。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_POINTER_TO_MEMBER_CONST</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不能正确处理常量成员函数的指针，要防止在重载函数模板时使用它们。相关例子请见&nbsp;<a href="../../../../../boost/functional.hpp" target="_top"><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">functional</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code></a>.&nbsp;
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_POINTER_TO_MEMBER_TEMPLATE_PARAMETERS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>成员指针不能作为模板参数使用。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_PRIVATE_IN_AGGREGATE</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器误读了 8.5.1, 将含私有或保护的成员函数的类视为 non-aggregate. </p>
</td>
</tr>
<tr><td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_RTTI</span></code> 
</p></td>
<td>
<p>编译器 </p></td>
<td>
<p>编译器可能有(或可能没有) typeid 操作符，但不支持一个对象的动态类型之上的 RTTI. </p></td></tr><tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_SFINAE</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不支持 "Substitution Failure Is Not An Error" 的元编程惯用法。 </p>
</td>
</tr>
<tr><td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_SFINAE_EXPR</span></code> </p></td>
<td>
<p>编译器 </p></td>
<td>
<p>编译器不支持带任意表达式的 SFINAE 用法。 
</p></td></tr><tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_ALLOCATOR</span></code>
</p>
</td>
<td>
<p> 标准库 </p>
</td>
<td>
<p>C++标准库没有提供符合标准的&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_DISTANCE</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>平台没有符合标准的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">distance</span></code> 版本。. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_ITERATOR</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>C++ 实现不提供&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator</span></code> 类。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_ITERATOR_TRAITS</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>编译器不提供符合标准的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator_traits</span></code>
实现。注意，编译器有可能提供非标准的实现。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_LOCALE</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_MESSAGES</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有符合标准的&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">messages</span></code> facet.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_MIN_MAX</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>C++标准库不提供&nbsp;<code class="computeroutput"><span class="identifier">min</span><span class="special">()</span></code>
和 <code class="computeroutput"><span class="identifier">max</span><span class="special">()</span></code>
模板函数，它们应该在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">algorithm</span><span class="special">&gt;</span></code>
中。&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_OUTPUT_ITERATOR_ASSIGN</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>如果标准库的输出迭代器不是可赋值的，就定义它。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_TYPEINFO</span></code>
</p>
</td>
<td>
<p> 标准库 </p>
</td>
<td>
<p> &lt;typeinfo&gt; 头文件将 <code class="computeroutput"><span class="identifier">type_info</span></code>
声明在全局名字空间而不是 namespace std. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_USE_FACET</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有符合标准的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">use_facet</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_WSTREAMBUF</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_streambuf</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span></code>
的实现，或者不完整，或者有缺陷。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STD_WSTRING</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STDC_NAMESPACE</span></code>
</p>
</td>
<td>
<p> 编译器,&nbsp;平台 </p>
</td>
<td>
<p>C++中的C库函数标准头文件(即&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">c</span><span class="special">...&gt;</span></code>
头文件)中的内容没有位于名字空间 std. 这个测试是很困难的 - 有些"假装"为标准C函数的库通过增加 using
声明来导入这些函数到名字空间 std, 不幸的是它们没有覆盖所有函数...&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_STRINGSTREAM</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>C++实现不提供&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">sstream</span><span class="special">&gt;</span></code> 头文件。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_SWPRINTF</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台没有符合标准的&nbsp; <code class="computeroutput"><span class="identifier">swprintf</span></code> 版本。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>不支持类模板偏特化(14.5.4 [temp.class.spec]). </p>
</td>
</tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_TEMPLATED_IOSTREAMS</span></code>
</p>
</td>
<td>标准库</td>
<td>
<p>标准库不提供模板化的 iostream 类。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有为容器提供模板化的迭代器结构函数。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_TEMPLATE_TEMPLATES</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不支持模板模板参数。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_TYPEID</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p> 编译器根本不支持 typeid 操作符。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_UNREACHABLE_RETURN_DETECTION</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>如果 return 语句不可到达，则不要求必须有 return
语句，但是有些编译器坚持要有，如果发生这种情形，会导致一串警告。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不接受用 using 声明将一个函数从基类的 typename
带入到派生类中，如果派生类中已经有同名的函数。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_USING_TEMPLATE</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不接受用 using 声明将一个模板类或模板函数从另一个名字空间导入。原本 Borland
存在导入到全局名字空间或从全局名字空间导入的问题，后来扩展以 MSVC6，它存在导入模板类(但不是模板函数)的问题。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_VOID_RETURNS</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器不允许一个 void 函数返回对另一个 void 函数的调用结果。&nbsp; </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">()</span> <span class="special">{}</span><br><span class="keyword">void</span> <span class="identifier">g</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">f</span><span class="special">();</span> <span class="special">}</span>
</pre>
<p> </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<a name="config_features"></a>
<p> </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_config.boost_macro_reference.macros_that_describe_optional_features"></a><a class="link" href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_optional_features" title="Macros that describe optional features">描述可选特性的宏</a>
</h3>
</div>
</div>
</div>
<p>以下宏描述了不被C++标准要求的一些特性。该宏只在该特性存在时被定义。 </p>
<div class="informaltable">
<table class="table">
<colgroup><col><col><col></colgroup> <thead><tr>
<th>
<p>宏 </p>
</th>
<th>
<p>节 </p>
</th>
<th>
<p> 说明 </p>
</th>
</tr>
</thead> <tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_BETHREADS</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台支持 BeOS 风格的线程。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_CLOCK_GETTIME</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX API <code class="computeroutput"><span class="identifier">clock_gettime</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_DECLSPEC</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器用&nbsp;<code class="computeroutput"><span class="identifier">__declspec</span><span class="special">(</span><span class="identifier">dllexport</span><span class="special">)</span></code> 和 <code class="computeroutput"><span class="identifier">__declspec</span><span class="special">(</span><span class="identifier">dllimport</span><span class="special">)</span></code> 来从
dll&nbsp;导出/导入 符号。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_DIRENT_H</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX 头文件 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">dirent</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_EXPM1</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有函数&nbsp;<code class="computeroutput"><span class="identifier">expm1</span></code>, <code class="computeroutput"><span class="identifier">expm1f</span></code>
和 <code class="computeroutput"><span class="identifier">expm1l</span></code>，
它们在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">math</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>
中。<code class="computeroutput"><span class="special"></span></code>
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_FTIME</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 Win32 API <code class="computeroutput"><span class="identifier">GetSystemTimeAsFileTime</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_GETTIMEOFDAY</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX API <code class="computeroutput"><span class="identifier">gettimeofday</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_HASH</span></code> </p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>C++实现提供了 (SGI) hash_set 和 hash_map 类。该宏被定义时，<code class="computeroutput"><span class="identifier">BOOST_HASH_SET_HEADER</span></code>
和 <code class="computeroutput"><span class="identifier">BOOST_HASH_LIST_HEADER</span></code>
将包含访问 hash_set 和 hash_map 所需的头文件名；<code class="computeroutput"><span class="identifier">BOOST_STD_EXTENSION_NAMESPACE</span></code>
将提供这两个类模板所处的名字空间。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_LOG1P</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有函数&nbsp;<code class="computeroutput"><span class="identifier">log1p</span></code>, <code class="computeroutput"><span class="identifier">log1pf</span></code>
和 <code class="computeroutput"><span class="identifier">log1pl</span></code>，
它们在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">math</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>
中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_MACRO_USE_FACET</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有符合标准的&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">use_facet</span></code>,
但是有一个宏&nbsp;<code class="computeroutput"><span class="identifier">_USE</span><span class="special">(</span><span class="identifier">loc</span><span class="special">,</span>
<span class="identifier">Type</span><span class="special">)</span></code> 来完成这一工作。主要用于
Dinkumware 标准库。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_MS_INT64</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>编译器支持&nbsp;<code class="computeroutput"><span class="identifier">__int64</span></code> 数据类型。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_NANOSLEEP</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX API nanosleep. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_NL_TYPES_H</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">nl_types</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_NRVO</span></code> </p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>表示编译器支持具名返回值优化(NRVO). 用于为某些函数选择最高效的实现。相关例子请见&nbsp;<a href="../../../../../boost/operators.hpp" target="_top"><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">operators</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code></a>.&nbsp;
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_PARTIAL_STD_ALLOCATOR</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有部分符合标准的&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span></code>
类，但没有任何成员模板。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_PTHREAD_DELAY_NP</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX API <code class="computeroutput"><span class="identifier">pthread_delay_np</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX API <code class="computeroutput"><span class="identifier">pthread_mutexattr_settype</span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_PTHREAD_YIELD</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX API <code class="computeroutput"><span class="identifier">pthread_yield</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_PTHREADS</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台支持 POSIX 风格的线程。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_SCHED_YIELD</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 POSIX API <code class="computeroutput"><span class="identifier">sched_yield</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_SGI_TYPE_TRAITS</span></code>
</p>
</td>
<td>
<p> 编译器,&nbsp;标准库 </p>
</td>
<td>
<p>编译器有对 SGI 风格的 type traits 有原生支持。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_STDINT_H</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台有 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">stdint</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_SLIST</span></code>
</p>
</td>
<td>
<p> 标准库 </p>
</td>
<td>
<p>C++实现提供了 (SGI) slist 类。该宏被定义时，<code class="computeroutput"><span class="identifier">OOST_SLIST_HEADER</span></code>
将包含访问&nbsp;<code class="computeroutput"><span class="identifier">slist</span></code> 所需的头文件名，<code class="computeroutput"><span class="identifier">BOOST_STD_EXTENSION_NAMESPACE</span></code>
提供了&nbsp;<code class="computeroutput"><span class="identifier">slist</span></code> 所处的名字空间。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_STLP_USE_FACET</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有符合标准的&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">use_facet</span></code>,
但有完成这一工作的变通版本的类。主要用于 STLport 标准库。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_ARRAY</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&gt;</span></code>
版本。. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_COMPLEX_OVERLOADS</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">complex</span><span class="special">&gt;</span></code>
支持传入标量给复数算法。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">complex</span><span class="special">&gt;</span></code> 包含 TR1
的新逆 trig 函数。&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_REFERENCE_WRAPPER</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的引用包装器，在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span></code> 中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_RESULT_OF</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的 result_of 模板，在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span></code>
中。&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_MEM_FN</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;mem_fn 函数模板，在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span></code> 中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_BIND</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;bind 函数模板，在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span></code> 中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_FUNCTION</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的 function 类模板，在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span></code> 中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_HASH</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;hash 函数模板，在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span></code> 中。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_SHARED_PTR</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的 <code class="computeroutput"><span class="identifier">shared_ptr</span></code><em>
</em>类模板，在 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">memory</span><span class="special">&gt;</span></code>
中。&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_RANDOM</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">random</span><span class="special">&gt;</span></code> 版本。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_REGEX</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">regex</span><span class="special">&gt;</span></code>
版本。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_TUPLE</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">tuple</span><span class="special">&gt;</span></code>
版本。&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_TYPE_TRAITS</span></code>
</p>
</td>
<td>
<p> 标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span></code> 版本。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_UTILITY</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的对&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">utility</span><span class="special">&gt;</span></code> 的补充(对 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>
的 tuple 接口)。&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_UNORDERED_MAP</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库有符合 TR1 的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">unordered_map</span><span class="special">&gt;</span></code> 版本。<code class="computeroutput"><span class="special"></span></code>.
</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_UNORDERED_SET</span></code>
</p>
</td>
<td>标准库</td>
<td>
<p>标准库有符合 TR1 的&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">unordered_set</span><span class="special">&gt;</span></code> 版本。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1</span></code> </p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>表示所有其它 <code class="computeroutput"><span class="identifier">BOOST_HAS_TR1_</span><span class="special">*</span></code> 宏均被设置。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_THREADS</span></code>
</p>
</td>
<td>
<p> 平台,&nbsp;编译器 </p>
</td>
<td>
<p>如果编译器在当前编译模式下支持多线程执行，则被定义。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_TWO_ARG_USE_FACET</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>标准库没有符合标准的 std::use_facet, 但有完成该工作的两参数版本。主要用于 Rogue Wave
标准库。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_UNISTD_H</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台提供了 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">unistd</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_WINTHREADS</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>平台支持 MS Windows 风格的线程。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_MSVC_STD_ITERATOR</span></code>
</p>
</td>
<td>
<p>标准库 </p>
</td>
<td>
<p>使用的是 Microsoft 的有问题的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator</span></code> 版本。相当于
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator</span></code>
不能接受两个以上模板参数。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_MSVC6_MEMBER_TEMPLATES</span></code>
</p>
</td>
<td>
<p> 编译器 </p>
</td>
<td>
<p>Microsoft Visual C++
6.0&nbsp;的成员模板特性(客气地说)足以定义&nbsp;<code class="computeroutput"><span class="identifier">BOOST_NO_MEMBER_TEMPLATES</span></code>.
定义&nbsp;<code class="computeroutput"><span class="identifier">BOOST_MSVC6_MEMBER_TEMPLATES</span></code>
可以采用编译器一些特定的变通方法。如果未定义&nbsp;<code class="computeroutput"><span class="identifier">BOOST_NO_MEMBER_TEMPLATES</span></code>
则会自动定义该宏 - 换言之，它被作标准要求的一个严格子集来处理。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_STDINT_H</span></code>
</p>
</td>
<td>
<p> 平台 </p>
</td>
<td>
<p>1998 C++ 标准中没有头文件&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">stdint</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code> 或 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">cstdint</span><span class="special">&gt;</span></code>, 虽然 1999
C 标准中包含了&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">stdint</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>.
如果有&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">stdint</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>,&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">stdint</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code>
就可以很好地使用它，所以提供了这个标志(作为信号使用；缺省是没有的，这符合当前的 C++ 标准)。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_config.boost_macro_reference.macros_that_describe_possible_c__0x_features"></a><a class="link" title="Macros that describe possible C++0x features" href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_possible_c__0x_features">描
述可能的 C++0x 特性的宏</a> </h3>
</div>
</div>
</div>
<p>以下宏描述了很可能被包含在即将到来的 ISO C++ 标准 C++0x 中，但尚未经批准加入到语言中的一些特性。 </p>
<div class="informaltable">
<table class="table">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
<p>宏 </p>
</th>
<th>
<p>说明 </p>
</th>
</tr>
</thead><tbody>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_HAS_CONCEPTS</span></code>
</p>
</td>
<td>
<p>编译器支持概念。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_config.boost_macro_reference.macros_that_describe_c__0x_features_not_supported"></a><a class="link" title="Macros that describe C++0x features not supported" href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_c__0x_features_not_supported">描
述不被支持的 C++0x 特性的宏</a> </h3>
</div>
</div>
</div>
<p>以下宏描述了在即将到来的 ISO C++ 标准 C++0x 中，但尚未被某个特定编译器或特定库支持的一些特性。 </p>
<div class="informaltable">
<table class="table">
<colgroup><col><col></colgroup>
<thead>
<tr>
<th>
<p>Macro </p></th>
<th>
<p>Description </p></th></tr></thead>
<tbody>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_ARRAY</span></code> </p></td>
<td>
<p>标准库不支持头文件 &lt;array&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_CHRONO</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;chrono&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_CODECVT</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;codecvt&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_CONCEPTS</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;concepts&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_CONDITION_VARIABLE</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;condition_variable&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_CONTAINER_CONCEPTS</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;container_concepts&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_FORWARD_LIST</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;forward_list&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_FUTURE</span></code> </p></td>
<td>
<p>标准库不支持头文件 &lt;future&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_INITIALIZER_LIST</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;initializer_list&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_ITERATOR_CONCEPTS</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;iterator_concepts&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_MEMORY_CONCEPTS</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;memory_concepts&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_MUTEX</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;mutex&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_RANDOM</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;random&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_RATIO</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;ratio&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_REGEX</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;regex&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_SYSTEM_ERROR</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;system_error&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_THREAD</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;thread&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_TUPLE</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;tuple&gt;. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_TYPE_TRAITS</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;type_traits&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_UNORDERED_MAP</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;unordered_map&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_0X_HDR_UNORDERED_SET</span></code> </p></td>
<td>
<p>标准库不支持头文件&nbsp;&lt;unordered_set&gt;. 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_AUTO_DECLARATIONS</span></code> </p></td>
<td>
<p>编译器不支持以 
<code class="computeroutput"><span class="keyword">auto</span></code> 关键字声明的变量(<code class="computeroutput"><span class="keyword">auto</span> <span class="identifier">var</span> <span class="special">=</span> <span class="special">...;</span></code>)的类型推导。 </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_AUTO_MULTIDECLARATIONS</span></code> </p></td>
<td>
<p>编译器不支持以 <code class="computeroutput"><span class="keyword">auto</span></code> 
关键字声明的多个变量(<code class="computeroutput"><span class="keyword">auto</span> <span class="identifier">var</span> <span class="special">=</span> <span class="special">...,</span> <span class="special">*</span><span class="identifier">ptr</span> <span class="special">=</span> <span class="special">...;</span></code>)的类型推导。 </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_CHAR16_T</span></code> </p></td>
<td>
<p>编译器不支持类型&nbsp;<code class="computeroutput"><span class="identifier">char16_t</span></code>. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_CHAR32_T</span></code> </p></td>
<td>
<p>编译器不支持类型&nbsp;<code class="computeroutput"><span class="identifier">char32_t</span></code>. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_CONCEPTS</span></code> </p></td>
<td>
<p>编译器不支持概念。 </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_TEMPLATE_ALIASES</span></code> </p></td>
<td>
<p>编译器不支持模板别名。 </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_CONSTEXPR</span></code> </p></td>
<td>
<p>编译器不支持&nbsp;<code class="computeroutput"><span class="identifier">constexpr</span></code>. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_DECLTYPE</span></code> </p></td>
<td>
<p>编译器不支持&nbsp;<code class="computeroutput"><span class="identifier">decltype</span></code>. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_DEFAULTED_FUNCTIONS</span></code> </p></td>
<td>
<p>编译器不支持缺省函数(<code class="computeroutput"><span class="special">=</span> <span class="keyword">default</span></code>)。 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_DELETED_FUNCTIONS</span></code> </p></td>
<td>
<p>编译器不支持已删函数(<code class="computeroutput"><span class="special">=</span> <span class="keyword">delete</span></code>)。 
</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_EXPLICIT_CONVERSION_OPERATIONS</span></code> </p></td>
<td>
<p>编译器不支持显式转换操作符(<code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="identifier">T</span><span class="special">()</span></code>)。 </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_EXTERN_TEMPLATE</span></code> </p></td>
<td>
<p>编译器不支持模板显式实例化声明&nbsp;(<code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">template</span></code>). </p></td></tr>
<tr><td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS</span></code> </p></td>
<td>
<p>编译器不支持用于函数模板的缺省模板参数。 </p></td></tr><tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_INITIALIZER_LISTS</span></code> </p></td>
<td>
<p>C++ 编译器不支持 C++0x 初始化列表。</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_LAMBDAS</span></code> </p></td>
<td>
<p>编译器不支持 Lambdas. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_LONG_LONG</span></code> </p></td>
<td>
<p>编译器不支持&nbsp;<code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_NULLPTR</span></code> </p></td>
<td>
<p>编译器不支持&nbsp;'nullptr'. </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_RAW_LITERALS</span></code> </p></td>
<td>
<p>编译器不支持裸字符串文字。</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_RVALUE_REFERENCES</span></code> </p></td>
<td>
<p>编译器不支持右值引用。</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_SCOPED_ENUMS</span></code> </p></td>
<td>
<p>编译器不支持定域枚举(<code class="computeroutput"><span class="keyword">enum</span> <span class="keyword">class</span></code>).</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_STATIC_ASSERT</span></code> </p></td>
<td>
<p>编译器不支持&nbsp;<code class="computeroutput"><span class="identifier">static_assert</span></code>.</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_STD_UNORDERD</span></code> </p></td>
<td>
<p>标准库不支持 &lt;unordered_map&gt; 和 &lt;unordered_set&gt;.</p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_TEMPLATE_ALIASES</span></code> </p></td>
<td>
<p>编译器不支持模板别名。 </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_UNICODE_LITERALS</span></code> </p></td>
<td>
<p>编译器不支持&nbsp;Unicode (<code class="computeroutput"><span class="identifier">u8</span></code>, <code class="computeroutput"><span class="identifier">u</span></code>, <code class="computeroutput"><span class="identifier">U</span></code>) 文字。 </p></td></tr>
<tr>
<td>
<p><code class="computeroutput"><span class="identifier">BOOST_NO_VARIADIC_TEMPLATES</span></code> </p></td>
<td>
<p>编译器不支持可变参数数量的模板。 </p></td></tr></tbody></table></div><br></div></div></div></div><div class="informaltable"><br></div>
</div>
<a name="config_helpers"></a>
<p> </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_config.boost_macro_reference.boost_helper_macros"></a><a class="link" href="boost_macro_reference.html#boost_config.boost_macro_reference.boost_helper_macros" title="Boost Helper Macros">Boost 辅助宏</a>
</h3>
</div>
</div>
</div>
<p>以下宏为简单的辅助宏，或是为编译器/标准库的缺陷提供变通方法的宏。 </p>
<div class="informaltable">
<table class="table">
<colgroup><col><col></colgroup> <thead><tr>
<th>
<p>宏 </p>
</th>
<th>
<p>说明 </p>
</th>
</tr>
</thead> <tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_DEDUCED_TYPENAME</span></code>
</p>
</td>
<td>
<p>有些编译器不支持推断上下文中为受限类型使用 <code>typename</code>.
在这些编译器中，该宏扩展为空，而在其它编译器中则扩展为 <code>typename</code>.
例如，将：&nbsp; <code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span>
<span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span>
<span class="keyword">typename</span> <span class="identifier">T</span><span class="special">::</span><span class="identifier">type</span><span class="special">);</span></code>
替换为 <code class="computeroutput"><span class="keyword">template</span>
<span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span>
<span class="identifier">BOOST_DEDUCED_TYPENAME</span>
<span class="identifier">T</span><span class="special">::</span><span class="identifier">type</span><span class="special">);</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HASH_MAP_HEADER</span></code>
</p>
</td>
<td>
<p>包含获得 SGI&nbsp;<code class="computeroutput"><span class="identifier">hash_map</span></code>
类的头文件。该宏仅在&nbsp;<code class="computeroutput"><span class="identifier">BOOST_HAS_HASH</span></code>
被定义时有效。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HASH_SET_HEADER</span></code>
</p>
</td>
<td>
<p>包含获得 SGI&nbsp;<code class="computeroutput"><span class="identifier">hash_set</span></code>
类的头文件。该宏仅在&nbsp;<code class="computeroutput"><span class="identifier">BOOST_HAS_HASH</span></code>
被定义时有效。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_SLIST_HEADER</span></code>
</p>
</td>
<td>
<p>包含获得 SGI&nbsp;<code class="computeroutput"><span class="identifier">slist</span></code>
类的头文件。该宏仅在&nbsp;<code class="computeroutput"><span class="identifier">BOOST_HAS_SLIST</span></code>
被定义时有效。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_STD_EXTENSION_NAMESPACE</span></code>
</p>
</td>
<td>
<p>用于标准库扩展(hashtable 类等)的名字空间。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_STATIC_CONSTANT</span><span class="special">(</span><span class="identifier">Type</span><span class="special">,</span> <span class="identifier">assignment</span><span class="special">)</span></code> </p>
</td>
<td>
<p>在不允许类中静态整型常量成员初始化的编译器上，我们必须使用 enums
作为变通的方法，如果我们想获得编译期的常量。该宏给了我们一个方便的方法来声明这样的常量。例如，将：&nbsp; </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">{</span><br><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">value</span> <span class="special">=</span> <span class="number">2</span><span class="special">;</span><br><span class="special">};</span>
</pre>
<p> 替换为： </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">{</span><br><span class="identifier">BOOST_STATIC_CONSTANT</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">value</span> <span class="special">=</span> <span class="number">2</span><span class="special">);</span><br><span class="special">};</span>
</pre>
<p> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_UNREACHABLE_RETURN</span><span class="special">(</span><span class="identifier">result</span><span class="special">)</span></code> </p>
</td>
<td>
<p>一般被扩展为空，但如果编译器要求即使不可到达也要一个返回语句，则扩展为 <font face="Courier New">return x;</font>&nbsp; </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_EXPLICIT_TEMPLATE_TYPE</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span></code> <code class="computeroutput"><span class="identifier">BOOST_EXPLICIT_TEMPLATE_NON_TYPE</span><span class="special">(</span><span class="identifier">t</span><span class="special">,</span><span class="identifier">v</span><span class="special">)</span></code> <code class="computeroutput"><span class="identifier">BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span></code> <code class="computeroutput"><span class="identifier">BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE</span><span class="special">(</span><span class="identifier">t</span><span class="special">,</span><span class="identifier">v</span><span class="special">)</span></code> </p>
</td>
<td>
<p>有些编译器在模板参数未出现在函数参数列表中时，会自动将不同的函数模板实例"折叠"起来。例如：&nbsp;
</p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">ostream</span><span class="special">&gt;</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">typeinfo</span><span class="special">&gt;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">n</span><span class="special">&gt;</span><br><span class="keyword">void</span> <span class="identifier">f</span><span class="special">()</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">n</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span><span class="special">;</span> <span class="special">}</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">void</span> <span class="identifier">g</span><span class="special">()</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="keyword">typeid</span><span class="special">(</span><span class="identifier">T</span><span class="special">).</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span><span class="special">;</span> <span class="special">}</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span><br><span class="identifier">f</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;();</span><br><span class="identifier">f</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;();</span><br><span class="identifier">g</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;();</span><br><span class="identifier">g</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;();</span><br><span class="special">}</span>
</pre>
<p>在VC++ 6上会错误地输出 <tt>"2 2 double double "</tt>.
这些宏可以在函数参数列表中使用，修正这一问题且不影响调用的语法。例如，将上例改写为：&nbsp; </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">n</span><span class="special">&gt;</span><br><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">BOOST_EXPLICIT_TEMPLATE_NON_TYPE</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">n</span><span class="special">))</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">void</span> <span class="identifier">g</span><span class="special">(</span><span class="identifier">BOOST_EXPLICIT_TEMPLATE_TYPE</span><span class="special">(</span><span class="identifier">T</span><span class="special">))</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span>
</pre>
<p>它们会声明(对于受影响的编译器)一个虚拟的缺省参数，所以它们<br>
<br>
a)&nbsp;被调用时总会带上参数列表 <br>
b) 如果你的函数模板有多份声明就不可使用。 <br>
<br>
此外，为了加上必要的逗号分隔符，当这些宏在普通的参数声明之后或同一组的其它宏调用之后出现，必须使用 "<code class="computeroutput"><span class="identifier">APPEND_</span><span class="special">*</span></code>" 版本。</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_USE_FACET</span><span class="special">(</span><span class="identifier">Type</span><span class="special">,</span> <span class="identifier">loc</span><span class="special">)</span></code> </p>
</td>
<td>
<p>如果标准库没有符合标准的&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">use_facet</span></code>，可以有多种普
通方法，每个库各不相同。该宏提供了一个简便的方法来访问某个 locale 的 facets. 例如，将：<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">use_facet</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;(</span><span class="identifier">loc</span><span class="special">);</span></code>
替换为 <code class="computeroutput"><span class="identifier">BOOST_USE_FACET</span><span class="special">(</span><span class="identifier">Type</span><span class="special">,</span> <span class="identifier">loc</span><span class="special">);</span></code>&nbsp;注意，不要在
&nbsp;<code class="computeroutput"><span class="identifier">BOOST_USE_FACET</span></code>
之前加上&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span></code>
前缀。</p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_HAS_FACET</span><span class="special">(</span><span class="identifier">Type</span><span class="special">,</span> <span class="identifier">loc</span><span class="special">)</span></code> </p>
</td>
<td>
<p>如果标准库没有符合标准的&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">has_facet</span></code>，可以有多种普
通方法，每个库各不相同。该宏提供了一个简便的方法来检查某个 locale 的 facets.&nbsp;例如，将：<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">has_facet</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;(</span><span class="identifier">loc</span><span class="special">);</span></code>
替换为 <code class="computeroutput"><span class="identifier">BOOST_HAS_FACET</span><span class="special">(</span><span class="identifier">Type</span><span class="special">,</span> <span class="identifier">loc</span><span class="special">);</span></code> 注意，不要在&nbsp;<code class="computeroutput"><span class="identifier">BOOST_</span></code><code class="computeroutput"><span class="identifier">HAS</span></code><code class="computeroutput"><span class="identifier">_FACET</span></code>
之前加上&nbsp;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span></code>
前缀。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NESTED_TEMPLATE</span></code>
</p>
</td>
<td>
<p>有些支持成员模板的编译器并不能使用&nbsp;<code class="computeroutput"><span class="identifier">A</span><span class="special">::</span><span class="keyword">template</span>
<span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;</span></code>
语法，作为变通的方法，可以将：<code class="computeroutput"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">::</span><span class="keyword">template</span> <span class="identifier">rebind</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;</span>
<span class="identifier">binder</span><span class="special">;</span></code> 替换为 <code class="computeroutput"><span class="keyword">typedef</span>
<span class="keyword">typename</span> <span class="identifier">A</span><span class="special">::</span><span class="identifier">BOOST_NESTED_TEMPLATE</span> <span class="identifier">rebind</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;</span>
<span class="identifier">binder</span><span class="special">;</span></code> </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_STRINGIZE</span><span class="special">(</span><span class="identifier">X</span><span class="special">)</span></code> </p>
</td>
<td>
<p>在对&nbsp;<code class="computeroutput"><span class="identifier">X</span></code>
执行宏替换后，将它转换为一个字符串。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_JOIN</span><span class="special">(</span><span class="identifier">X</span><span class="special">,</span><span class="identifier">Y</span><span class="special">)</span></code> </p>
</td>
<td>
<p>该宏将两个参数联接起来，即使其中有的参数本身也是宏(请见C++标准的16.3.1)。可用于创建一个名字与象
__LINE__ 这样的预定义宏结合。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<a name="config_info_macros"></a>
<p> </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_config.boost_macro_reference.boost_informational_macros"></a><a class="link" href="boost_macro_reference.html#boost_config.boost_macro_reference.boost_informational_macros" title="Boost Informational Macros">Boost 信息宏</a>
</h3>
</div>
</div>
</div>
<p>以下宏描述了一些 boost 特性；一般来说，这些 boost 宏只用于在用户代码中进行检测之用。 </p>
<div class="informaltable">
<table class="table">
<colgroup><col><col><col></colgroup> <thead><tr>
<th>
<p>宏 </p>
</th>
<th>
<p>头文件 </p>
</th>
<th>
<p>说明 </p>
</th>
</tr>
</thead> <tbody>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_VERSION</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">version</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>以 XXYYZZ 格式描述 boost 版本号如下：<code class="computeroutput"><span class="special">(</span><span class="identifier">BOOST_VERSION</span>
<span class="special">%</span> <span class="number">100</span><span class="special">)</span></code>
为子版本号，<code class="computeroutput"><span class="special">((</span><span class="identifier">BOOST_VERSION</span> <span class="special">/</span> <span class="number">100</span><span class="special">)</span> <span class="special">%</span>
<span class="number">1000</span><span class="special">)</span></code> 为次版本号，<code class="computeroutput"><span class="special">(</span><span class="identifier">BOOST_VERSION</span> <span class="special">/</span> <span class="number">100000</span><span class="special">)</span></code> 为主版本号。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_INT64_T</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">cstdint</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">stdint</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>没有64位整数类型 <code class="computeroutput"><span class="identifier">int64_t</span></code>, <code class="computeroutput"><span class="identifier">uint64_t</span></code>
等时被定义。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_INTEGRAL_INT64_T</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">cstdint</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">stdint</span><span class="special">.</span><span class="identifier">h</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>如果在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">cstdint</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
中定义的&nbsp;<code class="computeroutput"><span class="identifier">int64_t</span></code>
不可用于整型常量表达式，则定义该宏。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_MSVC</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>如果编译器为 Microsoft Visual C++, 但不是其它定义了&nbsp;<code class="computeroutput"><span class="identifier">_MSC_VER</span></code>
的编译器，则定义该宏。与&nbsp;<code class="computeroutput"><span class="identifier">_MSC_VER</span></code> 的值相同。 </p>
</td>
</tr>
<tr><td>
<p><code class="computeroutput"><span class="identifier">BOOST_MSVC_FULL_VER</span></code> </p></td>
<td>
<p><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p></td>
<td>
<p>定义为正规化的9位 _MSC_FULL_VER 版本(有时可能只有8位数字)，该宏的格式为 VVMMPPPPP，其中 VV 为主版本号，MM 为次版本号，PPPPP 为编译器构建号。 </p></td></tr><tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_INTEL</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>如果编译器为 Intel compiler, 则定义该宏，其中带有与编译器版本宏相同的值。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_WINDOWS</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>如果 Windows 平台 API 可用，则定义该宏。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_DINKUMWARE_STDLIB</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>如果使用的是 dinkumware 标准库，则定义该宏，如果 Dinkumware 库版本宏&nbsp;<code class="computeroutput"><span class="identifier">_CPPLIB_VER</span></code>
被定义，则带有与之相同的值，否则为 1. </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_NO_WREGEX</span></code>
</p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">regex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
</p>
</td>
<td>
<p>如果 regex 库不支持宽字符正则表达式，则定义该宏。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_COMPILER</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>定义为一个字符串，描述在用编译器的名字和版本。主要用于验证配置。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_STDLIB</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>定义为一个字符串，描述在用标准库的名字和版本。主要用于验证配置。 </p>
</td>
</tr>
<tr>
<td>
<p> <code class="computeroutput"><span class="identifier">BOOST_PLATFORM</span></code> </p>
</td>
<td>
<p> <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> </p>
</td>
<td>
<p>定义为一个字符串，描述平台的名字。主要用于验证配置。 </p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code"></a><a class="link" href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code" title="Macros for libraries with separate source code">用于分隔源代
码的宏</a>
</h3>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code.abi_fixing">ABI
的修正</a></span></dt>
<dt><span class="section"><a href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code.automatic_library_selection">自
动的库选择</a></span></dt>
</dl>
</div>
<p>以下宏和辅助头文件专门给那些包含独立源代码的库的作者使用，其目的是解决两个问题：修正被编译库的ABI，以及根据编译器的设置选择
哪一个已编译的库进行链接。</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code.abi_fixing"></a><a class="link" href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code.abi_fixing" title="ABI Fixing">ABI 的修正</a>
</h4>
</div>
</div>
</div>
<p>在与一个预编译的库进行链接时，关键是构建该库时编译器所用的ABI必须与使用该库的代码所用的ABI严格匹配。这里的ABI指的是，
象结构压缩排
列、命名扰乱机制、某些类型的大小(如 enum
类型)等东西。这些东西与线程支持、运行期库的变化等是分离的，后者必须通过构建变量来处理。为了解释得更清楚，一个编译器(如Borland的)有许多
编译器选项会对ABI造成很微妙的影响，理论上至少有3200种组合，这还没有考虑运行期库的变化。幸好，这些变量可以通过&nbsp; <code class="computeroutput"><span class="preprocessor">#pragma</span></code>
来管理，告诉编译器在你的库中所声明的类型使用了怎样的ABI。为了避免在 boost 头文件中到处出现&nbsp; <code class="computeroutput"><span class="preprocessor">#pragma</span></code>,
我们用一些前缀头文件和后缀头文件来完成这项工作。典型的用法如下：</p>
<p> <span class="bold"><strong>my_library.hpp</strong></span>
</p>
<pre class="programlisting"><span class="preprocessor">#ifndef</span> <span class="identifier">MY_INCLUDE_GUARD</span><br><span class="preprocessor">#define</span> <span class="identifier">MY_INCLUDE_GUARD</span><br><span class="comment">// 这里是要包含的头文件：<br></span><code class="literal"><span class="bold"><strong>#include &lt;boost/config.hpp&gt;</strong></span></code><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">whatever</span><span class="special">&gt;</span><br><code class="literal"><span class="bold"><strong>#include &lt;boost/config/abi_prefix.hpp&gt;</strong></span></code> <span class="comment">// 必须是最后一个 #include<br></span><br><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span><br><span class="comment">// 这里是你的代码<br></span><br><span class="special">}</span><br><code class="literal"><span class="bold"><strong>#include &lt;boost/config/abi_suffix.hpp&gt;</strong></span></code> <span class="comment">// 弹出 abi_prefix.hpp 的 pragmas<br></span><br><span class="preprocessor">#endif</span> <span class="comment">// include guard<br></span></pre>
<p> <span class="bold"><strong>my_library.cpp</strong></span>
</p>
<pre class="programlisting"><span class="special">...</span><br><span class="comment">// 在实现文件中不需要任何特殊处理<br></span><span class="special">...</span>
</pre>
<p>用户可以通过定义&nbsp;<code class="computeroutput"><span class="identifier">BOOST_DISABLE_ABI_HEADERS</span></code>
来禁止这一机制，或者他们可以定义&nbsp;<code class="computeroutput"><span class="identifier">BOOST_ABI_PREFIX</span></code>
和/或 <code class="computeroutput"><span class="identifier">BOOST_ABI_SUFFIX</span></code>
来指向它们自己的前缀/后缀头文件，如果他们想要的话。</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code.automatic_library_selection"></a><a class="link" href="boost_macro_reference.html#boost_config.boost_macro_reference.macros_for_libraries_with_separate_source_code.automatic_library_selection" title="Automatic library selection">自动的库选择</a>
</h4>
</div>
</div>
</div>
<p>当用户链接到一个库的某个构建时，本质上该库构建时所链接的运行期库必须与他们的应用所链接的一样 -
如果不是这样的话，该库与他们的代码就不是二进制兼容的 -
很可能他们的应用会在运行时发生异常。这种问题的调测非常耗费时间，也很困难，常常会导致用户和作者同样的失败(选择正确的库来链接并不象看起来那么容
易，它们通常有6-8个选择，有些用户并不清楚它们会有不同的选择)。</p>
<p class="title">为了解决这个问题，有些编译器允许源代码包含&nbsp;<code class="computeroutput"><span class="preprocessor">#pragma</span></code>
以指示链接器要链接哪一个库，用户要做的只是包含他们所需的头文件，将已编译的库放在他的库搜索路径中，剩下的交给编译器和链接器去做就行了。
Boost.config 通过头文件&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">/</span><span class="identifier">auto_link</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
支持这一方法，在包含这一头文件之前，要定义以下一个或多个宏：</p>
<div class="variablelist">
<dl>
<dt><span class="term"><code class="computeroutput"><span class="identifier">BOOST_LIB_NAME</span></code></span></dt>
<dd>
<p>必选：包含库的基本名的一个标识符，例如 'boost_regex'. </p>
</dd>
<dt><span class="term"><code class="computeroutput"><span class="identifier">BOOST_DYN_LINK</span></code></span></dt>
<dd>
<p>可选：要设置链接 dll 而不是静态库时。 </p>
</dd>
<dt><span class="term"><code class="computeroutput"><span class="identifier">BOOST_LIB_DIAGNOSTIC</span></code></span></dt>
<dd>
<p>可选：要设置头文件打印出选定的库的名字时(用于调试)。 </p>
</dd>
</dl>
</div>
<p>如果编译器支持这种机制，那么它将被告知链接到适当名字的库，用于生成库名的实际算法在&nbsp;<code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">/</span><span class="identifier">auto_link</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
中有相关说明，它必须与通过 bjam 的安装规则进行库的创建所用的算法相匹配。</p>
<p> <span class="bold"><strong>my_library.hpp</strong></span>
</p>
<pre class="programlisting"><span class="special">...</span><br><span class="comment">//<br></span><span class="comment">// 如果用户已通过定义</span><span class="comment"> BOOST_ALL_NO_LIB 或 BOOST_MY_LIBRARY_NO_LIB 来禁止，<br></span><span class="comment">// 或者这是我们自己的源代码(以 BOOST_MY_LIBRARY_SOURCE 来表示)，则不包含自动<br>// 自动链接代码:<br></span><span class="comment">//<br></span><span class="preprocessor">#if</span> <span class="special">!</span><span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_ALL_NO_LIB</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="special">!</span><span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_MY_LIBRARY_NO_LIB</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="special">!</span><span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_MY_LIBRARY_SOURCE</span><span class="special">)</span><br><span class="preprocessor"># define</span> <span class="identifier">BOOST_LIB_NAME</span> <span class="identifier">boost_my_library</span><br><span class="preprocessor"># ifdef</span> <span class="identifier">BOOST_MY_LIBRARY_DYN_LINK</span><br><span class="preprocessor"># define</span> <span class="identifier">BOOST_DYN_LINK</span><br><span class="preprocessor"># endif</span><br><span class="preprocessor"># include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">config</span><span class="special">/</span><span class="identifier">auto_link</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="preprocessor">#endif</span><br><span class="special">...</span>
</pre>
<p> <span class="bold"><strong>my_library.cpp</strong></span>
</p>
<pre class="programlisting"><span class="comment">// 定义 BOOST_MY_LIBRARY_SOURCE 以便头文件得知该库正在构建<br></span><span class="comment">// (可能是导出而不是导入代码)<br></span><span class="comment">//<br></span><span class="preprocessor">#define</span> <span class="identifier">BOOST_MY_LIBRARY_SOURCE</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">my_library</span><span class="special">/</span><span class="identifier">my_library</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><span class="special">...</span>
</pre>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%">
<tbody>
<tr>
<td align="left"></td>
<td align="right">
<div class="copyright-footer">Copyright © 2001 -2007
Beman Dawes, Vesa Karvonen, John Maddock
<p> Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>
</div>
</td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="../index.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="guidelines_for_boost_authors.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a></div>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>






  
  
  
  
  
  <meta http-equiv="Content-Language" content="en-us">






  
  
  
  
  
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">






  
  
  
  
  
  <meta name="ProgId" content="FrontPage.Editor.Document">






  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">







  
  
  
  
  
  
  
  
  
  
  <title>Filesystem Home</title>
  <link rel="stylesheet" type="text/css" href="../../../doc/html/minimal.css">
</head>


<body>







<table style="border-collapse: collapse;" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0" width="710">






  <tbody>





    <tr>






    <td width="277">
      <a href="../../../index.htm">
      <img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" border="0" height="86" width="277"></a></td>






    <td align="center" width="410">
    <font size="7">Filesystem 库</font>
    </td>






  </tr>






  
  
  
  
  
  </tbody>
</table>







<table style="border-collapse: collapse;" bgcolor="#d7eeff" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">






  <tbody>





    <tr>






    <td><a href="../../../index.htm">Boost Home</a>&nbsp;&nbsp;&nbsp;
    <a href="index.htm">Library Home</a>&nbsp; &nbsp; <a href="#tutorial">Tutorial</a>&nbsp; &nbsp; <a href="reference.html">
    Reference</a>&nbsp;&nbsp; <a href="faq.htm">FAQ</a></td>






  </tr>






  
  
  
  
  
  </tbody>
</table>







<table style="border-collapse: collapse;" align="right" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0">






  <tbody>





    <tr>






    <td align="center" bgcolor="#d7eeff" width="100%">
      <i><b>目录</b></i></td>






  </tr>






  <tr>






    <td bgcolor="#e8f5ff" width="100%">
    <a href="#Introduction">简介</a><br>






    <a href="#Using">使用本库</a><br>






    <a href="#tutorial">两分钟指南</a><br>






    <a href="#Cautions">警告</a><br>






    <a href="#Using_reference_doc">使用参考文档</a><br>






    <a href="#Examples">例子程序</a><br>






    <a href="#Implementation">实现</a><br>






    <a href="#narrow-only">只使用窄字符路径</a><br>






    <a href="#Building">构建目标库</a><br>






    &nbsp;&nbsp;&nbsp; <a href="#Cgywin">给 Cygwin 用户的说明</a><br>






    <a href="#Acknowledgements">鸣谢</a><br>






    <a href="#Change-history">变更历史</a></td>






  </tr>






  <tr>






    <td align="center" bgcolor="#d7eeff" width="100%">
      <i><b>其它文档</b></i></td>






  </tr>






  <tr>






    <td bgcolor="#e8f5ff" width="100%">
    <a href="reference.html">参考</a><br>






    <a href="design.htm">库的设计</a><br>






    <a href="faq.htm">FAQ</a><br>






    <a href="portability_guide.htm">可移植性指南</a><br>






    <a href="do-list.htm">待办事项</a>
    </td>






  </tr>






  
  
  
  
  
  </tbody>
</table>







<h2><a name="Introduction">简介</a></h2>






<p>Boost.Filesystem 库为对路径、文件和目录进行查询和操作提供了可移植的工具。</p>







<p>本库的动机源自以下需要，即在C++程序内部执行一些可移植的、类似于脚本的操作。它的意图不是要和 Python, Perl,或 shell 语言进行竞争，而是在已经选定了C++作为开发语言的情况下，提供一些可移植的文件系统操作。在 <a href="design.htm">
设计</a> 中我们鼓励但不要求安全和可移植地使用它。</p>







<p>使用本库的程序是<b><i>可移植的</i></b>，这意味着不仅程序代码的语法是可移植的，而且代码的语义和行为也是可移植的。<a href="reference.html">通用路径语法</a>也是可移植性的一个重点。</p>







<p>使用本库是<i><b>安全的</b></i>，意味着不可能忽略使用中发生的错误，由于其中大多数函数在检测到错误时会抛出C++异常。这对于用户来说也是很方便的，因为减少了通过返回码检查错误的需要。</p>







<p>提议
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1975.html">
N1975</a>
建议将 Boost.Filesystem 包含到 Technical Report 2
中，已经被C++标准委员会所接纳。Boost.Filesystem 库将保留在 TR2 Filesystem 建议书中，就象它在 TR2
的进程中那样。不过请注意，Boost.Filesystem 和 TR2 建议书之间的名字空间和头文件粒度会有所不同。</p>







<p>Boost.Filesystem 库提供了以下几个头文件：</p>







<ul>






  <li>头文件 &lt;<a href="../../../boost/filesystem.hpp">boost/filesystem.hpp</a>&gt; 提供了类 <i>
  basic_path, </i>一个在C++程序中表示
      <a href="#path">路径paths</a> 的可移植机制。Typedefs <i>path</i> 和 <i>
  wpath</i> 使得 <i>basic_path</i> 的常见用法更为容易。操作函数提供了对文件和目录的查询和维护。类 <i>basic_directory_iterator</i> 及 typdefs <i>
  directory_iterator</i> 和 <i>wdirectory_iterator</i> 提供了对目录内容的迭代。一些便利函数和类将底层的功能以有用的方式组合起来。<br>






&nbsp;</li>






  <li>头文件 &lt;<a href="../../../boost/filesystem/fstream.hpp">boost/filesystem<i>/</i>fstream.hpp</a>&gt; 提供了与C++标准库的 <i>fstream</i> 头文件相同的组件，除了它的文件是用 <i>basic_path</i> 对象而不是 <i>char *</i> 来标识。</li>






</ul>






<h2><a name="Using">使用本库</a></h2>






<p>Boost.Filesystem 被实现为一个单独编译的库，所以在使用它之前，你必须将它安装在一个你的链接器可以查找到的地方。请见
<a href="#Building">构建目标库</a>。 </p>






<p>本库的 <a href="../example">example 目录</a> 包含了非常简单的脚本，用于在不同平台上构建 <a href="#Examples">例子程序</a>。你可以用这些脚本来看一下，编译和链接你自己的程序需要些什么。</p>






<h2><a name="tutorial">两分钟指南</a></h2>






<p>(Tabrez Iqbal 还有一个 <a href="http://beans.seartipy.com/2006/05/10/boost-filesystem-library-writing-portable-c-programs-to-acess-the-filesystem/">更详尽的指南</a>)</p>






<p>先来一些准备工作：</p>






<blockquote>
  
  
  
  
  
  
  <pre>#include "boost/filesystem.hpp"   // 包含所有需要的 Boost.Filesystem 声明<br>#include &lt;iostream&gt;               // 使用 std::cout<br>using boost::filesystem;          // 为了方便陈述；在真实代码中使用名字空间别名是首选</pre>






</blockquote>






<p>然后可以创建一个 <a href="reference.html#Class-template-basic_path">类 <i>path</i></a> 的对象：</p>






<blockquote>
  
  
  
  
  
  
  <pre>path my_path( "some_dir/file.txt" );</pre>






</blockquote>






<p>传递给 <i>path</i> 构造函数的字符串可以是
<a href="reference.html#Pathname-formats">可移植通用路径格式</a> 或是实现定义的原生操作系统格式。访问函数使得 <i>my_path</i> 的内容可以以操作系统无关的格式来访问底层的操作系统API，如 <code>"some_dir:file.txt"</code>, <code>"[some_dir]file.txt"</code>,
<code>"some_dir/file.txt"</code>, 或者任何适用于操作系统的格式。如果使用类 <i>wpath</i> 来替代类 <i>path</i>，则会在操作系统需要时自动执行宽字符与窄字符之间的转换。</p>






<p>类 <i>path</i> 具有从 <i>const char*</i> 和 <i>
const std:: string&amp;</i> 进行构造的构造函数，所以即使以下代码片断中所使用的 Filesystem 库函数具有 <i>const path&amp;</i> 形参，用户也可以用C风格的字符串作为实参：</p>






<blockquote>
  
  
  
  
  
  
  <pre>remove_all( "foobar" );<br>create_directory( "foobar" );<br>ofstream file( "foobar/cheeze" );<br>file &lt;&lt; "tastes good!\n";<br>file.close();<br>if ( !exists( "foobar/cheeze" ) )<br>  std::cout &lt;&lt; "Something is rotten in foobar\n";</pre>






</blockquote>






<p>为了让类 <i>path</i> 的对象更容易在表达式中使用，<i>operator/</i> 被用来增加路径：</p>






<blockquote>
  
  
  
  
  
  
  <pre>ifstream file1( arg_path / "foo/bar" );<br>ifstream file2( arg_path / "foo" / "bar" );</pre>






</blockquote>






<p>表达式 <i>arg_path / "foo/bar"</i> 和 <i>arg_path / "foo" 
/ "bar"</i> 会得到相同的结果。</p>






<p>路径中可以包含对当前目录的引用，使用 "<code>.</code>" 
符号，还有父目录的引用，使用 "<code>..</code>" 
符号。</p>






<p><a href="reference.html#Class-template-basic_directory_iterator">类&nbsp;<i>basic_directory_iterator</i></a> 
是本库的一个重要组件。它提供了遍历一个目录内容的输入迭代器，它的值类型是类 <i>basic_path</i>. 
Typedefs <i>directory_iterator</i> 和 <i>wdirectory_iterator</i> 被提供以覆盖最常见的用例。</p>






<p>以下函数中，给定一个目录路径和一个文件名，在该目录及其子目录中递归查找该文件名，返回一个 
bool, 并在成功时返回找到文件的路径。以下代码取自一个真实的程序，为清晰起见作了少许修改：</p>






<blockquote>
  
  
  
  
  
  
  <pre>bool find_file( const path &amp; dir_path,         // 在该目录下，<br>                const std::string &amp; file_name, // 查找该文件名，<br>                path &amp; path_found )            // 如果找到将路径名存在此处<br>{<br>  if ( !exists( dir_path ) ) return false;<br>  directory_iterator end_itr; // 缺省构造生成一个结束迭代器<br>  for ( directory_iterator itr( dir_path );<br>        itr != end_itr;<br>        ++itr )<br>  {<br>    if ( is_directory(itr-&gt;status()) )<br>    {<br>      if ( find_file( itr-&gt;path(), file_name, path_found ) ) return true;<br>    }<br>    else if ( itr-&gt;leaf() == file_name ) // 见后<br>    {<br>      path_found = itr-&gt;path();<br>      return true;<br>    }<br>  }<br>  return false;<br>}</pre>






</blockquote>






<p>在注释 <i>// 见后</i> 所在的那行代码中，表达式 <i>itr-&gt;path().leaf() == file_name</i>，在迭代器所指的 <i>directory_entry</i> 对象的 <i>path()</i> 函数调用后所返回的 <i>path</i> 上再调用 <i>leaf()</i> 函数。<i>leaf()</i> 返回一个字符串，它是在
<i>path</i> 对象中的最后(最接近叶节点，离根节点最远)的文件或目录名的拷贝。</p>






<p>除了 <i>leaf()</i>, 还有其它几个函数名使用了 树tree/根root/分支branch/叶子leaf 的比喻。</p>






<p>注意，<i>find_file()</i> 并不显式检查错误，如验证 <i>dir_path</i>
参数是否真的表示一个目录。Boost.Filesystem
的函数在不同完全成功时会抛出异常，所以已经有了足够的隐式错误检查，应用程序无需提供额外的错误检查代码，除非你想要。有几个
Boost.Filesystem 函数具有不抛出版本，可用于不适合使用异常的情况。</p>






<blockquote>
  
  
  
  
  
  <p><i>说明：</i>在上述例子代码写完后，目录的递归迭代被作为一个便利函数被增加到库中，所以现在你不再需要自己编写代码来执行递归了。</p>






</blockquote>






<h2><a name="Cautions">警告</a></h2>






<p>阅读本指南后，你就可以使用 Filesystem 库进行简单的、类似脚本的编程了！不过在进行关键的工作之前，你还要知道几个警告：</p>






<h4><b>在出现竞争条件时结果与后续条件不被保证</b></h4>






<p>Filesystem 的函数规范遵循C++标准的格式，以结果和后续条件来规定行为。如果存在 <a href="reference.html#Race-condition">竞争条件race-condition</a>，则函数的后续条件在函数返回到调用者时可能不再为真。</p>






<blockquote>
  
  
  
  
  
  <p><b><i>解释：</i></b>文件和目录的状态通常都是全局共享的，因而可能会被其它线程、进程或甚至通过网络访问该文件系统的其它计算机所修改。这一点可能会引起问题，以下就是一个这样的例子，注意以下断言可能失败：</p>






  
  
  
  
  
  <blockquote>
    
    
    
    
    
    <p><code>assert( exists( "foo" ) == exists( "foo" ) );&nbsp; // 
(1)<br>






    <br>






remove_all( "foo" );<br>






assert( !exists( "foo" ) );&nbsp; // (2)<br>






    <br>






assert( is_directory( "foo" ) == is_directory( "foo" ) ); // 
(3)</code></p>






  </blockquote>






  
  
  
  
  
  <p>(1) 可能失败，如果在第一次和第二调用 <i>exists()</i> 之间，一个原本不存在的 "foo" 变为存在了，或者一个原本存在的 "foo" 被删除。这是有可能发生的，如果在这个例子的执行过程中，另一个线程、进程或计算机也在同一个目录下进行了操作。</p>






  
  
  
  
  
  <p>(2) 可能失败，如果在调用 <i>remove_all()</i> 和调用
  <i>exists()</i> 之间，一个名为 "foo" 的新文件或新目录被另一个线程、进程或计算机所创建。</p>






  
  
  
  
  
  <p>(3) 可能失败，如果另一个线程、进程或计算机在这个例子两次调用 <i>is_directory()</i> 之间删除了一个原本存在的文件 "foo"，然后又创建一个名为 "foo" 的目录。</p>






</blockquote>






<h4><b>可能抛出异常</b></h4>






<p>除非特别说明，否则 Boost.Filesystem 的函数在不能成功完成它们的操作规范时，会抛出 <i>
<a href="reference.html#basic_filesystem_error-constructors">basic_filesystem_error</a></i> 
异常。另外，实现可能会使用C++标准库的函数，而后者可能抛出 <i>std::bad_alloc</i>. 即使错误条件所导致的异常没有在函数的 "抛出" 节中明确给出，这些异常也可能会被抛出。</p>






<p>由 Filesystem 
库抛出的所有异常都是通过调用 <a href="../../utility/throw_exception.html">
boost::throw_exception()</a> 来实现的。因此精确的行为可能会有所不同，其取决于 filesystem 源代码编译时的 
BOOST_NO_EXCEPTIONS 设置。</p>






<p>有几个函数提供了无抛出的版本，它们通常用在适合以错误代码作为报告错误的方法的情形下。</p>






<h2><a name="Examples">例子程序</a></h2>






<h3><a href="../example/simple_ls.cpp">simple_ls.cpp</a></h3>






<p>例子程序 <a href="../example/simple_ls.cpp">simple_ls.cpp</a> 以命令行参数给定一个路径。因为命令行参数有可能是一个相对路径，所以程序会计算出完整路径，以使得显示的信息更为精确。</p>






<p>该程序检查该路径是否存在；如果不存在则打印出一条信息。</p>






<p>如果该路径表示一个目录，则该目录将被遍历，并打印出目录中的各条目名字，如果是目录则还有一个标识。程序将更新一个目录及文件的计数，并在遍历结束后打印出来。</p>






<p>如果该路径表示一个文件，则打印一条相应的信息。</p>






<p>请尝试编译和执行 <a href="../example/simple_ls.cpp">simple_ls.cpp</a>，看看它在你的系统上是如何工作的。试一下不同的路径参数，看看有什么发生。</p>






<h3><a href="../example/file_size.cpp">file_size.cpp</a></h3>






<p>如果给定的是一个普通文件，该例子程序将打印出文件的大小。</p>






<h3>其它例子</h3>






<p>以下程序使用 
Filesystem 库生成 Boost 回归测试状态表。请见：</p>






<ul>






  <li><a href="../../../tools/regression/src/process_jam_log.cpp">process_jam_log.cpp</a></li>






  <li><a href="../../../tools/regression/src/compiler_status.cpp">compiler_status.cpp</a></li>






</ul>






<p>有时候测试程序对于理解一个库是非常有用的，因为它们示范了开发人员应该做什么和不该做什么。请见：</p>






<ul>






  <li><a href="../test/wide_test.cpp">wide_test.cpp</a></li>






  <li><a href="../test/path_test.cpp">path_test.cpp</a></li>






  <li><a href="../test/operations_test.cpp">operations_test.cpp</a></li>






  <li><a href="../test/fstream_test.cpp">fstream_test.cpp</a></li>






</ul>






<h2><a name="Implementation">实现</a></h2>






<p>当前的实现支持的操作系统包括 POSIX 和 Windows API.</p>






<p>该库通常用于 Apple  OS X, HP-UX, IBM AIX, Linux, 
Microsoft Windows, SGI IRIX, 和 Sun Solaris 操作系统，并使用多个不同编译器。</p>






<h2><a name="narrow-only">只使用窄字符路径</a></h2>






<p>对于不支持宽字符(wchar_t)或宽字符串(std::wstring)的编译器或标准库，系统可以自动检测，并会引起本库的编译码限于只使用
窄字符路径(boost::filesystem::path)。用户可以强加这一局限，只要定义宏
BOOST_FILESYSTEM_NARROW_ONLY 就可以了。这对于旧的编译器或操作系统非常有用。</p>






<h2><a name="Building">构建目标库</a></h2>






<p>如果你使用的是 Boost 构建系统，则目标库将被自动构建。请见
<a href="../../../more/getting_started.html">入门Getting Started</a>. 你也可以用在目录 libs/filesystem/build 中提供的 <a href="../build/Jamfile.v2">Jamfile</a> 
进行手工构建，或者可以建立一个包含目标库源文件的 IDE 
项目或 make 文件。</p>






<p>目标库源文件在目录 <a href="../src">libs/filesystem/src</a> 中提供。这些源文件实现了支持
POSIX 或 Windows 兼容操作系统的库；不提供支持其它操作系统的实现。注意，许多并不被认为是 POSIX
系统的操作系统，如传统的大型机操作系统或嵌入式操作系统，只要支持 POSIX 兼容的文件系统，也可以使用 Filesystem 库。</p>






<p>目标库可以构建为静态或动态(shared/dll)链接。这是由 BOOST_ALL_DYN_LINK 或 BOOST_FILESYSTEM_DYN_LINK 
宏来控制的。对所用技术的说明请见 <a href="http://www.boost.org/more/separate_compilation.html">Separate 
Compilation</a> 页。</p>






<h3><a name="Cgywin">给 Cygwin</a> 用户的说明</h3>






<p>本库的实现代码自动检测当前平台，并据此编译为 POSIX 或 Windows 实现。在目标库编译过程中的自动平台检测可以通过定义 BOOST_POSIX_API 或 BOOST_WINDOWS_API 宏来改变。除了 Cygwin 
以外，通常没有理由定义这些宏，因为多数编译器提供的软件开发包只支持单一平台。</p>






<p><a href="http://www.cygwin.com/">Cygwin</a> 的工具包支持传统的 Windows 使用，但也提供了一个模拟层和其它工具，把 Windows 弄得象 Linux (也就是 POSIX)一样，提供了 
Linux 的外观和感觉。GCC 通常是这个环境下的编译器选择，它可以在 Cygwin 安装过程中安装。其它编译器也可以使用 Cygwin 的 POSIX 模拟，至少在理论上是可以的。</p>






<p>这些使用 Cygwin POSIX 模拟层的愿望需要在编译用户程序和 Boost.Filesystem 的目标库时定义 
BOOST_POSIX_API 宏。&nbsp;</p>






<h2>鸣谢</h2>






<p>The Filesystem Library was designed and implemented by Beman Dawes. The 
original <i>directory_iterator</i> and <i>filesystem_error</i> classes were 
based on prior work from Dietmar Kuehl, as modified by Jan Langer. Thomas Witt 
was a particular help in later stages of initial development. Peter Dimov and 
Rob Stewart made many useful suggestions and comments over a long period of 
time. Howard Hinnant helped with internationalization issues.</p>







<p>Key <a href="design.htm#Requirements">design requirements</a> and
<a href="design.htm#Realities">design realities</a> were developed during 
extensive discussions on the Boost mailing list, followed by comments on the 
initial implementation. Numerous helpful comments were then received during the 
Formal Review.</p>





<p>Participants included 
Aaron Brashears,
Alan Bellingham,
Aleksey Gurtovoy,
Alex Rosenberg,
Alisdair Meredith,
Andy Glew,
Anthony Williams,
Baptiste Lepilleur, 
Beman Dawes,
Bill Kempf,
Bill Seymour, 
Carl Daniel,
Chris Little,
Chuck Allison,
Craig Henderson, 
Dan Nuffer,
Dan'l Miller,
Daniel Frey, 
Darin Adler, 
David Abrahams,
David Held, 
Davlet Panech,
Dietmar Kuehl,
Douglas Gregor, 
Dylan Nicholson,
Ed Brey, 
Eric Jensen,
Eric Woodruff,
Fedder Skovgaard,
Gary Powell,
Gennaro Prota,
Geoff Leyland, 
George Heintzelman, 
Giovanni Bajo,
Glen Knowles,
Hillel Sims,
Howard Hinnant,
Jaap Suter,
James Dennett, 
Jan Langer, 
Jani Kajala, 
Jason Stewart, 
Jeff Garland,
Jens Maurer,
Jesse Jones,
Jim Hyslop,
Joel de Guzman,
Joel Young,
John Levon, 
John Maddock,
John Williston,
Jonathan Caves,
Jonathan Biggar,
Jurko,
Justus Schwartz,
Keith Burton, 
Ken Hagen,
Kostya Altukhov, 
Mark Rodgers,
Martin Schuerch, 
Matt Austern,
Matthias Troyer, 
Mattias Flodin, 
Michiel Salters,
Mickael Pointier,
Misha Bergal,
Neal Becker,
Noel Yap,
Parksie,
Patrick Hartling, Pavel Vozenilek,
Pete Becker, 
Peter Dimov,
Rainer Deyke,
Rene Rivera,
Rob Lievaart,
Rob Stewart,
Ron Garcia,
Ross Smith,
Sashan,
Steve Robbins, 
Thomas Witt, 
Tom Harris, 
Toon Knapen,
Victor Wagner,
Vincent Finn,
Vladimir Prus, and
Yitzhak Sapir
 
</p>





<p>A lengthy discussion on the C++ committee's library reflector illuminated the "illusion 
of portability" problem, particularly in postings by PJ Plauger and Pete Becker.</p>







<p>Walter Landry provided much help illuminating symbolic link use cases for 
version 1.31.0.</p>







<h3>版本 1.34 (<a href="i18n.html">i18n</a>) 的鸣谢</h3>







<p>So many people have contributed comments and bug reports that it isn't any 
longer possible to acknowledge them individually. That said, Peter Dimov and Rob 
Stewart need to be specially thanked for their many constructive criticisms and 
suggestions. Terence 
Wilson and Chris Frey contributed timing programs which helped illuminate 
performance issues.</p>







<h2><a name="Change-history">Change history</a></h2>







<h3>版本 1.35.0</h3>







<ul>






  <li>诊断功能被挪到单独的 <a href="../../system/doc/index.html">
  Boost.System</a> 库。</li>






  <li>增加了 current_path() 函数，设置当前目录的路径。</li>






  <li>扩展了测试的覆盖程度。</li>






  <li>一些次要的实现修正。</li>






</ul>







<h3><a href="i18n.html">Version 1.34.0</a></h3>







<ul>






  <li><a href="i18n.html#Internationalization">国际化Internationalization</a>, 由类模板 <i>basic_path</i>, <i>basic_filesystem_error</i>, 和 <i>
  basic_directory_iterator</i> 提供。</li>






  <li><a href="i18n.html#Simplification">简化Simplification</a> 了路径的接口，包括取消了原生格式和通用格式的区别，以及将名字检查功能从通用路径功能中分离出来。</li>






  <li><a href="i18n.html#Rationalization">合理化Rationalization</a> 的断言函数设计，包括增加了几个新的函数。</li>






  <li>尽可能 <a href="i18n.html#Preservation">保留Preservation</a> 已有的用户代码。为了旧代码保留了不再推荐的特性(<i>symbolic_link_exists()</i>, 等)。</li>






  <li>更清晰的规格说明，引用了 [<a href="design.htm#POSIX-01">POSIX-01</a>], 
  ISO/IEEE Single Unix Standard, 以及 Windows 和其它操作系统的规定。</li>






  <li>新增函数 <a href="reference.html#Status-functions">status</a>,
  <a href="reference.html#Status-functions">symlink_status</a>,
  <a href="reference.html#Predicate-functions">is_file</a>,
  <a href="reference.html#Predicate-functions">is_symlink</a>,
  <a href="reference.html#Operations-functions">create_hard_link</a>, 
  <a href="reference.html#Operations-functions">create_symlink</a>, path 的成员和非成员 swap, path 插入器, path 
  提取器, 其它 path 关系和 "/" 操作符重载，其它接受迭代器参数的 
  path 成员模板函数。</li>






  <li>在目录中进行遍历时，<span style="text-decoration: underline;"></span><a href="i18n.html#More_efficient">操作更为高效</a></li>






  <li>单独实现原生操作系统路径语法与API之间的区别。这对于 CYGWIN 用户是非常重要的，因为这样他们就可以同时为 Windows 或 POSIX API 进行构建。</li>






  <li>多个小的实现修正。</li>






</ul>







<h3>版本 1.33.0</h3>







<ul>






  <li>一些小的实现修正。</li>






</ul>







<h3>版本 1.32.0</h3>







<ul>






  <li>新增 <a href="reference.html#Attribute-functions">file_size()</a> 函数。</li>






  <li>增加了类 path <a href="reference.html#basic_path-non-member-functions">关系操作符</a>。</li>






  <li>新增 <a href="reference.html#Predicate-functions">equivalent()</a> 函数。&nbsp;</li>






  <li>如果目录已存在，<a href="reference.html#Operations-functions">create_directory()</a> 不再抛出异常。返回一个 bool 值，表示该目录不是未存在的。<a href="reference.html#Convenience-functions">create_directories()</a> 也有同样的修改。</li>






  <li>为希望在 Windows 上使用 Cygwin/POSIX 的用户 <a href="index.htm#Cgywin">增加了文档</a>。</li>






  <li>对于 POSIX, 需要时可以支持大文件(LSF)，如在 Linux 上。</li>






  <li>POSIX 上的 <a href="reference.html#initial_path">current_path()</a> 和
  <a href="reference.html#initial_path">initial_path()</a> 现在可以正确处理超长路径了。</li>






</ul>







<h3>版本 1.31.0</h3>







<ul>






  <li>现在目标库可以 <a href="#Building">构建built</a> 为静态或动态(shared/dll)链接。 </li>






  <li>新增了几个函数，包括改进了目录和文件名检查的可移植性。请见 <a href="portability_guide.htm#name_check%C3%83%E2%80%9A%C3%82%C2%AD_functions">
  名字检查函数</a>。</li>






  <li>典型格式和标准格式的分离，以及新增一个 path 成员函数 normalize(). 这改变了库的行为，这样典型格式有所不同了，但消除了一个微妙的 <a href="design.htm#symbolic-link-use-case">bug</a>，以支持目录的符号链接。 </li>






</ul>







<hr>
<p>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->18 March, 2008<!--webbot bot="Timestamp" endspan i-checksum="29005" --></p>







<p>&Acirc;&copy; Copyright Beman Dawes, 2002-2005</p>






<p> Use, modification, and distribution are subject to the Boost Software 
License, Version 1.0. See <a href="http://www.boost.org/LICENSE_1_0.txt">
www.boost.org/LICENSE_1_0.txt</a></p>







</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta http-equiv="Content-Language" content="en-us">

  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">

  <meta name="ProgId" content="FrontPage.Editor.Document">

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <link rel="stylesheet" type="text/css" href="../../../boost.css">
  <title>The Boost Statechart Library - Definitions</title>


</head>



<body link="#0000ff" vlink="#800080">

<table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">

  <tbody>

    <tr>

      <td valign="top" width="300">
      <h3><a href="../../../index.htm"><img alt="C++ Boost" src="../../../boost.png" border="0" height="86" width="277"></a></h3>

      </td>

      <td valign="top">
      <h1 align="center">Boost Statechart 库</h1>

      <h2 align="center">UML 到 Boost.Statechart 的映射概要</h2>

      </td>

    </tr>

  </tbody>
</table>

<hr>
<h2>Contents 目录</h2>

<dl class="page-index">

  <dt><a href="#StateMachine">State machine 状态机</a></dt>

  <dt><a href="#States">States 状态</a></dt>

  <dd><a href="#NormalState">Normal state 普通状态</a></dd>

  <dd><a href="#InitialPseudostate">Initial
pseudostate 初始伪状态</a></dd>

  <dd><a href="#FinalPseudostate">Final pseudostate 结束伪状态</a></dd>

  <dd><a href="#ShallowHistoryPseudostate">Shallow
history pseudostate 浅历史伪状态</a></dd>

  <dd><a href="#DeepHistoryPseudostate">Deep history
pseudostate 深历史伪状态</a></dd>

  <dd><a href="#JunctionPoint">Junction point 汇合点</a></dd>

  <dd><a href="#DynamicChoicePoint">Dynamic choice
point 动态选择点</a></dd>

  <dd><a href="#JoinAndForkBars">Join and fork bars
汇合与分叉条</a></dd>

  <dt><a href="#Events">Events 事件</a></dt>

  <dd><a href="#CallEvent">Call event 调用事件</a></dd>

  <dd><a href="#SignalEvent">Signal event 信号事件</a></dd>

  <dd><a href="#TimeEvent">Time event 时间事件</a></dd>

  <dd><a href="#ChangeEvent">Change event 转变事件</a></dd>

  <dt><a href="#Reactions">Reactions 反应</a></dt>

  <dd><a href="#Guard">Guard 警戒</a></dd>

  <dd><a href="#Transition">Transition 转换</a></dd>

  <dd><a href="#Deferral">Deferral 延迟</a></dd>

  <dd><a href="#InternalTransition">Internal
transition (in-state reaction) 内部转换(状态内反应)</a></dd>

  <dt><a href="#Actions">Actions 动作</a></dt>

  <dd><a href="#EntryAction">Entry action 进入动作</a></dd>

  <dd><a href="#ExitAction">Exit action 退出动作</a></dd>

  <dd><a href="#TransitionAction">Transition action
转换动作</a></dd>

  <dd><a href="#DoActivity">Do activity&nbsp;</a></dd>

</dl>

<hr>
<h2><a name="StateMachine" id="StateMachine">State
machine 状态机</a></h2>

<ul>

  <li>A state machine is defined by deriving a class from either
the <code><a href="reference.html#ClassTemplatestate_machine">state_machine</a></code>
or the <code><a href="reference.html#ClassTemplateasynchronous_state_machine">asynchronous_state_machine</a></code>
class templates; <a href="tutorial.html#DefiningStatesAndEvents">example</a>
    <br>
状态机是通过派生自 <code><a href="reference.html#ClassTemplatestate_machine">state_machine</a></code>
或 <code><a href="reference.html#ClassTemplateasynchronous_state_machine">asynchronous_state_machine</a></code>
类模板的类来定义的；<a href="tutorial.html#DefiningStatesAndEvents">例子</a></li>

</ul>

<h2><a name="States" id="States">States 状态</a></h2>

<h3><a name="NormalState" id="NormalState">Normal
state 普通状态</a></h3>

<ul>

  <li>A state is defined by deriving a class from either the <code><a href="reference.html#ClassTemplatesimple_state">simple_state</a></code>
or <code><a href="reference.html#ClassTemplatestate">state</a></code>
class templates; <a href="tutorial.html#DefiningStatesAndEvents">example</a></li>
  <li>The position of a state in the state hierarchy is defined
by what is passed as the <code>Context</code> template
parameter. <a href="definitions.html#OutermostState">Outermost
states</a> pass the <code><a href="reference.html#ClassTemplatestate_machine">state_machine&lt;&gt;</a></code>
or <code><a href="reference.html#ClassTemplateasynchronous_state_machine">asynchronous_state_machine&lt;&gt;</a></code>
subtype they belong to, inner states pass their direct outer state; <a href="tutorial.html#DefiningStatesAndEvents">example</a></li>
  <li>A state can be made a member of a particular orthogonal
region by passing an instantiation of the <code>orthogonal</code>
class template nested in its outer state; <a href="tutorial.html#OrthogonalStates">example</a></li>
  <li>状态是通过派生自 <code><a href="reference.html#ClassTemplatesimple_state">simple_state</a></code> 或 <code><a href="reference.html#ClassTemplatestate">state</a></code>
类模板的类来定义的；<a href="tutorial.html#DefiningStatesAndEvents">例子</a></li>

  <li>一个状态在状态层次中的位置是通过 <code>Context</code> 模板参数来定义的。<a href="definitions.html#OutermostState">最外层状态</a> 以它所属的 <code><a href="reference.html#ClassTemplatestate_machine">state_machine&lt;&gt;</a></code> 或 <code><a href="reference.html#ClassTemplateasynchronous_state_machine">asynchronous_state_machine&lt;&gt;</a></code>
子类型作为参数，内层状态则以它的直接外层状态作为参数；<a href="tutorial.html#DefiningStatesAndEvents">例子</a></li>

  <li>状态可以作为某个特定的正交区域的成员，方法是传递其外层状态的一个 <code>orthogonal</code>
类模板的实例；<a href="tutorial.html#OrthogonalStates">例子</a></li>

</ul>

<h3><a name="InitialPseudostate" id="InitialPseudostate">Initial
pseudostate 初始伪状态</a></h3>

<ul>

  <li>The state that is initially entered is identified by
template parameters rather than by a default transition from the
initial pseudostate (there is no such thing in Boost.Statechart)</li>
  <li>For <code><a href="reference.html#ClassTemplatestate_machine">state_machine&lt;&gt;</a></code>
and <code><a href="reference.html#ClassTemplateasynchronous_state_machine">asynchronous_state_machine&lt;&gt;</a></code>
the state that is initially entered needs to be specified with the <code>InitialState</code>
template parameter; <a href="tutorial.html#DefiningStatesAndEvents">example</a></li>
  <li>For <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
and <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
the inner state(s) that is/are initially entered can be specified with
the <code>InnerInitial</code> template parameter; <a href="tutorial.html#DefiningStatesAndEvents">example</a></li>
  <li>初始化时进入的状态由模板参数来标识，而不是由初始伪状态(在 Boost.Statechart 没有这个东西)的缺省转换来标识</li>

  <li>对于 <code><a href="reference.html#ClassTemplatestate_machine">state_machine&lt;&gt;</a></code> 和 <code><a href="reference.html#ClassTemplateasynchronous_state_machine">asynchronous_state_machine&lt;&gt;</a></code>，初始化时进入的状态必须以 <code>InitialState</code>
模板参数来指定；<a href="tutorial.html#DefiningStatesAndEvents">例子</a></li>

  <li>对于 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code> 和 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>，初始化时进入的内层状态可以通过 <code>InnerInitial</code> 模板参数来指定；<a href="tutorial.html#DefiningStatesAndEvents">例子</a></li>

</ul>

<h3><a name="FinalPseudostate" id="FinalPseudostate">Final
pseudostate 结束伪状态</a></h3>

<ul>

  <li>There is no such thing as a final pseudostate in
Boost.Statechart</li>
  <li>This functionality is implemented with a special reaction (<code><a href="reference.html#ClassTemplatetermination">termination&lt;&gt;</a></code>)
and special reaction function (<code><a href="reference.html#simple_state::terminate">simple_state&lt;&gt;::terminate()</a></code>);
    <a href="tutorial.html#StateQueries">example</a></li>
  <li>在
Boost.Statechart 中没有结束伪状态这样的东西</li>

  <li>该功能通过一个特殊的反应(<code><a href="reference.html#ClassTemplatetermination">termination&lt;&gt;</a></code>)和特殊的反应函数(<code><a href="reference.html#simple_state::terminate">simple_state&lt;&gt;::terminate()</a></code>)来实现；<a href="tutorial.html#StateQueries">例子</a></li>

</ul>

<h3><a name="ShallowHistoryPseudostate" id="ShallowHistoryPseudostate">Shallow history pseudostate 浅历史伪状态</a></h3>

<ul>

  <li>A shallow history transition target or shallow history
inner initial state can be specified with <code><a href="reference.html#ClassTemplateshallow_history">shallow_history&lt;&gt;</a></code></li>
  <li><code></code>浅历史转换目标或浅历史内层初始状态可以通过 <code><a href="reference.html#ClassTemplateshallow_history">shallow_history&lt;&gt;</a></code> 来指定<code><a href="reference.html#ClassTemplateshallow_history"></a></code></li>

</ul>

<h3><a name="DeepHistoryPseudostate" id="DeepHistoryPseudostate">Deep history pseudostate 深历史伪状态</a></h3>

<ul>

  <li>A deep history transition target or deep history inner
initial state can be specified with <code><a href="reference.html#ClassTemplatedeep_history">deep_history&lt;&gt;</a></code>;
    <a href="tutorial.html#History">example</a></li>
  <li>深历史转换目标或深历史内层初始状态可以通过 <code><a href="reference.html#ClassTemplatedeep_history">deep_history&lt;&gt;</a></code> 来指定；<a href="tutorial.html#History">例子</a></li>

</ul>

<h3><a name="JunctionPoint" id="JunctionPoint">Junction
point 汇合点</a></h3>

<ul>

  <li>Does not exist in Boost.Statechart; <a href="rationale.html#Limitations">rationale</a></li>
  <li>在 Boost.Statechart 中不存在；<a href="rationale.html#Limitations">原理</a></li>

</ul>

<h3><a name="DynamicChoicePoint" id="DynamicChoicePoint">Dynamic
choice point 动态选择点</a></h3>

<ul>

  <li>Does not (yet?) exist in Boost.Statechart; <a href="rationale.html#Limitations">rationale</a></li>
  <li>在 Boost.Statechart 中(尚)不存在；<a href="rationale.html#Limitations">原理</a></li>

</ul>

<h3><a name="JoinAndForkBars" id="JoinAndForkBars">Join
and fork bars 汇合与分叉条</a></h3>

<ul>

  <li>Do not exist in Boost.Statechart; <a href="rationale.html#Limitations">rationale</a></li>
  <li>在 Boost.Statechart 中不存在；<a href="rationale.html#Limitations">原理</a></li>

</ul>

<h2><a name="Events" id="Events">Events 事件</a></h2>

<ul>

  <li>A event is defined by deriving a class from the <a href="reference.html#ClassTemplateevent"><code>event</code></a>
class template; <a href="tutorial.html#DefiningStatesAndEvents">example</a></li>
  <li>There is no distinction between signal and call events, see
below</li>
  <li>事件是通过派生自 <a href="reference.html#ClassTemplateevent"><code>event</code></a>
类模板的类来定义的；<a href="tutorial.html#DefiningStatesAndEvents">例子</a></li>

  <li>信号和调用事件没有区别，详见下文</li>

</ul>

<h3><a name="CallEvent" id="CallEvent">Call
event 调用事件</a></h3>

<ul>

  <li>All events passed to <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event()</a></code>
are implicitly call events</li>
  <li>所有传递给 <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event()</a></code>
的事件都是调用事件</li>

</ul>

<h3><a name="SignalEvent" id="SignalEvent">Signal
event 信号事件</a></h3>

<ul>

  <li>All events passed to either <code><a href="reference.html#post_event0">simple_state&lt;&gt;::post_event()</a></code>
or <code><a href="reference.html#queue_event">fifo_scheduler&lt;&gt;::queue_event()</a></code>
are implicitly signal events</li>
  <li>所有传递给 <code><a href="reference.html#post_event0">simple_state&lt;&gt;::post_event()</a></code> 或 <code><a href="reference.html#queue_event">fifo_scheduler&lt;&gt;::queue_event()</a></code>
的事件都是信号事件</li>

</ul>

<h3><a name="TimeEvent" id="TimeEvent">Time
event 时间事件</a></h3>

<ul>

  <li>Does not exist in Boost.Statechart</li>
  <li>A time event can be simulated with an external timer that
is started in the entry action and stopped in the exit action of a
particular state. When starting the timer, it is instructed to call <code><a href="reference.html#queue_event">fifo_scheduler&lt;&gt;::queue_event()</a></code>
when the due time elapses</li>
  <li>在 Boost.Statechart 中存在</li>

  <li>时间事件可以通过外部定时器来模拟，定时器在特定状态的进入动作中开始，在退出动作中停止。在定时器开始时，它指定在特定的时间调用 <code><a href="reference.html#queue_event">fifo_scheduler&lt;&gt;::queue_event()</a></code>&nbsp;</li>

</ul>

<h3><a name="ChangeEvent" id="ChangeEvent">Change
event 转变事件</a></h3>

<ul>

  <li>Does not exist in Boost.Statechart</li>
  <li>A change event can be simulated by packing to be monitored
variables into an external wrapper with <code>get</code>
and <code>set</code> methods. Whenever <code>set</code>
is called the wrapper posts an appropriate event</li>
  <li>在 Boost.Statechart 中不存在</li>

  <li>转变事件可以通过将被监测变量包装到一个带 <code>get</code> 和 <code>set</code> 方法的外部包装器中来模拟。无论何时调用 <code>set</code>，该包装器都会发出适当的事件</li>

</ul>

<h2><a name="Reactions" id="Reactions">Reactions 反应</a></h2>

<h3><a name="Guard" id="Guard">Guard 警戒</a></h3>

<ul>

  <li>A guard can be implemented with a selection statement in a <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>;
    <a href="tutorial.html#Guards">example</a></li>
  <li>警戒可以通过 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code> 中的选择语句来实现；<a href="tutorial.html#Guards">例子</a></li>

</ul>

<h3><a name="Transition" id="Transition">Transition 转换</a></h3>

<ul>

  <li>A transition can be defined with either a <code><a href="reference.html#ClassTemplatetransition">transition&lt;&gt;</a></code>
or a call to <code><a href="reference.html#transit1">simple_state&lt;&gt;::transit&lt;&gt;</a></code>
in a <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>;
    <a href="tutorial.html#AddingReactions">example</a></li>
  <li>转换可以通过 <code><a href="reference.html#ClassTemplatetransition">transition&lt;&gt;</a></code>
或在 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code> 中对 <code><a href="reference.html#transit1">simple_state&lt;&gt;::transit&lt;&gt;</a></code>
的调用来定义；<a href="tutorial.html#AddingReactions">例子</a></li>

</ul>

<h3><a name="Deferral" id="Deferral">Deferral 延迟</a></h3>

<ul>

  <li>A deferral reaction can be defined with either a <code><a href="reference.html#ClassTemplatedeferral">deferral&lt;&gt;</a></code>
or a call to <code><a href="reference.html#defer_event">simple_state&lt;&gt;::defer_event()</a></code>
in a <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>;
    <a href="tutorial.html#DeferringEvents">example</a></li>
  <li>延迟反应可以通过 <code><a href="reference.html#ClassTemplatedeferral">deferral&lt;&gt;</a></code>
或在 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code> 中对 <code><a href="reference.html#defer_event">simple_state&lt;&gt;::defer_event()</a></code>
的调用来定义；<a href="tutorial.html#DeferringEvents">例子</a></li>

</ul>

<h3><a name="InternalTransition" id="InternalTransition">Internal
transition (in-state reaction) 内部转换(状态内反应)</a></h3>

<ul>

  <li>An in-state reaction can be defined with either a <code><a href="reference.html#ClassTemplatein_state_reaction">in_state_reaction&lt;&gt;</a></code>
or a call to <a href="reference.html#discard_event"><code>simple_state&lt;&gt;::discard_event()</code></a>
in a <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code></li>
  <li><code></code>状态内反应可以通过 <code><a href="reference.html#ClassTemplatein_state_reaction">in_state_reaction&lt;&gt;</a></code>
或在 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code> 中对 <a href="reference.html#discard_event"><code>simple_state&lt;&gt;::discard_event()</code></a>
的调用来定义<code><a href="reference.html#ClassTemplatecustom_reaction"></a></code></li>

</ul>

<h2><a name="Actions" id="Actions">Actions 动作</a></h2>

<h3><a name="EntryAction" id="EntryAction">Entry
action 进入动作</a></h3>

<ul>

  <li>A state entry action can be defined by adding a constructor
to a state class; <a href="tutorial.html#HelloWorld">example</a></li>
  <li>状态进入动作可以通过为状态类增加一个构造函数来定义；<a href="tutorial.html#HelloWorld">例子</a></li>

</ul>

<h3><a name="ExitAction" id="ExitAction">Exit
action 退出动作</a></h3>

<ul>

  <li>A state exit action can be defined by adding a destructor
to a state class; <a href="tutorial.html#HelloWorld">example</a></li>
  <li>状态退出动作可以通过为状态类增加一个析构函数来定义；<a href="tutorial.html#HelloWorld">例子</a></li>

</ul>

<h3><a name="TransitionAction" id="TransitionAction">Transition
action 转换动作</a></h3>

<ul>

  <li>A transition action can be defined by passing a function
pointer referencing the action to either <code><a href="reference.html#ClassTemplatetransition">transition&lt;&gt;</a></code>
or <code><a href="reference.html#transit2">simple_state&lt;&gt;::transit&lt;&gt;()</a></code>;
    <a href="tutorial.html#TransitionActions">example</a></li>
  <li>转换动作可能通过将一个引向该动作的函数指针传给 <code><a href="reference.html#ClassTemplatetransition">transition&lt;&gt;</a></code> 或 <code><a href="reference.html#transit2">simple_state&lt;&gt;::transit&lt;&gt;()</a></code> 来定义；<a href="tutorial.html#TransitionActions">例子</a></li>

</ul>

<h3><a name="DoActivity" id="DoActivity">Do
activity</a></h3>

<ul>

  <li>在&nbsp;Boost.Statechart 中不存在</li>

  <li>do activity 可以通过一个独立的线程来模拟，该线程在特定状态的进入动作中被开始，在退出动作中被取消</li>

</ul>

<hr>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Transitional" border="0" height="31" width="88"></a></p>

<p>Revised<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
03 December, 2006<!--webbot bot="Timestamp" endspan i-checksum="38512" --></p>

<p><i>Copyright &copy; 2003-<!--webbot bot="Timestamp" s-type="EDITED" s-format="%Y" startspan -->2006<!--webbot bot="Timestamp" endspan i-checksum="770" -->
<a href="contact.html">Andreas Huber D&ouml;nni</a></i></p>

<p><i>Distributed under the Boost Software License, Version
1.0. (See accompanying file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a>
or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>

</body>
</html>

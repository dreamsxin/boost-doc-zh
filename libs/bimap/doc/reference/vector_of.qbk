[/license

Boost.Bimap

Copyright (c) 2006-2007 Matias Capeletto

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)

]

[/ QuickBook Document version 1.4 ]

[section:vector_of_reference vector_of Reference  vector_of参考]

[section Header "boost/bimap/vector_of.hpp" synopsis]

    namespace boost {
    namespace bimaps {


    template< class KeyType >
    struct vector_of;

    struct vector_of_relation;


    } // namespace bimap
    } // namespace boost


[endsect]

[section:vector_of_views vector_of views  vector_of视图]

vector_of views are free-order sequences with constant time positional
access and random access iterators. Elements in a vector_of view are by
default sorted according to their order of insertion: this means that new elements
inserted through a different view of the `bimap` are appended to
the end of the vector_of view; additionally, facilities are provided for
further rearrangement of the elements. The public interface of vector_of views
includes that of list_of views, with differences in the complexity
of the operations, plus extra operations for positional access
(`operator[]` and `at()`) and for capacity handling. Validity of iterators and
references to elements is preserved in all operations, regardless of the
capacity status.\n
vector_of 视图是自由序的序列，它具有常数时间的位置访问和随机访问迭代器。一个 vector_of 视图中的元素缺省是按插入的顺序来排序的：
这意味着通过 `bimap` 的其它视图所插入的新元素会被增加到 vector_of 视图的尾部；另外还提供了元素的重排序功能。
vector_of 的公有接口包含了 list_of 视图的接口，但操作的复杂度有所不同，另外还有位置访问的操作(`operator[]` 和 `at()`)和容量操作。
在所有操作中，迭代器和元素引用的有效性被保持，无论容量状态如何。

As is the case with list_of views, vector_of views have the following
limitations with respect to STL sequence containers:\n
和 list_of 视图的情况相似，vector_of 视图与STL序列容器相比有以下限制：

* vector_of views
are not __SGI_ASSIGNABLE__ (like any other view.)\n
  vector_of 视图不是 __SGI_ASSIGNABLE__ (和其它视图一样)。
* Insertions into a vector_of view may fail due to clashings with other views.
This alters the semantics of the operations provided with respect to their analogues
in STL sequence containers.\n
  插入到 vector_of 视图中有可能因为其它视图的冲突而失败。与STL序列容器中的对照物相比，各种操作的语义有所改变。
* Elements in a vector_of view are not mutable, and can only be changed by
means of replace and modify member functions.\n
  一个 vector_of 视图中的元素是不可以直接修改的，只能通过 replace 和 modify 成员函数来修改。

Having these restrictions into account, vector of views are models of
__SGI_RANDOM_ACCESS_CONTAINER__ and __SGI_BACK_INSERTION_SEQUENCE__. Although these views
do not model __SGI_FRONT_INSERTION_SEQUENCE__, because front insertion and deletion
take linear time, front operations are nonetheless provided to match the interface
of list_of views. We only describe those types and operations that are either
not present in the concepts modeled or do not exactly conform to the requirements
for these types of containers.\n
有了这些限制，vector_of 视图符合 __SGI_RANDOM_ACCESS_CONTAINER__ 和 __SGI_BACK_INSERTION_SEQUENCE__ 概念。
但该视图不符合 __SGI_FRONT_INSERTION_SEQUENCE__ 概念，因为前端的插入和删除需要线性时间，尽管如此，为了与 list_of 视图的接口相匹配，
还是提供了前端操作。我们仅对那些在以上概念模型中没有，或者与此类容器要求不完全一致的类型和操作进行说明。


    namespace boost {
    namespace bimaps {
    namespace views {

    template< ``['-implementation defined parameter list-]`` >
    class ``['-implementation defined view name-]``
    {
        public:

        // types

        typedef ``['-unspecified-]`` value_type;
        typedef ``['-unspecified-]`` allocator_type;
        typedef ``['-unspecified-]`` reference;
        typedef ``['-unspecified-]`` const_reference;
        typedef ``['-unspecified-]`` iterator;
        typedef ``['-unspecified-]`` const_iterator;
        typedef ``['-unspecified-]`` size_type;
        typedef ``['-unspecified-]`` difference_type;
        typedef ``['-unspecified-]`` pointer;
        typedef ``['-unspecified-]`` const_pointer;
        typedef ``['-unspecified-]`` reverse_iterator;
        typedef ``['-unspecified-]`` const_reverse_iterator;

        typedef ``['-unspecified-]`` info_type;

        // construct / copy / destroy

        this_type & operator=(this_type & x);

        template< class InputIterator >
        void ``[link reference_vector_of_assign_iterator_iterator assign]``(InputIterator first, InputIterator last);

        void ``[link reference_vector_of_assign_size_value assign]``(size_type n, const value_type & value);

        allocator_type get_allocator() const;

        // iterators

        iterator               begin();
        const_iterator         begin() const;

        iterator               end();
        const_iterator         end() const;

        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;

        reverse_iterator       rend();
        const_reverse_iterator rend() const;

        // capacity

        bool      empty() const;

        size_type size() const;

        size_type max_size() const;

        size_type ``[link reference_vector_of_capacity capacity]``() const;

        void ``[link reference_vector_of_reserve_size reserve]``(size_type m);

        void ``[link reference_vector_of_resize_size_value resize]``(size_type n, const value_type & x = value_type());

        // access

        const_reference operator[](size_type n) const;

        const_reference at(size_type n) const;

        const_reference front() const;

        const_reference back() const;

        // modifiers

        std::pair<iterator,bool> ``[link reference_vector_of_push_front_value push_front]``(const value_type & x);
        void                     pop_front();

        std::pair<iterator,bool> ``[link reference_vector_of_push_back_value push_back]``(const value_type & x);
        void                     pop_back();

        std::pair<iterator,bool> ``[link reference_vector_of_insert_iterator_value insert]``(iterator position, const value_type & x);

        void ``[link reference_vector_of_insert_iterator_size_value insert]``(iterator position, size_type m, const value_type & x);

        template< class InputIterator>
        void ``[link reference_vector_of_insert_iterator_iterator_iterator insert]``(iterator position, InputIterator first, InputIterator last);

        iterator ``[link reference_vector_of_erase_iterator erase]``(iterator position);
        iterator ``[link reference_vector_of_erase_iterator_iterator erase]``(iterator first, iterator last);

        bool ``[link reference_vector_of_replace_iterator_value replace]``(iterator position, const value_type & x);

        // Only in map views
        // {

          template< class CompatibleKey >
          bool ``[link reference_vector_of_replace_key_iterator_key replace_key]``(iterator position, const CompatibleKey & x);

          template< class CompatibleData >
          bool ``[link reference_vector_of_replace_data_iterator_data replace_data]``(iterator position, const CompatibleData & x);

          template< class KeyModifier >
          bool ``[link reference_vector_of_modify_key_iterator_modifier modify_key]``(iterator position, KeyModifier mod);

          template< class DataModifier >
          bool ``[link reference_vector_of_modify_data_iterator_modifier modify_data]``(iterator position, DataModifier mod);

        // }


        void clear();

        // list operations

        void ``[link reference_vector_of_splice_iterator_this splice]``(iterator position, this_type & x);
        void ``[link reference_vector_of_splice_iterator_this_iterator splice]``(iterator position, this_type & x, iterator i);
        void ``[link reference_vector_of_splice_iterator_this_iterator_iterator splice]``(
            iterator position, this_type & x, iterator first, iterator last);

        void ``[link reference_vector_of_remove_value remove]``(const value_type & value);

        template< class Predicate >
        void ``[link reference_vector_of_remove_if_predicate remove_if]``(Predicate pred);

        void ``[link reference_vector_of_unique unique]``();

        template< class BinaryPredicate >
        void ``[link reference_vector_of_unique_predicate unique]``(BinaryPredicate binary_pred);

        void ``[link reference_vector_of_merge_this merge]``(this_type & x);

        template< typename Compare >
        void ``[link reference_vector_of_merge_this_compare merge]``(this_type & x, Compare comp);

        void ``[link reference_vector_of_sort sort]``();

        template< typename Compare >
        void ``[link reference_vector_of_sort_compare sort]``(Compare comp);

        void ``[link reference_vector_of_reverse reverse]``();

        // rearrange operations

        void ``[link reference_vector_of_relocate_iterator_iterator relocate]``(iterator position, iterator i);
        void ``[link reference_vector_of_relocate_iterator_iterator_iterator relocate]``(iterator position, iterator first, iterator last);
    };

    // view comparison

    bool operator==(const this_type & v1, const this_type & v2 );
    bool operator< (const this_type & v1, const this_type & v2 );
    bool operator!=(const this_type & v1, const this_type & v2 );
    bool operator> (const this_type & v1, const this_type & v2 );
    bool operator>=(const this_type & v1, const this_type & v2 );
    bool operator<=(const this_type & v1, const this_type & v2 );

    } // namespace views
    } // namespace bimap
    } // namespace boost



In the case of a `bimap< vector_of<Left>, ... >`\n
对于一个 `bimap< vector_of<Left>, ... >`

In the set view:\n
在集合视图中：

    typedef signature-compatible with relation< Left, ... > key_type;
    typedef signature-compatible with relation< Left, ... > value_type;

In the left map view:\n
在左映射视图中：

    typedef  Left  key_type;
    typedef  ...   data_type;

    typedef signature-compatible with std::pair< Left, ... > value_type;

In the right map view:\n
在右映射视图中：

    typedef  ...  key_type;
    typedef  Left data_type;

    typedef signature-compatible with std::pair< ... , Left > value_type;


[#vector_of_complexity_signature]

[section:complexity_signature Complexity signature 复杂度签名]

Here and in the descriptions of operations of `vector_of` views, we adopt
the scheme outlined in the
[link complexity_signature_explanation complexity signature section].
The complexity signature of `vector_of` view is:\n
在以下对 `vector_of` 视图的操作说明中，我们采用在 [link complexity_signature_explanation 复杂度签名一节] 中给出的方式来描述。
`vector_of` 视图的复杂度签名为：

* copying: `c(n) = n * log(n)`,\n
  复制：`c(n) = n * log(n)`, 
* insertion: `i(n) = 1` (amortized constant),\n
  插入：`i(n) = 1` (分期常数), 
* hinted insertion: `h(n) = 1` (amortized constant),\n
  提示插入：`h(n) = 1` (分期常数), 
* deletion: `d(n) = m`, where m is the distance from the deleted element to the
end of the sequence,\n
  删除：`d(n) = m`，其中 m 为被删元素与序列尾部的距离,
* replacement: `r(n) = 1` (constant),\n
  替换：`r(n) = 1` (常数), 
* modifying: `m(n) = 1` (constant).\n
  修改：`m(n) = 1` (常数), 

The following expressions are also used as a convenience for writing down some
of the complexity formulas:\n
以下表达式会在某些复杂度公式中使用：

[blurb
`shl(a,b) = a+b` if a is nonzero, 0 otherwise.
`rel(a,b,c) =` if `a<b`, `c-a`, else `a-b`,\n
`shl(a,b) = a+b` 如果 a 为非零，否则为 0。
`rel(a,b,c) =` 如果 `a<b`, `c-a`, 否则 `a-b`,
]

(`shl` and `rel` stand for ['shift left] and ['relocate], respectively.)\n
(`shl` 和 `rel` 分别表示 ['左移] 和 ['重定位]。) 

[endsect]

[section:instantiation_types Instantiation types 实例化类型]

`vector_of` views are instantiated internally to `bimap` and specified
by means of the collection type specifiers and the bimap itself.
Instantiations are dependent on the following types:\n
`vector_of` 视图在一个 `bimap` 的内部根据组合类型指示符和 `bimap` 本身进行实例化。实例化取决于以下类型：

* `Value` from `vector_of`,\n
  来自 `vector_of` 的 `Value`,
* `Allocator` from `bimap`,\n
  来自 `bimap` 的 `Allocator`, 

[endsect]

[section:constructors__copy_and_assignment Constructors, copy and assignment 构造函数、复制和赋值]

As explained in the views concepts section,
views do not have public constructors or destructors.
Assignment, on the other hand, is provided.\n
如视图概念一节中所解释的，视图没有公有的构造函数和析构函数。而另一方面，赋值操作则是提供的。

    this_type & operator=(const this_type & x);

* [*Effects: ] `a=b;`
where a and b are the `bimap` objects to which `*this` and
`x` belong, respectively.\n
  [*效果：]`a = b;` 其中 a 和 b 分别为 `*this` 和 `x` 所属的 `bimap` 对象。
* [*Returns: ] `*this`.\n
  [*返回：]`*this`. 


[#reference_vector_of_assign_iterator_iterator]

    template< class InputIterator >
    void assign(InputIterator first, InputIterator last);

* [*Requires: ] `InputIterator` is a model of __SGI_INPUT_ITERATOR__ over elements
of type `value_type` or a type convertible to `value_type`. `first` and `last` are
not iterators into any view of the `bimap` to which this
view belongs. `last` is reachable from `first`.\n
  [*要求：]`InputIterator` 是类型 `value_type` 或可转换为 `value_type` 的类型的元素之上的 __SGI_INPUT_ITERATOR__。
  `first` 和 `last` 不是指向该索引所属 `bimap` 的任一视图的迭代器。`last` 可从 `first` 到达。
* [*Effects: ] `clear(); insert(end(),first,last);`\n
  [*效果：]`clear(); insert(end(),first,last);`


[#reference_vector_of_assign_size_value]

    void assign(size_type n, const value_type & value);

* [*Effects: ] `clear(); for(size_type i = 0; i < n; ++n) push_back(v);`\n
  [*效果：]`clear(); for(size_type i = 0; i < n; ++n) push_back(v);`

[endsect]

[section:capacity_operations Capacity operations 容量操作]

[#reference_vector_of_capacity]

    size_type capacity() const;

* [*Returns:] The total number of elements `c` such that, when `size() < c`,
back insertions happen in constant time (the general case as described by
i(n) is ['amortized] constant time.) \n
  [*返回：]元素总数 `c` 满足：当 `size() < c` 时，后端操作为常数时间(通常情况描述为 i(n) 为['分期]常数时间)。 
* [*Note:] Validity of iterators and references to elements is preserved
in all insertions, regardless of the capacity status.\n
  [*注：]在所有操作中，迭代器和元素引用的有效性被保持，无论容量状态如何。


[#reference_vector_of_reserve_size]

    void reserve(size_type m);

* [*Effects:] If the previous value of `capacity()` was greater than or equal
to `m`, nothing is done; otherwise, the internal capacity is changed so that
`capacity()>=m`.\n
  [*效果：]如果早前的 `capacity()` 值大于等于 `m`，则不做任何事；否则内部容量被修改以满足 `capacity()>=m`.
* [*Complexity:] If the capacity is not changed, constant; otherwise O(n).\n
  [*复杂度：]如果容量不变，则为常数；否则为 O(n)。 
* [*Exception safety:] If the capacity is not changed, nothrow; otherwise, strong.\n
  [*异常安全性：]如果容量不变，则无抛出；否则为强异常安全。


[#reference_vector_of_resize_size_value]

    void resize(size_type n, const value_type & x = value_type());

* [*Effects: ] `if( n > size() ) insert(end(), n-size(), x);`
`else if( n<size() ) erase(begin()+n,end());`\n
  [*效果：]`if( n > size() ) insert(end(), n-size(), x);`
`else if( n<size() ) erase(begin()+n,end());`
* [*Note:] If an expansion is requested, the size of the view is not guaranteed
to be n after this operation (other views may ban insertions.)\n
  [*注：]如果需要进行扩展，则该操作后视图的大小不保证为 n (其它视图可能禁止插入)。 


[endsect]

[section:modifiers Modifiers 修改器]

[#reference_vector_of_push_front_value]

    std::pair<iterator,bool> push_front(const value_type & x);

* [*Effects:] Inserts x at the beginning of the sequence if no other view
of the `bimap` bans the insertion.\n
  [*效果：]将 x 插入到序列的开头，如果 `bimap` 的其它视图没有禁止此插入操作。
* [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only if
insertion took place. On successful insertion, `p.first` points to the element
inserted; otherwise, `p.first` points to an element that caused the insertion
to be banned. Note that more than one element can be causing insertion not
to be allowed.\n
  [*返回：]返回值为一个值对 `p`。`p.second` 为 `true` 当且仅当插入成功。插入成功时，`p.first` 指向被插入的元素；
  否则，`p.first` 指向导致插入失败的元素。注意，可能会有一个以上的元素导致插入失败。
* [link vector_of_complexity_signature [*Complexity:]] O(n+I(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(n+I(n)).
* [*Exception safety:] Strong.\n
  [*异常安全性：]强。


[#reference_vector_of_push_back_value]

    std::pair<iterator,bool> push_back(const value_type & x);

* [*Effects:] Inserts `x` at the end of the sequence if no other view of
the `bimap` bans the insertion.\n
  [*效果：]将 `x` 插入到序列的尾部，如果 `bimap` 的其它视图没有禁止此插入操作。
* [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only
if insertion took place. On successful insertion, `p.first` points to the
element inserted; otherwise, `p.first` points to an element that caused
the insertion to be banned. Note that more than one element can be
causing insertion not to be allowed.\n
  [*返回：]返回值为一个值对 `p`。`p.second` 为 `true` 当且仅当插入成功。插入成功时，`p.first` 指向被插入的元素；
  否则，`p.first` 指向导致插入失败的元素。注意，可能会有一个以上的元素导致插入失败。
* [link vector_of_complexity_signature [*Complexity:]] O(I(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(I(n)).
* [*Exception safety:] Strong.\n
  [*异常安全性：]强。


[#reference_vector_of_insert_iterator_value]

    std::pair<iterator,bool> insert(iterator position, const value_type & x);

* [*Requires: ] `position` is a valid iterator of the view.\n
  [*要求：]`position` 为视图的有效迭代器。
* [*Effects:] Inserts `x` before position if insertion is allowed by all
other views of the `bimap`.\n
  [*效果：]将 `x` 插入 `position` 之前，如果 `bimap` 的其它视图没有禁止此插入操作。
* [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only
if insertion took place. On successful insertion, `p.first` points to the
element inserted; otherwise, `p.first` points to an element that caused the
insertion to be banned. Note that more than one element can be causing
insertion not to be allowed.\n
  [*返回：]返回值为一个值对 `p`。`p.second` 为 `true` 当且仅当插入成功。插入成功时，`p.first` 指向被插入的元素；
  否则，`p.first` 指向导致插入失败的元素。注意，可能会有一个以上的元素导致插入失败。
* [link vector_of_complexity_signature [*Complexity:]] O(shl(end()-position,1) + I(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(shl(end()-position,1) + I(n)).
* [*Exception safety:] Strong.\n
  [*异常安全性：]强。


[#reference_vector_of_insert_iterator_size_value]

    void insert(iterator position, size_type m, const value_type & x);

* [*Requires: ] `position` is a valid iterator of the view.\n
  [*要求：]`position` 为视图的有效迭代器。
* [*Effects: ] `for(size_type i = 0; i < m; ++i) insert(position, x);`\n
  [*效果：]`for(size_type i = 0; i < m; ++i) insert(position, x);`
* [link vector_of_complexity_signature
[*Complexity:]] O(shl(end()-position,m) + m*I(n+m)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(shl(end()-position,m) + m*I(n+m)).


[#reference_vector_of_insert_iterator_iterator_iterator]

    template< class InputIterator >
    void insert(iterator position, InputIterator first, InputIterator last);

* [*Requires: ] `position` is a valid iterator of the view. `InputIterator`
is a model of __SGI_INPUT_ITERATOR__ over elements of type `value_type` or a type
convertible to `value_type`. `first` and `last` are not iterators into any view
of the `bimap` to which this view belongs. `last` is reachable
from `first`.\n
  [*要求：]`position` 为视图的有效迭代器。`InputIterator` 是类型 `value_type` 或可转换为 `value_type` 
  的类型的元素之上的 __SGI_INPUT_ITERATOR__。`first` 和 `last` 不是指向该索引所属 `bimap` 的任一视图的迭代器。
  `last` 可从 `first` 到达。
* [*Effects: ] `while(first!=last)insert(position,*first++);`\n
  [*效果：]`while(first!=last)insert(position,*first++);`
* [link vector_of_complexity_signature
[*Complexity:]] O(shl(end()-position,m) + m*I(n+m)), where m is the number
of elements in `[first,last)`.\n
  [link vector_of_complexity_signature [*复杂度：]]O(shl(end()-position,m) + m*I(n+m))，其中 m 为 `[first,last)` 中的元素数量。
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_erase_iterator]

    iterator erase(iterator position);

* [*Requires: ] `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]`position` 为该集合视图的有效可提领迭代器。
* [*Effects:] Deletes the element pointed to by `position`.\n
  [*效果：]删除 `position` 所指的元素。
* [*Returns:] An iterator pointing to the element immediately following the
one that was deleted, or `end()` if no such element exists.\n
  [*返回：]指向紧跟在被删元素之后的元素的迭代器，如果不存在这样的元素，则返回 `end()`。 
* [link vector_of_complexity_signature [*Complexity:]] O(D(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(D(n)).
* [*Exception safety:] nothrow.\n
  [*异常安全性：]无抛出。


[#reference_vector_of_erase_iterator_iterator]

    iterator erase(iterator first, iterator last);

* [*Requires: ] `[first,last)` is a valid range of the view.\n
  [*要求：]`[first,last)` 为视图的有效区间。
* [*Effects:] Deletes the elements in `[first,last)`.\n
  [*效果：]删除 `[first,last)` 中所有元素。 
* [*Returns:] last.\n
  [*返回：]`last`.
* [link vector_of_complexity_signature
[*Complexity:]] O(m*D(n)), where m is the number of elements in `[first,last)`.\n
  [link vector_of_complexity_signature [*复杂度：]]O(m*D(n))，其中 m 为 `[first,last)` 中的元素数量。
* [*Exception safety:] nothrow.\n
  [*异常安全性：]无抛出。


[#reference_vector_of_replace_iterator_value]

    bool replace(iterator position, const value_type & x);

* [*Requires: ] `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]`position` 为该集合视图的有效可提领迭代器。
* [*Effects:] Assigns the value x to the element pointed to by position into
the `bimap` to which the view belongs if replacing is allowed
by all other views of the `bimap`.\n
  [*效果：]将值 `x` 赋给 `position` 所指的元素，如果替换操作被 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of position is preserved in all cases.\n
  [*后置条件：]在所有情形下，`position` 的有效性被保持。
* [*Returns: ] `true` if the replacement took place, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。 
* [link vector_of_complexity_signature
[*Complexity:]] O(R(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(R(n)).
* [*Exception safety:] Strong. If an exception is thrown by some user-provided
operation the `bimap` to which the view belongs remains in its
original state.\n
  [*异常安全性：]强。如果用户提供的某个操作抛出异常，则集合视图所属的 `bimap` 将保持原有状态。



[#reference_vector_of_replace_key_iterator_key]

    template< class CompatibleKey >
    bool replace_key(iterator position, const CompatibleKey & x);

* [*Requires: ] `position` is a valid dereferenceable iterator of the set view.
`CompatibleKey` can be assigned to `key_type`.\n
  [*要求：]`position` 为该集合视图的有效可提领迭代器。`CompatibleKey` 可以被赋值给 `key_type`. 
* [*Effects:] Assigns the value `x` to `e.first`, where `e` is the element pointed 
to by `position` into the `bimap` to which the set view belongs if replacing is allowed by
all other views of the `bimap`.\n
  [*效果：]将值 `x` 赋给 `e.first`，其中 `e` 为 `position` 所指的元素，如果替换操作被 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of position is preserved in all cases.\n
  [*后置条件：]在所有情形下，`position` 的有效性被保持。
* [*Returns: ] `true` if the replacement took place, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link vector_of_complexity_signature
[*Complexity:]] O(R(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(R(n)).
* [*Exception safety:] Strong. If an exception is thrown by some user-provided
operation, the `bimap` to which the set view belongs remains in
its original state.\n
  [*异常安全性：]强。如果用户提供的某个操作抛出异常，则集合视图所属的 `bimap` 将保持原有状态。


[#reference_vector_of_replace_data_iterator_data]

    template< class CompatibleData >
    bool replace_data(iterator position, const CompatibleData & x);

* [*Requires: ] `position` is a valid dereferenceable iterator of the set view.
`CompatibleKey` can be assigned to `data_type`.\n
  [*要求：]`position` 为该集合视图的有效可提领迭代器。`CompatibleKey` 可以被赋值给 `data_type`.
* [*Effects:] Assigns the value `x` to `e.second`, where `e` is the element pointed 
to by `position` into the `bimap` to which the set view belongs if replacing is allowed by
all other views of the `bimap`.\n
  [*效果：]将值 `x` 赋给 `e.second`，其中 `e` 为 `position` 所指的元素，如果替换操作被 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of position is preserved in all cases.\n
  [*后置条件：]在所有情形下，`position` 的有效性被保持。
* [*Returns: ] `true` if the replacement took place, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link vector_of_complexity_signature
[*Complexity:]] O(R(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(R(n)).
* [*Exception safety:] Strong. If an exception is thrown by some user-provided
operation, the `bimap` to which the set view belongs remains in
its original state.\n
  [*异常安全性：]强。如果用户提供的某个操作抛出异常，则集合视图所属的 `bimap` 将保持原有状态。


[#reference_vector_of_modify_key_iterator_modifier]

    template< class KeyModifier >
    bool modify_key(iterator position, KeyModifier mod);

* [*Requires: ] `KeyModifier` is a model of __SGI_UNARY_FUNCTION__ accepting arguments of
type: `key_type&`; `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]`KeyModifier` 是一个 单参函数，它接受的参数类型为 `key_type&`; `position` 为该视图的有效可提领迭代器。
* [*Effects:] Calls `mod(e.first)` where e is the element pointed to by position and 
rearranges `*position` into all the views of the `bimap`.
If the rearrangement fails, the element is erased.
It is successful if the rearrangement is allowed by all other views of the `bimap`.\n
  [*效果：]调用 `mod(e.first)`，其中 `e` 是 `position` 所指元素，对 `*position` 在 `bimap` 的所有视图中重排。
  如果重排失败，该元素将被删除。如果重排操作被 `bimap` 的其它视图所允许则重排成功。
* [*Postconditions:] Validity of `position` is preserved if the operation succeeds.\n
  [*后置条件：]如果操作成功，则 `position` 的有效性被保持。
* [*Returns: ] `true` if the operation succeeded, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link vector_of_complexity_signature
[*Complexity:]] O(M(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(M(n)).
* [*Exception safety:] Basic. If an exception is thrown by some user-provided
operation (except possibly mod), then the element pointed to by position is erased.\n
  [*异常安全性：]基本。如果用户提供的某个操作(除 mod 以外)抛出异常，则 `position` 所指元素被删除。
* [*Note:] Only provided for map views. \n
  [*注：]仅对映射视图提供。


[#reference_vector_of_modify_data_iterator_modifier]

    template< class DataModifier >
    bool modify_data(iterator position, DataModifier mod);

* [*Requires: ] `DataModifier` is a model of __SGI_UNARY_FUNCTION__ accepting arguments of
type: `data_type&`; `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]
* [*Effects:] Calls `mod(e.second)` where e is the element pointed to by position and 
rearranges `*position` into all the views of the `bimap`.
If the rearrangement fails, the element is erased.
It is successful if the rearrangement is allowed by all other views of the `bimap`.\n
  [*效果：]调用 `mod(e.second)`，其中 `e` 是 `position` 所指元素，对 `*position` 在 `bimap` 的所有视图中重排。
  如果重排失败，该元素将被删除。如果重排操作被 `bimap` 的其它视图所允许则重排成功。
* [*Postconditions:] Validity of `position` is preserved if the operation succeeds.\n
  [*后置条件：]如果操作成功，则 `position` 的有效性被保持。
* [*Returns: ] `true` if the operation succeeded, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link vector_of_complexity_signature
[*Complexity:]] O(M(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]O(M(n)).
* [*Exception safety:] Basic. If an exception is thrown by some user-provided
operation (except possibly mod), then the element pointed to by position is erased.\n
  [*异常安全性：]基本。如果用户提供的某个操作(除 mod 以外)抛出异常，则 `position` 所指元素被删除。
* [*Note:] Only provided for map views. \n
  [*注：]仅对映射视图提供。

[/
[#reference_vector_of_modify_iterator_modifier]

    template< class Modifier >
    bool modify(iterator position, Modifier mod);

* [*Requires: ] `Modifier` is a model of __SGI_BINARY_FUNCTION__ accepting arguments of
type: `first_type&` and `second_type&` for ['Map View] or `left_type&` and `right_type&`
for ['Set View]; `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]
* [*Effects:] Calls `mod(e.first,e.second)` for ['Map View:] or calls `mod(e.left,e.right)`
for ['Set View] where e is the element pointed to by `position` and
rearranges `*position` into all the views of the `bimap`.
Rearrangement on `vector_of` views does not change the position of the
element with respect to the view; rearrangement on other views may or
might not suceed. If the rearrangement fails, the element is erased.\n
  [*效果：]
* [*Postconditions:] Validity of `position` is preserved if the operation succeeds.\n
  [*后置条件：]
* [*Returns: ] `true` if the operation succeeded, `false` otherwise.\n
  [*返回：]
* [link vector_of_complexity_signature [*Complexity:]] O(M(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]
* [*Exception safety:] Basic. If an exception is thrown by some user-provided
operation (except possibly `mod`), then the element pointed to by position
is erased.
]


[endsect]

[section:list_operations List operations 列表操作]

`vector_of` views replicate the interface of `list_of` views, which
in turn includes the list operations provided by `std::list`. The syntax and
behavior of these operations exactly matches those of `list_of` views, but
the associated complexity bounds differ in general.\n
`vector_of` 视图复制了 `list_of` 视图的接口，后者包含了 `std::list` 中所有的列表操作。
这些成员函数的语义与 `list_of` 视图的完全一样，但相关的复杂度不一样。


[#reference_vector_of_splice_iterator_this]

    void splice(iterator position, this_type & x);

* [*Requires: ] `position` is a valid iterator of the view. `&x!=this`.\n
  [*要求：]`position` 为该视图的有效迭代器。`&x!=this`.
* [*Effects:] Inserts the contents of `x` before position, in the same order
as they were in `x`. Those elements successfully inserted are erased from `x`.\n
  [*效果：]在 `position` 之上插入 `x` 的内容，顺序与 `x` 中的一样。成功插入的元素将从 `x` 中删除。
* [link vector_of_complexity_signature
[*Complexity:]] O(shl(end()-position,x.size()) + x.size()*I(n+x.size()) + x.size()*D(x.size())).\n
  [link vector_of_complexity_signature [*复杂度：]]O(shl(end()-position,x.size()) + x.size()*I(n+x.size()) + x.size()*D(x.size())).
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_splice_iterator_this_iterator]

    void splice(iterator position, this_type & x,iterator i);

* [*Requires: ] `position` is a valid iterator of the view. `i` is a valid
dereferenceable iterator `x`.\n
  [*要求：]`position` 为该视图的有效迭代器。`i` 为 `x` 的一个有效可提领迭代器。 
* [*Effects:] Inserts the element pointed to by `i` before `position`: if
insertion is successful, the element is erased from `x`. In the special
case `&x==this`, no copy or deletion is performed, and the operation is
always successful. If `position==i`, no operation is performed.\n
  [*效果：]在 `position` 之上插入由 `i` 所指的元素：如果成功插入，该元素将从 x 中删除。
  在 `&x==this` 的特殊情况下，不执行任何复制或删除，且操作总是成功。如果 `position==i`，则不执行操作。
* [*Postconditions:] If `&x==this`, no iterator or reference is invalidated.\n
  [*后置条件：]如果 `&x==this`，则没有迭代器或引用失效。
* [link vector_of_complexity_signature
[*Complexity:]] If `&x==this`, O(rel(position,i,i+1));
otherwise O(shl(end()-position,1) + I(n) + D(n)).\n
  [link vector_of_complexity_signature [*复杂度：]]如果 `&x==this`, 则为 O(rel(position,i,i+1));
否则为 O(shl(end()-position,1) + I(n) + D(n)).
* [*Exception safety:] If `&x==this`, nothrow; otherwise, strong.\n
  [*异常安全性：]如果 `&x==this`，则无抛出，否则为强异常安全。


[#reference_vector_of_splice_iterator_this_iterator_iterator]

    void splice(iterator position, this_type & x, iterator first, iterator last);

* [*Requires: ] `position` is a valid iterator of the view. `first` and
`last` are valid iterators of `x`. `last` is reachable from `first`. `position` is
not in the range `[first,last)`.\n
  [*要求：]`position` 为该视图的有效迭代器。`first` 和 `last` 为 `x` 的有效迭代器。
  `last` 可从 `first` 到达。`position` 不在区间 `[first,last)` 中。
* [*Effects:] For each element in the range `[first,last)`, insertion is
tried before `position`; if the operation is successful, the element is
erased from `x`. In the special case `&x==this`, no copy or deletion is
performed, and insertions are always successful.\n
  [*效果：]对于区间 `[first,last)` 中的每个元素，尝试将其插入到 `position` 之前；如果成功插入，该元素将从 `x` 中删除。
  在 `&x==this` 的特殊情况下，不执行任何复制或删除，且插入操作总是成功。
* [*Postconditions:] If `&x==this`, no iterator or reference is invalidated.\n
  [*后置条件：]如果 `&x==this`，则没有迭代器或引用失效。
* [link vector_of_complexity_signature
[*Complexity:]] If `&x==this`, O(rel(position,first,last));
otherwise O(shl(end()-position,m) + m*I(n+m) + m*D(x.size()))
where m is the number of elements in `[first,last)`.\n
  [link vector_of_complexity_signature [*复杂度：]]如果 `&x==this`，则为 `O(rel(position,first,last))`；
  否则 `O(shl(end()-position,m) + m*I(n+m) + m*D(x.size()))` 其中 `m` 为 `[first,last)` 中的元素数量。
* [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.\n
  [*异常安全性：]如果 `&x==this`，则无抛出，否则为基本异常安全。


[#reference_vector_of_remove_value]

    void remove(const value_type & value);

* [*Effects:] Erases all elements of the view which compare equal to `value`.\n
  [*效果：]删除视图中与 `value` 相等的所有元素。
* [link vector_of_complexity_signature
[*Complexity:]] O(n + m*D(n)), where m is the number of elements erased.\n
  [link vector_of_complexity_signature [*复杂度：]]O(n + m*D(n)), 其中 m 为删除的元素数量。
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_remove_if_predicate]

    template< class Predicate >
    void remove_if(Predicate pred);

* [*Effects:] Erases all elements `x` of the view for which `pred(x)` holds.\n
  [*效果：]删除视图中满足 `pred(x)` 的所有元素 `x`。
* [link vector_of_complexity_signature
[*Complexity:]] O(n + m*D(n)), where m is the number of elements erased.\n
  [link vector_of_complexity_signature [*复杂度：]]O(n + m*D(n)), 其中 m 为删除的元素数量。
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_unique]

    void unique();

* [*Effects:] Eliminates all but the first element from every consecutive
group of equal elements referred to by the iterator `i` in the range
`[first+1,last)` for which `*i==*(i-1)`.\n
  [*效果：]对于每一个连续的相等元素组，即区间 `[first+1,last)` 中每个迭代器 `i` 满足 `*i==*(i-1)` 的，只保留其中第一个元素。
* [link vector_of_complexity_signature
[*Complexity:]] O(n + m*D(n)), where m is the number of elements erased.\n
  [link vector_of_complexity_signature [*复杂度：]]O(n + m*D(n)), 其中 m 为删除的元素数量。
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_unique_predicate]

    template< class BinaryPredicate >
    void unique(BinaryPredicate binary_pred); 

* [*Effects:] Eliminates all but the first element from every consecutive
group of elements referred to by the iterator i in the range `[first+1,last)`
for which `binary_pred(*i, *(i-1))` holds.\n
  [*效果：]对于每一个连续的满足特定条件的元素组，即区间 `[first+1,last)` 中每个迭代器 `i` 满足 `binary_pred(*i,*(i-1))` 的，
  只保留其中第一个元素。
* [link vector_of_complexity_signature
[*Complexity:]] O(n + m*D(n)), where m is the number of elements erased.\n
  [link vector_of_complexity_signature [*复杂度：]]O(n + m*D(n)), 其中 m 为删除的元素数量。
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_merge_this]

    void merge(this_type & x);

* [*Requires: ] `std::less<value_type>` is a __SGI_STRICT_WEAK_ORDERING__ over
`value_type`. Both the view and `x` are sorted according to `std::less<value_type>`.\n
  [*要求：]`std::less<value_type>` 是 `value_type` 之上的 __SGI_STRICT_WEAK_ORDERING__。
  该视图与 `x` 均依照 `std::less<value_type>` 排序。
* [*Effects:] Attempts to insert every element of x into the corresponding
position of the view (according to the order). Elements successfully
inserted are erased from `x`. The resulting sequence is stable, i.e. equivalent
elements of either container preserve their relative position. In the special
case `&x==this`, no operation is performed.\n
  [*效果：]尝试将 `x` 的每个元素插入到视图中的相应位置(按照顺序)。成功插入的元素将从 `x` 中删除。
  结果序列是稳定的，即各个容器中相等的元素将保持它们的相对位置。在 `&x==this` 的特殊情况下，不执行任何操作。
* [*Postconditions:] Elements in the view and remaining elements in `x` are
sorted. Validity of iterators to the view and of non-erased elements of `x`
references is preserved.\n
  [*后置条件：]视图中的元素以及 `x` 中剩余的元素均为有序。视图中的迭代器以及 `x` 中未删除的元素的引用均保持有效性。
* [link vector_of_complexity_signature
[*Complexity:]] If `&x==this`, constant;
otherwise O(n + x.size()*I(n+x.size()) + x.size()*D(x.size())).\n
  [link vector_of_complexity_signature [*复杂度：]]如果 `&x==this`，则为常数；
  否则 `O(n + x.size()*I(n+x.size()) + x.size()*D(x.size()))`. 
* [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.\n
  [*异常安全性：]如果 `&x==this`，则无抛出，否则为基本异常安全。


[#reference_vector_of_merge_this_compare]

    template< class Compare >
    void merge(this_type & x, Compare comp);

* [*Requires: ] `Compare` is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`.
Both the view and `x` are sorted according to comp.\n
  [*要求：]`Compare` 是 `value_type` 之上的 __SGI_STRICT_WEAK_ORDERING__。该视图与 `x` 均依照 `comp` 排序。
* [*Effects:] Attempts to insert every element of `x` into the corresponding
position of the view (according to `comp`). Elements successfully inserted
are erased from `x`. The resulting sequence is stable, i.e. equivalent
elements of either container preserve their relative position. In the
special case `&x==this`, no operation is performed.\n
  [*效果：]尝试将 `x` 的每个元素插入到视图中的相应位置(按照 `comp`)。成功插入的元素将从 x 中删除。结果序列是稳定的，即各个容器中相等的元素将保持它们的相对位置。在 &x==this 的特殊情况下，不执行任何操作。
* [*Postconditions:] Elements in the view and remaining elements in `x` are
sorted according to `comp`. Validity of iterators to the view and of
non-erased elements of `x` references is preserved.\n
  [*后置条件：]视图中的元素以及 `x` 中剩余的元素均按照 `comp` 排序。视图中的迭代器以及 `x` 中未删除的元素的引用均保持有效性。
* [link vector_of_complexity_signature
[*Complexity:]] If `&x==this`, constant;
otherwise O(n + x.size()*I(n+x.size()) + x.size()*D(x.size())).\n
  [link vector_of_complexity_signature [*复杂度：]]如果 `&x==this`，则为常数；
  否则 O(n + x.size()*I(n+x.size()) + x.size()*D(x.size())). 
* [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.\n
  [*异常安全性：]如果 `&x==this`，则无抛出，否则为基本异常安全。


[#reference_vector_of_sort]

    void sort();

* [*Requires: ] `std::less<value_type>` is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`.\n
  [*要求：]`std::less<value_type>` 是 `value_type` 之上的 __SGI_STRICT_WEAK_ORDERING__。
* [*Effects:] Sorts the view according to `std::less<value_type>`.
The sorting is stable, i.e. equivalent elements preserve their relative position.\n
  [*效果：]按照 `std::less<value_type>` 对视图进行排序。排序是稳定的，即各个相等的元素将保持它们的相对位置。
* [*Postconditions:] Validity of iterators and references is preserved.\n
  [*后置条件：]迭代器及引用均保持有效性。
* [*Complexity:] O(n*log(n)).\n
  [*复杂度：]O(n*log(n)).
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_sort_compare]

    template< class Compare >
    void sort(Compare comp);

* [*Requires:] Compare is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`.\n
  [*要求：]Compare 是 `value_type` 之上的 __SGI_STRICT_WEAK_ORDERING__。
* [*Effects:] Sorts the view according to `comp`. The sorting is stable, i.e.
equivalent elements preserve their relative position.\n
  [*效果：]按照 `comp` 对视图进行排序。排序是稳定的，即各个相等的元素将保持它们的相对位置。
* [*Postconditions:] Validity of iterators and references is preserved.\n
  [*后置条件：]迭代器及引用均保持有效性。
* [*Complexity:] O(n*log(n)).\n
  [*复杂度：]O(n*log(n)).
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。


[#reference_vector_of_reverse]

    void reverse();

* [*Effects:] Reverses the order of the elements in the view.\n
  [*效果：]将视图的元素反序。
* [*Postconditions:] Validity of iterators and references is preserved.\n
  [*后置条件：]迭代器及引用均保持有效性。
* [*Complexity:] O(n).\n
  [*复杂度：]O(n).
* [*Exception safety:] nothrow.\n
  [*异常安全性：]无抛出。


[endsect]

[section:rearrange_operations Rearrange operations 重排操作]

These operations, without counterpart in `std::list` (although splice provides
partially overlapping functionality), perform individual and global repositioning
of elements inside the index.\n
这些操作在 `std::list` 中是没有的(虽然 `splice` 提供了部分功能)，它们在索引内部执行个别和全局的元素重定位。


[#reference_vector_of_relocate_iterator_iterator]

    void relocate(iterator position, iterator i);

* [*Requires: ] `position` is a valid iterator of the view. `i` is a valid
dereferenceable iterator of the view.\n
  [*要求：]`position` 是视图的有效迭代器。`i` 是视图的有效可提领迭代器。
* [*Effects:] Inserts the element pointed to by `i` before `position`.
If `position==i`, no operation is performed.\n
  [*效果：]将 `i` 所指元素插入到 `position` 之前。如果 `position==i`，不执行操作。
* [*Postconditions:] No iterator or reference is invalidated.\n
  [*后置条件：]没有迭代器及引用失效。
* [*Complexity:] Constant.\n
  [*复杂度：]常数。
* [*Exception safety:] nothrow.\n
  [*异常安全性：]无抛出。


[#reference_vector_of_relocate_iterator_iterator_iterator]

    void relocate(iterator position, iterator first, iterator last);

* [*Requires: ] `position` is a valid iterator of the view. `first` and `last` are
valid iterators of the view. `last` is reachable from `first`. `position` is not
in the range `[first,last)`.\n
  [*要求：]`position` 是视图的有效迭代器。`first` 和 `last` 是视图的有效迭代器。
  `last` 可从 `first` 到达。`position` 不在区间 `[first,last)` 中。
* [*Effects:] The range of elements `[first,last)` is repositioned just before
`position`.\n
  [*效果：]区间 `[first,last)` 中的元素被重定位到 `position` 之前。
* [*Postconditions:] No iterator or reference is invalidated.\n
  [*后置条件：]没有迭代器及引用失效。
* [*Complexity:] Constant.\n
  [*复杂度：]常数。
* [*Exception safety:] nothrow.\n
  [*异常安全性：]无抛出。


[endsect]


[section:serialization Serialization 序列化]

Views cannot be serialized on their own, but only as part of the `bimap`
into which they are embedded. In describing the additional preconditions and guarantees
associated to `vector_of` views with respect to serialization of their embedding
containers, we use the concepts defined in the `bimap` serialization section.\n
视图不能被它们自己序列化，只能作为它们所嵌的 `bimap` 的一部分。在描述与所嵌容器的 `vector_of` 
视图相关的其它前提条件和保证时，我们使用在 bimap 序列化一节中所定义的概念。

[blurb [*Operation:] saving of a `bimap` b to an output archive (XML archive) ar.\n
[*操作：]保存一个 `bimap` b 到一个输出存档(XML 存档) ar 中。]

* [*Requires:] No additional requirements to those imposed by the container.\n
  [*要求：]除了对容器的要求以外，没有其它要求。


[blurb [*Operation:] loading of a `bimap` b' from an input archive (XML archive) ar.\n
[*操作：]从一个输入存档(XML 存档) ar 中导入一个 `bimap` b' 。]

* [*Requires:] No additional requirements to those imposed by the container.\n
  [*要求：]除了对容器的要求以外，没有其它要求。
* [*Postconditions:] On successful loading, each of the elements of `[begin(), end())` is a
restored copy of the corresponding element in `[m.get<i>().begin(), m.get<i>().end())`,
where `i` is the position of the `vector_of` view in the container.\n
  [*后置条件：]成功导入后，在 `[begin(), end())` 中的每个元素为 `[m.get<i>().begin(), m.get<i>().end())` 
  中各相应元素的恢复后拷贝，其中 `i` 为 `vector_of` 视图在容器中的位置。



[blurb [*Operation:] saving of an `iterator` or `const_iterator` `it` to an output archive (XML archive) ar.\n
[*操作：]保存一个 `iterator` 或 `const_iterator` `it` 到一个输出存档(XML 存档) ar 中。]

* [*Requires: ] `it` is a valid iterator of the view. The associated `bimap`
has been previously saved.\n
  [*要求：]`it` 为视图的有效迭代器。相关联的 `bimap` 已经被保存。



[blurb [*Operation:] loading of an `iterator` or `const_iterator` `it`' from an input archive (XML archive) ar.\n
[*操作：]从一个输入存档(XML 存档) ar 中导入一个 `iterator` 或 `const_iterator` `it`' 。]

* [*Postconditions:] On successful loading, if it was dereferenceable then `*it`' is the
restored copy of `*it`, otherwise `it`'`==end()`.\n
  [*后置条件：]成功导入后，如果 `it` 是可提领的，则 `*it`' 为 `*it` 的恢复后拷贝，否则 `it`'`==end()`. 
* [*Note:] It is allowed that it be a `const_iterator` and the restored `it`' an `iterator`,
or viceversa.\n
  [*注：]允许 `it` 是一个 `const_iterator`，而恢复后的 `it`' 为一个 `iterator`，反之亦然。


[endsect]
[endsect]


[endsect]
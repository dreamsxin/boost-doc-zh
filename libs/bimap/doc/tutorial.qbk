[/license

Boost.Bimap

Copyright (c) 2006-2007 Matias Capeletto

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)

]

[/ QuickBook Document version 1.4 ]

[section:the_tutorial The tutorial 指南]

[section:roadmap Roadmap 路标]

# Boost.Bimap is intuitive because it is based on the standard
template library. New concepts are however presented to extend the
standard maps to bidirectional maps. The first step is to gain a
firm grasp of the bimap framework. The first section
([link boost_bimap.the_tutorial.discovering_the_bimap_framework Discovering the bimap framework])
aims to explain this.\n
Boost.Bimap 非常直观，因为它基于标准模板库。不过，从标准的 map 扩展至双向 map，还是要引入新的概念。
第一步是获得一个牢固的 bimap 框架。第一节([link boost_bimap.the_tutorial.discovering_the_bimap_framework 介绍bimap框架])
就是说明这一点的。

# Boost.Bimap offers much more than just a one-to-one ordered unique
bidirectional map. It is possible to control the collection type of each side
of the relationship that the bimap represents, giving one-to-many
containers, hashed bidirectional containers and others that may be more
suitable to the the task at hand. The second section
([link boost_bimap.the_tutorial.controlling_collection_types Controlling collection types])
explains how to instantiate a bimap with different collection constraints.\n
Boost.Bimap 比单纯的一对一有序双向 map 提供得更多。它可以控制 bimap 所代表的关系的每一方的组合类型，
也可以给出一对多的容器、散列的双向容器，以及其它更适合于完成工作的容器。
第二节([link boost_bimap.the_tutorial.controlling_collection_types 控制组合类型])
说明了如何以不同的组合约束来实例化一个 bimap。

# The section
([link boost_bimap.the_tutorial.the_collection_of_relations_type The "collection of relations" type])
explains how to create new types of bidirectional maps using custom collection types.\n
下一节([link boost_bimap.the_tutorial.the_collection_of_relations_type "关系组合"的类型])
讲解了如何创建一个使用定制组合类型的双向 map 类型。

# In the section [link boost_bimap.the_tutorial.differences_with_standard_maps Differences with standard maps] we will learn about the subtle differences between a bimap map view and a standard map.\n
在 [link boost_bimap.the_tutorial.differences_with_standard_maps 与标准 map 的差异] 一节中，
我们将学习 bimap 的 map 视图与标准 map 之间的微妙差异。

# The section [link boost_bimap.the_tutorial.useful_functions Useful functions] provides information
about functions of a bimap that are not found in the STL.\n
[link boost_bimap.the_tutorial.useful_functions 有用的函数] 一节提供了 bimap 中有而 STL 中没有的函数的信息。

# The types of a bimap can be tagged so that each side is accessible
by something closer to the problem than left and right. This leads to
more readable, self-documenting code. The fourth section
([link boost_bimap.the_tutorial.bimaps_with_user_defined_names Bimaps with user defined names]) shows
how to use this feature.\n
bimap 的类型可以被标记，以便以比 left 和 right 更为自然的方式来访问每个方向。这样可以写出易读性更好，
可自解释的代码。第四节([link boost_bimap.the_tutorial.bimaps_with_user_defined_names 带用户自定义名字的 bimaps])
示范如何使用这一特性。

# The bimap mapping framework allows to disable a view of a bimap, including the standard
mapping containers as a particular case. The section
[link boost_bimap.the_tutorial.unconstrained_sets Unconstrained Sets] explains how they work.\n
bimap 的映射框架允许禁止 bimap 的某个视图，包括标准的映射容器。
[link boost_bimap.the_tutorial.unconstrained_sets 不受限的 set] 一节讲解了如何使用。

# The section [link boost_bimap.the_tutorial.additional_information Additional information]
explains how to attach information to each relation of a bimap.\n
[link boost_bimap.the_tutorial.additional_information 其它信息] 解释了如何为 bimap 的每个关系附加信息。

# The final section
([link boost_bimap.the_tutorial.complete_instantiation_scheme Complete Instantiation Scheme])
summarizes bimap instantiation and explains how change the allocator type to be used.\n
最后一节([link boost_bimap.the_tutorial.complete_instantiation_scheme 完整的实例化方案])总结了 bimap 的实例化，
并解释如何变更所使用的分配器类型。

[endsect]

[section:discovering_the_bimap_framework Discovering the bimap framework 介绍bimap框架]

[section:interpreting_bidirectional_maps Interpreting bidirectional maps 解释双向映射]

One way to interpret bidirectional maps is as a function between two
collections of data, lets call them the left and the right collection. 
An element in this bimap is a relation between an element from the left 
collection and an element from the right collection.
The types of both collections defines the bimap behaviour. We can view
the stored data from the left side, as a mapping between keys from the
left collection and data from the right one, or from the right side, as
a mapping between keys from the right collection and data from the
left collection.\n
对双向映射的一种解释是，它是两组数据之间的一个函数，我们将这两组数据分别称为左组和右组。
这个 bimap 中的一个元素就是左组中的一个元素与右组中的一个元素间的关系。这两个组的类型定义了 bimap 的行为。
我们可以从左边来察看所保存的数据，就如一个以左组为键以右组为数据的映射，也可以从右边来察看，
就如一个以右组为键以左组为数据的映射。

[endsect]

[section:standard_mapping_framework Standard mapping framework 标准的映射框架]

Relationships between data in the STL are represented by maps. A
standard map is a directed relation of keys from a left collection and 
data from a right unconstrained collection.
The following diagram shows the relationship represented and the 
user's viewpoint.\n
在STL中，数据间的关系被表示为映射map。标准的 map 是以左组为键以右组为数据的一种直接关系，对右组数据无限制。
下图显示了所表示的关系以及用户的视点。

__STANDARD_MAPPING_FRAMEWORK__

The left collection type depends on the selected map type. For example if the the map type is `std::multimap` the collection type of X is a `multiset_of`.
The following table shows the equivalent types for the std associative containers.\n
左组的类型取决于所选择的 map 类型。例如，如果 map 类型为 `std::multimap` 则 X 的类型为 `multiset_of`.
下表显示了标准关联式容器的等价类型。

[table std associative containers 标准关联式容器
[[container 容器][left collection type 左组类型][right collection type 右组类型]]
[[`map`               ][`set_of`                  ][no constraints 无约束]]
[[`multimap`          ][`multiset_of`             ][no constraints 无约束]]
[[`unordered_map`     ][`unordered_set_of`        ][no constraints 无约束]]
[[`unordered_multimap`][`unordered_multiset_of`   ][no constraints 无约束]]
]

[endsect]

[section:bimap_mapping_framework Bimap mapping framework  Bimap的映射框架]

Boost.Bimap design is based on the STL, and extends the framework in a natural way.
The following diagram represents the new situation.\n
Boost.Bimap 的设计基于STL，并以自然的方法扩展了该框架。下图表示了新的情况。 

__EXTENDED_MAPPING_FRAMEWORK__

Notice that now the `std::maps` are a particular case of a Boost.Bimap
container, where you can view only one side of the relationship and can
control the constraints of only one of the collections. Boost.Bimap
allows the user to view the relationship from three viewpoints.
You can view it from one side, obtaining a `std::map` compatible
container, or you can work directly with the whole relation.\n
留意，现在 `std::map` 成了 Boost.Bimap 容器的一种特定情形，即你只能从关系的一侧进行察看，
而且只能控制一组数据的约束。Boost.Bimap 允许用户从三个视点察看关系。你既可以从某一边来察看，
得到一个与 `std::map` 兼容的容器，也可以直接对整个关系进行操作。

The next diagram shows the layout of the relation and pairs of a bimap. It is
the one from the ['one minute tutorial]\n
下图显示了一个 bimap 的关系布局和值对。它来自于 ['一分钟教程]

__RELATION_AND_PAIR__

Bimap pairs are signature-compatible with standard pairs but are different
from them. As you will see in other sections they can be tagged with user
defined names and additional information can be attached to them. You can
convert from `std::pairs` to bimap pairs directly but the reverse conversion
is not provided. This mean that you can insert elements in a bimap using
algorithms like `std::copy` from containers `like std::map`, or use `std::make_pair`
to add new elements. However it is best to use `bm.left.insert( bm_type::left_value_type(f,s) )` instead of `bm.insert( std::make_pair(f,s) )` to avoid an extra call to the
copy constructor of each type.\n
Bimap 对与标准的 pair 签名兼容，但有所不同。正如你将在另一个章节中看到的，它们可以用用户自定义名字来标识，
以附加额外信息。你可以直接从 `std::pairs` 转换到 bimap，但反向的转换而不提供。
这意味着你可以使用象 `std::copy` 这样的算法从 `std::map` 这样的容器向 bimap 插入元素，
或者使用 `std::make_pair` 来增加新的元素。但是最好还是使用 `bm.left.insert( bm_type::left_value_type(f,s) )` 
来替代 `bm.insert( std::make_pair(f,s) )` 以避免对各个类型的复制构造函数的额外调用。

The following code snippet shows the relation between a bimap and standard
maps.\n
以下代码片断显示了 bimap 与标准 map 之间的关系。

[note
You have to used references to views, and not directly views object. 
Views cannot be constructed as separate objects from the container they 
belong to, so the following:\n
你必须使用视图的引用，而不是直接使用视图对象。视图不能被作为独立的对象从它们所属的容器中构造得到，所以以下代码：
``
// Wrong: we forgot the & after bm_type::left_type
// 错误：我们忘记了在 bm_type::left_type 后加 &
bm_type::left_map lm = bm.left;
``
does not compile, since it is trying to construct the view object `lm`. 
This is a common source of errors in user code.\n
将不能编译，因为它试图构造视图对象 `lm`。这是用户代码中常见的错误来源。
]

[@../../example/standard_map_comparison.cpp Go to source code 察看源代码]

[import ../example/standard_map_comparison.cpp]

[code_standard_map_comparison]

[endsect]

[endsect]

[section:controlling_collection_types Controlling collection types 控制组合的类型]

[section:freedom_of_choice Freedom of choice 选择的自由]

As has already been said, in STL maps, you can only control the
constraints from one of the collections, namely the one that you are
viewing. In Boost.Bimap, you can control both and it is as easy as using the STL.\n
如前所说，在STL map 中，你只能从一方数据组控制约束性，即你察看的那一方。
在 Boost.Bimap 中，你可以同时从两方控制，而且和STL一样容易使用。

__EXTENDED_MAPPING_FRAMEWORK__

The idea is to use the same constraint names that are used in the
standard. If you don't specify the collection type, Boost.Bimap assumes
that the collection is a set. The instantiation of a bimap with custom
collection types looks like this:\n
思路是，使用与标准一样的约束名字。如果你不指定数据组合的类型，Boost.Bimap 就假定数据组合为一个 set。
带定制组合类型的 bimap 实例如下：

    typedef bimap< ``*CollectionType*``_of<A>, ``*CollectionType*``_of<B> > bm_type;

The following is the list of all supported collection types.\n
以下列出了所有被支持的组合类型。


[table Collection of Key Types 键类型的组合
[[name 名字][Features 特性][map view type 映射视图类型]]
[[`set_of`               ][['ordered, unique 有序，唯一]][`map`                    ]]
[[`multiset_of`          ][['ordered 有序]][`multimap`               ]]
[[`unordered_set_of`     ][['hashed, unique 散列，唯一]][`unordered_map`          ]]
[[`unordered_multiset_of`][['hashed 散列]][`unordered_multimap`     ]]
[[`list_of`              ][['sequenced 序列]][`list_map`               ]]
[[`vector_of`            ][['random access 随机访问]][`vector_map`             ]]
[[`unconstrained_set_of` ][['unconstrained 无约束]][['can not be viewed 不可察看]     ]]
]


`list_of` and `vector_of` map views are not associated with any existing STL
associative containers. They are two examples of unsorted associative
containers. `unconstrained_set_of` allow the user to ignore a view. This
will be explained later.\n
`list_of` 和 `vector_of` 映射视图不与任何已有STL关联式容器相关联。它们是两种无序关联式容器。
`unconstrained_set_of` 则允许用户忽略视图。稍后将会有解释。

__BIMAP_STRUCTURES__

The selection of the collection type affects the possible operations that you
can perform with each side of the bimap and the time it takes to do
each. If we have:\n
对数据组合类型的选择会影响你可以对 bimap 各方数据执行的操作，以及各种操作的时间。如果我们有：

    typedef bimap< ``*CollectionType*``_of<A>, ``*CollectionType*``_of<B> > bm_type;
    bm_type bm;

The following now describes the resulting map views of the bidirectional
map.\n
以下描述了该双向映射的结果映射视图。

* `bm.left` is signature-compatible with *LeftMapType*`<A,B>`
* `bm.right` is signature-compatible with *RightMapType*`<B,A>`

[endsect]

[section:configuration_parameters Configuration parameters 配置参数]

Each collection type template has different parameters to control its
behaviour. For example, in `set_of` specification, you can pass a Functor
type that compares two types. All of these parameters are exactly the
same as those of the standard library container, except for the
allocator type. You will learn later how to change the allocator for a
bimap.\n
每个组合类型模板都有不同的参数来控制其行为。例如，对于 `set_of`，你可以传入一个函数对象类型来比较两个类型。
所有这些参数都与标准库容器中的完全相同，除了分配器类型。稍后你将学到如何改变一个 bimap 的分配器。

The following table lists the meanings of each collection type's parameters.\n
下表列出了每个组合类型的参数含义。

[table
[[name 名字][Additional Parameters 额外参数]]

[[`set_of<T,KeyComp>`

  `multiset_of<T,KeyComp>` ]

[[*KeyComp ] is a Functor that compares two types using a less-than operator.
By default, this is `std::less<T>`. \n
[*KeyComp] 是一个函数对象，使用小于操作符比较两个类型。它缺省为 `std::less<T>`. ]]

[[`unordered_set_of<T,HashFunctor,EqualKey>`

  `unordered_multiset_of<T,HashFunctor,EqualKey>`]

[[*HashFunctor ] converts a `T` object into an `std::size_t` value. By default it is `boost::hash<T>`.\n
[*HashFunctor] 将一个 `T` 对象转换为一个 `std::size_t` 值。它缺省为 `boost::hash<T>`. 

 [*EqualKey ] is a Functor that tests two types for equality. By default, the
equality operator is `std::equal_to<T>`. \n
[*EqualKey] 是一个函数对象，检测两个类型的等价性。缺省的等价操作符是 `std::equal_to<T>`. ]]
[[`list_of<T>`              ][No additional parameters.\n无额外参数。]]
[[`vector_of<T>`            ][No additional parameters.\n无额外参数。]]
[[`unconstrained_set_of<T>` ][No additional parameters.\n无额外参数。]]
]

[endsect]

[section:examples Examples 示例]

[heading Countries Populations 各国人口]

We want to store countries populations.
The requeriments are:\n
我们想保存各国人口数据。需求如下：

# Get a list of countries in decresing order of their populations.\n
  获取各国的列表，以人口数量递减排序。
# Given a countrie, get their population.\n
  给定一个国家，获取其人口数。

Lets create the appropiate bimap.\n
我们来创建一个适当的 bimap。 

    typedef bimap<

        unordered_set_of< std::string >,
        multiset_of< long, std::greater<long> >

    > populations_bimap;

First of all countries names are unique identifiers, while two countries 
may have the same population. This is why we choose *multi*`set_of` for
populations.\n
首先，所有国家的名字是唯一的标识符，而两个国家有可能具有相同数量的人口。
这正是我们对人口数选用 *multi*`set_of` 的原因。

Using a `multiset_of` for population allow us to iterate over the data.
Since listing countries ordered by their names is not a requisite, we can
use an `unordered_set_of` that allows constant order look up.\n
对人口数使用 `multiset_of`，使得我们可以遍历该数据。由于并不要求按名字顺序列出各个国家，
所以我们可以使用 `unordered_set_of`，按固定的顺序来查找。

And now lets use it in a complete example\n
现在我们用它来举一个完整的例子。

[@../../example/population_bimap.cpp Go to source code 察看源代码]

[import ../example/population_bimap.cpp]

[code_population_bimap]


[heading Repetitions counter 重复次数计数]

We want to count the repetitions for each word in a text and print them
in order of appearance.\n
我们要计算一篇文本中各个单词的重复次数，并按它们出现的顺序打印。

[@../../example/repetitions_counter.cpp Go to source code 察看源代码]

[import ../example/repetitions_counter.cpp]

[code_repetitions_counter]

[endsect]

[endsect]

[section:the_collection_of_relations_type The collection of relations type 关系组合的类型]

[section:a_new_point_of_view A new point of view 对于视图的一个新观点]

Being able to change the collection type of the bimap relation view is another
very important feature. Remember that this view allows the user to see
the container as a group of the stored relations. This view has set
semantics instead of map semantics.\n
能够修改 bimap 关系视图的组合类型是 bimap 的另一个重要特性。该视图可以允许用户将容器视为所保存关系的一个群组。
该视图具有 set 语义而不是 map 语义。

__COLLECTION_TYPE_OF_RELATION__

By default, Boost.Bimap will base the collection type of the relation on the
type of the left collection. If the left collection type is a set, then the collection
type of the relation will be a set with the same order as the left view.\n
缺省情况下，Boost.Bimap 将其关系的组合类型基于其左组类型。如果左组类型为 set，
则关系的组合类型同样是一个 set，并具有与左视图相同的顺序。

In general, Boost.Bimap users will base the collection type of a relation on
the type of the collection on one of the two sides. However there are times
where it is useful to give this collection other constraints or simply to order
it differently. The user is allowed to choose between:\n
通常，Boost.Bimap 的用户会将关系的组合类型基于两方组合之一。
但是有时候也需要对该组合给定其它约束或者使其顺序不同。用户可以从以下所列进行选择

* left_based
* right_based
* set_of_relation<>
* multiset_of_relation<>
* unordered_set_of_relation<>
* unordered_multiset_of_relation<>
* list_of_relation
* vector_of_relation
* unconstrained_set_of_relation

[tip
The first two options and the last produce faster bimaps, so prefer
these where possible.\n
头两个和最后一个选择可以产生较快的 bimap，所以应该尽可能优先选择它们。
]

__MORE_BIMAP_STRUCTURES__

The collection type of relation can be used to create powerful containers. For
example, if you need to maximize search speed, then the best
bidirectional map possible is one that relates elements from an
`unordered_set` to another `unordered_set`. The problem is that this
container cannot be iterated. If you need to know the list of relations
inside the container, you need another collection type of relation. In this
case, a `list_of_relation` is a good choice. The resulting container
trades insertion and deletion time against fast search capabilities and
the possibility of bidirectional iteration.\n
关系组合的类型可以用于创建强大的容器。例如，如果你需要最快的查找速度，那么最好的双向映射可能是这样的，
相关联的元素从一个 `unordered_set` 映射到另一个 `unordered_set`。问题是，这个容器不能被遍历。
如果你需要知道容器内部的关系列表，你就需要另一种的关系组合类型。在这种情况下，`list_of_relation` 是一个好的选择。
这样所得到的容器以牺牲插入和删除的时间换取了更快的查找速度，并且可以被双向遍历。

[@../../example/mighty_bimap.cpp Go to source code 察看源代码]

[code_mighty_bimap]

[endsect]

[section:configuration_parameters Configuration parameters 配置参数]

Each collection type of relation has different parameters to control its
behaviour. For example, in the `set_of_relation` specification, you can
pass a Functor type that compares two types. All of the parameters are
exactly as in the standard library containers, except for the type,
which is set to the bimap relation and the allocator type. To help users
in the creation of each functor, the collection type of relation templates
takes an mpl lambda expression where the relation type will be evaluated
later. A placeholder named `_relation` is available to bimap users.\n
每一种关系组合类型都有不同的参数来控制其行为。例如，在 `set_of_relation` 的规格说明中，
你可以传入一个函数对象类型来比较两种类型。所有这些参数都与标准库中的一致，
除了用于那些被设置为 bimap 关系的类型和分配器类型。为了帮助用户创建每个函数对象，
关系组合类型的模板接受一个 mpl lambda 表达式，关系的类型会被延迟求值。
bimap 的用户可以使用一个名为 `_relation` 的占位符。

The following table lists the meaning of the parameters for each collection type of
relations.\n
下表列出了每种关系组合类型的各个参数的意义。

[table
[[name 名字][Additional Parameters 额外的参数]]

[[`left_based`                        ][Not a template.\n非模板。]]
[[`right_based`                       ][Not a template.\n非模板。]]
[[`set_of_relation<KeyComp>`

  `multiset_of_relation<KeyComp>` ]
[[*KeyComp ] is a Functor that compares two types using less than. By
default, the less-than operator is `std::less<_relation>`. \n
[*KeyComp] 是一个函数对象，它用小于关系比较两个类型。缺省情况下，小于比较操作符为 `std::less<_relation>`. ]]

[[`unordered_set_of_relation<HashFunctor,EqualKey>`

  `unordered_multiset_of_relation<HashFunctor,EqualKey>`]
[[*HashFunctor ] converts the `relation` into an `std::size_t` value. By default it is `boost::hash<_relation>`.\n
[*HashFunctor] 将 `relation` 转换为一个 `std::size_t` 值。缺省情况下，它是 `boost::hash<_relation>`. 

 [*EqualKey ] is a Functor that tests two relations for equality. By default,
the equality operator is `std::equal_to<_relation>`. \n
[*EqualKey] 是一个函数对象，它测试两个类型的等价性。缺省情况下，等价操作符为 `std::equal_to<_relation>`. ]]
[[`list_of_relation`                  ][Not a template.\n非模板。]]
[[`vector_of_relation`                ][Not a template.\n非模板。]]
[[`unconstrained_set_of_relation`     ][Not a template.\n非模板。]]
]

[endsect]

[section:examples Examples 示例]

Consider this example:\n
考虑以下例子：

    template< class Rel >
    struct RelOrder
    {
        bool operator()(Rel ra, Rel rb) const
        {
            return (ra.left+ra.right) < (rb.left+rb.right);
        }
    };

    typedef bimap
    <
            multiset_of< int >,
            multiset_of< int >,
            set_of_relation< RelOrder<_relation> >

    > bimap_type;

Here the bimap relation view is ordered using the information of
both sides. This container will only allow unique relations because
`set_of_relation` has been used but the elements in each side of the
bimap can be repeated.\n
以上 bimap 的关系视图使用两边的信息来排序。该容器只允许不重复的关系，
因为用的是 `set_of_relation`，不过 bimap 每侧的元素则可以重复。

    struct name         {};
    struct phone_number {};

    typedef bimap
    <
        tagged< unordered_multiset_of< string >, name         >,
        tagged< unordered_set_of     < int    >, phone_number >,
        set_of_relation<>

    > bimap_type;

In this other case the bimap will relate names to phone numbers.
Names can be repeated and phone numbers are unique. You can perform
quick searches by name or phone number and the container can be viewed
ordered using the relation view.\n
在第二个例子中，bimap 将姓名和电话号码关联起来。姓名可以重复而电话号码必须唯一。
你可以通过姓名或电话进行快速的查找，且容器可以按关系视图的顺序来察看。

[endsect]

[endsect]

[section:differences_with_standard_maps Differences with standard maps 与标准map的差异]

[section:insertion Insertion 插入操作]

Remember that a map can be interpreted as a relation between two collections.
In bimaps we have the freedom to change both collection types, imposing
constrains in each of them. Some insertions that we give for granted to
success in standard maps fails with bimaps.
For example:\n
记得 map 可以被解释为两组数据之间的关系。在 bimap 中，我们可以自由修改两组数据的类型，
对各组数据加以约束。这样，有些在标准 map 中可以成功的插入操作在 bimap 中就会失败。例如：

    bimap<int,std::string> bm;

    bm.left.insert(1,"orange");
    bm.left.insert(2,"orange"); // No effect! returns make_pair(iter,false) 无效！返回 make_pair(iter,false)

The insertion will only succeed if it is allowed by all views of the `bimap`.
In the next snippet we define the right collection as a multiset, when we
try to insert the same two elements the second insertion is allowed by the
left map view because both values are different and it is allowed by the
right map view because it is a non-unique collection type.\n
插入操作只有在 `bimap` 的所有视图都允许时才能成功。在后面一段代码中，我们将右组定义为 multiset，
这样我们在尝试插入与上相同的两个元素时，左映射视图因为插入的值不同而允许插入，
同时还由于右映射视图为非唯一值组合类型而允许插入。

    bimap<int, multiset_of<std::string> > bm;

    bm.left.insert(1,"orange");
    bm.left.insert(2,"orange"); // Insertion succeed! 插入成功！

If we use a custom collection of relation type, the insertion has to be
allowed by it too.\n
如果我们使用一个定制的关系类型组合，则插入操作也必须被它所允许。

[endsect]

[section:iterator__value_type iterator::value_type 迭代器的值类型]

The relations stored in the Bimap will not be in most cases modifiable
directly by iterators because both sides are used as keys of
['key-based] sets. When a `bimap<A,B>` left view iterator is dereferenced
the return type is ['signature-compatible] with a
`std::pair< const A, const B >`.
However there are some collection types that are not ['key_based], for example
list_of. If a Bimap uses one of these collection types there is no problem with
modifying the data of that side. The following code is valid:\n
保存在 bimap 中的关系通常不能通过迭代器来直接修改，因为关系的两边都会被用作['基于键]的 set 类型的键。
当提领一个 `bimap<A,B>` 的左映射视图时，返回的类型['签名兼容]于 `std::pair< const A, const B >`。
不过有些组合类型并不是['基于键]的，例如 list_of。如果一个 bimap 使用的是这些类型，
那么修改该侧数据是没有问题的。如以下代码就是有效的： 

    typedef bimap< int, list_of< std::string > > bm_type;
    bm_type bm;
    bm.insert( bm_type::relation( 1, "one" ) );
    ...
    bm.left.find(1)->second = "1"; // Valid 有效

In this case, when the iterator is dereferenced the return type is
['signature-compatible] with a `std::pair<const int, std::string>`.\n
在这个例子中，提领该迭代器时，返回的类型['签名兼容]于 `std::pair<const int, std::string>`。 

The following table shows the constness of the dereferenced data of each
collection type of:\n
下表显示了各种组合类型的被提领数据的常量性： 

[table
[[Side collection type 单侧组合类型][Dereferenced data 被提领数据]]
[[`set_of`               ][['constant 常性]]]
[[`multiset_of`          ][['constant 常性]]]
[[`unordered_set_of`     ][['constant 常性]]]
[[`unordered_multiset_of`][['constant 常性]]]
[[`list_of`              ][['mutable 可更改] ]]
[[`vector_of`            ][['mutable 可更改] ]]
[[`unconstrained_set_of` ][['mutable 可更改] ]]
]

Here are some examples. When dereferenced the iterators returns a type that
is ['signature-compatible] with these types.\n
以下是一些例子。对这些迭代器进行提领将返回一个['签名兼容]于以下类型的类型。

[table
[[Bimap type Bimap类型][Signature-compatible types 签名兼容于以下类型]]
[[`bimap<A,B>`][
    `iterator      ` *->* `relation<const A,const B>`

    `left_iterator ` *->* `pair<const A,const B>`

    `right_iterator` *->* `pair<const B,const A>`
]]
[[`bimap<multiset_of<A>,unordered_set_of<B> >`][
    `iterator      ` *->* `relation<const A,const B>`

    `left_iterator ` *->* `pair<const A,const B>`

    `right_iterator` *->* `pair<const B,const A>`
]]
[[`bimap<set_of<A>,list_of<B> >`][
    `iterator      ` *->* `relation<const A,B>`

    `left_iterator ` *->* `pair<const A,B>`

    `right_iterator` *->* `pair<B,const A>`
]]
[[`bimap<vector_of<A>,set_of<B> >`][
    `iterator      ` *->* `relation<A,const B>`

    `left_iterator ` *->* `pair<A,const B>`

    `right_iterator` *->* `pair<const B,A>`
]]
[[`bimap<list_of<A>,unconstrained_set_of<B> >`][
    `iterator      ` *->* `relation<A,B>`

    `left_iterator ` *->* `pair<A,B>`

    `right_iterator` *->* `pair<B,A>`
]]
]

[endsect]

[section operator\[\] and at()]

`set_of` and `unordered_set_of` map views overload `operator[]` to retrieve the
associated data of a given key only when the other collection type is a 
mutable one. In these cases it works in the same way as the standard.\n
`set_of` 和 `unordered_set_of` 映射视图重载了 `operator[]`，用于取出给定键值的相关联数据，
仅当另一个组合类型为可修改时可用。在此情况下它的用法与标准一样。

    bimap< unorderd_set_of< std::string>, list_of<int> > bm;

    bm.left["one"] = 1; // Ok

The standard defines an access function for `map` and `unordered_map`:\n
标准还为 `map` 和 `unordered_map` 定义了一个访问函数：

    const data_type & at(const key_type & k) const;
          data_type & at(const key_type & k);

These functions look for a key and returns the associated data value, but
throws a `std::out_of_range` exception if the key is not found.\n
该函数查找一个键值并返回相关联的数据值，不过如果键值未能找到，则抛出一个 `std::out_of_range` 异常。

In bimaps the constant version of these functions is given for `set_of` and
`unorderd_set_of` map views independently of the other collection type.
The mutable version is only provided when the other collection type is
mutable.\n
在 bimap 中，对于 `set_of` 和 `unorderd_set_of` 映射视图给出了该函数的常性版本，与另一组合类型无关。
而非常性版本则只在另一组合类型为可修改时提供。

The following examples shows the behaviour of `at(key)`\n
以下例子示范了 `at(key)` 的行为：

[@../../example/at_function_examples.cpp Go to source code 察看源代码]

[import ../example/at_function_examples.cpp]

[code_at_function_first]

[code_at_function_second]

[/
`set_of` and `unordered_set_of` views overload `operator[]` to retrieve the
associated data of a given key.
The symmetry of bimap imposes some constraints on `operator[]` that are
not found in `std::map` or `std::unordered_map`. If other views are unique,
`bimap::duplicate_value` is thrown whenever an assignment is attempted to
a value that is already a key in these views. As for
`bimap::value_not_found`, this exception is thrown while trying to access
a non-existent key: this behaviour differs from the standard containers,
which automatically assigns a default value to non-existent keys referred to
by `operator[]`.


    const data_type & operator[](const typename key_type & k) const;

[:  Returns the `data_type` reference that is associated with `k`, or
    throws `bimap::value_not_found` if such an element does not exist.
]

    ``['-unspecified data_type proxy-]`` operator[](const typename key_type & k);

[:  Returns a proxy to a `data_type` associated with `k` and the
    bimap. The proxy behaves as a reference to the `data_type` object. If this
    proxy is read and `k` was not in the bimap, the bimap::value_not_found is
    thrown. If it is written then `bimap::duplicate_value` is thrown if the
    assignment is not allowed by one of the other views of the `bimap`.
]


The following example shows the behaviour of `operator[]`

    bimap<int,std::string> bm;

    bm.left[1] = "one"; // Ok

    bm.right["two"] = 2; // Ok

    if( bm.left[3] == "three" ) // throws bimap::value_not_found
    {
        ...
    }

    bm.left[3] = "one"; // throws bimap::duplicate_value
]

[endsect]

[section:complexity_of_operations Complexity of operations 各操作的复杂度]

The complexity of some operations is different in bimaps. Read 
[link complexity_signature_explanation the reference] to find the
complexity of each function.\n
在 bimap 中有些操作的复杂度是不同的。要查看每种操作的复杂度，请看 [link complexity_signature_explanation 参考]。

[endsect]

[endsect]

[section:useful_functions Useful functions 有用的函数]

[section:projection_of_iterators Projection of iterators 迭代器的投射]

Iterators can be projected to any of the three views of the bimap.
A bimap provides three member functions to cope with projection: `project_left`,
`project_right` and `project_up`, with projects iterators to the ['left map view],
the ['right map view] and the ['collection of relations view]. These functions 
take any iterator from the bimap and retrieve an iterator over the projected view 
pointing to the same element.\n
迭代器可以被投射到 bimap 的三个视图中的任一个。bimap 提供了三个成员函数来执行投射：`project_left`, 
`project_right` 和 `project_up`, 分别将迭代器投射到 ['左映射视图]、['右映射视图] 和 ['关系组合视图]。
这些函数从 bimap 接受一个迭代器，并返回一个指向同一元素的被投射视图的迭代器。

[import ../example/projection.cpp]

Here is an example that uses projection:\n
以下是一个使用投射的例子：

[@../../example/projection.cpp Go to source code 察看源代码]

[code_projection_years]

[endsect]

[section:replace_and_modify replace and modify 替换和修改]

[import ../example/tutorial_modify_and_replace.cpp]

These functions are members of the views of a bimap that are not founded in 
their standard counterparts.\n
这些函数是 bimap 视图的成员函数，但在标准的对照物中是没有的。

The `replace` family member functions performs in-place replacement of a given 
element as the following example shows:\n
`replace` 族成员函数对一个综合元素执行就地替换，如下列所示：

[@../../example/tutorial_modify_and_replace.cpp Go to source code 察看源代码]

[code_tutorial_replace]

`replace` functions performs this substitution in such a manner that:\n
`replace` 函数按以下方式执行替换： 

* The complexity is constant time if the changed element retains its original order
with respect to all views; it is logarithmic otherwise.\n
  如果被替换元素对于所有视图都保持原有顺序，则复杂度为常量时间；否则为对数时间。
* Iterator and reference validity are preserved.\n
  迭代器和引用的有效性被保持。
* The operation is strongly exception-safe, i.e. the `bimap` remains unchanged if 
some exception (originated by the system or the user's data types) is thrown.\n
  该操作是强异常安全的，即如果有异常抛出(由系统或用户数据类型产生)，则 `bimap` 保持不变。

`replace` functions are powerful operations not provided by standard STL containers, 
and one that is specially handy when strong exception-safety is required.\n
`replace` 函数是标准STL容器没有提供的强大操作，当需要强异常安全时，它尤其方便。

The observant reader might have noticed that the convenience of replace comes at a
cost: namely the whole element has to be copied ['twice] to do the updating (when
retrieving it and inside `replace`). If elements are expensive to copy, this may
be quite a computational cost for the modification of just a tiny part of the
object. To cope with this situation, Boost.Bimap provides an alternative
updating mechanism: `modify` functions.\n
细心的读者可能已经注意到，替换操作的方便性是有代价的：即在进行更新时，整个元素必须被复制['两次]
(一次取出，一次内部 `replace`)。如果元素的复制很昂贵，那么即使是对对象的一小部分进行修改也需要较大的代价。
为了应付这一情况，Boost.Bimap 提供了另一个更新机制：`modify` 函数。

`modify` functions accepts a functor (or pointer to function) taking a reference 
to the data to be changed, thus eliminating the need for spurious copies. Like
`replace` functions, `modify` functions does preserve the internal orderings of
all the indices of the `bimap`. However, the semantics of modify functions are not
entirely equivalent to replace functions. Consider what happens if a collision occurs
as a result of modifying the element, i.e. the modified element clashes with another
with respect to some unique view. In the case of `replace` functions, the original
value is kept and the method returns without altering the container, but `modify`
functions cannot afford such an approach, since the modifying functor leaves no
trace of the previous value of the element. Integrity constraints thus lead to the
following policy: when a collision happens in the process of calling a modify functions,
the element is erased and the method returns false. This difference in behavior
between `replace` and `modify` functions has to be considered by the programmer on
a case-by-case basis.\n
`modify` 函数接受一个函数对象(或函数指针)和一个被修改数据的引用，从而消除多余的复制。
象 `replace` 函数一样，`modify` 函数保持 `bimap` 的所有索引的内部有序性。但是，
修改函数的语义并不完全等同于替换函数。考虑一下如果修改某个元素会发生冲突，
即修改后的元素与某个唯一视图的另一个元素冲突，那么会发生什么？在 `replace` 函数中，
原值将被保留，函数返回时没有对容器进行修改，而 `modify` 函数则不提供这一方式，
因为修改用的函数对象并没有保存元素的原来值。所以，完整性约束将导致以下策略：
在调用修改函数的过程中如果发生冲突，被修改元素将被删除而函数返回 false。
`replace` 和 `modify` 函数间的行为差异必须由程序员根据实际情况来考虑使用。

Boost.Bimap defines new placeholders named `_key` and `_data` to allow a sounder solution.
You have to include `<boost/bimap/support/lambda.hpp>` to use them.\n
Boost.Bimap 定义了新的占位符 `_key` 和 `_data`，以提供更漂亮的解决方案。
要使用它们，你必须包含 `<boost/bimap/support/lambda.hpp>`. 

[/
Boost.Bimap defines new placeholders to allow a sounder solution. For
pairs, two new placeholders are instantiated: `_first` and `_second`, and
for a relation, two more complete the set: `_left` and `_right`.
]

[@../../example/tutorial_modify_and_replace.cpp Go to source code 察看源代码]

[code_tutorial_modify]

[endsect]

[section:retrieval_of_ranges Retrieval of ranges 区间的取回]

[import ../example/tutorial_range.cpp]

Standard `lower_bound` and `upper_bound` functions can be used to lookup for
all the elements in a given range.\n
标准的 `lower_bound` 和 `upper_bound` 函数可以用于给定范围的所有元素。

Suppose we want to retrieve the elements from a `bimap<int,std::string>`
where the left value is in the range `[20,50]`\n
假设我们想从一个 `bimap<int,std::string>` 中取出范围为 `[20,50]` 的左值

[code_tutorial_range_standard_way]

Subtle changes to the code are required when strict inequalities are considered.
To retrieve the elements greater than 20 and less than 50, the code has to be 
rewritten as\n
如果要求严格的不等性，则需要一些修改。比如，要取出大于20小于50的元素，代码要改为

[code_tutorial_range_standard_way_subtle_changes]

To add to this complexity, the careful programmer has to take into account that
the lower and upper bounds of the interval searched be compatible: for instance,
if the lower bound is 50 and the upper bound is 20, the iterators `iter_first` and
`iter_second` produced by the code above will be in reverse order, with possibly
catastrophic results if a traversal from `iter_first` to `iter_second` is tried.
All these details make range searching a tedious and error prone task.\n
由于增加了这一复杂性，细心的程序员必须考虑查找区间的下界和上界必须兼容：例如，如果下界是50是上界是20，
则以上代码产生的迭代器 `iter_first` 和 `iter_second` 是反序的，如果尝试从 `iter_first` 到 `iter_second` 进行遍历，
就可能产生空难性的后果。所有这些细节使得区间查找成为了一件乏味而易错的工作。

The range member function, often in combination with lambda expressions,
can greatly help alleviate this situation:\n
range 成员函数，通常与 lambda 表达式一起使用，可以极大地避免这一情形：

[code_tutorial_range]

`range` simply accepts predicates specifying the lower and upper bounds of 
the interval searched. Please consult the reference for a detailed explanation 
of the permissible predicates passed to range.\n
`range` 只接受用于指定被查找区间的下界和上界的谓词。有关传递给 range 的可用谓词的详细解释，请看相关参考。 

One or both bounds can be omitted with the special unbounded marker:\n
单个或两个边界均可通过特定的无界标号来省略：

[code_tutorial_range_unbounded]

[@../../example/tutorial_range.cpp Go to source code 察看源代码]

[endsect]

[endsect]

[section:bimaps_with_user_defined_names Bimaps with user defined names 用户自定义名字的Bimap]

[import ../example/user_defined_names.cpp]

In the following example, the library user inserted comments to guide
future programmers:\n
在以下例子中，库用户插入了一些注释，以指导以后的程序员： 

[@../../example/user_defined_names.cpp Go to source code 察看源代码]

[code_user_defined_names_untagged_version]

In Boost.Bimap there is a better way to document the code and
in the meantime helping you to write more mantainable and readable code.
You can tag the two collections of the bimap so they can be 
accessed by more descriptive names.\n
在 Boost.Bimap 中，有更好的方法来注释代码，并帮助你写出更可维护和可读的代码。
你可以对 bimap 的两组数据贴上标签，然后可以通过更清晰的名字来访问它们。

__TAGGED__

A tagged type is a type that has been labelled using a tag. A tag is any
valid C++ type. In a bimap, the types are always tagged. If you do not
specify your own tag, the container uses `member_at::left` and
`member_at::right` to tag the left and right sides respectively. In order
to specify a custom tag, the type of each side has to be tagged. 
Tagging a type is very simple:\n
一个被标签类型就是一个已经被 tag 所标记的类型。tag 可以是任意一个有效的C++类型。
在一个 bimap 中，类型总是被标签的。如果你没有指定你自己的 tag，则容器使用 `member_at::left` 
和 `member_at::right` 来分别标签左组和右组。要指定一个定制的 tag，则每一边的类型都要标签。
标签一个类型非常简单：

    typedef tagged< int, a_tag > tagged_int;

Now we can rewrite the example:\n
现在我们可以重写以上例子：

[@../../example/user_defined_names.cpp Go to source code 察看源代码]

[code_user_defined_names_tagged_version]

Here is a list of common structures in both tagged and untagged versions.
Remember that when the bimap has user defined tags you can still use 
the untagged version structures.\n
以下是带标签和不带标签两种版本的常用结构。记住，当 bimap 带有用户自定义标签时，你仍然可以使用不带标签的结构。


    struct Left  {};
    struct Right {};
    typedef bimap< 
             multiset_of< tagged< int, Left  > >,
        unordered_set_of< tagged< int, Right > >
    > bm_type;

    bm_type bm;

    //...

    bm_type::iterator       iter       = bm.begin();
    bm_type::left_iterator  left_iter  = bm.left.begin();
    bm_type::right_iterator right_iter = bm.right.begin();



[table Equivalence of expresions using user defined names 使用用户自定义名字的等价表达式
[[Untagged version 不带标签的版本]               [Tagged version 带标签的版本]                     ]
[[`bm.left`]                      [`bm.by<Left>()`]                    ]
[[`bm.right`]                     [`bm.by<Right>()`]                   ]
[[`bm_type::left_map`]            [`bm::map_by<Left>::type`]           ]
[[`bm_type::right_value_type`]    [`bm::map_by<Right>::value_type`]    ]
[[`bm_type::left_iterator`]       [`bm::map_by<Left>::iterator`]       ]
[[`bm_type::right_const_iterator`][`bm::map_by<Right>::const_iterator`]]
[[`iter->left`]                   [`iter->get<Left>()`]                ]
[[`iter->right`]                  [`iter->get<Right>()`]               ]
[[`left_iter->first`]             [`left_iter->get<Left>()`]           ]
[[`left_iter->second`]            [`left_iter->get<Right>()`]          ]
[[`right_iter->first`]            [`right_iter->get<Right>()`]         ]
[[`right_iter->second`]           [`right_iter->get<Left>()`]          ]
[[`bm.project_left(iter)`]        [`bm.project<Left>(iter)`]           ]
[[`bm.project_right(iter)`]       [`bm.project<Right>(iter)`]          ]
]

[endsect]

[section:unconstrained_sets Unconstrained Sets 不受限的set]

Unconstrained sets allow the user to disable one of the views of a
bimap. Doing so makes the bimap operations execute faster and reduces
memory consumption. This completes the bidirectional mapping framework
by including unidirectional mappings as a particular case.\n
不受限 set 允许用户关闭 bimap 的某个视图。这样做可以使得 bimap 的操作执行得更快，
并且减少内存消耗。这完善了双向映射框架，包含了单向映射作为其中的一种特殊情况。

Unconstrained sets are useful for the following reasons:\n
由于以下原因，不受限 set 还是很有用的：

* A bimap type has stronger guarantees than its standard equivalent,
and includes some useful functions (replace, modify) that the standard
does not have.\n
  bimap 类型比标准的物价物有更强的保证，并包含一些标准中没有的有用函数(replace, modify)。 
* You can view the mapping as a collection of relations.\n
  你可以将映射当作一组关系来察看。
* Using this kind of map makes the code very extensible. If, at any
moment of the development, the need to perform searches from the right
side of the mapping arises, the only necessary change is to the `typedef`.\n
  使用这种 map 可以让代码非常好扩展。如果在开发的过程中，增加了要从映射的右侧进行查找的需求，要修改的只是 `typedef`. 

[import ../example/unconstrained_collection.cpp]

Given this bimap instance,\n
给出一个 bimap 例子：

[code_unconstrained_collection_bimap]

or this standard map one\n
或者一个标准的 map：

[code_unconstrained_collection_map]

The following code snippet is valid\n
以下代码片断是有效的：

[code_unconstrained_collection_common]

But using a bimap has some benefits\n
但是如果使用 bimap，则有更多好处：

[code_unconstrained_collection_only_for_bimap]

[@../../example/unconstrained_collection.cpp Go to source code 察看源代码]

[endsect]

[section:additional_information Additional information 更多的信息]

[import ../example/tutorial_info_hook.cpp]

Bidirectional maps may have associated information about each relation.
Suppose we want to represent a books and author bidirectional map.\n
双向映射可以具有关于每个关系的关联信息。假设我们想表示一个书籍与作者的双向映射。

[code_tutorial_info_hook_nothing]

Suppose now that we want to store abstract of each book.
We have two options:\n
假设现在我们想保存每本书的摘要。我们有两个选择：

# Books name are unique identifiers, so we can create a separate
`std::map< string, string >` that relates books names with abstracts.\n
  因为书名为唯一标识，所以我们可以创建一个单独的 `std::map< string, string >` 将书名和摘要关系起来。
# We can use __BOOST_MULTI_INDEX__ for the new beast.\n
  我们可以为此使用 __BOOST_MULTI_INDEX__. 

Option 1 is the wrong approach, if we go this path we lost what bimap has 
won us. We now have to maintain the logic of two interdependent containers,
there is an extra string stored for each book name, and the performance will
be worse. This is far away from being a good solution.\n
选择1是错误的方法，如果我们照此去做，将失去 bimap 带给我们的好处。我们现在必须维护两个独立容器的逻辑，
每个书名都保存有一个额外的字符串，而且性能也会变差。这不是一个好的解决方案。

Option 2 is correct. We start thinking books as entries in a table. So it
makes sense to start using Boost.MultiIndex. We can then add the year
of publication, the price, etc... and we can index this new items too. So
Boost.MultiIndex is a sound solution for our problem.\n
选择2是正确的。我们将书视为一张表中的项。所以显然应该使用 Boost.MultiIndex。
我们可以增加出版年份、价格等等...我们还可以对新增项进行索引。所以对于我们的问题，
Boost.MultiIndex 是正确的解决方案。

The thing is that there are cases where we want to maintain bimap
semantics (use `at()` to find an author given a book name and the other way
around) and add information about the relations that we are sure we will not
want to index later (like the abstracts). Option 1 is not possible, option 2
neither.\n
问题是，在有些情况下，我们希望保持 bimap 的语义时(使用 `at()` 查找给定书名的作者或其它方式)
并且增加与关系相关的信息，我们确保这些信息是不需要索引的(如摘要)。选择1 是不可能的，选择2也不行。

Boost.Bimap provides support for this kind of situations by means of
an embedded information member.
You can pass an extra parameter to a bimap: `with_info< InfoType >`
and an `info` member of type `InfoType` will appear in the relation and bimap
pairs.\n
Boost.Bimap 通过一个嵌入的信息成员为这种情形提供了支持。你可以传递给 bimap 一个额外的参数：
`with_info< InfoType >`，一个类型为 `InfoType` 的 `info` 成员会出现在关系和 bimap 对中。

__RELATION_AND_PAIR_WITH_INFO__

Relations and bimap pairs constructors will take an extra argument.
If only two arguments are used, the information will be initialized with
their default constructor.\n
关系和 bimap 对的构造函数将接受一个额外的参数。如果只使用两个参数，则该信息将被它们的缺省构造函数所初始化。

[code_tutorial_info_hook_first]

Contrary to the two key types, the information will be mutable using iterators.\n
与两个键类型不同，该信息可以通过迭代器进行修改。

[code_tutorial_info_hook_mutable]

A new function is included in ['unique] map views: `info_at(key)`, that mimics the
standard `at(key)` function but returned the associated information instead of
the data.\n
在['唯一]映射视图中将新增一个函数：`info_at(key)`，它模仿标准的 `at(key)` 函数，
但返回的是相关联的信息而不是数据。

[code_tutorial_info_hook_info_at]

The info member can be tagged just as the left or the right member. The following
is a rewrite of the above example using user defined names:\n
成员 info 可以象 left 和 right 成员那样加标签。以下使用用户自定义名字重写上述例子：

[code_tutorial_info_hook_tagged_info]

[@../../example/tutorial_info_hook.cpp Go to source code 察看源代码]

[endsect]

[section:complete_instantiation_scheme Complete instantiation scheme 完整的实例化方案]

To summarize, this is the complete instantiation scheme.\n
作为总结，以下是完整的实例化方案。

    typedef bimap
    <
        LeftCollectionType, RightCollectionType

        [ , SetTypeOfRelation  ]  // Default to left_based
        [ , with_info< Info >  ]  // Default to no info
        [ , Allocator          ]  // Default to std::allocator<>

    > bm;

`{Side}CollectionType` can directly be a type. This defaults to
`set_of<Type>`, or can be a `{CollectionType}_of<Type>` specification.
Additionally, the type of this two parameters can be tagged to specify 
user defined names instead of the usual `member_at::-Side-` tags. \n
`{Side}CollectionType` 可以直接为一类型。缺省为 `set_of<Type>`，或者可以是 `{CollectionType}_of<Type>` 声明。
另外，这两个参数的类型可以被标签，以用户自定义名字替换普通的 `member_at::-Side- tags`. 

The possibles way to use the first parameter are:\n
使用第一个参数的可能方法有：

    bimap< Type, R >

* Left type:                `Type`\n
  左类型：                  `Type`
* Left collection type:     `set_of< Type >`\n
  左组合类型：`set_of< Type >` 
* Left tag:                 `member_at::left`\n
  左标签：`member_at::left`

    bimap< {CollectionType}_of< Type >, R >

* Left type:                `Type`\n
  左类型：                  `Type`
* Left collection type:     `{CollectionType}_of< LeftType >`\n
  左组合类型：`{CollectionType}_of< LeftType >` 
* Left tag:                 `member_at::left`\n
  左标签：`member_at::left`

    bimap< tagged< Type, Tag >, R >

* Left type:                `Type`\n
  左类型：                  `Type`
* Left collection type:     `set_of< LeftType >`\n
  左组合类型：`set_of< LeftType >` 
* Left tag:                 `Tag`\n
  左标签：`Tag`

    bimap< {CollectionType}_of< tagged< Type, Tag > >, R >

* Left type:                `Type`\n
  左类型：                  `Type`
* Left collection type:     `{CollectionType}_of< LeftType >`\n
  左组合类型：`{CollectionType}_of< LeftType >` 
* Left tag:                 `Tag`\n
  左标签：`Tag`

The same options are available for the second parameter.\n
对于第二个参数，有相同选项可用。

The last three parameters are used to specify the collection type of the relation,
the information member and the allocator type.\n
后三个参数用于指定关系组合类型、信息成员和分配器类型。

If you want to specify a custom allocator type while relying on the default
value of CollectionTypeOfRelation, you can do so by simply writing
`bimap<LeftKeyType, RightKeyType, Allocator>`. Boost.Bimap's internal
machinery detects that the third parameter in this case does not refer
to the relation type but rather to an allocator.\n
如果你想指定一个依赖于 CollectionTypeOfRelation 缺省值的定制分配器类型，
你只需要写 `bimap<LeftKeyType, RightKeyType, Allocator>`。在这种情况下，
Boost.Bimap 的内部机制会检测出第三个参数不是指向关系类型而是一个分配器。

The following are the possible ways of instantiating the last three parameters
of a bimap. You can ignore some of the parameter but the order must be respected.\n
以下是实例化一个 bimap 的后三个参数的可能方法。你可以忽略一些参数，但顺序必须遵守。


    bimap< L, R >

* set_of_relation_type: based on the left key type\n
  set_of_relation_type: 基于左键类型
* info:                 no info\n
  info: 无信息
* allocator:            std::allocator


    bimap< L, R ,SetOfRelationType>

* set_of_relation_type: SetOfRelationType
* info:                 no info\n
  info: 无信息
* allocator:            std::allocator


    bimap< L, R , SetOfRelationType, with_info<Info> >

* set_of_relation_type: SetOfRelationType
* info:                 Info
* allocator:            std::allocator


    bimap< L, R , SetOfRelationType, with_info<Info>, Allocator>

* set_of_relation_type: SetOfRelationType
* info:                 Info
* allocator:            Allocator


    bimap< L, R , SetOfRelationType, Allocator>

* set_of_relation_type: SetOfRelationType
* info:                 no info\n
  info: 无信息
* allocator:            Allocator


    bimap< L, R , with_info<Info> >

* set_of_relation_type: based on the left key type\n
  set_of_relation_type: 基于左键类型 
* info:                 Info
* allocator:            std::allocator


    bimap< L, R , with_info<Info>, Allocator>

* set_of_relation_type: based on the left key type\n
  set_of_relation_type: 基于左键类型 
* allocator:            Allocator


    bimap< L, R , Allocator>

* set_of_relation_type: based on the left key type\n
  set_of_relation_type: 基于左键类型 
* info:                 no info\n
  info: 无信息
* allocator:            Allocator




[endsect]

[endsect]

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Discovering the bimap framework</title><link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="Chapter&nbsp;1.&nbsp;Boost.Bimap">
<link rel="up" href="../the_tutorial.html" title="The tutorial">
<link rel="prev" href="../the_tutorial.html" title="The tutorial">
<link rel="next" href="controlling_collection_types.html" title="Controlling collection types"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../the_tutorial.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../the_tutorial.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="controlling_collection_types.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_bimap.the_tutorial.discovering_the_bimap_framework"></a><a class="link" href="discovering_the_bimap_framework.html" title="Discovering the bimap framework">Discovering
      the bimap framework 介绍 bimap 框架</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="discovering_the_bimap_framework.html#boost_bimap.the_tutorial.discovering_the_bimap_framework.interpreting_bidirectional_maps">Interpreting
        bidirectional maps 解释双向映射</a></span></dt>
<dt><span class="section"><a href="discovering_the_bimap_framework.html#boost_bimap.the_tutorial.discovering_the_bimap_framework.standard_mapping_framework">Standard
        mapping framework 标准的映射框架</a></span></dt>
<dt><span class="section"><a href="discovering_the_bimap_framework.html#boost_bimap.the_tutorial.discovering_the_bimap_framework.bimap_mapping_framework">Bimap
        mapping framework &nbsp;Bimap的映射框架</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.the_tutorial.discovering_the_bimap_framework.interpreting_bidirectional_maps"></a><a class="link" href="discovering_the_bimap_framework.html#boost_bimap.the_tutorial.discovering_the_bimap_framework.interpreting_bidirectional_maps" title="Interpreting bidirectional maps">Interpreting
        bidirectional maps 解释双向映射</a>
</h4></div></div></div>
<p>
          One way to interpret bidirectional maps is as a function between two collections
          of data, lets call them the left and the right collection. An element in
          this bimap is a relation between an element from the left collection and
          an element from the right collection. The types of both collections defines
          the bimap behaviour. We can view the stored data from the left side, as
          a mapping between keys from the left collection and data from the right
          one, or from the right side, as a mapping between keys from the right collection
          and data from the left collection.&nbsp;</p><p>对
双向映射的一种解释是，它是两组数据之间的一个函数，我们将这两组数据分别称为左组和右组。这个 bimap
中的一个元素就是左组中的一个元素与右组中的一个元素间的关系。这两个组的类型定义了 bimap
的行为。我们可以从左边来察看所保存的数据，就如一个以左组为键以右组为数据的映射，也可以从右边来察看，就如一个以右组为键以左组为数据的映射。
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.the_tutorial.discovering_the_bimap_framework.standard_mapping_framework"></a><a class="link" href="discovering_the_bimap_framework.html#boost_bimap.the_tutorial.discovering_the_bimap_framework.standard_mapping_framework" title="Standard mapping framework">Standard
        mapping framework 标准的映射框架</a>
</h4></div></div></div>
<p>
          Relationships between data in the STL are represented by maps. A standard
          map is a directed relation of keys from a left collection and data from
          a right unconstrained collection. The following diagram shows the relationship
          represented and the user's viewpoint.</p><p>在STL中，数据间的关系被表示为映射map。标准的 map 是以左组为键以右组为数据的一种直接关系，对右组数据无限制。下图显示了所表示的关系以及用户的视点。
        </p>
<p>
          <span class="inlinemediaobject"><img src="../../images/bimap/standard.mapping.framework.png" alt="standard.mapping.framework"></span>
        </p>
<p>
          The left collection type depends on the selected map type. For example
          if the the map type is <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">multimap</span></code>
          the collection type of X is a <code class="computeroutput"><span class="identifier">multiset_of</span></code>.
          The following table shows the equivalent types for the std associative
          containers.</p><p>左组的类型取决于所选择的 map 类型。例如，如果 map 类型为 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">multimap</span></code> 则 X 的类型为 <code class="computeroutput"><span class="identifier">multiset_of</span></code>. 下表显示了标准关联式容器的等价类型。
          
        </p>
<div class="table">
<a name="id2640562"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;std associative containers&nbsp;</b></p><p class="title"><b>表 1.1 标准关联式容器</b></p>
<div class="table-contents"><table class="table" summary="std associative containers">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
              <p>
                container 容器
              </p>
              </th>
<th>
              <p>
                left collection type 左组类型
              </p>
              </th>
<th>
              <p>
                right collection type 右组类型
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">map</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">set_of</span></code>
              </p>
              </td>
<td>
              <p>
                no constraints 无约束
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">multimap</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">multiset_of</span></code>
              </p>
              </td>
<td>
              <p>
                no constraints 无约束
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">unordered_map</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">unordered_set_of</span></code>
              </p>
              </td>
<td>
              <p>
                no constraints 无约束
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">unordered_multimap</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">unordered_multiset_of</span></code>
              </p>
              </td>
<td>
              <p>
                no constraints 无约束
              </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.the_tutorial.discovering_the_bimap_framework.bimap_mapping_framework"></a><a class="link" href="discovering_the_bimap_framework.html#boost_bimap.the_tutorial.discovering_the_bimap_framework.bimap_mapping_framework" title="Bimap mapping framework">Bimap
        mapping framework &nbsp;Bimap的映射框架</a>
</h4></div></div></div>
<p>
          Boost.Bimap design is based on the STL, and extends the framework in a
          natural way. The following diagram represents the new situation.</p><p>Boost.Bimap 的设计基于STL，并以自然的方法扩展了该框架。下图表示了新的情况。
        </p>
<p>
          <span class="inlinemediaobject"><img src="../../images/bimap/extended.mapping.framework.png" alt="extended.mapping.framework"></span>
        </p>
<p>
          Notice that now the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">maps</span></code>
          are a particular case of a Boost.Bimap container, where you can view only
          one side of the relationship and can control the constraints of only one
          of the collections. Boost.Bimap allows the user to view the relationship
          from three viewpoints. You can view it from one side, obtaining a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span></code> compatible container, or you can
          work directly with the whole relation.</p><p>留意，现在 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span></code> 成了 Boost.Bimap 容器的一种特定情形，即你只能从关系的一侧进行察看，而且只能控制一组数据的约束。Boost.Bimap 允许用户从三个视点察看关系。你既可以从某一边来察看，得到一个与 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span></code> 兼容的容器，也可以直接对整个关系进行操作。
        </p>
<p>
          The next diagram shows the layout of the relation and pairs of a bimap.
          It is the one from the <span class="emphasis"><em>one minute tutorial</em></span></p><p><span class="emphasis"><em></em></span>下图显示了一个 bimap 的关系布局和值对。它来自于 <span class="emphasis"><em>一分钟教程</em></span>
        </p>
<p>
          <span class="inlinemediaobject"><img src="../../images/bimap/relation.and.pair.png" alt="relation.and.pair"></span>
        </p>
<p>
          Bimap pairs are signature-compatible with standard pairs but are different
          from them. As you will see in other sections they can be tagged with user
          defined names and additional information can be attached to them. You can
          convert from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pairs</span></code> to bimap pairs directly but the
          reverse conversion is not provided. This mean that you can insert elements
          in a bimap using algorithms like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span></code>
          from containers <code class="computeroutput"><span class="identifier">like</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span></code>,
          or use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span></code> to add new elements. However
          it is best to use <code class="computeroutput"><span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_value_type</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span><span class="identifier">s</span><span class="special">)</span> <span class="special">)</span></code> instead
          of <code class="computeroutput"><span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span><span class="identifier">s</span><span class="special">)</span> <span class="special">)</span></code> to avoid
          an extra call to the copy constructor of each type.</p><p>Bimap 对与标准的 pair 签名兼容，但有所不同。正如你将在另一个章节中看到的，它们可以用用户自定义名字来标识，以附加额外信息。你可以直接从 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pairs</span></code> 转换到 bimap，但反向的转换而不提供。这意味着你可以使用象 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span></code> 这样的算法从<code class="computeroutput"> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span></code> 这样的容器向 bimap 插入元素，或者使用 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span></code> 来增加新的元素。但是最好还是使用 <code class="computeroutput"><span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_value_type</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span><span class="identifier">s</span><span class="special">)</span> <span class="special">)</span></code> 来替代 <code class="computeroutput"><span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span><span class="identifier">s</span><span class="special">)</span> <span class="special">)</span></code> 以避免对各个类型的复制构造函数的额外调用。
        </p>
<p>
          The following code snippet shows the relation between a bimap and standard
          maps.</p><p>以下代码片断显示了 bimap 与标准 map 之间的关系。
        </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top">
<p>
            You have to used references to views, and not directly views object.
            Views cannot be constructed as separate objects from the container they
            belong to, so the following:</p><p>你必须使用视图的引用，而不是直接使用视图对象。视图不能被作为独立的对象从它们所属的容器中构造得到，所以以下代码： 
</p>
<pre class="programlisting"><span class="comment">// Wrong: we forgot the &amp; after bm_type::left_type<br>// 错误：我们忘记了在 bm_type::left_type 后加 &amp;<br></span><span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_map</span> <span class="identifier">lm</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">;</span>
</pre>
<p>
            does not compile, since it is trying to construct the view object <code class="computeroutput"><span class="identifier">lm</span></code>. This is a common source of errors
            in user code.<br>将不能编译，因为它试图构造视图对象 <code class="computeroutput"><span class="identifier">lm</span></code>。这是用户代码中常见的错误来源。</p>
</td></tr>
</tbody></table></div>
<p>
          <a href="../../../../example/standard_map_comparison.cpp" target="_top">Go to source code 察看源代码</a>
        </p>


<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Map</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">CompatibleKey</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">CompatibleData</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">use_it</span><span class="special">(</span> <span class="identifier">Map</span> <span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span>
             <span class="keyword">const</span> <span class="identifier">CompatibleKey</span>  <span class="special">&amp;</span> <span class="identifier">key</span><span class="special">,</span>
             <span class="keyword">const</span> <span class="identifier">CompatibleData</span> <span class="special">&amp;</span> <span class="identifier">data</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Map</span><span class="special">::</span><span class="identifier">value_type</span> <span class="identifier">value_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Map</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">const_iterator</span><span class="special">;</span>

    <span class="identifier">m</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">value_type</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span><span class="identifier">data</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">const_iterator</span> <span class="identifier">iter</span> <span class="special">=</span> <span class="identifier">m</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">iter</span> <span class="special">!=</span> <span class="identifier">m</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">assert</span><span class="special">(</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">first</span>  <span class="special">==</span> <span class="identifier">key</span>  <span class="special">);</span>
        <span class="identifier">assert</span><span class="special">(</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">second</span> <span class="special">==</span> <span class="identifier">data</span> <span class="special">);</span>

        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">first</span> <span class="special">&lt;&lt;</span> <span class="string">" --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">m</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="identifier">set_of</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">set_of</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">bimap_type</span><span class="special">;</span>
    <span class="identifier">bimap_type</span> <span class="identifier">bm</span><span class="special">;</span>

    <span class="comment">// Standard map 标准map<br></span>    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">map_type</span><span class="special">;</span>
        <span class="identifier">map_type</span> <span class="identifier">m</span><span class="special">;</span>

        <span class="identifier">use_it</span><span class="special">(</span> <span class="identifier">m</span><span class="special">,</span> <span class="string">"one"</span><span class="special">,</span> <span class="number">1</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Left map view 左映射视图<br></span>    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">bimap_type</span><span class="special">::</span><span class="identifier">left_map</span> <span class="identifier">map_type</span><span class="special">;</span>
        <span class="identifier">map_type</span> <span class="special">&amp;</span> <span class="identifier">m</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">;</span>

        <span class="identifier">use_it</span><span class="special">(</span> <span class="identifier">m</span><span class="special">,</span> <span class="string">"one"</span><span class="special">,</span> <span class="number">1</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Reverse standard map 反标准map<br></span>    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">reverse_map_type</span><span class="special">;</span>
        <span class="identifier">reverse_map_type</span> <span class="identifier">rm</span><span class="special">;</span>

        <span class="identifier">use_it</span><span class="special">(</span> <span class="identifier">rm</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="string">"one"</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Right map view 右映射视图<br></span>    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">bimap_type</span><span class="special">::</span><span class="identifier">right_map</span> <span class="identifier">reverse_map_type</span><span class="special">;</span>
        <span class="identifier">reverse_map_type</span> <span class="special">&amp;</span> <span class="identifier">rm</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span><span class="special">;</span>

        <span class="identifier">use_it</span><span class="special">(</span> <span class="identifier">rm</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="string">"one"</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2006 -2007 Matias Capeletto<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../the_tutorial.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../the_tutorial.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="controlling_collection_types.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
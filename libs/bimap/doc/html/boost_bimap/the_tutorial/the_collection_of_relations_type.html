<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>The collection of relations type</title><link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="Chapter&nbsp;1.&nbsp;Boost.Bimap">
<link rel="up" href="../the_tutorial.html" title="The tutorial">
<link rel="prev" href="controlling_collection_types.html" title="Controlling collection types">
<link rel="next" href="differences_with_standard_maps.html" title="Differences with standard maps"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="controlling_collection_types.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../the_tutorial.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="differences_with_standard_maps.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_bimap.the_tutorial.the_collection_of_relations_type"></a><a class="link" href="the_collection_of_relations_type.html" title="The collection of relations type">The
      collection of relations type 关系组合的类型</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="the_collection_of_relations_type.html#boost_bimap.the_tutorial.the_collection_of_relations_type.a_new_point_of_view">A
        new point of view 对于视图的一个新观点</a></span></dt>
<dt><span class="section"><a href="the_collection_of_relations_type.html#boost_bimap.the_tutorial.the_collection_of_relations_type.configuration_parameters">Configuration
        parameters 配置参数</a></span></dt>
<dt><span class="section"><a href="the_collection_of_relations_type.html#boost_bimap.the_tutorial.the_collection_of_relations_type.examples">Examples 示例</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.the_tutorial.the_collection_of_relations_type.a_new_point_of_view"></a><a class="link" href="the_collection_of_relations_type.html#boost_bimap.the_tutorial.the_collection_of_relations_type.a_new_point_of_view" title="A new point of view">A
        new point of view 对于视图的一个新观点</a>
</h4></div></div></div>
<p>
          Being able to change the collection type of the bimap relation view is
          another very important feature. Remember that this view allows the user
          to see the container as a group of the stored relations. This view has
          set semantics instead of map semantics.</p><p>能够修改 bimap 关系视图的组合类型是 bimap 的另一个重要特性。该视图可以允许用户将容器视为所保存关系的一个群组。该视图具有 set 语义而不是 map 语义。
        </p>
<p>
          <span class="inlinemediaobject"><img src="../../images/bimap/collection.type.of.relation.png" alt="collection.type.of.relation"></span>
        </p>
<p>
          By default, Boost.Bimap will base the collection type of the relation on
          the type of the left collection. If the left collection type is a set,
          then the collection type of the relation will be a set with the same order
          as the left view.</p><p>缺省情况下，Boost.Bimap 将其关系的组合类型基于其左组类型。如果左组类型为 set，则关系的组合类型同样是一个 set，并具有与左视图相同的顺序。
        </p>
<p>
          In general, Boost.Bimap users will base the collection type of a relation
          on the type of the collection on one of the two sides. However there are
          times where it is useful to give this collection other constraints or simply
          to order it differently. The user is allowed to choose between:</p><p>通常，Boost.Bimap 的用户会将关系的组合类型基于两方组合之一。但是有时候也需要对该组合给定其它约束或者使其顺序不同。用户可以从以下所列进行选择：
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            left_based
          </li>
<li>
            right_based
          </li>
<li>
            set_of_relation&lt;&gt;
          </li>
<li>
            multiset_of_relation&lt;&gt;
          </li>
<li>
            unordered_set_of_relation&lt;&gt;
          </li>
<li>
            unordered_multiset_of_relation&lt;&gt;
          </li>
<li>
            list_of_relation
          </li>
<li>
            vector_of_relation
          </li>
<li>
            unconstrained_set_of_relation
          </li>
</ul></div>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top"><p>
            The first two options and the last produce faster bimaps, so prefer these
            where possible.</p><p>头两个和最后一个选择可以产生较快的 bimap，所以应该尽可能优先选择它们。
          </p></td></tr>
</tbody></table></div>
<p>
          <span class="inlinemediaobject"><img src="../../images/bimap/more.bimap.structures.png" alt="more.bimap.structures"></span>
        </p>
<p>
          The collection type of relation can be used to create powerful containers.
          For example, if you need to maximize search speed, then the best bidirectional
          map possible is one that relates elements from an <code class="computeroutput"><span class="identifier">unordered_set</span></code>
          to another <code class="computeroutput"><span class="identifier">unordered_set</span></code>.
          The problem is that this container cannot be iterated. If you need to know
          the list of relations inside the container, you need another collection
          type of relation. In this case, a <code class="computeroutput"><span class="identifier">list_of_relation</span></code>
          is a good choice. The resulting container trades insertion and deletion
          time against fast search capabilities and the possibility of bidirectional
          iteration.</p><p>关系组合的类型可以用于创建强大的容器。例如，如果你需要最快的查找速度，那么最好的双向映射可能是这样的，相关联的元素从一个 <code class="computeroutput"><span class="identifier">unordered_set</span></code> 映射到另一个 <code class="computeroutput"><span class="identifier">unordered_set</span></code>。问题是，这个容器不能被遍历。如果你需要知道容器内部的关系列表，你就需要另一种的关系组合类型。在这种情况下，<code class="computeroutput"><span class="identifier">list_of_relation</span></code> 是一个好的选择。这样所得到的容器以牺牲插入和删除的时间换取了更快的查找速度，并且可以被双向遍历。
        </p>


<p>
          <a href="../../../../example/mighty_bimap.cpp" target="_top">Go to source code 察看源代码</a></p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">/</span><span class="identifier">list_of</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">/</span><span class="identifier">unordered_set_of</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">english</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">spanish</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">bimaps</span><span class="special">;</span>

    <span class="keyword">typedef</span> <span class="identifier">bimap</span>
    <span class="special">&lt;</span>
        <span class="identifier">unordered_set_of</span><span class="special">&lt;</span> <span class="identifier">tagged</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">spanish</span> <span class="special">&gt;</span> <span class="special">&gt;,</span>
        <span class="identifier">unordered_set_of</span><span class="special">&lt;</span> <span class="identifier">tagged</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">english</span> <span class="special">&gt;</span> <span class="special">&gt;,</span>
        <span class="identifier">list_of_relation</span>

    <span class="special">&gt;</span> <span class="identifier">translator</span><span class="special">;</span>

    <span class="identifier">translator</span> <span class="identifier">trans</span><span class="special">;</span>

    <span class="comment">// We have to use `push_back` because the collection of relations is<br></span>    <span class="comment">// a `list_of_relation`<br>    // 我们必须使用</span><span class="comment">`push_back`</span><span class="comment">，因为关系组合是</span><span class="comment">`list_of_relation`</span><span class="comment"> <br></span>
    <span class="identifier">trans</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">translator</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"hola"</span>  <span class="special">,</span><span class="string">"hello"</span>   <span class="special">)</span> <span class="special">);</span>
    <span class="identifier">trans</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">translator</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"adios"</span> <span class="special">,</span><span class="string">"goodbye"</span> <span class="special">)</span> <span class="special">);</span>
    <span class="identifier">trans</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">translator</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"rosa"</span>  <span class="special">,</span><span class="string">"rose"</span>    <span class="special">)</span> <span class="special">);</span>
    <span class="identifier">trans</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">translator</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"mesa"</span>  <span class="special">,</span><span class="string">"table"</span>   <span class="special">)</span> <span class="special">);</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"enter a word"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">word</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">getline</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cin</span><span class="special">,</span><span class="identifier">word</span><span class="special">);</span>

    <span class="comment">// Search the queried word on the from index (Spanish)<br>    // 在 from 索引</span><span class="comment">(Spanish)</span><span class="comment">上查找被询问的单词<br></span>
    <span class="identifier">translator</span><span class="special">::</span><span class="identifier">map_by</span><span class="special">&lt;</span><span class="identifier">spanish</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">is</span>
        <span class="special">=</span> <span class="identifier">trans</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">spanish</span><span class="special">&gt;().</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">word</span><span class="special">);</span>

    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">is</span> <span class="special">!=</span> <span class="identifier">trans</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">spanish</span><span class="special">&gt;().</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">word</span> <span class="special">&lt;&lt;</span> <span class="string">" is said "</span>
                  <span class="special">&lt;&lt;</span> <span class="identifier">is</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">english</span><span class="special">&gt;()</span>
                  <span class="special">&lt;&lt;</span> <span class="string">" in English"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">else</span>
    <span class="special">{</span>
        <span class="comment">// Word not found in Spanish, try our luck in English<br>        // Spanish的单词未能查找到，试一下English<br></span>
        <span class="identifier">translator</span><span class="special">::</span><span class="identifier">map_by</span><span class="special">&lt;</span><span class="identifier">english</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">ie</span>
            <span class="special">=</span> <span class="identifier">trans</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">english</span><span class="special">&gt;().</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">word</span><span class="special">);</span>

        <span class="keyword">if</span><span class="special">(</span> <span class="identifier">ie</span> <span class="special">!=</span> <span class="identifier">trans</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">english</span><span class="special">&gt;().</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">word</span> <span class="special">&lt;&lt;</span> <span class="string">" is said "</span>
                      <span class="special">&lt;&lt;</span> <span class="identifier">ie</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">spanish</span><span class="special">&gt;()</span>
                      <span class="special">&lt;&lt;</span> <span class="string">" in Spanish"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="keyword">else</span>
        <span class="special">{</span>
            <span class="comment">// Word not found, show the possible translations<br>            // 单词未能找到，显示可能的翻译<br></span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"No such word in the dictionary"</span>      <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"These are the possible translations"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

            <span class="keyword">for</span><span class="special">(</span> <span class="identifier">translator</span><span class="special">::</span><span class="identifier">const_iterator</span>
                    <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">trans</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span>
                    <span class="identifier">i_end</span> <span class="special">=</span> <span class="identifier">trans</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>

                    <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">i_end</span> <span class="special">;</span> <span class="special">++</span><span class="identifier">i</span> <span class="special">)</span>
            <span class="special">{</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">spanish</span><span class="special">&gt;()</span>
                          <span class="special">&lt;&lt;</span> <span class="string">" &lt;---&gt; "</span>
                          <span class="special">&lt;&lt;</span> <span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">english</span><span class="special">&gt;()</span>
                          <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
            <span class="special">}</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.the_tutorial.the_collection_of_relations_type.configuration_parameters"></a><a class="link" href="the_collection_of_relations_type.html#boost_bimap.the_tutorial.the_collection_of_relations_type.configuration_parameters" title="Configuration parameters">Configuration
        parameters 配置参数</a>
</h4></div></div></div>
<p>
          Each collection type of relation has different parameters to control its
          behaviour. For example, in the <code class="computeroutput"><span class="identifier">set_of_relation</span></code>
          specification, you can pass a Functor type that compares two types. All
          of the parameters are exactly as in the standard library containers, except
          for the type, which is set to the bimap relation and the allocator type.
          To help users in the creation of each functor, the collection type of relation
          templates takes an mpl lambda expression where the relation type will be
          evaluated later. A placeholder named <code class="computeroutput"><span class="identifier">_relation</span></code>
          is available to bimap users.</p><p>每一种关系组合类型都有不同的参数来控制其行为。例如，在 <code class="computeroutput"><span class="identifier">set_of_relation</span></code>
的规格说明中，你可以传入一个函数对象类型来比较两种类型。所有这些参数都与标准库中的一致，除了用于那些被设置为 bimap
关系的类型和分配器类型。为了帮助用户创建每个函数对象，关系组合类型的模板接受一个 mpl lambda
表达式，关系的类型会被延迟求值。bimap 的用户可以使用一个名为 <code class="computeroutput"><span class="identifier">_relation</span></code> 的占位符。
        </p>
<p>
          The following table lists the meaning of the parameters for each collection
          type of relations.</p><p>下表列出了每种关系组合类型的各个参数的意义。
        </p>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  name 名字
                </p>
                </th>
<th>
                <p>
                  Additional Parameters 额外的参数
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">left_based</span></code>
                </p>
                </td>
<td>
                <p>
                  Not a template.</p><p>非模板。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">right_based</span></code>
                </p>
                </td>
<td>
                <p>
                  Not a template.</p><p>非模板。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">set_of_relation</span><span class="special">&lt;</span><span class="identifier">KeyComp</span><span class="special">&gt;</span></code>
                </p>
                <p>
                  <code class="computeroutput"><span class="identifier">multiset_of_relation</span><span class="special">&lt;</span><span class="identifier">KeyComp</span><span class="special">&gt;</span></code>
                </p>
                </td>
<td>
                <p>
                  <span class="bold"><strong>KeyComp </strong></span> is a Functor that compares
                  two types using less than. By default, the less-than operator is
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">_relation</span><span class="special">&gt;</span></code>.<span class="bold"><strong></strong></span></p><p><span class="bold"><strong>KeyComp </strong></span> 是一个函数对象，它用小于关系比较两个类型。缺省情况下，小于比较操作符为
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">_relation</span><span class="special">&gt;</span></code>.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">unordered_set_of_relation</span><span class="special">&lt;</span><span class="identifier">HashFunctor</span><span class="special">,</span><span class="identifier">EqualKey</span><span class="special">&gt;</span></code>
                </p>
                <p>
                  <code class="computeroutput"><span class="identifier">unordered_multiset_of_relation</span><span class="special">&lt;</span><span class="identifier">HashFunctor</span><span class="special">,</span><span class="identifier">EqualKey</span><span class="special">&gt;</span></code>
                </p>
                </td>
<td>
                <p>
                  <span class="bold"><strong>HashFunctor </strong></span> converts the <code class="computeroutput"><span class="identifier">relation</span></code> into an <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></code> value. By default it is
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">_relation</span><span class="special">&gt;</span></code>.</p><p><span class="bold"><strong>HashFunctor </strong></span>将 <code class="computeroutput"><span class="identifier">relation</span></code> 转换为一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></code> 值。缺省情况下，它是
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">_relation</span><span class="special">&gt;</span></code>.
                </p>
                <p>
                  <span class="bold"><strong>EqualKey </strong></span> is a Functor that tests
                  two relations for equality. By default, the equality operator is
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">_relation</span><span class="special">&gt;</span></code>.<br><span class="bold"><strong>EqualKey </strong></span> 是一个函数对象，它测试两个类型的等价性。缺省情况下，等价操作符为
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">_relation</span><span class="special">&gt;</span></code>.
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">list_of_relation</span></code>
                </p>
                </td>
<td>
                <p>
                  Not a template.</p><p>非模板。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">vector_of_relation</span></code>
                </p>
                </td>
<td>
                <p>
                  Not a template.</p><p>非模板。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">unconstrained_set_of_relation</span></code>
                </p>
                </td>
<td>
                <p>
                  Not a template.</p><p>非模板。
                </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.the_tutorial.the_collection_of_relations_type.examples"></a><a class="link" href="the_collection_of_relations_type.html#boost_bimap.the_tutorial.the_collection_of_relations_type.examples" title="Examples">Examples 示例</a>
</h4></div></div></div>
<p>
          Consider this example:</p><p>考虑以下例子：
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Rel</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">RelOrder</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Rel</span> <span class="identifier">ra</span><span class="special">,</span> <span class="identifier">Rel</span> <span class="identifier">rb</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">(</span><span class="identifier">ra</span><span class="special">.</span><span class="identifier">left</span><span class="special">+</span><span class="identifier">ra</span><span class="special">.</span><span class="identifier">right</span><span class="special">)</span> <span class="special">&lt;</span> <span class="special">(</span><span class="identifier">rb</span><span class="special">.</span><span class="identifier">left</span><span class="special">+</span><span class="identifier">rb</span><span class="special">.</span><span class="identifier">right</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">bimap</span>
<span class="special">&lt;</span>
        <span class="identifier">multiset_of</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;,</span>
        <span class="identifier">multiset_of</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;,</span>
        <span class="identifier">set_of_relation</span><span class="special">&lt;</span> <span class="identifier">RelOrder</span><span class="special">&lt;</span><span class="identifier">_relation</span><span class="special">&gt;</span> <span class="special">&gt;</span>

<span class="special">&gt;</span> <span class="identifier">bimap_type</span><span class="special">;</span>
</pre>
<p>
          Here the bimap relation view is ordered using the information of both sides.
          This container will only allow unique relations because <code class="computeroutput"><span class="identifier">set_of_relation</span></code>
          has been used but the elements in each side of the bimap can be repeated.</p><p>以上 bimap 的关系视图使用两边的信息来排序。该容器只允许不重复的关系，因为用的是 <code class="computeroutput"><span class="identifier">set_of_relation</span></code>，不过 bimap 每侧的元素则可以重复。
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">name</span>         <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">phone_number</span> <span class="special">{};</span>

<span class="keyword">typedef</span> <span class="identifier">bimap</span>
<span class="special">&lt;</span>
    <span class="identifier">tagged</span><span class="special">&lt;</span> <span class="identifier">unordered_multiset_of</span><span class="special">&lt;</span> <span class="identifier">string</span> <span class="special">&gt;,</span> <span class="identifier">name</span>         <span class="special">&gt;,</span>
    <span class="identifier">tagged</span><span class="special">&lt;</span> <span class="identifier">unordered_set_of</span>     <span class="special">&lt;</span> <span class="keyword">int</span>    <span class="special">&gt;,</span> <span class="identifier">phone_number</span> <span class="special">&gt;,</span>
    <span class="identifier">set_of_relation</span><span class="special">&lt;&gt;</span>

<span class="special">&gt;</span> <span class="identifier">bimap_type</span><span class="special">;</span>
</pre>
<p>
          In this other case the bimap will relate names to phone numbers. Names
          can be repeated and phone numbers are unique. You can perform quick searches
          by name or phone number and the container can be viewed ordered using the
          relation view.</p><p>在第二个例子中，bimap 将姓名和电话号码关联起来。姓名可以重复而电话号码必须唯一。你可以通过姓名或电话进行快速的查找，且容器可以按关系视图的顺序来察看。
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2006 -2007 Matias Capeletto<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="controlling_collection_types.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../the_tutorial.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="differences_with_standard_maps.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
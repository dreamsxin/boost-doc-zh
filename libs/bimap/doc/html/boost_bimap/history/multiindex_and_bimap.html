<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>MultiIndex and Bimap</title><link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="Chapter&nbsp;1.&nbsp;Boost.Bimap">
<link rel="up" href="../history.html" title="History">
<link rel="prev" href="../history.html" title="History">
<link rel="next" href="../acknowledgements.html" title="Acknowledgements"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../history.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../history.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../acknowledgements.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_bimap.history.multiindex_and_bimap"></a><a class="link" href="multiindex_and_bimap.html" title="MultiIndex and Bimap">MultiIndex
      and Bimap &nbsp;MultiIndex 和 Bimap</a>
</h3></div></div></div>
<p>
        This is the conversation thread that began during Boost.PropertyTree formal
        review process. The review was very interesting and very deep topics were
        addressed. It is quite interesting and it is now part of this library history.
        Enjoy!</p><p>这是在 Boost.PropertyTree 的正式审查过程中开始的一系列对话。这个审查非常有趣，而且谈及了非常深刻的话题。它很有趣，而且现在已成为本库历史的一部分。希望你喜欢！
      </p>
<p>
        <span class="bold"><strong>Marcin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> The biggest virtue of property_tree is easy to use interface.
            If we try to make generic tree of it, it will be compromised. </em></span>
          </p>
<p>
        <span class="emphasis"><em>property_tree 最大的优点是它易于使用的接口。如果我们将它变为泛化的树，它将会受到损害。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Gennadiy</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> IMO the same result (as library presents) could be achieved
            just by using multi_index. </em></span>
          </p>
<p>
        <span class="emphasis"><em>在我看来，只使用 multi_index 也能得到同样的效果(正如现在的库)。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Marcin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Could you elaborate more on that? I considered use of multi_index
            to implement indexing for properties, but it only affected the implementation
            part of library, not interface, and because I already had a working,
            exception safe solution, I didn't see the reason to dump it and add another
            dependency on another library. </em></span>
          </p>
<p>
        <span class="emphasis"><em>你能否更详细地说明一下？我考虑过使用 multi_index
            来实现属性的索引，但它只对库的实现部分有影响，对接口是没有影响的，所以我已经开始着手了一个异常安全的方法，我看不到有什么理由放弃它并增加对另一个库的依赖。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Gennadiy</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I mean why do I need this half baked property_tree as another
            data structure? Property tree supports nothing in itself. It's just a
            data structure. You have parsers that produce property tree out of different
            sources. But you mat as well produce maps or something else. Here for
            example All that I need to do to "implement" similar functionality
            as your property tree: </em></span>
          </p>
<p>
        <span class="emphasis"><em>我的意思是，为什么我需要这个半成品的
property_tree
作为另一个数据结构？属性树本身并不支持什么。它只是一个数据结构。你有解析器从不同来源生成属性树。但你倒不如生成映射或其它别的东西。这有一个例子，
我所需要做的就是"实现"和你的属性树所类似的功能：</em></span></p>
</blockquote></div>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// Data structure itself 数据结构本身<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ValueType</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">KeyType</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">Node</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ValueType</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">KeyType</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ptree_gen</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">KeyType</span><span class="special">,</span><span class="identifier">Node</span><span class="special">&lt;</span><span class="identifier">ValueType</span><span class="special">,</span><span class="identifier">KeyType</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">mi_value</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span><span class="identifier">mi_value</span><span class="special">,</span> <span class="identifier">indexed_by</span><span class="special">&lt;...&gt;</span> <span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ValueType</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">KeyType</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">Node</span> <span class="special">{</span>
    <span class="identifier">ValueType</span> <span class="identifier">v</span><span class="special">;</span>
    <span class="identifier">ptree_gen</span><span class="special">&lt;</span><span class="identifier">ValueType</span><span class="special">,</span><span class="identifier">KeyType</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">children</span><span class="special">;</span>
<span class="special">};</span>
<span class="comment">// serialization support 序列化支持<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Archive</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">ValueType</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">KeyType</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">serialize</span><span class="special">(</span><span class="identifier">Archive</span> <span class="special">&amp;</span> <span class="identifier">ar</span><span class="special">,</span> <span class="identifier">Node</span><span class="special">&lt;</span><span class="identifier">ValueType</span><span class="special">,</span><span class="identifier">KeyType</span><span class="special">&gt;&amp;</span> <span class="identifier">n</span><span class="special">,</span>
               <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">version</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">ar</span> <span class="special">&amp;</span> <span class="identifier">n</span><span class="special">.</span><span class="identifier">v</span><span class="special">;</span>
    <span class="identifier">ar</span> <span class="special">&amp;</span> <span class="identifier">n</span><span class="special">.</span><span class="identifier">children</span><span class="special">;</span>
<span class="special">}</span>
<span class="comment">// some access methods 一些访问方法<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ValueType</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">KeyType</span><span class="special">&gt;</span>
<span class="identifier">ValueType</span> <span class="keyword">const</span><span class="special">&amp;</span>
<span class="identifier">get</span><span class="special">(</span> <span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">keys</span><span class="special">,</span> <span class="identifier">ptree_gen</span><span class="special">&lt;</span><span class="identifier">ValueType</span><span class="special">,</span><span class="identifier">KeyType</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">src</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">pait</span><span class="special">&lt;</span><span class="identifier">string</span><span class="special">,</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">sk</span> <span class="special">=</span> <span class="identifier">split</span><span class="special">(</span> <span class="identifier">keys</span><span class="special">,</span> <span class="string">"."</span> <span class="special">);</span>
    <span class="identifier">Node</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">N</span> <span class="special">=</span> <span class="identifier">src</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span> <span class="identifier">sk</span><span class="special">.</span><span class="identifier">first</span> <span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">sk</span><span class="special">.</span><span class="identifier">second</span><span class="special">.</span><span class="identifier">empty</span><span class="special">()</span> <span class="special">?</span> <span class="identifier">N</span><span class="special">.</span><span class="identifier">v</span> <span class="special">:</span> <span class="identifier">get</span><span class="special">(</span> <span class="identifier">sk</span><span class="special">.</span><span class="identifier">second</span><span class="special">,</span> <span class="identifier">N</span><span class="special">.</span><span class="identifier">children</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Use it like this: </em></span>
          </p>
<p>
        <span class="emphasis"><em>它的用法如下：</em></span></p>
</blockquote></div>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">ptree_gen</span><span class="special">&lt;</span><span class="identifier">string</span><span class="special">,</span><span class="identifier">string</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">PT</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">text_iarchive</span> <span class="identifier">ia</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ifstream</span> <span class="identifier">ifs</span><span class="special">(</span><span class="string">"filename"</span><span class="special">)</span> <span class="special">);</span>
<span class="identifier">ia</span> <span class="special">&gt;&gt;</span> <span class="identifier">PT</span><span class="special">;</span>
<span class="identifier">string</span> <span class="identifier">value</span> <span class="special">=</span> <span class="identifier">get</span><span class="special">(</span> <span class="string">"a.b.c.d"</span><span class="special">,</span> <span class="identifier">PT</span> <span class="special">);</span>
</pre>
<p>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Now tell me how property_tree interface is easier? And what
            is the value in 50k of Code you need to implement this data structure.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>现在请告诉我，property_tree 的接口如何更易用？你要用50k代码来实现这个数据结构有什么价值。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Thorsten</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Seriously Gennadiy, do you really see newbies writing the
            code you just did? </em></span>
          </p>
<p>
        <span class="emphasis"><em> 认真的 Gennadiy，你真的看不出你刚才所做的是新手写的代码？</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Marcin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> What you just implemented is stripped down, bare bones version
            of property_tree that, among other things, does not allow you to produce
            human editable XML files. Now add more interface (aka get functions),
            add more archives to serialization lib, add customization, add transparent
            translation from strings to arbitrary types and vice versa. Spend some
            weeks trying to get all the corner cases right, and then some more weeks
            trying to smooth rough edges in the interface. Then write tests. Write
            docs. At the end, I believe you will not get much less code than there
            is in the library already. Maybe you get some savings by using multi_index
            instead of manual indexing. </em></span>
          </p>
<p>
        <span class="emphasis"><em>你刚才所写是剪下来的 property_tree
的骨干版本，不允许你生成用户可编辑的 XML 文件。现在已增加了更多的接口(如 get
函数)，为序列化库增加了更多存档格式，增加客户化，增加了从字符串的透明转换及相反操作。你先花了几周来让所有极端的案例正确运行，还有几周用于试图把
接口边界变平滑。然后编写测试，编写文档。最后，我相信你不会得到比本库更少的代码。也许你会用 multi_index 替代手工索引来节省一些代码。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> The reason why ptree does not use multi index is because implementation
            existed long before I considered submitting to boost, probably before
            even I knew of multi index existence. It was working well. Later, when
            I was improving it during pre-review process, I seriously considered
            using multi-index. But I decided it is not worth throwing everything
            out. </em></span>
          </p>
<p>
        <span class="emphasis"><em>ptree 不使用 multi index
的原因是，因为在我考虑将它提交到 boost 之前很久该实现就已经存在了，甚至可能是在我知道有 multi index
之前。它工作得很好。以后当我在预审查过程中对它进行改进时，我会认真考虑使用 multi-index。但我认为不值得抛弃所有一切。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>

<p>
            <span class="emphasis"><em> Although ptree has large interface with many functions modifying
            state of the tree, it uses "single point of change" approach.
            Every insert eventually goes through one function, which takes care of
            exception safety and keeping index in sync with data. The same applies
            to erase. This function has 9 lines of code in case of insert, and (by
            coincidence) also 9 in case of erase. By using multi index these functions
            would obviously be simplified, maybe to 4 lines each. Net gain: 10 lines
            of code (out of several hundred in ptree_implementation.hpp).</em></span></p>
<p>
            <span class="emphasis"><em>虽然 ptree
带有很大的接口，它有很多函数来修改树的状态，它使用了 "单点修改"
方法。每个插入最终都通过一个函数完成，该函数考虑了异常安全性，并保持数据和索引的同步。对于删除也一样。这个函数有9行代码用于插入，同样也有9行用
于删除。通过使用 multi index，这些函数可以明显简化，也许每个只要4行。净收益：10行代码(相对于
ptree_implementation.hpp 的几百行代码)。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I'm aware that there are performance gains to be reaped as
            well, but at that time I was rather focusing on getting the interface
            right. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我知道还可以获得性能的提升，但是当时我只关注于接口的正确性。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Dave</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> That's perfectly reasonable, but (through no fault of yours)
            it misses the point I was trying to make. I guess I should have said,
            "...that demonstrates it to be the best implementation." </em></span>
          </p>
<p>
        <span class="emphasis"><em>这是完全合理的，但是(这不是你的错)它误会了我的观点。我想我应该说,
            "...这表示它是最好的实现。"</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> All I'm saying is that the extent to which a Boost library
            implementation should leverage other Boost libraries is not a question
            that can always be decided based on following simple guidelines, and
            that if this library is accepted, it's worth revisiting your decision.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>我要说的是，一个 Boost 库的实现的程度应该促进其它的 Boost 库，这不是一个问题，它应该基于以下的简单指引来决定，如果这个库是被接受的，就值得重新审视你的决定。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Thorsten</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I think it is important to focus on the interface in the review,
            but I also see several benefits of an implementation that builds on Boost.MultiIndex:'
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>我想在审查中，重要的是关注接口，但是我也看到了用 Boost.MultiIndex 来构建的几个优点：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- fewer bugs like the one Joaquin found</em></span>
          </p>
<p>
        <span class="emphasis"><em>- 更少的缺陷，象 Joaquin 发现的那个</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- better space efficiency</em></span>
          </p>
<p>
        <span class="emphasis"><em>- 更好的空间效率</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- exception-safety guarantees are immediately full-filled (I
            haven't looked, but I suspect that there are several bugs in this area)</em></span>
          </p>
<p>
        <span class="emphasis"><em>- 异常安全性保证可以立即满足(我还没有看过，但我怀疑在这方面存在一些缺陷)</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Daniel</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Multi_index supports everything a bimap would, but its interface
            is more cumbersome. I for one won't use a W3DOM-like library if we get
            one, but I would happily use property_tree. I've also only used multi_index
            once, and that was to use it as a bidirectional map. Property_tree covers
            other areas as well as being a potential subset of an XML library, but
            I still hold there is value in such a subset. </em></span>
          </p>
<p>
        <span class="emphasis"><em> Multi_index 支持 bimap 所要的任何东西，但它的接口太过笨重。我不会使用一个象 W3DOM 那样的库，但是我会很高兴使用 property_tree。我也只用过 multi_index
            一次，是把它用作一个双向映射。Property_tree 涵盖了其它方面，并作为一个 XML 库的潜在子集，但我仍然认为这样的子集是有价值的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Boris</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I haven't used program_options yet. But if I understand correctly
            both libraries seem to support storing and accessing data with strings
            that might describe some kind of hierarchy. This seems to be the core
            idea of both libraries - is this correct? </em></span>
          </p>
<p>
        <span class="emphasis"><em>我还没有用过 program_options。但如果我的理解是正确的，这两个库似乎都支持以可能描述了某种层次的字符串来保存和访问数据。这似乎是这两个库的核心理念 - 这是正确的吗？</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Then it wouldn't matter much what container is used. However
            a generic tree which can store data hierarchically probably makes most
            sense. If I understand correctly both libraries could make use of such
            a class? </em></span>
          </p>
<p>
        <span class="emphasis"><em>那么它并不比已经使用的容器多些什么？一般的树都可以按层次存储数据，可能更有意义。如果我理解得正确的话，是否两个库都可以利用这样的类？</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Marcin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>

<p>
            <span class="emphasis"><em> I think generic tree container is material for another library.
            Whether property_tree should be based on it or not is a matter of internal
            implementation, and generally of little interest to users. The biggest
            value of property_tree is in its easy to use interface, that should not
            be compromised, if at all possible. I have been already reassured in
            this view by quite many people who took their time to review the library.</em></span></p>
<p>
            <span class="emphasis"><em>我觉得通用的树容器是另一个库的原材料。property_tree 是否应该基于它，是一个内部实现的问题，通常用户不感兴趣。property_tree 的最大价值是它容易使用的接口，如果可能的话，这不应被损害。我已经从花时间来审查本库的多数人中得到保证。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Boris</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I was trying to see the big picture: I rather prefer a C++
            standard based on a few well-known concepts like containers, iterators,
            algorithms etc. instead of having a C++ standard with hundreds of components
            which are tailored for specific needs, collaborate with only a handful
            of other components and think they provide an easy-to-use interface while
            all the easy-to-use interfaces make the whole standard less easy-to-use.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>我尝试从大的方面来看：我宁愿要一个基于少量著名概念如容器、迭代器、算法等的C++标准，而不要一个有数百个特定需要的组件、只有少数组件可以合作的C++标准，每个组件应提供易用的接口而所有易用的接口可以使整个标准易于使用。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> That said I have used your property tree library myself to
            read and write a configuration file. It was indeed very easy to use.
            However it would have been even easier if it was something I had known
            before like eg. an iterator. For now I will definitely use your property
            tree library but would appreciate if existing concepts were reused many
            C++ developers are familiar with. My opinion is that your library should
            be a part of Boost but should be more generalized in the future. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我用过你的 property tree 库来读写一个配置文件。它确实很容易使用。但是，如果它具有我已知的某些东西，如迭代器，的话，会更易用。现在，我一定会使用你的 property
            tree 库，但是如果能够复用已有的、为广大C++开发者所熟悉的概念，就更好了。我的意见是，你的库应该成为 Boost 的一部分，但是在以后应该更为通用。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Thorsten</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Well, I think we need both. Boost.MultiIndex is a great library
            and can do all kinds of wonderful things. But I would still like to see
            a bidirectional map (boost::bimap) written as a wrapper around it to
            get an easy and specialized interface. </em></span>
          </p>
<p>
        <span class="emphasis"><em>好的，我想我们两个都需要。Boost.MultiIndex 是一个强大的库，可以做各种奇妙的事情。但是我也想看到一个双向映射(boost::bimap)，作为它的一个包装器，具有易用和特化的接口。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Pavel</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Bimap is available in libs/multi-index/examples/bimap.cpp.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em> Bimap 已在 libs/multi-index/examples/bimap.cpp 下。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Thorsten</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Right, but the real value comes when somebody designs a nice
            STL-like interface and write docs etc, at least that was my point. </em></span>
          </p>
<p>
        <span class="emphasis"><em>好的，但只有当有人设计了一个类似于STL的接口并且写出文档时，才有真正的价值，至少我是这么认为。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Dave</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> IMO Thorsten is exactly right. This is precisely the sort
            of thing that could be added to the library as part of its ongoing maintenance
            and development (without review, of course). </em></span>
          </p>
<p>
        <span class="emphasis"><em>在我看来，Thorsten 是对的。正是这些东西可以加入到库中，作为维护和开发的一部分(当然无需审查)。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Thorsten, we have talked about this privately in the past,
            but I feel like bringing it to the list in the hope of getting the attention
            of potential contributors: </em></span>
          </p>
<p>
        <span class="emphasis"><em> Thorsten, 过去我们已经私下讨论这一点，我想把它放到列表中，希望得到潜在的贡献者的关注：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> There are some data structures buildable with B.MI which are
            regarded as particularly useful or common, like for instance the bidirectional
            map or bimap. A lean and mean implementation is provided in the aforementioned
            example, but certainly a much carefully crafted interface can be provided
            keeping B.MI as the implementation core: operator[], selection of 1-1/1-N/N-1/N-N
            variants, hashing/ordering, etc. </em></span>
          </p>
<p>
        <span class="emphasis"><em>有些可以用 B.MI 构建的数据结构被认为是特别有用或通用的，例如双向映射或 bimap。在上述例子中提供了一个精简的实现，但是无疑，可以提供一个精心制作的接口并以 B.MI 作为实现核心：operator[], 1-1/1-N/N-1/N-N
            多种选择，散列/排序，等等。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I'm afraid I don't have the time to pursue this, as the current
            roadmap for core features of B.MI is taking all the spare time I can
            dedicate to the library. For this reason, I would love to see some volunteer
            jumping in who can develop this and other singular containers using B.MI
            (a cache container comes to mind) and then propose the results here either
            as a stand alone library of as part of B.MI --I'd prefer the former so
            as to keep the size of B.MI bounded. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我恐怕没有时间去追求这一点，因为当前的 B.MI&nbsp;核心特性的路线图已经占据了我可以奉献给本库的所有空闲时间。因此，我希望看到有一些志愿者可以参与开发本库和其它使用 B.MI
            的特定容器(</em></span><span class="emphasis"><em>正在考虑</em></span><span class="emphasis"><em>一个缓冲容器)，然后给出结果，无论是作为一个独立的库还是 B.MI 的一部分 -- 我宁愿选择前者，以保持 B.MI 的边界大小。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> If there's such a volunteer I can provide her with some help/mentoring.
            I also wonder whether this is a task suitable to be proposed for Google
            Summer of Code. </em></span>
          </p>
<p>
        <span class="emphasis"><em>如果有这样的志愿者，我可以提供一些帮助/指导。我想知道这个任务是否适合作为 Google
            Summer of Code 的提议。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Thorsten</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I think it would be good for SOC. All the really hard things
            are taken care of by B.MI, and so it seems reasonable for a student to
            be able to fill in the details. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我想它作为 SOC 不错。所有较困难的事情由 B.MI 负责，所以它看来比较适合让学生来填补细节。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Dave</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Great! </em></span>
          </p>
<p>
        <span class="emphasis"><em>不错！</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Jeff</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Please write a proposal! </em></span>
          </p>
<p>
        <span class="emphasis"><em>请写一个建议书！</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I've just done so: </em></span>
          </p>
<p>
        <span class="emphasis"><em>我已经写了一个：</em></span></p>
</blockquote></div>
<div class="sidebar">
<p class="title"><b></b></p>
<p>
        <span class="bold"><strong>Specialized containers with Boost.MultiIndex 由&nbsp;Boost.MultiIndex 构建的专用容器</strong></span>
      </p>
<p>
        <span class="bold"><strong>Introduction 简介</strong></span>
      </p>
<p>
        Boost.MultiIndex allows the construction of complex data structures involving
        two or more indexing mechanisms on the same set of elements. Out of the unlimited
        range of possible data structures specifiable within Boost.MultiIndex, some
        particular configurations arise recurrently:<br>Boost.MultiIndex 可以构造出复杂的数据结构，在同一组元素中包含两个或以上的索引机制。虽然在 Boost.MultiIndex 中可以指定不受限制的各种可能的数据结构，但是有些特定的配置经常反复出现：
      </p>
<p>
        <span class="bold"><strong>a.</strong></span> A bidirectional map or bimap is a container
        of elements of type pair&lt;T,Q&gt; where fast look up is provided both for
        the T and the Q field, in contrast with a regular STL map which only allows
        for fast look up on T.<br><span class="bold"><strong>a.</strong></span> 双向映射或 bimap 是一种元素类型为 pair&lt;T,Q&gt; 的容器，它提供了按 T 和 Q 字段的快速查找，而普通的 STL map 只允许按 T 进行快速查找。
      </p>

<p>
        <span class="bold"><strong>b.</strong></span> An MRU (most recently used) list keeps
        the n last referenced elements: when a new item is inserted and the list
        has reached its maximum length, the oldest element is erased, whereas if
        an insertion is tried of a preexistence element, this gets promoted to the
        first position. MRU lists can be used to implement dynamic caches and the
        kind of behavior exhibited by programs featuring a "Recent files"
        menu command, for instance.<br><span class="bold"><strong>b.</strong></span> MRU (最近最常使用)列表可以保持最后引用的 n 个元素：当插入一个新元素而列表已达到最大长度时，最旧的元素被删除，但是如果插入的是已存在的元素，则将它提升到第一个位置。MRU 列表可用于实现动态缓冲以及象程序中的"最近使用的文件"此类功能。
      </p>
<p>
        Although Boost.MultiIndex provides the mechanisms to build these common structures,
        the resulting interface can be cumbersome and too general in comparison with
        specialized containers focusing on such particular structures.&nbsp;<br>虽然 Boost.MultiIndex 提供了构建这些常用结构的机制，但是所得到的接口非常笨重，与这些特定容器所关注的这些特定结构相比也过于通用。
      </p>
<p>
        <span class="bold"><strong>Goal 目标</strong></span>
      </p>
<p>
        To write a library of specialized containers like the ones described above,
        using Boost.MultiIndex as the implementation core. Besides bimap and MRU
        list, the student can also propose other specialized containers of interest
        in the community. It is expected that the library meets the standards of
        quality required by Boost for an eventual inclusion in this project, which
        implies a strong emphasis on interface design, documentation and unit testing;
        the mentor will be guiding the student through the complete cycle from specification
        and requirements gathering to documentation and actual coding. The final
        result of the project must then contain:<br>编
写一个如上所述的专用容器库，用 Boost.MultiIndex 作为实现核心。除了 bimap 和 MRU
列表以外，学生还可以提议其它感兴趣的专用容器。我们希望这个库符合 Boost 所要求的质量标准，最后有可能将该库纳入
Boost，这意味着对接口设计、文档和单元测试的特别强调；导师将在整个开发周期中指导学生，从规格和需求收集到文档和具体编码。本项目的最终结果必须
包含： </p>
<p>
        <span class="bold"><strong>a.</strong></span> Source code following <a href="http://boost.org/more/lib_guide.htm#Guidelines" target="_top">Boost
        programming guidelines</a>.<br><span class="bold"><strong>a.</strong></span> 符合 <a href="http://boost.org/more/lib_guide.htm#Guidelines" target="_top">Boost
        编程指引</a> 的源代码。
      </p>
<p>
        <span class="bold"><strong>b.</strong></span> User documentation. Requirements on the
        format are loose, though the <a href="http://www.boost.org/tools/quickbook/doc/html/index.html" target="_top">QuickBook</a>
        format is gaining acceptance within Boost.<br><span class="bold"><strong>b.</strong></span> 用户文档。对格式的要求较松，不过 <a href="http://www.boost.org/tools/quickbook/doc/html/index.html" target="_top">QuickBook</a>
        格式在 Boost 内部是广为接受的。
      </p>
<p>
        <span class="bold"><strong>c.</strong></span> Complete set of unit tests powered by
        <a href="http://boost.sourceforge.net/boost-build2/" target="_top">Boost Build System
        V2</a>.<br><span class="bold"><strong>c.</strong></span> 可用于
        <a href="http://boost.sourceforge.net/boost-build2/" target="_top">Boost Build System
        V2</a> 的完整的单元测试集。
      </p>
<p>
        <span class="bold"><strong>Requirements 要求</strong></span>
      </p>
<p>
        <span class="bold"><strong>a.</strong></span> Intermediate-to-high level in C++, with
        emphasis in generic programming (templates).<br><span class="bold"><strong>a.</strong></span> C++水平为中至高级，在泛型编程(模板)方面较强。
      </p>
<p>
        <span class="bold"><strong>b.</strong></span> Knowledge of the STL framework and design
        principles. Of course, knowledge of Boost in general and Boost.MultiIndex
        in particular is a big plus.<br><span class="bold"><strong>b.</strong></span> 熟悉STL框架和设计原理。当然熟悉 Boost 尤其是 Boost.MultiIndex
        就更好了。
      </p>
<p>
        <span class="bold"><strong>c.</strong></span> Acquaintance with at least two different
        C++ programming environments.<br><span class="bold"><strong>c.</strong></span> 至少熟悉两个不同的C++编程环境。
      </p>
<p>
        <span class="bold"><strong>d.</strong></span> Some fluency in the English language;
        subsequent reviews of the documentation can help smooth rough edges here,
        though.<br><span class="bold"><strong>d.</strong></span> 流利的英语；不过后续的文档审查可以有所帮助。
      </p>
<p>
        <span class="bold"><strong>e.</strong></span> A mathematical inclination and previous
        exposure to a formal Algorithms course would help very much.<br><span class="bold"><strong>e.</strong></span> 爱好数学，以前接触过正式的算法课程会有很大帮助。
      </p>
<p>
        <span class="bold"><strong>f.</strong></span> A craving for extreme quality work.<br><span class="bold"><strong>f.</strong></span> 追求高质量的工作。
      </p>
<p>
        <span class="bold"><strong>Benefits for the student 对学生的好处</strong></span>
      </p>
<p>
        The student taking on this project will have the opportunity to learn the
        complete process of software production inside a highly regarded C++ open
        source institution, and even see her work included in Boost eventually. The
        completion of the project involves non-trivial problems in C++ interface
        design and so-called modern C++ programming, high quality user documentation
        and unit testing. The student will also learn, perhaps to her surprise, that
        most of the time will be spent gathering and trying ideas and, in general,
        thinking, rather than writing actual code.<br>参
与这一项目的学生，将有机会学习在一个高度重视C++开源的机构中进行软件生产的完整过程，甚至最终会在 Boost
中见到自己的作品。完成这个项目包括在C++接口设计中的一些不简单的问题，以及所谓的现代C++编程，还有高质量的用户文档和单元测试。学生可能会惊
讶，他还将学到大部分时间将用于收集和尝试各种思路，通常来说是思考而不是实际编写代码。 </p>
</div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I am planning to submit an application to SoC. I will love
            to make real the specialized containers you mention and try to include
            some useful others. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我正计划将它提交到 SoC. 我希望你所提到的专用容器成为真实，并尝试加入一些有用的其它东西。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <code class="literal"> And then... after long hours of coding (and fun) this library
            saw the light. </code>
          </p>
<p>
        <code class="literal">然后... 在长时间的编码(和乐趣)后，这个库看到了光明。</code></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="inlinemediaobject"><img src="../../images/bimap/boost.bimap.logo.png" alt="boost.bimap.logo"></span>
          </p>
<p>
        </p>
</blockquote></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2006 -2007 Matias Capeletto<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../history.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../history.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../acknowledgements.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>The student and the mentor</title><link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="Chapter&nbsp;1.&nbsp;Boost.Bimap">
<link rel="up" href="../rationale.html" title="Rationale">
<link rel="prev" href="code.html" title="Code">
<link rel="next" href="../history.html" title="History"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="code.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../rationale.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../history.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_bimap.rationale.the_student_and_the_mentor"></a><a class="link" href="the_student_and_the_mentor.html" title="The student and the mentor">The
      student and the mentor 学生与导师</a>
</h3></div></div></div>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top"><p>
          It is a good idea to read the original <a href="http://h1.ripway.com/mcape/boost/libs/misc/" target="_top">Boost.Misc
          SoC proposal</a> first.</p><p>请先阅读原有的 <a href="http://h1.ripway.com/mcape/boost/libs/misc/" target="_top">Boost.Misc
          SoC 建议书</a>。
        </p></td></tr>
</tbody></table></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <code class="literal">- The discussion starts with Joaquin trying to strip out the
            "misc" name out of the library -</code>
          </p>
<p>
        <code class="literal">- 这一讨论从 Joaquin 试图剥去本库的 "misc" 名字开始 -</code></p>
</blockquote></div>
<p>
        <span class="inlinemediaobject"><img src="../../images/people/joaquin.png" alt="joaquin"></span>
      </p>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Thinking about it, the unifying principle of MISC containers
            is perhaps misleading: certainly all miscs use multi-indexing internally,
            but this does not reflect much in the external interface (as it should
            be, OTOH). So, from the user's point of view, miscs are entirely heterogeneous
            beasts. Moreover, there isn't in your proposal any kind of global facility
            common to all miscs. What about dropping the misc principle and working
            on each container as a separate library, then? You'd have boost::bimap,
            boost::mru, etc, and no common intro to them. This also opens up the
            possibility to add other containers to the suite which aren't based on
            B.MI. What's your stance on this? Do you see a value in keeping miscs
            conceptually together?</em></span></p><p><span class="emphasis"><em></em></span><span class="emphasis"><em>思
考一下这个问题，MISC容器的统一原则也许是具有误导性的：当然所有 miscs
在其内部使用了多索引，但是这在外部接口中并不会反映出来(因为它应该如此，OTOH)。所以，从用户的角度来看，miscs
是完全异构的东西。此外，在你的建议中没有任何全局的机制为所有 miscs 共用。如果放开这个 misc
原则，将每个容器作为一个单独的库，又如何？你就有了 boost::bimap, boost::mru,
等等，它们没有共同的说明。这也开放了一个可能性，添加其它容器到这个不是基于 B.MI 的套件中。你对此有何立场？你认为值得一起保持 miscs
概念吗？ </em></span>
          </p>
<p>
        </p>
</blockquote></div>
<p>
        <span class="inlinemediaobject"><img src="../../images/people/matias.png" alt="matias"></span>
      </p>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">


<p>
            <span class="emphasis"><em> As the original proposal states only two containers (bimap
            and mru set) both based in B.MI, it was straight forward to group them
            together. When I was writing the SoC proposal I experienced a similar
            feeling when the two families begin to grow. As you say, the only common
            denominator is their internal implementation. I thought a bit about a
            more general framework to join this two families (and other internally
            related ones) and finally came up with an idea: Boost.MultiIndex! So
            I think that it is not a good idea to try to unify the two families and
            I voted in favor of get rid of the misc part of boost::misc::bimap and
            boost::misc::mru. Anyway, for my SoC application it seems OK to put the
            two families in the same project because although from the outside they
            are completely unrelated, the work I will have to do in order to build
            the libraries will be consistent and what I will learn coding the bimap
            family will be used when I start to code the mru family. When the mru
            family is in place, I will surely have learnt other things to improve
            the bimap group. </em></span>
          </p>
<p><span class="emphasis"><em>作为原来的提案，只有两个容器 (bimap 和 mru set)，它们均基于
B.MI, 将它们组合在一起是很显然的。当我编写 SoC
建议时，我经历了类似的感觉，两个类族开始增长。正如你所说，唯一的共同点是它们的内部实现。我想了一个更为通用的框架，以合并这两个类族(以及其它内部
相关的类)，最终想出一个主意：Boost.MultiIndex! 因此，我认为试图统一这两个类族并不是一个好主意，我投票赞同去除
boost::misc::bimap 和 boost::misc::mru 的 misc 部分。无论如何，对于我们 SoC
应用来说，将这两个类族放在同一个项目中是OK的，因为毕竟从外面看它们是完全无关的，为了构建这些库，我必须要做的工作就是一致性，我从 bimap
类族的编码中学到的，在我编写 mru 类族时也会有用。当 mru 类族写好后，我也确定会学到其它东西以改进 bimap 类族。</em></span><br></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> On the other hand, I think it will be useful for the general
            user to have at least some document linked in the B.MI documentation
            that enumerates the most common cases of uses (a bimap and an mru set
            for example) and points where to find clean implementation for this useful
            containers. For now, a link to boost::bimap and other one to boost::mru
            will suffice. If you think about the title of such a document, you will
            probably come up with something like: Common Multi Index Specialized
            Containers, and we are back to our misc proposal. So, to order some ideas:</em></span></p><p><span class="emphasis"><em></em></span><span class="emphasis"><em>
另一方面，我认为普通用户至少有一些文档链接到 B.MI 文档是有帮助的，这些文档列举了最常见的用例(例如一个 bimap 和一个 mru
set&nbsp;)，并指出在哪里可以找到这些容器的干净实现。现在，有一个到 boost::bimap 的链接和另一个到 boost::mru
的链接就足够了。如果你要为这个文档想一个标题，你可以用这样的名字：通用多索引专用容器，我们又回到了我们的 misc 建议。所以，有以下想法： </em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- A new family of containers that can be accessed by both key
            will be created. (boost::bimap)</em></span>
          </p>
<p>
        <span class="emphasis"><em>-&nbsp;一个新的，可以通过两个键来访问的容器族被创建。(boost::bimap)</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- A new family of time aware containers will see the light.
            (boost::mru)</em></span>
          </p>
<p>
        <span class="emphasis"><em>- 一个新的时间感知的容器族将问世。(boost::mru)</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- A page can be added to B.MI documentation, titled misc that
            links this new libraries.</em></span>
          </p>
<p>
        <span class="emphasis"><em>- 向 B.MI 文档中增加一页，标题为 misc，链接到新的库。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> This is a clearer framework for the user. They can use a mru
            container without hearing about Boost.MultiIndex at all. And B.MI users
            will get some of their common containers already implemented with an
            STL friendly interface in other libraries. And as you stated this is
            more extensible because opens the door to use other libraries in bimap
            and mru families than just Boost.MultiIndex without compromising the
            more general boost framework. The word "misc" it is going to
            disappear from the code and the documentation of bimap and mru. From
            now on the only use for it will be to identify our SoC project. I am
            thinking in a name for the bimap library. What about Boost.BidirectionalMap?
            Ideas? </em></span>
          </p>
<p>
        <span class="emphasis"><em>对于用户来说，这是一个更为清晰的框架。他们可以使用 mru
容器而无须知道 Boost.MultiIndex。而且 B.MI
的用户则得到一些他们常用的容器，这些容器已经在其它库中实现了STL友好的接口。正如你所指出的，这样更可扩展，因为它向 bimap 和 mru
类族的其它库打开了大门，而不仅是 Boost.MultiIndex，同时也没有损害更为通用的 boost 框架。单词 "misc" 正从代码和
bimap 及 mru 的文档中消失。从现在起，它的唯一用处就是确定我们的 SoC 项目。我正在考虑为 bimap 库起一个名字。叫
Boost.BidirectionalMap 如何？有没有其它想法？</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Yes, Boost.Bimap. In my opinion, bimap is a well known name
            in the Boost and even in the C++ community. It sounds and is short. Why
            not to vindicate yourself as the owner of this name? </em></span>
          </p>
<p>
        <span class="emphasis"><em>是的，叫 Boost.Bimap 吧。我认为，bimap 是一个在 Boost 甚至在 C++ 社区中人所共知的名字。它很响亮，也较短。作为这个名字的所有者，你为什么维护自身呢？</em></span></p>
</blockquote></div>
<p>
        <code class="literal">- Then after a week of work -</code></p><p><code class="literal">- 在一周的工作后 -</code>
      </p>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Now that Boost.Bimap is getting some shape, I see that as
            you have told me, we must offer a "one_to_many_map" and a "multi_bimap"
            as part of the library. The framework I am actually working allowed to
            construct this kind of bidirectional maps and it is easy to understand
            from the user side. </em></span>
          </p>
<p>
        <span class="emphasis"><em>现在 Boost.Bimap 已经有点成形了，我看到了你所说的，我们必须提供一个 "一对多映射" 和一个 "multi_bimap"
            作为本库的一部分。我所使用的框架其实是允许构建这种双向映射的，而且从用户侧来说也很容易理解。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> OK, I am glad we agree on this point. </em></span>
          </p>
<p>
        <span class="emphasis"><em>好的，我很高兴我们都同意这一点。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> With respect to the symmetry of the key access names, I have
            to agree that there is not much a difference between the following ones:
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>关于键访问名的对称性，我必须同意以下几个并没有太大的区别：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- to - from</em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- to - b</em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- 0 - 1</em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- left - right</em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> In my opinion it is a matter of taste, but left/right sounds
            more symmetrical than the others. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我认为这只是一个品味的问题，但好象 left/right 比其它几个更为对称。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I like very much the left/right notation, it is very simple
            to remember and it is a lot more symmetrical than to/from. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我喜欢 left/right 的记法，它很容易被记住，而且比 to/from 更为对称。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> At first my idea was to obtain ease of use hiding the B.MI
            core, making it more STL-intuitive. Nevertheless I have realized that
            B.MI is a lot more coherent and easy to use that I had imagined. This
            makes me think again in the problem. In the design that I am coding now,
            bimap <span class="bold"><strong>is-a</strong></span> multi_index_container specializes
            with a data type very comfortable called bipair, that can be seen like
            any of the two maps that integrates it using map views. This scheme has
            great benefits for users: </em></span>
          </p>
<p>
        <span class="emphasis"><em>首先，我的想法是为了易用性隐藏 B.MI
            的核心，让它直观上更象 STL。不过，我也意识到
            B.MI 比我想象的更为一致和易用。这使得我再次考虑了这个问题。在我现在所编码的设计中，bimap <span class="bold"><strong>是一个</strong></span> 以某个数据类型特化的 multi_index_container，该数据类型适合叫作 bipair，可以看出，它由任意两个映射使用映射视图集成而得。这种机制对于用户有很大好处：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - If the user already knows B.MI, he can take advantage of
            the tools that it provides and that are not present in the STL containers.
            In addition, in some cases the use to indices to see the data can be
            very useful. </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 如果用户已经知道 B.MI，他可以利用所提供的在 STL 容器中所没有的工具。另外，在某些情形下使用索引察看数据是很有用的。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - If the user does not know anything about B.MI but have an
            STL framework, the learning curve is reduced to understand the bimap
            instantiation and how a is obtained the desired map view. </em></span>
          </p>

<p>
            <span class="emphasis"><em> - 如果用户不了解 B.MI 但是有一个
            STL 框架，那么学习曲线可以降低为了解 bimap
            实例以及如何得到想要的映射视图。 </em></span>
          </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Another very important benefit holds: All the algorithms done
            for B.MI continues to work with Boost.Bimap and if B.MI continues growing,
            bimap grow automatically. </em></span>
          </p>
<p>
        <span class="emphasis"><em>另一个非常重要的好处是：所有对于 B.MI 可用的算法同样可用于 Boost.Bimap，如果 B.MI 继续发展，bimap 可以自动跟随。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Umm... This is an interesting design decision, but controversial
            in my opinion. Basically you decide to expose the implementation of bimap;
            that has advantages, as you stated, but also a nonsmall disadvantage:
            once <span class="bold"><strong>you have documented</strong></span> the implementation,
            it is not possible to change it anymore. It is a marriage with B.MI without
            the chance of divorce. The other possibility, to hide the implementation
            and to duplicate and document the provided functionality, explicitly
            or implicitly due to the same characteristics of the implementation,
            is of course heavier to maintain, but it gives a degree of freedom to
            change the guts of your software if you need to. Do not take this like
            a frontal objection, but I think that it is quite important design decision,
            not only in the context of bimap but in general. </em></span>
          </p>
<p>
        <span class="emphasis"><em>嗯... 这是一个有趣的设计决策，但是我有保留意见。基本上你是决定暴露 bimap 的实现；如你所说，它有好处，不过也有不小的坏处：一旦<span class="bold"><strong>你将这个实现记录到文档中</strong></span>，
就不能再修改它了。这相当于与 B.MI
结合而没有机会再分开了。另一种可能性是隐藏具体的实现，复制并记录所提供的功能，相同的实现特性当然是增加了维护量，但是在你需要时它可以给你一个修改
软件的自由度。不要将这个意见视为正面的反对，但我认为它是一个很重要的设计决策，不仅是在 bimap 中，而且是通用的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>

<p>
            <span class="emphasis"><em> You are quite right here. I think we have to choose the hardest
            path and hide the B.MI core from the user. I am sending you the first
            draft of bimap along with some documentation.</em></span></p>
<p>
            <span class="emphasis"><em>这里你是对的。我想我们必须选择最艰难的道路，向用户隐藏 B.MI 核心。我正将 bimap 的第一稿以及一些文档发给你。 </em></span>
          </p>
</blockquote></div>
<p>
        <code class="literal">- This completes the second week, the documentation was basically
        the first section of this rationale -</code></p><p><code class="literal">- 第二周结束后，文档基本上就是本原理的第一节 -</code>
      </p>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I must confess that I am beginning to like what I see. I am
            mathematical by vocation, and when I see symmetry in a formulation I
            believe that it is in the right track. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我必须承认，我开始喜欢所看到的东西了。我天生就是数学的，当我看到公式中的对称性时，我相信这就是正确的道路。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> We are two mathematicians by vocation then. </em></span>
          </p>
<p>
        <span class="emphasis"><em>那么我们俩天生都是数学的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I think that the part of std::set theory is very clear. To
            me, it turns out to me somewhat strange to consider the rank of a map
            (values X) like a std::set, but of course the formulation is consistent.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>我认为 std::set 理论的部分很清楚了。对我来说，将一个映射(值 X)的评级当成</em></span><span class="emphasis"><em> std::set 来考虑</em></span><span class="emphasis"><em>，有点奇怪，但是当然公式是一致的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I like it very much, it can be a little odd at first, but
            now that I have get used to it, it is very easy to express in the code
            my contrains on the data, and I believe that if somebody reads the code
            and sees the bimap instantiation he is not going to have problems understanding
            it. Perhaps it is easier to understand it if we use your notation: ordered_nonunique,
            unordered_unique, but this goes against our STL facade. In my opinion
            the user that comes from STL must have to learn as less as possible.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>我非常喜欢它，开始它可能有点古怪，但现在我已经习惯了，它很容易在代码上表达我对于数据的约束，而且我相信，如果别人来读这些代码和看到 bimap 的实例，他的理解应该不会有问题。如果我们使用你的记号：ordered_nonunique,
            unordered_unique, 也许更易于理解，但是它违背了我们的 STL 外观。在我认为，来自于 STL 的用户必须尽可能少地需要学习。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Considering a relation like a <code class="computeroutput"><span class="keyword">struct</span>
            <span class="special">{</span><span class="identifier">left</span><span class="special">,</span> <span class="identifier">right</span><span class="special">}</span></code> is clean and clear. If I understand
            it well, one relation has views of type <code class="computeroutput"><span class="identifier">pair</span><span class="special">{</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">second</span><span class="special">}</span></code>, is this correct? </em></span>
          </p>
<p>
        <span class="emphasis"><em>想象一下，一个象 <code class="computeroutput"><span class="keyword">struct</span>
            <span class="special">{</span><span class="identifier">left</span><span class="special">,</span> <span class="identifier">right</span><span class="special">}</span></code> 这样的关系是干净和清晰的。如果我的理解是它不错，那么一个关系具有类型 <code class="computeroutput"><span class="identifier">pair</span><span class="special">{</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">second</span><span class="special">}</span></code> 的视图，是否正确？</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Yes, I believe that the left/right notation to express symmetry
            is great. I believe that to people is going to love it. </em></span>
          </p>
<p>
        <span class="emphasis"><em>是的，我相信 left/right 记号所表达的对称性是伟大的。我相信人们会爱上它的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> OK, perfect. I likes this very much: </em></span>
          </p>
<p>
        <span class="emphasis"><em> 好的，漂亮。我很喜欢它们：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- bm.left is compatible with std::map&lt;A,B&gt;</em></span>
          </p>
<p>
        <span class="emphasis"><em>- bm.left 兼容于 std::map&lt;A,B&gt;</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- bm.right is compatible with std::map&lt;B,A&gt;</em></span>
          </p>
<p>
        <span class="emphasis"><em>- bm.right 兼容于 std::map&lt;B,A&gt;</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- bm is compatible with std::set&lt;relation&lt;A,B&gt;&gt;</em></span>
          </p>
<p>
        <span class="emphasis"><em>- bm 兼容于 std::set&lt;relation&lt;A,B&gt;&gt;</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> It is elegant and symmetric. I feel good vibrations here.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>这既优雅又对称。这里我感到了振动。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Great! </em></span>
          </p>
<p>
        <span class="emphasis"><em> 强!</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Moving on, the support for N-1, N-N, and hashed index is very
            easy to grasp, and it fits well in framework. However I do not finish
            to understand very well the "set&lt;relation&gt; constraints"
            section. Will you came up with some examples of which is the meaning
            of the different cases that you enumerate? </em></span>
          </p>
<p>
        <span class="emphasis"><em>继续前进，对 N-1, N-N, 和散列索引的支持很容易理解，它们也适合于这个框架。不过我还不是很理解 "set&lt;relation&gt; 的约束"
            一节。你可以给出一些例子来说明你所列举的不同情形的意义吗？</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias - </strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Yes, I mean: </em></span>
          </p>
<p>
        <span class="emphasis"><em>好的，我的意思是：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- based on the left</em></span>
          </p>
<p>
        <span class="emphasis"><em>- 基于左侧</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- based on the right</em></span>
          </p>
<p>
        <span class="emphasis"><em>- 基于右侧</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> The bimap core must be based on some index of multi index.
            If the index of the left is of the type hash, then in fact the main view
            is going to be an unordered_set&lt; relation&lt;A,B&gt; &gt;. Perhaps
            this is not what the user prefers and he wants to base its main view
            on the right index. </em></span>
          </p>
<p>
        <span class="emphasis"><em>bimap 核心必须基于多个索引中的某些索引。如果左侧的索引类型是散列的，那么事实上主视图就应该是一个 unordered_set&lt; relation&lt;A,B&gt; &gt;。可能这不是用户想要的，他可能想将主视图基于右侧索引。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- set_of_relation </em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- multiset_of_relation </em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- unordered_set_of_relation </em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em>- unordered_multiset_of_relation </em></span>
          </p>
<p>
        </p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> However, if both of them are hash indexes, the user may want
            the main view to be ordered. As we have a B.MI core this is very easy
            to support, we just have to add another index to it. </em></span>
          </p>
<p>
        <span class="emphasis"><em>不过，如果左右两侧都是散列索引，而用户可能希望主视图是有序的。因为我们有一个 B.MI 核心，所以这很容易支持，我们要做的只是增加一个索引。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I understand it now. OK, I do not know if we have to include
            this in the first version, is going to be a functionality avalanche!
            </em></span>
          </p>
<p>
        <span class="emphasis"><em>现在我明白了。好的，我不清楚如果我们必须将它包含在第一个版本中，是否功能太多。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> The user is not affected by the addition of this functionality,
            because by default it will be based on the left index that is a very
            natural behaviour. I do not think that this is functionality bloat, but
            I agree with you that it is a functionality avalanche. </em></span>
          </p>
<p>
        <span class="emphasis"><em>用户不会感觉到增加的功能，因为缺省情况是基于左索引的，这是非常自然的行为。我不认为这是功能膨胀，但是我同意它是一个功能雪崩。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> There are restrictions between the left and right set types
            and the possible main view set types. For example if some of the index
            is of unique type, then the main view cannot be of type multiset_of_relation.
            To the inverse one, if the main view is of type set_of_relation the left
            and the right index cannot be of type multi_set. All this subject of
            the unicity constrictions and the resulting interactions between indexes
            is one of the subtle subjects of B.MI. </em></span>
          </p>
<p>
        <span class="emphasis"><em>在左、右集合类型和可能的主视图集合类型之间是有约束的。例如，如果
某个索引类型是唯一的，那么主视图的类型就不能是 multiset_of_relation。相反，如果主视图的类型是
set_of_relation，那么左索引和右索引的类型就不能是 multi_set。所有这些单一性约束和由此产生的索引间的相互作用，正是
B.MI 的微妙之处。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> This can be checked at compile time and informed as an error
            in compile time. </em></span>
          </p>
<p>
        <span class="emphasis"><em>这可以在编译期被检验出来，并产生一个编译期错误。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> It can be interesting. </em></span>
          </p>
<p>
        <span class="emphasis"><em>这很有趣。</em></span></p>
</blockquote></div>
<p>
        <code class="literal">- And right when everything seems to be perfect... -</code></p><p><code class="literal"></code><code class="literal">- 接着一切似乎都是完善的... - </code>
      </p>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I have some worse news with respect to mutant, it is very
            a well designed and manageable class, unfortunately, C++ does not guarantee
            layout-compatibility almost in any case. For example, the C++ standard
            does not guarantee that the classes <code class="computeroutput"><span class="keyword">struct</span><span class="special">{</span><span class="identifier">T1</span> <span class="identifier">a</span><span class="special">;</span> <span class="identifier">T2</span> <span class="identifier">b</span><span class="special">;}</span></code> and <code class="computeroutput"><span class="keyword">struct</span><span class="special">{</span><span class="identifier">T1</span> <span class="identifier">b</span><span class="special">;</span> <span class="identifier">T2</span> <span class="identifier">a</span><span class="special">;}</span></code> are layout-compatible, and therefore
            the trick of reinterpret_cast is an undefined behavior. I am with you
            in which that in the 100% of the cases this scheme will really work,
            but the standard is the standard. If you can look the layout-compatibility
            subject in it (http://www.kuzbass.ru/docs<span class="emphasis"><em>isocpp</em></span>).
            As you see, sometimes the standard is cruel. Although mutant seems a
            lost case, please do not hurry to eliminate it. We will see what can
            be done for it. </em></span>
          </p>
<p>
        <span class="emphasis"><em>关于 mutant 我有一些坏消息，它是一个很好的设计和可管理的类，不幸的是，C++ 并不保证任何情形下的布局兼容。例如，C++ 标准不保证 <code class="computeroutput"><span class="keyword">struct</span><span class="special">{</span><span class="identifier">T1</span> <span class="identifier">a</span><span class="special">;</span> <span class="identifier">T2</span> <span class="identifier">b</span><span class="special">;}</span></code> 和 <code class="computeroutput"><span class="keyword">struct</span><span class="special">{</span><span class="identifier">T1</span> <span class="identifier">b</span><span class="special">;</span> <span class="identifier">T2</span> <span class="identifier">a</span><span class="special">;}</span></code> 是布局兼容的，因此 reinterpret_cast 技巧是未定义的行为。虽然我同意你所说的在100%的情况下这一方式都是正确的，但是标准就是标准。如果你可以看一下这里(http://www.kuzbass.ru/docs<span class="emphasis"><em>isocpp</em></span>)关于布局兼容的文章。你会看到，有时候标准是残酷的。虽然 mutant 看起来没有机会，但请不要急于消除它。让我们看看有什么可以为它做的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I read the standard, and you were right about it. Mutant was
            an implementation detail. It is a pity because I am sure that it will
            work perfect in any compiler. Perhaps the standard becomes more strict
            some day and mutant returns to life... We can then try a wrapper around
            a relation&lt;A,B&gt; that have two references named first and second
            that bind to A and B, or B and A. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我阅读了标准，你是对的。Mutant
是一个实现细节。太可惜了，我确认在任何编译器上它都是可以使用的。也许某天标准会变得更严格，mutant 会重返我们的生活... 我们可以尝试在
relation&lt;A,B&gt; 的外围加一层包装，有两个名为 first 和 second 的引用，分别绑定到 A 和 B，或 B 和
A。</em></span></p>
</blockquote></div>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">relation</span><span class="special">&lt;</span><span class="identifier">TA</span><span class="special">,</span><span class="identifier">TB</span><span class="special">&gt;</span> <span class="identifier">r</span><span class="special">;</span>
<span class="identifier">const_reference_pair</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">&gt;</span> <span class="identifier">pba</span><span class="special">(</span><span class="identifier">r</span><span class="special">);</span>
<span class="identifier">const_reference_pair</span><span class="special">&lt;</span><span class="identifier">B</span><span class="special">,</span><span class="identifier">A</span><span class="special">&gt;</span> <span class="identifier">pbb</span><span class="special">(</span><span class="identifier">r</span><span class="special">);</span>
</pre>
<p>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> It is not difficult to code the relation class in this way
            but two references are initialized with every access and the use of
            <code class="computeroutput"><span class="identifier">pba</span><span class="special">.</span><span class="identifier">first</span></code> will be slower than <code class="computeroutput"><span class="identifier">r</span><span class="special">.</span><span class="identifier">left</span></code> in most compilers. It is very
            difficult to optimize this kind of references. </em></span>
          </p>
<p>
        <span class="emphasis"><em>用这种方法不难写出 relation 类的代码，但是每次访问都要初始化这两个引用，而且在多数编译器中，使用
            <code class="computeroutput"><span class="identifier">pba</span><span class="special">.</span><span class="identifier">first</span></code> 会比 <code class="computeroutput"><span class="identifier">r</span><span class="special">.</span><span class="identifier">left</span></code> 慢。这种引用很难优化。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> This workaround is not possible, due to technical problems
            with the expected behavior of the iterators. If the iterators of bm.left
            are of bidirectional type, then standard stated that it have to return
            an object of type const value_type&amp; when dereferenced. You will have
            to return a const_reference_pair created in the flight, making it impossible
            to return a reference. </em></span>
          </p>
<p>
        <span class="emphasis"><em>这种变通方法不可行，因为迭代器的期望行为会有技术问题。如果 bm.left
            的迭代器是双向的，那么标准声明它在提领时必须返回一个类型为 const value_type&amp; 的对象。你将不得不返回一个就地创建的 const_reference_pair，返回引用是不可能的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I understand... I have workaround for that also but surely
            the standard will attack me again! We must manage to create the class
            relation that responds as we want, the rest of the code will flow from
            this point. This clear separation between the relation class and the
            rest of the library, is going to help to us to separate the problems
            and to attack them better. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我明白... 我已经想过其它变通方法，但是标准再次与我为难！我们必须设法创建我们想要的
            relation 类，剩余的代码将由此产生。relation 类与库的其余部分间的明确划分，有助于我们将问题区分开来，更好地解决。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> What workaround? It already pricks my curiosity,I have dedicated
            a long time to the subject and I do not find any solution except that
            we allow the relation class to occupy more memory. </em></span>
          </p>
<p>
        <span class="emphasis"><em>有什么替代方法？它已经引起我的好奇心了，我为此已经专门花了很长时间，还没找到任何解决方法，除非我们允许 relation 类占用更多内存。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> We must achieve that the relation&lt;A,B&gt; size equals the
            pair&lt;A,B&gt; size if we want this library to be really useful. I was
            going to write my workaround and I realized that It does not work. Look
            at this: http://www.boost.org/libs/iterator/doc/new-iter-concepts.html
            Basically the problem that we are dealing is solved if we based our iterators
            on this proposal. The present standard forces that the bidirectional
            iterators also are of the type input and output. Using the new concepts
            there is no inconvenient in making our iterators "Readable Writable
            Swappable Bidirectional Traversal". Therefore the const_reference_pair
            returns to be valid. </em></span>
          </p>
<p>
        <span class="emphasis"><em>如果我们想这个库真的可用，就必须实现
relation&lt;A,B&gt; 的大小和 pair&lt;A,B&gt; 一样。我在准备写一个变通方法时意识到它也无法工作。请看这里：
http://www.boost.org/libs/iterator/doc/new-iter-concepts.html
基本上我们要处理的这个问题已经解决了，如果我们按这个建议来设计迭代器。当前的标准强制要求双向迭代器也是输入和输出的。使用这个新的概念就可以将我们
的迭代器构建为"可读可写可交换可双向遍历的"。因此 const_reference_pair 的返回是有效的。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> It is correct in the sense that you simply say that your iterators
            are less powerful than those of the std::map. It is not that it is wrong,
            simply that instead of fixing the problem, you confess it. </em></span>
          </p>
<p>
        <span class="emphasis"><em>感觉上是正确的，你只是说你的迭代器比 std::map 的稍弱一点。这并不等于是错的，只是解决问题的替代方法，你承认。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> OK, but in our particular case; What are the benefits of offering
            a LValue iterator against a Read Write iterator? It does not seem to
            me that it is less powerful in this case. </em></span>
          </p>
<p>
        <span class="emphasis"><em> OK, 但只是在我们的特定情况下；提供一个左值迭代器而不是读写迭代器有什么好处？在我看来，这种情形下并没什么用。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> The main problem with a ReadWrite is that the following thing:
            <code class="computeroutput"><span class="identifier">value_type</span> <span class="special">*</span>
            <span class="identifier">p</span><span class="special">=&amp;(*</span><span class="identifier">it</span><span class="special">);</span></code>
            fails or stores a transitory direction in p. Is this important in the
            real life? I do not know. How frequently you store the direction of the
            elements of a map? Perhaps it is not very frequent, since the logical
            thing is to store the iterators instead of the directions of the elements.
            Let us review our options: </em></span>
          </p>
<p>
        <span class="emphasis"><em>读写迭代器的主要问题是这样的：<code class="computeroutput"><span class="identifier">value_type</span> <span class="special">*</span>
            <span class="identifier">p</span><span class="special">=&amp;(*</span><span class="identifier">it</span><span class="special">);</span></code>
            失败或在 p 中保存一个短暂的方向。在现实生活中这是否重要？我不知道。你会经常保存一个映射的元素方向吗？也许不会，因为合乎逻辑的是保存迭代器而不是元素的方向。我们来审查一下我们的选择：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">


<p>
            <span class="emphasis"><em> 1. We used mutant knowing that is not standard, but of course
            it is supported in the 100% of the cases.</em></span></p>
<p>
            <span class="emphasis"><em> 1. 我们使用了 mutant 但知道它不标准，当然在100%情况下它是被支持的。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">

<p>
            <span class="emphasis"><em> 2. We used const_reference_pair and we declared the iterators
            not LValue. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 2. 我们使用 const_reference_pair 且将迭代器声明为非左值。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 3. We found some trick that still we do not know. I have thus
            been playing with unions and things, without much luck. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 3. 我们寻找一些还不知道的技巧。我已经试过 union 什么的，但不够运气。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 4. We leverage the restriction that views have to support
            the first, second notation. If we made this decision, there are several
            possibilities: </em></span>
          </p>
<p>
        <span class="emphasis"><em> 4. 我们放大这一约束，要求视图必须支持 first, second 记号。如果我们作出这一决定，就有以下几个可能性：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> a. The left map has standard semantics first/second while
            the right map has the inverse semantics. </em></span>
          </p>
<p>
        <span class="emphasis"><em> a. 左映射具有标准语义的 first/second 而右映射则具有相反的语义。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> b. Instead of first and second we provide first() and second(),
            with which the problem is trivial. </em></span>
          </p>
<p>
        <span class="emphasis"><em> b. 我们提供</em></span><span class="emphasis"><em> first() 和 second()</em></span><span class="emphasis"><em> 来代替 first 和 second，这没什么问题。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> c. The map view do not support first/second but left/right
            as the father relation </em></span>
          </p>
<p>
        <span class="emphasis"><em> c. 映射视图不支持 first/second 但以 left/right 作为父关系。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 5. We solve the problem using more memory than sizeof(pair&lt;A,B&gt;).
            </em></span>
          </p>
<p>
        <span class="emphasis"><em> 5. 我们使用多于 sizeof(pair&lt;A,B&gt;) 的内存来解决这一问题。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> In any case, I would say that the only really unacceptable
            option is the last one. </em></span>
          </p>
<p>
        <span class="emphasis"><em>在任何情况下，我要说唯一不可接受的选择是最后一个。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Lets see. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我们来看看：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 1. I want the "standard compliant" label in the
            library. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 1. 我希望在库中有 "符合标准" 的标记。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 2. This is the natural choice, but knowing that there is another
            option that always works and it is more efficient is awful. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 2. 这是一个自然的选择，但是知道有另一个选择可以使用而且更为高效，这是可怕的。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 3. I have also tried to play with unions, the problem is that
            the union members must be POD types. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 3. 我也试过使用 union，问题是 union 的成员必须是 POD 类型。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 4. This option implies a big lost to the library. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 4. 这个选择意味着本库有巨大损失。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 5. Totally agree. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 5. 完全同意。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I want to add another option to this list. Using metaprogramming,
            the relation class checks if the compiler supports the mutant idiom.
            If it supports it then it uses it and obtains zero overhead plus LValue
            iterators, but if it do not supports it then uses const_reference_pair
            and obtains minimum overhead with ReadWrite iterators. This might be
            controversial but the advantages that mutant offers are very big and
            the truth is that I do not believe that in any actual compiler this idiom
            is not supported. This scheme would adjust perfectly to the present standard
            since we are not supposing anything. The only drawback here is that although
            the mutant approach allows to make LValue iterators we have to degrade
            they to Read Write in both cases, because we want that the same code
            can be compiled in any standard compliant compiler. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我想在这个列表中增加一个选择。通过使用元编程，relation
类可以检查编译器是否支持 mutant 惯用法。如果它支持，则使用它，可以用零代价得到左值迭代器。如果不支持则使用
const_reference_pair ，可以用最小的代价得到读写迭代器。这可能存在争议，但是 mutant
所提供的好处是非常明显的，事实是我不相信会有任何一个真实的编译器不支持它。这一方式完全符合当前的标准，我们没有假设任何前提。唯一的缺点是，虽然
mutant 方法允许左值迭代器，但是我们必须在两种情形下都将它退化为读写迭代器，因为我们希望相同的代码可以在任何符合标准的编译器上通过编译。</em></span></p>
</blockquote></div>
<p>
        <code class="literal">- Hopefully we find our way out of the problem -</code></p><p><code class="literal"></code><code class="literal">- 我们有希望找到解决问题的方法 -</code>
      </p>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Changing the subject, I believe that the general concept of
            hooking data is good, but I do not like the way you implement it. It
            has to be easy to migrate to B.MI to anticipate the case in that Boost.Bimap
            becomes insufficient. It is more natural for a B.MI user that the data
            is accessed without the indirection of <code class="computeroutput"><span class="special">.</span><span class="identifier">data</span></code>. I do not know how this can be
            articulated in your framework. </em></span>
          </p>
<p>
        <span class="emphasis"><em>换个话题，我相信挂载数据的想法是好的，但我不喜欢你实现的方法。它必须易于迁移到 B.MI 以防 Boost.Bimap
            不够用的情形。对于一个 B.MI 用户来说，更自然的方法是不要用 <code class="computeroutput"><span class="special">.</span><span class="identifier">data</span></code> 来间接访问数据。我不知道在你的框架中如何能够实现。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> I have a technical problem to implement the data_hook in this
            way. If the standard would let us use the mutant idiom directly, I can
            implement it using multiple inheritance. But as we must use const_reference_pair
            too, It becomes impossible for me to support it. We have three options
            here: </em></span>
          </p>
<p>
        <span class="emphasis"><em>以这种方法实现 data_hook，我有一个技术问题。如果标准可以让我们直接使用 mutant 惯用法，我可以用多重继承来实现它。但是因为我们还要用 const_reference_pair
           ，这就不可能支持它了。我们有三个选择：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 1) relation { left, right, data } and pair_view { first, second,
            data } </em></span>
          </p>
<p>
        <span class="emphasis"><em> 1) relation { left, right, data } 和 pair_view { first, second,
            data }</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - This is more intuitive within the bimap framework, since
            it does not mix the data with the index, as a table in a data base does,
            but gives more importance to the index. </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 这在 bimap 框架中更为直观，因为它没有把数据和索引混起来，就象数据库中的表那样，不过对索引给予了更多重要性。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - It is not necessary that the user puts the mutable keyword
            in each member of the data class. </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 用户不需要把 mutable 关键字放在数据类的每个成员前。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - This moves away just a little bit from B.MI because the
            model of it is similar to a table, but it continues to exist a clear
            path of migration. </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 这与 B.MI 之间只是一点点距离，因为它的模型类似于表格，不过它存在一个清晰的迁移路径。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 2) relation { left,right, d1,d2... dn } and pair_view { first,
            second, data } </em></span>
          </p>
<p>
        <span class="emphasis"><em> 2) relation { left,right, d1,d2... dn } 和 pair_view { first,
            second, data }</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - The path to B.MI is the one you have proposed. </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 到 B.MI 的迁移正是你所提议的。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - It is very asymmetric. It is necessary to explain that the
            views are handled different that the relation. </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 它非常不对称。它需要解释，关系的视图处理方法不同。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - The user must place the mutable keyboards in the data class.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 用户必须将 mutable 关键字放在数据类中。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 3) Only relation { left,right, d1,d2... dn } </em></span>
          </p>
<p>
        <span class="emphasis"><em> 3) 只有 relation { left,right, d1,d2... dn }</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - Simple migration path to B.MI. </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 迁移到 B.MI 很简单。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> - You are not able to access the hooked data from the views.
            </em></span>
          </p>
<p>
        <span class="emphasis"><em> - 你不能够从视图访问挂载的数据。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> My vote goes to the first proposal. </em></span>
          </p>
<p>
        <span class="emphasis"><em>我投票给第一个建议。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Yes, the first option is the one that less surprises hold
            to the user. I also vote for 1. </em></span>
          </p>
<p>
        <span class="emphasis"><em>是的，第一个选择最不会令用户惊讶。我也投票给 1.</em></span></p>
</blockquote></div>
<p>
        <code class="literal">- The third week was over -</code></p><p><code class="literal"></code><code class="literal">- 第三周结束 -</code>
      </p>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> There is still one problem that I have to solve. I need to
            know if it is necessary to create a map_view associated to nothing. If
            it is necessary there are two options: that it behaves as an empty container
            or that it throws an exception or assert when trying to use it. If it
            is not necessary, the map_view is going to keep a reference instead of
            a pointer. To me, the map_view always must be viewing something. In the
            case of the iterators being able to create them empty, makes them easy
            to use in contexts that require constructors by default, like being the
            value_type of a container, but I do not believe that this is the case
            of map_view. </em></span>
          </p>
<p>
        <span class="emphasis"><em>还有一个问题要解决。我需要知道是否有必要创建一个没有关联的
map_view。如果需要，则有两个选择：要么其行为象一个空的容器，要么在试图使用它时抛出一个异常或断言。如果不需要，则 map_view
将持有一个引用而不是指针。对我来说，map_view
应该总能察看到某些东西。在一些情形下，迭代器可以创建空的容器，还有为了容易使用，也要求缺省构造函数，就象一个容器的 value_type
那样，但是我不认为这种情形适合于 map_view.</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> How would an empty map_view be useful? My intuition is like
            yours, map_view would have to be always associate to something. If we
            wished to obtain the semantics "is associated or not" we can
            use a pointer to a map_view. </em></span>
          </p>
<p>
        <span class="emphasis"><em>一个空的 map_view 可以怎么使用？我的意见和你一样，map_view 应该必须关联到某些东西上。如果我们希望得到 "是否关联" 的语义，我们可以使用指向 map_view 的指针。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> OK, then you agree to that map_views stores a reference instead
            of a pointer? </em></span>
          </p>
<p>
        <span class="emphasis"><em> OK, 那么你同意在 map_views 中保存一个引用而不是指针了？</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Joaquin</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> It depends on the semantics you want to give to map_views,
            and in concrete to the copy of map_views. </em></span>
          </p>
<p>
        <span class="emphasis"><em>这取决于你想给 map_views 的语义，以及复制 map_views 的语义。</em></span></p>
</blockquote></div>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">map_view</span> <span class="identifier">x</span><span class="special">=...;</span>
<span class="identifier">map_view</span> <span class="identifier">y</span><span class="special">=...;</span>
<span class="identifier">x</span><span class="special">=</span><span class="identifier">y</span><span class="special">;</span>
</pre>
<p>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> What is supposed to do this last line? </em></span>
          </p>
<p>
        <span class="emphasis"><em>最后一行应该做些什么呢？</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 1. Rebinding of x, that is to say, x points at the same container
            that y. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 1. 重新绑定 x，即是说，x 指向与 y 同一个容器。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 2. Copy of the underlying container. </em></span>
          </p>
<p>
        <span class="emphasis"><em> 2. 复制底层的容器。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> If you want to implement 1, you cannot use references internally.
            If you want to implement 2, it is almost the same to use a reference
            or a pointer. </em></span>
          </p>
<p>
        <span class="emphasis"><em>如果你想实现 1，那么你不能在内部使用引用。如果你想实现 2，则使用引用或指针都一样。</em></span></p>
</blockquote></div>
<p>
        <span class="bold"><strong>Matias</strong></span>
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> If I want that they behave exactly as std::maps then I must
            go for 2. But if I think they as "views" of something, I like
            1. The question is complicated. I add another option: </em></span>
          </p>
<p>
        <span class="emphasis"><em>如果我想它们的行为和 std::maps 一样，则我必须取用 2。但如果我将它们看作某物的 "视图"，我更喜欢
            1。这个问题是复杂的。我再加一个选择：</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> 3. Error: operator= is declare as private in boost::bimap::map_view
            std_container </em></span>
          </p>
<p>
        <span class="emphasis"><em> 3. 错误：在</em></span><span class="emphasis"><em> boost::bimap::map_view
            std_container</em></span><span class="emphasis"><em> 中将 operator= 声明为私有。</em></span></p>
</blockquote></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            <span class="emphasis"><em> Also What happens with <code class="computeroutput"><span class="identifier">std_container</span>
            <span class="special">=</span> <span class="identifier">view</span><span class="special">;</span></code>? and with <code class="computeroutput"><span class="identifier">view</span>
            <span class="special">=</span> <span class="identifier">std_container</span><span class="special">;</span></code>? </em></span>
          </p>
<p>
        <span class="emphasis"><em>还有，对于 <code class="computeroutput"><span class="identifier">std_container</span>
            <span class="special">=</span> <span class="identifier">view</span><span class="special">;</span></code> 和 <code class="computeroutput"><span class="identifier">view</span>
            <span class="special">=</span> <span class="identifier">std_container</span><span class="special">;</span></code> 又如何呢？</em></span></p>
</blockquote></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2006 -2007 Matias Capeletto<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="code.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../rationale.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../history.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
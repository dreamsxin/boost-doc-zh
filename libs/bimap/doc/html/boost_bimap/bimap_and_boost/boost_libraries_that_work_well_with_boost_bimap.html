<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Boost Libraries that work well with Boost.Bimap</title><link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="Chapter&nbsp;1.&nbsp;Boost.Bimap">
<link rel="up" href="../bimap_and_boost.html" title="Bimap and Boost">
<link rel="prev" href="../bimap_and_boost.html" title="Bimap and Boost">
<link rel="next" href="dependencies.html" title="Dependencies"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../bimap_and_boost.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bimap_and_boost.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="dependencies.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html" title="Boost Libraries that work well with Boost.Bimap">Boost
      Libraries that work well with Boost.Bimap 可以与 Boost.Bimap 共同使用的 Boost 库</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.introduction">Introduction 简介</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_serialization">Boost.Serialization</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_assign">Boost.Assign</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_hash">Boost.Hash</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_lambda">Boost.Lambda</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_range">Boost.Range</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_foreach">Boost.Foreach</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_typeof">Boost.Typeof</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_xpressive">Boost.Xpressive</a></span></dt>
<dt><span class="section"><a href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_property_map">Boost.Property_map</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.introduction"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.introduction" title="Introduction">Introduction 简介</a>
</h4></div></div></div>
<div class="informaltable"><table class="table">
<colgroup><col><col><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  Name 名字
                </p>
                </th>
<th>
                <p>
                  Description 说明
                </p>
                </th>
<th>
                <p>
                  author 作者
                </p>
                </th>
<th>
                <p>
                  Purpose 目的
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/libs/serialization/doc/index.html" target="_top"><span class="bold"><strong>Boost.Serialization</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  Serialization for persistence and marshalling</p><p>为持续性和重整进行序列化
                </p>
                </td>
<td>
                <p>
                  Robert Ramey
                </p>
                </td>
<td>
                <p>
                  Serialization support for bimap containers and iterators</p><p>支持 bimap 容器及迭代器的序列化
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/libs/assign/doc/index.html" target="_top"><span class="bold"><strong>Boost.Assign</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  Filling containers with constant or generated data has never been
                  easier</p><p>以最易用的方式用常数或生成的数据填充容器
                </p>
                </td>
<td>
                <p>
                  Thorsten Ottosen
                </p>
                </td>
<td>
                <p>
                  Help to fill a bimap or views of it</p><p>帮助填充一个 bimap 或其视图
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/doc/html/hash.html" target="_top"><span class="bold"><strong>Boost.Hash</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  A TR1 hash function object that can be extended to hash user defined
                  types</p><p>TR1的散列函数对象，可以扩展至对用户自定义类型进行散列
                </p>
                </td>
<td>
                <p>
                  Daniel James
                </p>
                </td>
<td>
                <p>
                  Default hashing function</p><p>缺省的散列函数
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/doc/html/lambda.html" target="_top"><span class="bold"><strong>Boost.Lambda</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  Define small unnamed function objects at the actual call site,
                  and more</p><p>就地定义小型匿名函数对象，及其它
                </p>
                </td>
<td>
                <p>
                  from Jaakko Järvi, Gary Powell
                </p>
                </td>
<td>
                <p>
                  Functors for modify, range, lower_bound and upper_bound</p><p>用于 modify, range, lower_bound 和 upper_bound&nbsp;的函数对象
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/doc/html/range.html" target="_top"><span class="bold"><strong>Boost.Range</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  A new infrastructure for generic algorithms that builds on top
                  of the new iterator concepts</p><p>用于泛型算法的新的基础设施，建筑于新的迭代器概念之上
                </p>
                </td>
<td>
                <p>
                  Thorsten Ottosen
                </p>
                </td>
<td>
                <p>
                  Range based algorithms</p><p>基于区间范围的算法
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/doc/html/foreach.html" target="_top"><span class="bold"><strong>Boost.Foreach</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  BOOST_FOREACH macro for easily iterating over the elements of a
                  sequence</p><p>BOOST_FOREACH 宏，更容易地遍历一个序列的元素
                </p>
                </td>
<td>
                <p>
                  Eric Niebler
                </p>
                </td>
<td>
                <p>
                  Iteration</p><p>迭代
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/libs/typeof/doc/index.html" target="_top"><span class="bold"><strong>Boost.Typeof</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  Typeof operator emulation</p><p>模仿 typeof 操作符
                </p>
                </td>
<td>
                <p>
                  Arkadiy Vertleyb, Peder Holt
                </p>
                </td>
<td>
                <p>
                  Using BOOST_AUTO while we wait for C++0x</p><p>在等待 C++0x 之时使用 BOOST_AUTO
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/libs/xpressive/doc/index.html" target="_top"><span class="bold"><strong>Boost.Xpressive</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  Regular expressions that can be written as strings or as expression
                  templates</p><p>可以写为字符串或表达式模板的正规表达式
                </p>
                </td>
<td>
                <p>
                  Eric Niebler
                </p>
                </td>
<td>
                <p>
                  Help to fill a bimap from a string</p><p>帮助从一个字符串填充 bimap
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <a href="http://www.boost.org/doc/html/property_map.html" target="_top"><span class="bold"><strong>Boost.PropertyMap</strong></span></a>
                </p>
                </td>
<td>
                <p>
                  Concepts defining interfaces which map key objects to value objects</p><p>定义了将键对象映射至值对象的接口的概念
                </p>
                </td>
<td>
                <p>
                  Jeremy Siek
                </p>
                </td>
<td>
                <p>
                  Integration with BGL</p><p>与 BGL 集成
                </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_serialization"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_serialization" title="Boost.Serialization">Boost.Serialization</a>
</h4></div></div></div>
<p>
          A bimap can be archived and retrieved by means of the Boost.Serialization
          Library. Both regular and XML archives are supported. The usage is straightforward
          and does not differ from that of any other serializable type. For instance:</p><p>bimap 可以通过 Boost.Serialization 库进行存档和取回。常规存档和XML存档均可支持。用法直接，与其它可序列化类型没有区别。例如：
        </p>


<p>
          <a href="../../../../example/bimap_and_boost/serialization.cpp" target="_top">Go to source
          code 察看源代码</a></p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">bm_type</span><span class="special">;</span>

<span class="comment">// Create a bimap and serialize it to a file 创建一个bimap并将它序列化至文件<br></span><span class="special">{</span>
    <span class="identifier">bm_type</span> <span class="identifier">bm</span><span class="special">;</span>
    <span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"one"</span><span class="special">,</span><span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"two"</span><span class="special">,</span><span class="number">2</span><span class="special">)</span> <span class="special">);</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ofstream</span> <span class="identifier">ofs</span><span class="special">(</span><span class="string">"data"</span><span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">text_oarchive</span> <span class="identifier">oa</span><span class="special">(</span><span class="identifier">ofs</span><span class="special">);</span>

    <span class="identifier">oa</span> <span class="special">&lt;&lt;</span> <span class="keyword">const_cast</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">bm_type</span><span class="special">&amp;&gt;(</span><span class="identifier">bm</span><span class="special">);</span> <span class="callout_bug"><a class="co" name="boost_bimap16co" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap16"><img src="../../images/callouts/1.png" alt="1" border="0"></a></span>

    <span class="line_callout_bug"><a class="co" name="boost_bimap17co" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap17"><img src="../../images/callouts/2.png" alt="2" border="0"></a></span><span class="keyword">const</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_iterator</span> <span class="identifier">left_iter</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="string">"two"</span><span class="special">);</span>
    <span class="identifier">oa</span> <span class="special">&lt;&lt;</span> <span class="identifier">left_iter</span><span class="special">;</span>

    <span class="keyword">const</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">right_iterator</span> <span class="identifier">right_iter</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
    <span class="identifier">oa</span> <span class="special">&lt;&lt;</span> <span class="identifier">right_iter</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// Load the bimap back 取回bimap<br></span><span class="special">{</span>
    <span class="identifier">bm_type</span> <span class="identifier">bm</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ifstream</span> <span class="identifier">ifs</span><span class="special">(</span><span class="string">"data"</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ios</span><span class="special">::</span><span class="identifier">binary</span><span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">text_iarchive</span> <span class="identifier">ia</span><span class="special">(</span><span class="identifier">ifs</span><span class="special">);</span>

    <span class="identifier">ia</span> <span class="special">&gt;&gt;</span> <span class="identifier">bm</span><span class="special">;</span>

    <span class="identifier">assert</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>

    <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_iterator</span> <span class="identifier">left_iter</span><span class="special">;</span>
    <span class="identifier">ia</span> <span class="special">&gt;&gt;</span> <span class="identifier">left_iter</span><span class="special">;</span>

    <span class="identifier">assert</span><span class="special">(</span> <span class="identifier">left_iter</span><span class="special">-&gt;</span><span class="identifier">first</span> <span class="special">==</span> <span class="string">"two"</span> <span class="special">);</span>

    <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">right_iterator</span> <span class="identifier">right_iter</span><span class="special">;</span>
    <span class="identifier">ia</span> <span class="special">&gt;&gt;</span> <span class="identifier">right_iter</span><span class="special">;</span>

    <span class="identifier">assert</span><span class="special">(</span> <span class="identifier">right_iter</span><span class="special">-&gt;</span><span class="identifier">first</span> <span class="special">==</span> <span class="number">1</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
          </p>
<p>
            </p>
<div class="calloutlist"><table summary="Callout list" border="0">
<tbody><tr>
<td align="left" valign="top" width="5%"><p><a name="boost_bimap16"></a><a href="#boost_bimap16co"><img src="../../images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td align="left" valign="top"><p>
            We must do a const cast because Boost.Serialization archives only save
            const objects. Read Boost.Serializartion docs for the rationale behind
            this decision</p><p>我们必须做一次 const cast，因为 Boost.Serialization 存档只能保存常量对象。此问题的相关原理请见 Boost.Serialization 的文档。 </p></td>
</tr>
<tr>
<td align="left" valign="top" width="5%"><p><a name="boost_bimap17"></a><a href="#boost_bimap17co"><img src="../../images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td align="left" valign="top"><p> We can only serialize iterators if the bimap was serialized
            first. Note that the const cast is not requiered here because we create
            our iterators as const.</p><p>我们只能先序列化 bimap，然后才可以序列化迭代器。注意，由于我们已经将迭代器创建为 const 的，所以这里不再需要 const cast。 </p></td>
</tr>
</tbody></table></div>


<p>
          Serialization capabilities are automatically provided by just linking with
          the appropriate Boost.Serialization library module: it is not necessary
          to explicitly include any header from Boost.Serialization, apart from those
          declaring the type of archive used in the process. If not used, however,
          serialization support can be disabled by globally defining the macro BOOST_BIMAP_DISABLE_SERIALIZATION.
          Disabling serialization for Boost.MultiIndex can yield a small improvement
          in build times, and may be necessary in those defective compilers that
          fail to correctly process Boost.Serialization headers.</p><p>只
要与合适的 Boost.Serialization 库链接，就能自动提供序列化的能力：不需要显式包含任何
Boost.Serialization
的头文件，除了那些声明了要使用的存档类型的头文件以外。不过，如果不使用序列化，也可以通过在全局定义一个宏
BOOST_BIMAP_DISABLE_SERIALIZATION 来禁止掉序列化的支持。禁止 Boost.MultiIndex
的序列化可以对构建时间有少许的改进，也可能对于那些有缺陷的不能正确处理 Boost.Serialization 头文件的编译器，这是必须的。 </p>
<div class="warning"><table summary="Warning" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../../doc/html/images/warning.png"></td>
<th align="left">Warning 警告</th>
</tr>
<tr><td align="left" valign="top"><p>
            Boost.Bimap and Boost.MultiIndex share a lot of serialization code. The
            macro <code class="computeroutput"><span class="identifier">BOOST_BIMAP_DISABLE_SERIALIZATION</span></code>
            disables serialization in <span class="bold"><strong>both</strong></span> libraries.
            The same happens when <code class="computeroutput"><span class="identifier">BOOST_MULTI_INDEX_DISABLE_SERIALIZATION</span></code>
            is defined.</p><p>
            Boost.Bimap 和 Boost.MultiIndex 共享了大量的序列化代码。宏 <code class="computeroutput"><span class="identifier">BOOST_BIMAP_DISABLE_SERIALIZATION</span></code> 将禁止掉<span style="font-weight: bold;">两个</span>库的序列化。如果定义了 <code class="computeroutput"><span class="identifier">BOOST_MULTI_INDEX_DISABLE_SERIALIZATION</span></code>，结果也一样。
          </p></td></tr>
</tbody></table></div>
<p>
          Retrieving an archived bimap restores not only the elements, but also the
          order they were arranged in the views of the container. There is an exception
          to this rule, though: for unordered sets, no guarantee is made about the
          order in which elements will be iterated in the restored container; in
          general, it is unwise to rely on the ordering of elements of a hashed view,
          since it can change in arbitrary ways during insertion or rehashing --this
          is precisely the reason why hashed indices and TR1 unordered associative
          containers do not define an equality operator.</p><p>取
加一个存档的 bimap，不仅恢复了其中的元素，同时它们对于容器各视图的顺序也是排好的。不过对于这一规则有一个例外：对于 unordered
set，被恢复的容器中的元素的遍历顺序没有保证；通常，依赖于一个散列视图的元素顺序是不明智的，因为在插入和重散列时，元素的顺序会任意改变--这正
是为什么散列索引和TR1的无序关联式容器没有定义相等操作符的原因。
        </p>
<p>
          Iterators of a bimap can also be serialized. Serialization of an iterator
          must be done only after serializing its corresponding container.</p><p>
          bimap 的迭代器也可以被序列化。对一个迭代器的序列化必须在其对应容器被序列化之后进行。
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_assign"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_assign" title="Boost.Assign">Boost.Assign</a>
</h4></div></div></div>
<p>
          The purpose of this library is to make it easy to fill containers with
          data by overloading operator,() and operator()(). These two operators make
          it possible to construct lists of values that are then copied into a container.</p><p>这个库的目的是可以很容易地向容器中填充数据，它通过重载 operator,() 和 operator()() 来实现。这两个操作符可以构造一个值列表，然后复制到容器中。
        </p>
<p>
          These lists are particularly useful in learning, testing, and prototyping
          situations, but can also be handy otherwise. The library comes with predefined
          operators for the containers of the standard library, but most functionality
          will work with any standard compliant container. The library also makes
          it possible to extend user defined types so for example a member function
          can be called for a list of values instead of its normal arguments.</p><p>这些列表尤其适用于学习、测试和原型化，但是在其它情况下也很方便。该库对于标准库的容器预定义了一些操作符，但多数功能都可以用于与标准兼容的任意容器。该库也可以扩展至用户自定义类型，例如某个成员函数可以对一个值列表进行调用，替换原有的普通参数。
        </p>
<p>
          Boost.Assign can be used with bimap containers. The views of a bimap are
          signature-compatible with their standard counterparts, so we can use other
          Boost.Assign utilities with them.</p><p>Boost.Assign 可以用于 bimap 容器。bimap 的视图与标准中的对应物是签名兼容的，所以我们可以对它们使用其它 Boost.Assign 工具。
        </p>


<p>
          <a href="../../../../example/bimap_and_boost/assign.cpp" target="_top">Go to source code 察看源代码</a></p>
<pre class="programlisting"> <span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="identifier">multiset_of</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;,</span> <span class="identifier">list_of</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">bm_type</span><span class="special">;</span>

 <span class="comment">// We can use assign::list_of to initialize the container.<br> // 我们可以用 assign::list_of 来初始化该容器。<br></span>
 <span class="identifier">bm_type</span> <span class="identifier">bm</span> <span class="special">=</span> <span class="identifier">assign</span><span class="special">::</span><span class="identifier">list_of</span><span class="special">&lt;</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">relation</span> <span class="special">&gt;</span> <span class="callout_bug"><a class="co" name="boost_bimap18co" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap18"><img src="../../images/callouts/1.png" alt="1" border="0"></a></span>
     <span class="special">(</span> <span class="number">1</span><span class="special">,</span> <span class="string">"one"</span>   <span class="special">)</span>
     <span class="special">(</span> <span class="number">2</span><span class="special">,</span> <span class="string">"two"</span>   <span class="special">)</span>
     <span class="special">(</span> <span class="number">3</span><span class="special">,</span> <span class="string">"three"</span> <span class="special">);</span>

 <span class="comment">// The left map view is a multiset, again we use insert<br> // 左映射视图是一个 multiset，我们再次使用 insert<br></span>
 <span class="identifier">assign</span><span class="special">::</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span> <span class="special">)</span>
     <span class="special">(</span> <span class="number">4</span><span class="special">,</span> <span class="string">"four"</span> <span class="special">)</span>
     <span class="special">(</span> <span class="number">5</span><span class="special">,</span> <span class="string">"five"</span> <span class="special">)</span>
     <span class="special">(</span> <span class="number">6</span><span class="special">,</span> <span class="string">"six"</span>  <span class="special">);</span>

 <span class="comment">// The right map view is a list so we use push_back here<br></span> <span class="comment">// Note the order of the elements in the list!<br> // 右映射视图是一个 list，所以我们使用 push_back。注意在 list 中的元素顺序<br></span>
 <span class="identifier">assign</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span> <span class="special">)</span>
     <span class="special">(</span> <span class="string">"seven"</span> <span class="special">,</span> <span class="number">7</span> <span class="special">)</span>
     <span class="special">(</span> <span class="string">"eight"</span> <span class="special">,</span> <span class="number">8</span> <span class="special">);</span>

 <span class="identifier">assign</span><span class="special">::</span><span class="identifier">push_front</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span> <span class="special">)</span>
     <span class="special">(</span> <span class="string">"nine"</span>  <span class="special">,</span>  <span class="number">9</span> <span class="special">)</span>
     <span class="special">(</span> <span class="string">"ten"</span>   <span class="special">,</span> <span class="number">10</span> <span class="special">)</span>
     <span class="special">(</span> <span class="string">"eleven"</span><span class="special">,</span> <span class="number">11</span> <span class="special">);</span>

<span class="comment">// Since it is left_based the main view is a multiset, so we use insert<br>// 因为容器是 left_based 的，所以主视图是 multiset，所以我们使用 insert<br></span>
 <span class="identifier">assign</span><span class="special">::</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm</span> <span class="special">)</span>
     <span class="special">(</span> <span class="number">12</span><span class="special">,</span> <span class="string">"twelve"</span>   <span class="special">)</span>
     <span class="special">(</span> <span class="number">13</span><span class="special">,</span> <span class="string">"thirteen"</span> <span class="special">);</span>
 </pre>
<p>
          </p>
<div class="calloutlist"><table summary="Callout list" border="0"><tbody><tr>
<td align="left" valign="top" width="5%"><p><a name="boost_bimap18"></a><a href="#boost_bimap18co"><img src="../../images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td align="left" valign="top"><p>
        Note that <code class="computeroutput"><span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">relation</span></code> has to be used instead of
            <code class="computeroutput"><span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span></code>. Contrary to <code class="computeroutput"><span class="identifier">value_type</span></code>, <code class="computeroutput"><span class="identifier">relation</span></code>
            type stores the elements as non const, a requirement of <code class="computeroutput"><span class="identifier">assign</span><span class="special">::</span><span class="identifier">list_of</span></code></p><p><code class="computeroutput"><span class="identifier"></span></code>
        注意，必须使用 <code class="computeroutput"><span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">relation</span></code> 来代替
            <code class="computeroutput"><span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span></code>。与 <code class="computeroutput"><span class="identifier">value_type</span></code> 不同，<code class="computeroutput"><span class="identifier">relation</span></code>
            类型以非const方式保存元素，这是 <code class="computeroutput"><span class="identifier">assign</span><span class="special">::</span><span class="identifier">list_of</span></code> 的要求。<code class="computeroutput"><span class="identifier"></span></code> </p></td>
</tr></tbody></table></div>
<p>
          </p></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_hash"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_hash" title="Boost.Hash">Boost.Hash</a>
</h4></div></div></div>
<p>
          The hash function is the very core of the fast lookup capabilities of the
          unordered sets: a hasher is just a Unary Function returning an std::size_t
          value for any given key. In general, it is impossible that every key map
          to a different hash value, for the space of keys can be greater than the
          number of permissible hash codes: what makes for a good hasher is that
          the probability of a collision (two different keys with the same hash value)
          is as close to zero as possible.</p><p>散
列函数是无序集合的快速查找能力的核心：散列器就是一个可以对任意给定的键值返回一个 std::size_t
值的单参函数对象。通常，它不可能将每一个键值映射到一个不同的散列值，键值的空间可以大于所允许的散列值的数量：一个好的散列器，要求其发生冲突(两个
不同的键值对应同一个散列值)的可能性尽量接近于零。 </p>
<p>
          This is a statistical property depending on the typical distribution of
          keys in a given application, so it is not feasible to have a general-purpose
          hash function with excellent results in every possible scenario; the default
          value for this parameter uses Boost.Hash, which often provides good enough
          results.</p><p>这是一种统计特性，它依赖于在给定应用中的键值分布情况，所以不存在一个通用的散列函数，可以在各种情况都得到很好的效果；这个参数的缺省值将使用 Boost.Hash，它通常能够提供不错的效果。
        </p>
<p>
          Boost.Hash can be <a href="http://www.boost.org/regression-logs/cs-win32_metacomm/doc/html/hash/custom.html" target="_top">extended
          for custom data types</a>, enabling to use the default parameter of
          the unordered set types with any user types.</p><p>
          Boost.Hash 可以 <a href="http://www.boost.org/regression-logs/cs-win32_metacomm/doc/html/hash/custom.html" target="_top">针对定制的数据类型进行扩展</a>，以对用户类型使用无序集合类型的缺省参数。
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_lambda"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_lambda" title="Boost.Lambda">Boost.Lambda</a>
</h4></div></div></div>
<p>
          The Boost Lambda Library (BLL in the sequel) is a C++ template library,
          which implements form of lambda abstractions for C++. The term originates
          from functional programming and lambda calculus, where a lambda abstraction
          defines an unnamed function. Lambda expressions are very useful to construct
          the function objects required by some of the functions in a bimap view.</p><p>Boost
Lambda 库(后称BLL)是一个C++模板库，它为C++实现了 lambda 抽象形式。这一术语来源自函数式编程和 lambda
运算，lambda 抽象定义了一个匿名函数。Lambda 表达式对于在 bimap 视图的某些函数中构造函数对象非常有用。
        </p>
<p>
          Boost.Bimap defines new placeholders in <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">/</span><span class="identifier">support</span><span class="special">/</span><span class="identifier">lambda</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
          to allow a sounder solution. The placeholders are named _key and _data
          and both are equivalent to boost::lambda::_1. There are two reasons to
          include this placeholders: the code looks better with them and they avoid
          the clash problem between lambda::_1 and boost::_1 from Boost.Bind.</p><p>
          Boost.Bimap 在 <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">/</span><span class="identifier">support</span><span class="special">/</span><span class="identifier">lambda</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
中定义了新的占位符，以得到更漂亮的解法。这些占位符名为 _key 和 _data，它们都等价于 boost::lambda::_1.
包含这些占位符有两个原因：代码更好看一些，而且避免了在 lambda::_1 和 Boost::Bind 的 boost::_1
间的冲突问题。 </p>


<p>
          <a href="../../../../example/bimap_and_boost/lambda.cpp" target="_top">Go to source code 察看源代码</a></p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">bm_type</span><span class="special">;</span>

<span class="identifier">bm_type</span> <span class="identifier">bm</span><span class="special">;</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"one"</span><span class="special">,</span><span class="number">1</span><span class="special">)</span> <span class="special">);</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"two"</span><span class="special">,</span><span class="number">2</span><span class="special">)</span> <span class="special">);</span>

<span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span><span class="special">.</span><span class="identifier">range</span><span class="special">(</span> <span class="number">5</span> <span class="special">&lt;</span> <span class="identifier">_key</span><span class="special">,</span> <span class="identifier">_key</span> <span class="special">&lt;</span> <span class="number">10</span> <span class="special">);</span>

<span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">modify_key</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="string">"one"</span><span class="special">),</span> <span class="identifier">_key</span> <span class="special">=</span> <span class="string">"1"</span> <span class="special">);</span>

<span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">modify_data</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">_data</span> <span class="special">*=</span> <span class="number">10</span> <span class="special">);</span>
</pre>
<p>
          </p></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_range"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_range" title="Boost.Range">Boost.Range</a>
</h4></div></div></div>
<p>
          Boost.Range is a collection of concepts and utilities that are particularly
          useful for specifying and implementing generic algorithms. Generic algorithms
          have so far been specified in terms of two or more iterators. Two iterators
          would together form a range of values that the algorithm could work on.
          This leads to a very general interface, but also to a somewhat clumsy use
          of the algorithms with redundant specification of container names. Therefore
          we would like to raise the abstraction level for algorithms so they specify
          their interface in terms of Ranges as much as possible.</p><p>Boost.Range
包含一组概念和工具，它们特别适用于声明和实现泛型算法。当前的泛型算法都是以两个或多个迭代器来声明的。这两个迭代器一起表示了该算法要操作的一组值的
范围。这导致了一个非常通用的接口，但是也由于容器名的冗余而使得算法的使用有些笨拙。因此我们希望提升算法的抽象级别，尽可能按照 Range
来声明。
        </p>
<p>
          As Boost.Bimap views are signature-compatible with their standard container
          counterparts, they are compatible with the concept of a range. As an additional
          feature, ordered bimap views offer a function named <code class="computeroutput"><span class="identifier">range</span></code>
          that allows a range of values to be obtained.&nbsp;</p><p>由于 Boost.Bimap 的视图签名兼容于它们的标准容器对应物，所以它们也兼容于 range 的概念。作为一个额外的特性，有序的 bimap 视图提供了一个名为 <code class="computeroutput"><span class="identifier">range</span></code>
          的函数，以获得值的 range。
        </p>


<p>
          If we have some generic functions that accepts ranges:</p><p>如果我们有一些接受 range 的泛型函数：</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">ForwardReadableRange</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">UnaryFunctor</span> <span class="special">&gt;</span>
<span class="identifier">UnaryFunctor</span> <span class="identifier">for_each</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ForwardReadableRange</span> <span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="identifier">UnaryFunctor</span> <span class="identifier">func</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <br>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">range_const_iterator</span><span class="special">&lt;</span><span class="identifier">ForwardReadableRange</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">const_iterator</span><span class="special">;</span>

    <span class="keyword">for</span><span class="special">(</span><span class="identifier">const_iterator</span> <span class="identifier">i</span><span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">r</span><span class="special">),</span> <span class="identifier">iend</span><span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span><span class="identifier">r</span><span class="special">);</span> <span class="identifier">i</span><span class="special">!=</span><span class="identifier">iend</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">func</span><span class="special">(*</span><span class="identifier">i</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="identifier">func</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">ForwardReadableRange</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span> <span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">range_difference</span><span class="special">&lt;</span><span class="identifier">ForwardReadableRange</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">count_if</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ForwardReadableRange</span> <span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">range_const_iterator</span><span class="special">&lt;</span><span class="identifier">ForwardReadableRange</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">const_iterator</span><span class="special">;</span>

    <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">range_difference</span><span class="special">&lt;</span><span class="identifier">ForwardReadableRange</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">c</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

    <span class="keyword">for</span><span class="special">(</span> <span class="identifier">const_iterator</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">r</span><span class="special">),</span> <span class="identifier">iend</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">end</span><span class="special">(</span><span class="identifier">r</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">iend</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">if</span><span class="special">(</span> <span class="identifier">pred</span><span class="special">(*</span><span class="identifier">i</span><span class="special">)</span> <span class="special">)</span> <span class="special">++</span><span class="identifier">c</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="identifier">c</span><span class="special">;</span>
<span class="special">}</span>
</pre>


<p>
          <br>We can use them with Boost.Bimap with the help of the <code class="computeroutput"><span class="identifier">range</span></code>
          function.
        </p>

<p>
          我们就可以在&nbsp;<code class="computeroutput"><span class="identifier">range</span></code>
 函数的帮助下将它们用于 Boost.Bimap。</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">pair_printer</span>
<span class="special">{</span>
    <span class="identifier">pair_printer</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="identifier">o</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">os</span><span class="special">(</span><span class="identifier">o</span><span class="special">)</span> <span class="special">{}</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Pair</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Pair</span> <span class="special">&amp;</span> <span class="identifier">p</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">os</span> <span class="special">&lt;&lt;</span> <span class="string">"("</span> <span class="special">&lt;&lt;</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">first</span> <span class="special">&lt;&lt;</span> <span class="string">","</span> <span class="special">&lt;&lt;</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span> <span class="special">&lt;&lt;</span> <span class="string">")"</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="identifier">os</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">second_extractor</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Pair</span> <span class="special">&gt;</span>
    <span class="keyword">const</span> <span class="keyword">typename</span> <span class="identifier">Pair</span><span class="special">::</span><span class="identifier">second_type</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Pair</span> <span class="special">&amp;</span> <span class="identifier">p</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">multiset_of</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">bm_type</span><span class="special">;</span>

    <span class="identifier">bm_type</span> <span class="identifier">bm</span><span class="special">;</span>
    <span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="number">2.5</span> <span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="number">3.1</span> <span class="special">,</span> <span class="number">2</span><span class="special">)</span> <span class="special">);</span>
    <span class="comment">//...<br></span>    <span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="number">6.4</span> <span class="special">,</span> <span class="number">4</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="number">1.7</span> <span class="special">,</span> <span class="number">2</span><span class="special">)</span> <span class="special">);</span>

    <span class="comment">// Print all the elements of the left map view<br>    // 打印左映射视图的所有元素<br></span>
    <span class="identifier">for_each</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">,</span> <span class="identifier">pair_printer</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">)</span> <span class="special">);</span>

    <span class="comment">// Print a range of elements of the right map view<br>    // 打印右映射视图中某个范围的元素<br></span>
    <span class="identifier">for_each</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span><span class="special">.</span><span class="identifier">range</span><span class="special">(</span> <span class="number">2</span> <span class="special">&lt;=</span> <span class="identifier">_key</span><span class="special">,</span> <span class="identifier">_key</span> <span class="special">&lt;</span> <span class="number">6</span> <span class="special">),</span> <span class="identifier">pair_printer</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">)</span> <span class="special">);</span>

    <span class="comment">// Count the number of elements where the data is equal to 2 from a<br></span>    <span class="comment">// range of elements of the left map view<br>    // 从左映射视图的某个范围的元素中计算其数据值等于2的元素数量<br></span>
    <span class="identifier">count_if</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">range</span><span class="special">(</span> <span class="number">2.3</span> <span class="special">&lt;</span> <span class="identifier">_key</span><span class="special">,</span> <span class="identifier">_key</span> <span class="special">&lt;</span> <span class="number">5.4</span> <span class="special">),</span>
              <span class="identifier">bind</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span> <span class="identifier">second_extractor</span><span class="special">(),</span> <span class="identifier">_1</span> <span class="special">)</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>


<p>
          <br><a href="../../../../example/bimap_and_boost/range.cpp" target="_top">Go to source code 察看源代码</a>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_foreach"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_foreach" title="Boost.Foreach">Boost.Foreach</a>
</h4></div></div></div>
<p>
          In C++, writing a loop that iterates over a sequence is tedious. We can
          either use iterators, which requires a considerable amount of boiler-plate,
          or we can use the std::for_each() algorithm and move our loop body into
          a predicate, which requires no less boiler-plate and forces us to move
          our logic far from where it will be used. In contrast, some other languages,
          like Perl, provide a dedicated "foreach" construct that automates
          this process. BOOST_FOREACH is just such a construct for C++. It iterates
          over sequences for us, freeing us from having to deal directly with iterators
          or write predicates.</p><p>在C++中，编写一个循环来遍历一个序列是很乏味的。我们可以使用迭代器，它要求相当数量的 boiler-plate，或者我们可以使用 std::for_each() 算法，这样我们需要将我们的循环体写成一个谓词，它并没有减少 boiler
-plate，还迫使我们将处理逻辑移到了远离使用点的地方。作为比较，有些语言，如
Perl，提供了一个专门的"foreach"结构来自动处理这一过程。BOOST_FOREACH
就是用于C++的这样一个结构。它为我们迭代整个序列，不需要我们直接处理迭代器或编写谓词。
        </p>
<p>
          You can use BOOST_FOREACH macro with Boost.Bimap views. The generated code
          will be as efficient as a std::for_each iteration. Here are some examples:
        </p>

<p>
          你可以对 Boost.Bimap 视图使用 BOOST_FOREACH 宏。所生成的代码和 std::for_each 迭代同样高效。以下是一些例子：</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">list_of</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">bm_type</span><span class="special">;</span>

<span class="identifier">bm_type</span> <span class="identifier">bm</span><span class="special">;</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"1"</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"2"</span><span class="special">,</span> <span class="number">2</span><span class="special">)</span> <span class="special">);</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"3"</span><span class="special">,</span> <span class="number">4</span><span class="special">)</span> <span class="special">);</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"4"</span><span class="special">,</span> <span class="number">2</span><span class="special">)</span> <span class="special">);</span>

<span class="identifier">BOOST_FOREACH</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_reference</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="special">++</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span><span class="special">;</span> <span class="callout_bug"><a class="co" name="boost_bimap19co" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap19"><img src="../../images/callouts/1.png" alt="1" border="0"></a></span>
<span class="special">}</span>

<span class="identifier">BOOST_FOREACH</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">right_const_reference</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">first</span> <span class="special">&lt;&lt;</span> <span class="string">"--&gt;"</span> <span class="special">&lt;&lt;</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

</pre>
<div class="calloutlist"><table summary="Callout list" border="0"><tbody><tr>
<td align="left" valign="top" width="5%"><p><a name="boost_bimap19"></a><a href="#boost_bimap19co"><img src="../../images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td align="left" valign="top"><p> We can modify the right element because we have use a mutable collection
            type in the right side.</p><p>我们可以修改右边的元素，因为我们在右侧使用了可修改的组合类型。 </p></td>
</tr></tbody></table></div>


<p>
          <br>You can use it directly with ranges too:
        </p>

<p>
          你也可以直接使用 range：</p>
<pre class="programlisting"><span class="identifier">BOOST_FOREACH</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_reference</span> <span class="identifier">p</span><span class="special">,</span>
             <span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">range</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"1"</span><span class="special">)</span> <span class="special">&lt;=</span> <span class="identifier">_key</span><span class="special">,</span> <span class="identifier">_key</span> <span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"3"</span><span class="special">)</span> <span class="special">)</span> <span class="special">))</span>
<span class="special">{</span>
    <span class="special">++</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">BOOST_FOREACH</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">left_const_reference</span> <span class="identifier">p</span><span class="special">,</span>
             <span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">left</span><span class="special">.</span><span class="identifier">range</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"1"</span><span class="special">)</span> <span class="special">&lt;=</span> <span class="identifier">_key</span><span class="special">,</span> <span class="identifier">_key</span> <span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"3"</span><span class="special">)</span> <span class="special">)</span> <span class="special">))</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">first</span> <span class="special">&lt;&lt;</span> <span class="string">"--&gt;"</span> <span class="special">&lt;&lt;</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>


<p>
          <br><a href="../../../../example/bimap_and_boost/foreach.cpp" target="_top">Go to source code 察看源代码</a>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_typeof"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_typeof" title="Boost.Typeof">Boost.Typeof</a>
</h4></div></div></div>
<p>
          Once C++0x is out we are going to be able to write code like:</p><p>一旦 C++0x 发布，我们就可以写这样的代码：
        </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">iter</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;().</span><span class="identifier">find</span><span class="special">(</span><span class="string">"john"</span><span class="special">);</span>
</pre>
<p>
          instead of the more verbose</p><p>替代以下冗长的写法：
        </p>
<pre class="programlisting"><span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">map_by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">iter</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;().</span><span class="identifier">find</span><span class="special">(</span><span class="string">"john"</span><span class="special">);</span>
</pre>
<p>
          Boost.Typeof defines a macro BOOST_AUTO that can be used as a library solution
          to the auto keyword while we wait for the next standard.</p><p>Boost.Typeof 定义了一个宏 BOOST_AUTO，在我们等待新标准的期间，它可以用作对 auto 关键字的一个库形式的解决方案。
        </p>
<p>
          If we have
        </p>

<p>
          如果我们有：</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="identifier">tagged</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><span class="identifier">name</span><span class="special">&gt;,</span> <span class="identifier">tagged</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span><span class="identifier">number</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">bm_type</span><span class="special">;</span>
<span class="identifier">bm_type</span> <span class="identifier">bm</span><span class="special">;</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"one"</span>  <span class="special">,</span><span class="number">1</span><span class="special">)</span> <span class="special">);</span>
<span class="identifier">bm</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="string">"two"</span>  <span class="special">,</span><span class="number">2</span><span class="special">)</span> <span class="special">);</span>
</pre>


<p>
          The following code snippet
        </p>

<p>
          则以下代码片断：</p>
<pre class="programlisting"><span class="keyword">for</span><span class="special">(</span> <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">map_by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">iter</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;().</span><span class="identifier">begin</span><span class="special">();</span>
     <span class="identifier">iter</span><span class="special">!=</span><span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;().</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">iter</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">first</span> <span class="special">&lt;&lt;</span> <span class="string">" --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">second</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">map_by</span><span class="special">&lt;</span><span class="identifier">number</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">iter</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">number</span><span class="special">&gt;().</span><span class="identifier">find</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"2: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;();</span>
</pre>


<p>
          can be rewrited as
        </p>

<p>
          可以写为：</p>
<pre class="programlisting"><span class="keyword">for</span><span class="special">(</span> <span class="identifier">BOOST_AUTO</span><span class="special">(</span><span class="identifier">iter</span><span class="special">,</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;().</span><span class="identifier">begin</span><span class="special">());</span> <span class="identifier">iter</span><span class="special">!=</span><span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;().</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">iter</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">first</span> <span class="special">&lt;&lt;</span> <span class="string">" --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">second</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">BOOST_AUTO</span><span class="special">(</span> <span class="identifier">iter</span><span class="special">,</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">by</span><span class="special">&lt;</span><span class="identifier">number</span><span class="special">&gt;().</span><span class="identifier">find</span><span class="special">(</span><span class="number">2</span><span class="special">)</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"2: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">iter</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">name</span><span class="special">&gt;();</span>
</pre>


<p>
          <br><a href="../../../../example/bimap_and_boost/typeof.cpp" target="_top">Go to source code 察看源代码</a>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_xpressive"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_xpressive" title="Boost.Xpressive">Boost.Xpressive</a>
</h4></div></div></div>
<p>
          Using Boost.Xpressive we can parse a file and insert the relations in a
          bimap in the same step. It is just amazing the power of four lines of code.
          Here is an example (it is just beatifull)
        </p>

<p>
          使用 Boost.Xpressive，我们可以分析一个文件并同时将其中的关系插入到一个 bimap 中。令人惊讶的是，这只需要四行代码。以下是一个例子(非常漂亮)：</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">bm_type</span><span class="special">;</span>
<span class="identifier">bm_type</span> <span class="identifier">bm</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">rel_str</span><span class="special">(</span><span class="string">"one &lt;--&gt; 1     two &lt;--&gt; 2      three &lt;--&gt; 3"</span><span class="special">);</span>

<span class="identifier">sregex</span> <span class="identifier">rel</span> <span class="special">=</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="string">" &lt;--&gt; "</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s2</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span><span class="special">)</span> <span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">xp</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">bm</span><span class="special">)-&gt;*</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;(</span><span class="identifier">s1</span><span class="special">,</span> <span class="identifier">as</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">s2</span><span class="special">))</span> <span class="special">)</span>
<span class="special">];</span>

<span class="identifier">sregex</span> <span class="identifier">relations</span> <span class="special">=</span> <span class="identifier">rel</span> <span class="special">&gt;&gt;</span> <span class="special">*(+</span><span class="identifier">_s</span> <span class="special">&gt;&gt;</span> <span class="identifier">rel</span><span class="special">);</span>

<span class="identifier">regex_match</span><span class="special">(</span><span class="identifier">rel_str</span><span class="special">,</span> <span class="identifier">relations</span><span class="special">);</span>

<span class="identifier">assert</span><span class="special">(</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">3</span> <span class="special">);</span>
</pre>


<p>
          <a href="../../../../example/bimap_and_boost/xpressive.cpp" target="_top">Go to source code 察看代码</a>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_property_map"></a><a class="link" href="boost_libraries_that_work_well_with_boost_bimap.html#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_property_map" title="Boost.Property_map">Boost.Property_map</a>
</h4></div></div></div>
<p>
          The Boost Property Map Library consists mainly of interface specifications
          in the form of concepts (similar to the iterator concepts in the STL).
          These interface specifications are intended for use by implementers of
          generic libraries in communicating requirements on template parameters
          to their users. In particular, the Boost Property Map concepts define a
          general purpose interface for mapping key objects to corresponding value
          objects, thereby hiding the details of how the mapping is implemented from
          algorithms.</p><p>Boost
Property Map
库主要是以概念(类似于STL中的迭代器概念)的方式包含了一些接口规范。这些接口规范计划用于实现那些以模板参数与其用户进行要求沟通的泛型库。具体地
说，Boost Property Map 的概念为将键对象映射至相应的值对象定义了一个通用的接口，从而对算法隐藏了如何实现映射的细节。
        </p>
<p>
          The need for the property map interface came from the Boost Graph Library
          (BGL), which contains many examples of algorithms that use the property
          map concepts to specify their interface. For an example, note the ColorMap
          template parameter of the breadth_first_search. In addition, the BGL contains
          many examples of concrete types that implement the property map interface.
          The adjacency_list class implements property maps for accessing objects
          (properties) that are attached to vertices and edges of the graph.</p><p>对于属性映射接口的需求来自于 Boost Graph 库(BGL)，该库包含了许多算法例子，它们使用属性映射概念来指定其接口。例如，breadth_first_search 的&nbsp;ColorMap 模板参数。此外，BGL 还包含了多个实现了属性映射接口的具体类型例子。adjacency_list 类实现了一些属性映射，用于访问附属于图的顶点和边的对象(属性)。
        </p>
<p>
          The counterparts of two of the views of Boost.Bimap map, the <code class="computeroutput"><span class="identifier">set</span></code> and <code class="computeroutput"><span class="identifier">unordered_set</span></code>,
          are read-write property maps. In order to use these, you need to include
          one of the following headers:</p><p>Boost.Bimap 映射视图的两个对应物，<code class="computeroutput"><span class="identifier">set</span></code> 和 <code class="computeroutput"><span class="identifier">unordered_set</span></code>，就是可读写的属性映射。为了使用它们，你需要包含以下头文件中的某一个：
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">/</span><span class="identifier">property_map</span><span class="special">/</span><span class="identifier">set_support</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">bimap</span><span class="special">/</span><span class="identifier">property_map</span><span class="special">/</span><span class="identifier">unordered_set_support</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          The following is adapted from the example in the Boost.PropertyMap documentation.</p><p>以下例子是根据 Boost.PropertyMap 文档中的例子改写的。
        </p>


<p>
          <a href="../../../../example/bimap_and_boost/property_map.cpp" target="_top">Go to source
          code 察看源代码</a></p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">AddressMap</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">AddressMap</span> <span class="special">&amp;</span> <span class="identifier">address_map</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">property_traits</span><span class="special">&lt;</span><span class="identifier">AddressMap</span><span class="special">&gt;::</span><span class="identifier">value_type</span> <span class="identifier">value_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">property_traits</span><span class="special">&lt;</span><span class="identifier">AddressMap</span><span class="special">&gt;::</span><span class="identifier">key_type</span> <span class="identifier">key_type</span><span class="special">;</span>

    <span class="identifier">value_type</span> <span class="identifier">address</span><span class="special">;</span>
    <span class="identifier">key_type</span> <span class="identifier">fred</span> <span class="special">=</span> <span class="string">"Fred"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">address_map</span><span class="special">,</span> <span class="identifier">fred</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">bimap</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">multiset_of</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">Name2Address</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Name2Address</span><span class="special">::</span><span class="identifier">value_type</span> <span class="identifier">location</span><span class="special">;</span>

    <span class="identifier">Name2Address</span> <span class="identifier">name2address</span><span class="special">;</span>
    <span class="identifier">name2address</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">location</span><span class="special">(</span><span class="string">"Fred"</span><span class="special">,</span> <span class="string">"710 West 13th Street"</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">name2address</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">location</span><span class="special">(</span> <span class="string">"Joe"</span><span class="special">,</span> <span class="string">"710 West 13th Street"</span><span class="special">)</span> <span class="special">);</span>

    <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">name2address</span><span class="special">.</span><span class="identifier">left</span> <span class="special">);</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2006 -2007 Matias Capeletto<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../bimap_and_boost.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bimap_and_boost.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="dependencies.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
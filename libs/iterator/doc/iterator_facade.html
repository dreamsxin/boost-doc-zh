<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>











  
  
  
  
  
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />











  
  
  
  
  
  
  
  
  
  
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />












  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>Iterator Facade</title>
  <meta name="author" content="David Abrahams, Jeremy Siek, Thomas Witt" />











  
  
  
  
  
  
  
  
  
  
  <meta name="organization" content="Boost Consulting, Indiana University Open Systems Lab, University of Hanover Institute for Transport Railway Operation and Construction" />











  
  
  
  
  
  
  
  
  
  
  <meta name="date" content="2006-09-11" />











  
  
  
  
  
  
  
  
  
  
  <meta name="copyright" content="Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003." />











  
  
  
  
  
  
  
  
  
  
  <link rel="stylesheet" href="../../../rst.css" type="text/css" />
</head>


<body>











<div class="document" id="iterator-facade">
<h1 class="title">迭代器的外观</h1>











<table class="docinfo" frame="void" rules="none">











  <col class="docinfo-name" />
  <col class="docinfo-content" />
  <tbody valign="top">











    <tr>










      <th class="docinfo-name">Author:</th>











      <td>David Abrahams, Jeremy Siek, Thomas Witt</td>










    </tr>











    <tr>










      <th class="docinfo-name">Contact:</th>











      <td><a class="first reference external" href="mailto:dave@boost-consulting.com">dave@boost-consulting.com</a>, <a class="reference external" href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>, <a class="last reference external" href="mailto:witt@ive.uni-hannover.de">witt@ive.uni-hannover.de</a></td>










    </tr>











    <tr>










      <th class="docinfo-name">Organization:</th>











      <td><a class="first reference external" href="http://www.boost-consulting.com">Boost Consulting</a>, Indiana University <a class="reference external" href="http://www.osl.iu.edu">Open Systems
Lab</a>, University of Hanover <a class="last reference external" href="http://www.ive.uni-hannover.de">Institute for Transport
Railway Operation and Construction</a></td>










    </tr>











    <tr>










      <th class="docinfo-name">Date:</th>











      <td>2006-09-11</td>










    </tr>











    <tr>










      <th class="docinfo-name">Copyright:</th>











      <td>Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003.</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">概要：</th>










      <td class="field-body"><!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
      <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 是一个基类模板，依据少量的核心函数和关联类型实现了标准迭代器的接口，用于派生出迭代器类。</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<div class="contents topic" id="table-of-contents">
<p class="topic-title first">目录</p>











<ul class="simple">











  <li><a class="reference internal" href="#overview" id="id23">简介</a>
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><a class="reference internal" href="#usage" id="id24">用法</a></li>











      <li><a class="reference internal" href="#iterator-core-access" id="id25">迭代器的核心访问</a></li>











      <li><a class="reference internal" href="#operator" id="id26"><tt class="docutils literal"><span class="pre">operator[]</span></tt></a></li>











      <li><a class="reference internal" href="#id2" id="id27"><tt class="docutils literal"><span class="pre">operator-&gt;</span></tt></a></li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li><a class="reference internal" href="#reference" id="id28">参考</a>
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><a class="reference internal" href="#iterator-facade-requirements" id="id29"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的要求</a></li>











      <li><a class="reference internal" href="#iterator-facade-operations" id="id30"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的操作符</a></li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li><a class="reference internal" href="#tutorial-example" id="id31">指南和例子</a>
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><a class="reference internal" href="#the-problem" id="id32">问题</a></li>











      <li><a class="reference internal" href="#a-basic-iterator-using-iterator-facade" id="id33">一个使用</a><a class="reference internal" href="iterator_facade.html#a-basic-iterator-using-iterator-facade" id="id33"> <tt class="docutils literal"><span class="pre">iterator_facade</span></tt></a><a class="reference internal" href="#a-basic-iterator-using-iterator-facade" id="id33"> 的基本迭代器<tt class="docutils literal"><span class="pre"></span></tt></a>
        
        
        
        
        
        
        
        
        
        
        <ul>











          <li><a class="reference internal" href="iterator_facade.html#template-arguments-for-iterator-facade" id="id34"> <tt class="docutils literal"><span class="pre">iterator_facade</span></tt></a><a class="reference internal" href="#template-arguments-for-iterator-facade" id="id34"> 的模板参数<tt class="docutils literal"><span class="pre"></span></tt></a>
            
            
            
            
            
            
            
            
            
            
            <ul>











              <li><a class="reference internal" href="#derived" id="id35"><tt class="docutils literal"><span class="pre">Derived</span></tt></a></li>











              <li><a class="reference internal" href="#value" id="id36"><tt class="docutils literal"><span class="pre">Value</span></tt></a></li>











              <li><a class="reference internal" href="#categoryortraversal" id="id37"><tt class="docutils literal"><span class="pre">CategoryOrTraversal</span></tt></a></li>











              <li><a class="reference internal" href="#id12" id="id38"><tt class="docutils literal"><span class="pre">Reference</span></tt></a></li>











              <li><a class="reference internal" href="#difference" id="id39"><tt class="docutils literal"><span class="pre">Difference</span></tt></a></li>











            
            
            
            
            
            
            
            
            
            
            </ul>











          </li>











          <li><a class="reference internal" href="#constructors-and-data-members" id="id40">构造函数和数据成员</a></li>











          <li><a class="reference internal" href="#implementing-the-core-operations" id="id41">实现核心的操作</a></li>











        
        
        
        
        
        
        
        
        
        
        </ul>











      </li>











      <li><a class="reference internal" href="#a-constant-node-iterator" id="id42">常量 <tt class="docutils literal"><span class="pre">node_iterator</span></tt></a></li>











      <li><a class="reference internal" href="#interoperability" id="id43">互操作性</a></li>











      <li><a class="reference internal" href="#telling-the-truth" id="id44">实话实说</a></li>











      <li><a class="reference internal" href="#wrap-up" id="id45">结束语</a></li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











</ul>











</div>











<div class="section" id="overview">
<h1><a class="toc-backref" href="#id23">简介</a></h1>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.1 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG for TR1. -->
<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. -->
<p>迭代器的接口可以非常复杂，不过还是存在一个核心的接口子集，该子集对于所有不同功能的迭代器都是必须的。我们可以为迭代器列出以下核心行为：</p>











<ul class="simple">











  <li>提领</li>











  <li>递增</li>











  <li>递减</li>











  <li>等同性比较</li>











  <li>随机访问动作</li>











  <li>距离计算</li>











</ul>











<p>除了以上列出的行为以外，核心接口元素还应包括一些由迭代器 traits 所声明的关联类型：<tt class="docutils literal"><span class="pre">value_type</span></tt>, <tt class="docutils literal"><span class="pre">reference</span></tt>, <tt class="docutils literal"><span class="pre">difference_type</span></tt>, 和
<tt class="docutils literal"><span class="pre">iterator_category</span></tt>.</p>











<p>迭代器外观使用了 Curiously Recurring Template
Pattern (CRTP) <a class="citation-reference" href="#cop95" id="id1">[Cop95]</a>，这样用户可以在派生类中指定 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的行为。以前的设计使用了策略对象来指定行为，但这种方法由于以下原因而被弃用：</p>











<blockquote>
  
  
  
  
  
  
  
  
  
  
  <ol class="arabic simple">











    <li>策略对象拷贝的创建和销毁会增加开销，而现在的方法可以避免。</li>











    <li>策略对象方法不允许对被创建的迭代器类型定制构造函数，而如果
      <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 要用于其它的库实现，该特性是必须的。</li>











    <li>如果不使用 CRTP, 那么标准所要求的：迭代器的 <tt class="docutils literal"><span class="pre">operator++</span></tt> 要返回迭代器类型本身，将会导致由本库所创建的所有迭代器都必须是<tt class="docutils literal"><span class="pre">iterator_facade&lt;...&gt;</span></tt> 的特化，而不能是象 <tt class="docutils literal"><span class="pre">indirect_iterator&lt;T*&gt;</span></tt> 这样的类型。要创建新的参数化迭代器就必须要使用笨重的类型生成器元函数，而且一个独立的 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 层也是不可能的了。</li>











  
  
  
  
  
  
  
  
  
  
  </ol>











</blockquote>











<div class="section" id="usage">
<h2><a class="toc-backref" href="#id24">用法</a></h2>











<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的用户应从 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的一个特化派生出他的迭代器类，并将该派生的迭代器类作为 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的第一个模板参数。其它模板参数的顺序是经过仔细选择的，以便于使用缺省值。例如，定义一个常量左值迭代器时，用户可以传入将迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的一个const版本作为
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">Value</span></tt> 参数传入，而省略后面的
<tt class="docutils literal"><span class="pre">Reference</span></tt> 参数。</p>











<p>派生的迭代器类必须定义一些成员函数来实现迭代器的核心行为。下表描述了一些依据于迭代器类型而要求必须有效的表达式。这些成员函数会有简单的描述，更为详细的介绍请见"迭代器外观的要求"一节。</p>











<blockquote>
  
  
  
  
  
  
  
  
  
  
  <table class="docutils" border="1">











    <colgroup><col width="44%" /><col width="56%" /></colgroup>
    <thead valign="bottom">
    <tr>










      <th class="head">表达式</th>











      <th class="head">作用</th>











    </tr>











    </thead>
    <tbody valign="top">











      <tr>










        <td><tt class="docutils literal"><span class="pre">i.dereference()</span></tt></td>











        <td>访问所引向的值</td>











      </tr>











      <tr>










        <td><tt class="docutils literal"><span class="pre">i.equal(j)</span></tt></td>











        <td>比较与 <tt class="docutils literal"><span class="pre">j</span></tt> 的等价性<tt class="docutils literal"><span class="pre"></span></tt></td>











      </tr>











      <tr>










        <td><tt class="docutils literal"><span class="pre">i.increment()</span></tt></td>











        <td>前进一个位置</td>











      </tr>











      <tr>










        <td><tt class="docutils literal"><span class="pre">i.decrement()</span></tt></td>











        <td>后退一个位置</td>











      </tr>











      <tr>










        <td><tt class="docutils literal"><span class="pre">i.advance(n)</span></tt></td>











        <td>前进 <tt class="docutils literal"><span class="pre">n</span></tt> 个位置</td>











      </tr>











      <tr>










        <td><tt class="docutils literal"><span class="pre">i.distance_to(j)</span></tt></td>











        <td>计算与 <tt class="docutils literal"><span class="pre">j</span></tt> 的距离<tt class="docutils literal"><span class="pre"></span></tt></td>











      </tr>











    
    
    
    
    
    
    
    
    
    
    </tbody>
  
  
  
  
  
  
  
  
  
  
  </table>











</blockquote>











<!-- Should we add a comment that a zero overhead implementation of iterator_facade
is possible with proper inlining? -->
<p>除了实现以上核心接口函数之外，一个派生自 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的迭代器通常还要定义几个构造函数。为了符合标准的迭代器概念，至少要有一个复制构造函数。此外，如果迭代器类型 <tt class="docutils literal"><span class="pre">X</span></tt> 是与另一个迭代器类型 <tt class="docutils literal"><span class="pre">Y</span></tt> 可以自动互操作的(如常量迭代器和可变迭代器)，那么就必须有一个从 <tt class="docutils literal"><span class="pre">X</span></tt> 到 <tt class="docutils literal"><span class="pre">Y</span></tt> 或者从 <tt class="docutils literal"><span class="pre">Y</span></tt> 以 <tt class="docutils literal"><span class="pre">X</span></tt> 的隐式转换(不必两个都有)，通常的实现方式就是一个转换构造函数。最后，如果迭代器符合前向遍历迭代器或更为强化的迭代器概念，则要求有一个缺省构造函数。</p>











</div>











<div class="section" id="iterator-core-access">
<h2><a class="toc-backref" href="#id25">迭代器的核心访问</a></h2>











<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 及其操作符的实现要能够访问派生类的核心成员函数。而将核心成员函数声明为公有的，又会把实现细节暴露给了用户。这里使用的设计可以确保实现细节不会出现在派生迭代器类型的公有接口中。</p>











<p>防止直接访问核心成员函数有两个好处。首先，用户不可能在要使用 value_type 的成员时无意中用到了迭代器的成员函数。这在以前的智能指针实现中是一个问题。第二个也是主要的好处是，库的实现可以自由地将一个基于 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的迭代器换为手工实现的迭代器，而无需担心破坏了要被直接访问的公有核心成员函数的代码。</p>











<p>在一个简单的实现中，要保持派生类的核心成员函数私有，就要将
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的所有七个操作符声明为友元函数。为了减轻这个负担，我们提供了 <tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 类，它的作用是作为派生迭代器类的核心成员函数的网关。派生类的作者只需将 <tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 声明为友元就可以让程序库使用他的核心成员函数了。</p>











<!-- This is no long uptodate -thw -->
<!-- Yes it is; I made sure of it! -DWA -->
<p><tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 被实现为一个空类，只包含了私有的静态成员函数，这些函数会调用迭代器的核心成员函数。我们不需要对这个网关协议进行标准化。请注意，即使
<tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 使用了公有的成员函数，也不会有安全漏洞，因为每个核心成员函数都保证了迭代器的不变式。</p>











</div>











<div class="section" id="operator">
<h2><a class="toc-backref" href="#id26"><tt class="docutils literal"><span class="pre">operator[]</span></tt></a></h2>











<p>泛型迭代器的索引操作符带来了特殊的挑战。随机访问迭代器的 <tt class="docutils literal"><span class="pre">operator[]</span></tt> 只要求返回某个可以转换为 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的东西。要求它返回一个左值会将某些当前合法的随机访问迭代器排除在外，这些迭代器在它的数据成员中保存了一个被引用值(如 <a class="reference external" href="counting_iterator.html"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt></a>), 由于 <tt class="docutils literal"><span class="pre">*(p+n)</span></tt> 是临时迭代器 <tt class="docutils literal"><span class="pre">p+n</span></tt> 的引用，当
<tt class="docutils literal"><span class="pre">operator[]</span></tt> 返回时就会被销毁。</p>











<p>用&nbsp;<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 创建的可写迭代器实现了在 <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html#299">issue 299</a>&nbsp;的首选方案中和在提议书 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/papers/2003/n1550.html">n1550</a> 中所采用的语义：<tt class="docutils literal"><span class="pre">p[n]</span></tt> 的结果是一个可以转换为迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的对象，且 <tt class="docutils literal"><span class="pre">p[n]</span> <span class="pre">=</span> <span class="pre">x</span></tt> 等同于 <tt class="docutils literal"><span class="pre">*(p</span> <span class="pre">+</span> <span class="pre">n)</span> <span class="pre">=</span> <span class="pre">x</span></tt> (注：该结果对象可以实现为某个包含了 <tt class="docutils literal"><span class="pre">p+n</span></tt> 的一个拷贝的代理)。这个方法对于任意的随机访问迭代器都可以正确工作，不管迭代器的其它实现细节。用户如果知道更多有关他的迭代器的实现细节，也可以实现一个
<tt class="docutils literal"><span class="pre">operator[]</span></tt> 以在派生的迭代器类中返回一个左值；这样可以向迭代器的用户隐藏由 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 所提供的实现。</p>











</div>











<div class="section" id="id2">
<span id="operator-arrow"></span>
<h2><a class="toc-backref" href="#id27"><tt class="docutils literal"><span class="pre">operator-&gt;</span></tt></a></h2>











<p>一个可读迭代器(或者现在的输入迭代器)的 <tt class="docutils literal"><span class="pre">reference</span></tt> 类型并不需要真的是一个引用，只要它可以转换为迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 就行了。但是，如果 <tt class="docutils literal"><span class="pre">value_type</span></tt>
是一个类，那么就还需要可以通过 <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> 访问其成员。因此，一个迭代器如果其 <tt class="docutils literal"><span class="pre">reference</span></tt>
类型不真的是一个引用，那么就必须从它的 <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> 返回一个代理，其中包含被引用值的拷贝。</p>











<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> 和
<tt class="docutils literal"><span class="pre">operator[]</span></tt> 的返回类型并没有明确地指定。这些类型被描述为一组要求，<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的实现必须满足这些要求。</p>











<table class="docutils citation" id="cop95" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label">[Cop95]</td>










      <td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> [Coplien, 1995] Coplien, J., Curiously Recurring Template
Patterns, C++ Report, February 1995, pp. 24-27.</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="reference">
<h1><a class="toc-backref" href="#id28">参考</a></h1>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.3 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG for TR1. -->
<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. -->
<pre class="literal-block">template &lt;<br />    class Derived<br />  , class Value<br />  , class CategoryOrTraversal<br />  , class Reference  = Value&amp;<br />  , class Difference = ptrdiff_t<br />&gt;<br />class iterator_facade {<br /> public:<br />    typedef remove_const&lt;Value&gt;::type value_type;<br />    typedef Reference reference;<br />    typedef Value* pointer;<br />    typedef Difference difference_type;<br />    typedef /* 见 <a class="reference internal" href="#iterator-category">下文</a> */ iterator_category;<br /><br />    reference operator*() const;<br />    /* 见 <a class="reference internal" href="#operator-arrow">下文</a> */ operator-&gt;() const;<br />    /* 见 <a class="reference internal" href="#brackets">下文</a> */ operator[](difference_type n) const;<br />    Derived&amp; operator++();<br />    Derived operator++(int);<br />    Derived&amp; operator--();<br />    Derived operator--(int);<br />    Derived&amp; operator+=(difference_type n);<br />    Derived&amp; operator-=(difference_type n);<br />    Derived operator-(difference_type n) const;<br /> protected:<br />    typedef iterator_facade iterator_facade_;<br />};<br /><br />// 比较操作符<br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type // exposition<br />operator ==(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator !=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />// 迭代器减法<br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />/* 见 <a class="reference internal" href="#minus">下文</a> */<br />operator-(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />          iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />// 迭代器加法<br />template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;,<br />                   typename Derived::difference_type n);<br /><br />template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (typename Derived::difference_type n,<br />                   iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;);<br /></pre>











<p id="iterator-category"> <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 成员为</p>











<pre class="literal-block"><em>iterator-category</em>(CategoryOrTraversal, value_type, reference)<br /></pre>











<p>其中 <em>iterator-category</em> 定义如下：</p>











<pre class="literal-block" id="id7"><em>iterator-category</em>(C,R,V) :=<br />   if (C 可转换为 std::input_iterator_tag<br />       || C 可转换为 std::output_iterator_tag<br />   )<br />       return C<br /><br />   else if (C 不可转换为 incrementable_traversal_tag)<br />       <em>程序有错误</em>

   else return 一个满足以下两个约束条件的类型 X:

      1. X 可转换为 X1, 并且没有更深的派生类，其中 X1 的定义为：

           if (R 为引用类型
               &amp;&amp; C 可转换为 forward_traversal_tag)
           {
               if (C 可转换为 random_access_traversal_tag)
                   X1 = random_access_iterator_tag
               else if (C 可转换为 bidirectional_traversal_tag)
                   X1 = bidirectional_iterator_tag
               else
                   X1 = forward_iterator_tag
           }
           else
           {
               if (C 可转换为 single_pass_traversal_tag
                   &amp;&amp; R 可转换为 V)
                   X1 = input_iterator_tag
               else
                   X1 = C
           }

      2. <a class="reference external" href="new-iter-concepts.html#category-to-traversal"><em>category-to-traversal</em></a>(X) 可转换为也可以由 X 转换的最深派生层次的<br />         traversal tag type, 并且没有更深的派生 traversal tag type.<br /></pre>











<p>[注：目的是允许 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 是五个原有的 category tags 之一，而可转换为
traversal tags 之一并没有增加信息]</p>











<!-- Copyright David Abrahams 2004. Use, modification and distribution is -->
<!-- subject to the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p>上面所用的 <tt class="docutils literal"><span class="pre">enable_if_interoperable</span></tt> 模板是为了暴露不合理的操作符。这些成员操作符只有当派生类型 <tt class="docutils literal"><span class="pre">Dr1</span></tt> 和 <tt class="docutils literal"><span class="pre">Dr2</span></tt> 是可交互的才应提供一组重载，即两个类型中至少有一个可转换为另一个。<tt class="docutils literal"><span class="pre">enable_if_interoperable</span></tt> 方法使用了 SFINAE 来实现当这两个类型不可交互时将这些操作符剔除出重载函数组。这些操作符的行为就象 <tt class="docutils literal"><span class="pre">enable_if_interoperable</span></tt>
的定义如下：</p>











<pre class="literal-block">template &lt;bool, typename&gt; enable_if_interoperable_impl<br />{};<br /><br />template &lt;typename T&gt; enable_if_interoperable_impl&lt;true,T&gt;<br />{ typedef T type; };<br /><br />template&lt;typename Dr1, typename Dr2, typename T&gt;<br />struct enable_if_interoperable<br />  : enable_if_interoperable_impl&lt;<br />        is_convertible&lt;Dr1,Dr2&gt;::value || is_convertible&lt;Dr2,Dr1&gt;::value<br />      , T<br />    &gt;<br />{};<br /></pre>











<div class="section" id="iterator-facade-requirements">
<h2><a class="toc-backref" href="#id29"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的要求</a></h2>











<p>下表描述了对于
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">Derived</span></tt> 参数的有效表达式，依赖于所属的迭代器概念。第一列中的操作必须可以被类
<tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 的成员函数访问。此外，<tt class="docutils literal"><span class="pre">static_cast&lt;Derived*&gt;(iterator_facade*)</span></tt> 应该是合法的。</p>











<p>在下表中，<tt class="docutils literal"><span class="pre">F</span></tt> 为 <tt class="docutils literal"><span class="pre">iterator_facade&lt;X,V,C,R,D&gt;，</span></tt><tt class="docutils literal"><span class="pre">a</span></tt> 是类型 <tt class="docutils literal"><span class="pre">X</span></tt> 的一个对象，<tt class="docutils literal"><span class="pre">b</span></tt> 和 <tt class="docutils literal"><span class="pre">c</span></tt> 是类型 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">X</span></tt> 的对象，<tt class="docutils literal"><span class="pre">n</span></tt> 是类型 <tt class="docutils literal"><span class="pre">F::difference_type</span></tt> 的对象，<tt class="docutils literal"><span class="pre">y</span></tt> 是一个与 <tt class="docutils literal"><span class="pre">X</span></tt> 可交互的单遍迭代器类型的常量对象，而 <tt class="docutils literal"><span class="pre">z</span></tt>
是一个与 <tt class="docutils literal"><span class="pre">X</span></tt> 可交互的随机访问遍历迭代器的常量对象。</p>











<div class="topic" id="core-operations">
<p class="topic-title first"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 核心操作</p>











<table class="docutils" border="1">











  <colgroup><col width="21%" /><col width="23%" /><col width="27%" /><col width="29%" /></colgroup>
  <thead valign="bottom">
  <tr>










    <th class="head">表达式</th>











    <th class="head">返回类型</th>











    <th class="head">断言/备注</th>











    <th class="head">用于实现哪些迭代器概念</th>











  </tr>











  </thead>
  <tbody valign="top">











    <tr>










      <td><tt class="docutils literal"><span class="pre">c.dereference()</span></tt></td>











      <td><tt class="docutils literal"><span class="pre">F::reference</span></tt></td>











      <td>&nbsp;</td>











      <td>可读迭代器，可写迭代器</td>











    </tr>











    <tr>










      <td><tt class="docutils literal"><span class="pre">c.equal(y)</span></tt></td>











      <td>可转换为 bool</td>











      <td>true 当且仅当 <tt class="docutils literal"><span class="pre">c</span></tt> 和 <tt class="docutils literal"><span class="pre">y</span></tt>
引向同一个位置</td>











      <td>单遍迭代器</td>











    </tr>











    <tr>










      <td><tt class="docutils literal"><span class="pre">a.increment()</span></tt></td>











      <td>未使用</td>











      <td>&nbsp;</td>











      <td>可递增迭代器</td>











    </tr>











    <tr>










      <td><tt class="docutils literal"><span class="pre">a.decrement()</span></tt></td>











      <td>未使用</td>











      <td>&nbsp;</td>











      <td>双向遍历迭代器</td>











    </tr>











    <tr>










      <td><tt class="docutils literal"><span class="pre">a.advance(n)</span></tt></td>











      <td>未使用</td>











      <td>&nbsp;</td>











      <td>随机访问遍历迭代器</td>











    </tr>











    <tr>










      <td><tt class="docutils literal"><span class="pre">c.distance_to(z)</span></tt></td>











      <td>可转换为 <tt class="docutils literal"><span class="pre">F::difference_type</span></tt></td>











      <td>等同于 <tt class="docutils literal"><span class="pre">distance(c,</span> <span class="pre">X(z))</span></tt>.</td>











      <td>随机访问遍历迭代器</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="iterator-facade-operations">
<h2><a class="toc-backref" href="#id30"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的操作</a></h2>











<p>本节所介绍的各个操作是作为 <tt class="docutils literal"><span class="pre">Derived</span></tt>&nbsp;核心接口的操作符，它们可能是不可访问的(即私有接口)。实现中应该通过类 <tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 的成员函数来访问这些操作符。</p>











<p><tt class="docutils literal"><span class="pre">reference</span> <span class="pre">operator*()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">static_cast&lt;Derived</span> <span class="pre">const*&gt;(this)-&gt;dereference()</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">operator-&gt;()</span> <span class="pre">const;</span></tt> (见 <a class="reference internal" href="#operator-arrow">下文</a>)</p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name"><span style="font-family: monospace;">返回：</span></th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">reference</span></tt> 是一个引用类型，则返回一个类型为 <tt class="docutils literal"><span class="pre">pointer</span></tt> 的对象，等同于：</p>











      
      
      
      
      
      
      
      
      
      
      <pre class="literal-block">&amp;static_cast&lt;Derived const*&gt;(this)-&gt;dereference()<br /></pre>











      
      
      
      
      
      
      
      
      
      
      <p class="last">否则返回一个不确定类型的对象，以满足 <tt class="docutils literal"><span class="pre">(*static_cast&lt;Derived</span> <span class="pre">const*&gt;(this))-&gt;m</span></tt> 等价于 <tt class="docutils literal"><span class="pre">(w</span> <span class="pre">=</span> <span class="pre">**static_cast&lt;Derived</span> <span class="pre">const*&gt;(this),</span>
      <span class="pre">w.m)</span></tt> 其中 <tt class="docutils literal"><span class="pre">w</span></tt> 是类型 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的某个临时对象。</p>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p id="brackets"><em>unspecified</em> <tt class="docutils literal"><span class="pre">operator[](difference_type</span> <span class="pre">n)</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个可转换为 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的对象。对于类型<tt class="docutils literal"><span class="pre"></span></tt> <tt class="docutils literal"><span class="pre">value_type</span></tt> 的常量对象 <tt class="docutils literal"><span class="pre">v</span></tt><tt class="docutils literal"><span class="pre"></span></tt>, 以及类型
      <tt class="docutils literal"><span class="pre">difference_type</span></tt> 的对象 <tt class="docutils literal"><span class="pre">n</span></tt><tt class="docutils literal"><span class="pre"></span></tt>, <tt class="docutils literal"><span class="pre">(*this)[n]</span> <span class="pre">=</span> <span class="pre">v</span></tt> 等价于
      <tt class="docutils literal"><span class="pre">*(*this</span> <span class="pre">+</span> <span class="pre">n)</span> <span class="pre">=</span> <span class="pre">v</span></tt>, 且 <tt class="docutils literal"><span class="pre">static_cast&lt;value_type</span>
      <span class="pre">const&amp;&gt;((*this)[n])</span></tt> 等价于
      <tt class="docutils literal"><span class="pre">static_cast&lt;value_type</span> <span class="pre">const&amp;&gt;(*(*this</span> <span class="pre">+</span> <span class="pre">n))</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;increment();<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived</span> <span class="pre">operator++(int);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />++*this;<br />return tmp;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator--();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;decrement();<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived</span> <span class="pre">operator--(int);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />--*this;<br />return tmp;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator+=(difference_type</span> <span class="pre">n);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;advance(n);<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator-=(difference_type</span> <span class="pre">n);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;advance(-n);<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived</span> <span class="pre">operator-(difference_type</span> <span class="pre">n)</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />return tmp -= n;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;,<br />                   typename Derived::difference_type n);<br /><br />template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (typename Derived::difference_type n,<br />                   iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />return tmp += n;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator ==(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).equal((Dr2</span> <span class="pre">const&amp;)rhs)</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).equal((Dr1</span> <span class="pre">const&amp;)lhs)</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator !=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">!((Dr1</span> <span class="pre">const&amp;)lhs).equal((Dr2</span> <span class="pre">const&amp;)rhs)</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">!((Dr2</span> <span class="pre">const&amp;)rhs).equal((Dr1</span> <span class="pre">const&amp;)lhs)</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block" id="minus">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,difference&gt;::type<br />operator -(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回类型：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <blockquote>
        
        
        
        
        
        
        
        
        
        
        <dl class="docutils">











          <dt>则</dt>











          <dd>
            
            
            
            
            
            
            
            
            
            
            <p class="first last"><tt class="docutils literal"><span class="pre">difference</span></tt> shall be
            <tt class="docutils literal"><span class="pre">iterator_traits&lt;Dr1&gt;::difference_type</span></tt>.</p>











          </dd>











          <dt>否则</dt>











          <dd>
            
            
            
            
            
            
            
            
            
            
            <p class="first last"><tt class="docutils literal"><span class="pre">difference</span></tt> shall be <tt class="docutils literal"><span class="pre">iterator_traits&lt;Dr2&gt;::difference_type</span></tt></p>











          </dd>











        
        
        
        
        
        
        
        
        
        
        </dl>











      </blockquote>











      </td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">-((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="tutorial-example">
<h1><a class="toc-backref" href="#id31">指南和例子</a></h1>











<!-- Copyright David Abrahams 2004. Use, modification and distribution is -->
<!-- subject to the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p>在本节中我们来浏览一下几个用 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 实现的迭代器，它们用于一个多态对象链表的简单例子。这个例子来自于 Keith Macdonald 在 <a class="reference external" href="../../../more/mailing_lists.htm#users">Boost-Users</a> 邮件列表上的 <a class="reference external" href="http://thread.gmane.org/gmane.comp.lib.boost.user/5100">posting</a>&nbsp;.</p>











<div class="section" id="the-problem">
<h2><a class="toc-backref" href="#id32">问题</a></h2>











<p>假设我们已经写了一个多态链表的节点基类：</p>











<pre class="literal-block"># include &lt;iostream&gt;<br /><br />struct node_base<br />{<br />    node_base() : m_next(0) {}<br /><br />    // 每个节点负责管理它后面的所有节点<br />    virtual ~node_base() { delete m_next; }<br /><br />    // 访问后面的链表<br />    node_base* next() const { return m_next; }<br /><br />    // 打印输出到流<br />    virtual void print(std::ostream&amp; s) const = 0;<br /><br />    // 对值进行加倍<br />    virtual void double_me() = 0;<br /><br />    void append(node_base* p)<br />    {<br />        if (m_next)<br />            m_next-&gt;append(p);<br />        else<br />            m_next = p;<br />    }<br /><br /> private:<br />    node_base* m_next;<br />};<br /></pre>











<p>这个链表可以保存不同类型的对象，通过把以下模板的特化类型链接到一起：</p>











<pre class="literal-block">template &lt;class T&gt;<br />struct node : node_base<br />{<br />    node(T x)<br />      : m_value(x)<br />    {}<br /><br />    void print(std::ostream&amp; s) const { s &lt;&lt; this-&gt;m_value; }<br />    void double_me() { m_value += m_value; }<br /><br /> private:<br />    T m_value;<br />};<br /></pre>











<p>我们还可以用以下流操作符打印任意一个节点：</p>











<pre class="literal-block">inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, node_base const&amp; n)<br />{<br />    n.print(s);<br />    return s;<br />}<br /></pre>











<p>我们的第一个挑战是，构建一个可用于此链表的合适的迭代器。</p>











</div>











<div class="section" id="a-basic-iterator-using-iterator-facade">
<h2><a class="toc-backref" href="#id33">一个使用 <tt class="docutils literal"><span class="pre">iterator_facade </span></tt>基本迭代器<tt class="docutils literal"><span class="pre"></span></tt></a></h2>











<p>我们将通过从
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 派生，来构造一个 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 类，以实现这个迭代器的多数操作符。</p>











<pre class="literal-block"># include "node.hpp"<br /># include &lt;boost/iterator/iterator_facade.hpp&gt;<br /><br />class node_iterator<br />  : public boost::iterator_facade&lt;...&gt;<br />{<br />   ...<br />};<br /></pre>











<div class="section" id="template-arguments-for-iterator-facade">
<h3><a class="toc-backref" href="#id34"><tt class="docutils literal"><span class="pre">iterator_facade 的模板参数</span></tt></a></h3>











<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 有几个模板参数，所以我们必须决定对这些参数使用什么样的类型。这些参数分别是 <tt class="docutils literal"><span class="pre">Derived</span></tt>,
<tt class="docutils literal"><span class="pre">Value</span></tt>, <tt class="docutils literal"><span class="pre">CategoryOrTraversal</span></tt>, <tt class="docutils literal"><span class="pre">Reference</span></tt>, 和 <tt class="docutils literal"><span class="pre">Difference</span></tt>.</p>











<div class="section" id="derived">
<h4><a class="toc-backref" href="#id35"><tt class="docutils literal"><span class="pre">Derived</span></tt></a></h4>











<p>由于 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 使用了 CRTP
<a class="citation-reference" href="#cop95" id="id10">[Cop95]</a>，所以第一个参数就是这个迭代器类名字本身，<tt class="docutils literal"><span class="pre">node_iterator</span></tt>.</p>











</div>











<div class="section" id="value">
<h4><a class="toc-backref" href="#id36"><tt class="docutils literal"><span class="pre">Value</span></tt></a></h4>











<p><tt class="docutils literal"><span class="pre">Value</span></tt> 参数决定了 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 的
<tt class="docutils literal"><span class="pre">value_type</span></tt>.  在这个例子中，我们要迭代 <tt class="docutils literal"><span class="pre">node_base</span></tt>
对象，所以 <tt class="docutils literal"><span class="pre">Value</span></tt> 应为 <tt class="docutils literal"><span class="pre">node_base</span></tt>.</p>











</div>











<div class="section" id="categoryortraversal">
<h4><a class="toc-backref" href="#id37"><tt class="docutils literal"><span class="pre">CategoryOrTraversal</span></tt></a></h4>











<p>现在我们要决定我们的
<tt class="docutils literal"><span class="pre">node_iterator</span></tt> 应满足哪一个 <a class="reference external" href="new-iter-concepts.html#iterator-traversal-concepts-lib-iterator-traversal">迭代器遍历概念</a><tt class="docutils literal"><span class="pre"></span></tt> 了。单向链表只有前向链接，所以我们的迭代器不可能是 <a class="reference external" href="new-iter-concepts.html#bidirectional-traversal-iterators-lib-bidirectional-traversal-iterators">双向遍历迭代器</a>。我们的迭代器应该可以多次遍历同一个链表(不应该象
<tt class="docutils literal"><span class="pre">istream_iterator</span></tt> 那样消耗掉它所遍历的流)，因此它肯定是 <a class="reference external" href="new-iter-concepts.html#forward-traversal-iterators-lib-forward-traversal-iterators">前向遍历迭代器</a>。所以我们在这个参数位置上传入
<tt class="docutils literal"><span class="pre">boost::forward_traversal_tag</span></tt>&nbsp;<a class="footnote-reference" href="#category" id="id11"><sup>1</sup></a>.</p>











<table class="docutils footnote" id="category" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label"><a class="fn-backref" href="#id11">[1]</a></td>










      <td><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 也支持旧式的迭代器类别标志，所以我们也可以在这里传入 <tt class="docutils literal"><span class="pre">std::forward_iterator_tag</span></tt>;
这样，所得到的迭代器的 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 将是 <tt class="docutils literal"><span class="pre">std::forward_iterator_tag</span></tt>.</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











<div class="section" id="id12">
<h4><a class="toc-backref" href="#id38"><tt class="docutils literal"><span class="pre">Reference</span></tt></a></h4>











<p><tt class="docutils literal"><span class="pre">Reference</span></tt> 参数是
<tt class="docutils literal"><span class="pre">node_iterator</span></tt> 的提领操作符所返回的类型，并且应与 <tt class="docutils literal"><span class="pre">std::iterator_traits&lt;node_iterator&gt;::reference</span></tt> 一致。在本库中的缺省值是 <tt class="docutils literal"><span class="pre">Value&amp;</span></tt>; 由于
<tt class="docutils literal"><span class="pre">node_base&amp;</span></tt> 是这个迭代器的 <tt class="docutils literal"><span class="pre">reference</span></tt>
类型的一个不错的选择，所以我们可以省略这个参数，或者传入 <tt class="docutils literal"><span class="pre">use_default</span></tt>.</p>











</div>











<div class="section" id="difference">
<h4><a class="toc-backref" href="#id39"><tt class="docutils literal"><span class="pre">Difference</span></tt></a></h4>











<p><tt class="docutils literal"><span class="pre">Difference</span></tt> 参数决定了如果计算两个 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 间的距离，并且应与 <tt class="docutils literal"><span class="pre">std::iterator_traits&lt;node_iterator&gt;::difference_type</span></tt> 一致。在本库中 <tt class="docutils literal"><span class="pre">Difference</span></tt> 的缺省值是<tt class="docutils literal"><span class="pre"></span></tt> <tt class="docutils literal"><span class="pre">std::ptrdiff_t</span></tt>, 这个类型适合于计算内存中任意两个地址间的距离，这几乎适用于任意迭代器，所以我们也可以省略这个参数。</p>











<p>这样，<tt class="docutils literal"><span class="pre">node_iterator</span></tt> 的声明应该如下：</p>











<pre class="literal-block"># include "node.hpp"<br /># include &lt;boost/iterator/iterator_facade.hpp&gt;<br /><br />class node_iterator<br />  : public boost::iterator_facade&lt;<br />        node_iterator<br />      , node_base<br />      , boost::forward_traversal_tag<br />    &gt;<br />{<br />   ...<br />};<br /></pre>











</div>











</div>











<div class="section" id="constructors-and-data-members">
<h3><a class="toc-backref" href="#id40">构造函数和数据成员</a></h3>











<p>接下来我们要决定如何表示迭代器的位置。表示的方法应该采用数据成员的方式，这样我们还要写一个构造函数来初始化它们。<tt class="docutils literal"><span class="pre">node_iterator</span></tt> 的位置很自然地应该用一个 <tt class="docutils literal"><span class="pre">node_base</span></tt> 的指针来表示。我们需要一个构造函数，由 <tt class="docutils literal"><span class="pre">node_base*</span></tt> 构造一个迭代器，还要一个缺省构造函数以满足 <a class="reference external" href="new-iter-concepts.html#forward-traversal-iterators-lib-forward-traversal-iterators">前向遍历迭代器</a> 的要求<a class="footnote-reference" href="#default" id="id13"><sup>2</sup></a>。所以我们的 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 就变成了：</p>











<pre class="literal-block"># include "node.hpp"<br /># include &lt;boost/iterator/iterator_facade.hpp&gt;<br /><br />class node_iterator<br />  : public boost::iterator_facade&lt;<br />        node_iterator<br />      , node_base<br />      , boost::forward_traversal_tag<br />    &gt;<br />{<br /> public:<br />    node_iterator()<br />      : m_node(0)<br />    {}<br /><br />    explicit node_iterator(node_base* p)<br />      : m_node(p)<br />    {}<br /><br /> private:<br />    ...<br />    node_base* m_node;<br />};<br /></pre>











<table class="docutils footnote" id="default" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label"><a class="fn-backref" href="#id13">[2]</a></td>










      <td>技术上，C++ 标准几乎不需要一个缺省构造的迭代器，所以如果我们非常关心效率的话，也可以编写一个不初始化 <tt class="docutils literal"><span class="pre">m_node</span></tt> 的缺省构造函数。</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











<div class="section" id="implementing-the-core-operations">
<h3><a class="toc-backref" href="#id41">实现核心的操作</a></h3>











<p>最后一步就是实现我们的迭代器想要满足的概念所要求的 <a class="reference internal" href="#core-operations">核心操作</a>。根据这个
<a class="reference internal" href="#core-operations">表格</a>，我们可以看到应该实现前三行的操作，因为 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 需要满足 <a class="reference external" href="new-iter-concepts.html#readable-iterators-lib-readable-iterators">可读迭代器</a>，<a class="reference external" href="new-iter-concepts.html#single-pass-iterators-lib-single-pass-iterators">单遍迭代器</a>，和 <a class="reference external" href="new-iter-concepts.html#incrementable-iterators-lib-incrementable-iterators">可递增迭代器</a> 的要求。</p>











<p>因此我们需要提供 <tt class="docutils literal"><span class="pre">dereference</span></tt>,
<tt class="docutils literal"><span class="pre">equal</span></tt>, 和 <tt class="docutils literal"><span class="pre">increment</span></tt> 三个成员函数。我们不想让这些成员函数成为 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 的公有接口，所以我们将它们声明为私有的，并且授权
<tt class="docutils literal"><span class="pre">boost::iterator_core_access</span></tt> 为友元，这样
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 就有了一个"后门"来访问这些核心操作了：</p>











<pre class="literal-block"># include "node.hpp"<br /># include &lt;boost/iterator/iterator_facade.hpp&gt;<br /><br />class node_iterator<br />  : public boost::iterator_facade&lt;<br />        node_iterator<br />      , node_base<br />      , boost::forward_traversal_tag<br />    &gt;<br />{<br /> public:<br />    node_iterator()<br />      : m_node(0) {}<br /><br />    explicit node_iterator(node_base* p)<br />      : m_node(p) {}<br /><br /> private:<br />    friend class boost::iterator_core_access;<br /><br />    void increment() { m_node = m_node-&gt;next(); }<br /><br />    bool equal(node_iterator const&amp; other) const<br />    {<br />        return this-&gt;m_node == other.m_node;<br />    }<br /><br />    node_base&amp; dereference() const { return *m_node; }<br /><br />    node_base* m_node;<br />};<br /></pre>











<p>喔，一个完整且漂亮的可读、前向遍历的迭代器！关于如何使用它的一个例子，请见 <a class="reference external" href="../example/node_iterator1.cpp">这个程序</a>。</p>











</div>











</div>











<div class="section" id="a-constant-node-iterator">
<h2><a class="toc-backref" href="#id42">常量 <tt class="docutils literal"><span class="pre">node_iterator</span></tt></a></h2>











<div class="sidebar">
<p class="first sidebar-title">常量与非常量迭代器</p>











<p>术语 <strong>mutable iterator非常量迭代器</strong> 是指该迭代器所引向的对象(它的 "指示物")可以改变。而
<strong>constant iterator常量迭代器</strong> 则是指不允许改变它的指示物。</p>











<p>单词 <em>constant</em> 和 <em>mutable</em> 并不是指迭代器本身能否改变。例如，一个 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">const*</span></tt> 是一个非-<tt class="docutils literal"><span class="pre">const</span></tt> 的 <em>常量迭代器</em>，它可以被递增但不允许改变其指示物，而 <tt class="docutils literal"><span class="pre">int*</span>
<span class="pre">const</span></tt> 岀是一个 <tt class="docutils literal"><span class="pre">const</span></tt> 的 <em>非常量迭代器</em>，它不能被改变但可以修改其指示物。</p>











<p class="last">觉得混乱吗？我们也有同感，但这是标准的术语。它可能对于将容器的常量迭代器称为 <tt class="docutils literal"><span class="pre">const_iterator</span></tt> 没有多大的帮助。</p>











</div>











<p>现在，我们的 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 可以让用户既访问 <tt class="docutils literal"><span class="pre">node</span></tt> 的 <tt class="docutils literal"><span class="pre">print(std::ostream&amp;)</span> <span class="pre">const</span></tt> 成员函数，也可以访问非常量的 <tt class="docutils literal"><span class="pre">double_me()</span></tt> 成员函数。如果我们想构建一个 <em>常量的</em> <tt class="docutils literal"><span class="pre">node_iterator</span></tt>, 我们只需要做三处修改：</p>











<pre class="literal-block">class const_node_iterator<br />  : public boost::iterator_facade&lt;<br />        const_node_iterator<br />      , node_base <strong>const</strong>
      , boost::forward_traversal_tag
    &gt;
{
 public:
    const_node_iterator()
      : m_node(0) {}

    explicit const_node_iterator(node_base* p)
      : m_node(p) {}

 private:
    friend class boost::iterator_core_access;

    void increment() { m_node = m_node-&gt;next(); }

    bool equal(const_node_iterator const&amp; other) const
    {
        return this-&gt;m_node == other.m_node;
    }

    node_base <strong>const</strong>&amp; dereference() const { return *m_node; }<br /><br />    node_base <strong>const</strong>* m_node;<br />};<br /></pre>











<div class="sidebar">
<p class="first sidebar-title"><tt class="docutils literal"><span class="pre">const</span></tt> 与迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt></p>











<p class="last">C++ 标准要求一个迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> <em>不能</em> 是
<tt class="docutils literal"><span class="pre">const</span></tt>-限定的，所以 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 在生成迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 时会剥去其<tt class="docutils literal"><span class="pre"></span></tt> <tt class="docutils literal"><span class="pre">Value</span></tt> 参数的
<tt class="docutils literal"><span class="pre">const</span></tt>.  使 <tt class="docutils literal"><span class="pre">Value</span></tt> 参数为
<tt class="docutils literal"><span class="pre">const</span></tt> 可以提示 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 该迭代器是一个 <em>常量迭代器</em>，并且缺省的 <tt class="docutils literal"><span class="pre">Reference</span></tt>
参数对于所有左值迭代器也是正确的。</p>











</div>











<p>事实上，<tt class="docutils literal"><span class="pre">node_iterator</span></tt> 和 <tt class="docutils literal"><span class="pre">const_node_iterator</span></tt>
是如此的相似，应该将它们的共同代码取出来放入到如下的模板中：</p>











<pre class="literal-block">template &lt;class Value&gt;<br />class node_iter<br />  : public boost::iterator_facade&lt;<br />        node_iter&lt;Value&gt;<br />      , Value<br />      , boost::forward_traversal_tag<br />    &gt;<br />{<br /> public:<br />    node_iter()<br />      : m_node(0) {}<br /><br />    explicit node_iter(Value* p)<br />      : m_node(p) {}<br /><br /> private:<br />    friend class boost::iterator_core_access;<br /><br />    bool equal(node_iter&lt;Value&gt; const&amp; other) const<br />    {<br />        return this-&gt;m_node == other.m_node;<br />    }<br /><br />    void increment()<br />    { m_node = m_node-&gt;next(); }<br /><br />    Value&amp; dereference() const<br />    { return *m_node; }<br /><br />    Value* m_node;<br />};<br />typedef node_iter&lt;node_base&gt; node_iterator;<br />typedef node_iter&lt;node_base const&gt; node_const_iterator;<br /></pre>











</div>











<div class="section" id="interoperability">
<h2><a class="toc-backref" href="#id43">互操作性</a></h2>











<p>我们的 <tt class="docutils literal"><span class="pre">const_node_iterator</span></tt> 自己可以很好地工作，但如果要和 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 一起使用，就有点不太满足要求了。例如，我们希望可以将一个
<tt class="docutils literal"><span class="pre">node_iterator</span></tt> 传给需要 <tt class="docutils literal"><span class="pre">node_const_iterator</span></tt> 的地方，正如你可以对 <tt class="docutils literal"><span class="pre">std::list&lt;int&gt;</span></tt> 的 <tt class="docutils literal"><span class="pre">iterator</span></tt> 和
<tt class="docutils literal"><span class="pre">const_iterator</span></tt> 这样做一样。而且，如果给定同一个链表的 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 和
<tt class="docutils literal"><span class="pre">node_const_iterator</span></tt>, 我们还希望可以比较它们的相等性。</p>











<p>这种同时使用两个不同的迭代器类型的能力称为 <a class="reference external" href="new-iter-concepts.html#interoperable-iterators-lib-interoperable-iterators"><strong>interoperability互操作性</strong></a>。在我们的例子中实现互操作性非常简单，只要将 <tt class="docutils literal"><span class="pre">equal</span></tt> 函数模板化，并且增加一个模板转换构造函数<a class="footnote-reference" href="#broken" id="id16"><sup>3</sup></a><a class="footnote-reference" href="#random" id="id17"><sup>4</sup></a>就可以了：</p>











<pre class="literal-block">template &lt;class Value&gt;<br />class node_iter<br />  : public boost::iterator_facade&lt;<br />        node_iter&lt;Value&gt;<br />      , Value<br />      , boost::forward_traversal_tag<br />    &gt;<br />{<br /> public:<br />    node_iter()<br />      : m_node(0) {}<br /><br />    explicit node_iter(Value* p)<br />      : m_node(p) {}<br /><br />    template &lt;class OtherValue&gt;<br />    node_iter(node_iter&lt;OtherValue&gt; const&amp; other)<br />      : m_node(other.m_node) {}<br /><br /> private:<br />    friend class boost::iterator_core_access;<br />    template &lt;class&gt; friend class node_iter;<br /><br />    template &lt;class OtherValue&gt;<br />    bool equal(node_iter&lt;OtherValue&gt; const&amp; other) const<br />    {<br />        return this-&gt;m_node == other.m_node;<br />    }<br /><br />    void increment()<br />    { m_node = m_node-&gt;next(); }<br /><br />    Value&amp; dereference() const<br />    { return *m_node; }<br /><br />    Value* m_node;<br />};<br />typedef impl::node_iterator&lt;node_base&gt; node_iterator;<br />typedef impl::node_iterator&lt;node_base const&gt; node_const_iterator;<br /></pre>











<table class="docutils footnote" id="broken" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label"><a class="fn-backref" href="#id16">[3]</a></td>










      <td>如果你用的是一个较老的编译器，不能编译这个例子，那么请看 <a class="reference external" href="../example/node_iterator2.hpp">例子代码</a> 中如何解决。</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<table class="docutils footnote" id="random" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label"><a class="fn-backref" href="#id17">[4]</a></td>










      <td>如果 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 是一个 <a class="reference external" href="new-iter-concepts.html#random-access-traversal-iterators-lib-random-access-traversal-iterators">随机访问遍历迭代器</a>，我们还要模板化它的 <tt class="docutils literal"><span class="pre">distance_to</span></tt> 函数。</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p>你在 <a class="reference external" href="../example/node_iterator2.cpp">这里</a> 可以看到一个如何测试我们的可交互迭代器的例子。<a class="reference external" href="../example/node_iterator2.cpp"></a></p>











</div>











<div class="section" id="telling-the-truth">
<h2><a class="toc-backref" href="#id44">实话实说</a></h2>











<p>现在 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 和 <tt class="docutils literal"><span class="pre">node_const_iterator</span></tt> 都完全按照你的意愿来工作了... 几乎如此。我们可以比较它们，也可以从一个方向进行转换：从 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 到 <tt class="docutils literal"><span class="pre">node_const_iterator</span></tt>.
如果我们试着从 <tt class="docutils literal"><span class="pre">node_const_iterator</span></tt> 转换为
<tt class="docutils literal"><span class="pre">node_iterator</span></tt>, 我们会得到一个错误，因为转换构造函数试图用一个 <tt class="docutils literal"><span class="pre">node</span> <span class="pre">const*</span></tt> 初始化 <tt class="docutils literal"><span class="pre">node_iterator</span></tt> 的 <tt class="docutils literal"><span class="pre">m_node</span></tt>, 一个
<tt class="docutils literal"><span class="pre">node*</span></tt>&nbsp;.  这有什么问题呢？</p>











<p>问题是，<tt class="docutils literal"><span class="pre">boost::</span></tt><a class="reference external" href="../../type_traits/index.html#relationships"><tt class="docutils literal"><span class="pre">is_convertible</span></tt></a><tt class="docutils literal"><span class="pre">&lt;node_const_iterator,node_iterator&gt;::value</span></tt>
会为 <tt class="docutils literal"><span class="pre">true</span></tt>, 但它应该是 <tt class="docutils literal"><span class="pre">false</span></tt>.  <a class="reference external" href="../../type_traits/index.html#relationships"><tt class="docutils literal"><span class="pre">is_convertible</span></tt></a>
说谎了，因为它只看到了
<tt class="docutils literal"><span class="pre">node_iter</span></tt> 的转换构造函数的 <em>声明</em>，而看不到内部的 <em>定义</em> 以确认它可以编译。完美的解决方案是，当 <tt class="docutils literal"><span class="pre">m_node</span></tt> 的转换失败时，让 <tt class="docutils literal"><span class="pre">node_iter</span></tt> 的转换构造函数消失。<tt class="docutils literal"><span class="pre"></span></tt></p>











<p>实际上，这种魔术可以用
<a class="reference external" href="../../utility/enable_if.html"><tt class="docutils literal"><span class="pre">boost::enable_if</span></tt></a> 来实现。按以下方式重写转换构造函数，我们就可以在转换构造函数不适用的时候从重载函数组中将它去掉。</p>











<pre class="literal-block">#include &lt;boost/type_traits/is_convertible.hpp&gt;<br />#include &lt;boost/utility/enable_if.hpp&gt;<br /><br />  ...<br /><br />private:<br />  struct enabler {};<br /><br />public:<br />  template &lt;class OtherValue&gt;<br />  node_iter(<br />      node_iter&lt;OtherValue&gt; const&amp; other<br />    , typename boost::enable_if&lt;<br />          boost::is_convertible&lt;OtherValue*,Value*&gt;<br />        , enabler<br />      &gt;::type = enabler()<br />  )<br />    : m_node(other.m_node) {}<br /></pre>











</div>











<div class="section" id="wrap-up">
<h2><a class="toc-backref" href="#id45">结束语</a></h2>











<p>我们的 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 指南到此为止，不过在你结束阅读之前，我们强烈建议你看一看 <a class="reference external" href="iterator_adaptor.html"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt></a>.
那里有另一种方法编写更为高级的迭代器。</p>











</div>











</div>











</div>











<div class="footer">
<hr class="footer" />
<a class="reference external" href="iterator_facade.rst">View document source</a>.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>











</body>
</html>

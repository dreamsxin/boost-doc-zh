<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>











  
  
  
  
  
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />











  
  
  
  
  
  
  
  
  
  
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />












  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>Iterator Facade and Adaptor</title>
  <meta name="author" content="David Abrahams, Jeremy Siek, Thomas Witt" />











  
  
  
  
  
  
  
  
  
  
  <meta name="organization" content="Boost Consulting, Indiana University Open Systems Lab, Zephyr Associates, Inc." />











  
  
  
  
  
  
  
  
  
  
  <meta name="date" content="2006-09-11" />











  
  
  
  
  
  
  
  
  
  
  <link rel="stylesheet" href="../../../rst.css" type="text/css" />
</head>


<body>











<div class="document" id="iterator-facade-and-adaptor">
<h1 class="title">迭代器的外观和适配器</h1>











<table class="docinfo" frame="void" rules="none">











  <col class="docinfo-name" />
  <col class="docinfo-content" />
  <tbody valign="top">











    <tr>










      <th class="docinfo-name">Author:</th>











      <td>David Abrahams, Jeremy Siek, Thomas Witt</td>










    </tr>











    <tr>










      <th class="docinfo-name">Contact:</th>











      <td><a class="first reference external" href="mailto:dave@boost-consulting.com">dave@boost-consulting.com</a>, <a class="reference external" href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>, <a class="last reference external" href="mailto:witt@styleadvisor.com">witt@styleadvisor.com</a></td>










    </tr>











    <tr>










      <th class="docinfo-name">Organization:</th>











      <td><a class="first reference external" href="http://www.boost-consulting.com">Boost Consulting</a>, Indiana University <a class="reference external" href="http://www.osl.iu.edu">Open Systems
Lab</a>, <a class="last reference external" href="http://www.styleadvisor.com">Zephyr Associates, Inc.</a></td>










    </tr>











    <tr>










      <th class="docinfo-name">Date:</th>











      <td>2006-09-11</td>










    </tr>











    <tr class="field">










      <th class="docinfo-name">Number:</th>










      <td class="field-body">This is a revised version of <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1530.html">N1530</a>=03-0113, which was
accepted for Technical Report 1 by the C++ standard
committee's library working group.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.9 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG. -->
<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">copyright:</th>










      <td class="field-body">Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">概要：</th>










      <td class="field-body">我们提议了一组类模板，帮助程序员构建符合标准的迭代器，包括从草稿出发和调整其它迭代器。</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<div class="contents topic" id="table-of-contents">
<p class="topic-title first">目录</p>











<ul class="simple">











  <li><a class="reference internal" href="#motivation" id="id15">动机</a></li>











  <li><a class="reference internal" href="#impact-on-the-standard" id="id16">对标准的影响</a></li>











  <li><a class="reference internal" href="#design" id="id17">设计</a>
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><a class="reference internal" href="#iterator-concepts" id="id18">迭代器的概念</a></li>











      <li><a class="reference internal" href="#interoperability" id="id19">可交互性</a></li>











      <li><a class="reference internal" href="#iterator-facade" id="id20">迭代器的外观</a>
        
        
        
        
        
        
        
        
        
        
        <ul>











          <li><a class="reference internal" href="#usage" id="id21">用法</a></li>











          <li><a class="reference internal" href="#iterator-core-access" id="id22">迭代器的核心访问</a></li>











          <li><a class="reference internal" href="#operator" id="id23"><tt class="docutils literal"><span class="pre">operator[]</span></tt></a></li>











          <li><a class="reference internal" href="#id6" id="id24"><tt class="docutils literal"><span class="pre">operator-&gt;</span></tt></a></li>











        
        
        
        
        
        
        
        
        
        
        </ul>











      </li>











      <li><a class="reference internal" href="#iterator-adaptor" id="id25">迭代器的适配器</a></li>











      <li><a class="reference internal" href="#specialized-adaptors" id="id26">特定的适配器</a></li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li><a class="reference internal" href="#proposed-text" id="id27">提议文本</a>
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><a class="reference internal" href="#header-iterator-helper-synopsis-lib-iterator-helper-synopsis" id="id28">Header <tt class="docutils literal"><span class="pre">&lt;iterator_helper&gt;</span></tt> 概要    [lib.iterator.helper.synopsis]</a></li>











      <li><a class="reference internal" href="#iterator-facade-lib-iterator-facade" id="id29">迭代器外观 [lib.iterator.facade]</a>
        
        
        
        
        
        
        
        
        
        
        <ul>











          <li><a class="reference internal" href="#class-template-iterator-facade" id="id30">类模板 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt></a></li>











          <li><a class="reference internal" href="#iterator-facade-requirements" id="id31"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的要求</a></li>











          <li><a class="reference internal" href="#iterator-facade-operations" id="id32"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的操作</a></li>











        
        
        
        
        
        
        
        
        
        
        </ul>











      </li>











      <li><a class="reference internal" href="#iterator-adaptor-lib-iterator-adaptor" id="id33">迭代器适配器 [lib.iterator.adaptor]</a>
        
        
        
        
        
        
        
        
        
        
        <ul>











          <li><a class="reference internal" href="#class-template-iterator-adaptor" id="id34">类模板 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt></a></li>











          <li><a class="reference internal" href="#iterator-adaptor-requirements" id="id35"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的要求</a></li>











          <li><a class="reference internal" href="#iterator-adaptor-base-class-parameters" id="id36"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的基类参数</a></li>











          <li><a class="reference internal" href="#iterator-adaptor-public-operations" id="id37"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的公有操作</a></li>











          <li><a class="reference internal" href="#iterator-adaptor-protected-member-functions" id="id38"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的保护成员函数</a></li>











          <li><a class="reference internal" href="#iterator-adaptor-private-member-functions" id="id39"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的私有成员函数</a></li>











        
        
        
        
        
        
        
        
        
        
        </ul>











      </li>











      <li><a class="reference internal" href="#specialized-adaptors-lib-iterator-special-adaptors" id="id40">特定的适配器 [lib.iterator.special.adaptors]</a>
        
        
        
        
        
        
        
        
        
        
        <ul>











          <li><a class="reference internal" href="#indirect-iterator" id="id41">间接迭代器</a>
            
            
            
            
            
            
            
            
            
            
            <ul>











              <li><a class="reference internal" href="#class-template-pointee" id="id42">类模板 <tt class="docutils literal"><span class="pre">pointee</span></tt></a></li>











              <li><a class="reference internal" href="#class-template-indirect-reference" id="id43">类模板 <tt class="docutils literal"><span class="pre">indirect_reference</span></tt></a></li>











              <li><a class="reference internal" href="#class-template-indirect-iterator" id="id44">类模板 <tt class="docutils literal"><span class="pre">indirect_iterator</span></tt></a></li>











              <li><a class="reference internal" href="#indirect-iterator-requirements" id="id45"><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的要求</a></li>











              <li><a class="reference internal" href="#indirect-iterator-models" id="id46"><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的模型</a></li>











              <li><a class="reference internal" href="#indirect-iterator-operations" id="id47"><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的操作</a></li>











            
            
            
            
            
            
            
            
            
            
            </ul>











          </li>











          <li><a class="reference internal" href="#reverse-iterator" id="id48">反序迭代器</a>
            
            
            
            
            
            
            
            
            
            
            <ul>











              <li><a class="reference internal" href="#class-template-reverse-iterator" id="id49">类模板 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt></a></li>











              <li><a class="reference internal" href="#reverse-iterator-requirements" id="id50"><tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 的要求</a></li>











              <li><a class="reference internal" href="#reverse-iterator-models" id="id51"><tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 的模型</a></li>











              <li><a class="reference internal" href="#reverse-iterator-operations" id="id52"><tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 的操作</a></li>











            
            
            
            
            
            
            
            
            
            
            </ul>











          </li>











          <li><a class="reference internal" href="#transform-iterator" id="id53">转换迭代器</a>
            
            
            
            
            
            
            
            
            
            
            <ul>











              <li><a class="reference internal" href="#class-template-transform-iterator" id="id54">类模板 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt></a></li>











              <li><a class="reference internal" href="#transform-iterator-requirements" id="id55"><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的要求</a></li>











              <li><a class="reference internal" href="#transform-iterator-models" id="id56"><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的模型</a></li>











              <li><a class="reference internal" href="#transform-iterator-operations" id="id57"><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的操作</a></li>











            
            
            
            
            
            
            
            
            
            
            </ul>











          </li>











          <li><a class="reference internal" href="#filter-iterator" id="id58">过虑迭代器</a>
            
            
            
            
            
            
            
            
            
            
            <ul>











              <li><a class="reference internal" href="#class-template-filter-iterator" id="id59">类模板 <tt class="docutils literal"><span class="pre">filter_iterator</span></tt></a></li>











              <li><a class="reference internal" href="#filter-iterator-requirements" id="id60"><tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 的要求</a></li>











              <li><a class="reference internal" href="#filter-iterator-models" id="id61"><tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 的模型</a></li>











              <li><a class="reference internal" href="#filter-iterator-operations" id="id62"><tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 的操作</a></li>











            
            
            
            
            
            
            
            
            
            
            </ul>











          </li>











          <li><a class="reference internal" href="#counting-iterator" id="id63">计数迭代器</a>
            
            
            
            
            
            
            
            
            
            
            <ul>











              <li><a class="reference internal" href="#class-template-counting-iterator" id="id64">类模板 <tt class="docutils literal"><span class="pre">counting_iterator</span></tt></a></li>











              <li><a class="reference internal" href="#counting-iterator-requirements" id="id65"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 的要求</a></li>











              <li><a class="reference internal" href="#counting-iterator-models" id="id66"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 的模型</a></li>











              <li><a class="reference internal" href="#counting-iterator-operations" id="id67"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 的操作</a></li>











            
            
            
            
            
            
            
            
            
            
            </ul>











          </li>











          <li><a class="reference internal" href="#function-output-iterator" id="id68">函数输出迭代器</a>
            
            
            
            
            
            
            
            
            
            
            <ul>











              <li><a class="reference internal" href="#class-template-function-output-iterator" id="id69">类模板 <tt class="docutils literal"><span class="pre">function_output_iterator</span></tt></a></li>











              <li><a class="reference internal" href="#header" id="id70">头文件</a></li>











              <li><a class="reference internal" href="#function-output-iterator-requirements" id="id71"><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt> 的要求</a></li>











              <li><a class="reference internal" href="#function-output-iterator-models" id="id72"><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt> 的模型</a></li>











              <li><a class="reference internal" href="#function-output-iterator-operations" id="id73"><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt> 的操作</a></li>











            
            
            
            
            
            
            
            
            
            
            </ul>











          </li>











        
        
        
        
        
        
        
        
        
        
        </ul>











      </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











</ul>











</div>











<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id15">动机</a></h1>











<p>迭代器是现代C++编程中的重要角色。它是标准库中的算法的重要抽象物，使得算法可以被重用于广泛的上下文中。C++ 标准库包含了大量有用的迭代器。每一种标准容器都带有常量和非常量迭代器<a class="footnote-reference" href="#mutable" id="id1"><sup>2</sup></a>，还有相应的反向版本用于以相反顺序对容器进行遍历。标准还提供了 <tt class="docutils literal"><span class="pre">istream_iterator</span></tt> 和
<tt class="docutils literal"><span class="pre">ostream_iterator</span></tt> 用于从流读取和写出到流，<tt class="docutils literal"><span class="pre">insert_iterator</span></tt>, <tt class="docutils literal"><span class="pre">front_insert_iterator</span></tt> 和
<tt class="docutils literal"><span class="pre">back_insert_iterator</span></tt> 则用于插入元素到容器中，还有
<tt class="docutils literal"><span class="pre">raw_storage_iterator</span></tt> 用于初始化原始内存。[7]</p>











<p>尽管标准库提供了许多迭代器，但是还是遗漏了一些明显和有用的迭代器，对于C++程序员来说创建新的迭代器类型仍是一项常见的工作。有一些文献讨论了一些迭代器，如 line_iterator [3] 和 Constant_iterator
[9].  迭代器的抽象是非常强有力的，我们认为程序员总是需要发明新的迭代器类型。</p>











<p>虽然创建一个<span style="font-style: italic;">几乎</span>符合标准的迭代器很容易，但是对迭代器的要求包含了一些很微妙的地方，使得创建一个<span style="font-style: italic;">精确</span>符合标准的迭代器非常困难。更进一步，迭代器的接口非常丰富，包含了许多操作符，技术上是存在冗余而实现它们是乏味的。为了让构造迭代器的重复工作可以自动完成，我们提议了
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt>, 它是一个迭代器基类模板，提供了标准迭代器的丰富接口，并且将其实现委托给派生类的成员函数。除了减少创建迭代器所需的代码数量之外，<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 还提供了编译期错误检测。迭代器实现中经常被忽视的错误变成了编译期错误，因为派生类的实现必须符合 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的期望。</p>











<p>构造迭代器的一个常见模式是将一个已有的迭代器改编为新的迭代器。一个迭代器的功能由四个正交的方面组成：遍历，间接性，相等性比较和距离计算。改编一个旧的迭代器以创建新的迭代器通常可以节省工作量，因为你可以重用某些方面的功能而重定义其它方面。例如，标准提供了 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt>, 它将一个任意的双向迭代器改编为以相反的顺序进行遍历。和普通的迭代器一样，在标准之外定义的迭代器适配器已经常常出现在文献中：</p>











<ul class="simple">











  <li>Checked iter[13] 为一个已有迭代器增加边界检查。</li>











  <li>View Template Library[14]改编了标准容器，而其中的迭代器则改编了底层的迭代器。</li>











  <li>Smart iterators [5] 改编了一个迭代器的提领行为，将一个函数对象用于被引用的对象并返回函数的结果。</li>











  <li>Custom iterators [4], 其中列举了多个适配器类型。</li>











  <li>Compound iterators [1], 用于访问由多个容器组成的一个容器的片段。</li>











  <li>来自于 MTL [12] 的几个迭代器适配器。MTL 包含一个步幅迭代器，每次调用 <tt class="docutils literal"><span class="pre">operator++()</span></tt> 会将迭代器前移一个常量值；还有一个比例迭代器，它会将提领得到的值乘以一个常量倍数。</li>











</ul>











<table class="docutils footnote" id="concept" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label">[1]</td>










      <td>我们用术语"概念"表示一个被用于某个特定模板参数的类型所必须满足的一组要求。</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<table class="docutils footnote" id="mutable" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label"><a class="fn-backref" href="#id1">[2]</a></td>










      <td>术语"非常量迭代器"是指，可以通过对被提领的迭代器进行赋值来修改迭代器所指的对象，而"常量迭代器"则是指迭代器所指的对象不能被改变。</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p>为了满足构造适配器的需要，我们提议了
<tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 类模板。<tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的实例可用作新迭代器的基类，它提供的缺省行为是将所有操作前转至底层的迭代器。用户可以在派生的迭代器类中有选择地替代某些操作。该提议书中还包含了许多特定的适配器，如 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 可以在迭代器提领时执行某些用户指定的函数。</p>











</div>











<div class="section" id="impact-on-the-standard">
<h1><a class="toc-backref" href="#id16">对标准的影响</a></h1>











<p>该提议书完全是对C++标准库的添加。但是，请注意本提议书依赖于"新的迭代器概念"提议书。</p>











</div>











<div class="section" id="design">
<h1><a class="toc-backref" href="#id17">设计</a></h1>











<div class="section" id="iterator-concepts">
<h2><a class="toc-backref" href="#id18">迭代器的概念</a></h2>











<p>本提议书是依据 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/papers/2003/n1550.html">n1550</a> 中提议的新的迭代器概念来阐述的，由于用户自定义的迭代器尤其是改编的迭代器一直以来都受到老的迭代器分类方式所带来的著名的分类问题所困扰。</p>











<p>本提议书本没有完全遵照 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/papers/2003/n1550.html">n1550</a> 中的提议，如在新旧分类法间建立直接的映射。如果 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/papers/2003/n1550.html">n1550</a> 不被接受，本提议书可能会用这些映射重新编写。</p>











</div>











<div class="section" id="interoperability">
<h2><a class="toc-backref" href="#id19">可交互性</a></h2>











<p>在当前标准中，对于迭代器的可交互性问题几乎没有提及。当前有两个缺点是由可交互性问题所引起的。</p>











<p>问题 <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a> 提及这样一个事实，即非常量的容器迭代器只被要求可转换为对应的常量迭代器类型，而不要求这些类型的对象可以相互比较或相减。这种情形在实践中是乏味的，而且与内建类型的工作方式不一致。本提议书实现了问题
<a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a> 所建议的解决方案，正如当今多数标准库实现所做的那样。换句话说，如果一个迭代器类型 A 有一个隐式的或用户定义的到迭代器类型 B 的转换，那么这两个迭代器类型就是可交互的，且常见的操作符都可用。</p>











<p>问题 <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html#280">280</a> 提及了当前反向迭代器类型间的可交互性的缺失。本提议书中的新的 reverse_iterator 模板修正了 280 所提到的问题。它提供了想要的可交互性，而且没有引入不想要的重载。</p>











</div>











<div class="section" id="iterator-facade">
<h2><a class="toc-backref" href="#id20">迭代器的外观</a></h2>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.1 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG for TR1. -->
<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. -->
<p>迭代器接口非常丰富，不过存在一组对于所有功能都需要的核心接口。我们已为迭代器标识出以下核心行为：</p>











<ul class="simple">











  <li>提领</li>











  <li>递增</li>











  <li>递减</li>











  <li>相等性比较</li>











  <li>随机访问动作</li>











  <li>距离计算</li>











</ul>











<p>除了以上列出的行为以外，核心接口元素还应包括一些由迭代器 traits 所声明的关联类型：<tt class="docutils literal"><span class="pre">value_type</span></tt>, <tt class="docutils literal"><span class="pre">reference</span></tt>, <tt class="docutils literal"><span class="pre">difference_type</span></tt>, 和
<tt class="docutils literal"><span class="pre">iterator_category</span></tt>.</p>











<p>迭代器外观使用了 Curiously Recurring Template
Pattern (CRTP) <a class="citation-reference" href="facade-and-adaptor.html#cop95" id="id4">[Cop95]</a>，这样用户可以在派生类中指定 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的行为。以前的设计使用了策略对象来指定行为，但这种方法由于以下原因而被弃用：</p>


















<blockquote>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <ol class="arabic simple">








    <li>策略对象拷贝的创建和销毁会增加开销，而现在的方法可以避免。</li>








    <li>策略对象方法不允许对被创建的迭代器类型定制构造函数，而如果
      <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 要用于其它的库实现，该特性是必须的。</li>








    <li>如果不使用 CRTP, 那么标准所要求的：迭代器的 <tt class="docutils literal"><span class="pre">operator++</span></tt> 要返回迭代器类型本身，将会导致由本库所创建的所有迭代器都必须是<tt class="docutils literal"><span class="pre">iterator_facade&lt;...&gt;</span></tt> 的特化，而不能是象 <tt class="docutils literal"><span class="pre">indirect_iterator&lt;T*&gt;</span></tt> 这样的类型。要创建新的参数化迭代器就必须要使用笨重的类型生成器元函数，而且一个独立的 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 层也是不可能的了。</li>








  
  
  
  
  
  
  
  
  </ol>








</blockquote>








<div class="section" id="usage">
<h3><a class="toc-backref" href="#id21">用法</a></h3>











<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的用户应从 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的一个特化派生出他的迭代器类，并将该派生的迭代器类作为 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的第一个模板参数。其它模板参数的顺序是经过仔细选择的，以便于使用缺省值。例如，定义一个常量左值迭代器时，用户可以传入将迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的一个const版本作为
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">Value</span></tt> 参数传入，而省略后面的
<tt class="docutils literal"><span class="pre">Reference</span></tt> 参数。</p>

















<p>派生的迭代器类必须定义一些成员函数来实现迭代器的核心行为。下表描述了一些依据于迭代器类型而要求必须有效的表达式。这些成员函数会有简单的描述，更为详细的介绍请见"迭代器外观的要求"一节。</p>

















<blockquote>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <table class="docutils" border="1">

















    <colgroup><col width="44%" /><col width="56%" /></colgroup>
    <thead valign="bottom">
    <tr>
















      <th class="head">表达式</th>

















      <th class="head">作用</th>

















    </tr>

















    </thead>
    <tbody valign="top">

















      <tr>
















        <td><tt class="docutils literal"><span class="pre">i.dereference()</span></tt></td>

















        <td>访问所引向的值</td>

















      </tr>

















      <tr>
















        <td><tt class="docutils literal"><span class="pre">i.equal(j)</span></tt></td>

















        <td>比较与 <tt class="docutils literal"><span class="pre">j</span></tt> 的等价性<tt class="docutils literal"><span class="pre"></span></tt></td>

















      </tr>

















      <tr>
















        <td><tt class="docutils literal"><span class="pre">i.increment()</span></tt></td>

















        <td>前进一个位置</td>

















      </tr>

















      <tr>
















        <td><tt class="docutils literal"><span class="pre">i.decrement()</span></tt></td>

















        <td>后退一个位置</td>

















      </tr>

















      <tr>
















        <td><tt class="docutils literal"><span class="pre">i.advance(n)</span></tt></td>

















        <td>前进 <tt class="docutils literal"><span class="pre">n</span></tt> 个位置</td>

















      </tr>

















      <tr>
















        <td><tt class="docutils literal"><span class="pre">i.distance_to(j)</span></tt></td>

















        <td>计算与 <tt class="docutils literal"><span class="pre">j</span></tt> 的距离<tt class="docutils literal"><span class="pre"></span></tt></td>

















      </tr>

















    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    </tbody>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  </table>







  <img src="chrome://editor/content/images/tag-comment.gif" /><!-- Should we add a comment that a zero overhead implementation of iterator_facade
is possible with proper inlining? --></blockquote>








<p>除了实现以上核心接口函数之外，一个派生自 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的迭代器通常还要定义几个构造函数。为了符合标准的迭代器概念，至少要有一个复制构造函数。此外，如果迭代器类型 <tt class="docutils literal"><span class="pre">X</span></tt> 是与另一个迭代器类型 <tt class="docutils literal"><span class="pre">Y</span></tt> 可以自动互操作的(如常量迭代器和可变迭代器)，那么就必须有一个从 <tt class="docutils literal"><span class="pre">X</span></tt> 到 <tt class="docutils literal"><span class="pre">Y</span></tt> 或者从 <tt class="docutils literal"><span class="pre">Y</span></tt> 以 <tt class="docutils literal"><span class="pre">X</span></tt> 的隐式转换(不必两个都有)，通常的实现方式就是一个转换构造函数。最后，如果迭代器符合前向遍历迭代器或更为强化的迭代器概念，则要求有一个缺省构造函数。</p>











</div>











<div class="section" id="iterator-core-access">
<h3><a class="toc-backref" href="#id22">迭代器的核心访问</a></h3>











<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 及其操作符的实现要能够访问派生类的核心成员函数。而将核心成员函数声明为公有的，又会把实现细节暴露给了用户。这里使用的设计可以确保实现细节不会出现在派生迭代器类型的公有接口中。</p>

















<p>防止直接访问核心成员函数有两个好处。首先，用户不可能在要使用 value_type 的成员时无意中用到了迭代器的成员函数。这在以前的智能指针实现中是一个问题。第二个也是主要的好处是，库的实现可以自由地将一个基于 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的迭代器换为手工实现的迭代器，而无需担心破坏了要被直接访问的公有核心成员函数的代码。</p>

















<p>在一个简单的实现中，要保持派生类的核心成员函数私有，就要将
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的所有七个操作符声明为友元函数。为了减轻这个负担，我们提供了 <tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 类，它的作用是作为派生迭代器类的核心成员函数的网关。派生类的作者只需将 <tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 声明为友元就可以让程序库使用他的核心成员函数了。</p>







<!-- This is no long uptodate -thw -->
<!-- Yes it is; I made sure of it! -DWA -->
<p><tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 被实现为一个空类，只包含了私有的静态成员函数，这些函数会调用迭代器的核心成员函数。我们不需要对这个网关协议进行标准化。请注意，即使
<tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 使用了公有的成员函数，也不会有安全漏洞，因为每个核心成员函数都保证了迭代器的不变式。</p>











</div>











<div class="section" id="operator">
<h3><a class="toc-backref" href="#id23"><tt class="docutils literal"><span class="pre">operator[]</span></tt></a></h3>











<p>泛型迭代器的索引操作符带来了特殊的挑战。随机访问迭代器的 <tt class="docutils literal"><span class="pre">operator[]</span></tt> 只要求返回某个可以转换为 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的东西。要求它返回一个左值会将某些当前合法的随机访问迭代器排除在外，这些迭代器在它的数据成员中保存了一个被引用值(如&nbsp;<a class="reference internal" href="facade-and-adaptor.html#counting"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt></a>), 由于 <tt class="docutils literal"><span class="pre">*(p+n)</span></tt> 是临时迭代器 <tt class="docutils literal"><span class="pre">p+n</span></tt> 的引用，当
<tt class="docutils literal"><span class="pre">operator[]</span></tt> 返回时就会被销毁。</p>

















<p>用&nbsp;<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 创建的可写迭代器实现了在 <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html#299">issue 299</a>&nbsp;的首选方案中和在提议书 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/papers/2003/n1550.html">n1550</a> 中所采用的语义：<tt class="docutils literal"><span class="pre">p[n]</span></tt> 的结果是一个可以转换为迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的对象，且 <tt class="docutils literal"><span class="pre">p[n]</span> <span class="pre">=</span> <span class="pre">x</span></tt> 等同于 <tt class="docutils literal"><span class="pre">*(p</span> <span class="pre">+</span> <span class="pre">n)</span> <span class="pre">=</span> <span class="pre">x</span></tt> (注：该结果对象可以实现为某个包含了 <tt class="docutils literal"><span class="pre">p+n</span></tt> 的一个拷贝的代理)。这个方法对于任意的随机访问迭代器都可以正确工作，不管迭代器的其它实现细节。用户如果知道更多有关他的迭代器的实现细节，也可以实现一个
<tt class="docutils literal"><span class="pre">operator[]</span></tt> 以在派生的迭代器类中返回一个左值；这样可以向迭代器的用户隐藏由 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 所提供的实现。</p>







</div>











<div class="section" id="id6">
<span id="operator-arrow"></span>
<h3><a class="toc-backref" href="#id24"><tt class="docutils literal"><span class="pre">operator-&gt;</span></tt></a></h3>











<p>一个可读迭代器(或者现在的输入迭代器)的 <tt class="docutils literal"><span class="pre">reference</span></tt> 类型并不需要真的是一个引用，只要它可以转换为迭代器的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 就行了。但是，如果 <tt class="docutils literal"><span class="pre">value_type</span></tt>
是一个类，那么就还需要可以通过 <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> 访问其成员。因此，一个迭代器如果其 <tt class="docutils literal"><span class="pre">reference</span></tt>
类型不真的是一个引用，那么就必须从它的 <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> 返回一个代理，其中包含被引用值的拷贝。</p>

















<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> 和
<tt class="docutils literal"><span class="pre">operator[]</span></tt> 的返回类型并没有明确地指定。这些类型被描述为一组要求，<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的实现必须满足这些要求。</p>







<table class="docutils citation" id="cop95" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label"><a class="fn-backref" href="#id4">[Cop95]</a></td>










      <td>[Coplien, 1995] Coplien, J., Curiously Recurring Template
Patterns, C++ Report, February 1995, pp. 24-27.</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="iterator-adaptor">
<h2><a class="toc-backref" href="#id25">迭代器的适配器</a></h2>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.2 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG for TR1. -->
<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. -->
<p><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 类模板通过改编某个 <tt class="docutils literal"><span class="pre">Base</span></tt><a class="footnote-reference" href="#base" id="id7"><sup>3</sup></a>
类型来创建一个新的迭代器。<tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt>
的实例派生自一个对应的 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt>
的实例，并依据 <tt class="docutils literal"><span class="pre">Base</span></tt> 类型实现核心行为。基本上，<tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 只是将所有操作前转至 <tt class="docutils literal"><span class="pre">Base</span></tt> 类型的一个实例，该实例被作为一个成员保存。</p>











<table class="docutils footnote" id="base" frame="void" rules="none">











  <colgroup><col class="label" /><col /></colgroup>
  <tbody valign="top">











    <tr>










      <td class="label"><a class="fn-backref" href="#id7">[3]</a></td>










      <td>这里的术语 "Base" 并不是指基类，也没有使用派生。我们跟随了标准库的带领，标准库为 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 适配器提供了 base() 函数来访问底层的迭代器对象。</td>










    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的用户创建了一个派生自某个 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 实例的类，然后有选择地重新定义在
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的核心要求表格中所列的某些核心成员函数。<tt class="docutils literal"><span class="pre">Base</span></tt> 类型不必完全符合迭代器的所有要求；它只须支持那些被
<tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的核心接口函数使用而又没有在用户的派生类中重新定义的操作就可以了。</p>












<p><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 有几个模板参数的缺省值是 <tt class="docutils literal"><span class="pre">use_default</span></tt>. 这允许用户使用缺省参数，即使他想在后面的参数列表中指定参数。还有，对应的关联类型缺省值有些复杂，需要用元编程来计算它们，而
<tt class="docutils literal"><span class="pre">use_default</span></tt> 可以帮助简化实现。最后，<tt class="docutils literal"><span class="pre">use_default</span></tt> 类型的标识符没有留作非未指明的，这是因为规定该标识符可以有助于突出 <tt class="docutils literal"><span class="pre">Reference</span></tt>
模板参数并不总是与迭代器的
<tt class="docutils literal"><span class="pre">reference</span></tt> 类型一致这一事实，并防止用户由于这个假设而出错。</p>







</div>











<div class="section" id="specialized-adaptors">
<h2><a class="toc-backref" href="#id26">特定的适配器</a></h2>











<p>本提议书还包含了几个特定适配器的例子，它们可以用 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 很容易地实现：</p>











<ul class="simple">











  <li><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt>, 它迭代一组迭代器、指针或智能指针，并对它们进行多一次的提领动作。</li>











  <li>一个新的 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt>, 它将一个底层迭代器的移动方向反序，并允许改编后的常量和非常量迭代器以期望的方法相互操作(而不是象在多数 C++98&nbsp;的实现那样)。</li>











  <li><tt class="docutils literal"><span class="pre">transform_iterator</span></tt>, 它将一个用户自定义的函数对象作用于底层迭代器的提领值。</li>











  <li><tt class="docutils literal"><span class="pre">filter_iterator</span></tt>, 它提供某个迭代器区间的一个视图，其中跳过底层区间的一些元素。</li>











</ul>











<ul class="simple" id="counting">











  <li><tt class="docutils literal"><span class="pre">counting_iterator</span></tt>, 它用于改编任意的可递增类型(如整型数、迭代器)，可以对改编后的迭代器进行递增/递减，并且对它的提领动作将产生 Base 类型的连续值。</li>











  <li><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt>, 可以方便地创建定制化的输出迭代器。</li>











</ul>











<p>基于 Boost
库的这些例子，用户已经生成了许多新的适配器，如排列适配器，它对一个随机访问迭代器进行重新排列的操作；还有步幅适配器，它改编一个随机访问迭代器将其
移动的步幅乘以一个常量因子。另外，Boost Graph Library (BGL) 使用了迭代器适配器来将其它 graph 库，如 LEDA
[10]
和 Stanford GraphBase [8], 改编为 BGL 接口(该接口要求符合 C++
标准的迭代器)。</p>











</div>











</div>











<div class="section" id="proposed-text">
<h1><a class="toc-backref" href="#id27">提议文本</a></h1>











<div class="section" id="header-iterator-helper-synopsis-lib-iterator-helper-synopsis">
<h2><a class="toc-backref" href="#id28">头文件 <tt class="docutils literal"><span class="pre">&lt;iterator_helper&gt;</span></tt> 概要 [lib.iterator.helper.synopsis]</a></h2>











<pre class="literal-block">struct use_default;<br /><br />struct iterator_core_access { /* 实现细节 */ };<br /><br />template &lt;<br />    class Derived<br />  , class Value<br />  , class CategoryOrTraversal<br />  , class Reference  = Value&amp;<br />  , class Difference = ptrdiff_t<br />&gt;<br />class iterator_facade;<br /><br />template &lt;<br />    class Derived<br />  , class Base<br />  , class Value      = use_default<br />  , class CategoryOrTraversal  = use_default<br />  , class Reference  = use_default<br />  , class Difference = use_default<br />&gt;<br />class iterator_adaptor;<br /><br />template &lt;<br />    class Iterator<br />  , class Value = use_default<br />  , class CategoryOrTraversal = use_default<br />  , class Reference = use_default<br />  , class Difference = use_default<br />&gt;<br />class indirect_iterator;<br /><br />template &lt;class Dereferenceable&gt;<br />struct pointee;<br /><br />template &lt;class Dereferenceable&gt;<br />struct indirect_reference;<br /><br />template &lt;class Iterator&gt;<br />class reverse_iterator;<br /><br />template &lt;<br />    class UnaryFunction<br />  , class Iterator<br />  , class Reference = use_default<br />  , class Value = use_default<br />&gt;<br />class transform_iterator;<br /><br />template &lt;class Predicate, class Iterator&gt;<br />class filter_iterator;<br /><br />template &lt;<br />    class Incrementable<br />  , class CategoryOrTraversal  = use_default<br />  , class Difference = use_default<br />&gt;<br />class counting_iterator;<br /><br />template &lt;class UnaryFunction&gt;<br />class function_output_iterator;<br /></pre>











</div>











<div class="section" id="iterator-facade-lib-iterator-facade">
<h2><a class="toc-backref" href="#id29">迭代器外观 [lib.iterator.facade]</a></h2>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 是一个基类模板，它依据由派生的迭代器类所提供的少量核心函数和关联类型实现标准迭代器的接口。</p>











<div class="section" id="class-template-iterator-facade">
<h3><a class="toc-backref" href="#id30">类模板 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt></a></h3>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.3 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG for TR1. -->
<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. -->
<pre class="literal-block">template &lt;<br />    class Derived<br />  , class Value<br />  , class CategoryOrTraversal<br />  , class Reference  = Value&amp;<br />  , class Difference = ptrdiff_t<br />&gt;<br />class iterator_facade {<br /> public:<br />    typedef remove_const&lt;Value&gt;::type value_type;<br />    typedef Reference reference;<br />    typedef Value* pointer;<br />    typedef Difference difference_type;<br />    typedef /* 见 <a class="reference internal" href="#iterator-category">下文</a> */ iterator_category;<br /><br />    reference operator*() const;<br />    /* 见 <a class="reference internal" href="#operator-arrow">下文</a> */ operator-&gt;() const;<br />    /* 见 <a class="reference internal" href="#brackets">下文</a> */ operator[](difference_type n) const;<br />    Derived&amp; operator++();<br />    Derived operator++(int);<br />    Derived&amp; operator--();<br />    Derived operator--(int);<br />    Derived&amp; operator+=(difference_type n);<br />    Derived&amp; operator-=(difference_type n);<br />    Derived operator-(difference_type n) const;<br /> protected:<br />    typedef iterator_facade iterator_facade_;<br />};<br /><br />// 比较操作符<br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type // exposition<br />operator ==(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator !=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />// 迭代器减法<br />template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />/* 见 <a class="reference internal" href="#minus">下文</a> */<br />operator-(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />          iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /><br />// 迭代器加法<br />template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;,<br />                   typename Derived::difference_type n);<br /><br />template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (typename Derived::difference_type n,<br />                   iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;);<br /></pre>











<p id="iterator-category"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 成员为</p>











<pre class="literal-block"><em>iterator-category</em>(CategoryOrTraversal, value_type, reference)<br /></pre>











<p>其中 <em>iterator-category</em> 定义如下：</p>











<pre class="literal-block" id="id12"><em>iterator-category</em>(C,R,V) :=<br />   if (C 可转换为 std::input_iterator_tag<br />       || C 可转换为 std::output_iterator_tag<br />   )<br />       return C<br /><br />   else if (C 不可转换为 incrementable_traversal_tag)<br />       <em>程序有错误</em><br /><br />   else return 一个满足以下两个约束条件的类型 X:<br /><br />      1. X 可转换为 X1, 并且没有更深的派生类，其中 X1 的定义为：<br /><br />           if (R 为引用类型<br />               &amp;&amp; C 可转换为 forward_traversal_tag)<br />           {<br />               if (C 可转换为 random_access_traversal_tag)<br />                   X1 = random_access_iterator_tag<br />               else if (C 可转换为 bidirectional_traversal_tag)<br />                   X1 = bidirectional_iterator_tag<br />               else<br />                   X1 = forward_iterator_tag<br />           }<br />           else<br />           {<br />               if (C 可转换为 single_pass_traversal_tag<br />                   &amp;&amp; R 可转换为 V)<br />                   X1 = input_iterator_tag<br />               else<br />                   X1 = C<br />           }<br /><br />      2. <a class="reference external" href="new-iter-concepts.html#category-to-traversal"><em>category-to-traversal</em></a>(X) 可转换为也可以由 X 转换的最深派生层次的<br />         traversal tag type, 并且没有更深的派生 traversal tag type.<br /></pre>











<p>[注：目的是允许 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 是五个原有的 category tags 之一，而可转换为
traversal tags 之一并没有增加信息]</p>











<!-- Copyright David Abrahams 2004. Use, modification and distribution is -->
<!-- subject to the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p>上面所用的 <tt class="docutils literal"><span class="pre">enable_if_interoperable</span></tt> 模板是为了暴露不合理的操作符。这些成员操作符只有当派生类型 <tt class="docutils literal"><span class="pre">Dr1</span></tt> 和 <tt class="docutils literal"><span class="pre">Dr2</span></tt> 是可交互的才应提供一组重载，即两个类型中至少有一个可转换为另一个。<tt class="docutils literal"><span class="pre">enable_if_interoperable</span></tt> 方法使用了 SFINAE 来实现当这两个类型不可交互时将这些操作符剔除出重载函数组。这些操作符的行为就象 <tt class="docutils literal"><span class="pre">enable_if_interoperable</span></tt>
的定义如下：</p>











<pre class="literal-block">template &lt;bool, typename&gt; enable_if_interoperable_impl<br />{};<br /><br />template &lt;typename T&gt; enable_if_interoperable_impl&lt;true,T&gt;<br />{ typedef T type; };<br /><br />template&lt;typename Dr1, typename Dr2, typename T&gt;<br />struct enable_if_interoperable<br />  : enable_if_interoperable_impl&lt;<br />        is_convertible&lt;Dr1,Dr2&gt;::value || is_convertible&lt;Dr2,Dr1&gt;::value<br />      , T<br />    &gt;<br />{};<br /></pre>











</div>











<div class="section" id="iterator-facade-requirements">
<h3><a class="toc-backref" href="#id31"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的要求</a></h3>











<p>下表描述了对于
<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的 <tt class="docutils literal"><span class="pre">Derived</span></tt> 参数的有效表达式，依赖于所属的迭代器概念。第一列中的操作必须可以被类
<tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 的成员函数访问。此外，<tt class="docutils literal"><span class="pre">static_cast&lt;Derived*&gt;(iterator_facade*)</span></tt> 应该是合法的。</p>

















<p>在下表中，<tt class="docutils literal"><span class="pre">F</span></tt> 为 <tt class="docutils literal"><span class="pre">iterator_facade&lt;X,V,C,R,D&gt;，</span></tt><tt class="docutils literal"><span class="pre">a</span></tt> 是类型 <tt class="docutils literal"><span class="pre">X</span></tt> 的一个对象，<tt class="docutils literal"><span class="pre">b</span></tt> 和 <tt class="docutils literal"><span class="pre">c</span></tt> 是类型 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">X</span></tt> 的对象，<tt class="docutils literal"><span class="pre">n</span></tt> 是类型 <tt class="docutils literal"><span class="pre">F::difference_type</span></tt> 的对象，<tt class="docutils literal"><span class="pre">y</span></tt> 是一个与 <tt class="docutils literal"><span class="pre">X</span></tt> 可交互的单遍迭代器类型的常量对象，而 <tt class="docutils literal"><span class="pre">z</span></tt>
是一个与 <tt class="docutils literal"><span class="pre">X</span></tt> 可交互的随机访问遍历迭代器的常量对象。</p>






<div class="topic" id="core-operations">
<div class="topic" id="core-operations">
<p class="topic-title first"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 核心操作</p>

















<table class="docutils" border="1">

















  <colgroup><col width="21%" /><col width="23%" /><col width="27%" /><col width="29%" /></colgroup>
  <thead valign="bottom">
  <tr>
















    <th class="head">表达式</th>

















    <th class="head">返回类型</th>

















    <th class="head">断言/备注</th>

















    <th class="head">用于实现哪些迭代器概念</th>

















  </tr>

















  </thead>
  <tbody valign="top">

















    <tr>
















      <td><tt class="docutils literal"><span class="pre">c.dereference()</span></tt></td>

















      <td><tt class="docutils literal"><span class="pre">F::reference</span></tt></td>

















      <td>&nbsp;</td>

















      <td>可读迭代器，可写迭代器</td>

















    </tr>

















    <tr>
















      <td><tt class="docutils literal"><span class="pre">c.equal(y)</span></tt></td>

















      <td>可转换为 bool</td>

















      <td>true 当且仅当 <tt class="docutils literal"><span class="pre">c</span></tt> 和 <tt class="docutils literal"><span class="pre">y</span></tt>
引向同一个位置</td>

















      <td>单遍迭代器</td>

















    </tr>

















    <tr>
















      <td><tt class="docutils literal"><span class="pre">a.increment()</span></tt></td>

















      <td>未使用</td>

















      <td>&nbsp;</td>

















      <td>可递增迭代器</td>

















    </tr>

















    <tr>
















      <td><tt class="docutils literal"><span class="pre">a.decrement()</span></tt></td>

















      <td>未使用</td>

















      <td>&nbsp;</td>

















      <td>双向遍历迭代器</td>

















    </tr>

















    <tr>
















      <td><tt class="docutils literal"><span class="pre">a.advance(n)</span></tt></td>

















      <td>未使用</td>

















      <td>&nbsp;</td>

















      <td>随机访问遍历迭代器</td>

















    </tr>

















    <tr>
















      <td><tt class="docutils literal"><span class="pre">c.distance_to(z)</span></tt></td>

















      <td>可转换为 <tt class="docutils literal"><span class="pre">F::difference_type</span></tt></td>

















      <td>等同于 <tt class="docutils literal"><span class="pre">distance(c,</span> <span class="pre">X(z))</span></tt>.</td>

















      <td>随机访问遍历迭代器</td>

















    </tr>

















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>

















</div>





























</div>






</div>






<div class="section" id="iterator-facade-operations">
<h3><a class="toc-backref" href="#id32"><tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的操作</a></h3>











<p>本节所介绍的各个操作是作为 <tt class="docutils literal"><span class="pre">Derived</span></tt>&nbsp;核心接口的操作符，它们可能是不可访问的(即私有接口)。实现中应该通过类 <tt class="docutils literal"><span class="pre">iterator_core_access</span></tt> 的成员函数来访问这些操作符。</p>











<p><tt class="docutils literal"><span class="pre">reference</span> <span class="pre">operator*()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">static_cast&lt;Derived</span> <span class="pre">const*&gt;(this)-&gt;dereference()</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">operator-&gt;()</span> <span class="pre">const;</span></tt> (见 <a class="reference internal" href="#operator-arrow">下文</a>)</p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">reference</span></tt>&nbsp;是一个引用类型，则返回一个类型为 <tt class="docutils literal"><span class="pre">pointer</span></tt> 的对象，等同于：</p>











      
      
      
      
      
      
      
      
      
      
      <pre class="literal-block">&amp;static_cast&lt;Derived const*&gt;(this)-&gt;dereference()<br /></pre>











      
      
      
      
      
      
      
      
      
      
      <p class="last">否则返回一个不确定类型的对象，以满足 <tt class="docutils literal"><span class="pre">(*static_cast&lt;Derived</span> <span class="pre">const*&gt;(this))-&gt;m</span></tt> 等价于 <tt class="docutils literal"><span class="pre">(w</span> <span class="pre">=</span> <span class="pre">**static_cast&lt;Derived</span> <span class="pre">const*&gt;(this),</span>
      <span class="pre">w.m)</span></tt> 其中 <tt class="docutils literal"><span class="pre">w</span></tt> 是类型 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的某个临时对象。</p>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p id="brackets"><em>unspecified</em> <tt class="docutils literal"><span class="pre">operator[](difference_type</span> <span class="pre">n)</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个可转换为 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的对象。对于类型<tt class="docutils literal"><span class="pre"></span></tt> <tt class="docutils literal"><span class="pre">value_type</span></tt> 的常量对象 <tt class="docutils literal"><span class="pre">v</span></tt><tt class="docutils literal"><span class="pre"></span></tt>, 以及类型
      <tt class="docutils literal"><span class="pre">difference_type</span></tt> 的对象 <tt class="docutils literal"><span class="pre">n</span></tt><tt class="docutils literal"><span class="pre"></span></tt>, <tt class="docutils literal"><span class="pre">(*this)[n]</span> <span class="pre">=</span> <span class="pre">v</span></tt> 等价于
      <tt class="docutils literal"><span class="pre">*(*this</span> <span class="pre">+</span> <span class="pre">n)</span> <span class="pre">=</span> <span class="pre">v</span></tt>, 且 <tt class="docutils literal"><span class="pre">static_cast&lt;value_type</span>
      <span class="pre">const&amp;&gt;((*this)[n])</span></tt> 等价于
      <tt class="docutils literal"><span class="pre">static_cast&lt;value_type</span> <span class="pre">const&amp;&gt;(*(*this</span> <span class="pre">+</span> <span class="pre">n))</span></tt><tt class="docutils literal"><span class="pre"></span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;increment();<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived</span> <span class="pre">operator++(int);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />++*this;<br />return tmp;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator--();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;decrement();<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived</span> <span class="pre">operator--(int);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />--*this;<br />return tmp;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator+=(difference_type</span> <span class="pre">n);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;advance(n);<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived&amp;</span> <span class="pre">operator-=(difference_type</span> <span class="pre">n);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">static_cast&lt;Derived*&gt;(this)-&gt;advance(-n);<br />return *static_cast&lt;Derived*&gt;(this);<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Derived</span> <span class="pre">operator-(difference_type</span> <span class="pre">n)</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />return tmp -= n;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;,<br />                   typename Derived::difference_type n);<br /><br />template &lt;class Dr, class V, class TC, class R, class D&gt;<br />Derived operator+ (typename Derived::difference_type n,<br />                   iterator_facade&lt;Dr,V,TC,R,D&gt; const&amp;);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <pre class="first last literal-block">Derived tmp(static_cast&lt;Derived const*&gt;(this));<br />return tmp += n;<br /></pre>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator ==(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).equal((Dr2</span> <span class="pre">const&amp;)rhs)</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).equal((Dr1</span> <span class="pre">const&amp;)lhs)</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator !=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">!((Dr1</span> <span class="pre">const&amp;)lhs).equal((Dr2</span> <span class="pre">const&amp;)rhs)</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">!((Dr2</span> <span class="pre">const&amp;)rhs).equal((Dr1</span> <span class="pre">const&amp;)lhs)</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &lt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,bool&gt;::type<br />operator &gt;=(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />            iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block" id="minus">template &lt;class Dr1, class V1, class TC1, class R1, class D1,<br />          class Dr2, class V2, class TC2, class R2, class D2&gt;<br />typename enable_if_interoperable&lt;Dr1,Dr2,difference&gt;::type<br />operator -(iterator_facade&lt;Dr1,V1,TC1,R1,D1&gt; const&amp; lhs,<br />           iterator_facade&lt;Dr2,V2,TC2,R2,D2&gt; const&amp; rhs);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回类型：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <blockquote>
        
        
        
        
        
        
        
        
        
        
        <dl class="docutils">











          <dt>则</dt>











          <dd>
            
            
            
            
            
            
            
            
            
            
            <p class="first last"><tt class="docutils literal"><span class="pre">difference</span></tt> shall be
            <tt class="docutils literal"><span class="pre">iterator_traits&lt;Dr1&gt;::difference_type</span></tt>.</p>











          </dd>











          <dt>否则</dt>











          <dd>
            
            
            
            
            
            
            
            
            
            
            <p class="first last"><tt class="docutils literal"><span class="pre">difference</span></tt> shall be <tt class="docutils literal"><span class="pre">iterator_traits&lt;Dr2&gt;::difference_type</span></tt></p>











          </dd>











        
        
        
        
        
        
        
        
        
        
        </dl>











      </blockquote>











      </td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">
      
      
      
      
      
      
      
      
      
      
      <p class="first">如果 <tt class="docutils literal"><span class="pre">is_convertible&lt;Dr2,Dr1&gt;::value</span></tt></p>











      
      
      
      
      
      
      
      
      
      
      <dl class="last docutils">











        <dt>则</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">-((Dr1</span> <span class="pre">const&amp;)lhs).distance_to((Dr2</span> <span class="pre">const&amp;)rhs)</span></tt>.</p>











        </dd>











        <dt>否则，</dt>











        <dd>
          
          
          
          
          
          
          
          
          
          
          <p class="first last"><tt class="docutils literal"><span class="pre">((Dr2</span> <span class="pre">const&amp;)rhs).distance_to((Dr1</span> <span class="pre">const&amp;)lhs)</span></tt>.</p>











        </dd>











      
      
      
      
      
      
      
      
      
      
      </dl>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="iterator-adaptor-lib-iterator-adaptor">
<h2><a class="toc-backref" href="#id33">迭代器适配器 [lib.iterator.adaptor]</a></h2>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.1 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG. -->
<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. -->
<p><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 类模板的每个<tt class="docutils literal"><span class="pre"></span></tt>特化类都派生自 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的某个特化类。<tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 所需要的各个核心接口函数依据
<tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的 <tt class="docutils literal"><span class="pre">Base</span></tt> 模板参数而实现。派生自 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的类通常要重定义某些核心接口函数来调整 <tt class="docutils literal"><span class="pre">Base</span></tt> 类型的行为。这个派生类是否符合某个标准迭代器概念，取决于 <tt class="docutils literal"><span class="pre">Base</span></tt> 类型所支持的操作以及 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt> 的哪些核心接口函数被
<tt class="docutils literal"><span class="pre">Derived</span></tt> 类重新定义。</p>











<div class="section" id="class-template-iterator-adaptor">
<h3><a class="toc-backref" href="#id34">类模板 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt></a></h3>











<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.4 of this ReStructuredText document corresponds to
n1530_, the paper accepted by the LWG for TR1. -->
<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. -->
<pre class="literal-block">template &lt;<br />    class Derived<br />  , class Base<br />  , class Value               = use_default<br />  , class CategoryOrTraversal = use_default<br />  , class Reference           = use_default<br />  , class Difference = use_default<br />&gt;<br />class iterator_adaptor<br />  : public iterator_facade&lt;Derived, <em>V'</em>, <em>C'</em>, <em>R'</em>, <em>D'</em>&gt; // 请见 <a class="reference internal" href="#base-parameters">详细说明</a><br />{<br />    friend class iterator_core_access;<br /> public:<br />    iterator_adaptor();<br />    explicit iterator_adaptor(Base const&amp; iter);<br />    typedef Base base_type;<br />    Base const&amp; base() const;<br /> protected:<br />    typedef iterator_adaptor iterator_adaptor_;<br />    Base const&amp; base_reference() const;<br />    Base&amp; base_reference();<br /> private: // iterator_facade 的核心迭代器接口<br />    typename iterator_adaptor::reference dereference() const;<br /><br />    template &lt;<br />    class OtherDerived, class OtherIterator, class V, class C, class R, class D<br />    &gt;<br />    bool equal(iterator_adaptor&lt;OtherDerived, OtherIterator, V, C, R, D&gt; const&amp; x) const;<br /><br />    void advance(typename iterator_adaptor::difference_type n);<br />    void increment();<br />    void decrement();<br /><br />    template &lt;<br />        class OtherDerived, class OtherIterator, class V, class C, class R, class D<br />    &gt;<br />    typename iterator_adaptor::difference_type distance_to(<br />        iterator_adaptor&lt;OtherDerived, OtherIterator, V, C, R, D&gt; const&amp; y) const;<br /><br /> private:<br />    Base m_iterator; // exposition only<br />};<br /></pre>











</div>











<div class="section" id="iterator-adaptor-requirements">
<span id="requirements"></span>
<h3><a class="toc-backref" href="#id35"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的要求</a></h3>











<p><tt class="docutils literal"><span class="pre">static_cast&lt;Derived*&gt;(iterator_adaptor*)</span></tt> 必须是合法的。<tt class="docutils literal"><span class="pre">Base</span></tt> 参数必须是可赋值和可复制构造的。</p>











</div>











<div class="section" id="iterator-adaptor-base-class-parameters">
<span id="base-parameters"></span>
<h3><a class="toc-backref" href="#id36"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的基类参数</a></h3>











<p>上面的 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 摘要中的基类 <tt class="docutils literal"><span class="pre">iterator_facade</span></tt>
的 <em>V'</em>, <em>C'</em>, <em>R'</em>, 和 <em>D'</em> &nbsp;参数定义如下：</p>











<pre class="literal-block"><em>V'</em> = if (Value 为 use_default)<br />          return iterator_traits&lt;Base&gt;::value_type<br />      else<br />          return Value<br /><br /><em>C'</em> = if (CategoryOrTraversal 为 use_default)<br />          return iterator_traversal&lt;Base&gt;::type<br />      else<br />          return CategoryOrTraversal<br /><br /><em>R'</em> = if (Reference 为 use_default)<br />          if (Value 为 use_default)<br />              return iterator_traits&lt;Base&gt;::reference<br />          else<br />              return Value&amp;<br />      else<br />          return Reference<br /><br /><em>D'</em> = if (Difference 为 use_default)<br />          return iterator_traits&lt;Base&gt;::difference_type<br />      else<br />          return Difference<br /></pre>











<!-- ``iterator_adaptor`` models
- - - - - - - - - - - - - - - - - - - - - - - - - - -

In order for ``Derived`` to model the iterator concepts corresponding
to ``iterator_traits<Derived>::iterator_category``, the expressions
involving ``m_iterator`` in the specifications of those private member
functions of ``iterator_adaptor`` that may be called by
``iterator_facade<Derived, V, C, R, D>`` in evaluating any valid
expression involving ``Derived`` in those concepts' requirements. -->
<!-- The above is confusing and needs a rewrite. -JGS -->
<!-- That's why it's removed.  We're embracing inheritance, remember? -->
</div>











<div class="section" id="iterator-adaptor-public-operations">
<h3><a class="toc-backref" href="#id37"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的公有操作</a></h3>











<p><tt class="docutils literal"><span class="pre">iterator_adaptor();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">Base</span></tt> 类型必须是可缺省构造的。</td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 实例，其中的
      <tt class="docutils literal"><span class="pre">m_iterator</span></tt> 为缺省构造。</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">explicit</span> <span class="pre">iterator_adaptor(Base</span> <span class="pre">const&amp;</span> <span class="pre">iter);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个 <tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 实例，其中的
      <tt class="docutils literal"><span class="pre">m_iterator</span></tt> 从 <tt class="docutils literal"><span class="pre">iter</span></tt> 复制构造。</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Base</span> <span class="pre">const&amp;</span> <span class="pre">base()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>






<br />






</div>











<div class="section" id="iterator-adaptor-protected-member-functions">
<h3><a class="toc-backref" href="#id38"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的保护成员函数</a></h3>











<p><tt class="docutils literal"><span class="pre">Base</span> <span class="pre">const&amp;</span> <span class="pre">base_reference()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span></tt> 的一个常量引用。</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Base&amp;</span> <span class="pre">base_reference();</span></tt></p>
















  
<table class="docutils field-list" frame="void" rules="none">






  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span></tt> 的一个非常量引用。</td>






    </tr>






  
  
  
  
  
  
  </tbody>
</table>






<br />






</div>











<div class="section" id="iterator-adaptor-private-member-functions">
<h3><a class="toc-backref" href="#id39"><tt class="docutils literal"><span class="pre">iterator_adaptor</span></tt> 的私有成员函数</a></h3>











<p><tt class="docutils literal"><span class="pre">typename</span> <span class="pre">iterator_adaptor::reference</span> <span class="pre">dereference()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;<br />class OtherDerived, class OtherIterator, class V, class C, class R, class D<br />&gt;<br />bool equal(iterator_adaptor&lt;OtherDerived, OtherIterator, V, C, R, D&gt; const&amp; x) const;<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span> <span class="pre">==</span> <span class="pre">x.base()</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">void</span> <span class="pre">advance(typename</span> <span class="pre">iterator_adaptor::difference_type</span> <span class="pre">n);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span> <span class="pre">+=</span> <span class="pre">n;</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">void</span> <span class="pre">increment();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">++m_iterator;</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">void</span> <span class="pre">decrement();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">--m_iterator;</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;<br />    class OtherDerived, class OtherIterator, class V, class C, class R, class D<br />&gt;<br />typename iterator_adaptor::difference_type distance_to(<br />    iterator_adaptor&lt;OtherDerived, OtherIterator, V, C, R, D&gt; const&amp; y) const;<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">y.base()</span> <span class="pre">-</span> <span class="pre">m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>






<br />






</div>











</div>











<div class="section" id="specialized-adaptors-lib-iterator-special-adaptors">
<h2><a class="toc-backref" href="#id40">特定的适配器 [lib.iterator.special.adaptors]</a></h2>











<p>本节中所使用的 <tt class="docutils literal"><span class="pre">enable_if_convertible&lt;X,Y&gt;::type</span></tt> 表达式是为了说明的目的。特定适配器的转换构造函数应该只是一组重载，使得类型 <tt class="docutils literal"><span class="pre">X</span></tt> 的对象可以隐式转换为 <tt class="docutils literal"><span class="pre">Y</span></tt> 的对象。<tt class="docutils literal"><span class="pre">enable_if_convertible</span></tt> 的符合特征应该象以下所定义的<em></em> <tt class="docutils literal"><span class="pre">enable_if_convertible</span></tt> 那样：</p>











<pre class="literal-block">template &lt;bool&gt; enable_if_convertible_impl<br />{};<br /><br />template &lt;&gt; enable_if_convertible_impl&lt;true&gt;<br />{ struct type; };<br /><br />template&lt;typename From, typename To&gt;<br />struct enable_if_convertible<br />  : enable_if_convertible_impl&lt;is_convertible&lt;From,To&gt;::value&gt;<br />{};<br /></pre>











<p>如果一个非缺省参数表达式被用作函数参数的值，而该参数的类型是根据 <tt class="docutils literal"><span class="pre">enable_if_convertible</span></tt> 来写的，那么程序就是错误的，无需诊断。</p>











<p>[<em>注：</em><tt class="docutils literal"><span class="pre">enable_if_convertible</span></tt> 方法使用了 SFINAE，当类型不能被隐式转换时，将某个构造函数排除出重载集。]</p>











<div class="section" id="indirect-iterator">
<h3><a class="toc-backref" href="#id41">间接迭代器</a></h3>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 改编一个迭代器，改编的方法是在 <tt class="docutils literal"><span class="pre">operator*()</span></tt> 中多使用一次提领。例如，该迭代器适配器可以用于察看一个指针容器(如 <tt class="docutils literal"><span class="pre">list&lt;foo*&gt;</span></tt>)，就象它是一个所指类型的容器(如 <tt class="docutils literal"><span class="pre">list&lt;foo&gt;</span></tt>)一样。<tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 依赖于两个辅助 traits, <tt class="docutils literal"><span class="pre">pointee</span></tt> 和 <tt class="docutils literal"><span class="pre">indirect_reference</span></tt>, 它们提供了对于那些 <tt class="docutils literal"><span class="pre">value_type</span></tt> 不是一个迭代器的底层迭代器的支持。</p>











<div class="section" id="class-template-pointee">
<h4><a class="toc-backref" href="#id42">类模板 <tt class="docutils literal"><span class="pre">pointee</span></tt></a></h4>











<!-- Copyright David Abrahams 2004. Use, modification and distribution is -->
<!-- subject to the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<pre class="literal-block">template &lt;class Dereferenceable&gt;<br />struct pointee<br />{<br />    typedef /* 见下文 */ type;<br />};<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body">对于类型&nbsp;<tt class="docutils literal"><span class="pre">Dereferenceable</span></tt> 的一个对象 <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">*x</span></tt>
是合法的。如果 <tt class="docutils literal"><span class="pre">++x</span></tt> 是非法的，那么它应该既不是歧义的，也不违犯访问控制，且
      <tt class="docutils literal"><span class="pre">Dereferenceable::element_type</span></tt> 应该是一个可访问的类型。否则 <tt class="docutils literal"><span class="pre">iterator_traits&lt;Dereferenceable&gt;::value_type</span></tt> 就应该是合法的。[注：这些要求无需适用于 <tt class="docutils literal"><span class="pre">pointee</span></tt> 的显式特化或偏特化]</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">type</span></tt> 按以下算法确定，其中
<tt class="docutils literal"><span class="pre">x</span></tt> 为类型 <tt class="docutils literal"><span class="pre">Dereferenceable</span></tt> 的一个对象：</p>











<pre class="literal-block">if ( ++x 是非法的 )<br />{<br />    return ``Dereferenceable::element_type``<br />}<br />else if (``*x`` 是一个 std::iterator_traits&lt;Dereferenceable&gt;::value_type 的非常量引用)<br />{<br />    return iterator_traits&lt;Dereferenceable&gt;::value_type<br />}<br />else<br />{<br />    return iterator_traits&lt;Dereferenceable&gt;::value_type const<br />}<br /></pre>











</div>











<div class="section" id="class-template-indirect-reference">
<h4><a class="toc-backref" href="#id43">类模板 <tt class="docutils literal"><span class="pre">indirect_reference</span></tt></a></h4>











<!-- Copyright David Abrahams 2004. Use, modification and distribution is -->
<!-- subject to the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<pre class="literal-block">template &lt;class Dereferenceable&gt;<br />struct indirect_reference<br />{<br />    typedef /* 见下文 */ type;<br />};<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body">对于类型<tt class="docutils literal"><span class="pre"></span></tt> <tt class="docutils literal"><span class="pre">Dereferenceable</span></tt> 的一个对象 <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">*x</span></tt>
是合法的。如果 <tt class="docutils literal"><span class="pre">++x</span></tt> 是非法的，那么它应该既不是歧义的，也不违犯访问控制，且
      <tt class="docutils literal"><span class="pre">pointee&lt;Dereferenceable&gt;::type&amp;</span></tt> 应该是合法的。否则 <tt class="docutils literal"><span class="pre">iterator_traits&lt;Dereferenceable&gt;::reference</span></tt> 就应该是合法的。[注：这些要求无需适用于<tt class="docutils literal"><span class="pre">indirect_reference</span></tt> 的显式特化或偏特化]</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">type</span></tt> 按以下算法确定，其中
<tt class="docutils literal"><span class="pre">x</span></tt> 为类型 <tt class="docutils literal"><span class="pre">Dereferenceable</span></tt> 的一个对象：</p>











<pre class="literal-block">if ( ++x 是非法的 )<br />    return ``pointee&lt;Dereferenceable&gt;::type&amp;``<br />else<br />    std::iterator_traits&lt;Dereferenceable&gt;::reference<br /></pre>











</div>











<div class="section" id="class-template-indirect-iterator">
<h4><a class="toc-backref" href="#id44">类模板 <tt class="docutils literal"><span class="pre">indirect_iterator</span></tt></a></h4>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<pre class="literal-block">template &lt;<br />    class Iterator<br />  , class Value = use_default<br />  , class CategoryOrTraversal = use_default<br />  , class Reference = use_default<br />  , class Difference = use_default<br />&gt;<br />class indirect_iterator<br />{<br /> public:<br />    typedef /* 见下文 */ value_type;<br />    typedef /* 见下文 */ reference;<br />    typedef /* 见下文 */ pointer;<br />    typedef /* 见下文 */ difference_type;<br />    typedef /* 见下文 */ iterator_category;<br /><br />    indirect_iterator();<br />    indirect_iterator(Iterator x);<br /><br />    template &lt;<br />        class Iterator2, class Value2, class Category2<br />      , class Reference2, class Difference2<br />    &gt;<br />    indirect_iterator(<br />        indirect_iterator&lt;<br />             Iterator2, Value2, Category2, Reference2, Difference2<br />        &gt; const&amp; y<br />      , typename enable_if_convertible&lt;Iterator2, Iterator&gt;::type* = 0 // exposition<br />    );<br /><br />    Iterator const&amp; base() const;<br />    reference operator*() const;<br />    indirect_iterator&amp; operator++();<br />    indirect_iterator&amp; operator--();<br />private:<br />   Iterator m_iterator; // exposition<br />};<br /></pre>











<p><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的成员类型按以下伪代码定义，其中 <tt class="docutils literal"><span class="pre">V</span></tt> 为
<tt class="docutils literal"><span class="pre">iterator_traits&lt;Iterator&gt;::value_type</span></tt></p>











<pre class="literal-block">if (Value 是 use_default) then<br />    typedef remove_const&lt;pointee&lt;V&gt;::type&gt;::type value_type;<br />else<br />    typedef remove_const&lt;Value&gt;::type value_type;<br /><br />if (Reference 是 use_default) then<br />    if (Value 是 use_default) then<br />        typedef indirect_reference&lt;V&gt;::type reference;<br />    else<br />        typedef Value&amp; reference;<br />else<br />    typedef Reference reference;<br /><br />if (Value 是 use_default) then<br />    typedef pointee&lt;V&gt;::type* pointer;<br />else<br />    typedef Value* pointer;<br /><br />if (Difference 是 use_default)<br />    typedef iterator_traits&lt;Iterator&gt;::difference_type difference_type;<br />else<br />    typedef Difference difference_type;<br /><br />if (CategoryOrTraversal 是 use_default)<br />    typedef <em>iterator-category</em> (<br />        iterator_traversal&lt;Iterator&gt;::type,``reference``,``value_type``<br />    ) iterator_category;<br />else<br />    typedef <em>iterator-category</em> (<br />        CategoryOrTraversal,``reference``,``value_type``<br />    ) iterator_category;<br /></pre>











</div>











<div class="section" id="indirect-iterator-requirements">
<h4><a class="toc-backref" href="#id45"><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的要求</a></h4>











<p>表达式 <tt class="docutils literal"><span class="pre">*v</span></tt> 应是有效表达式且可转换为 <tt class="docutils literal"><span class="pre">reference</span></tt>，其中 <tt class="docutils literal"><span class="pre">v</span></tt> 是
<tt class="docutils literal"><span class="pre">iterator_traits&lt;Iterator&gt;::value_type</span></tt> 的对象。<tt class="docutils literal"><span class="pre">Iterator</span></tt> 应符合 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 所表示的遍历概念。<tt class="docutils literal"><span class="pre">Value</span></tt>, <tt class="docutils literal"><span class="pre">Reference</span></tt>, 和 <tt class="docutils literal"><span class="pre">Difference</span></tt> 的选择应使得 <tt class="docutils literal"><span class="pre">value_type</span></tt>, <tt class="docutils literal"><span class="pre">reference</span></tt>, 和 <tt class="docutils literal"><span class="pre">difference_type</span></tt> 满足 <tt class="docutils literal"><span class="pre">iterator_category</span></tt>&nbsp;的要求。</p>











<p>[注：如果 <tt class="docutils literal"><span class="pre">Value</span></tt> 参数不是  <tt class="docutils literal"><span class="pre">use_default</span></tt>，则对于
<tt class="docutils literal"><span class="pre">iterator_traits&lt;Iterator&gt;::value_type</span></tt> 还有更多要求，如算法所暗示的可以推断出 <tt class="docutils literal"><span class="pre">value_type</span></tt> 成员的缺省值。]</p>











</div>











<div class="section" id="indirect-iterator-models">
<h4><a class="toc-backref" href="#id46"><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的模型</a></h4>











<p>除了 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 和 <tt class="docutils literal"><span class="pre">iterator_traversal&lt;indirect_iterator&gt;::type</span></tt> 所表示的概念之外，<tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的特化类还符合以下概念，其中 <tt class="docutils literal"><span class="pre">v</span></tt> 为
<tt class="docutils literal"><span class="pre">iterator_traits&lt;Iterator&gt;::value_type</span></tt> 对象：</p>











<blockquote>
  
  
  
  
  
  
  
  
  
  
  <ul class="simple">











    <li>可读迭代器，如果 <tt class="docutils literal"><span class="pre">reference(*v)</span></tt> 可转换为
      <tt class="docutils literal"><span class="pre">value_type</span></tt>.</li>











    <li>可写迭代器，如果 <tt class="docutils literal"><span class="pre">reference(*v)</span> <span class="pre">=</span> <span class="pre">t</span></tt> 是有效表达式(其中 <tt class="docutils literal"><span class="pre">t</span></tt> 是 <tt class="docutils literal"><span class="pre">indirect_iterator::value_type</span></tt> 对象)</li>











    <li>左值迭代器，如果 <tt class="docutils literal"><span class="pre">reference</span></tt> 是引用类型。</li>











  
  
  
  
  
  
  
  
  
  
  </ul>











</blockquote>











<p><tt class="docutils literal"><span class="pre">indirect_iterator&lt;X,V1,C1,R1,D1&gt;</span></tt> 与
<tt class="docutils literal"><span class="pre">indirect_iterator&lt;Y,V2,C2,R2,D2&gt;</span></tt> 可交互，当且仅当 <tt class="docutils literal"><span class="pre">X</span></tt> 与 <tt class="docutils literal"><span class="pre">Y</span></tt> 是可交互的。</p>











</div>











<div class="section" id="indirect-iterator-operations">
<h4><a class="toc-backref" href="#id47"><tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的操作</a></h4>











<p>除了上述概念所要求的操作以外，<tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 的特化类还提供了以下操作。</p>











<p><tt class="docutils literal"><span class="pre">indirect_iterator();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">Iterator</span></tt> 必须是可缺省构造的。</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 实例，带有一个缺省构造的 <tt class="docutils literal"><span class="pre">m_iterator</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">indirect_iterator(Iterator</span> <span class="pre">x);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 实例，带有一个从<tt class="docutils literal"><span class="pre"></span></tt> <tt class="docutils literal"><span class="pre">x</span></tt> 复制构造得到的
      <tt class="docutils literal"><span class="pre">m_iterator</span></tt><tt class="docutils literal"><span class="pre"></span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;<br />    class Iterator2, class Value2, unsigned Access, class Traversal<br />  , class Reference2, class Difference2<br />&gt;<br />indirect_iterator(<br />    indirect_iterator&lt;<br />         Iterator2, Value2, Access, Traversal, Reference2, Difference2<br />    &gt; const&amp; y<br />  , typename enable_if_convertible&lt;Iterator2, Iterator&gt;::type* = 0 // exposition<br />);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">Iterator2</span></tt> 可隐式转换为 <tt class="docutils literal"><span class="pre">Iterator</span></tt>.</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">indirect_iterator</span></tt> 实例，其 <tt class="docutils literal"><span class="pre">m_iterator</span></tt> 子对象构造自 <tt class="docutils literal"><span class="pre">y.base()</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Iterator</span> <span class="pre">const&amp;</span> <span class="pre">base()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">reference</span> <span class="pre">operator*()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">**m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">indirect_iterator&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">++m_iterator</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">indirect_iterator&amp;</span> <span class="pre">operator--();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">--m_iterator</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="reverse-iterator">
<h3><a class="toc-backref" href="#id48">反序迭代器</a></h3>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p>反序迭代器适配器以相反的方向遍历被改编的迭代器的区间。</p>











<div class="section" id="class-template-reverse-iterator">
<h4><a class="toc-backref" href="#id49">类模板 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt></a></h4>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<pre class="literal-block">template &lt;class Iterator&gt;<br />class reverse_iterator<br />{<br />public:<br />  typedef iterator_traits&lt;Iterator&gt;::value_type value_type;<br />  typedef iterator_traits&lt;Iterator&gt;::reference reference;<br />  typedef iterator_traits&lt;Iterator&gt;::pointer pointer;<br />  typedef iterator_traits&lt;Iterator&gt;::difference_type difference_type;<br />  typedef /* 见下文 */ iterator_category;<br /><br />  reverse_iterator() {}<br />  explicit reverse_iterator(Iterator x) ;<br /><br />  template&lt;class OtherIterator&gt;<br />  reverse_iterator(<br />      reverse_iterator&lt;OtherIterator&gt; const&amp; r<br />    , typename enable_if_convertible&lt;OtherIterator, Iterator&gt;::type* = 0 // exposition<br />  );<br />  Iterator const&amp; base() const;<br />  reference operator*() const;<br />  reverse_iterator&amp; operator++();<br />  reverse_iterator&amp; operator--();<br />private:<br />  Iterator m_iterator; // exposition<br />};<br /></pre>











<p>如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合随机访问遍历迭代器及可读左值迭代器，则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为
<tt class="docutils literal"><span class="pre">random_access_iterator_tag</span></tt>. 否则，如果
<tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合双向遍历迭代器及可读左值迭代器，则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为
<tt class="docutils literal"><span class="pre">bidirectional_iterator_tag</span></tt>. 否则，<tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">input_iterator_tag</span></tt>.</p>











</div>











<div class="section" id="reverse-iterator-requirements">
<h4><a class="toc-backref" href="#id50"><tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 的要求</a></h4>











<p><tt class="docutils literal"><span class="pre">Iterator</span></tt> 必须符合双向遍历迭代器。类型 <tt class="docutils literal"><span class="pre">iterator_traits&lt;Iterator&gt;::reference</span></tt> 必须是
<tt class="docutils literal"><span class="pre">*i</span></tt> 的类型，其中 <tt class="docutils literal"><span class="pre">i</span></tt> 为类型 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 的一个对象。</p>











</div>











<div class="section" id="reverse-iterator-models">
<h4><a class="toc-backref" href="#id51"><tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 的模型</a></h4>











<p><tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 的特化类所符合的迭代器遍历概念和迭代器访问概念与它的 <tt class="docutils literal"><span class="pre">Iterator</span></tt>
参数所符合的相同。此外，它还可能符合下表中所指定的旧式迭代器概念：</p>











<table class="docutils" border="1">











  <colgroup><col width="53%" /><col width="47%" /></colgroup>
  <thead valign="bottom">
  <tr>










    <th class="head">如果 <tt class="docutils literal"><span class="pre">I</span></tt> 符合</th>











    <th class="head">则&nbsp;<tt class="docutils literal"><span class="pre">reverse_iterator&lt;I&gt;</span></tt> 符合</th>











  </tr>











  </thead>
  <tbody valign="top">











    <tr>










      <td>可读左值迭代器，双向遍历迭代器</td>











      <td>双向迭代器</td>











    </tr>











    <tr>










      <td>可写左值迭代器，双向遍历迭代器</td>











      <td>非常量双向迭代器</td>











    </tr>











    <tr>










      <td>可读左值迭代器，随机访问遍历迭代器</td>











      <td>随机访问迭代器</td>











    </tr>











    <tr>










      <td>可写左值迭代器，随机访问遍历迭代器</td>











      <td>非常量随机访问迭代器</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">reverse_iterator&lt;X&gt;</span></tt> 与
<tt class="docutils literal"><span class="pre">reverse_iterator&lt;Y&gt;</span></tt> 可交互，当且仅当 <tt class="docutils literal"><span class="pre">X</span></tt> 与
<tt class="docutils literal"><span class="pre">Y</span></tt> 是可交互的。</p>











</div>











<div class="section" id="reverse-iterator-operations">
<h4><a class="toc-backref" href="#id52"><tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 的操作</a></h4>











<p>除了
<tt class="docutils literal"><span class="pre">reverse_iterator</span></tt>&nbsp;符合的概念所要求的操作以外，<tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 还提供了以下操作。</p>











<p><tt class="docutils literal"><span class="pre">reverse_iterator();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">Iterator</span></tt> 必须是可缺省构造的。</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 实例，带有缺省构造的 <tt class="docutils literal"><span class="pre">m_iterator</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">explicit</span> <span class="pre">reverse_iterator(Iterator</span> <span class="pre">x);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 实例，带有从 <tt class="docutils literal"><span class="pre">x</span></tt> 复制构造所得的
      <tt class="docutils literal"><span class="pre">m_iterator</span></tt><tt class="docutils literal"><span class="pre"></span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template&lt;class OtherIterator&gt;<br />reverse_iterator(<br />    reverse_iterator&lt;OtherIterator&gt; const&amp; r<br />  , typename enable_if_convertible&lt;OtherIterator, Iterator&gt;::type* = 0 // exposition<br />);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">OtherIterator</span></tt> 可隐式转换为 <tt class="docutils literal"><span class="pre">Iterator</span></tt>.</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">reverse_iterator</span></tt> 实例，其
      <tt class="docutils literal"><span class="pre">m_iterator</span></tt> 子对象构造自 <tt class="docutils literal"><span class="pre">y.base()</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Iterator</span> <span class="pre">const&amp;</span> <span class="pre">base()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">reference</span> <span class="pre">operator*()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">Iterator tmp = m_iterator;<br />return *--tmp;<br /></pre>











<p><tt class="docutils literal"><span class="pre">reverse_iterator&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">--m_iterator</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">reverse_iterator&amp;</span> <span class="pre">operator--();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">++m_iterator</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="transform-iterator">
<h3><a class="toc-backref" href="#id53">转换迭代器</a></h3>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p>转换迭代器改编一个迭代器，将
<tt class="docutils literal"><span class="pre">operator*</span></tt> 改为对迭代器提领得到的值应用于一个函数对象，然后返回函数调用的结果。</p>











<div class="section" id="class-template-transform-iterator">
<h4><a class="toc-backref" href="#id54">类模板 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt></a></h4>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.3 of this document was accepted for TR1 -->
<pre class="literal-block">template &lt;class UnaryFunction,<br />          class Iterator,<br />          class Reference = use_default,<br />          class Value = use_default&gt;<br />class transform_iterator<br />{<br />public:<br />  typedef /* 见下文 */ value_type;<br />  typedef /* 见下文 */ reference;<br />  typedef /* 见下文 */ pointer;<br />  typedef iterator_traits&lt;Iterator&gt;::difference_type difference_type;<br />  typedef /* 见下文 */ iterator_category;<br /><br />  transform_iterator();<br />  transform_iterator(Iterator const&amp; x, UnaryFunction f);<br /><br />  template&lt;class F2, class I2, class R2, class V2&gt;<br />  transform_iterator(<br />        transform_iterator&lt;F2, I2, R2, V2&gt; const&amp; t<br />      , typename enable_if_convertible&lt;I2, Iterator&gt;::type* = 0      // exposition only<br />      , typename enable_if_convertible&lt;F2, UnaryFunction&gt;::type* = 0 // exposition only<br />  );<br />  UnaryFunction functor() const;<br />  Iterator const&amp; base() const;<br />  reference operator*() const;<br />  transform_iterator&amp; operator++();<br />  transform_iterator&amp; operator--();<br />private:<br />  Iterator m_iterator; // exposition only<br />  UnaryFunction m_f;   // exposition only<br />};<br /></pre>











<p>如果 <tt class="docutils literal"><span class="pre">Reference</span></tt> 为 <tt class="docutils literal"><span class="pre">use_default</span></tt> 则
<tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的 <tt class="docutils literal"><span class="pre">reference</span></tt> 成员为
<tt class="docutils literal"><span class="pre">result_of&lt;UnaryFunction(iterator_traits&lt;Iterator&gt;::reference)&gt;::type</span></tt>.
否则，<tt class="docutils literal"><span class="pre">reference</span></tt> 为 <tt class="docutils literal"><span class="pre">Reference</span></tt>.</p>











<p>如果 <tt class="docutils literal"><span class="pre">Value</span></tt> 为 <tt class="docutils literal"><span class="pre">use_default</span></tt> 则 <tt class="docutils literal"><span class="pre">value_type</span></tt> 成员为
<tt class="docutils literal"><span class="pre">remove_cv&lt;remove_reference&lt;reference&gt;</span> <span class="pre">&gt;::type</span></tt>. 否则，<tt class="docutils literal"><span class="pre">value_type</span></tt> 为 <tt class="docutils literal"><span class="pre">Value</span></tt>.</p>











<p>如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合可读左值迭代器，并且 <tt class="docutils literal"><span class="pre">Iterator</span></tt>
符合随机访问遍历迭代器，则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">random_access_iterator_tag</span></tt>. 否则，如果
<tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合双向遍历迭代器，则
<tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为
<tt class="docutils literal"><span class="pre">bidirectional_iterator_tag</span></tt>.  否则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">forward_iterator_tag</span></tt>. 如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 不符合可读左值迭代器则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">input_iterator_tag</span></tt>.</p>











</div>











<div class="section" id="transform-iterator-requirements">
<h4><a class="toc-backref" href="#id55"><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的要求</a></h4>











<p>类型 <tt class="docutils literal"><span class="pre">UnaryFunction</span></tt> 必须是可赋值的、可复制构造的，并且表达式 <tt class="docutils literal"><span class="pre">f(*i)</span></tt> 必须是有效的，其中 <tt class="docutils literal"><span class="pre">f</span></tt> 为类型 <tt class="docutils literal"><span class="pre">UnaryFunction</span></tt> 的一个对象，<tt class="docutils literal"><span class="pre">i</span></tt> 为类型 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 的一个对象，<tt class="docutils literal"><span class="pre">f(*i)</span></tt> 的类型必须是
<tt class="docutils literal"><span class="pre">result_of&lt;UnaryFunction(iterator_traits&lt;Iterator&gt;::reference)&gt;::type</span></tt>.</p>











<p>参数 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 应符合可读迭代器。</p>











</div>











<div class="section" id="transform-iterator-models">
<h4><a class="toc-backref" href="#id56"><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的模型</a></h4>











<p><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的结果符合以下概念中 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 所符合的最强化的一个。</p>











<blockquote>
  
  
  
  
  
  
  
  
  
  
  <ul class="simple">











    <li>可写左值迭代器，如果 <tt class="docutils literal"><span class="pre">transform_iterator::reference</span></tt> 为非常量引用。</li>











    <li>可读左值迭代器，如果 <tt class="docutils literal"><span class="pre">transform_iterator::reference</span></tt> 为常量引用。</li>











    <li>否则，可读迭代器。</li>











  
  
  
  
  
  
  
  
  
  
  </ul>











</blockquote>











<p><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 符合其 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 参数所符合的最强化的标准遍历概念。</p>











<p>如果 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 符合可读左值迭代器，则它依据其 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 参数的情况符合以下原有迭代器概念。</p>











<table class="docutils" border="1">











  <colgroup><col width="47%" /><col width="53%" /></colgroup>
  <thead valign="bottom">
  <tr>










    <th class="head">如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合</th>











    <th class="head">则&nbsp;<tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 符合</th>











  </tr>











  </thead>
  <tbody valign="top">











    <tr>










      <td>单遍迭代器</td>











      <td>输入迭代器</td>











    </tr>











    <tr>










      <td>前向遍历迭代器</td>











      <td>前向迭代器</td>











    </tr>











    <tr>










      <td>双向遍历迭代器</td>











      <td>双向迭代器</td>











    </tr>











    <tr>










      <td>随机访问遍历迭代器</td>











      <td>随机访问迭代器</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p>如果 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 符合可写左值迭代器，则它为非常量迭代器(参照旧式迭代器要求中的定义)。</p>











<p><tt class="docutils literal"><span class="pre">transform_iterator&lt;F1,</span> <span class="pre">X,</span> <span class="pre">R1,</span> <span class="pre">V1&gt;</span></tt> 与
<tt class="docutils literal"><span class="pre">transform_iterator&lt;F2,</span> <span class="pre">Y,</span> <span class="pre">R2,</span> <span class="pre">V2&gt;</span></tt> 可交互，当且仅当 <tt class="docutils literal"><span class="pre">X</span></tt> 与 <tt class="docutils literal"><span class="pre">Y</span></tt> 是可交互的。</p>











</div>











<div class="section" id="transform-iterator-operations">
<h4><a class="toc-backref" href="#id57"><tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 的操作</a></h4>











<p>除了
<tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 所符合的概念所要求的操作以外，<tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 还提供了以下操作。</p>











<p><tt class="docutils literal"><span class="pre">transform_iterator();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 实例，带有缺省构造的 <tt class="docutils literal"><span class="pre">m_f</span></tt> 和 <tt class="docutils literal"><span class="pre">m_iterator</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">transform_iterator(Iterator</span> <span class="pre">const&amp;</span> <span class="pre">x,</span> <span class="pre">UnaryFunction</span> <span class="pre">f);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 实例，其 <tt class="docutils literal"><span class="pre">m_f</span></tt>
初始化为 <tt class="docutils literal"><span class="pre">f</span></tt> 且 <tt class="docutils literal"><span class="pre">m_iterator</span></tt> 初始化为 <tt class="docutils literal"><span class="pre">x</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template&lt;class F2, class I2, class R2, class V2&gt;<br />transform_iterator(<br />      transform_iterator&lt;F2, I2, R2, V2&gt; const&amp; t<br />    , typename enable_if_convertible&lt;I2, Iterator&gt;::type* = 0      // exposition only<br />    , typename enable_if_convertible&lt;F2, UnaryFunction&gt;::type* = 0 // exposition only<br />);<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个 <tt class="docutils literal"><span class="pre">transform_iterator</span></tt> 实例，其 <tt class="docutils literal"><span class="pre">m_f</span></tt>
初始化为 <tt class="docutils literal"><span class="pre">t.functor()</span></tt> 且 <tt class="docutils literal"><span class="pre">m_iterator</span></tt> 初始化为
      <tt class="docutils literal"><span class="pre">t.base()</span></tt>.</td>











    </tr>











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">OtherIterator</span></tt> 可隐式转换为 <tt class="docutils literal"><span class="pre">Iterator</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">UnaryFunction</span> <span class="pre">functor()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_f</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Iterator</span> <span class="pre">const&amp;</span> <span class="pre">base()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">reference</span> <span class="pre">operator*()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_f(*m_iterator)</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">transform_iterator&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">++m_iterator</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">transform_iterator&amp;</span> <span class="pre">operator--();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">--m_iterator</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="filter-iterator">
<h3><a class="toc-backref" href="#id58">过滤迭代器</a></h3>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p>过滤迭代器适配器创建一个迭代器区间的视图，该区间中的某些元素会被跳过。跳过哪些元素是由一个谓词函数对象来控制的。该谓词被应用于某个元素，如果返回 <tt class="docutils literal"><span class="pre">true</span></tt> 则该元素被保留，如果返回 <tt class="docutils literal"><span class="pre">false</span></tt> 则该元素被跳过。跳过了多个元素后，过滤适配器需要知道何时停止，以防止越过底层迭代器区间的末尾。因此一个过滤迭代器要由一对迭代器来构造，这对迭代器表示了被遍历的未过滤序列的元素范围。</p>











<div class="section" id="class-template-filter-iterator">
<h4><a class="toc-backref" href="#id59">类模板 <tt class="docutils literal"><span class="pre">filter_iterator</span></tt></a></h4>











<!-- Copyright David Abrahams, Jeremy Siek, and Thomas Witt -->
<!-- 2004. Use, modification and distribution is subject to the Boost -->
<!-- Software License, Version 1.0. (See accompanying  file -->
<!-- LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<pre class="literal-block">template &lt;class Predicate, class Iterator&gt;<br />class filter_iterator<br />{<br /> public:<br />    typedef iterator_traits&lt;Iterator&gt;::value_type value_type;<br />    typedef iterator_traits&lt;Iterator&gt;::reference reference;<br />    typedef iterator_traits&lt;Iterator&gt;::pointer pointer;<br />    typedef iterator_traits&lt;Iterator&gt;::difference_type difference_type;<br />    typedef /* 见下文 */ iterator_category;<br /><br />    filter_iterator();<br />    filter_iterator(Predicate f, Iterator x, Iterator end = Iterator());<br />    filter_iterator(Iterator x, Iterator end = Iterator());<br />    template&lt;class OtherIterator&gt;<br />    filter_iterator(<br />        filter_iterator&lt;Predicate, OtherIterator&gt; const&amp; t<br />        , typename enable_if_convertible&lt;OtherIterator, Iterator&gt;::type* = 0 // exposition<br />        );<br />    Predicate predicate() const;<br />    Iterator end() const;<br />    Iterator const&amp; base() const;<br />    reference operator*() const;<br />    filter_iterator&amp; operator++();<br />private:<br />    Predicate m_pred; // exposition only<br />    Iterator m_iter;  // exposition only<br />    Iterator m_end;   // exposition only<br />};<br /></pre>











<p>如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合可读左值迭代器及双向遍历迭代器，则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为
<tt class="docutils literal"><span class="pre">std::bidirectional_iterator_tag</span></tt>. 否则，如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合可读左值迭代器及前向遍历迭代器，则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为
<tt class="docutils literal"><span class="pre">std::forward_iterator_tag</span></tt>. 否则 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">std::input_iterator_tag</span></tt>.</p>











</div>











<div class="section" id="filter-iterator-requirements">
<h4><a class="toc-backref" href="#id60"><tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 的要求</a></h4>











<p><tt class="docutils literal"><span class="pre">Iterator</span></tt> 参数应满足可读迭代器和单遍迭代器的要求，或者满足输入迭代器的要求。</p>











<p><tt class="docutils literal"><span class="pre">Predicate</span></tt> 参数必须是可赋值、可复制构造的，且表达式 <tt class="docutils literal"><span class="pre">p(x)</span></tt> 必须有效，其中 <tt class="docutils literal"><span class="pre">p</span></tt> 为类型
<tt class="docutils literal"><span class="pre">Predicate</span></tt> 的一个对象，<tt class="docutils literal"><span class="pre">x</span></tt> 为类型
<tt class="docutils literal"><span class="pre">iterator_traits&lt;Iterator&gt;::value_type</span></tt> 的对象，而
<tt class="docutils literal"><span class="pre">p(x)</span></tt> 的类型必须可转换为 <tt class="docutils literal"><span class="pre">bool</span></tt>.</p>











</div>











<div class="section" id="filter-iterator-models">
<h4><a class="toc-backref" href="#id61"><tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 的模型</a></h4>











<p><tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 所符合的概念取决于其 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 参数所符合的概念，如下表所示：</p>











<table class="docutils" border="1">











  <colgroup><col width="44%" /><col width="56%" /></colgroup>
  <thead valign="bottom">
  <tr>










    <th class="head">如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合</th>











    <th class="head">则&nbsp;<tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 符合</th>











  </tr>











  </thead>
  <tbody valign="top">











    <tr>










      <td>单遍迭代器</td>











      <td>单遍迭代器</td>











    </tr>











    <tr>










      <td>前向遍历迭代器</td>











      <td>前向遍历迭代器</td>











    </tr>











    <tr>










      <td>双向遍历迭代器</td>











      <td>双向遍历迭代器</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<table class="docutils" border="1">











  <colgroup><col width="41%" /><col width="59%" /></colgroup>
  <thead valign="bottom">
  <tr>










    <th class="head">如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合</th>











    <th class="head">则&nbsp;<tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 符合</th>











  </tr>











  </thead>
  <tbody valign="top">











    <tr>










      <td>可读迭代器</td>











      <td>可读迭代器</td>











    </tr>











    <tr>










      <td>可写迭代器</td>











      <td>可写迭代器</td>











    </tr>











    <tr>










      <td>左值迭代器</td>











      <td>左值迭代器</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<table class="docutils" border="1">











  <colgroup><col width="63%" /><col width="38%" /></colgroup>
  <thead valign="bottom">
  <tr>










    <th class="head">如果 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 符合</th>











    <th class="head">则&nbsp;<tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 符合</th>











  </tr>











  </thead>
  <tbody valign="top">











    <tr>










      <td>可读迭代器，单遍迭代器</td>











      <td>输入迭代器</td>











    </tr>











    <tr>










      <td>可读迭代器，前向遍历迭代器</td>











      <td>前向迭代器</td>











    </tr>











    <tr>










      <td>可写迭代器，前向遍历迭代器</td>











      <td>非常量前向迭代器</td>











    </tr>











    <tr>










      <td>可写迭代器，双向遍历迭代器</td>











      <td>非常量双向迭代器</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">filter_iterator&lt;P1,</span> <span class="pre">X&gt;</span></tt> 与 <tt class="docutils literal"><span class="pre">filter_iterator&lt;P2,</span> <span class="pre">Y&gt;</span></tt>
可交互，当且仅当 <tt class="docutils literal"><span class="pre">X</span></tt> 与 <tt class="docutils literal"><span class="pre">Y</span></tt> 是可交互的。</p>











</div>











<div class="section" id="filter-iterator-operations">
<h4><a class="toc-backref" href="#id62"><tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 的操作</a></h4>











<p>除了
<tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 所符合的概念所要求的操作以外，<tt class="docutils literal"><span class="pre">filter_iterator</span></tt> 还提供了以下操作。</p>











<p><tt class="docutils literal"><span class="pre">filter_iterator();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">Predicate</span></tt> 和 <tt class="docutils literal"><span class="pre">Iterator</span></tt> 必须是可缺省构造的。</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">filter_iterator</span></tt>，其中``m_pred``,  <tt class="docutils literal"><span class="pre">m_iter</span></tt>, 和 <tt class="docutils literal"><span class="pre">m_end</span></tt> 成员都是缺省构造的。</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">filter_iterator(Predicate</span> <span class="pre">f,</span> <span class="pre">Iterator</span> <span class="pre">x,</span> <span class="pre">Iterator</span> <span class="pre">end</span> <span class="pre">=</span> <span class="pre">Iterator());</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">filter_iterator</span></tt>，其中 <tt class="docutils literal"><span class="pre">m_iter</span></tt> 要么是区间 <tt class="docutils literal"><span class="pre">[x,end)</span></tt> 中的第一个满足 <tt class="docutils literal"><span class="pre">f(*m_iter)</span> <span class="pre">==</span> <span class="pre">true</span></tt>
的位置，要么``m_iter == end``. 成员 <tt class="docutils literal"><span class="pre">m_pred</span></tt> 构造自 <tt class="docutils literal"><span class="pre">f</span></tt> 而 <tt class="docutils literal"><span class="pre">m_end</span></tt> 构造自 <tt class="docutils literal"><span class="pre">end</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">filter_iterator(Iterator</span> <span class="pre">x,</span> <span class="pre">Iterator</span> <span class="pre">end</span> <span class="pre">=</span> <span class="pre">Iterator());</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">Predicate</span></tt> 必须是可缺省构造的，且 <tt class="docutils literal"><span class="pre">Predicate</span></tt> 是一个类类型(不是函数指针)。</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">filter_iterator</span></tt>，其中 <tt class="docutils literal"><span class="pre">m_iter</span></tt> 要么是区间 <tt class="docutils literal"><span class="pre">[x,end)</span></tt> 中的第一个满足 <tt class="docutils literal"><span class="pre">m_pred(*m_iter)</span> <span class="pre">==</span> <span class="pre">true</span></tt>
的位置，要么``m_iter == end``. 成员 <tt class="docutils literal"><span class="pre">m_pred</span></tt> 是缺省构造的。</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<pre class="literal-block">template &lt;class OtherIterator&gt;<br />filter_iterator(<br />    filter_iterator&lt;Predicate, OtherIterator&gt; const&amp; t<br />    , typename enable_if_convertible&lt;OtherIterator, Iterator&gt;::type* = 0 // exposition<br />    );``<br /></pre>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">OtherIterator</span></tt> 可隐式转换为 <tt class="docutils literal"><span class="pre">Iterator</span></tt>.</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个过滤迭代器，其成员复制自 <tt class="docutils literal"><span class="pre">t</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Predicate</span> <span class="pre">predicate()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_pred</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Iterator</span> <span class="pre">end()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_end</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Iterator</span> <span class="pre">const&amp;</span> <span class="pre">base()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_iterator</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">reference</span> <span class="pre">operator*()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*m_iter</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">filter_iterator&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">递增 <tt class="docutils literal"><span class="pre">m_iter</span></tt> 并持续递增至要么 <tt class="docutils literal"><span class="pre">m_iter</span> <span class="pre">==</span> <span class="pre">m_end</span></tt>，要么 <tt class="docutils literal"><span class="pre">m_pred(*m_iter)</span> <span class="pre">==</span> <span class="pre">true</span></tt>.</td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="counting-iterator">
<h3><a class="toc-backref" href="#id63">计数迭代器</a></h3>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 改编一个对象，为其增加一个 <tt class="docutils literal"><span class="pre">operator*</span></tt>，返回该对象的当前值。所有其它迭代器操作均前转至被改编的对象。</p>











<div class="section" id="class-template-counting-iterator">
<h4><a class="toc-backref" href="#id64">类模板 <tt class="docutils literal"><span class="pre">counting_iterator</span></tt></a></h4>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<pre class="literal-block">template &lt;<br />    class Incrementable<br />  , class CategoryOrTraversal = use_default<br />  , class Difference = use_default<br />&gt;<br />class counting_iterator<br />{<br />public:<br />    typedef Incrementable value_type;<br />    typedef const Incrementable&amp; reference;<br />    typedef const Incrementable* pointer;<br />    typedef /* 见下文 */ difference_type;<br />    typedef /* 见下文 */ iterator_category;<br /><br />    counting_iterator();<br />    counting_iterator(counting_iterator const&amp; rhs);<br />    explicit counting_iterator(Incrementable x);<br />    Incrementable const&amp; base() const;<br />    reference operator*() const;<br />    counting_iterator&amp; operator++();<br />    counting_iterator&amp; operator--();<br />private:<br />    Incrementable m_inc; // exposition<br />};<br /></pre>











<p>如果 <tt class="docutils literal"><span class="pre">Difference</span></tt> 参数为 <tt class="docutils literal"><span class="pre">use_default</span></tt> 则
<tt class="docutils literal"><span class="pre">difference_type</span></tt> 为一个未指定的有符号整型类型。否则 <tt class="docutils literal"><span class="pre">difference_type</span></tt> 为 <tt class="docutils literal"><span class="pre">Difference</span></tt>.</p>











<p><tt class="docutils literal"><span class="pre">iterator_category</span></tt> 根据以下算法决定：</p>











<pre class="literal-block">if (CategoryOrTraversal 不是 use_default)<br />    return CategoryOrTraversal<br />else if (numeric_limits&lt;Incrementable&gt;::is_specialized)<br />    return <a class="reference internal" href="#id12"><em>iterator-category</em></a>(<br />        random_access_traversal_tag, Incrementable, const Incrementable&amp;)<br />else<br />    return <a class="reference internal" href="#id12"><em>iterator-category</em></a>(<br />         iterator_traversal&lt;Incrementable&gt;::type,<br />         Incrementable, const Incrementable&amp;)<br /></pre>











<dl class="docutils">











  <dt>[<em>注：</em>我们建议实现</dt>











  <dd><tt class="docutils literal"><span class="pre">operator-</span></tt> 和一个 <tt class="docutils literal"><span class="pre">difference_type</span></tt> 以避免当 <tt class="docutils literal"><span class="pre">std::numeric_limits&lt;Incrementable&gt;::is_specialized</span></tt> 为 true 时发生溢出。]</dd>











</dl>











</div>











<div class="section" id="counting-iterator-requirements">
<h4><a class="toc-backref" href="#id65"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 的要求</a></h4>











<p><tt class="docutils literal"><span class="pre">Incrementable</span></tt> 参数应该是可复制构造的和可赋值的。</p>











<p>如果 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">forward_iterator_tag</span></tt> 或 <tt class="docutils literal"><span class="pre">forward_traversal_tag</span></tt>, 则以下写法必须是合法的：</p>











<pre class="literal-block">Incrementable i, j;<br />++i;         // 前缀递增<br />i == j;      // operator==<br /></pre>











<p>如果 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为
<tt class="docutils literal"><span class="pre">bidirectional_iterator_tag</span></tt> 或 <tt class="docutils literal"><span class="pre">bidirectional_traversal_tag</span></tt>, 则以下表达式也必须是合法的：</p>











<pre class="literal-block">--i<br /></pre>











<p>如果 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 可转换为
<tt class="docutils literal"><span class="pre">random_access_iterator_tag</span></tt> 或 <tt class="docutils literal"><span class="pre">random_access_traversal_tag</span></tt>, 则以下表达式也必须有效：</p>











<pre class="literal-block">counting_iterator::difference_type n;<br />i += n;<br />n = i - j;<br />i &lt; j;<br /></pre>











</div>











<div class="section" id="counting-iterator-models">
<h4><a class="toc-backref" href="#id66"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 的模型</a></h4>











<p><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 的特化类符合可读左值迭代器。此外，它们还符合可以由其 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 参数转换得到的迭代器 tags 还对应的概念。还有，如果 <tt class="docutils literal"><span class="pre">CategoryOrTraversal</span></tt> 不是 <tt class="docutils literal"><span class="pre">use_default</span></tt>，则
<tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 符合迭代器
tag <tt class="docutils literal"><span class="pre">CategoryOrTraversal</span></tt> 所对应的概念。否则，如果
<tt class="docutils literal"><span class="pre">numeric_limits&lt;Incrementable&gt;::is_specialized</span></tt>, 则
<tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 符合随机访问遍历迭代器。否则，<tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 符合 <tt class="docutils literal"><span class="pre">Incrementable</span></tt> 所符合的迭代器遍历概念。</p>











<p><tt class="docutils literal"><span class="pre">counting_iterator&lt;X,C1,D1&gt;</span></tt> 与
<tt class="docutils literal"><span class="pre">counting_iterator&lt;Y,C2,D2&gt;</span></tt> 可交互，当且仅当 <tt class="docutils literal"><span class="pre">X</span></tt> 与 <tt class="docutils literal"><span class="pre">Y</span></tt> 是可交互的。</p>











</div>











<div class="section" id="counting-iterator-operations">
<h4><a class="toc-backref" href="#id67"><tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 的操作</a></h4>











<p>除了
<tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 所符合的概念所要求的操作以外，<tt class="docutils literal"><span class="pre">counting_iterator</span></tt> 还提供了以下操作。</p>











<p><tt class="docutils literal"><span class="pre">counting_iterator();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">要求：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">Incrementable</span></tt> 是可缺省构造的。</td>











    </tr>











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">缺省构造成员 <tt class="docutils literal"><span class="pre">m_inc</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">counting_iterator(counting_iterator</span> <span class="pre">const&amp;</span> <span class="pre">rhs);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">从 <tt class="docutils literal"><span class="pre">rhs.m_inc</span></tt> 构造成员 <tt class="docutils literal"><span class="pre">m_inc</span></tt><tt class="docutils literal"><span class="pre"></span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">explicit</span> <span class="pre">counting_iterator(Incrementable</span> <span class="pre">x);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">从<tt class="docutils literal"><span class="pre"></span></tt> <tt class="docutils literal"><span class="pre">x</span></tt> 构造成员 <tt class="docutils literal"><span class="pre">m_inc</span></tt><tt class="docutils literal"><span class="pre"></span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">reference</span> <span class="pre">operator*()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_inc</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">counting_iterator&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">++m_inc</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">counting_iterator&amp;</span> <span class="pre">operator--();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">--m_inc</span></tt></td>











    </tr>











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">Incrementable</span> <span class="pre">const&amp;</span> <span class="pre">base()</span> <span class="pre">const;</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">m_inc</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











</div>











</div>











<div class="section" id="function-output-iterator">
<h3><a class="toc-backref" href="#id68">函数输出迭代器</a></h3>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<p>函数输出迭代器适配器可以很容易地创建定制化的输出迭代器。该适配器接受一个单参函数，并创建一个输出迭代器的
model。每一个赋给该输出迭代器的数据都被作为参数传递给给定的单参函数。定义该迭代器的动机是，创建一个符合标准的输出迭代器是有些难度的，尤其是
因为正确的实现通常需要一个代理对象。</p>











<div class="section" id="class-template-function-output-iterator">
<h4><a class="toc-backref" href="#id69">类模板 <tt class="docutils literal"><span class="pre">function_output_iterator</span></tt></a></h4>











<!-- Copyright David Abrahams 2006. Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
</div>











<div class="section" id="header">
<h4><a class="toc-backref" href="#id70">头文件</a></h4>











<pre class="literal-block">#include &lt;boost/function_output_iterator.hpp&gt;<br /></pre>











<pre class="literal-block">template &lt;class UnaryFunction&gt;<br />class function_output_iterator {<br />public:<br />  typedef std::output_iterator_tag iterator_category;<br />  typedef void                     value_type;<br />  typedef void                     difference_type;<br />  typedef void                     pointer;<br />  typedef void                     reference;<br /><br />  explicit function_output_iterator();<br /><br />  explicit function_output_iterator(const UnaryFunction&amp; f);<br /><br />  /* 见下文 */ operator*();<br />  function_output_iterator&amp; operator++();<br />  function_output_iterator&amp; operator++(int);<br />private:<br />  UnaryFunction m_f;     // exposition only<br />};<br /></pre>











</div>











<div class="section" id="function-output-iterator-requirements">
<h4><a class="toc-backref" href="#id71"><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt> 的要求</a></h4>











<p><tt class="docutils literal"><span class="pre">UnaryFunction</span></tt> 必须是可赋值和可复制构造的。</p>











</div>











<div class="section" id="function-output-iterator-models">
<h4><a class="toc-backref" href="#id72"><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt> 的模型</a></h4>











<p><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt> 是可写和可递增迭代器概念的 model.</p>











</div>











<div class="section" id="function-output-iterator-operations">
<h4><a class="toc-backref" href="#id73"><tt class="docutils literal"><span class="pre">function_output_iterator</span></tt> 的操作</a></h4>











<p><tt class="docutils literal"><span class="pre">explicit</span> <span class="pre">function_output_iterator(const</span> <span class="pre">UnaryFunction&amp;</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">UnaryFunction());</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">作用：</th>










      <td class="field-body">构造一个 <tt class="docutils literal"><span class="pre">function_output_iterator</span></tt>
实例，其 <tt class="docutils literal"><span class="pre">m_f</span></tt> 构造自 <tt class="docutils literal"><span class="pre">f</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">operator*();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body">一个未指定类型的对象 <tt class="docutils literal"><span class="pre">r</span></tt>，对于所有 <tt class="docutils literal"><span class="pre">t</span></tt> 满足 <tt class="docutils literal"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">t</span></tt>
等效于 <tt class="docutils literal"><span class="pre">m_f(t)</span></tt>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">function_output_iterator&amp;</span> <span class="pre">operator++();</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p><tt class="docutils literal"><span class="pre">function_output_iterator&amp;</span> <span class="pre">operator++(int);</span></tt></p>











<table class="docutils field-list" frame="void" rules="none">











  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">











    <tr class="field">










      <th class="field-name">返回：</th>










      <td class="field-body"><tt class="docutils literal"><span class="pre">*this</span></tt></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<!-- LocalWords:  Abrahams Siek Witt istream ostream iter MTL strided interoperate
LocalWords:  CRTP metafunctions inlining lvalue JGS incrementable BGL LEDA cv
LocalWords:  GraphBase struct ptrdiff UnaryFunction const int typename bool pp
LocalWords:  lhs rhs SFINAE markup iff tmp OtherDerived OtherIterator DWA foo
LocalWords:  dereferenceable subobject AdaptableUnaryFunction impl pre ifdef'd
LocalWords:  OtherIncrementable Coplien -->
</div>











</div>











</div>











</div>











</div>











<div class="footer">
<hr class="footer" />
<a class="reference external" href="facade-and-adaptor.rst">View document source</a>.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>











</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><!-- Copyright David Abrahams 2006. Distributed under the Boost --><!-- Software License, Version 1.0. (See accompanying --><!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
    <meta name="generator" content="HTML Tidy for Windows (vers 1st August 2002), see www.w3.org">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../boost.css">

    <title>Boost.Python - &lt;boost/python/object.hpp&gt;</title></head>
<body>
    <table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">
      <tbody><tr>
        <td valign="top" width="300">
          <h3><a href="../../../../index.htm"><img alt="C++ Boost" src="../../../../boost.png" border="0" height="86" width="277"></a></h3>
        </td>

        <td valign="top">
          <h1 align="center"><a href="../index.html">Boost.Python</a></h1>

          <h2 align="center">Header &lt;boost/python/object.hpp&gt;</h2>
        </td>
      </tr>
    </tbody></table>
    <hr>

    <h2>Contents</h2>

    <dl class="page-index">
      <dt><a href="#introduction">Introduction</a></dt>

      <dt><a href="#types">Types</a></dt>

      <dd>
        <dl class="page-index">
          <dt><a href="#slice_nil-spec">slice_nil</a></dt>
        </dl>
      </dd>

      <dt><a href="#classes">Classes</a></dt>

      <dd>
        <dl class="page-index">
          <dt><a href="#const_attribute_policies-spec">Class
          <code>const_attribute_policies</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#const_attribute_policies-spec-synopsis">Class
              <code>const_attribute_policies</code> synopsis</a></dt>

              <dt><a href="#const_attribute_policies-spec-statics">Class
              <code>const_attribute_policies</code> static functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#attribute_policies-spec">Class
          <code>attribute_policies</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#attribute_policies-spec-synopsis">Class
              <code>attribute_policies</code> synopsis</a></dt>

              <dt><a href="#attribute_policies-spec-statics">Class
              <code>attribute_policies</code> static functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#const_item_policies-spec">Class
          <code>const_item_policies</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#const_item_policies-spec-synopsis">Class
              <code>const_item_policies</code> synopsis</a></dt>

              <dt><a href="#const_item_policies-spec-statics">Class
              <code>const_item_policies</code> static functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#item_policies-spec">Class
          <code>item_policies</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#item_policies-spec-synopsis">Class
              <code>item_policies</code> synopsis</a></dt>

              <dt><a href="#item_policies-spec-statics">Class
              <code>item_policies</code> static functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#const_slice_policies-spec">Class
          <code>const_slice_policies</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#const_slice_policies-spec-synopsis">Class
              <code>const_slice_policies</code> synopsis</a></dt>

              <dt><a href="#const_slice_policies-spec-statics">Class
              <code>const_slice_policies</code> static functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#slice_policies-spec">Class
          <code>slice_policies</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#slice_policies-spec-synopsis">Class
              <code>slice_policies</code> synopsis</a></dt>

              <dt><a href="#slice_policies-spec-statics">Class
              <code>slice_policies</code> static functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#object_operators-spec">Class
          <code>object_operators</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#object_operators-spec-synopsis">Class
              <code>object_operators</code> synopsis</a></dt>

              <dt><a href="#object_operators-spec-observers">Class
              <code>object_operators</code> observer functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#object-spec">Class <code>object</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#object-spec-synopsis">Class <code>object</code>
              synopsis</a></dt>

              <dt><a href="#object-spec-ctors">Class <code>object</code>
              constructors and destructor</a></dt>

              <dt><a href="#object-spec-modifiers">Class template
              <code>object</code> modifier functions</a></dt>

              <dt><a href="#object-spec-observers">Class template
              <code>object</code> observer functions</a></dt>
            </dl>
          </dd>

          <dt><a href="#proxy-spec">Class template
          <code>proxy</code></a></dt>

          <dd>
            <dl class="page-index">
              <dt><a href="#proxy-spec-synopsis">Class template
              <code>proxy</code> synopsis</a></dt>

              <dt><a href="#proxy-spec-modifiers">Class template
              <code>proxy</code> modifier functions</a></dt>

              <dt><a href="#proxy-spec-observers">Class template
              <code>proxy</code> observer functions</a></dt>
            </dl>
          </dd>
        </dl>
      </dd>

      <dt><a href="#functions">Functions</a></dt>

      <dd>
        <dl class="page-index">
          <dt><a href="#del-spec">del</a></dt>

          <dt><a href="#comparisons-spec">comparisons</a></dt>

          <dt><a href="#binary-spec">binary operations</a></dt>

          <dt><a href="#assignment-spec">assignment operations</a></dt>

        </dl>

        <dl class="page-index">
          <dt><a href="#object_operators-spec">operators</a></dt>
        </dl>

        <dl class="page-index">
          <dt><a href="#len-spec">len()</a></dt>
        </dl>
      </dd>

      <dt><a href="#examples">Example</a></dt>
    </dl>
    <hr>

    <h2><a name="introduction"></a>Introduction</h2>

    <p>Exposes the generic Python object wrapper class <code>object</code>,
    and related classes. In order to avoid some potenential problems with
    argument-dependent lookup and the generalized operators defined on
    <code>object</code>, all these facilities are defined in
    <code>namespace&nbsp;boost::python::api</code>, and <code>object</code>
    is imported into <code>namespace&nbsp;boost::python</code> with a
    <i>using-declaration</i>.</p>

    <p>
    导出一般Python对象的封装类 <code>object</code> 及其相关类。

    为了避免在参数依赖查找（argument-dependent lookup）上，
    或者<code>object</code>定义的通用运算符上出现问题，
    所有这些工具定义于
    <code>namespace&nbsp;boost::python::api</code>，
    并且 <code>object</code> 通过
    <i>using声明（using-declaration）</i>
    导入 <code>namespace&nbsp;boost::python</code>。
    </p>

    <h2><a name="types"></a>Types</h2>

    <p><a name="slice_nil-spec"></a></p>
<pre>class slice_nil;<br>static const _ = slice_nil();<br></pre>
    A type that can be used to get the effect of leaving out an index in a
    Python slice expression: 
    
    <p>一个类型，
    可用于达到在Python分片表达式中省略索引的效果。
    </p>
<pre>&gt;&gt;&gt; x[:-1]<br>&gt;&gt;&gt; x[::-1]<br></pre>
    C++ equivalent: 
    
    <p>等效的C++：</p>
<pre>x.slice(_,-1)<br>x[slice(_,_,-1)]<br></pre>

    <h2><a name="classes"></a>Classes</h2>
    <!-- begin -->

    <h3><a name="const_attribute_policies-spec"></a>Class
    <code>const_attribute_policies</code></h3>

    <p>The policies which are used for proxies representing an attribute
    access to a <code>const&nbsp;object</code>.</p>

    <p>
    代理对 <code>const&nbsp;object</code> 进行属性访问时所表现的策略。
    </p>

    <h4><a name="const_attribute_policies-spec-synopsis"></a>Class
    <code>const_attribute_policies</code> synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  struct const_attribute_policies<br>  {<br>      typedef char const* key_type;<br>      static object get(object const&amp; target, char const* key);<br>  };<br>}}}<br></pre>

    <h4><a name="const_attribute_policies-spec-statics"></a>Class
    <code>const_attribute_policies</code> static functions</h4>
<pre>static object get(object const&amp; target, char const* key);<br></pre>

    <dl class="function-semantics">
      <dt><b>Requires:</b> <code>key</code> is an <a href="definitions.html#ntbs">ntbs</a>.</dt>

      <dt><b>Effects:</b> accesses the attribute of <code>target</code> named
      by <code>key</code>.</dt>

      <dt><b>Returns:</b> An <code>object</code> managing the result of the
      attribute access.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>要求：</b> <code>key</code> 是个 <a href="definitions.html#ntbs">ntbs</a>。</dt>

      <dt><b>效果：</b> 访问 <code>target</code> 名字为
      <code>key</code> 的属性。</dt>

      <dt><b>返回：</b> 一个管理属性访问结果的
       <code>object</code>。
      </dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>

    <h3><a name="attribute_policies-spec"></a>Class
    <code>attribute_policies</code></h3>

    <p>The policies which are used for proxies representing an attribute
    access to a mutable <code>object</code>.</p>

    <p>
    代理对可变性 <code>object</code> 进行属性访问时所表现的策略。
    </p>

    <h4><a name="attribute_policies-spec-synopsis"></a>Class
    <code>attribute_policies</code> synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  struct attribute_policies : const_attribute_policies<br>  {<br>      static object const&amp; set(object const&amp; target, char const* key, object const&amp; value);<br>      static void del(object const&amp;target, char const* key);<br>  };<br>}}}<br></pre>

    <h4><a name="attribute_policies-spec-statics"></a>Class
    <code>attribute_policies</code> static functions</h4>
<pre>static object const&amp; set(object const&amp; target, char const* key, object const&amp; value);<br></pre>

    <dl class="function-semantics">
      <dt><b>Requires:</b> <code>key</code> is an <a href="definitions.html#ntbs">ntbs</a>.</dt>

      <dt><b>Effects:</b> sets the attribute of <code>target</code> named by
      <code>key</code> to <code>value</code>.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>要求：</b> <code>key</code> 是个 <a href="definitions.html#ntbs">ntbs</a>。</dt>

      <dt><b>效果：</b> 将 <code>target</code> 名字为
      <code>key</code> 的属性设置为 <code>value</code>。</dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>

<pre>static void del(object const&amp;target, char const* key);<br></pre>

    <dl class="function-semantics">
      <dt><b>Requires:</b> <code>key</code> is an <a href="definitions.html#ntbs">ntbs</a>.</dt>

      <dt><b>Effects:</b> deletes the attribute of <code>target</code> named
      by <code>key</code>.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>
    
    <dl class="function-semantics">
      <dt><b>要求：</b> <code>key</code> 是个 <a href="definitions.html#ntbs">ntbs</a>.</dt>

      <dt><b>效果：</b> 删除 <code>target</code> 名字为
      <code>key</code> 的属性。</dt>

      <dt><b>抛出：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>
    <!-- end -->
    <!-- begin -->

    <h3><a name="const_item_policies-spec"></a>Class
    <code>const_item_policies</code></h3>

    <p>The policies which are used for proxies representing an item access
    (via the Python bracket operators <code>[]</code>) to a
    <code>const&nbsp;object</code>.</p>

    <p>
    代理（通过Python方括号运算符 <code>[]</code>）
    对 <code>const&nbsp;object</code> 进行条目访问时所表现的策略。
    </p>

    <h4><a name="const_item_policies-spec-synopsis"></a>Class
    <code>const_item_policies</code> synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  struct const_item_policies<br>  {<br>      typedef object key_type;<br>      static object get(object const&amp; target, object const&amp; key);<br>  };<br>}}}<br></pre>

    <h4><a name="const_item_policies-spec-statics"></a>Class
    <code>const_item_policies</code> static functions</h4>
<pre>static object get(object const&amp; target, object const&amp; key);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> accesses the item of <code>target</code> specified
      by <code>key</code>.</dt>

      <dt><b>Returns:</b> An <code>object</code> managing the result of the
      item access.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 访问 <code>target</code> 由
      <code>key</code> 指定的条目。
      </dt>

      <dt><b>返回：</b> 一个管理条目访问结果的 <code>object</code>。
      </dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>
    
    <h3><a name="item_policies-spec"></a>Class
    <code>item_policies</code></h3>

    <p>The policies which are used for proxies representing an item access
    (via the Python bracket operators <code>[]</code>) to a mutable
    <code>object</code>.</p>

    <p>
    代理（通过Python方括号运算符 <code>[]</code>）
    对可变性 <code>object</code> 进行条目访问时所表现的策略。
    </p>

    <h4><a name="item_policies-spec-synopsis"></a>Class
    <code>item_policies</code> synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  struct item_policies : const_item_policies<br>  {<br>      static object const&amp; set(object const&amp; target, object const&amp; key, object const&amp; value);<br>      static void del(object const&amp; target, object const&amp; key);<br>  };<br>}}}<br></pre>

    <h4><a name="item_policies-spec-statics"></a>Class
    <code>item_policies</code> static functions</h4>
<pre>static object const&amp; set(object const&amp; target, object const&amp; key, object const&amp; value);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> sets the item of <code>target</code> specified by
      <code>key</code> to <code>value</code>.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 将 <code>target</code> 由
      <code>key</code> 指定的条目设置为 <code>value</code>。</dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>

<pre>static void del(object const&amp; target, object const&amp; key);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> deletes the item of <code>target</code> specified
      by <code>key</code>.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 删除 <code>target</code> 由
      <code>key</code> 指定的条目。</dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>
    
    <!-- end -->
    <!-- begin -->

    <h3><a name="const_slice_policies-spec"></a>Class
    <code>const_slice_policies</code></h3>

    <p>The policies which are used for proxies representing an slice access
    (via the Python slice notation
    <code>[</code><i>x</i><code>:</code><i>y</i><code>]</code>) to a
    <code>const&nbsp;object</code>.</p>

    <p>
    代理（通过分片符
    <code>[</code><i>x</i><code>:</code><i>y</i><code>]</code>）
    对 <code>const&nbsp;object</code> 进行分片访问时所表现的策略。
    </p>

    <h4><a name="const_slice_policies-spec-synopsis"></a>Class
    <code>const_slice_policies</code> synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  struct const_slice_policies<br>  {<br>      typedef std::pair&lt;handle&lt;&gt;, handle&lt;&gt; &gt; key_type;<br>      static object get(object const&amp; target, key_type const&amp; key);<br>  };<br>}}}<br></pre>

    <h4><a name="const_slice_policies-spec-statics"></a>Class
    <code>const_slice_policies</code> static functions</h4>
<pre>static object get(object const&amp; target, key_type const&amp; key);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> accesses the slice of <code>target</code> specified
      by <code>key</code>.</dt>

      <dt><b>Returns:</b> An <code>object</code> managing the result of the
      slice access.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 访问 <code>target</code> 由
      <code>key</code> 指定的分片。</dt>

      <dt><b>返回：</b> 一个管理分片访问结果的 <code>object</code>。
      </dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>

    <h3><a name="slice_policies-spec"></a>Class
    <code>slice_policies</code></h3>

    <p>The policies which are used for proxies representing an slice access
    to a mutable <code>object</code>.</p>

    <p>
    代理对可变性 <code>object</code> 进行分片访问时所表现的策略。
    </p>

    <h4><a name="slice_policies-spec-synopsis"></a>Class
    <code>slice_policies</code> synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  struct slice_policies : const_slice_policies<br>  {<br>      static object const&amp; set(object const&amp; target, key_type const&amp; key, object const&amp; value);<br>      static void del(object const&amp; target, key_type const&amp; key);<br>  };<br>}}}<br></pre>

    <h4><a name="slice_policies-spec-statics"></a>Class
    <code>slice_policies</code> static functions</h4>
<pre>static object const&amp; set(object const&amp; target, key_type const&amp; key, object const&amp; value);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> sets the slice of <code>target</code> specified by
      <code>key</code> to <code>value</code>.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 将 <code>target</code> 由
      <code>key</code> 指定的分片设置为 <code>value</code>。</dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>

<pre>static void del(object const&amp; target, key_type const&amp; key);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> deletes the slice of <code>target</code> specified
      by <code>key</code>.</dt>

      <dt><b>Throws:</b> <code><a href="errors.html#error_already_set-spec">error_already_set</a></code> if a
      Python exception is raised.</dt>
    </dl>
    
    <dl class="function-semantics">
      <dt><b>效果：</b> 删除 <code>target</code> 由
      <code>key</code> 指定的分片。</dt>

      <dt><b>抛异常：</b> 如果引发Python异常，则抛出 <code><a href="errors.html#error_already_set-spec">error_already_set</a></code>。
      </dt>
    </dl>
    
    <!-- end -->

    <h3><a name="object_operators-spec"></a>Class template
    <code>object_operators&lt;U&gt;</code></h3>

    <p>This is the base class of <code>object</code> and its
    <code>proxy</code> template used to supply common interface: member
    functions, and operators which must be defined within the class body. Its
    template parameter <code>U</code> is expected to be a class derived from
    <code>object_operators&lt;U&gt;</code>. In practice users should never
    use this class directly, but it is documented here because it supplies
    important interface to <code>object</code> and its proxies.</p>

    <p>
    这是 <code>object</code> 的基类，
    它的代理（<code>proxy</code>）模板通常提供公共的接口：
    即必须在类中定义的成员函数和运算符。
    
    它的模板参数 <code>U</code> 要求为
    <code>object_operators&lt;U&gt;</code> 的派生类。
    
    实际上用户不应该直接使用该类，这里的文档是因为它向
    <code>object</code> 及其代理提供重要的接口。
    </p>

    <h4><a name="object_operators-spec-synopsis"></a>Class template
    <code>object_operators</code> synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  template &lt;class U&gt;<br>  class object_operators<br>  {<br>   public:<br>      // function call<br>      //<br>      object operator()() const;<br><br>      template &lt;class A0&gt;<br>      object operator()(A0 const&amp;) const;<br>      template &lt;class A0, class A1&gt;<br>      object operator()(A0 const&amp;, A1 const&amp;) const;<br>      ...<br>      template &lt;class A0, class A1,...class An&gt;<br>      object operator()(A0 const&amp;, A1 const&amp;,...An const&amp;) const;<br><br>      detail::args_proxy operator* () const; <br>      object operator()(detail::args_proxy const &amp;args) const; <br>      object operator()(detail::args_proxy const &amp;args, <br>                        detail::kwds_proxy const &amp;kwds) const; <br><br>      // truth value testing<br>      //<br>      typedef unspecified bool_type;<br>      operator bool_type() const;<br><br>      // Attribute access<br>      //<br>      proxy&lt;const_object_attribute&gt; attr(char const*) const;<br>      proxy&lt;object_attribute&gt; attr(char const*);<br><br>      // item access<br>      //<br>      template &lt;class T&gt;<br>      proxy&lt;const_object_item&gt; operator[](T const&amp; key) const;<br>    <br>      template &lt;class T&gt;<br>      proxy&lt;object_item&gt; operator[](T const&amp; key);<br><br>      // slicing<br>      //<br>      template &lt;class T, class V&gt;<br>      proxy&lt;const_object_slice&gt; slice(T const&amp; start, V const&amp; end) const<br>    <br>      template &lt;class T, class V&gt;<br>      proxy&lt;object_slice&gt; slice(T const&amp; start, V const&amp; end);<br>  };<br>}}}<br></pre>

    <h4><a name="object_operators-spec-observers"></a>Class template
    <code>object_operators</code> observer functions</h4>
<pre>object operator()() const;<br>template &lt;class A0&gt;<br>object operator()(A0 const&amp;) const;<br>template &lt;class A0, class A1&gt;<br>object operator()(A0 const&amp;, A1 const&amp;) const;<br>...<br>template &lt;class A0, class A1,...class An&gt;<br>object operator()(A0 const&amp; a1, A1 const&amp; a2,...An const&amp; aN) const;<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b>
      call&lt;object&gt;(object(*static_cast&lt;U*&gt;(this)).ptr(), a1,
      a2,...aN)
</dt></dl><pre>object operator()(detail::args_proxy const &amp;args) const; <br></pre>
<dl class="function-semantics"><dt></dt><dt><b>Effects:</b> call object with arguments given by the tuple 
<varname>args</varname></dt><b>效果：</b>以元组 
<varname>args</varname> 给定的实参调用&nbsp;object<varname></varname> </dl><pre>object operator()(detail::args_proxy const &amp;args, <br>                  detail::kwds_proxy const &amp;kwds) const; <br></pre>
<dl class="function-semantics"><dt></dt><dt><b>Effects:</b> call object with arguments given by the tuple 
<varname>args</varname>, and named arguments given by the dictionary 
<varname>kwds</varname></dt><b>效果：</b>以元组 
<varname>args</varname> 给定的实参以及字典&nbsp;<varname>kwds</varname> 给定的命名实参调用&nbsp;object&nbsp;<varname></varname> </dl><dl class="function-semantics">
    </dl>
<pre>operator bool_type() const;<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> Tests truth value of <code>*this</code>.</dt>

      <dt><b>Returns:</b>
      call&lt;object&gt;(object(*static_cast&lt;U*&gt;(this)).ptr(), a1,
      a2,...aN)</dt>
    </dl>
    
    <dl class="function-semantics">
      <dt><b>效果：</b> 测度 <code>*this</code> truth 值。</dt>

      <dt><b>返回：</b>
      call&lt;object&gt;(object(*static_cast&lt;U*&gt;(this)).ptr(), a1,
      a2,...aN)</dt>
    </dl>
    
<pre>proxy&lt;const_object_attribute&gt; attr(char const* name) const;<br>proxy&lt;object_attribute&gt; attr(char const* name);<br></pre>

    <dl class="function-semantics">
      <dt><b>Requires:</b> name is an <a href="definitions.html#ntbs">ntbs</a>.</dt>

      <dt><b>Effects:</b> accesses the named attribute of
      <code>*this</code>.</dt>

      <dt><b>Returns:</b> a proxy object which binds
      <code>object(*static_cast&lt;U*&gt;(this))</code> as its target, and
      <code>name</code> as its key.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>要求：</b> name 是个 <a href="definitions.html#ntbs">ntbs</a>。</dt>

      <dt><b>效果：</b> 访问 <code>*this</code> 名为 name 的属性。
      </dt>

      <dt><b>返回：</b> 一个绑定 target 为
      <code>object(*static_cast&lt;U*&gt;(this))</code>，
      key 为 <code>name</code> 的代理对象。
      。</dt>
    </dl>

<pre>template &lt;class T&gt;<br>proxy&lt;const_object_item&gt; operator[](T const&amp; key) const;<br>template &lt;class T&gt;<br>proxy&lt;object_item&gt; operator[](T const&amp; key);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> accesses the item of <code>*this</code> indicated
      by <code>key</code>.</dt>

      <dt><b>Returns:</b> a proxy object which binds
      <code>object(*static_cast&lt;U*&gt;(this))</code> as its target, and
      <code>object(key)</code> as its key.</dt>
    </dl>
    
    <dl class="function-semantics">
      <dt><b>效果：</b> 访问 <code>*this</code> 由
      <code>key</code> 指明的条目。</dt>

      <dt><b>返回：</b> 一个绑定 target 为
      <code>object(*static_cast&lt;U*&gt;(this))</code>，
      key 为 <code>object(key)</code> 的代理对象。
      </dt>
    </dl>
    
<pre>template &lt;class T, class V&gt;<br>proxy&lt;const_object_slice&gt; slice(T const&amp; start; start, V const&amp; finish) const<br>template &lt;class T, class V&gt;<br>proxy&lt;object_slice&gt; slice(T const&amp; start; start, V const&amp; finish);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> accesses the slice of <code>*this</code> indicated
      by <code>std::make_pair(object(start), object(finish))</code>.</dt>

      <dt><b>Returns:</b> a proxy object which binds
      <code>object(*static_cast&lt;U*&gt;(this))</code> as its target, and
      <code>std::make_pair(object(start), object(finish))</code> as its
      key.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 访问 <code>*this</code> 由
      <code>std::make_pair(object(start), object(finish))</code>
      指明的分片。
      </dt>

      <dt><b>返回：</b> 一个绑定 target 为
      <code>object(*static_cast&lt;U*&gt;(this))</code>，
      key 为 <code>std::make_pair(object(start), object(finish))</code>
      的代理对象。
      </dt>
    </dl>
    
    <!--  -->

    <h3><a name="object-spec"></a>Class <code>object</code></h3>

    <p>The intention is that <code>object</code> acts as much like a
    Python variable as possible. Thus expressions you'd expect to work
    in Python should generally work in the same way from C++. Most of
    <code>object</code>'s interface is provided by its base class
    <code><a href="#object_operators-spec">object_operators</a>&lt;object&gt;</code>,
    and the <a href="#functions">free functions</a> defined in this
    header.
</p> 

    <p>
    目的是让 <code>object</code> 尽可能地像个Python变量。
    
    这种表达式通常会以像在Python中一样的方式运行于C++。
    
    <code>object</code> 的大部分接口是由其基类
    <code><a href="#object_operators-spec">object_operators</a>&lt;object&gt;</code>，
    及一些<a href="#functions">自由函数</a>提供的，
    它们都定义于这个头文件中。
    
</p> 

    <h4><a name="object-spec-synopsis"></a>Class <code>object</code>
    synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  class object : public object_operators&lt;object&gt;<br>  {<br>   public:<br>      object();<br><br>      object(object const&amp;);<br>      <br>      template &lt;class T&gt;<br>      explicit object(T const&amp; x);<br><br>      ~object();<br><br>      object&amp; operator=(object const&amp;); <br><br>      PyObject* ptr() const;<br><br>      bool is_none() const;<br>  };<br>}}}<br></pre>

    <h4><a name="object-spec-ctors"></a>Class <code>object</code>
    constructors and destructor</h4>
<pre>object();<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> Constructs an object managing a reference to the
      Python <code>None</code> object.</dt>

      <dt><b>Throws:</b> nothing.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 构造一个对象，该对象管理一个
      指向Python <code>None</code> 对象的引用。</dt>

      <dt><b>抛异常：</b> 无。</dt>
    </dl>

<pre>template &lt;class T&gt;<br>explicit object(T const&amp; x);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> converts <code>x</code> to python and manages a
      reference to it.</dt>

      <dt><b>Throws:</b> <code>error_already_set</code> and sets a Python
      <code>TypeError</code> exception if no such conversion is
      possible.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 将 <code>x</code> 转换到 python，
      并管理一个对它的引用。</dt>

      <dt><b>抛出：</b> 如果无法进行这种转换，
      则抛出 <code>error_already_set</code>，
      并设置一个 Python 
      <code>TypeError</code> 异常。</dt>
    </dl>

<pre>~object();<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> decrements the reference count of the
      internally-held object.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 递减内部持有对象的引用计数。
      </dt>
    </dl>
    
    <h4><a name="object-spec-modifiers"></a>Class <code>object</code>
    modifiers</h4>
<pre>object&amp; operator=(object const&amp; rhs); <br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> increments the reference count of the object held
      by <code>rhs</code> and decrements the reference count of the object
      held by <code>*this</code>.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 递增 <code>rhs</code> 所持有对象的引用计数，
      并递减 <code>*this</code> 所持有对象的引用计数。</dt>
    </dl>

    <h4><a name="object-spec-observers"></a>Class <code>object</code>
    observers</h4>
<pre>PyObject* ptr() const;<br></pre>

    <dl class="function-semantics">
      <dt><b>Returns:</b> a pointer to the internally-held Python
      object.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>返回：</b> 一个指针，指向内部持有的Python对象。
<dt></dt></dt></dl><pre>bool is_none() const;<br></pre>
<dl class="function-semantics"><dt><b>返回：</b>(ptr() == Py_None) 的结果。 </dt></dl><!-- --><dl class="function-semantics">
    </dl>
    
    <!-- -->

    <h3><a name="proxy-spec"></a>Class template <code>proxy</code></h3>

    <p>This template is instantiated with various Policies described in this
    document in order to implement attribute, item, and slice access for
    <code>object</code>. It stores an object of type
    <code>Policies::key_type</code>.</p>

    <p>
    该模板由本文档所述的各种策略实例化，
    目的是实现对 <code>object</code> 的属性、条目，和分片访问。
    
    它保存着一个类型为 <code>Policies::key_type</code> 的对象。
    </p>

    <h4><a name="proxy-spec-synopsis"></a>Class template <code>proxy</code>
    synopsis</h4>
<pre>namespace boost { namespace python { namespace api<br>{<br>  template &lt;class Policies&gt;<br>  class proxy : public object_operators&lt;proxy&lt;Policies&gt; &gt;<br>  {<br>   public:<br>      operator object() const;<br><br>      proxy const&amp; operator=(proxy const&amp;) const;<br>      template &lt;class T&gt;<br>      inline proxy const&amp; operator=(T const&amp; rhs) const;<br>      <br>      void del() const;<br><br>      template &lt;class R&gt;<br>      proxy operator+=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator-=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator*=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator/=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator%=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator&lt;&lt;=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator&gt;&gt;=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator&amp;=(R const&amp; rhs);<br>      template &lt;class R&gt;<br>      proxy operator|=(R const&amp; rhs);<br>  };<br>}}}<br></pre>

    <h4><a name="proxy-spec-observers"></a>Class template <code>proxy</code>
    observer functions</h4>
<pre>operator object() const;<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> applies
      <code>Policies::get(</code><i>target</i><code>,</code>&nbsp;<i>key</i>
      <code>)</code> with the proxy's target and key objects.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 用代理的 target 和 key 对象应用
      <code>Policies::get(</code><i>target</i><code>,</code>&nbsp;<i>key</i>
      <code>)</code>。
      </dt>
    </dl>

    <h4><a name="proxy-spec-modifiers"></a>Class template <code>proxy</code>
    modifier functions</h4>
<pre>proxy const&amp; operator=(proxy const&amp; rhs) const;<br>template &lt;class T&gt;<br>inline proxy const&amp; operator=(T const&amp; rhs) const;<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b>
      <code>Policies::set(</code><i>target</i><code>,</code>&nbsp;<i>key</i>
      <code>,&nbsp;object(rhs))</code> with the proxy's target and key
      objects.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 
      用代理的 target 和 key 对象应用
      <code>Policies::set(</code><i>target</i><code>,</code>&nbsp;<i>key</i>
      <code>,&nbsp;object(rhs))</code>。
      </dt>
    </dl>

<pre>template &lt;class R&gt;<br>proxy operator+=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator-=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator*=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator/=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator%=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator&lt;&lt;=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator&gt;&gt;=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator&amp;=(R const&amp; rhs);<br>template &lt;class R&gt;<br>proxy operator|=(R const&amp; rhs);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> for a given operator@=,
      <code>object(*this)&nbsp;@=&nbsp;rhs;</code></dt>
      <dt><b>Returns:</b> <code>*this</code></dt>
    </dl>
    
    <dl class="function-semantics">
      <dt><b>效果：</b> 对于给定 operator@=，
      <code>object(*this)&nbsp;@=&nbsp;rhs;</code></dt>
      <dt><b>返回：</b> <code>*this</code></dt>
    </dl>
    
<pre>void del() const;<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b>
      <code>Policies::del(</code><i>target</i><code>,</code>&nbsp;<i>key</i>
      <code>)</code> with the proxy's target and key objects.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b>
      用代理的 target 和 key 对象应用
      <code>Policies::del(</code><i>target</i><code>,</code>&nbsp;<i>key</i>
      <code>)</code>。
      </dt>
    </dl>

    <!-- -->

    <h2><a name="functions"></a>Functions</h2>
<pre><a name="del-spec"></a>template &lt;class T&gt;<br>void del(proxy&lt;T&gt; const&amp; x);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> x.del()</dt>
    </dl>
<pre><a name="comparisons-spec"></a>
template&lt;class L,class R&gt; object operator&gt;(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator&gt;=(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator&lt;(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator&lt;=(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator==(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator!=(L const&amp;l,R const&amp;r);
</pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> returns the result of applying the operator to
      <code>object(l)</code> and <code>object(r)</code>, respectively, in
      Python.</dt>
    </dl>
    
    <dl class="function-semantics">
      <dt><b>效果：</b> 分别返回对 
      <code>object(l)</code> 和 <code>object(r)</code>
      在Python中应用运算符的结果。
      </dt>
    </dl>
    
<pre><a name="binary-spec"></a>
template&lt;class L,class R&gt; object operator+(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator-(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator*(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator/(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator%(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator&lt;&lt;(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator&gt;&gt;(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator&amp;(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator^(L const&amp;l,R const&amp;r);
template&lt;class L,class R&gt; object operator|(L const&amp;l,R const&amp;r);
</pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> returns the result of applying the operator to
      <code>object(l)</code> and <code>object(r)</code>, respectively, in
      Python.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>返回：</b> 分别返回对
      <code>object(l)</code> 和 <code>object(r)</code>
      在Python中应用运算符的结果。</dt>
    </dl>

<pre><a name="assignment-spec"></a>
template&lt;class R&gt; object&amp; operator+=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator-=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator*=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator/=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator%=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator&lt;&lt;=(object&amp;l,R const&amp;r)
template&lt;class R&gt; object&amp; operator&gt;&gt;=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator&amp;=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator^=(object&amp;l,R const&amp;r);
template&lt;class R&gt; object&amp; operator|=(object&amp;l,R const&amp;r);
</pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> assigns to l the result of applying the
      corresponding Python inplace operator to <code>l</code> and
      <code>object(r)</code>, respectively.</dt>

      <dt><b>Returns:</b> <code>l</code>.</dt>
    </dl>

    <dl class="function-semantics">
      <dt><b>效果：</b> 分别将 l 赋值为对 
      <code>l</code> 和 <code>object(r)</code>
      应用相应的Python就地运算符（inplace operator）的结果。
      </dt>

      <dt><b>返回：</b> <code>l</code>.</dt>
    </dl>


<pre>inline long len(object const&amp; obj);<br></pre>

    <dl class="function-semantics">
      <dt><b>Effects:</b> PyObject_Length(obj.ptr()) </dt>
      <dt><b>Returns:</b> len() of object.</dt>
    </dl>

<h2><a name="examples"></a>Example</h2>
    Python code: 
<pre>def sum_items(seq):<br>   result = 0<br>   for x in seq:<br>      result += x<br>   return result<br></pre>
    C++ version: 
<pre>object sum_items(object seq)<br>{<br>   object result = object(0);<br>   for (int i = 0; i &lt; len(seq); ++i)<br>      result += seq[i];<br>   return result;<br>}<br></pre>
    <p>Revised <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->15 
March, 2010 
    </p>

    <p><i>© Copyright <a href="http://www.boost.org/people/dave_abrahams.htm">Dave Abrahams</a> 2006.</i></p>
  </body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><!-- Copyright David Abrahams 2006. Distributed under the Boost --><!-- Software License, Version 1.0. (See accompanying --><!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
    <meta name="generator" content="HTML Tidy for Windows (vers 1st August 2002), see www.w3.org">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../boost.css">

    <title>Boost.Python - Configuration</title></head>





  <body link="#0000ff" vlink="#800080">
    <table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">
      <tbody><tr>
        <td valign="top" width="300">
          <h3><a href="../../../../index.htm"><img alt="C++ Boost" src="../../../../boost.png" border="0" height="86" width="277"></a></h3>
        </td>

        <td valign="top">
          <h1 align="center"><a href="../index.html">Boost.Python</a></h1>

          <h2 align="center">Configuration</h2>
          <h2 align="center">配置</h2>
        </td>
      </tr>
    </tbody></table>
    <hr>

    <dl class="page-index">
      <dt><a href="#introduction">Introduction</a></dt>

      <dt><a href="#app-defined">Application Defined Macros</a></dt>

      <dt><a href="#lib-defined-impl">Library Defined Implementation
      Macros</a></dt>
    </dl>

    <dl class="page-index">
      <dt><a href="#introduction">介绍</a></dt>

      <dt><a href="#app-defined">应用定义的宏</a></dt>

      <dt><a href="#lib-defined-impl">库定义的实现宏</a></dt>
    </dl>

    <h2><a name="introduction"></a>Introduction</h2>

    <h2><a name="introduction"></a>介绍</h2>

    <p><b>Boost.Python</b> uses several configuration macros in <a href="http://www.boost.org/libs/config/config.htm">&lt;boost/config.hpp&gt;</a>,
    as well as configuration macros meant to be supplied by the application.
    These macros are documented here.</p>

    <p><b>Boost.Python</b>使用了<a href="http://www.boost.org/libs/config/config.htm">&lt;boost/config.hpp&gt;</a>
    的几个配置宏，
    同时还会有应用提供的配置宏。
    此处是这些宏的说明文档。</p>

    <h2><a name="app-defined"></a>Application Defined Macros</h2>

    <h2><a name="app-defined"></a>应用定义的宏</h2>

    <p>These are the macros that may be defined by an application using
    <b>Boost.Python</b>. Note that if you extend a strict interpretation of
    the C++ standard to cover dynamic libraries, using different values of
    these macros when compiling different libraries (including extension
    modules and the <b>Boost.Python</b> library itself) is a violation of the
    <a href="definitions.html#ODR">ODR</a>. However, we know of no C++
    implementations on which this particular violation is detectable or
    causes any problems.</p>
    
    <p>这些是可以由使用<b>Boost.Python</b>的应用定义的宏。
    注意，如果严格解释C++标准，使之包括动态库，
    那么就不能用不同的宏值编译不同的库，
    （包括扩展模块和<b>Boost.Python</b>库本身），
    否则就是对<a href="definitions.html#ODR">ODR</a>的违反。
    然而，我们没有在任何C++实现中检测到这种特殊的违例，或因此造成任何问题。
    </p>
    

    <table summary="application defined macros" cellpadding="10" width="100%">
      <tbody><tr>
        <th align="left"><b>Macro
        <br>宏
        </b></th>

        <th><b>Default
        <br>默认值
        </b></th>

        <th align="left"><b>Meaning
        <br>含义
        </b></th>
      </tr>

      <tr>
        <td valign="top"><code>BOOST_PYTHON_MAX_ARITY</code></td>

        <td align="center" valign="top">15</td>

        <td valign="top">The maximum <a href="definitions.html#arity">arity</a> of any function, member function,
        or constructor to be wrapped, invocation of a <b>Boost.Python</b>
        function wich is specified as taking arguments
        <code>x1,&nbsp;x2,</code>...<code>X</code><i>n</i>. This includes, in
        particular, callback mechanisms such as <code><a href="object.html#object-spec">object</a>::operator()(</code>...<code>)</code>
        or <code><a href="call_method.html#call_method-spec">call_method</a>&lt;R&gt;(</code>...
        <code>)</code>.
        
        <br><br>
        
        待封装的任一函数、成员函数或构造函数的最大<a href="definitions.html#arity">元数</a>，
        即<b>Boost.Python</b>函数接受的参数
        <code>x1,&nbsp;x2,</code>...<code>X</code><i>n</i>。
        特别包括回调机制，例如<code><a href="object.html#object-spec">object</a>::operator()(</code>...<code>)</code>
        或<code><a href="call_method.html#call_method-spec">call_method</a>&lt;R&gt;(</code>...
        <code>)</code>。        
        
        </td>
      </tr>

      <tr>
        <td valign="top"><code>BOOST_PYTHON_MAX_BASES</code></td>

        <td align="center" valign="top">10</td>

        <td valign="top">The maximum number of template arguments to the
        <code><a href="class.html#bases-spec">bases</a>&lt;</code>...<code>&gt;</code>
        class template, which is used to specify the bases of a wrapped C++
        class..
        
        <br><br>
        
        <code><a href="class.html#bases-spec">bases</a>&lt;</code>...<code>&gt;</code>
        类模板的最大模板参数个数，
        该类模板用来指明被封装的C++类的基类。
        
        </td>
      </tr>

      <tr>
        <td valign="top"><code>BOOST_PYTHON_STATIC_MODULE</code></td>

        <td align="center" valign="top"><i>not&nbsp;defined
        <br>
        未定义
        </i></td>

        <td valign="top">If defined, prevents your module initialization
        function from being treated as an exported symbol on platforms which
        support that distinction in-code

        <br><br>
        如果平台支持用代码区分导出符号，
        定义它可以防止模块初始化函数被当作一个导出符号。
        
        </td>
      </tr><tr><td valign="top"><code>BOOST_PYTHON_ENABLE_CDECL</code></td>
<td align="middle" valign="top"><i>not&nbsp;defined</i><i>
        <br>
        未定义</i></td>
<td valign="top">If defined, allows functions using the <code>__cdecl </code>calling convention to be wrapped.<br>定义它可允许函数使用 <code>__cdecl </code>调用约定来外覆</td></tr><tr><td valign="top"><code>BOOST_PYTHON_ENABLE_STDCALL</code></td>
<td align="middle" valign="top"><i>not&nbsp;defined</i><i>
        <br>
        未定义</i></td>
<td valign="top">If defined, allows functions using the <code>__stdcall </code>calling convention to be wrapped.<br>定义它可允许函数使用&nbsp;<code>__stdcall</code><code> </code>调用约定来外覆</td></tr><tr><td valign="top"><code>BOOST_PYTHON_ENABLE_FASTCALL</code></td>
<td align="middle" valign="top"><i>not&nbsp;defined</i><i>
        <br>
        未定义</i></td>
<td valign="top">If defined, allows functions using the <code>__fastcall </code>calling convention to be wrapped.<br>定义它可允许函数使用 <code>__fastcall</code><code> </code>调用约定来外覆</td></tr>
    </tbody></table>

    <h2><a name="lib-defined-impl"></a>Library Defined Implementation
    Macros</h2>

    <h2><a name="lib-defined-impl"></a>库定义的实现宏</h2>

    <p>These macros are defined by <b>Boost.Python</b> and are implementation
    details of interest only to implementors and those porting to new
    platforms.</p>

    <p>这些宏由<b>Boost.Python</b>定义的，是实现上的细节，
    只有库的实现者，以及那些移植库到新平台的人对此感兴趣。
    </p>

    <table summary="library defined implementation macros" cellpadding="10" width="100%">
      <tbody><tr>
        <th align="left"><b>Macro
        <br>宏
        </b></th>

        <th><b>Default
        <br>默认值
        </b></th>

        <th align="left"><b>Meaning
        <br>含义
        </b></th>
      </tr>

      <tr>
        <td valign="top"><code>BOOST_PYTHON_TYPE_ID_NAME</code></td>

        <td align="center" valign="top"><i>not&nbsp;defined
        <br>未定义
        </i></td>

        <td valign="top">If defined, this indicates that the type_info
        comparison across shared library boundaries does not work on this
        platform. In other words, if shared-lib-1 passes
        <code>typeid(T)</code> to a function in shared-lib-2 which compares
        it to <code>typeid(T)</code>, that comparison may return
        <code>false</code>. If this macro is #defined, Boost.Python uses and
        compares <code>typeid(T).name()</code> instead of using and comparing
        the <code>std::type_info</code> objects directly.
        
        <br><br>
        
        如果有定义，
        说明该平台上不可以跨越共享库的边界比较type_info。
        换句话说就是，如果共享库1向共享库2的函数传递
        <code>typeid(T)</code>，并与库2的<code>typeid(T)</code>比较，
        结果可能是<code>false</code>。
        如果#define该宏，Boost.Python会使用<code>typeid(T).name()</code>
        进行比较，而不是直接使用和比较<code>std::type_info</code>对象。
        
        </td>
      </tr>
      <tr>
        <td valign="top"><code>BOOST_PYTHON_NO_PY_SIGNATURES</code></td>

        <td align="center" valign="top"><i>not&nbsp;defined
        <br>未定义
        </i></td>

        <td valign="top">If defined for a module no pythonic signatures are generated 
        for the docstrings of the module functions, and no python type is associated with any
        of the converters registered by the module. This also reduces the binary size of the 
        module by about 14% (gcc compiled).<br>
        If defined for the boost_python runtime library, the default for the 
        <code>docstring_options.enable_py_signatures()</code> is set to <code>false</code>.
        
        <br><br>
        
        如果模块有定义，则该模块函数的文档字符串中就不会产生Python的签名式，
        该模块注册的任何转换器都不会关联Python类型。
        这也会减小二进制模块的大小，约14%（gcc编译）。<br>
        如果boost_python运行时库有定义，
        <code>docstring_options.enable_py_signatures()</code>
        的默认值会设为<code>false</code>。

        </td>

      </tr>
      <tr>
        <td valign="top"><code>BOOST_PYTHON_SUPPORTS_PY_SIGNATURES</code></td>

        <td align="center" valign="top"><i>defined if <code>BOOST_PYTHON_NO_PY_SIGNATURES</code> is undefined
        <br>
        <br>
        如果<code>BOOST_PYTHON_NO_PY_SIGNATURES</code>未定义则定义该宏
        </i></td>

        <td valign="top">This macro is defined to enable a smooth transition from older Boost.Python versions
        which do not support pythonic signatures. For example usage see 
        <a href="pytype_function.html#examples">here</a>.
        
        <br><br>
        
        Boost.Python旧版本不支持Python签名，定义该宏，可以从旧版本平稳过渡。
        使用的例子见<a href="pytype_function.html#examples">这里</a>。
        </td>

      </tr>
      <tr>
        <td valign="top"><code>BOOST_PYTHON_PY_SIGNATURES_PROPER_INIT_SELF_TYPE</code></td>

        <td align="center" valign="top"><i>not&nbsp;defined
        <br>未定义
        </i></td>

        <td valign="top">If defined the python type of <code>__init__</code> method "self" parameters
        is properly generated, otherwise <code><b>object</b></code> is used. It is undefined
        by default because it increases the binary size of the module by about 14% (gcc compiled).
        
        <br><br>
        如果有定义，就会正确生成Python <code>__init__</code>方法的“self”参数的类型，否则，就使用<code><b>object</b></code>。默认是未定义，因为它增加了模块的二进制大小，约14%（gcc编译）。
        
        </td>

      </tr>
      
    </tbody></table>
    
    <hr>

    <p>Revised 
    <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
     7 January, 2003 
    <!--webbot bot="Timestamp" endspan i-checksum="39359" -->
    </p>

    <p><i>© Copyright <a href="http://www.boost.org/people/dave_abrahams.htm">Dave Abrahams</a> 2002.</i></p>
    
    <p>
    翻译：<a href="http://blog.csdn.net/jq0123">金庆</a>
    </p>

    <p>
    译文更新：2008.6.15
    </p>
    
  </body></html>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<library name="Lambda" dirname="lambda" id="lambda" 
         last-revision="$Date: 2009-06-13 17:18:10 -0400 (Sat, 13 Jun 2009) $" 
         xmlns:xi="http://www.w3.org/2001/XInclude">
<libraryinfo>
  <author>
    <firstname>Jaakko</firstname>
    <surname>J鋜vi</surname>
     <email>jarvi at cs tamu edu</email>
  </author>

  <copyright>
    <year>1999</year>
    <year>2000</year>
    <year>2001</year>
    <year>2002</year>
    <year>2003</year>
    <year>2004</year>
    <holder>Jaakko J鋜vi</holder>
    <holder>Gary Powell</holder>
  </copyright>

  <legalnotice>
    <para>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <filename>LICENSE_1_0.txt</filename> or copy at <ulink
    url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)</para>
  </legalnotice>

  <librarypurpose>Define small unnamed function objects at the actual call site, and more</librarypurpose>
  <librarycategory name="category:higher-order"/>
</libraryinfo>

<title>Boost.Lambda</title>

  <!--  -->

  <section id="introduction">

    <title>In a nutshell 概述</title>

    <para>

      The Boost Lambda Library (BLL in the sequel) is a C++ template
      library, which implements a form of <emphasis>lambda abstractions</emphasis> for C++.
The term originates from functional programming and lambda calculus, where a lambda abstraction defines an unnamed function.
      The primary motivation for the BLL is to provide flexible and
      convenient means to define unnamed function objects for STL algorithms.
In explaining what the library is about, a line of code says more than a thousand words; the
      following line outputs the elements of some STL container
      <literal>a</literal> separated by spaces:<sbr/>
      Boost Lambda Library（简称为 BLL）是一个 C++ 模板库，为 C++ 实现了 <emphasis>lambda abstractions</emphasis> 
      的形式。这个术语起源于函数式编程和 lambda 演算，一个 lambda abstraction 定义一个无名函数。
      BLL 的主要动机是为定义供 STL 算法使用的无名函数对象提供灵活性和便利性。在讲解一个库是什么的时候，
      一行代码往往胜过千言万语，下面这一行输出以空格分隔的某个 STL 容器 <literal>a</literal> 中的元素：

      <programlisting><![CDATA[for_each(a.begin(), a.end(), std::cout << _1 << ' ');]]></programlisting>

      The expression <literal><![CDATA[std::cout << _1 << ' ']]></literal> defines a unary function object. 
      The variable <literal>_1</literal> is the parameter of this function, a <emphasis>placeholder</emphasis> for the actual argument. 
      Within each iteration of <literal>for_each</literal>, the function is
      called with an element of <literal>a</literal> as the actual argument.
      This actual argument is substituted for the placeholder, and the <quote>body</quote> of the function is evaluated.<sbr/>
      表达式 <literal><![CDATA[std::cout << _1 << ' ']]></literal> 定义了一个一元的函数对象。变量 <literal>_1</literal> 
      是这个函数的形式参数，相当于一个实际参数的 <emphasis>占位符</emphasis>。在 <literal>for_each</literal> 
      的每一次迭代中，针对实际参数 <literal>a</literal> 中的元素调用这个函数。这个实际参数取代了占位符，
      而这个函数<quote>体</quote>被求值。
    </para>

    <para>The essence of BLL is letting you define small unnamed function objects, such as the one above, directly on the call site of an STL algorithm.<sbr/>
    BLL 的本质是让你就像上面那个一样，在紧挨着 STL 算法调用位置的上面，定义小的无名函数对象。
    </para>
  </section>

  <section id="lambda.getting_started">
    <title>Getting Started 起步</title>

    <section>
      <title>Installing the library 库的安装</title>
      

      <para>
	The library consists of include files only, hence there is no
	installation procedure. The <literal>boost</literal> include directory
	must be on the include path.
	There are a number of include files that give different functionality:<sbr/>
    这个库仅由 include 文件组成，因此不需要安装过程。<literal>boost</literal> 的
    include 目录必须加入到 include 路径中。有许多 include 文件提供了不同的功能：

	<!-- TODO: tarkista viel?riippuvuudet-->
	<itemizedlist>

	  <listitem><para>
	      <filename>lambda/lambda.hpp</filename> defines lambda expressions for different C++
	      operators, see <xref linkend="lambda.operator_expressions"/>.<sbr/>
          <filename>lambda/lambda.hpp</filename> 为不同的 C++ 操作符定义了 lambda 表达式，
          参见 <xref linkend="lambda.operator_expressions"/> 。
	    </para></listitem>

	  <listitem><para>
	      <filename>lambda/bind.hpp</filename> defines <literal>bind</literal> functions for up to 9 arguments, see <xref linkend="lambda.bind_expressions"/>.<sbr/>
          <filename>lambda/bind.hpp</filename> 为最多 9 个参数定义了 <literal>bind</literal> 表达式，
          参见 <xref linkend="lambda.bind_expressions"/> 。</para></listitem>


	  <listitem><para>
	      <filename>lambda/if.hpp</filename> defines lambda function equivalents for if statements and the conditional operator, see <xref linkend="lambda.lambda_expressions_for_control_structures"/> (includes <filename>lambda.hpp</filename>).<sbr/>
          <filename>lambda/if.hpp</filename> 定义了相当于 if 语句和条件操作符的 lambda 函数，
          参见 <xref linkend="lambda.lambda_expressions_for_control_structures"/> （包括 <filename>lambda.hpp</filename>）。
	    </para></listitem>

	  <listitem><para>
	      <filename>lambda/loops.hpp</filename> defines lambda function equivalent for looping constructs, see <xref linkend="lambda.lambda_expressions_for_control_structures"/>.<sbr/>
          <filename>lambda/loops.hpp</filename> 定义了相当于循环结构的 lambda 函数，参见
          <xref linkend="lambda.lambda_expressions_for_control_structures"/> 。
	    </para></listitem>

	  <listitem><para>
	      <filename>lambda/switch.hpp</filename> defines lambda function equivalent for the switch statement, see <xref linkend="lambda.lambda_expressions_for_control_structures"/>.<sbr/>
          <filename>lambda/switch.hpp</filename> 定义了相当于 switch 语句的 lambda 函数，参见 
          <xref linkend="lambda.lambda_expressions_for_control_structures"/> 。
	    </para></listitem>

	  <listitem><para>
	      <filename>lambda/construct.hpp</filename> provides tools for writing lambda expressions with constructor, destructor, new and delete invocations, see <xref linkend="lambda.construction_and_destruction"/> (includes <filename>lambda.hpp</filename>).<sbr/>
          <filename>lambda/construct.hpp</filename> 提供了用于写带有构造函数，析构函数，new 和 delete 调用的 lambda 表达式的工具，
          参见 <xref linkend="lambda.construction_and_destruction"/> （包括 <filename>lambda.hpp</filename>）。
	    </para></listitem>

	  <listitem><para>
	      <filename>lambda/casts.hpp</filename> provides lambda versions of different casts, as well as <literal>sizeof</literal> and <literal>typeid</literal>, see <xref linkend="lambda.cast_expressions"/>.<sbr/>
          <filename>lambda/casts.hpp</filename> 提供了各种强制转型以及 <literal>sizeof</literal> 和 
          <literal>typeid</literal> 的 lambda 版本，参见 <xref linkend="lambda.cast_expressions"/> 。
	    </para></listitem>

	  <listitem><para>
	      <filename>lambda/exceptions.hpp</filename> gives tools for throwing and catching
	      exceptions within lambda functions, <xref linkend="lambda.exceptions"/> (includes
	      <filename>lambda.hpp</filename>).<sbr/>
          <filename>lambda/exceptions.hpp</filename> 给出了在 lambda 函数中抛出和捕获异常的工具，
          参见 <xref linkend="lambda.exceptions"/> （包括 <filename>lambda.hpp</filename>）。
	    </para></listitem>

	  <listitem><para>
	      <filename>lambda/algorithm.hpp</filename> and <filename>lambda/numeric.hpp</filename> (cf. standard <filename>algortihm</filename> and <filename>numeric</filename> headers) allow nested STL algorithm invocations, see <xref linkend="lambda.nested_stl_algorithms"/>.<sbr/>
          <filename>lambda/algorithm.hpp</filename> 和 <filename>lambda/numeric.hpp</filename>（与标准 
          <filename>algortihm</filename> 和 <filename>numeric</filename> 头文件相对）允许嵌入 STL 算法调用，
          参见 <xref linkend="lambda.nested_stl_algorithms"/> 。
	    </para></listitem>

	</itemizedlist>

	Any other header files in the package are for internal use.
	Additionally, the library depends on two other Boost Libraries, the
	<emphasis>Tuple</emphasis> <xref linkend="cit:boost::tuple"/> and the <emphasis>type_traits</emphasis> <xref linkend="cit:boost::type_traits"/> libraries, and on the <filename>boost/ref.hpp</filename> header.<sbr/>
    其它一些包中的头文件是内部使用的。另外，这个库依赖于另外两个 Boost 库，<emphasis>Tuple</emphasis> 
    <xref linkend="cit:boost::tuple"/> 和 <emphasis>type_traits</emphasis> <xref linkend="cit:boost::type_traits"/> 库，
    还有 <filename>boost/ref.hpp</filename> 头文件。
      </para>

      <para>
	All definitions are placed in the namespace <literal>boost::lambda</literal> and its subnamespaces.<sbr/>
    所有的定义都位于名字空间 <literal>boost::lambda</literal> 和它的子名字空间中。
      </para>

    </section>

    <section>
      <title>Conventions used in this document 此文档中用到的约定</title>

      <para>In most code examples, we omit the namespace prefixes for names in the <literal moreinfo="none">std</literal> and <literal moreinfo="none">boost::lambda</literal> namespaces.
Implicit using declarations<sbr/>
      在大多数代码示例中，我们省略了那些位于名字空间 <literal moreinfo="none">std</literal> 和 
      <literal moreinfo="none">boost::lambda</literal> 中的名字的名字空间前缀。缺省 using 声明
<programlisting>
using namespace std;
using namespace boost::lambda;
</programlisting>
are assumed to be in effect.<sbr/>
被假定为有效。
</para> 

    </section>
  </section>

  <section>
    <title>Introduction 简介</title>

    <section>
      <title>Motivation 动机</title>
      <para>The Standard Template Library (STL)
	<xref role="citation" linkend="cit:stepanov:94"/>, now part of the C++ Standard Library <xref role="citation" linkend="cit:c++:98"/>, is a generic container and algorithm library.
Typically STL algorithms operate on container elements via <emphasis>function objects</emphasis>. These function objects are passed as arguments to the algorithms.<sbr/>
    标准模板库 (STL) <xref role="citation" linkend="cit:stepanov:94"/>，现在是 C++ 标准库 
    [<xref role="citation" linkend="cit:c++:98"/>] 的一部分，是一个泛型容器和算法库。通常，
    STL 算法通过 <emphasis>函数对象</emphasis>操作容器元素。这些函数对象作为参数传递给算法。
</para>

<para>
Any C++ construct that can be called with the function call syntax
is a function object. 
The STL contains predefined function objects for some common cases (such as <literal>plus</literal>, <literal>less</literal> and <literal>not1</literal>). 
As an example, one possible implementation for the standard <literal>plus</literal> template is:<sbr/>
能够用函数调用语法调用的任何 C++ 结构都是一个函数对象。STL 容器为一些通常情况定义了一些预定义的函数对象
（比如 <literal>plus</literal>, <literal>less</literal> 和 <literal>not1</literal>）。
例如，这是标准 <literal>plus</literal> 模板的一种可能的实现：

<programlisting>
<![CDATA[template <class T> 
struct plus : public binary_function<T, T, T> {
  T operator()(const T& i, const T& j) const {
    return i + j; 
  }
};]]>
</programlisting>

The base class <literal><![CDATA[binary_function<T, T, T>]]></literal> contains typedefs for the argument and return types of the function object, which are needed to make the function object <emphasis>adaptable</emphasis>.<sbr/>
基类 <literal><![CDATA[binary_function<T, T, T>]]></literal> 包含了函数对象的参数和返回值类型的 typedefs，
这些是让这个函数对象成为 <emphasis>可适配的</emphasis> 的需要。
</para>

<para>
In addition to the basic function object classes, such as the one above,
the STL contains <emphasis>binder</emphasis> templates for creating a unary function object from an adaptable binary function object by fixing one of the arguments to a constant value.
For example, instead of having to explicitly write a function object class like:<sbr/>
除了像上面那个一样的基本函数对象类之外，还有 STL 容器 <emphasis>绑定器</emphasis> 模板，
可以用来将一个可适配的二元函数对象通过将其中一个参数修改为一个常数而创建一个一元函数对象。
例如，为了替代像下面这样不得不显式写出的函数对象类：

<programlisting>
<![CDATA[class plus_1 {
  int _i;
public:
  plus_1(const int& i) : _i(i) {}
  int operator()(const int& j) { return _i + j; }
};]]>
</programlisting>

the equivalent functionality can be achieved with the <literal moreinfo="none">plus</literal> template and one of the binder templates (<literal moreinfo="none">bind1st</literal>).
E.g., the following two expressions create function objects with identical functionalities; 
when invoked, both return the result of adding <literal moreinfo="none">1</literal> to the argument of the function object:<sbr/>
使用 <literal moreinfo="none">plus</literal> 模板和绑定器模板之一（<literal moreinfo="none">bind1st</literal>）
也能得到等价的功能。例如，下面两个表达式创建了功能相同的函数对象，在调用的时候，
都会返回在函数对象的参数上加 <literal moreinfo="none">1</literal> 之后的结果：

<programlisting>
<![CDATA[plus_1(1)
bind1st(plus<int>(), 1)]]>
</programlisting>

The subexpression <literal><![CDATA[plus<int>()]]></literal> in the latter line is a binary function object which computes the sum of two integers, and <literal>bind1st</literal> invokes this function object partially binding the first argument to <literal>1</literal>.
As an example of using the above function object, the following code adds <literal>1</literal> to each element of some container <literal>a</literal> and outputs the results into the standard output stream <literal>cout</literal>.<sbr/>
上面最后一行中的子表达式 <literal><![CDATA[plus<int>()]]></literal> 是一个计算两个整数之和的二元函数对象，
而 <literal>bind1st</literal> 调用这个函数对象，将第一个参数部分绑定为 <literal>1</literal>。
作为使用上面的函数对象的一个示例，下面的代码在某个容器 <literal>a</literal> 的每一个元素上加 <literal>1</literal>，
并且将结果输出到标准输出流 <literal>cout</literal> 中。

<programlisting>
<![CDATA[transform(a.begin(), a.end(), ostream_iterator<int>(cout),
          bind1st(plus<int>(), 1));]]>
</programlisting>

</para>

<para>
To make the binder templates more generally applicable, the STL contains <emphasis>adaptors</emphasis> for making 
pointers or references to functions, and pointers to member functions, 
adaptable.

Finally, some STL implementations contain function composition operations as
extensions to the standard <xref linkend="cit:sgi:02"/>.<sbr/>
为了让绑定器模板更加通用，STL 包含了 <emphasis>适配器</emphasis>，它可以使指向函数的指针或引用和指向成员函数的指针可以被适配。
最终，作为对标准的扩展，某些 STL 实现包含了函数合成操作 <xref linkend="cit:sgi:02"/>。
      </para>

<para>
All these tools aim at one goal: to make it possible to specify 
<emphasis>unnamed functions</emphasis> in a call of an STL algorithm, 
in other words, to pass code fragments as an argument to a function. 

However, this goal is attained only partially.
The simple example above shows that the definition of unnamed functions 
with the standard tools is cumbersome.

Complex expressions involving functors, adaptors, binders and 
function composition operations tend to be difficult to comprehend.

In addition to this, there are significant restrictions in applying 
the standard tools. E.g. the standard binders allow only one argument 
of a binary function to be bound; there are no binders for 
3-ary, 4-ary etc. functions. <sbr/>
所有这些工具都指向一个目标：让“在一个 STL 算法的调用中指定 <emphasis>无名函数</emphasis>”成为可能，
换句话说，就是将代码片段作为一个参数传递给一个函数。然而，这个目标只实现了一部分。
上面的简单示例展示了使用标准工具的无名函数定义是如何的麻烦。调用仿函数，适配器，
绑定器和函数合成操作的复杂表达式越来越难以理解。除此之外，应用标准工具也有很大的限制。
例如，标准绑定器只允许绑定一个二元函数的一个参数，而且也没有三元，四元等等函数的绑定器。
</para>

<para>
The Boost Lambda Library provides solutions for the problems described above:<sbr/>
Boost Lambda 库为上面描述的问题提供了解决方案：

<itemizedlist>
<listitem>
<para>
Unnamed functions can be created easily with an intuitive syntax. 

The above example can be written as:<sbr/>
无名函数能够通过符合直觉的语法简单地创建。上面的示例可以被写为：

<programlisting>
<![CDATA[transform(a.begin(), a.end(), ostream_iterator<int>(cout), 
          1 + _1);]]>
</programlisting>

or even more intuitively:<sbr/>
或者更符合直觉的：

<programlisting>
<![CDATA[for_each(a.begin(), a.end(), cout << (1 + _1));]]>
</programlisting>
</para>

</listitem>

<listitem>
<para>
Most of the restrictions in argument binding are removed, 
arbitrary arguments of practically any C++ function can be bound.<sbr/>
消除了参数绑定的大多数限制，几乎任何 C++ 函数的任意参数都能被绑定。
</para>
</listitem>

<listitem>
<para>
Separate function composition operations are not needed, 
as function composition is supported implicitly.<sbr/>
不再需要单独的函数合成操作，因为函数合成已被隐含支持。

</para>
</listitem>

</itemizedlist>

</para>

</section>



<section>
      <title>Introduction to lambda expressions 简介lambda表达式</title>

      <para>
	Lambda expression are common in functional programming languages. 
	Their syntax varies between languages (and between different forms of lambda calculus), but the basic form of a lambda expressions is:<sbr/>
    lambda 表达式在函数式编程语言中很普通。在不同的语言之间（以及不同的 lambda 演算形式之间）语法有所区别，
    但是一个 lambda 表达式的基本形式如下：


<programlisting>
lambda x<subscript>1</subscript> ... x<subscript>n</subscript>.e
</programlisting>
	<!-- $\lambda x_1 \cdots x_n . e$ -->

	A lambda expression defines an unnamed function and consists of:<sbr/>
    一个 lambda 表达式定义一个无名函数，并由以下部分组成：
	<itemizedlist>
	  <listitem>
	    <para>
	      the parameters of this function: <literal>x<subscript>1</subscript> ... x<subscript>n</subscript></literal>.<sbr/>
          这个函数的参数：<literal>x<subscript>1</subscript> ... x<subscript>n</subscript></literal>。
	      <!--$x_1 \cdots x_n$-->
	    </para>
	  </listitem>
	  <listitem>
	    <para>the expression e which computes the value of the function in terms of the parameters <literal>x<subscript>1</subscript> ... x<subscript>n</subscript></literal>.<sbr/>
        表达式 e，这就是根据参数 <literal>x<subscript>1</subscript> ... x<subscript>n</subscript></literal> 要求其值的那个函数。
	    </para>
	  </listitem>
	</itemizedlist>

	A simple example of a lambda expression is <sbr/>
    一个简单的 lambda 表达式示例如下：
<programlisting>
lambda x y.x+y
</programlisting>
Applying the lambda function means substituting the formal parameters with the actual arguments:<sbr/>
应用 lambda 函数意味着用实际参数取代形式参数：
<programlisting>
(lambda x y.x+y) 2 3 = 2 + 3 = 5 
</programlisting>


      </para>

<para>
In the C++ version of lambda expressions the <literal>lambda x<subscript>1</subscript> ... x<subscript>n</subscript></literal> part is missing and the formal parameters have predefined names.
In the current version of the library, 
there are three such predefined formal parameters, 
called <emphasis>placeholders</emphasis>: 
<literal>_1</literal>, <literal>_2</literal> and <literal>_3</literal>. 
They refer to the first, second and third argument of the function defined 
by the lambda expression.
	
For example, the C++ version of the definition<sbr/>
在 lambda 表达式的 C++ 版本中，缺少 <literal>lambda x<subscript>1</subscript> ... x<subscript>n</subscript></literal> 部分，
而且形式参数有预定义的名字。在库的当前版本中，有三个这样的预定义形式参数，称为 <emphasis>占位符</emphasis>：
<literal>_1</literal>, <literal>_2</literal> 和 <literal>_3</literal>。它们分别与通过 lambda 表达式定义的函数的第一个，
第二个和第三个参数相关，例如，定义
<programlisting>lambda x y.x+y</programlisting>
is <sbr/>
的 C++ 版本为
<programlisting>_1 + _2</programlisting>
</para>

      <para>
Hence, there is no syntactic keyword for C++ lambda expressions. 
	The use of a placeholder as an operand implies that the operator invocation is a lambda expression.
	However, this is true only for operator invocations.
	Lambda expressions containing function calls, control structures, casts etc. require special syntactic constructs. 
	Most importantly, function calls need to be wrapped inside a <literal>bind</literal> function. 

	As an example, consider the lambda expression:<sbr/>
    因此，C++ lambda 表达式没有专门的句法关键字。作为一个操作数使用的占位符暗示这个操作符调用是一个 lambda 表达式。
    然而，也仅仅对于操作符调用来说这是真的。lambda 表达式包含的函数调用，控制结构，强制转型等都需要特殊的语法结构。
    最重要的是，函数调用需要被包装在一个 <literal>bind</literal> 函数之内。例如，考虑这个 lambda 表达式：

	<programlisting>lambda x y.foo(x,y)</programlisting>

	Rather than <literal>foo(_1, _2)</literal>, the C++ counterpart for this expression is:<sbr/>
    这个 lambda 表达式的 C++ 对等物不是 <literal>foo(_1, _2)</literal>，而是：

	<programlisting>bind(foo, _1, _2)</programlisting>

	We refer to this type of C++ lambda expressions as <emphasis>bind expressions</emphasis>. <sbr/>
    我们将这种类型的 C++ lambda 表达式称为 <emphasis>bind 表达式</emphasis>。
      </para>

      <para>A lambda expression defines a C++ function object, hence function application syntax is like calling any other function object, for instance: <literal>(_1 + _2)(i, j)</literal>.<sbr/>
      一个 lambda 表达式定义一个函数对象，因此函数应用语法就像调用任何其它的函数对象，例如：<literal>(_1 + _2)(i, j)</literal>。
      </para>



<section id="lambda.partial_function_application"> 
<title>Partial function application 部分函数应用</title>

<para>
A bind expression is in effect a <emphasis>partial function application</emphasis>.
In partial function application, some of the arguments of a function are bound to fixed values. 
	  The result is another function, with possibly fewer arguments. 
	  When called with the unbound arguments, this new function invokes the original function with the merged argument list of bound and unbound arguments.<sbr/>
      一个 bind 表达式本质上就是一个 <emphasis>部分函数应用</emphasis>。在部分函数应用中，
      一个函数的某些参数被绑定到固定的值。结果是另一个函数，可能还带有更多的参数。
      当使用未绑定参数调用它的时候，这个新的函数合并绑定和未绑定参数的参数列表并调用原始函数。
	</para>

<!--	<para>The underlying implementation of the BLL unifies the two types of lambda expressions (bind expressions and lambda expressions consisting of operator calls).
	  If operators are regarded as functions, it is easy to see that lambda expressions using operators are partial function applications as well. 
	  E.g. the lambda expression <literal>_1 + 1</literal> can be seen as syntactic sugar for the pseudo code <literal>bind(operator+, _1, 1)</literal>.
	</para>
-->

      </section>



      <section id="lambda.terminology">
	<title>Terminology 术语</title>

	<para>
	  A lambda expression defines a function. A C++ lambda expression concretely constructs a function object, <emphasis>a functor</emphasis>, when evaluated. We use the name <emphasis>lambda functor</emphasis> to refer to such a function object. 
	  Hence, in the terminology adopted here, the result of evaluating a lambda expression is a lambda functor.<sbr/>
      一个 lambda 表达式定义一个函数。在求值的时候，一个 C++ lambda 表达式实际上构造了一个函数对象，
      一个 <emphasis>仿函数</emphasis>。我们用名字 <emphasis>lambda 仿函数</emphasis> 来指涉这样一个函数对象。
      因此，在此采纳的术语中，一个 lambda 表达式的求值结果是一个 lambda 仿函数。
	</para>

      </section>

    </section>



  </section>

  <section id = "lambda.using_library">
    <title>Using the library 库的使用</title>

    <para>
The purpose of this section is to introduce the basic functionality of the library.
There are quite a lot of exceptions and special cases, but discussion of them is postponed until later sections.<sbr/>
这一部分的目标是介绍库的基本功能。库中有大量的例外和特殊情况，但我们到以后的章节再讨论它们。


    </para>

    <section id = "lambda.introductory_examples">
      <title>Introductory Examples 介绍性示例</title>

      <para>
	In this section we give basic examples of using BLL lambda expressions in STL algorithm invocations. 
	We start with some simple expressions and work up. 
	First, we initialize the elements of a container, say, a <literal>list</literal>, to the value <literal>1</literal>:<sbr/>
    本节中我们给出在 STL 算法调用中使用 BLL lambda 表达式的基础示例。我们以一些简单的表达式开始并逐步发展。
    首先，我们初始化一个容器的元素，比方说，一个 <literal>list</literal>，设为值 <literal>1</literal>：


	<programlisting>
<![CDATA[list<int> v(10);
for_each(v.begin(), v.end(), _1 = 1);]]></programlisting>

	The expression <literal>_1 = 1</literal> creates a lambda functor which assigns the value <literal>1</literal> to every element in <literal>v</literal>.<sbr/>
    表达式 <literal>_1 = 1</literal> 创建一个 lambda 仿函数，它将 <literal>v</literal> 中的每一元素赋值为 <literal>1</literal>。<footnote>
<para>
Strictly taken, the C++ standard defines <literal>for_each</literal> as a <emphasis>non-modifying sequence operation</emphasis>, and the function object passed to <literal moreinfo="none">for_each</literal> should not modify its argument. 
The requirements for the arguments of <literal>for_each</literal> are unnecessary strict, since as long as the iterators are <emphasis>mutable</emphasis>, <literal>for_each</literal> accepts a function object that can have side-effects on their argument.
Nevertheless, it is straightforward to provide another function template with the functionality of<literal>std::for_each</literal> but more fine-grained requirements for its arguments.<sbr/>
严格地说，C++ 标准将 <literal>for_each</literal> 定义为一个 <emphasis>不变序列操作</emphasis>，而传给 
<literal moreinfo="none">for_each</literal> 的函数对象不应该改变它的参数。其实对 <literal>for_each</literal> 
的参数的要求不必那么严格，因为只要迭代器是 <emphasis>可变化</emphasis>的，<literal>for_each</literal> 
也可以接受能够对它们的参数产生副作用的函数对象。不过，它只是直截了当地提供一个其它带有 <literal>std::for_each</literal> 
的功能的函数模板，只不过它对它的参数没有那么细致的要求。
</para>
</footnote>
      </para>

      <para>
	Next, we create a container of pointers and make them point to the elements in the first container <literal>v</literal>:<sbr/>
    接下来，我们创建一个指针的容器，并让它们指向第一个容器 <literal>v</literal> 中的元素：

	<programlisting>
<![CDATA[vector<int*> vp(10); 
transform(v.begin(), v.end(), vp.begin(), &_1);]]></programlisting>

The expression <literal><![CDATA[&_1]]></literal> creates a function object for getting the address of each element in <literal>v</literal>.
The addresses get assigned to the corresponding elements in <literal>vp</literal>.<sbr/>
表达式 <literal><![CDATA[&_1]]></literal> 创建一个取得 <literal>v</literal> 中每一个元素的地址的函数对象。
这些地址赋值给 <literal>vp</literal> 中的对应元素。
      </para>

      <para>
	The next code fragment changes the values in <literal>v</literal>. 
	For each element, the function <literal>foo</literal> is called. 
The original value of the element is passed as an argument to <literal>foo</literal>.
The result of <literal>foo</literal> is assigned back to the element:<sbr/>
下一个代码片段改变 <literal>v</literal> 中的值。对于每一个元素，函数 <literal>foo</literal> 被调用。
元素的原始值作为一个参数被传送给 <literal>foo</literal>。<literal>foo</literal> 的结果被赋回给那个元素：


	<programlisting>
<![CDATA[int foo(int);
for_each(v.begin(), v.end(), _1 = bind(foo, _1));]]></programlisting>
      </para>


      <para>
	The next step is to sort the elements of <literal>vp</literal>:<sbr/>
    下一步是为 <literal>vp</literal> 中的元素排序：
	
	<programlisting>sort(vp.begin(), vp.end(), *_1 > *_2);</programlisting>

	In this call to <literal>sort</literal>, we are sorting the elements by their contents in descending order. <sbr/>
    在这个 <literal>sort</literal> 的调用中，我们根据元素的内容以递减的顺序排列那些元素。
      </para>

      <para>
	Finally, the following <literal>for_each</literal> call outputs the sorted content of <literal>vp</literal> separated by line breaks:<sbr/>
    最后，下面的 <literal>for_each</literal> 调用输出以换行符分隔的 <literal>vp</literal> 的排序后的内容：

<programlisting>
<![CDATA[for_each(vp.begin(), vp.end(), cout << *_1 << '\n');]]>
</programlisting>

Note that a normal (non-lambda) expression as subexpression of a lambda expression is evaluated immediately.  
This may cause surprises. 
For instance, if the previous example is rewritten as<sbr/>
注意，作为一个 lambda 表达式的子表达式的一个常规（非 lambda 的）表达式立即被求值。这可能让人觉得惊讶。
例如，如果前面的示例被重写为：
<programlisting>
<![CDATA[for_each(vp.begin(), vp.end(), cout << '\n' << *_1);]]>
</programlisting>
the subexpression <literal><![CDATA[cout << '\n']]></literal> is evaluated immediately and the effect is to output a single line break, followed by the elements of <literal>vp</literal>.
The BLL provides functions <literal>constant</literal> and <literal>var</literal> to turn constants and, respectively, variables into lambda expressions, and can be used to prevent the immediate evaluation of subexpressions:<sbr/>
子表达式 <literal><![CDATA[cout << '\n']]></literal> 被立即求值，而效果是输出一个单个换行符，后面跟着 
<literal>vp</literal> 的元素。BLL 提供函数 <literal>constant</literal> 和 <literal>var</literal> 分别将常量和变量引入 
lambda 表达式，并可用于防止子表达式的立即求值：
<programlisting>
<![CDATA[for_each(vp.begin(), vp.end(), cout << constant('\n') << *_1);]]>
</programlisting>
These functions are described more thoroughly in <xref linkend="lambda.delaying_constants_and_variables"/><sbr/>
关于这些函数的更彻底的描述，参见 <xref linkend="lambda.delaying_constants_and_variables"/>。

</para>





    </section>


    <section id="lambda.parameter_and_return_types">
      <title>Parameter and return types of lambda functors  lambda仿函数的参数和返回类型</title>

      <para>
	During the invocation of a lambda functor, the actual arguments are substituted for the placeholders. 
	The placeholders do not dictate the type of these actual arguments.
	The basic rule is that a lambda function can be called with arguments of any types, as long as the lambda expression with substitutions performed is a valid C++ expression. 
	As an example, the expression
	<literal>_1 + _2</literal> creates a binary lambda functor. 
	It can be called with two objects of any types <literal>A</literal> and <literal>B</literal> for which <literal>operator+(A,B)</literal> is defined (and for which BLL knows the return type of the operator, see below).<sbr/>
    通过 lambda 仿函数的调用，实际参数取代了占位符。占位符没有规定这些实际参数的类型。
    基本的规则是只要完成取代的 lambda 表达式是一个合法的 C++ 表达式，那么这个 lambda 函数就能够用任何类型的参数调用。
    例如，表达式 <literal>_1 + _2</literal> 创建一个二元 lambda 仿函数。它能够被任意类型的两个对象 <literal>A</literal> 
    和 <literal>B</literal> 调用，只要这两个对象定义了 <literal>operator+(A,B)</literal>（而且 BLL 知道这个操作符的返回类型，
    参见后面的描述）。
      </para>

      <para>
	C++ lacks a mechanism to query a type of an expression. 
	However, this precise mechanism is crucial for the implementation of C++ lambda expressions.
	Consequently, BLL includes a somewhat complex type deduction system which uses a set of traits classes for deducing the resulting type of lambda functions.
	It handles expressions where the operands are of built-in types and many of the expressions with operands of standard library types.
	Many of the user defined types are covered as well, particularly if the user defined operators obey normal conventions in defining the return types. <sbr/>
    C++ 缺乏一个查询某个表达式类型的机制。然而，这种精确的机制对于 C++ lambda 表达式的实现又是至关重要的。
    因此，BLL 包含一个稍微复杂的类型推演系统，用一套特征类来推演 lambda 表达式的结果类型。
    它处理那些操作数是内建类型的表达式以及大多数操作数是标准库类型的表达式。
    大多数用户定义类型也同样适用，特别是在被定义的返回类型中的用户定义操作符符合通常惯例。
      </para>

      <!-- TODO: move  this forward, and just refer to it. -->
      <para>
	There are, however, cases when the return type cannot be deduced. For example, suppose you have defined:<sbr/>
    然而，还是有一些情况返回类型无法推演。例如，假设你有这样的定义：

	<programlisting>C operator+(A, B);</programlisting>

	The following lambda function invocation fails, since the return type cannot be deduced:<sbr/>
    这个 lambda 表达式调用失败，因为返回类型无法被推演出来：

	<programlisting>A a; B b; (_1 + _2)(a, b);</programlisting>
      </para>

      <para>
	There are two alternative solutions to this. 
	The first is to extend the BLL type deduction system to cover your own types (see <xref linkend="lambda.extending"/>). 
	The second is to use a special lambda expression (<literal>ret</literal>) which defines the return type in place (see <xref linkend = "lambda.overriding_deduced_return_type"/>):<sbr/>
    对此有两种可供选择的解决方案。第一种是扩展 BLL 类型推演系统覆盖你自己的类型（参见 <xref linkend="lambda.extending"/>）。
    第二种是使用一个特殊的 lambda 表达式 (<literal>ret</literal>) 来就地定义返回类型
    （参见 <xref linkend = "lambda.overriding_deduced_return_type"/>）：

	<programlisting><![CDATA[A a; B b; ret<C>(_1 + _2)(a, b);]]></programlisting>
      </para>

      <para>
	For bind expressions, the return type can be defined as a template argument of the bind function as well: <sbr/>
    对于 bind 表达式，返回类型的定义就像是 bind 函数的一个模板参数一样：
	<programlisting><![CDATA[bind<int>(foo, _1, _2);]]></programlisting>

<!--
	A rare case, where the <literal><![CDATA[ret<type>(bind(...))]]></literal> syntax does not work, but
	<literal><![CDATA[bind<type>(...)]]></literal> does, is explained in <xref linkend="lambda.nullary_functors_and_ret"/>.
-->
      </para>
    </section>

    <section id="lambda.actual_arguments_to_lambda_functors">
      <title>About actual arguments to lambda functors 关于 lambda 仿函数的实际参数</title>

<!--      <para><emphasis>This section is no longer (or currently) relevant;
       acual arguments can be non-const rvalues.
       The section can, however, become relevant again, if in the future BLL will support
       lambda functors with higher arities than 3.</emphasis></para> -->

      <para>A general restriction for the actual arguments is that they cannot be non-const rvalues. 
	For example:<sbr/>
    对实际参数的一个大体限制是它们不能是非常量的右值。例如：

<programlisting>
int i = 1; int j = 2; 
(_1 + _2)(i, j); // ok
(_1 + _2)(1, 2); // error (!)
</programlisting>

	This restriction is not as bad as it may look. 
	Since the lambda functors are most often called inside STL-algorithms, 
	the arguments originate from dereferencing iterators and the dereferencing operators seldom return rvalues.
	And for the cases where they do, there are workarounds discussed in 
<xref linkend="lambda.rvalues_as_actual_arguments"/>.<sbr/>
这一限制也许不像看上去那么糟糕。因为 lambda 仿函数最常用在 STL 算法中，
参数来自于很少返回右值的间接引用迭代器和间接引用操作符。对于它们返回右值的情况，
相关讨论参见 <xref linkend="lambda.rvalues_as_actual_arguments"/>。


      </para>

    </section>


<section id="lambda.storing_bound_arguments">

<title>Storing bound arguments in lambda functions 在 lambda 函数中存储已绑定参数</title>
      
<para>

By default, temporary const copies of the bound arguments are stored 
in the lambda functor.

This means that the value of a bound argument is fixed at the time of the 
creation of the lambda function and remains constant during the lifetime 
of the lambda function object.
For example:<sbr/>
缺省情况下，已绑定参数的 temporary const copies（临时常拷贝）存储在 lambda 仿函数中。
这就意味着已绑定参数的值在 lambda 函数的创建时是固定的，而且在这个 lambda 函数对象的整个生命周期中也会保持不变。例如：
<programlisting>
int i = 1;
(_1 = 2, _1 + i)(i);
</programlisting>
The comma operator is overloaded to combine lambda expressions into a sequence;
the resulting unary lambda functor first assigns 2 to its argument, 
then adds the value of <literal>i</literal> to it.
The value of the expression in the last line is 3, not 4. 
In other words, the lambda expression that is created is
<literal>lambda x.(x = 2, x + 1)</literal> rather than
<literal>lambda x.(x = 2, x + i)</literal>.<sbr/>
逗号操作符被重载用来将 lambda 表达式结合到一个序列中，结果是，一元 lambda 仿函数的参数首先被赋为 2，
然后再为它加上 <literal>i</literal> 的值。最终表达式的值是 3，不是 4。换句话说，lambda 表达式由 
<literal>lambda x.(x = 2, x + 1)</literal> 创建，而不是 <literal>lambda x.(x = 2, x + i)</literal>。
      
</para>

<para>

As said, this is the default behavior for which there are exceptions.
The exact rules are as follows:<sbr/>
就像我们说过的，这是有例外的缺省行为。严格的规则如下：

<itemizedlist>

<listitem>

<para>

The programmer can control the storing mechanism with <literal>ref</literal> 
and <literal>cref</literal> wrappers <xref linkend="cit:boost::ref"/>.

Wrapping an argument with <literal>ref</literal>, or <literal>cref</literal>, 
instructs the library to store the argument as a reference, 
or as a reference to const respectively.

For example, if we rewrite the previous example and wrap the variable 
<literal>i</literal> with <literal>ref</literal>, 
we are creating the lambda expression <literal>lambda x.(x = 2, x + i)</literal> 
and the value of the expression in the last line will be 4:<sbr/>
程序员可以控制使用 <literal>ref</literal> 和 <literal>cref</literal> 包装的存储机制 [<xref linkend="cit:boost::ref"/>]。
用 <literal>ref</literal> 或 <literal>cref</literal> 包装一个参数，分别指示库将参数作为一个引用或常引用来存储。
例如，如果我们重写前面的示例，并用 <literal>ref</literal> 包装变量 <literal>i</literal>，
我们可以创建 lambda 表达式 <literal>lambda x.(x = 2, x + i)</literal> ，而且表达式最终的值是 4：

<programlisting>
i = 1;
(_1 = 2, _1 + ref(i))(i);
</programlisting>

Note that <literal>ref</literal> and <literal>cref</literal> are different
from <literal>var</literal> and <literal>constant</literal>.

While the latter ones create lambda functors, the former do not. 
For example:<sbr/>
注意，<literal>ref</literal> 和 <literal>cref</literal> 不同于 <literal>var</literal> 和 <literal>constant</literal>。
后者创建 lambda 仿函数，而前者不创建。例如：

<programlisting>
int i; 
var(i) = 1; // ok
ref(i) = 1; // not ok, ref(i) is not a lambda functor
</programlisting>

The functions <literal>ref</literal> and <literal>cref</literal> mostly 
exist for historical reasons,
and <literal>ref</literal> can always
be replaced with <literal>var</literal>, and <literal>cref</literal> with
<literal>constant_ref</literal>. 
See <xref linkend="lambda.delaying_constants_and_variables"/> for details.
The <literal>ref</literal> and <literal>cref</literal> functions are
general purpose utility functions in Boost, and hence defined directly
in the <literal moreinfo="none">boost</literal> namespace.<sbr/>
函数 <literal>ref</literal> 和 <literal>cref</literal> 的存在主要是由于历史原因，
而且 <literal>ref</literal> 总是能被 <literal>var</literal> 取代，而 <literal>cref</literal> 
总能被 <literal>constant_ref</literal> 取代。关于细节，参见 <xref linkend="lambda.delaying_constants_and_variables"/>。
<literal>ref</literal> 和 <literal>cref</literal> 函数是 Boost 中的通用工具函数，
因此直接定义在 <literal moreinfo="none">boost</literal> 名字空间中。

</para>
</listitem>
	  
<listitem>
<para>
Array types cannot be copied, they are thus stored as const reference by default.<sbr/>
数组类型不能被拷贝，因此，缺省情况下，它们作为常引用存储。
</para>
</listitem>

<listitem>

<para> 
For some expressions it makes more sense to store the arguments as references. 

For example, the obvious intention of the lambda expression 
<literal>i += _1</literal> is that calls to the lambda functor affect the 
value of the variable <literal>i</literal>, 
rather than some temporary copy of it. 

As another example, the streaming operators take their leftmost argument 
as non-const references. 

The exact rules are:<sbr/>
对于某些表达式，参数作为引用存储更有意义。例如，lambda 表达式 <literal>i += _1</literal> 
的意图很明显是要调用 lambda 仿函数以影响变量 <literal>i</literal> 的值，而不是它的什么临时拷贝。
再例如，流操作符把它的最左边的参数作为 非常量引用。严格规则为：

<itemizedlist>
<listitem>
<para>The left argument of compound assignment operators (<literal>+=</literal>, <literal>*=</literal>, etc.) are stored as references to non-const.<sbr/>
混合赋值操作符 (<literal>+=</literal>, <literal>*=</literal>, 等等) 的左参数作为引向非常量的引用存储。</para>
</listitem>

<listitem>
<para>If the left argument of <literal><![CDATA[<<]]></literal> or <literal><![CDATA[>>]]></literal>  operator is derived from an instantiation of <literal>basic_ostream</literal> or respectively from <literal>basic_istream</literal>, the argument is stored as a reference to non-const. 
For all other types, the argument is stored as a copy.<sbr/>
如果 <literal><![CDATA[<<]]></literal> 或 <literal><![CDATA[>>]]></literal> 操作符的左参数分别从 <literal>basic_ostream</literal> 
或 <literal>basic_istream</literal> 的实例派生，则参数作为引向非常量的引用存储。对于所有其它类型，参数作为一个拷贝存储。
</para>
</listitem>

<listitem>
<para>
In pointer arithmetic expressions, non-const array types are stored as non-const references.
This is to prevent pointer arithmetic making non-const arrays const. <sbr/>
在指针算数表达式中，非常量数组作为非常量引用来存储。这是为了防止指针算术运算使非常量数组常量化。

</para>
</listitem> 

</itemizedlist>

</para>
</listitem>

</itemizedlist>
</para>

</section>

</section>

<section id="lambda.le_in_details">
<title>Lambda expressions in details  lambda表达式详细研究</title>

<para>
This section describes different categories of lambda expressions in details.
We devote a separate section for each of the possible forms of a lambda expression.<sbr/>
本节详细描述 lambda 表达式的各个不同方面。我们为一个 lambda 表达式的每一种可能的形式都投入一个专门的部分。


</para>

<section id="lambda.placeholders">
<title>Placeholders 占位符</title>

<para>
The BLL defines three placeholder types: <literal>placeholder1_type</literal>, <literal>placeholder2_type</literal> and <literal>placeholder3_type</literal>. 
BLL has a predefined placeholder variable for each placeholder type: <literal>_1</literal>, <literal>_2</literal> and <literal>_3</literal>. 
However, the user is not forced to use these placeholders. 
It is easy to define placeholders with alternative names.
This is done by defining new variables of placeholder types. 
For example:<sbr/>
BLL 定义了三个占位符类型：<literal>placeholder1_type</literal>, <literal>placeholder2_type</literal> 
和 <literal>placeholder3_type</literal>。BLL 为每一个占位符类型提供了一个预定义的占位符变量：
<literal>_1</literal>, <literal>_2</literal> 和 <literal>_3</literal>。然而，用户并没有被强制使用这些变量，
定义其它名字的占位符也很简单。可以通过定义新的占位符类型的变量来做到这一点。例如：

<programlisting>boost::lambda::placeholder1_type X;
boost::lambda::placeholder2_type Y;
boost::lambda::placeholder3_type Z;
</programlisting>

With these variables defined, <literal>X += Y * Z</literal> is equivalent to <literal>_1 += _2 * _3</literal>.<sbr/>
有了这些变量定义，那么 <literal>X += Y * Z</literal> 就等价于 <literal>_1 += _2 * _3</literal>。
</para>

<para>
The use of placeholders in the lambda expression determines whether the resulting function is nullary, unary, binary or 3-ary. 
The highest placeholder index is decisive. For example:<sbr/>
占位符在 lambda 表达式中的使用决定了结果函数是无元的，一元的，二元的还是三元的。这由最高的占位符索引决定。例如：

<programlisting>
_1 + 5              // unary
_1 * _1 + _1        // unary
_1 + _2             // binary
bind(f, _1, _2, _3) // 3-ary
_3 + 10             // 3-ary
</programlisting>

Note that the last line creates a 3-ary function, which adds <literal>10</literal> to its <emphasis>third</emphasis> argument. 
The first two arguments are discarded.
Furthermore, lambda functors only have a minimum arity.
One can always provide more arguments (up the number of supported placeholders)
that is really needed.
The remaining arguments are just discarded.
For example:<sbr/>
注意，最后一行创建了一个三元函数，它在它的<emphasis>第三个</emphasis>参数上加 <literal>10</literal>。
不去理会前两个参数。而且，lambda 仿函数只有一个最小的数量。它总能提供真正需要的更多的参数（增加支持占位符的数量）。
多余的参数只是被丢弃。例如：

<programlisting>
int i, j, k; 
_1(i, j, k)        // returns i, discards j and k
(_2 + _2)(i, j, k) // returns j+j, discards i and k
</programlisting>

See
<xref linkend="lambda.why_weak_arity"/> for the design rationale behind this
functionality.<sbr/>
如果要了解这一功能背后的设计原理，参见 <xref linkend="lambda.why_weak_arity"/>。

</para>

<para>
In addition to these three placeholder types, there is also a fourth placeholder type <literal>placeholderE_type</literal>.
The use of this placeholder is defined in <xref linkend="lambda.exceptions"/> describing exception handling in lambda expressions.<sbr/>
除了这三个占位符类型之外，还有第四个占位符类型 <literal>placeholderE_type</literal>。
这个占位符的作用是定义 <xref linkend="lambda.exceptions"/> 描述的 lambda 表达式中的异常处理。 
</para>

<para>When an actual argument is supplied for a placeholder, the parameter passing mode is always by reference. 
This means that any side-effects to the placeholder are reflected to the actual argument. 
For example:<sbr/>
为一个占位符提供真正的参数的时候，参数传递的方式总是传引用。这就意味着任何影响占位符的副作用都会反映到实际参数上。例如：


<programlisting>
<![CDATA[int i = 1; 
(_1 += 2)(i);         // i is now 3
(++_1, cout << _1)(i) // i is now 4, outputs 4]]>
</programlisting>
</para>

</section>

<section id="lambda.operator_expressions">
<title>Operator expressions 操作符表达式</title>

<para>
The basic rule is that any C++ operator invocation with at least one argument being a lambda expression is itself a lambda expression.
Almost all overloadable operators are supported. 
For example, the following is a valid lambda expression:<sbr/>
基本规则是任何 C++ 操作符调用，只要它的参数中至少有一个是 lambda 表达式，则这个调用本身也是 lambda 表达式。
几乎所有的能重载操作符都已被支持。例如，下面就是一个合法的 lambda 表达式：

<programlisting><![CDATA[cout << _1, _2[_3] = _1 && false]]></programlisting>
</para>

<para>
However, there are some restrictions that originate from the C++ operator overloading rules, and some special cases.<sbr/>
然而，有一些来自于 C++ 操作符重载规则的限制，以及一些特殊情况。
</para>


<section>
<title>Operators that cannot be overloaded 不能重载的操作符</title>

<para>
Some operators cannot be overloaded at all (<literal>::</literal>, <literal>.</literal>, <literal>.*</literal>).
For some operators, the requirements on return types prevent them to be overloaded to create lambda functors.
These operators are <literal>->.</literal>, <literal>-></literal>, <literal>new</literal>, <literal>new[]</literal>, <literal>delete</literal>, <literal>delete[]</literal> and <literal>?:</literal> (the conditional operator).<sbr/>
有些操作符根本不能重载（<literal>::</literal>, <literal>.</literal>, <literal>.*</literal>）。
对于有些操作符，对返回类型的要求阻碍了它们为创建 lambda 函数而重载。这些操作符有 <literal>->.</literal>, 
<literal>-></literal>, <literal>new</literal>, <literal>new[]</literal>, <literal>delete</literal>, <literal>delete[]</literal> 
和 <literal>?:</literal>（条件操作符）。
</para>

</section>

<section id="lambda.assignment_and_subscript">
<title>Assignment and subscript operators 赋值和下标操作符</title>

<para>
These operators must be implemented as class members. 
Consequently, the left operand must be a lambda expression. For example:<sbr/>
这些操作符必须被实现为类成员。因此，左操作数必须是一个 lambda 表达式。例如：

<programlisting>
int i; 
_1 = i;      // ok
i = _1;      // not ok. i is not a lambda expression
</programlisting>

There is a simple solution around this limitation, described in <xref linkend="lambda.delaying_constants_and_variables"/>.
In short, 
the left hand argument can be explicitly turned into a lambda functor by wrapping it with a special <literal>var</literal> function:<sbr/>
关于这一限制有一个简单的解决方案，在 <xref linkend="lambda.delaying_constants_and_variables"/>描述。
简而言之，就是通过用一个特殊的 <literal>var</literal> 函数进行包装，左侧参数可以被显式转变为 lambda 仿函数：
<programlisting>
var(i) = _1; // ok
</programlisting>

</para>
</section>

<section id="lambda.logical_operators">
<title>Logical operators 逻辑操作符</title>

<para>
Logical operators obey the short-circuiting evaluation rules. For example, in the following code, <literal>i</literal> is never incremented:<sbr/>
逻辑操作符服从短路求值规则。例如，在下面的代码中，<literal>i</literal> 没有被增加：
<programlisting>
bool flag = true; int i = 0;
(_1 || ++_2)(flag, i);
</programlisting>
</para>
</section>

<section id="lambda.comma_operator">
<title>Comma operator 逗号操作符</title>

<para>
Comma operator is the <quote>statement separator</quote> in lambda expressions. 
Since comma is also the separator between arguments in a function call, extra parenthesis are sometimes needed:<sbr/>
逗号操作符在 lambda 表达式中是<quote>语句分隔符</quote>。因为逗号也是函数调用中的参数分隔符，所以有时需要额外的括号：

<programlisting>
for_each(a.begin(), a.end(), (++_1, cout &lt;&lt; _1));
</programlisting>

Without the extra parenthesis around <literal>++_1, cout &lt;&lt; _1</literal>, the code would be interpreted as an attempt to call <literal>for_each</literal> with four arguments.<sbr/>
如果没有包围 <literal>++_1, cout &lt;&lt; _1</literal> 的额外括号，这行代码的意图会被解释为用四个参数调用 
<literal>for_each</literal>。
</para>
<para>
The lambda functor created by the comma operator adheres to the C++ rule of always evaluating the left operand before the right one.
In the above example, each element of <literal>a</literal> is first incremented, then written to the stream.<sbr/>
使用逗号操作符建立的 lambda 仿函数坚 C++ 中左操作数的求值总是先于右操作数的规则。在上面的示例中，
<literal>a</literal> 中的每一个元素首先被增 1，然后才写入流中。
</para>
</section>

<section id="lambda.function_call_operator">
<title>Function call operator 函数调用操作符</title>

<para>
The function call operators have the effect of evaluating the lambda
functor. 
Calls with too few arguments lead to a compile time error.<sbr/>
函数调用操作符有求 lambda 仿函数的值的作用。用过多的参数调用会导致一个编译时错误。
</para>
</section>

<section id="lambda.member_pointer_operator">
<title>Member pointer operator 成员指针操作符</title>

<para>
The member pointer operator <literal>operator->*</literal> can be overloaded freely. 
Hence, for user defined types, member pointer operator is no special case.
The built-in meaning, however, is a somewhat more complicated case.
The built-in member pointer operator is applied if the left argument is a pointer to an object of some class <literal>A</literal>, and the right hand argument is a pointer to a member of <literal>A</literal>, or a pointer to a member of a class from which <literal>A</literal> derives.
We must separate two cases:<sbr/>
成员指针操作符 <literal>operator->*</literal> 可以随意重载，因此，对于用户定义类型，成员指针操作符没有特定的情况。
然而，它的内建的意义，却稍微有些复杂。内建成员指针操作符被用于以下情况：左参数是一个指向某个类 <literal>A</literal> 
的对象的指针，而右手参数是一个指向 <literal>A</literal> 的一个成员的指针，或者是一个指向从 <literal>A</literal> 
派生的类的一个成员的指针。我们必须区分以下两种情况：

<itemizedlist>

<listitem>
<para>The right hand argument is a pointer to a data member. 
In this case the lambda functor simply performs the argument substitution and calls the built-in member pointer operator, which returns a reference to the member pointed to. 
For example:<sbr/>
右手参数是一个数据成员的指针。在这种情况下，lambda 仿函数简单地执行参数替换并调用内建成员指针操作符，
它返回一个引向它所指向的成员的引用。例如：
<programlisting>
<![CDATA[struct A { int d; };
A* a = new A();
  ...
(a ->* &A::d);     // returns a reference to a->d 
(_1 ->* &A::d)(a); // likewise]]>
</programlisting>
</para>
</listitem>

<listitem>
<para>
The right hand argument is a pointer to a member function.
For a built-in call like this, the result is kind of a delayed member function call. 
Such an expression must be followed by a function argument list, with which the delayed member function call is performed.
For example:<sbr/>
右侧参数是一个指向成员函数的指针。对于一个像这样的内建调用，结果有点儿像一个被延迟的成员函数调用。
这样一个表达式必须在后面跟一个函数参数列表，以使得这个被延迟的成员函数调用可以被执行。例如：
<programlisting>
<![CDATA[struct B { int foo(int); };
B* b = new B();
  ...
(b ->* &B::foo)         // returns a delayed call to b->foo
                        // a function argument list must follow
(b ->* &B::foo)(1)      // ok, calls b->foo(1)

(_1 ->* &B::foo)(b);    // returns a delayed call to b->foo, 
                        // no effect as such
(_1 ->* &B::foo)(b)(1); // calls b->foo(1)]]>
</programlisting>
</para>
</listitem>
</itemizedlist>
</para>
</section>

</section>

<section id="lambda.bind_expressions">
<title>Bind expressions bind表达式</title>

<para>
Bind expressions can have two forms: <sbr/>
bind 表达式可以有两种形式：

<!-- TODO: shouldn't really be emphasis, but a variable or something-->
<programlisting>
bind(<parameter>target-function</parameter>, <parameter>bind-argument-list</parameter>)
bind(<parameter>target-member-function</parameter>, <parameter>object-argument</parameter>, <parameter>bind-argument-list</parameter>)
</programlisting>

A bind expression delays the call of a function. 
If this <emphasis>target function</emphasis> is <emphasis>n</emphasis>-ary, then the <literal><emphasis>bind-argument-list</emphasis></literal> must contain <emphasis>n</emphasis> arguments as well.
In the current version of the BLL, <inlineequation>0 &lt;= n &lt;= 9</inlineequation> must hold. 
For member functions, the number of arguments must be at most <inlineequation>8</inlineequation>, as the object argument takes one argument position.

Basically, the
<emphasis><literal>bind-argument-list</literal></emphasis> must be a valid argument list for the target function, except that any argument can be replaced with a placeholder, or more generally, with a lambda expression. 
Note that also the target function can be a lambda expression.

The result of a bind expression is either a nullary, unary, binary or 3-ary function object depending on the use of placeholders in the <emphasis><literal>bind-argument-list</literal></emphasis> (see <xref linkend="lambda.placeholders"/>).<sbr/>
一个 bind 表达式延迟了一个函数的调用。如果这个 <emphasis>target function</emphasis> 是 <emphasis>n</emphasis> 元的，
那么 <literal><emphasis>bind-argument-list</emphasis></literal> 也必须同样包含 <emphasis>n</emphasis> 个参数。
在 BLL 的当前版本中，必须保证 <inlineequation>0 &lt;= n &lt;= 9</inlineequation>。对于成员函数来说，
参数的数目最高为 <inlineequation>8</inlineequation>，因为对象参数要占有一个参数位置。总的来说，
除了任何一个参数都能被一个占位符（更一般地说，是 lambda 表达式）取代之外，还要求 
<emphasis><literal>bind-argument-list</literal></emphasis> 对于目标函数来说必须是一个合法的参数列表。
注意，目标函数也可以是一个 lambda 表达式。根据在 <emphasis><literal>bind-argument-list</literal></emphasis> 
中占位符的使用，一个 bind 表达式的结果可以是无元的，一元的，二元的或三元的函数对象
（参见 <xref linkend="lambda.placeholders"/>）。
</para>

<para>
The return type of the lambda functor created by the bind expression can be given as an explicitly specified template parameter, as in the following example:<sbr/>
bind 表达式创建的 lambda 仿函数的返回类型可以由显式特化的模板参数给定，就像下面的示例：
<programlisting>
bind&lt;<emphasis>RET</emphasis>&gt;(<emphasis>target-function</emphasis>, <emphasis>bind-argument-list</emphasis>)
</programlisting>
This is only necessary if the return type of the target function cannot be deduced.<sbr/>
这一方法只有在目标函数的返回类型不能被推演出来的情况下才是必要的。
</para>

<para>
The following sections describe the different types of bind expressions.<sbr/>
以下部分描述 bind 表达式的不同类型。
</para>

<section id="lambda.function_pointers_as_targets">
<title>Function pointers or references as targets 以函数指针或引用为目标</title>

<para>The target function can be a pointer or a reference to a function and it can be either bound or unbound. For example:<sbr/>
目标函数可以是指向一个函数的指针或引向一个函数的引用，而且它可以使已被绑定的或未被绑定的。例如：
<programlisting>
<![CDATA[X foo(A, B, C); A a; B b; C c;
bind(foo, _1, _2, c)(a, b);
bind(&foo, _1, _2, c)(a, b);
bind(_1, a, b, c)(foo);]]>
</programlisting>
 
The return type deduction always succeeds with this type of bind expressions. <sbr/>
这种类型的 bind 表达式的返回类型推演总是能够成功。
</para>

<para>
Note, that in C++ it is possible to take the address of an overloaded function only if the address is assigned to, or used as an initializer of, a variable, the type of which solves the amibiguity, or if an explicit cast expression is used.
This means that overloaded functions cannot be used in bind expressions directly, e.g.:<sbr/>
注意，在 C++ 中，只有当一个重载函数的地址符合以下条件，才可能持有这个地址，它被赋值给一个变量，
或用于初始化一个变量，这个变量的类型消除了多义性，或者使用了一个显式的强制转型表达式。
这就意味着重载函数不能直接用于一个 bind 表达式，例如：
<programlisting>
<![CDATA[void foo(int);
void foo(float);
int i; 
  ...
bind(&foo, _1)(i);                            // error 
  ...
void (*pf1)(int) = &foo;
bind(pf1, _1)(i);                             // ok
bind(static_cast<void(*)(int)>(&foo), _1)(i); // ok]]>
</programlisting>
</para>
</section>

<section id="member_functions_as_targets">
<title>Member functions as targets 以成员函数为目标</title>

<para>
The syntax for using pointers to member function in bind expression is:<sbr/>
在 bind 表达式内使用指向成员函数的指针的语法为：
<programlisting>
bind(<parameter>target-member-function</parameter>, <parameter>object-argument</parameter>, <parameter>bind-argument-list</parameter>)
</programlisting>

The object argument can be a reference or pointer to the object, the BLL supports both cases with a uniform interface: <sbr/>
对象参数可以是一个引向对象的引用或指向对象的指针，BLL 以同样的接口支持这两种情况：

<programlisting>
<![CDATA[bool A::foo(int) const; 
A a;
vector<int> ints; 
  ...
find_if(ints.begin(), ints.end(), bind(&A::foo, a, _1)); 
find_if(ints.begin(), ints.end(), bind(&A::foo, &a, _1));]]>
</programlisting>

Similarly, if the object argument is unbound, the resulting lambda functor can be called both via a pointer or a reference:<sbr/>
类似地，如果对象参数是未绑定的，则作为结果的 lambda 仿函数可以通过指针或者引用调用：

<programlisting>
<![CDATA[bool A::foo(int); 
list<A> refs; 
list<A*> pointers; 
  ...
find_if(refs.begin(), refs.end(), bind(&A::foo, _1, 1)); 
find_if(pointers.begin(), pointers.end(), bind(&A::foo, _1, 1));]]>
</programlisting>

</para>

<!--%The exact rules for the object argument (whether it is bound, or supplied in the lambda function invoction) are as follows:
%If the target function is a pointer to a member function of some class \snip{A}, then the object argument must be an expression of type \snip{B}, where either
%\begin{itemize}
%\item \snip{B} = \snip{A} or there is an implicit conversion from \snip{B} to \snip{A}.
%\item \snip{B} = \snip{A*}.
%\item \snip{B} = \snip{C*}, where \snip{C} is any class derived form \snip{A}.
%\end{itemize}
%For example:
%\begin{alltt}
%struct A \{
%  virtual void f();
%  void fc() const;
%\};
%
%struct B : public A \{ 
%  virtual void f(); 
%\};
%
%struct C \{
%  operator A const() \{ return A(); \}
%\};
%
% A a; B b; C c;
%  ...
% bind(&A::f, a)(); 
% bind(&A::f, b)(); // calls B::f
% bind(&A::fc, c)(); 
%
% bind(&A::f, &a)();
% bind(&A::f, &b)(); // calls B::f
% bind(&A::f, &c)(); // error: no conversion from C* \(\rightarrow\) A, 
%\end{alltt}
-->

<para>
Even though the interfaces are the same, there are important semantic differences between using a pointer or a reference as the object argument.
The differences stem from the way <literal>bind</literal>-functions take their parameters, and how the bound parameters are stored within the lambda functor.
The object argument has the same parameter passing and storing mechanism as any other bind argument slot (see <xref linkend="lambda.storing_bound_arguments"/>); it is passed as a const reference and stored as a const copy in the lambda functor.
This creates some asymmetry between the lambda functor and the original member function, and between seemingly similar lambda functors. For example:<sbr/>
尽管接口相同，但是使用一个指针或一个引用作为对象参数还是有重要的语义上的区别。这些区别主要来自于 
<literal>bind</literal>-functions 持有它们的参数的方法是不同的，以及被绑定参数是如何存储在 lambda 仿函数中的。
对象参数与任何其它 bind 参数具有相同的参数传递和存储机制（参见 <xref linkend="lambda.storing_bound_arguments"/>），
它以一个常引用传递并以一个常拷贝存储在 lambda 仿函数中。这就造成了 lambda 仿函数和原来的成员函数之间的不对称，
也造成了表面上类似的 lambda 仿函数之间的不对称。例如：
<programlisting>
class A {
  int i; mutable int j;
public:

  A(int ii, int jj) : i(ii), j(jj) {};
  void set_i(int x) { i = x; }; 
  void set_j(int x) const { j = x; }; 
};
</programlisting>

When a pointer is used, the behavior is what the programmer might expect:<sbr/>
使用一个指针的时候，它的行为可能正符合程序员的预期：

<programlisting>
<![CDATA[A a(0,0); int k = 1;
bind(&A::set_i, &a, _1)(k); // a.i == 1
bind(&A::set_j, &a, _1)(k); // a.j == 1]]>
</programlisting>

Even though a const copy of the object argument is stored, the original object <literal>a</literal> is still modified.
This is since the object argument is a pointer, and the pointer is copied, not the object it points to.
When we use a reference, the behaviour is different:<sbr/>
尽管存储的是一个对象参数的常拷贝，原始对象 <literal>a</literal> 还是被改变了。这是因为对象参数是一个指针，
是这个指针本身，而不是它指向的对象，被拷贝。使用一个引用的时候，程序的行为会有所不同：

<programlisting>
<![CDATA[A a(0,0); int k = 1;
bind(&A::set_i, a, _1)(k); // error; a const copy of a is stored. 
                           // Cannot call a non-const function set_i
bind(&A::set_j, a, _1)(k); // a.j == 0, as a copy of a is modified]]>
</programlisting>
</para>

<para>
To prevent the copying from taking place, one can use the <literal>ref</literal> or <literal>cref</literal> wrappers (<literal>var</literal> and <literal>constant_ref</literal> would do as well):<sbr/>
为了防止拷贝的发生，可以使用 <literal>ref</literal> 或 <literal>cref</literal> 包装
（<literal>var</literal> 和 <literal>constant_ref</literal> 也同样可以使用）：
<programlisting>
<![CDATA[bind(&A::set_i, ref(a), _1)(k); // a.j == 1
bind(&A::set_j, cref(a), _1)(k); // a.j == 1]]>
</programlisting>
</para>

<para>Note that the preceding discussion is relevant only for bound arguments. 
If the object argument is unbound, the parameter passing mode is always by reference. 
Hence, the argument <literal>a</literal> is not copied in the calls to the two lambda functors below:<sbr/>
注意，前面的讨论只与被绑定参数有关。如果这个对象参数是未绑定的，参数传递模式总是以传引用的方式。
因此，在下面两个 lambda 仿函数的调用中参数 <literal>a</literal> 不会被拷贝进来：
<programlisting>
<![CDATA[A a(0,0);
bind(&A::set_i, _1, 1)(a); // a.i == 1
bind(&A::set_j, _1, 1)(a); // a.j == 1]]>
</programlisting>
</para>
</section>

<section id="lambda.members_variables_as_targets">
<title>Member variables as targets 以成员变量为目标</title>

<para>
A pointer to a member variable is not really a function, but 
the first argument to the <literal>bind</literal> function can nevertheless
be a pointer to a member variable.
Invoking such a bind expression returns a reference to the data member.
For example:<sbr/>
一个指向成员变量的指针不是一个真正的函数，但是 <literal>bind</literal> 函数的第一个参数依然可以是一个指向成员变量的指针。
调用这样一个 bind 表达式会返回一个引向这个数据成员的引用。例如：

<programlisting>
<![CDATA[struct A { int data; };
A a;
bind(&A::data, _1)(a) = 1;     // a.data == 1]]>
</programlisting>

The cv-qualifiers of the object whose member is accessed are respected.
For example, the following tries to write into a const location:<sbr/>
成员被访问的那个对象的 cv 修饰符（c 为 const，v 为 volatile ——译者注）也需要被考虑。
例如，下面的例子就是试图写到一个 const 区域中：
<programlisting>
<![CDATA[const A ca = a;
bind(&A::data, _1)(ca) = 1;     // error]]>
</programlisting>

</para>
</section>

<section id="lambda.function_objects_as_targets">
<title>Function objects as targets 以函数对象为目标</title>

<para>

Function objects, that is, class objects which have the function call 
operator defined, can be used as target functions. 

In general, BLL cannot deduce the return type of an arbitrary function object. 

However, there are two methods for giving BLL this capability for a certain 
function object class.<sbr/>
函数对象，换句话说，就是定义了函数调用操作符，可以像目标函数一样使用的类对象。
通常，BLL 不能推演一个任意的函数对象的返回类型。然而，有两种方法赋予 BLL 这种针对某一函数对象类的能力。

</para>

<simplesect>

<title>The result_type typedef 结果类型typedef</title>

<para>

The BLL supports the standard library convention of declaring the return type
of a function object with a member typedef named <literal>result_type</literal> in the
function object class.

Here is a simple example:<sbr/>
BLL 支持标准库的在一个函数对象类中用一个名为 <literal>result_type</literal> 的成员 
typedef 声明一个函数对象的返回类型的惯例。这是一个简单的示例：
<programlisting>
<![CDATA[struct A {
  typedef B result_type;
  B operator()(X, Y, Z); 
};]]>
</programlisting>

If a function object does not define a <literal>result_type</literal> typedef, 
the method described below (<literal>sig</literal> template) 
is attempted to resolve the return type of the
function object. If a function object defines both <literal>result_type</literal>
and <literal>sig</literal>, <literal>result_type</literal> takes precedence.<sbr/>
如果一个函数对象没有定义 <literal>result_type</literal> typedef，下面描述的方法
（<literal>sig</literal> 模板）也可以用来决定函数对象的返回类型。如果一个函数对象既定义了 
<literal>result_type</literal> 也定义了 <literal>sig</literal>，优先使用 <literal>result_type</literal>。

</para>

</simplesect>

<simplesect>

<title>The sig template sig模板</title>

<para>
Another mechanism that make BLL aware of the return type(s) of a function object is defining
member template struct 
<literal><![CDATA[sig<Args>]]></literal> with a typedef 
<literal>type</literal> that specifies the return type.

Here is a simple example:<sbr/>
另一种可以让 BLL 感知一个函数对象的返回类型的机制是定义一个成员模板结构 <literal><![CDATA[sig<Args>]]></literal>，
其中包含一个指定返回类型的 typedef <literal>type</literal>。这是一个简单的示例：
<programlisting>
<![CDATA[struct A {
  template <class Args> struct sig { typedef B type; }
  B operator()(X, Y, Z); 
};]]>
</programlisting>

The template argument <literal>Args</literal> is a 
<literal>tuple</literal> (or more precisely a <literal>cons</literal> list) 
type <xref linkend="cit:boost::tuple"/>, where the first element 
is the function 
object type itself, and the remaining elements are the types of 
the arguments, with which the function object is being called.

This may seem overly complex compared to defining the <literal>result_type</literal> typedef.
Howver, there are two significant restrictions with using just a simple
typedef to express the return type:<sbr/>
模板参数 <literal>Args</literal> 是一个 <literal>tuple</literal>（或者更精确些，
一个 <literal>cons</literal> list（部件链表））类型 [<xref linkend="cit:boost::tuple"/>]，
它的第一个元素是函数对象类型本身，而剩下的元素是调用这个函数对象的参数的类型。
这与 定义一个 <literal>result_type</literal> typedef 相比似乎过于复杂了。
但是，仅仅用一个简单的 typedef 表示返回类型有两个重要的限制：
<orderedlist>
<listitem>
<para>
If the function object defines several function call operators, there is no way to specify different result types for them.<sbr/>
如果这个函数对象定义了不止一个函数调用操作符，它们没有办法指定不同的返回类型。
</para>
</listitem>
<listitem>
<para>
If the function call operator is a template, the result type may 
depend on the template parameters. 
Hence, the typedef ought to be a template too, which the C++ language 
does not support.<sbr/>
如果函数调用操作符是一个模板，则结果类型可能依赖于模板参数。因此，typedef 也应该是一个模板，但 C++ 语言并不支持。
</para>
</listitem>
</orderedlist>

The following code shows an example, where the return type depends on the type
of one of the arguments, and how that dependency can be expressed with the
<literal>sig</literal> template:<sbr/>
下面的代码展示了一个示例，返回类型依赖于一个参数的类型，以及这种依赖是如何通过 
<literal>sig</literal> 模板表达出来的：

<programlisting>
<![CDATA[struct A {

  // the return type equals the third argument type:
  template<class T1, class T2, class T3>
  T3 operator()(const T1& t1, const T2& t2, const T3& t3) const;

  template <class Args> 
  class sig {
    // get the third argument type (4th element)
    typedef typename 
      boost::tuples::element<3, Args>::type T3;
  public:
    typedef typename 
      boost::remove_cv<T3>::type type;
  };
};]]>
</programlisting>


The elements of the <literal>Args</literal> tuple are always 
non-reference types.

Moreover, the element types can have a const or volatile qualifier
(jointly referred to as <emphasis>cv-qualifiers</emphasis>), or both.
This is since the cv-qualifiers in the arguments can affect the return type.
The reason for including the potentially cv-qualified function object 
type itself into the <literal>Args</literal> tuple, is that the function
object class can contain both const and non-const (or volatile, even
const volatile) function call operators, and they can each have a different
return type.<sbr/>
<literal>Args</literal> 的元素总是非引用类型。而且，元素的类型可以有一个 const 或 volatile 修饰符
（合在一起，被称为 <emphasis>cv-qualifiers</emphasis>（cv 修饰符）），或者两者都有。
这是因为参数中的 cv 修饰符会影响返回类型。将潜在的被 cv 修饰过的函数返回类型本身包含到 
<literal>Args</literal> tuple 中的理由，在于函数对象类可以包含 const 和非 const
（或者 volatile，甚至 const volatile）的函数调用操作符，而且它们每一个都会有一个不同的返回类型。
</para>

<para>
The <literal>sig</literal> template can be seen as a 
<emphasis>meta-function</emphasis> that maps the argument type tuple to 
the result type of the call made with arguments of the types in the tuple.

As the example above demonstrates, the template can end up being somewhat 
complex.
Typical tasks to be performed are the extraction of the relevant types 
from the tuple, removing cv-qualifiers etc.
See the Boost type_traits <xref linkend="cit:boost::type_traits"/> and
Tuple <xref linkend="cit:boost::type_traits"/> libraries 
for tools that can aid in these tasks.
The <literal>sig</literal> templates are a refined version of a similar
mechanism first introduced in the FC++ library  
<xref linkend="cit:fc++"/>.<sbr/>
<literal>sig</literal> 模板可以被看做一个 <emphasis>meta-function</emphasis>（元函数），
它使用 tuple 中的参数类型将参数类型 tuple 映射出为调用的返回类型。
从上面的示例看来，那个模板最终变得有些复杂。它所执行的典型任务就是从 tuple 中提取相关类型，
移除 cv 修饰符等等。对于这些能帮助这个任务的工具可以参见 Boost type_traits [<xref linkend="cit:boost::type_traits"/>] 
和 Tuple [<xref linkend="cit:boost::type_traits"/>] 库。<literal>sig</literal> 模板是一个最初在 FC++ 库 
[<xref linkend="cit:fc++"/>] 中引入的类似机制的一个优雅的版本。
</para>

</simplesect>

</section>



</section>

<section id="lambda.overriding_deduced_return_type">
<title>Overriding the deduced return type 越过推演出的返回类型</title>

<para>
The return type deduction system may not be able to deduce the return types of some user defined operators or bind expressions with class objects.
<!-- (see the example in <xref linkend="lambda.parameter_and_return_types"/>).-->
A special lambda expression type is provided for stating the return type explicitly and overriding the deduction system. 
To state that the return type of the lambda functor defined by the lambda expression <literal>e</literal> is <literal>T</literal>, you can write:<sbr/>
返回类型推演系统可能不能推演某些用户定义操作符或带有类对象的 bind 表达式的返回类型。有一种特殊的 lambda 表达式类型被提供，
用于显式表述返回类型和越过推演系统。为了表述由 lambda 表达式 <literal>e</literal> 定义的 lambda 仿函数的返回值的类型为 
<literal>T</literal>，你可以这样写：

<programlisting><![CDATA[ret<T>(e);]]></programlisting>

The effect is that the return type deduction is not performed for the lambda expression <literal>e</literal> at all, but instead, <literal>T</literal> is used as the return type. 
Obviously <literal>T</literal> cannot be an arbitrary type, the true result of the lambda functor must be implicitly convertible to <literal>T</literal>. 
For example:<sbr/>
这样的效果是对这个 lambda 表达式 <literal>e</literal> 的返回类型推演根本就不被执行，改为使用 <literal>T</literal> 作为返回类型。
很明显，<literal>T</literal> 不能是任意类型，那个 lambda 仿函数的真正的返回类型必须能够被隐式转换到 <literal>T</literal>。例如：

<programlisting>
<![CDATA[A a; B b;
C operator+(A, B);
int operator*(A, B); 
  ...
ret<D>(_1 + _2)(a, b);     // error (C cannot be converted to D)
ret<C>(_1 + _2)(a, b);     // ok
ret<float>(_1 * _2)(a, b); // ok (int can be converted to float)
  ...
struct X {
  Y operator(int)();   
};
  ...
X x; int i;
bind(x, _1)(i);            // error, return type cannot be deduced
ret<Y>(bind(x, _1))(i);    // ok]]>
</programlisting>
For bind expressions, there is a short-hand notation that can be used instead of <literal>ret</literal>. 
The last line could alternatively be written as:<sbr/>
对于 bind 表达式，有一个简单的记法用来代替 <literal>ret</literal>。最后一行可以用这种写法：

<programlisting><![CDATA[bind<Z>(x, _1)(i);]]></programlisting>
This feature is modeled after the Boost Bind library <xref linkend="cit:boost::bind"/>.<sbr/>
这一特性是模仿了 Boost Bind 库 <xref linkend="cit:boost::bind"/>。

</para>

<para>Note that within nested lambda expressions, 
the <literal>ret</literal> must be used at each subexpression where 
the deduction would otherwise fail. 
For example:<sbr/>
注意，在嵌套 lambda 表达式中，<literal>ret</literal> 必须被用于每一个推演被舍弃的子表达式。例如：
<programlisting>
<![CDATA[A a; B b;
C operator+(A, B); D operator-(C);
  ...
ret<D>( - (_1 + _2))(a, b); // error 
ret<D>( - ret<C>(_1 + _2))(a, b); // ok]]>
</programlisting>
</para>

<para>If you find yourself using  <literal>ret</literal> repeatedly with the same types, it is worth while extending the return type deduction (see <xref linkend="lambda.extending"/>).<sbr/>
如果你发现你在相同的类型上重复使用 <literal>ret</literal>，那就值得扩展返回类型推演（参见 <xref linkend="lambda.extending"/>）。
</para>

<section id="lambda.nullary_functors_and_ret">
<title>Nullary lambda functors and ret 无元lambda仿函数和 ret</title>

<para>
As stated above, the effect of <literal>ret</literal> is to prevent the return type deduction to be performed. 
However, there is an exception. 
Due to the way the C++ template instantiation works, the compiler is always forced to instantiate the return type deduction templates for zero-argument lambda functors.
This introduces a slight problem with <literal>ret</literal>, best described with an example:<sbr/>
就像上面所表述的，<literal>ret</literal> 的作用是阻止执行返回类型推演。然而，有一个例外。由于 C++ 模板实例化的工作方式，
对于 0 参数的 lambda 仿函数，编译器总是强制实例化返回类型推演模板。这里介绍一个 <literal>ret</literal> 的小问题，
最好用一个例子来说明：

<programlisting>
<![CDATA[struct F { int operator()(int i) const; }; 
F f;
  ...
bind(f, _1);           // fails, cannot deduce the return type
ret<int>(bind(f, _1)); // ok
  ...
bind(f, 1);            // fails, cannot deduce the return type
ret<int>(bind(f, 1));  // fails as well!]]>
</programlisting>
The BLL cannot deduce the return types of the above bind calls, as <literal>F</literal> does not define the typedef <literal>result_type</literal>. 
One would expect <literal>ret</literal> to fix this, but for the nullary lambda functor that results from a bind expression (last line above) this does not work.
The return type deduction templates are instantiated, even though it would not be necessary and the result is a compilation error.<sbr/>
BLL 不能推演出上面的 bind 调用的返回类型，因为 <literal>F</literal> 没有定义 typedef <literal>result_type</literal>。
有人希望用 <literal>ret</literal> 来修复它，但是对于无元 lambda 仿函数来说，来自于 bind 表达式（上面最后一行）
的结果不能工作。返回类型推演模板已经被实例化，即使它没有必要而结果是一个编译错误。
</para>

<para>The solution to this is not to use the <literal>ret</literal> function, but rather define the return type as an explicitly specified template parameter in the <literal>bind</literal> call:<sbr/>
这个问题的解决方案是不使用 <literal>ret</literal> 函数，而是将返回类型定义成 <literal>bind</literal> 
调用中的一个显式特化的模板参数：
<programlisting>
<![CDATA[bind<int>(f, 1);       // ok]]>
</programlisting>

The lambda functors created with 
<literal>ret&lt;<parameter>T</parameter>&gt;(bind(<parameter>arg-list</parameter>))</literal> and 
<literal>bind&lt;<parameter>T</parameter>&gt;(<parameter>arg-list</parameter>)</literal> have the exact same functionality &mdash;
apart from the fact that for some nullary lambda functors the former does not work while the latter does. <sbr/>
使用 <literal>ret&lt;<parameter>T</parameter>&gt;(bind(<parameter>arg-list</parameter>))</literal> 和 
<literal>bind&lt;<parameter>T</parameter>&gt;(<parameter>arg-list</parameter>)</literal> 
创建的仿函数具有完全相同的功能 &mdash; 实际上的区别是对于某些无元 lambda 仿函数，后者可以工作，而前者不行。
</para>
</section>
</section>


<section id="lambda.delaying_constants_and_variables">
<title>Delaying constants and variables 延迟常量和变量</title>

<para>
The unary functions <literal>constant</literal>,
<literal>constant_ref</literal> and <literal>var</literal> turn their argument into a lambda functor, that implements an identity mapping.
The former two are for constants, the latter for variables. 
The use of these <emphasis>delayed</emphasis> constants and variables is sometimes necessary due to the lack of explicit syntax for lambda expressions. 
For example:<sbr/>
一元函数 <literal>constant</literal>，<literal>constant_ref</literal> 和 <literal>var</literal> 
将它们的参数变成一个实现恒等映射的 lambda 仿函数，前两个用于常量，后面的用于变量。
为了明确 lambda 表达式的语法，这些<emphasis>延迟</emphasis>常量和变量的使用有时是有必要的。例如：
<programlisting>
<![CDATA[for_each(a.begin(), a.end(), cout << _1 << ' ');
for_each(a.begin(), a.end(), cout << ' ' << _1);]]>
</programlisting>
The first line outputs the elements of <literal>a</literal> separated by spaces, while the second line outputs a space followed by the elements of <literal>a</literal> without any separators.
The reason for this is that neither of the operands of 
<literal><![CDATA[cout << ' ']]></literal> is a lambda expression, hence <literal><![CDATA[cout << ' ']]></literal> is evaluated immediately.

To delay the evaluation of <literal><![CDATA[cout << ' ']]></literal>, one of the operands must be explicitly marked as a lambda expression. 
This is accomplished with the <literal>constant</literal> function:<sbr/>
第一行输出以逗号分隔的 <literal>a</literal> 的元素，第二行输出一个空格，后面跟着没有任何分隔符的 <literal>a</literal> 的元素。
这里的原因在于 <literal><![CDATA[cout << ' ']]></literal> 中的两个操作数都不是 lambda 表达式，因此 
<literal><![CDATA[cout << ' ']]></literal> 被立即求值。为了延迟 <literal><![CDATA[cout << ' ']]></literal> 的求值，
其中一个操作数必须被显式标记为一个 lambda 表达式。这正是 <literal>constant</literal> 函数的用武之地：
<programlisting>
<![CDATA[for_each(a.begin(), a.end(), cout << constant(' ') << _1);]]>
</programlisting>

The call <literal>constant(' ')</literal> creates a nullary lambda functor which stores the character constant <literal>' '</literal> 
and returns a reference to it when invoked. 
The function <literal>constant_ref</literal> is similar, except that it
stores a constant reference to its argument.

The <literal>constant</literal> and <literal>consant_ref</literal> are only
needed when the operator call has side effects, like in the above example.<sbr/>
调用 <literal>constant(' ')</literal> 创建了一个无元 lambda 仿函数，它存储着字符常量 <literal>' '</literal> ，
并在被调用时返回这个字符常量的一个引用。函数 <literal>constant_ref</literal> 与此类似，只不过它存储的是它的参数的一个常引用。
<literal>constant</literal> 和 <literal>constant_ref</literal> 只有在操作符调用有副作用的时候才需要使用，就像上面的那个例子一样。
</para>

<para>
Sometimes we need to delay the evaluation of a variable. 
Suppose we wanted to output the elements of a container in a numbered list:<sbr/>
有时我们需要延迟一个变量的求值。假设我们要输出一个容器中的元素到一个带有编号的列表中：

<programlisting>
<![CDATA[int index = 0; 
for_each(a.begin(), a.end(), cout << ++index << ':' << _1 << '\n');
for_each(a.begin(), a.end(), cout << ++var(index) << ':' << _1 << '\n');]]>
</programlisting>

The first <literal>for_each</literal> invocation does not do what we want; <literal>index</literal> is incremented only once, and its value is written into the output stream only once.
By using <literal>var</literal> to make <literal>index</literal> a lambda expression, we get the desired effect.<sbr/>
第一个 <literal>for_each</literal> 调用不会做出我们想要的东西，<literal>index</literal> 被增加的次数只有一次，
而且它的值被写到输出流中的次数也只有一次。通过使用 <literal>var</literal> 使 <literal>index</literal> 变成一个 
lambda 表达式，我们可以得到想要的效果。


<!-- Note that <literal>var</literal> accepts const objects as well, in which case
calling <literal>var</literal> equals calling <literal>constant_ref</literal>.-->
</para>

<para>
In sum, <literal>var(x)</literal> creates a nullary lambda functor, 
which stores a reference to the variable <literal>x</literal>. 
When the lambda functor is invoked, a reference to <literal>x</literal> is returned.<sbr/>
总的来说，<literal>var(x)</literal> 创建一个无元 lambda 仿函数，它存储一个引向变量 <literal>x</literal> 的引用。
当这个 lambda 仿函数被调用时，返回一个引向 <literal>x</literal> 的引用。
</para>

<simplesect>
<title>Naming delayed constants and variables 有名字的延迟常量和变量</title>

<para>
It is possible to predefine and name a delayed variable or constant outside a lambda expression. 
The templates <literal>var_type</literal>, <literal>constant_type</literal> 
and <literal>constant_ref_type</literal> serve for this purpose. 
They are used as:<sbr/>
在一个 lambda 表达式外部预定义和命名一个延迟变量或常量是有可能的。模板 <literal>var_type</literal>，
<literal>constant_type</literal> 和 <literal>constant_ref_type</literal> 可以为这一目标提供帮助，可以像这样使用它们：
<programlisting>
<![CDATA[var_type<T>::type delayed_i(var(i));
constant_type<T>::type delayed_c(constant(c));]]>
</programlisting>
The first line defines the variable <literal>delayed_i</literal> which is a delayed version of the variable <literal>i</literal> of type <literal>T</literal>.
Analogously, the second line defines the constant <literal>delayed_c</literal> as a delayed version of the constant <literal>c</literal>.
For example:<sbr/>
第一行定义的变量 <literal>delayed_i</literal> 是类型为 <literal>T</literal> 的变量 <literal>i</literal> 的一个延迟版本。
类似地，第二行定义的常量 <literal>delayed_c</literal> 是常量 <literal>c</literal> 的一个延迟版本。例如：

<programlisting>
int i = 0; int j;
for_each(a.begin(), a.end(), (var(j) = _1, _1 = var(i), var(i) = var(j))); 
</programlisting>
is equivalent to:<sbr/>
等价于：
<programlisting>
<![CDATA[int i = 0; int j;
var_type<int>::type vi(var(i)), vj(var(j));
for_each(a.begin(), a.end(), (vj = _1, _1 = vi, vi = vj));]]>
</programlisting>
</para>
<para>
Here is an example of naming a delayed constant:<sbr/>
这是命名一个延迟常量的示例：
<programlisting>
<![CDATA[constant_type<char>::type space(constant(' '));
for_each(a.begin(),a.end(), cout << space << _1);]]>
</programlisting>
</para>

</simplesect>

<simplesect>
<title>About assignment and subscript operators 关于赋值和下标操作符</title>

<para>
As described in <xref linkend="lambda.assignment_and_subscript"/>, assignment and subscripting operators are always defined as member functions.
This means, that for expressions of the form
<literal>x = y</literal> or <literal>x[y]</literal> to be interpreted as lambda expressions, the left-hand operand <literal>x</literal> must be a lambda expression. 
Consequently, it is sometimes necessary to use <literal>var</literal> for this purpose.
We repeat the example from <xref linkend="lambda.assignment_and_subscript"/>:<sbr/>
就像在 <xref linkend="lambda.assignment_and_subscript"/> 描述的，赋值和下标操作符总是定义为成员函数。
这就意味着，为了把 <literal>x = y</literal> 或 <literal>x[y]</literal> 形式的表达式解释为 lambda 表达式，
左侧操作数 <literal>x</literal> 必须是一个 lambda 表达式。因此，有时需要用 <literal>var</literal> 来达到这个目的。
我们再看一看 <xref linkend="lambda.assignment_and_subscript"/> 的示例：

<programlisting>
int i; 
i = _1;       // error
var(i) = _1;  // ok
</programlisting>
</para>

<para>

Note that the compound assignment operators <literal>+=</literal>, <literal>-=</literal> etc. can be defined as non-member functions, and thus they are interpreted as lambda expressions even if only the right-hand operand is a lambda expression.
Nevertheless, it is perfectly ok to delay the left operand explicitly. 
For example, <literal>i += _1</literal> is equivalent to <literal>var(i) += _1</literal>.<sbr/>
注意，混合式赋值操作符 <literal>+=</literal>, <literal>-=</literal> 等可以定义为非成员函数，因此即使只有右侧操作数是一个
lambda 表达式，它们也可以被解释为 lambda 表达式。不过，延迟左操作数还是非常完美的。例如，<literal>i += _1</literal> 
等价于 <literal>var(i) += _1</literal>。
</para>
</simplesect>

</section>

<section id="lambda.lambda_expressions_for_control_structures">
<title>Lambda expressions for control structures 控制结构的lambda表达式</title>

<para>
BLL defines several functions to create lambda functors that represent control structures. 
They all take lambda functors as parameters and return <literal>void</literal>.
To start with an example, the following code outputs all even elements of some container <literal>a</literal>:<sbr/>
BLL 定义了几个函数用来创建代替控制结构的 lambda 仿函数。它们都以 lambda 仿函数作为参数并返回 <literal>void</literal>。
我们以一个例子开始，下面的代码输出某个容器 <literal>a</literal> 的全部偶数元素：

<programlisting>
<![CDATA[for_each(a.begin(), a.end(), 
         if_then(_1 % 2 == 0, cout << _1));]]>  
</programlisting>
</para>

<para>
The BLL supports the following function templates for control structures: <sbr/>
BLL 支持以下用于控制结构的函数模板：

<programlisting>
if_then(condition, then_part)
if_then_else(condition, then_part, else_part)
if_then_else_return(condition, then_part, else_part)
while_loop(condition, body)
while_loop(condition) // no body case
do_while_loop(condition, body)
do_while_loop(condition) // no body case 
for_loop(init, condition, increment, body)
for_loop(init, condition, increment) // no body case
switch_statement(...)
</programlisting>

The return types of all control construct lambda functor is 
<literal>void</literal>, except for <literal>if_then_else_return</literal>,
which wraps a call to the conditional operator <sbr/>
所有控制结构 lambda 仿函数的返回类型都是 <literal>void</literal>，但 <literal>if_then_else_return</literal> 除外，
它包装一个条件操作符的调用
<programlisting>
condition ? then_part : else_part
</programlisting>
The return type rules for this operator are somewhat complex. 
Basically, if the branches have the same type, this type is the return type.
If the type of the branches differ, one branch, say of type 
<literal>A</literal>, must be convertible to the other branch, 
say of type <literal>B</literal>.
In this situation, the result type is <literal>B</literal>.
Further, if the common type is an lvalue, the return type will be an lvalue
too.<sbr/>
这个操作符的返回类型规则多少有些复杂。主要的是，如果分支有相同的类型，这个类型就是返回类型。
如果分支的返回类型不同，一个分支，比方说是类型 <literal>A</literal>，必须能够转换到另一个分支，
比方说是类型 <literal>B</literal>。在这种情况下，结果类型是 <literal>B</literal>。
更进一步，如果通用类型是一个左值，则返回类型也是一个左值。
</para>


<para>
Delayed variables tend to be commonplace in control structure lambda expressions. 
For instance, here we use the <literal>var</literal> function to turn the arguments of <literal>for_loop</literal> into lambda expressions. 
The effect of the code is to add 1 to each element of a two-dimensional array:<sbr/>
延迟变量在控制结构 lambda 表达式中随处可见。例如，这里我们用 <literal>var</literal> 函数将 
<literal>for_loop</literal> 的参数变成 lambda 表达式。代码的作用是为一个二维数组的每一个元素加 1：

<programlisting>
<![CDATA[int a[5][10]; int i;
for_each(a, a+5, 
  for_loop(var(i)=0, var(i)<10, ++var(i), 
           _1[var(i)] += 1));]]>  
</programlisting>

<!--
As explained in <xref linkend="lambda.delaying_constants_and_variables"/>, we can avoid the repeated use of wrapping of <literal>var</literal> if we define it beforehand:

<programlisting>
<![CDATA[int i;
var_type<int>::type vi(var(i));
for_each(a, a+5, 
  for_loop(vi=0, vi<10, ++vi, _1[vi] += 6));]]>  
</programlisting>

-->
</para>

<para>
The BLL supports an alternative syntax for control expressions, suggested
by Joel de Guzmann. 
By overloading the <literal>operator[]</literal> we can
get a closer resemblance with the built-in control structures:<sbr/>
BLL 还支持另外一种控制机构的语法，这个建议由 Joel de Guzmann 提出。通过重载 
<literal>operator[]</literal> 我们可以得到一种和内建控制结构非常类似的形式：

<programlisting>
<![CDATA[if_(condition)[then_part]
if_(condition)[then_part].else_[else_part]
while_(condition)[body]
do_[body].while_(condition)
for_(init, condition, increment)[body]]]>
</programlisting>

For example, using this syntax the <literal>if_then</literal> example above
can be written as:<sbr/>
例如，如果使用这种语法，上面的 <literal>if_then</literal> 的例子可以写成：
<programlisting>
<![CDATA[for_each(a.begin(), a.end(), 
         if_(_1 % 2 == 0)[ cout << _1 ])]]>  
</programlisting>

As more experience is gained, we may end up deprecating one or the other 
of these syntaces. <sbr/>
通过获得更多的经验，我们最终可能会抛弃这些语法中的一种。

</para>



<section id="lambda.switch_statement">
<title>Switch statement  switch语句</title>
</section>

<para>
The lambda expressions for <literal>switch</literal> control structures are more complex since the number of cases may vary. 
The general form of a switch lambda expression is:<sbr/>
<literal>switch</literal> 控制结构的 lambda 表达式更加复杂，因为 cases 的数量是可以变化的。
一个 switch lambda 表达式的常规形式是：

<programlisting>
switch_statement(<parameter>condition</parameter>, 
  case_statement&lt;<parameter>label</parameter>&gt;(<parameter>lambda expression</parameter>),
  case_statement&lt;<parameter>label</parameter>&gt;(<parameter>lambda expression</parameter>),
  ...
  default_statement(<parameter>lambda expression</parameter>)
)
</programlisting>

The <literal><parameter>condition</parameter></literal> argument must be a lambda expression that creates a lambda functor with an integral return type.
The different cases are created with the <literal>case_statement</literal> functions, and the optional default case with the <literal>default_statement</literal> function.
The case labels are given as explicitly specified template arguments to <literal>case_statement</literal> functions and 
<literal>break</literal> statements are implicitly part of each case. 
For example, <literal><![CDATA[case_statement<1>(a)]]></literal>, where <literal>a</literal> is some lambda functor,  generates the code:<sbr/>
<literal><parameter>condition</parameter></literal> 参数必须是一个创建带有一个整型返回值的 lambda 仿函数的 lambda 表达式。
各种不同的 cases 通过 <literal>case_statement</literal> 函数创建，可选的 default case 通过 <literal>default_statement</literal> 
函数创建。case 标签通过显式特化 <literal>case_statement</literal> 函数的模板参数给定，而 <literal>break</literal> 
语句是每一种 case 的隐含部分。例如，<literal><![CDATA[case_statement<1>(a)]]></literal>，这里 <literal>a</literal> 
是某一个lambda 仿函数，以上语句生成如下代码：

<programlisting>
case 1: 
  <parameter>evaluate lambda functor</parameter> a; 
  break;
</programlisting>
The <literal>switch_statement</literal> function is specialized for up to 9 case statements.<sbr/>
<literal>switch_statement</literal> 函数最多可以指定 9 个 case 语句。

</para>

<para>
As a concrete example, the following code iterates over some container <literal>v</literal> and ouptuts <quote>zero</quote> for each <literal>0</literal>, <quote>one</quote> for each <literal>1</literal>, and <quote>other: <parameter>n</parameter></quote> for any other value <parameter>n</parameter>.
Note that another lambda expression is sequenced after the <literal>switch_statement</literal> to output a line break after each element:<sbr/>
举一个具体的例子，下面的代码迭代遍历某个容器 <literal>v</literal> 并针对每一个 <literal>0</literal> 输出 <quote>zero</quote>，
针对每一个 <literal>1</literal> 输出 <quote>one</quote>，针对其它的任意值 <parameter>n</parameter> 输出 
<quote>other: <parameter>n</parameter></quote>。注意，依次排列在 <literal>switch_statement</literal> 后面的另一个 
lambda 表达式在每一个元素后输出一行 break：

<programlisting>
<![CDATA[std::for_each(v.begin(), v.end(),
  ( 
    switch_statement(
      _1,
      case_statement<0>(std::cout << constant("zero")),
      case_statement<1>(std::cout << constant("one")),
      default_statement(cout << constant("other: ") << _1)
    ), 
    cout << constant("\n") 
  )
);]]>
</programlisting>
</para>

</section>

<section id="lambda.exceptions">
<title>Exceptions 异常</title>

<para>
The BLL provides lambda functors that throw and catch exceptions.
Lambda functors for throwing exceptions are created with the unary function <literal>throw_exception</literal>.
The argument to this function is the exception to be thrown, or a lambda functor which creates the exception to be thrown.
A lambda functor for rethrowing exceptions is created with the nullary <literal>rethrow</literal> function.<sbr/>
BLL 提供抛出和捕获异常的 lambda 仿函数。用于抛出异常的 lambda 仿函数由一元函数 <literal>throw_exception</literal> 创建。
传给这个函数的参数是想要抛出的异常，或者是创建想要抛出的异常的 lambda 仿函数。用于重新抛出异常的 lambda 仿函数由一元的
<literal>rethrow</literal> 函数创建。
</para>

<para>
Lambda expressions for handling exceptions are somewhat more complex.
The general form of a lambda expression for try catch blocks is as follows:<sbr/>
用于处理异常的 lambda 表达式更加复杂。一个 try catch 块的 lambda 表达式的常规形式如下：

<programlisting>
try_catch(
  <parameter>lambda expression</parameter>,
  catch_exception&lt;<parameter>type</parameter>&gt;(<parameter>lambda expression</parameter>),
  catch_exception&lt;<parameter>type</parameter>&gt;(<parameter>lambda expression</parameter>),
  ...
  catch_all(<parameter>lambda expression</parameter>)
)
</programlisting>

The first lambda expression is the try block. 
Each <literal>catch_exception</literal> defines a catch block where the 
explicitly specified template argument defines the type of the exception 
to catch.

The lambda expression within the <literal>catch_exception</literal> defines 
the actions to take if the exception is caught.

Note that the resulting exception handlers catch the exceptions as 
references, i.e., <literal>catch_exception&lt;T&gt;(...)</literal> 
results in the catch block:<sbr/>
第一个 lambda 表达式是 try 块。每一个 <literal>catch_exception</literal> 定义一个 catch 块，
其中的显示特化模板参数定义被捕获的异常的类型。在 <literal>catch_exception</literal> 内的 lambda 
表达式定义了异常被捕获到时的动作。注意，最终异常处理器捕捉到的异常是引用，例如，
<literal>catch_exception&lt;T&gt;(...)</literal> 导致的 chatch 块如下：

<programlisting>
catch(T&amp; e) { ... }
</programlisting>

The last catch block can alternatively be a call to 
<literal>catch_exception&lt;<parameter>type</parameter>&gt;</literal> 
or to 
<literal>catch_all</literal>, which is the lambda expression equivalent to 
<literal>catch(...)</literal>.<sbr/>
最后一个 chatch 块可以在 <literal>catch_exception&lt;<parameter>type</parameter>&gt;</literal> 
或 <literal>catch_all</literal>（这一 lambda 表达式等价于 <literal>catch(...)</literal>）
这两个调用之中选择一个。

</para>

<para>

The <xref linkend="ex:exceptions"/> demonstrates the use of the BLL 
exception handling tools. 
The first handler catches exceptions of type <literal>foo_exception</literal>. 
Note the use of <literal>_1</literal> placeholder in the body of the handler.<sbr/>
<xref linkend="ex:exceptions"/> 示范了 BLL 的异常处理工具的使用。
第一个 handler（处理器）捕捉 <literal>foo_exception</literal> 类型的异常。
注意 handler（处理器）体内 <literal>_1</literal> 占位符的使用。
</para>

<para>
The second handler shows how to throw exceptions, and demonstrates the 
use of the <emphasis>exception placeholder</emphasis> <literal>_e</literal>.

It is a special placeholder, which refers to the caught exception object 
within the handler body.

Here we are handling an exception of type <literal>std::exception</literal>, 
which carries a string explaining the cause of the exception. 

This explanation can be queried with the zero-argument member 
function <literal>what</literal>.

The expression
<literal>bind(&amp;std::exception::what, _e)</literal> creates the lambda 
function for making that call.

Note that <literal>_e</literal> cannot be used outside of an exception handler lambda expression.
<!--Violating this rule is caught by the compiler.-->

The last line of the second handler constructs a new exception object and 
throws that with <literal>throw exception</literal>. 

Constructing and destructing objects within lambda expressions is 
explained in <xref linkend="lambda.construction_and_destruction"/><sbr/>
第二个 handler（处理器）展示如何抛出异常，并示范了 <emphasis>异常占位符</emphasis> <literal>_e</literal> 的使用。
这是一个特殊的占位符，它与在 handler（处理器）体内捕捉到的异常对象相关。这里我们处理一个类型为 
<literal>std::exception</literal> 的异常，它带有一个解释异常原因的字符串。这一解释可以用无参数成员函数 
<literal>what</literal> 进行查询。表达式 <literal>bind(&amp;std::exception::what, _e)</literal> 
创建能产生这个调用的 lambda 函数。注意，<literal>_e</literal> 不能在一个异常处理器 lambda 表达式之外使用。
第二个 handler（处理器）的最后一行构造一个新的异常对象并通过 <literal>throw exception</literal> 将它抛出。
在 lambda 表达式中构造和析构对象在<xref linkend="lambda.construction_and_destruction"/> 进行了说明。
</para>

<para>
Finally, the third handler (<literal>catch_all</literal>) demonstrates 
rethrowing exceptions.<sbr/>
最后，第三个 handler（处理器）(<literal>catch_all</literal>) 示范重新抛出异常。
</para>

<example id="ex:exceptions">
<title>Throwing and handling exceptions in lambda expressions. 在lambda表达式中抛出和处理异常</title>
<programlisting>
<![CDATA[for_each(
  a.begin(), a.end(),
  try_catch(
    bind(foo, _1),                 // foo may throw
    catch_exception<foo_exception>(
      cout << constant("Caught foo_exception: ") 
           << "foo was called with argument = " << _1
    ),
    catch_exception<std::exception>(
      cout << constant("Caught std::exception: ") 
           << bind(&std::exception::what, _e),
      throw_exception(bind(constructor<bar_exception>(), _1)))
    ),      
    catch_all(
      (cout << constant("Unknown"), rethrow())
    )
  )
);]]>
</programlisting>
</example>

</section>

<section id="lambda.construction_and_destruction">
<title>Construction and destruction 构造函数和析构函数</title>


<para>
Operators <literal>new</literal> and <literal>delete</literal> can be 
overloaded, but their return types are fixed. 

Particularly, the return types cannot be lambda functors, 
which prevents them to be overloaded for lambda expressions.

It is not possible to take the address of a constructor, 
hence constructors cannot be used as target functions in bind expressions.

The same is true for destructors.

As a way around these constraints, BLL defines wrapper classes for 
<literal>new</literal> and <literal>delete</literal> calls, 
as well as for constructors and destructors.

Instances of these classes are function objects, that can be used as 
target functions of bind expressions. 

For example:<sbr/>
操作符 <literal>new</literal> 和 <literal>delete</literal> 能被重载，但它们的返回类型是固定的。
特别是，返回类型不能是 lambda 表达式，以防止它们为 lambda 表达式重载。持有一个构造函数的地址是不可能的，
因此构造函数不能在 bind 表达式中作为目标函数使用。这些对于析构函数也同样成立。为了绕过这些限制，
BLL 提供了 <literal>new</literal> 和 <literal>delete</literal> 的包装类，
也提供了构造函数和析构函数的包装类。这些函数的实例是函数对象，它们可以在bind 表达式中作为目标函数使用。例如：

<programlisting>
<![CDATA[int* a[10];
for_each(a, a+10, _1 = bind(new_ptr<int>())); 
for_each(a, a+10, bind(delete_ptr(), _1));]]>
</programlisting>

The <literal>new_ptr&lt;int&gt;()</literal> expression creates 
a function object that calls <literal>new int()</literal> when invoked, 
and wrapping that inside <literal>bind</literal> makes it a lambda functor.

In the same way, the expression <literal>delete_ptr()</literal> creates 
a function object that invokes <literal>delete</literal> on its argument. 

Note that <literal>new_ptr&lt;<parameter>T</parameter>&gt;()</literal> 
can take arguments as well.

They are passed directly to the constructor invocation and thus allow 
calls to constructors which take arguments. <sbr/>
<literal>new_ptr&lt;int&gt;()</literal> 表达式被调用时就会创建了一个调用 <literal>new int()</literal> 的函数对象，
并将它包装在 <literal>bind</literal> 中做成一个 lambda 仿函数。用同样的方法，表达式 <literal>delete_ptr()</literal> 
创建一个在其参数上调用 <literal>delete</literal> 的函数对象。注意，<literal>new_ptr&lt;<parameter>T</parameter>&gt;()</literal> 
同样可以持有参数。它们被直接传送给构造函数调用，并因此而允许调用持有参数的构造函数。

</para>

<para>

As an example of constructor calls in lambda expressions, 
the following code reads integers from two containers <literal>x</literal> 
and <literal>y</literal>, 
constructs pairs out of them and inserts them into a third container:<sbr/>
举一个在 lambda 表达式中调用构造函数的例子，下面的代码从两个容器 <literal>x</literal> 
和 <literal>Y</literal> 中读取整数，用这两个整数创建 pairs，并把它们插入到第三个容器中：

<programlisting>
<![CDATA[vector<pair<int, int> > v;
transform(x.begin(), x.end(), y.begin(), back_inserter(v),
          bind(constructor<pair<int, int> >(), _1, _2));]]>
</programlisting>

<xref linkend="table:constructor_destructor_fos"/> lists all the function 
objects related to creating and destroying objects,
 showing the expression to create and call the function object, 
and the effect of evaluating that expression.<sbr/>
Table 11.1 <xref linkend="table:constructor_destructor_fos"/> 列出了所有与创建和销毁对象相关的函数对象，
展示了被创建的表达式和调用的函数对象，以及对表达式求值的效果。

</para>



<table id="table:constructor_destructor_fos">
<title>Construction and destruction related function objects. 构造函数和析构函数相关函数对象</title>
<tgroup cols="2">
<thead>
<row>
<entry>Function object call 函数对象调用</entry>
<entry>Wrapped expression 被包装表达式</entry>
</row>
</thead>
<tbody>
<row>
<entry><literal>constructor&lt;T&gt;()(<parameter>arg_list</parameter>)</literal></entry>
<entry>T(<parameter>arg_list</parameter>)</entry>
</row>
<row>
<entry><literal>destructor()(a)</literal></entry>
<entry><literal>a.~A()</literal>, where <literal>a</literal> is of type <literal>A</literal></entry>
</row>
<row>
<entry><literal>destructor()(pa)</literal></entry>
<entry><literal>pa->~A()</literal>, where <literal>pa</literal> is of type <literal>A*</literal></entry>
</row>
<row>
<entry><literal>new_ptr&lt;T&gt;()(<parameter>arg_list</parameter>)</literal></entry>
<entry><literal>new T(<parameter>arg_list</parameter>)</literal></entry>
</row>
<row>
<entry><literal>new_array&lt;T&gt;()(sz)</literal></entry>
<entry><literal>new T[sz]</literal></entry>
</row>
<row>
<entry><literal>delete_ptr()(p)</literal></entry>
<entry><literal>delete p</literal></entry>
</row>
<row>
<entry><literal>delete_array()(p)</literal></entry>
<entry><literal>delete p[]</literal></entry>
</row>


</tbody>
</tgroup>
</table> 

</section>


<section>
<title>Special lambda expressions 特殊lambda表达式</title>

<section>
<title>Preventing argument substitution 阻止参数置换</title>

<para>
When a lambda functor is called, the default behavior is to substitute 
the actual arguments for the placeholders within all subexpressions.

This section describes the tools to prevent the substitution and 
evaluation of a subexpression, and explains when these tools should be used.<sbr/>
当一个 lambda 仿函数被调用的时候，缺省行为是在所有子表达式内用实际参数替换占位符。
本节描述阻止这种替换和和子表达式求值的工具，并说明这些工具应该在什么时候使用。
</para>


<para>
The arguments to a bind expression can be arbitrary lambda expressions, 
e.g., other bind expressions.

For example:<sbr/>
一个 bind 表达式的参数可以是任意的 lambda 表达式，比如，其它的 bind 表达式。例如：

<programlisting>
int foo(int); int bar(int);
...
int i;
bind(foo, bind(bar, _1))(i);
</programlisting>

The last line makes the call <literal>foo(bar(i));</literal>

Note that the first argument in a bind expression, the target function, 
is no exception, and can thus be a bind expression too.

The innermost lambda functor just has to return something that can be used 
as a target function: another lambda functor, function pointer, 
pointer to member function etc. 

For example, in the following code the innermost lambda functor makes 
a selection between two functions, and returns a pointer to one of them:<sbr/>
最后一行调用了 <literal>foo(bar(i));</literal>，注意，bind 表达式中的第一个参数，
也就是目标函数，也不例外，因此也可以是一个 bind 表达式。只不过最里层的 lambda 
仿函数必须返回某些可以当作一个目标函数来用的东西：另一个 lambda 仿函数，
函数指针，指向成员函数的指针，等等。例如，下面的代码中，最里层 lambda 
仿函数在两个函数之间进行选择，并返回指向其中一个的指针：

<programlisting>
int add(int a, int b) { return a+b; }
int mul(int a, int b) { return a*b; }

int(*)(int, int)  add_or_mul(bool x) { 
  return x ? add : mul; 
}

bool condition; int i; int j;
...
bind(bind(&amp;add_or_mul, _1), _2, _3)(condition, i, j);
</programlisting>

</para>



<section id="lambda.unlambda">
<title>Unlambda</title>

<para>A nested bind expression may occur inadvertently, 
if the target function is a variable with a type that depends on a 
template parameter. 

Typically the target function could be a formal parameter of a 
function template. 

In such a case, the programmer may not know whether the target function is a lambda functor or not.<sbr/>
某种嵌套的 bind 表达式可能会在漫不经心中出现，它的目标函数是一个变量，这个变量的类型依赖于一个模板参数。
特别是目标函数可以是一个函数模板的形式参数。在这种情况下，程序员可能不知道这个目标函数是否是一个 lambda 仿函数。
</para>

<para>Consider the following function template:<sbr/>
考虑下面的函数模板：

<programlisting>
<![CDATA[template<class F>
int nested(const F& f) {
  int x;
  ...
  bind(f, _1)(x);
  ...
}]]>
</programlisting>

Somewhere inside the function the formal parameter
<literal>f</literal> is used as a target function in a bind expression. 

In order for this <literal>bind</literal> call to be valid, 
<literal>f</literal> must be a unary function.

Suppose the following two calls to <literal>nested</literal> are made:<sbr/>
在函数内的某处，形式参数 <literal>f</literal> 被用作一个bind表达式的目标函数。
为了使这个 <literal>bind</literal> 调用合法，<literal>f</literal> 必须是一个一元函数。
假设有下面两个对 <literal>nested</literal> 的调用：

<programlisting>
<![CDATA[int foo(int);
int bar(int, int);
nested(&foo);
nested(bind(bar, 1, _1));]]>
</programlisting>

Both are unary functions, or function objects, with appropriate argument 
and return types, but the latter will not compile.

In the latter call, the bind expression inside <literal>nested</literal> 
will become:<sbr/>
都是带有恰当的参数和返回类型的一元函数，或者函数对象，但是后一个无法正常编译。
在后一个调用中，<literal>nested</literal> 中的 bind 表达式会变成：

<programlisting>
bind(bind(bar, 1, _1), _1) 
</programlisting>

When this is invoked with <literal>x</literal>, 
after substituitions we end up trying to call<sbr/>
当用<literal>x</literal> 来调用它时，替换之后我们最终企图调用

<programlisting>
bar(1, x)(x)
</programlisting>

which is an error. 

The call to <literal>bar</literal> returns int, 
not a unary function or function object.<sbr/>
这是一个错误，对 <literal>bar</literal> 的调用返回 int，不是一个一元函数或函数对象。
</para>

<para>
In the example above, the intent of the bind expression in the 
<literal>nested</literal> function is to treat <literal>f</literal> 
as an ordinary function object, instead of a lambda functor. 

The BLL provides the function template <literal>unlambda</literal> to 
express this: a lambda functor wrapped inside <literal>unlambda</literal> 
is not a lambda functor anymore, and does not take part into the 
argument substitution process.

Note that for all other argument types <literal>unlambda</literal> is 
an identity operation, except for making non-const objects const.<sbr/>
在上面的例子中，<literal>nested</literal> 函数内的 bind 表达式的意图是将 <literal>f</literal> 看做一个普通的函数对象。
BLL 提供函数模板 <literal>unlambda</literal> 来表达这一点：一个包装在 <literal>unlambda</literal> 中的 lambda 
仿函数不再是一个 lambda 仿函数，也不再参与参数替换过程。注意，对于所有其它参数类型而言，除了将非 const 对象变成 const 之外，
<literal>unlambda</literal> 是一个恒等操作。
</para>

<para>
Using <literal>unlambda</literal>, the <literal>nested</literal> 
function is written as:<sbr/>
使用 <literal>unlambda</literal>，<literal>nested</literal> 函数写为：

<programlisting>
<![CDATA[template<class F>
int nested(const F& f) {
  int x;
  ...
  bind(unlambda(f), _1)(x);
  ...
}]]>
</programlisting>

</para>

</section>

<section>
<title>Protect</title>

<para>
The <literal>protect</literal> function is related to unlambda. 

It is also used to prevent the argument substitution taking place, 
but whereas <literal>unlambda</literal> turns a lambda functor into 
an ordinary function object for good, <literal>protect</literal> does 
this temporarily, for just one evaluation round.

For example:<sbr/>
<literal>protect</literal> 函数与 unlambda 相似。它也用于阻止参数替换的发生，
但是 <literal>unlambda</literal> 将一个 lambda 仿函数永久地变成一个普通函数对象，
<literal>protect</literal> 只是暂时地，对一次求值起作用。例如：

<programlisting>
int x = 1, y = 10;
(_1 + protect(_1 + 2))(x)(y);
</programlisting>
    
The first call substitutes <literal>x</literal> for the leftmost 
<literal>_1</literal>, and results in another lambda functor 
<literal>x + (_1 + 2)</literal>, which after the call with 
<literal>y</literal> becomes <literal>x + (y + 2)</literal>, 
and thus finally 13.<sbr/>
第一个调用用 <literal>x</literal> 替换最左边的 <literal>_1</literal>，
结果成为另一个 lambda 仿函数 <literal>x + (_1 + 2)</literal>，最后用 
<literal>y</literal> 调用它，变成 <literal>x + (y + 2)</literal>，因此结果为 13。
</para>

<para>
Primary motivation for including <literal>protect</literal> into the library, 
was to allow nested STL algorithm invocations 
(<xref linkend="lambda.nested_stl_algorithms"/>).<sbr/>
将 <literal>protect</literal> 包含在库中的主要动机，在于允许嵌套的 STL 算法调用
（<xref linkend="lambda.nested_stl_algorithms"/>）。
</para>

</section>

</section>

<section id="lambda.rvalues_as_actual_arguments">
<title>Rvalues as actual arguments to lambda functors 右值作为lambda仿函数的实际参数</title>

<!--      <para><emphasis>This section and all of its subsections
       are no longer (or currently) relevant;
       acual arguments can be non-const rvalues and these workarounds are thus
       not needed.
       The section can, however, become relevant again, if in the future BLL will support
       lambda functors with higher arities than 3.</emphasis></para> -->

<para>
Actual arguments to the lambda functors cannot be non-const rvalues.
This is due to a deliberate design decision: either we have this restriction, 
or there can be no side-effects to the actual arguments.

There are ways around this limitation.

We repeat the example from section 
<xref linkend="lambda.actual_arguments_to_lambda_functors"/> and list the 
different solutions:<sbr/>
lambda 仿函数的参数不能是非 const 右值。这是因为一个经过深思熟虑的设计权衡：
我们有了这个约束，就不会对实际参数产生副作用。也有方法可以绕过这个限制。
我们再看一下 <xref linkend="lambda.actual_arguments_to_lambda_functors"/> 的例子，
并列举不同的解决方案：

<programlisting>
int i = 1; int j = 2; 
(_1 + _2)(i, j); // ok
(_1 + _2)(1, 2); // error (!)
</programlisting>

<orderedlist>
<listitem>
<para>
If the rvalue is of a class type, the return type of the function that 
creates the rvalue should be defined as const. 
Due to an unfortunate language restriction this does not work for 
built-in types, as built-in rvalues cannot be const qualified. <sbr/>
如果右值是一个类类型，创建这个右值的函数返回值应该被定义为 const。
因为一个不幸的语言约束，这个方法不能用于内建类型，因为内建右值不能被 const 修饰。
</para>
</listitem>

<listitem>
<para>
If the lambda function call is accessible, the <literal>make_const</literal> 
function can be used to <emphasis>constify</emphasis> the rvalue. E.g.:<sbr/>
如果那个 lambda 函数调用是可访问的，<literal>make_const</literal> 函数可以用来 
<emphasis>常量化</emphasis> 这个右值。例如：

<programlisting>
(_1 + _2)(make_const(1), make_const(2)); // ok
</programlisting>

Commonly the lambda function call site is inside a standard algorithm 
function template, preventing this solution to be used.<sbr/>
通常 lambda 函数调用的位置是在一个标准算法函数模板内部，无法使用这个解决方案。

</para>
</listitem>

<listitem>
<para>
If neither of the above is possible, the lambda expression can be wrapped 
in a <literal>const_parameters</literal> function. 
It creates another type of lambda functor, which takes its arguments as 
const references. For example:<sbr/>
如果上面的都不可行，可以把 lambda 表达式包装在一个 <literal>const_parameters</literal> 函数内。
它创建另一种类型的 lambda 仿函数，以 const 引用的方式持有它的参数。例如：

<programlisting>
const_parameters(_1 + _2)(1, 2); // ok
</programlisting>

Note that <literal>const_parameters</literal> makes all arguments const.
Hence, in the case were one of the arguments is a non-const rvalue, 
and another argument needs to be passed as a non-const reference, 
this approach cannot be used.<sbr/>
注意，<literal>const_parameters</literal> 把所有的参数变成 const。因此，
在某一个参数是一个非 const 右值，或者另一个参数需要以非 const 引用方式传递的情况下，
这个方法不可用。
</para>

</listitem>

<listitem>
<para>If none of the above is possible, there is still one solution, 
which unfortunately can break const correctness.

The solution is yet another lambda functor wrapper, which we have named 
<literal>break_const</literal> to alert the user of the potential dangers 
of this function. 

The <literal>break_const</literal> function creates a lambda functor that 
takes its arguments as const, and casts away constness prior to the call 
to the original wrapped lambda functor.

For example:<sbr/>
如果以上方法都不可行，还有一个解决方案，非常不幸的是，这一方案可能会破坏 const 的正确性。
这个解决方案使用另一个 lambda 仿函数包装，我们称它为 <literal>break_const</literal> 是为了警告用户这个函数有潜在的危险。
<literal>break_const</literal> 函数创建一个 lambda 仿函数，这个 lambda 仿函数以 const 方式持有它的参数，
并在调用原来的被包装的 lambda 仿函数之前强行去掉它的常量性。例如：
<programlisting>
int i; 
...
(_1 += _2)(i, 2);                 // error, 2 is a non-const rvalue
const_parameters(_1 += _2)(i, 2); // error, i becomes const
break_const(_1 += _2)(i, 2);      // ok, but dangerous
</programlisting>

Note, that the results of <literal> break_const</literal> or 
<literal>const_parameters</literal> are not lambda functors, 
so they cannot be used as subexpressions of lambda expressions. For instance:<sbr/>
注意， <literal> break_const</literal> 或 <literal>const_parameters</literal> 
的结果不是 lambda 仿函数，所以不能用作 lambda 表达式的子表达式。例如：

<programlisting>
break_const(_1 + _2) + _3; // fails.
const_parameters(_1 + _2) + _3; // fails.
</programlisting>

However, this kind of code should never be necessary, 
since calls to sub lambda functors are made inside the BLL, 
and are not affected by the non-const rvalue problem.<sbr/>
但是，这种代码应该永远不是必要的，因为调用子 lambda 仿函数的方法已经做入到 BLL 中，
而且它不会受到非 const 右值问题的影响。
</para>
</listitem>

</orderedlist>

</para>
</section>

</section>


<section>
<title>Casts, sizeof and typeid 强制转型，sizeof和typeid</title>

<section id="lambda.cast_expressions">
<title>
Cast expressions 强制转型表达式
</title>
<para>
The BLL defines its counterparts for the four cast expressions 
<literal>static_cast</literal>, <literal>dynamic_cast</literal>, 
<literal>const_cast</literal> and <literal>reinterpret_cast</literal>.

The BLL versions of the cast expressions have the prefix 
<literal>ll_</literal>.

The type to cast to is given as an explicitly specified template argument, 
and the sole argument is the expression from which to perform the cast.

If the argument is a lambda functor, the lambda functor is evaluated first.

For example, the following code uses <literal>ll_dynamic_cast</literal> 
to count the number of <literal>derived</literal> instances in the container 
<literal>a</literal>:<sbr/>
BLL 定义了针对四种强制转型表达式 <literal>static_cast</literal>, <literal>dynamic_cast</literal>, 
<literal>const_cast</literal> 和 <literal>reinterpret_cast</literal> 的对应物。
强制转型的 BLL 版本有 <literal>ll_</literal> 前缀。被转到的类型通过一个显式特化的模板参数给出，
而唯一的参数是被执行强制转型的表达式。如果这个参数是一个 lambda 表达式，这个 lambda 表达式首先被求值。
例如，下面的代码使用 <literal>ll_dynamic_cast</literal> 统计容器 <literal>a</literal> 中 
<literal>derived</literal> 实例的个数：

<programlisting>
<![CDATA[class base {};
class derived : public base {};

vector<base*> a;
...
int count = 0;
for_each(a.begin(), a.end(), 
         if_then(ll_dynamic_cast<derived*>(_1), ++var(count)));]]>
</programlisting>
</para>
</section>

<section>
<title>Sizeof and typeid</title>
<para>
The BLL counterparts for these expressions are named 
<literal>ll_sizeof</literal> and <literal>ll_typeid</literal>.

Both take one argument, which can be a lambda expression.
The lambda functor created wraps the <literal>sizeof</literal> or 
<literal>typeid</literal> call, and when the lambda functor is called 
the wrapped operation is performed.

For example:<sbr/>
BLL 中这些表达式的对应物名为 <literal>ll_sizeof</literal> 和 <literal>ll_typeid</literal>。他们都只持有一个参数，这个参数可以是一个 lambda 表达式。创建的 lambda 仿函数包装 <literal>sizeof</literal> 
和 <literal>typeid</literal> 调用，当调用这个 lambda 仿函数时执行被包装的操作。例如：

<programlisting>
<![CDATA[vector<base*> a; 
...
for_each(a.begin(), a.end(), 
         cout << bind(&type_info::name, ll_typeid(*_1)));]]>
</programlisting>

Here <literal>ll_typeid</literal> creates a lambda functor for 
calling <literal>typeid</literal> for each element.

The result of a <literal>typeid</literal> call is an instance of 
the <literal>type_info</literal> class, and the bind expression creates 
a lambda functor for calling the <literal>name</literal> member 
function of that class.<sbr/>
这里 <literal>ll_typeid</literal> 创建一个 lambda 仿函数用于对每一个元素调用 <literal>typeid</literal>。
一个 <literal>typeid</literal> 调用的结果是一个 <literal>type_info</literal> 类的实例，
而那个 bind 表达式创建一个 lambda 表达式用于调用那个类的 <literal>name</literal> 成员函数。

</para>
</section>



</section>

<section id="lambda.nested_stl_algorithms">
<title>Nesting STL algorithm invocations 嵌入STL算法调用</title>

<para>
The BLL defines common STL algorithms as function object classes, 
instances of which can be used as target functions in bind expressions.
For example, the following code iterates over the elements of a 
two-dimensional array, and computes their sum.<sbr/>
BLL 将通常的 STL 算法解释为函数对象类，它们的实例可以被用作 bind 表达式中的目标函数。
例如，下面的代码遍历一个二维数组中的元素，并计算它们的和。

<programlisting>
int a[100][200];
int sum = 0;

std::for_each(a, a + 100, 
	      bind(ll::for_each(), _1, _1 + 200, protect(sum += _1)));
</programlisting>

The BLL versions of the STL algorithms are classes, which define the function call operator (or several overloaded ones) to call the corresponding function templates in the <literal>std</literal> namespace.
All these structs are placed in the subnamespace <literal>boost::lambda:ll</literal>. <sbr/>
STL 算法的 BLL 版本是这样一些类，它们定义了函数调用操作符（或者它的各种重载）用来调用 <literal>std</literal> 
名字空间中的相应的函数模板。所有这些结构位于子名字空间 <literal>boost::lambda:ll</literal> 中。
<!--The supported algorithms are listed in <xref linkend="table:nested_algorithms"/>.-->
</para>

<para>
Note that there is no easy way to express an overloaded member function 
call in a lambda expression. 

This limits the usefulness of nested STL algorithms, as for instance 
the <literal>begin</literal> function has more than one overloaded 
definitions in container templates.

In general, something analogous to the pseudo-code below cannot be written:<sbr/>
注意，没有容易的方法表达一个 lambda 表达式中重载成员函数的调用。这限制了嵌套 STL 算法的用处，
例如，<literal>begin</literal> 函数在容器模板中有不止一个重载定义。通常，等效于下面伪码的代码是写不出来的：

<programlisting>
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), _1.begin(), _1.end(), protect(sum += _1)));
</programlisting>

Some aid for common special cases can be provided though.

The BLL defines two helper function object classes, 
<literal>call_begin</literal> and <literal>call_end</literal>, 
which wrap a call to the <literal>begin</literal> and, respectively, 
<literal>end</literal> functions of a container, and return the 
<literal>const_iterator</literal> type of the container.

With these helper templates, the above code becomes:<sbr/>
不过，对于通常的特定情况还是能够提供一些帮助。BLL 定义了两个辅助函数对象类，
<literal>call_begin</literal> 和 <literal>call_end</literal>，分别用于包装一个容器的 
<literal>begin</literal> 和 <literal>end</literal> 的调用，并返回容器的 <literal>const_iterator</literal> 类型。
使用这些辅助模板，上面的代码可以写成：
<programlisting>
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), 
                   bind(call_begin(), _1), bind(call_end(), _1),
                        protect(sum += _1)));
</programlisting>

</para>

<!--
<table id="table:nested_algorithms">
<title>The nested STL algorithms.</title>
<tgroup cols="1">
<thead>
<trow><entry>Otsikko</entry></trow>
</thead>
<tbody>
<row><entry><literal>for_each</literal></entry></row>
<row><entry><literal>find</literal></entry></row>
<row><entry><literal>find_if</literal></entry></row>
<row><entry><literal>find_end</literal></entry></row>
<row><entry><literal>find_first_of</literal></entry></row>
<row><entry><literal>transform</literal></entry></row>
</tbody>
</tgroup>

</table>

-->

</section>


</section>


<!--
<section>
<title>Common gothcas</title>

calling member functions a.begin() 

calling templated functions ...

</section>

-->

<section id="lambda.extending">
<title>Extending return type deduction system 扩展返回类型推演系统</title>

<para>
<!--The <xref linkend = "lambda.overriding_deduced_return_type"/> showed how to make BLL aware of the return type of a function object in bind expressions.-->

In this section, we explain  how to extend the return type deduction system 
to cover user defined operators. 

In many cases this is not necessary, 
as the BLL defines default return types for operators.

For example, the default return type for all comparison operators is 
<literal>bool</literal>, and as long as the user defined comparison operators 
have a bool return type, there is no need to write new specializations 
for the return type deduction classes.

Sometimes this cannot be avoided, though.<sbr/>
本节，我们讲解如何扩展返回类型推演系统以包括用户定义操作符。很多情况下这没有必要，
因为 BLL 定义了操作符的缺省返回类型。例如，所有比较操作符的缺省返回类型是 bool，
那么，只要用户定义的比较操作符具有一个 <literal>bool</literal> 类型的返回值，
就不需要为返回类型推演类提供新的特化。不过，有时这却必不可少。

</para>

<para>
The overloadable user defined operators are either unary or binary. 

For each arity, there are two traits templates that define the 
return types of the different operators.

Hence, the return type system can be extended by providing more 
specializations for these templates.

The templates for unary functors are

<literal>
<![CDATA[plain_return_type_1<Action, A>]]>
</literal>

and 

<literal>
<![CDATA[return_type_1<Action, A>]]>
</literal>, and 

<literal>
<![CDATA[plain_return_type_2<Action, A, B>]]>
</literal>

and 

<literal>
<![CDATA[return_type_2<Action, A, B>]]>
</literal>

respectively for binary functors.<sbr/>
可重载用户定义操作符既有一元的也有二元的。对每一个数量，有两个定义不同操作符的返回类型的特征模板。
因此，返回类型系统可以通过提供对这些模板的更多特化来进行扩展。用于一元函数的模板是 
<literal>
<![CDATA[plain_return_type_1<Action, A>]]>
</literal>

和 

<literal>
<![CDATA[return_type_1<Action, A>]]>
</literal>, 用于二元函数的模板是 

<literal>
<![CDATA[plain_return_type_2<Action, A, B>]]>
</literal>

和 

<literal>
<![CDATA[return_type_2<Action, A, B>]]>
</literal>。

</para>

<para>
The first parameter (<literal>Action</literal>) to all these templates 
is the <emphasis>action</emphasis> class, which specifies the operator. 

Operators with similar return type rules are grouped together into 
<emphasis>action groups</emphasis>, 
and only the action class and action group together define the operator 
unambiguously. 

As an example, the action type 
<literal><![CDATA[arithmetic_action<plus_action>]]></literal> stands for 
<literal>operator+</literal>. 

The complete listing of different action types is shown in 
<xref linkend="table:actions"/>. <sbr/>
传给这些模板的第一个参数 (<literal>Action</literal>) 是指定操作符的 <emphasis>action</emphasis> 类，
具有相似返回值规则的操作符组织到 <emphasis>action 组</emphasis> 中，而且只有 action 类和 action 组一起可以明确定义操作符。
例如，action 类型 <literal><![CDATA[arithmetic_action<plus_action>]]></literal> 代表 <literal>operator+</literal>。
各种 action 类型的完整列表参见 <xref linkend="table:actions"/>。
</para>

<para>
The latter parameters, <literal>A</literal> in the unary case, 
or <literal>A</literal> and <literal>B</literal> in the binary case, 
stand for the argument types of the operator call. 

The two sets of templates, 
<literal>plain_return_type_<parameter>n</parameter></literal> and 
<literal>return_type_<parameter>n</parameter></literal> 
(<parameter>n</parameter> is 1 or 2) differ in the way how parameter types 
are presented to them.

For the former templates, the parameter types are always provided as 
non-reference types, and do not have const or volatile qualifiers.

This makes specializing easy, as commonly one specialization for each 
user defined operator, or operator group, is enough.

On the other hand, if a particular operator is overloaded for different 
cv-qualifications of the same argument types, 
and the return types of these overloaded versions differ, a more fine-grained control is needed.

Hence, for the latter templates, the parameter types preserve the 
cv-qualifiers, and are non-reference types as well. 
 
The downside is, that for an overloaded set of operators of the 
kind described above, one may end up needing up to 
16 <literal>return_type_2</literal> specializations.<sbr/>
后面的参数，一元情况下的 <literal>A</literal>，或二元情况下的 <literal>A</literal> 和 <literal>B</literal>，
代表操作符调用的参数类型。两套模板，<literal>plain_return_type_<parameter>n</parameter></literal> 和 
<literal>return_type_<parameter>n</parameter></literal>（<parameter>n</parameter> 为 1 或 2）
的区别在于将参数类型呈现给它们的方法不同。对于前者，参数类型总是以非引用类型提供，而且没有 const 或 volatile 修饰符。
这将使特化比较简单，而且通常对于每一个用户定义操作符，或操作符组只需要一个特化就足够了。另一方面，
如果一个特定的操作符针对同样的参数类型的不同 cv 修饰进行了重载，而且这些重载版本的返回类型不同，
就需要一个更细致的控制机制。因此，对于后者，参数类型带有 cv 修饰符，而且是非引用类型为好。不利方面在于，
对于上面描述的这种操作符的一套重载，有人最多可能会需要 16 个 <literal>return_type_2</literal> 的特化。
</para>

<para>
Suppose the user has overloaded the following operators for some user defined 
types <literal>X</literal>, <literal>Y</literal> and <literal>Z</literal>:<sbr/>
假设用户拥有下面的操作符针对某些用户定义类型 <literal>X</literal>, 
<literal>Y</literal> 和 <literal>Z</literal> 的重载：

<programlisting>
<![CDATA[Z operator+(const X&, const Y&);
Z operator-(const X&, const Y&);]]>
</programlisting>

Now, one can add a specialization stating, that if the left hand argument 
is of type <literal>X</literal>, and the right hand one of type 
<literal>Y</literal>, the return type of all such binary arithmetic 
operators is <literal>Z</literal>:<sbr/>
现在，要增加一种特化情形，这种情形中左侧参数为类型 <literal>X</literal>，右侧参数为类型 
<literal>Y</literal>，所有这样的二元算术操作符的返回类型都是 <literal>Z</literal>：

<programlisting>
<![CDATA[namespace boost { 
namespace lambda {
  
template<class Act> 
struct plain_return_type_2<arithmetic_action<Act>, X, Y> {
  typedef Z type;
};

}
}]]>
</programlisting>

Having this specialization defined, BLL is capable of correctly 
deducing the return type of the above two operators.

Note, that the specializations must be in the same namespace, 
<literal>::boost::lambda</literal>, with the primary template. 

For brevity, we do not show the namespace definitions in the examples below.<sbr/>
有了这个特化定义，BLL 就可以正确推演上面两个操作符的返回类型。注意，特化必须和原来的模板在同样的名字空间中，
<literal>::boost::lambda</literal>，为了简单起见，在下面的示例中我们没有表明名字空间定义。
</para>

<para>
It is possible to specialize on the level of an individual operator as well, 
in addition to providing a specialization for a group of operators. 
Say, we add a new arithmetic operator for argument types <literal>X</literal> 
and <literal>Y</literal>:<sbr/>
除了为一组操作符提供一个特化外，有时在个别操作符的层次上提供特化可能更好。比如说，
我们为参数类型 <literal>X</literal> 和 <literal>Y</literal> 增加一个新的算术操作符：

<programlisting>
<![CDATA[X operator*(const X&, const Y&);]]>
</programlisting>

Our first rule for all arithmetic operators specifies that the return 
type of this operator is <literal>Z</literal>, 
which obviously is not the case.
Hence, we provide a new rule for the multiplication operator:<sbr/>
我们先前的规则是针对返回类型为 <literal>Z</literal> 的所有算术操作符特化的，
这里显然不是这种情况。因此，我们为乘法操作符提供了一个新的规则：

<programlisting>
<![CDATA[template<> 
struct plain_return_type_2<arithmetic_action<multiply_action>, X, Y> {
  typedef X type;
};]]>
</programlisting>
</para>

<para>
The specializations can define arbitrary mappings from the argument types 
to the return type. 

Suppose we have some mathematical vector type, templated on the element type:<sbr/>
特化可以定义从参数类型到返回类型的任意映射。假设我们有某一数学 vector 类型，
它的元素类型被模板化：

<programlisting>
<![CDATA[template <class T> class my_vector;]]>
</programlisting>

Suppose the addition operator is defined between any two 
<literal>my_vector</literal> instantiations, 
as long as the addition operator is defined between their element types. 

Furthermore, the element type of the resulting <literal>my_vector</literal> 
is the same as the result type of the addition between the element types.

E.g., adding <literal><![CDATA[my_vector<int>]]></literal> and 
<literal><![CDATA[my_vector<double>]]></literal> results in 
<literal><![CDATA[my_vector<double>]]></literal>.

The BLL has traits classes to perform the implicit built-in and standard 
type conversions between integral, floating point, and complex classes.

Using BLL tools, the addition operator described above can be defined as:<sbr/>
假设在任何两个 <literal>my_vector</literal> 实例之间，只要它们的元素之间定义了加法操作符，
就要在这两个 <literal>my_vector</literal> 实例之间定义加法操作符。而且，存储结果的 
<literal>my_vector</literal> 的元素类型和元素之间加法的结果类型相同。
例如，<literal><![CDATA[my_vector<int>]]></literal> 和 <literal><![CDATA[my_vector<double>]]></literal> 
相加的结果存储在 <literal><![CDATA[my_vector<double>]]></literal> 中。
BLL 中有特征类用来执行整型，浮点数和复杂类之间的隐式内建类型转换和标准类型转换。
使用 BLL 工具，上面描述的加法操作符可以定义为：

<programlisting>
<![CDATA[template<class A, class B> 
my_vector<typename return_type_2<arithmetic_action<plus_action>, A, B>::type>
operator+(const my_vector<A>& a, const my_vector<B>& b)
{
  typedef typename 
    return_type_2<arithmetic_action<plus_action>, A, B>::type res_type;
  return my_vector<res_type>();
}]]>
</programlisting>
</para>

<para>
To allow BLL to deduce the type of <literal>my_vector</literal> 
additions correctly, we can define:<sbr/>
为了让 BLL 能够正确推演 <literal>my_vector</literal> 的类型，我们可以定义：

<programlisting>
<![CDATA[template<class A, class B> 
class plain_return_type_2<arithmetic_action<plus_action>, 
                           my_vector<A>, my_vector<B> > {
  typedef typename 
    return_type_2<arithmetic_action<plus_action>, A, B>::type res_type;
public:
  typedef my_vector<res_type> type;
};]]>
</programlisting>
Note, that we are reusing the existing specializations for the 
BLL <literal>return_type_2</literal> template, 
which require that the argument types are references. <sbr/>
注意，我们复用了对 BLL 的 <literal>return_type_2</literal> 模板的已有的特化，
它需要参数类型为引用。
</para>

<!-- TODO: is an example of specifying the other level needed at all -->
<!-- TODO: comma operator is a special case for that -->

<table id = "table:actions">
<title>Action types 动作类型</title>
<tgroup cols="2">
<tbody>

<row><entry><literal><![CDATA[+]]></literal></entry><entry><literal><![CDATA[arithmetic_action<plus_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[-]]></literal></entry><entry><literal><![CDATA[arithmetic_action<minus_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[*]]></literal></entry><entry><literal><![CDATA[arithmetic_action<multiply_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[/]]></literal></entry><entry><literal><![CDATA[arithmetic_action<divide_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[%]]></literal></entry><entry><literal><![CDATA[arithmetic_action<remainder_action>]]></literal></entry></row>



<row><entry><literal><![CDATA[+]]></literal></entry><entry><literal><![CDATA[unary_arithmetic_action<plus_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[-]]></literal></entry><entry><literal><![CDATA[unary_arithmetic_action<minus_action>]]></literal></entry></row>



<row><entry><literal><![CDATA[&]]></literal></entry><entry><literal><![CDATA[bitwise_action<and_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[|]]></literal></entry><entry><literal><![CDATA[bitwise_action<or_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[~]]></literal></entry><entry><literal><![CDATA[bitwise_action<not_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[^]]></literal></entry><entry><literal><![CDATA[bitwise_action<xor_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[<<]]></literal></entry><entry><literal><![CDATA[bitwise_action<leftshift_action_no_stream>]]></literal></entry></row>
<row><entry><literal><![CDATA[>>]]></literal></entry><entry><literal><![CDATA[bitwise_action<rightshift_action_no_stream>]]></literal></entry></row>



<row><entry><literal><![CDATA[&&]]></literal></entry><entry><literal><![CDATA[logical_action<and_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[||]]></literal></entry><entry><literal><![CDATA[logical_action<or_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[!]]></literal></entry><entry><literal><![CDATA[logical_action<not_action>]]></literal></entry></row>



<row><entry><literal><![CDATA[<]]></literal></entry><entry><literal><![CDATA[relational_action<less_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[>]]></literal></entry><entry><literal><![CDATA[relational_action<greater_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[<=]]></literal></entry><entry><literal><![CDATA[relational_action<lessorequal_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[>=]]></literal></entry><entry><literal><![CDATA[relational_action<greaterorequal_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[==]]></literal></entry><entry><literal><![CDATA[relational_action<equal_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[!=]]></literal></entry><entry><literal><![CDATA[relational_action<notequal_action>]]></literal></entry></row>



<row><entry><literal><![CDATA[+=]]></literal></entry><entry><literal><![CDATA[arithmetic_assignment_action<plus_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[-=]]></literal></entry><entry><literal><![CDATA[arithmetic_assignment_action<minus_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[*=]]></literal></entry><entry><literal><![CDATA[arithmetic_assignment_action<multiply_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[/=]]></literal></entry><entry><literal><![CDATA[arithmetic_assignment_action<divide_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[%=]]></literal></entry><entry><literal><![CDATA[arithmetic_assignment_action<remainder_action>]]></literal></entry></row>



<row><entry><literal><![CDATA[&=]]></literal></entry><entry><literal><![CDATA[bitwise_assignment_action<and_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[=|]]></literal></entry><entry><literal><![CDATA[bitwise_assignment_action<or_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[^=]]></literal></entry><entry><literal><![CDATA[bitwise_assignment_action<xor_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[<<=]]></literal></entry><entry><literal><![CDATA[bitwise_assignment_action<leftshift_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[>>=]]></literal></entry><entry><literal><![CDATA[bitwise_assignment_action<rightshift_action>]]></literal></entry></row>



<row><entry><literal><![CDATA[++]]></literal></entry><entry><literal><![CDATA[pre_increment_decrement_action<increment_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[--]]></literal></entry><entry><literal><![CDATA[pre_increment_decrement_action<decrement_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[++]]></literal></entry><entry><literal><![CDATA[post_increment_decrement_action<increment_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[--]]></literal></entry><entry><literal><![CDATA[post_increment_decrement_action<decrement_action>]]></literal></entry></row>



<row><entry><literal><![CDATA[&]]></literal></entry><entry><literal><![CDATA[other_action<address_of_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[*]]></literal></entry><entry><literal><![CDATA[other_action<contents_of_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[,]]></literal></entry><entry><literal><![CDATA[other_action<comma_action>]]></literal></entry></row>
<row><entry><literal><![CDATA[->*]]></literal></entry><entry><literal><![CDATA[other_action<member_pointer_action>]]></literal></entry></row>

</tbody>
</tgroup>
</table>

</section>


<section>
<title>Practical considerations 实践中的考虑</title>


<section>
<title>Performance 性能</title>

<para>In theory, all overhead of using STL algorithms and lambda functors 
compared to hand written loops can be optimized away, just as the overhead 
from standard STL function objects and binders can.

Depending on the compiler, this can also be true in practice.
We ran two tests with the GCC 3.0.4 compiler on 1.5 GHz Intel Pentium 4.
The optimization flag -03 was used.<sbr/>
在理论上，使用 STL 算法和 lambda 仿函数的全部代价要远远小于手写循环，就像标准 STL 函数对象和绑定器那样。
依靠编译器的能力，这在实践中也是成立的。我们使用 GCC 3.0.4 编译器在 1.5 GHz Intel Pentium 4 上运行了两个测试。
使用了优化标志 -03。
</para>

<para>
In the first test we compared lambda functors against explicitly written 
function objects. 
We used both of these styles to define unary functions which multiply the
argument repeatedly by itself. 
We started with the identity function, going up to 
x<superscript>5</superscript>.
The expressions were called inside a <literal>std::transform</literal> loop, 
reading the argument from one <literal><![CDATA[std::vector<int>]]></literal> 
and placing the result into another.
The length of the vectors was 100 elements.
The running times are listed in 
<xref linkend="table:increasing_arithmetic_test"/>.

We can observe that there is no significant difference between the
two approaches.<sbr/>
在第一个测试中我们对比了 lambda 仿函数与显式写出的函数对象之间的差异。我们用这两种形式定义了参数反复与自己相乘的一元函数。
我们从恒等函数开始，一直到 x<superscript>5</superscript>。在一个 <literal>std::transform</literal> 循环中调用了一个表达式，
这个表达式从一个 <literal><![CDATA[std::vector<int>]]></literal> 读取参数，并将结果放入另一个 
<literal><![CDATA[std::vector<int>]]></literal>。vectors 的长度为 100 个元素。运行时间列在 
<xref linkend="table:increasing_arithmetic_test"/> 中。我们可以看到，两种方法没有太大的区别。
</para>

<para>
In the second test we again used <literal>std::transform</literal> to 
perform an operation to each element in a 100-element long vector.
This time the element type of the vectors was <literal>double</literal>
and we started with very simple arithmetic expressions and moved to 
more complex ones.
The running times are listed in <xref linkend="table:ll_vs_stl_test"/>.

Here, we also included classic STL style unnamed functions into tests.
We do not show these expressions, as they get rather complex. 
For example, the
last expression in <xref linkend="table:ll_vs_stl_test"/> written with
classic STL tools contains 7 calls to <literal>compose2</literal>, 
8 calls to <literal>bind1st</literal>
and altogether 14 constructor invocations for creating 
<literal>multiplies</literal>, <literal>minus</literal> 
and <literal>plus</literal> objects.

In this test the BLL expressions are a little slower (roughly 10% on average,
less than 14% in all cases)
than the corresponding hand-written function objects.
The performance hit is a bit greater with classic STL expressions,
up to 27% for the simplest expressios.<sbr/>
在第二个测试中我们再次使用 <literal>std::transform</literal> 对 100 个元素长的 vector 中的每一个元素执行一项操作。
这次 vectors 中的元素类型是 <literal>double</literal>，而且我们从非常简单的算术表达式开始，慢慢变得更加复杂。
运行时间列在 <xref linkend="table:ll_vs_stl_test"/> 中。这一次，我们在测试中还包括了标准的 STL 形式的无名函数。
我们没有列出这些表达式，因为它们更加复杂。比如，<xref linkend="table:ll_vs_stl_test"/> 中的最后一个表达式如果用标准
STL 工具写出来，包含 7 个 <literal>compose2</literal> 的调用，8 个 <literal>bind1st</literal> 的调用，
和总共 14 个创建 <literal>multiplies</literal>，<literal>minus</literal> 和 <literal>plus</literal> 
对象的构造函数的调用。在这个测试中 BLL 表达式与相应的手写函数对象相比稍微慢了一点（平均大约 10%，
所有情况下均不超过 14%）。多少有些意外的是标准 STL 表达式慢了一些，最简单的表达式相差达到了 27%。
</para>

<para>
The tests suggest that the BLL does not introduce a loss of performance 
compared to STL function objects.  
With a reasonable optimizing compiler, one should expect the performance characteristics be comparable to using classic STL.
Moreover, with simple expressions the performance can be expected to be close
to that of explicitly written function objects.

<!-- We repeated both tests with the KAI C++ 4.0f compiler (using +K2 -O3 flags), 
generally considered a good optimizing compiler.
We do not list the results here, since the running times for the two alternatives in the first test were essentially the same, just as the running times
for the three different alternatives in the second test.
These tests suggest there to be no performance penalty at all
with a good optimizing compiler.
-->

Note however, that evaluating a lambda functor consist of a sequence of calls to small functions that are declared inline. 
If the compiler fails to actually expand these functions inline, 
the performance can suffer. 
The running time can more than double if this happens.
Although the above tests do not include such an expression, we have experienced
this for some seemingly simple expressions.<sbr/>
以上测试表明 BLL 相对于 STL 函数对象没有引入性能损失。通过合理优化的编译器，
应该认为性能特征可以和使用标准 STL 并驾齐驱。而且，对于简单表达式，
可以预期性能接近于显式写出的函数对象。评测一个由一系列对声明为 inline 的小函数的调用组成的 lambda 表达式时，
无论如何要注意。如果编译器没有真的内联扩展这些函数，性能可能会遭受损失。如果这样，运行时间可能会大于二倍。
尽管上面的测试不包含这样一个表达式，对于一些表面上简单的表达式，我们也会有这样的经验。


<table id = "table:increasing_arithmetic_test">
<title>Test 1</title>
<caption>CPU time of expressions with integer multiplication written as a lambda expression and as a traditional hand-coded function object class. 
The running times are expressed in arbitrary units.<sbr/>
整数乘法写成一个 lambda 表达式和写成一个传统的手编码函数对象类的 CPU 时间。运行时间可以表示为任意单位。</caption>
<tgroup cols="3">
<thead>
<row>
<entry>expression 表达式</entry><entry>lambda expression lambda表达式</entry><entry>hand-coded function object 手编码函数对象</entry></row>
</thead>

<tbody>

<row>
<entry>x</entry><entry>240</entry><entry>230</entry>
</row>

<row>
<entry>x*x</entry><entry>340</entry><entry>350</entry>
</row>

<row>
<entry>x*x*x</entry><entry>770</entry><entry>760</entry>
</row>

<row>
<entry>x*x*x*x</entry><entry>1180</entry><entry>1210</entry>
</row>

<row>
<entry>x*x*x*x*x</entry><entry>1950</entry><entry>1910</entry>
</row>

</tbody>
</tgroup>
</table>
</para>

<!--
16:19:49 bench [601] ./arith.out 100 1000000

Number of elements = 100
L1 : 240
L2 : 340
L3 : 770
L4 : 1180
L5 : 1950

P2 : 1700
P3 : 2130
P4 : 2530
P5 : 3000

F1 : 230
F2 : 350
F3 : 760
F4 : 1210
F5 : 1910


Number of elements    = 100
Number of outer_iters = 1000000
L1 : 330
L2 : 350
L3 : 470
L4 : 620
L5 : 1660
LP : 1230
C1 : 370
C2 : 370
C3 : 500
C4 : 670
C5 : 1660
CP : 1770
F1 : 290
F2 : 310
F3 : 420
F4 : 600
F5 : 1460
FP : 1040

-->


<para>
<table id = "table:ll_vs_stl_test">
<title>Test 2</title>
<caption>CPU time of arithmetic expressions written as lambda 
expressions, as classic STL unnamed functions (using <literal>compose2</literal>, <literal>bind1st</literal> etc.) and as traditional hand-coded function object classes. 
Using BLL terminology, 
<literal>a</literal> and <literal>b</literal> are bound arguments in the expressions, and <literal>x</literal> is open. 
All variables were of types <literal>double</literal>.
The running times are expressed in arbitrary units.<sbr/>
算术表达式写成 lambda 表达式，写成标准 STL 无名函数（使用 <literal>compose2</literal>，<literal>bind1st</literal> 等）
和写成传统的手编码函数对象类的 CPU 时间。使用 BLL 术语，<literal>a</literal> 和 <literal>b</literal> 是表达式中的已绑定参数，
而 <literal>x</literal> 是开放的。所有变量是 <literal>double</literal> 类型的。运行时间可以表示为任意单位。</caption>
<tgroup cols="4">
<thead>
<row>
<entry>expression 表达式</entry><entry>lambda expression lambda表达式</entry><entry>classic STL expression 标准STL表达式</entry><entry>hand-coded function object 手编码函数对象</entry></row>
</thead>

<tbody>

<row>
<entry>ax</entry><entry>330</entry><entry>370</entry><entry>290</entry>
</row>

<row>
<entry>-ax</entry><entry>350</entry><entry>370</entry><entry>310</entry>
</row>

<row>
<entry>ax-(a+x)</entry><entry>470</entry><entry>500</entry><entry>420</entry>
</row>

<row>
<entry>(ax-(a+x))(a+x)</entry><entry>620</entry><entry>670</entry><entry>600</entry>
</row>

<row>
<entry>((ax) - (a+x))(bx - (b+x))(ax - (b+x))(bx - (a+x))</entry><entry>1660</entry><entry>1660</entry><entry>1460</entry>
</row>

</tbody>
</tgroup>

</table>
</para>


<para>Some additional performance testing with an earlier version of the
library is described
<xref linkend="cit:jarvi:00"/>.<sbr/>
还有一些针对库的早期版本的额外的性能测试 <xref linkend="cit:jarvi:00"/>。 
</para>

</section>
    <section>
      <title>About compiling 关于编译</title>

      <para>The BLL uses templates rather heavily, performing numerous recursive instantiations of the same templates. 
This has (at least) three implications:<sbr/>
BLL 大量使用了模板，实行了无数针对同一模板的递归实例化。这里（至少）有三条推论：
<itemizedlist>

<listitem>
<para>
While it is possible to write incredibly complex lambda expressions, it probably isn't a good idea. 
Compiling such expressions may end up requiring a lot of memory 
at compile time, and being slow to compile.<sbr/>
写一些难以置信地复杂的 lambda 表达式即使是可能的，可能也不是好主意。
编译这样的表达式可能会需要大量内存，而且编译速度会变得很慢。
</para>
</listitem>


<listitem>
<para>
The types of lambda functors that result from even the simplest lambda expressions are cryptic. 
Usually the programmer doesn't need to deal with the lambda functor types at all, but in the case of an error in a lambda expression, the compiler usually outputs the types of the lambda functors involved. 
This can make the error messages very long and difficult to interpret, particularly if the compiler outputs the whole chain of template instantiations.<sbr/>
即使是由最简单的 lambda 表达式产生的 lambda 仿函数的类型也是隐含的。通常程序员根本不需要涉及 lambda 仿函数类型，
但是在一个 lambda 表达式中有错误的情况下，编译器通常会输出被调用的 lambda 仿函数的类型。
这可能使得错误信息非常长而且难以理解，特别是如果编译器输出整串模板实例。
</para>
</listitem>

<listitem>
<para>
The C++ Standard suggests a template nesting level of 17 to help detect infinite recursion. 
Complex lambda templates can easily exceed this limit. 
Most compilers allow a greater number of nested templates, but commonly require the limit explicitly increased with a command line argument.<sbr/>
C++ 标准建议一个模板嵌套不要超过 17 层以帮助探测无限递归。复杂 lambda 表达式可能很容易超过这个限制。
大多数编译器允许很大数量的嵌套模板，但是通常需要通过一个命令行参数以将界限明确扩充。
</para>
</listitem>
</itemizedlist></para>

    </section>

    <section>
      <title>Portability 可移植性</title>
      <para>
The BLL works with the following compilers, that is, the compilers are capable of compiling the test cases that are included with the BLL:<sbr/>
BLL 可以和以下编译器一起工作，就是说，这些编译器可以编译包含 BLL 的测试用例：

      <itemizedlist>
	<listitem>GCC 3.0.4
	</listitem>
	<listitem>KCC 4.0f with EDG 2.43.1
	</listitem>
	<listitem>GCC 2.96 (fails with one test case, the <filename>exception_test.cpp</filename> results in an internal compiler error.
)<sbr/>
              GCC 2.96（失败一个测试用例，exception_test.cpp 导致一个内部编译错误。） 

	</listitem>
      </itemizedlist>
</para>

      <section>
	<title>Test coverage 测试范围</title>

<para>The following list describes the test files included and the features that each file covers:<sbr/>
下面的列表描述了包含的测试文件以及每一个文件覆盖的特性：

<itemizedlist>
<listitem>
<para>
<filename>bind_tests_simple.cpp</filename> : Bind expressions of different arities and types of target functions: function pointers, function objects and member functions.
Function composition with bind expressions.<sbr/>
<filename>bind_tests_simple.cpp</filename>：不同数量和目标函数类型（函数指针，函数对象和成员函数）的 bind 表达式。结合 bind 表达式的函数。</para>
</listitem>

<listitem>
<para><filename>bind_tests_simple_function_references.cpp</filename> :
Repeats all tests from <filename moreinfo="none">bind_tests_simple.cpp</filename> where the target function is a function pointer, but uses function references instead.<sbr/>
<filename>bind_tests_simple_function_references.cpp</filename>：重复 <filename moreinfo="none">bind_tests_simple.cpp</filename> 
中那些目标函数为函数指针的所有测试，但是使用函数引用来代替函数指针。
</para></listitem>

	    
<listitem>
<para><filename>bind_tests_advanced.cpp</filename> : Contains tests for nested bind expressions, <literal>unlambda</literal>, <literal>protect</literal>, <literal>const_parameters</literal> and <literal>break_const</literal>.
Tests passing lambda functors as actual arguments to other lambda functors, currying, and using the <literal>sig</literal> template to specify the return type of a function object.<sbr/>
<filename>bind_tests_advanced.cpp</filename>：包含针对嵌套 lambda 表达式，<literal>unlambda</literal>，
<literal>protect</literal>，<literal>const_parameters</literal> 和 <literal>break_const</literal> 的测试。
测试了将 lambda 仿函数作为实际参数传递给另一个 lambda 仿函数，整理，并使用 <literal>sig</literal> 
模板指定一个函数对象的返回值。
</para>
</listitem>

<listitem>
<para>
<filename>operator_tests_simple.cpp</filename> :
Tests using all operators that are overloaded for lambda expressions, that is, unary and binary arithmetic, 
bitwise, 
comparison, 
logical,
increment and decrement, 
compound, 
assignment,
subscrict, 
address of,
dereference, and comma operators.
The streaming nature of shift operators is tested, as well as pointer arithmetic with plus and minus operators.<sbr/>
<filename>operator_tests_simple.cpp</filename>：测试为 lambda 表达式重载的所有操作符，也就是说，一元和二元算术，
位操作，比较，逻辑，增一和减一，复合，赋值，下标，取地址，引用，和逗号操作符。移位操作符的流动特性也进行了测试，
还包括使用加法和减法操作符的指针算术。
</para>
</listitem>
	    
<listitem>
<para><filename>member_pointer_test.cpp</filename> : The pointer to member operator is complex enough to warrant a separate test file.<sbr/>
<filename>member_pointer_test.cpp</filename>：指向成员函数的指针复杂到足以提供一个单独的测试文件。
</para>
</listitem>

<listitem>
<para>
<filename>control_structures.cpp</filename> :
Tests for the looping and if constructs.<sbr/>
<filename>control_structures.cpp</filename>：测试了循环和 if 结构。
</para></listitem>

<listitem>
<para>
<filename>switch_construct.cpp</filename> :
Includes tests for all supported arities of the switch statement, both with and without the default case.<sbr/>
<filename>switch_construct.cpp</filename>：包含针对 switch 语句的全部已支持数量的测试，包含有和没有 default 两种情况。
</para>
</listitem>

<listitem>
<para>
<filename>exception_test.cpp</filename> :
Includes tests for throwing exceptions and for try/catch constructs with varying number of catch blocks.<sbr/>
<filename>exception_test.cpp</filename>：包含针对抛出异常和针对 catch 块数量可变的 try/catch 结构的测试。
</para>
</listitem>

<listitem>
<para>
<filename>constructor_tests.cpp</filename> :
Contains tests for <literal>constructor</literal>, <literal>destructor</literal>, <literal>new_ptr</literal>, <literal>delete_ptr</literal>, <literal>new_array</literal> and <literal>delete_array</literal>.<sbr/>
<filename>constructor_tests.cpp</filename>：包含针对 <literal>constructor</literal>, <literal>destructor</literal>, 
<literal>new_ptr</literal>, <literal>delete_ptr</literal>, <literal>new_array</literal> 和 <literal>delete_array</literal> 的测试。
</para>
</listitem>

<listitem>
<para>
<filename>cast_test.cpp</filename> : Tests for the four cast expressions, as well as <filename>typeid</filename> and <literal>sizeof</literal>.<sbr/>
<filename>cast_test.cpp</filename>：针对四种强制转型表达式，以及 <filename>typeid</filename> 和 <literal>sizeof</literal> 的测试。
</para>
</listitem>

<listitem>
<para>
<filename>extending_return_type_traits.cpp</filename> : Tests extending the return type deduction system for user defined types.
Contains several user defined operators and the corresponding specializations for the return type deduction templates.<sbr/>
<filename>extending_return_type_traits.cpp</filename>：测试为用户定义类型扩展返回类型推演系统。
包含几个用户定义操作符和相应的返回类型推演模板的特化。
</para>
</listitem>

<listitem>
<para>
<filename>is_instance_of_test.cpp</filename> : Includes tests for an internally used traits template, which can detect whether a given type is an instance of a certain template or not. <sbr/>
<filename>is_instance_of_test.cpp</filename>：包含针对一个内部使用的特征模板的测试，
这个模板可以探测一个给定类型是否是某一个模板的实例。
</para></listitem>

<listitem>
<para>
<filename>bll_and_function.cpp</filename> :
Contains tests for using <literal>boost::function</literal> together with lambda functors.<sbr/>
<filename>bll_and_function.cpp</filename>：包含和 lambda 仿函数一起使用 <literal>boost::function</literal> 的测试。
</para></listitem>

	  </itemizedlist>

</para>

      </section>

    </section>


</section>


<section>
<title>Relation to other Boost libraries 和其它Boost库的关系</title>

<section>
<title>Boost Function  Boost函数</title>

<para>Sometimes it is convenient to store lambda functors in variables.
However, the types of even the simplest lambda functors are long and unwieldy, and it is in general unfeasible to declare variables with lambda functor types.
<emphasis>The Boost Function library</emphasis> <xref linkend="cit:boost::function"/> defines wrappers for arbitrary function objects, for example 
lambda functors; and these wrappers have types that are easy to type out.

For example:<sbr/>
有时候把 lambda 仿函数存储到变量中是很方便的。但是，即使是最简单的 lambda 仿函数的类型也是又长又难看的，而且，
声明具有 lambda 仿函数类型的变量基本上是不可能的。<emphasis>The Boost Function library</emphasis> 
<xref linkend="cit:boost::function"/> 为任意的函数对象（比如 lambda 仿函数）声明了包装类，
而且这些包装类的类型是非常容易输出的。例如：

<programlisting>
<![CDATA[boost::function<int(int, int)> f = _1 + _2;
boost::function<int&(int&)> g = (_1 += 10);
int i = 1, j = 2;
f(i, j); // returns 3
g(i);    // sets i to = 11;]]>
</programlisting>

The return and parameter types of the wrapped function object must be written explicilty as the template argument to the wrapper template <literal>boost::function</literal>; even when lambda functors, which otherwise have generic parameters, are wrapped.
Wrapping a function object with <literal>boost::function</literal> introduces a performance cost comparable to virtual function dispatch, though virtual functions are not actually used.

Note that storing lambda functors inside <literal>boost::function</literal> 
introduces a danger.
Certain types of lambda functors may store references to the bound 
arguments, instead as taking copies of the arguments of the lambda expression.
When temporary lambda functor objects are used 
in STL algorithm invocations this is always safe, as the lambda functor gets 
destructed immediately after the STL algortihm invocation is completed.

However, a lambda functor wrapped inside <literal>boost::function</literal> 
may continue to exist longer, creating the possibility of dangling references.
For example:<sbr/>
被包装函数对象的返回值和参数类型必须作为包装类模板 <literal>boost::function</literal> 的模板参数显式写出来，
即使是具有其它泛型参数担的 lambda 仿函数被包装时也是如此。用 <literal>boost::function</literal> 
包装一个函数对象引起的性能成本相当于虚拟函数的匹配，虽然这里并没有真的使用虚拟函数。需要注意将 lambda 仿函数存储在 
<literal>boost::function</literal> 中会引发的一个危险。某种类型的 lambda 仿函数可能将引用存储在已绑定参数中，
而不是持有 lambda 表达式的参数的拷贝。当临时 lambda 仿函数对象用在 STL 算法调用中，这总是安全的，
因为在 STL 算法调用完成之后，lambda 仿函数立即被销毁。但是，一个被包装在 <literal>boost::function</literal> 中的 
lambda 仿函数可以继续存在，造成悬挂引用的可能性。例如：

<programlisting>
<![CDATA[int* sum = new int();
*sum = 0;
boost::function<int&(int)> counter = *sum += _1;
counter(5); // ok, *sum = 5;
delete sum; 
counter(3); // error, *sum does not exist anymore]]>
</programlisting>

</para>

</section>

<section>
<title>Boost Bind</title>
<para>
<emphasis>The Boost Bind</emphasis> <xref linkend="cit:boost::bind"/> library has partially overlapping functionality with the BLL. 
Basically, the Boost Bind library (BB in the sequel) implements the bind expression part of BLL.
There are, however, some semantical differerences.<sbr/>
<emphasis>The Boost Bind</emphasis> <xref linkend="cit:boost::bind"/> 库和 BLL 有部分重叠功能。
基本上，Boost Bind 库（简称为 BB）实现了 BLL 的 bind 表达式部分。但是，还是有一些语义上的不同。
</para>
<para>
The BLL and BB evolved separately, and have different implementations. 
This means that the bind expressions from the BB cannot be used within 
bind expressions, or within other type of lambda expressions, of the BLL.
The same holds for using BLL bind expressions in the BB.
The libraries can coexist, however, as
the names of the BB library are in <literal>boost</literal> namespace, 
whereas the BLL names are in <literal>boost::lambda</literal> namespace.<sbr/>
BLL 和 BB 各自单独发展，而且有着各自不同的实现。这就意味着来自 BB 的 bind 表达式不能用于 BLL 的 bind 表达式，
或者其它类型的 lambda 表达式中。对于在 BB 中使用 BLL bind 表达式也有同样的问题。但是，库还是会共存，
因为 BB 库的名字在 <literal>boost</literal> 名字空间中，而 BLL 名字在 <literal>boost::lambda</literal> 名字空间中。
</para>

<para>
The BLL requires a compiler that is reasonably conformant to the 
C++ standard, whereas the BB library is more portable, and works with 
a larger set of compilers. <sbr/>
BLL 需要一个与 C++ 标准比较一致的编译器，BB 库的可移植性更好一些，可以用于更多的编译器。
</para>

<para>
The following two sections describe what are the semantic differences 
between the bind expressions in BB and BLL.<sbr/>
下面两段描述 BB 的 bind 表达式和 BLL 的 bind 表达式有哪些语义上的区别。
</para>




<section>
<title>First argument of bind expression  bind表达式的第一个参数</title>

In BB the first argument of the bind expression, the target function, 
is treated differently from the other arguments, 
as no argument substitution takes place within that argument.
In BLL the first argument is not a special case in this respect.

For example:<sbr/>
BB 中的 bind 表达式的第一个参数，目标函数，与其它参数的被处理手段不同，
因为这个参数没有发生参数替换。在 BLL 中，第一个参数在这方面没什么特殊。例如：

<programlisting>
<![CDATA[template<class F>
int foo(const F& f) {
  int x;
  ..
  bind(f, _1)(x);
  ...
}]]>
</programlisting>

<programlisting>
<![CDATA[int bar(int, int);
nested(bind(bar, 1, _1));]]>
</programlisting>

The bind expression inside <literal>foo</literal> becomes:<sbr/>
<literal>foo</literal> 中的 bind 表达式变成：
<programlisting>
bind(bind(bar, 1, _1), _1)(x)
</programlisting>

The BLL interpretes this as:<sbr/>
BLL 将此解释为：
<programlisting>
bar(1, x)(x)
</programlisting>
whereas the BB library as<sbr/>
而 BB 库解释为
<programlisting>
bar(1, x)
</programlisting>

To get this functionality in BLL, the bind expression inside the <literal moreinfo="none">foo</literal> function can be written as:<sbr/>
为了在 BLL 中得到这个功能，<literal moreinfo="none">foo</literal> 函数中的 bind 表达式可以写成：
<programlisting>
bind(unlambda(f), _1)(x);
</programlisting>
as explained in <xref linkend = "lambda.unlambda"/>. <sbr/>
就像 <xref linkend = "lambda.unlambda"/> 的解释。

</section>




<para>
The BB library supports up to nine placeholders, while the BLL 
defines only three placeholders. 
The rationale for not providing more, is that the highest arity of the
function objects accepted by any STL algorithm is two. 
The placeholder count is easy to increase in the BB library.
In BLL it is possible, but more laborous.
The BLL currently passes the actual arguments to the lambda functors
internally just as they are and does not wrap them inside a tuple object.
The reason for this is that some widely used compilers are not capable
of optimizing the intermediate tuple objects away. 
The creation of the intermediate tuples would cause a significant
performance hit, particularly for the simplest (and thus the most common) 
lambda functors.  
We are working on a hybrid approach, which will allow more placeholders
but not compromise the performance of simple lambda functors.<sbr/>
BB 库最多支持 9 个占位符，而 BLL 只定义了三个占位符。不再提供更多的根本原因，
在于任何 STL 算法接受的函数对象的最大数量是 2。BB 库中的占位符数量很容易增加。
在 BLL 中也可以做到，但是更费事一些。BLL 将实际参数传递到 lambda 仿函数中时通常不会把它们包装到一个 tuple 对象中，
除非它们本身就是 tuple。原因在于一些广泛使用的编译器不能将中间 tuple 对象优化掉。
中间 tuples 的构建可能引起重大的性能损失，特别是对于最简单的（同时也是最普通的）lambda 仿函数。
我们致力于一个混合方案，即允许更多的占位符，同时又不危害简单 lambda 仿函数的性能。
</para>

</section>

  </section>


<section>
<title>Contributors 贡献者</title>

The main body of the library was written by Jaakko J鋜vi and Gary Powell.
We've got outside help, suggestions and ideas from Jeremy Siek, Peter Higley, Peter Dimov, Valentin Bonnard, William Kempf.
We would particularly like to mention Joel de Guzmann and his work with 
Phoenix which has influenced BLL significantly, making it considerably simpler 
to extend the library with new features.<sbr/>
这个库的主要部分由 Jaakko Jrvi 和 Gary Powell 提供。我们还得到很多外界的帮助，
建议和想法，来自 Jeremy Siek, Peter Higley, Peter Dimov, Valentin Bonnard, William Kempf。
我们要特别提到 Joel de Guzmann 以及他在 Phoenix 的工作，深刻地影响了 BLL，
使得在库中扩展新的特性相当地容易。

</section>



<section>
<title>Rationale for some of the design decisions 某些设计权衡的根本原因</title>

<section id="lambda.why_weak_arity">
<title>
Lambda functor arity  lambda仿函数数量
</title>

<para>
The highest placeholder index in a lambda expression determines the arity of the resulting function object.
However, this is just the minimal arity, as the function object can take arbitrarily many arguments; those not needed are discarded.
Consider the two bind expressions and their invocations below:<sbr/>
一个 lambda 表达式中的最高占位符索引决定最终的函数对象的数量。但是，这只是一个最小数量，因为函数对象可以持有任意多的参数，
那些不需要被放弃。考虑下面的两个 bind 表达式和它们的调用：

<programlisting>
bind(g, _3, _3, _3)(x, y, z); 
bind(g, _1, _1, _1)(x, y, z); 
</programlisting>

This first line discards arguments <literal>x</literal> and
<literal>y</literal>, and makes the call:<sbr/>
第一行放弃参数 <literal>x</literal> 和 <literal>y</literal>，做成这样的调用：
<programlisting>
g(z, z, z) 
</programlisting>
whereas the second line discards arguments <literal>y</literal> and
<literal>z</literal>, and calls:<sbr/>
第二行放弃参数 <literal>y</literal> 和 <literal>z</literal>，调用：
<programlisting>
g(x, x, x)
</programlisting>
In earlier versions of the library, the latter line resulted in a compile 
time error.

This is basically a tradeoff between safety and flexibility, and the issue
was extensively discussed during the Boost review period of the library.
The main points for the <emphasis>strict arity</emphasis> checking
was that it might
catch a programming error at an earlier time and that a lambda expression that
explicitly discards its arguments is easy to write:<sbr/>
在库的早期版本中，后一行将导致一个编译时错误。这主要是安全性和灵活性之间的一个折衷，
而且这个问题在 Boost 库的评审期间引起广泛讨论。<emphasis>强数量</emphasis>
检查的主要观点在于它可以尽早捕捉到一个编程错误，而且一个 lambda 表达式显式放弃它的参数也很容易：
<programlisting>
(_3, bind(g, _1, _1, _1))(x, y, z);
</programlisting>
This lambda expression takes three arguments.
The left-hand argument of the comma operator does nothing, and as comma 
returns the result of evaluating the right-hand argument we end up with 
the call
<literal>g(x, x, x)</literal>
even with the strict arity.<sbr/>
这个 lambda 表达式持有三个参数。逗号操作符的左侧参数什么也不做，逗号返回右侧参数的求值结果，
这样我们就在强数量检查的情况下调用了 <literal>g(x, x, x)</literal>。
</para>

<para>
The main points against the strict arity checking were that the need to 
discard arguments is commonplace, and should therefore be straightforward, 
and that strict arity checking does not really buy that much more safety, 
particularly as it is not symmetric.
For example, if the programmer wanted to write the expression 
<literal>_1 + _2</literal> but mistakenly wrote <literal>_1 + 2</literal>, 
with strict arity checking, the complier would spot the error.
However, if the erroneous expression was <literal>1 + _2</literal> instead,
the error would go unnoticed.
Furthermore, weak arity checking simplifies the implementation a bit.
Following the recommendation of the Boost review, strict arity checking 
was dropped.<sbr/>
反对强数量检查的主要观点在于需要放弃参数是很平常的事情，因此应该是直截了当的，
而且强数量检查也没有真正换取多少安全性，特别是它不是对称的。例如，如果程序员想要写表达式 
<literal>_1 + _2</literal>，但是错写成 <literal>_1 + 2</literal>，如果有强数量检查，
编译器会发现这个错误。但是，如果错误表达式是 <literal>1 + _2</literal>，这个错误就不会被注意。
此外，弱数量检查的实现更简单。根据 Boost 审查的建议，强数量检查被去掉了。
</para>

</section>

</section>



<bibliography>

<biblioentry id="cit:stepanov:94">
<abbrev>STL94</abbrev>
<authorgroup>
<author>
<surname>Stepanov</surname>
<firstname>A. A.</firstname>
</author>
<author>
<surname>Lee</surname>
<firstname>M.</firstname>
</author>
</authorgroup>      
<title>The Standard Template Library</title>
<orgname>Hewlett-Packard Laboratories</orgname>
<pubdate>1994</pubdate>
<bibliomisc>
<ulink url="http://www.hpl.hp.com/techreports">www.hpl.hp.com/techreports</ulink>
</bibliomisc>
</biblioentry>

<biblioentry id="cit:sgi:02">
<abbrev>SGI02</abbrev>
<title>The SGI Standard Template Library</title>
<pubdate>2002</pubdate>
<bibliomisc><ulink url="http://www.sgi.com/tech/stl/">www.sgi.com/tech/stl/</ulink></bibliomisc>

</biblioentry>
    
<biblioentry id="cit:c++:98">
<abbrev>C++98</abbrev>
<title>International Standard, Programming Languages &ndash; C++</title>
<subtitle>ISO/IEC:14882</subtitle>
<pubdate>1998</pubdate>
</biblioentry>


<biblioentry id="cit:jarvi:99">
<abbrev>J鋜99</abbrev>

<articleinfo>
<author>
<surname>J鋜vi</surname>
<firstname>Jaakko</firstname>
</author>
<title>C++ Function Object Binders Made Easy</title>
</articleinfo>

<title>Lecture Notes in Computer Science</title>
<volumenum>1977</volumenum>
<publishername>Springer</publishername>

<pubdate>2000</pubdate>
</biblioentry>



<biblioentry id="cit:jarvi:00">
<abbrev>J鋜00</abbrev>
<author>
<surname>J鋜vi</surname>
<firstname>Jaakko</firstname>
</author>
<author>
<firstname>Gary</firstname>
<surname>Powell</surname>
</author>
<title>The Lambda Library : Lambda Abstraction in C++</title>
      <orgname>Turku Centre for Computer Science</orgname>
<bibliomisc>Technical Report </bibliomisc>
      <issuenum>378</issuenum>
<pubdate>2000</pubdate>
<bibliomisc><ulink url="http://www.tucs.fi/Publications/techreports/TR378.php">www.tucs.fi/publications</ulink></bibliomisc>


</biblioentry>


<biblioentry id="cit:jarvi:01">
<abbrev>J鋜01</abbrev>
<author>
<surname>J鋜vi</surname>
<firstname>Jaakko</firstname>
</author>
<author>
<firstname>Gary</firstname>
<surname>Powell</surname>
</author>
<title>The Lambda Library : Lambda Abstraction in C++</title>
      <confgroup>
	<conftitle>Second  Workshop on C++ Template Programming</conftitle>
	<address>Tampa Bay, OOPSLA'01</address>
      </confgroup>
<pubdate>2001</pubdate>
<bibliomisc><ulink url="http://www.oonumerics.org/tmpw01/">www.oonumerics.org/tmpw01/</ulink></bibliomisc>
</biblioentry>

<biblioentry id="cit:jarvi:03">
<abbrev>J鋜03</abbrev>

<articleinfo>

<author>
<surname>J鋜vi</surname>
<firstname>Jaakko</firstname>
</author>

<author>
<firstname>Gary</firstname>
<surname>Powell</surname>
</author>

<author>
<firstname>Andrew</firstname>
<surname>Lumsdaine</surname>
</author>
<title>The Lambda Library : unnamed functions in C++</title>

</articleinfo>

<title>Software - Practice and Expreience</title>
<volumenum>33:259-291</volumenum>


<pubdate>2003</pubdate>
</biblioentry>


<biblioentry id="cit:boost::tuple">
<abbrev>tuple</abbrev>
<title>The Boost Tuple Library</title>
<bibliomisc><ulink url="http://www.boost.org/libs/tuple/doc/tuple_users_guide.html">www.boost.org/libs/tuple/doc/tuple_users_guide.html</ulink>
</bibliomisc>
<pubdate>2002</pubdate>
</biblioentry>

<biblioentry id="cit:boost::type_traits">
<abbrev>type_traits</abbrev>
<title>The Boost type_traits</title>
<bibliomisc><ulink url="http://www.boost.org/libs/type_traits/index.htm">www.boost.org/libs/type_traits/</ulink>
</bibliomisc>
<pubdate>2002</pubdate>
</biblioentry>

<biblioentry id="cit:boost::ref">
<abbrev>ref</abbrev>
<title>Boost ref</title>
<bibliomisc><ulink url="http://www.boost.org/libs/bind/ref.html">www.boost.org/libs/bind/ref.html</ulink>
</bibliomisc>
<pubdate>2002</pubdate>
</biblioentry>

<biblioentry id="cit:boost::bind">
<abbrev>bind</abbrev>
<title>Boost Bind Library</title>
<bibliomisc><ulink url="http://www.boost.org/libs/bind/bind.html">www.boost.org/libs/bind/bind.html</ulink>
</bibliomisc>
<pubdate>2002</pubdate>
</biblioentry>

<biblioentry id="cit:boost::function">
<abbrev>function</abbrev>
<title>Boost Function Library</title>
<bibliomisc><ulink url="http://www.boost.org/libs/function/">www.boost.org/libs/function/</ulink>
</bibliomisc>
<pubdate>2002</pubdate>
</biblioentry>

<biblioentry id="cit:fc++">
<abbrev>fc++</abbrev>
<title>The FC++ library: Functional Programming in C++</title>
<author>
<surname>Smaragdakis</surname>
<firstname>Yannis</firstname>
</author>
<author>
<firstname>Brian</firstname>
<surname>McNamara</surname>
</author>
<bibliomisc><ulink url="http://www.cc.gatech.edu/~yannis/fc++/">www.cc.gatech.edu/~yannis/fc++/</ulink>
</bibliomisc>
<pubdate>2002</pubdate>
</biblioentry>


</bibliography>


</library>

[library Boost.Units
  [quickbook 1.3]
  [version 1.0.0]
  [authors [Schabel, Matthias C.]]
  [authors [Watanabe, Steven]]
  [copyright 2003-2008 Matthias Christian Schabel, 2007-2008 Steven Watanabe]
  [license
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      [@http://www.boost.org/LICENSE_1_0.txt])
  ]
  [purpose zero-overhead compile-time dimensional analysis and unit computations]
]

[def __boost_mpl [@http://www.boost.org/libs/mpl/doc/index.html Boost Metaprogramming Library]]

[def __mpl_forward_sequence [@http://www.boost.org/libs/mpl/doc/refmanual/forward-sequence.html MPL Forward Sequence]]

[def __ordinal [classref boost::units::ordinal ordinal]]
[def __dim [classref boost::units::dim dim]]
[def __static_rational [classref boost::units::static_rational static_rational]]
[def __make_dimension_list [classref boost::units::make_dimension_list make_dimension_list]]
[def __unit [classref boost::units::unit unit]]
[def __base_unit_info [classref boost::units::base_unit_info base_unit_info]]
[def __quantity [classref boost::units::quantity quantity]]
[def __conversion_helper [classref boost::units::conversion_helper conversion_helper]]
[def __absolute [classref boost::units::absolute absolute]]
[def __base_unit [classref boost::units::base_unit base_unit]]
[def __base_dimension [classref boost::units::base_dimension base_dimension]]
[def __scaled_base_unit [classref boost::units::scaled_base_unit base_unit]]
[def __make_scaled_unit [classref boost::units::make_scaled_unit make_scaled_unit]]

[def __unary_plus_typeof_helper [classref boost::units::unary_plus_typeof_helper unary_plus_typeof_helper]]
[def __unary_minus_typeof_helper [classref boost::units::unary_minus_typeof_helper unary_minus_typeof_helper]]
[def __add_typeof_helper [classref boost::units::add_typeof_helper add_typeof_helper]]
[def __subtract_typeof_helper [classref boost::units::subtract_typeof_helper subtract_typeof_helper]]
[def __multiply_typeof_helper [classref boost::units::multiply_typeof_helper multiply_typeof_helper]]
[def __divide_typeof_helper [classref boost::units::divide_typeof_helper divide_typeof_helper]]
[def __power_typeof_helper [classref boost::units::power_typeof_helper power_typeof_helper]]
[def __root_typeof_helper [classref boost::units::root_typeof_helper root_typeof_helper]]

[def __static_negate [classref boost::units::static_negate static_negate]]
[def __static_add [classref boost::units::static_add static_add]]
[def __static_subtract [classref boost::units::static_subtract static_subtract]]
[def __static_multiply [classref boost::units::static_multiply static_multiply]]
[def __static_divide [classref boost::units::static_divide static_divide]]
[def __static_power [classref boost::units::static_power static_power]]
[def __static_root [classref boost::units::static_root static_root]]

[def __get_dimension [classref boost::units::get_dimension get_dimension]]
[def __get_system [classref boost::units::get_system get_system]]

[def __pow [funcref boost::units::pow pow]]
[def __root [funcref boost::units::root root]]
[def __quantity_cast [funcref boost::units::quantity_cast quantity_cast]]

[def __from_value [memberref boost::units::quantity::from_value from_value]]
[def __value [memberref boost::units::quantity::value value]]

[def __reduce_unit [classref boost::units::reduce_unit reduce_unit]]
[def __unscale [classref boost::units::unscale unscale]]

[def __BOOST_UNITS_STATIC_CONSTANT [macroref BOOST_UNITS_STATIC_CONSTANT]]

[def __BOOST_UNITS_DEFINE_CONVERSION_FACTOR [macroref BOOST_UNITS_DEFINE_CONVERSION_FACTOR]]
[def __BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE [macroref BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE]]
[def __BOOST_UNITS_DEFAULT_CONVERSION [macroref BOOST_UNITS_DEFAULT_CONVERSION]]

[section:Introduction Introduction 简介]

The Boost.Units library is a C++ implementation of dimensional analysis in a general 
and extensible manner, treating it as a generic compile-time metaprogramming problem. With appropriate
compiler optimization, no runtime execution cost is introduced, facilitating the use of this library to
provide dimension checking in performance-critical code. Support for units
and quantities (defined as a unit and associated value) for arbitrary unit system models and arbitrary  
value types is provided, as is a fine-grained general facility for unit conversions. Complete SI and CGS unit 
systems are provided, along with systems for 
angles measured in degrees, radians, gradians, and revolutions and 
systems for temperatures measured in Kelvin, degrees Celsius and degrees Fahrenheit. 
The library architecture has been designed with flexibility and extensibility in mind; demonstrations of the ease
of adding new units and unit conversions are provided in the examples.\n
Boost.Units 库是将量纲分析当作一个泛型元编程问题而实现的一个通用可扩展的库。
通过合适的编译优化，没有运行时开销会被引入，这使其很适合应用在性能敏感的代码中实现量纲检查。 
单位和数量(定义为一个单位和相应的数字)可以应用于任意的单位系统，一个合适粒度的单位转换工具。
提供了完整的 SI 和 CGS 单位系统，还有以角度、弧度、gradians 和 revolutions 度量的角度系统和以开尔文、摄氏度和华氏度为单位的温度系统。
库的结构被设计得有很强的适应性和扩展性；所提供的添加新单位和单位转换的示例就可以说明这一点。 

In order to enable complex compile-time dimensional analysis calculations with no runtime overhead,
Boost.Units relies heavily on the [___boost_mpl] (MPL) and on template metaprogramming techniques, and is, as a consequence, 
fairly demanding of compiler compliance to ISO standards. At present, it has been successfully
compiled and tested on the following compilers/platforms :\n
为了实现这个复杂的、运行时零开销的编译期量纲分析，Boost.Units 非常依赖于 [___boost_mpl] (MPL) 和模板元编程技术。
其结果就是，只有符合ISO标准的编译器才可以使用。下面是一些测试成功通过的编译器和平台：

# g++ 4.0.1 on Mac OSX 10.4
# Intel CC 9.1, 10.0, and 10.1 on Mac OSX 10.4
# g++ 3.4.4, 4.2.3, and 4.3.0 on Windows XP
# Microsoft Visual C++ 7.1, 8.0, and 9.0 on Windows XP
# Comeau 4.3.10.1 beta2 on Windows XP
# Metrowerks CodeWarrior 9.2 on Windows XP.  
# Sun CC 5.9 on Solaris and Linux

The following compilers/platforms are known *not* to work :\n
下面是很不幸的已知不能成功使用的平台和编译器：

# g++ 3.3.x
# Microsoft Visual C++ 6.0 on Windows XP
# Microsoft Visual C++ 7.0 on Windows XP
# Metrowerks CodeWarrior 8.0 on Windows XP.
# All versions of Borland.

[endsect]

[section:Quick_Start Quick Start 快速入门]

Before discussing the basics of the library, we first define a few terms that will be used frequently
in the following :\n
在开始讨论这个库之前，我们先定义一些后面会经常用到的术语：

*  *Base dimension* : A base dimension is loosely defined as a measurable entity of interest; in conventional 
   dimensional analysis, base dimensions include length (\[L\]), mass (\[M\]), time (\[T\]), etc... but there is
   no specific restriction on what base dimensions can be used. Base dimensions are essentially a tag type and 
   provide no dimensional analysis functionality themselves.\n
   *基础量纲*：基础量纲被松散定义为可计量的实体；在分析量纲转换中，基础量纲包括长度(\[L\])，质量(\[M\])，时间(\[T\])等。
   但哪个被使用并没有限制。基础量纲只是必需的标签类型，本身并不提供量纲分析功能。
*  *Dimension* : A collection of zero or more base dimensions, each
   potentially raised to a different rational power. For example, area = \[L\]^2, velocity = \[L\]^1/\[T\]^1, and
   energy = \[M\]^1 \[L\]^2/\[T\]^2 are all dimensions.\n
   *量纲*：零或多个基础量纲的集合，每个基础量纲都有一个不同的有理数指数。
   例如，面积 = \[L\]^2，速度 = \[L\]^1/\[T\]^1，能量 = \[M\]^1 \[L\]^2/\[T\]^2，这些都是量纲。
*  *Base unit* : A base unit represents a specific measure of a dimension. For example, while length is an abstract measure of
   distance, the meter is a concrete base unit of distance.  Conversions are defined using base units.
   Much like base dimensions, base units are a tag type used solely to define units and do not support dimensional
   analysis algebra.\n
   *基础单位*：一个基础单位表示一个量纲的特定量度。例如，长度是距离的一个抽象的度量，而米是距离的一个具体的基础单位。
   转换是通过基础单位来进行定义的。就像基础量纲一样，基础单位也是一个标签类型，用来独立地定义单位，并且也不支持量纲分析代数。
*  *Unit* : A set of base units raised to rational exponents, e.g. kg^1 m^1/s^2.\n
   *单位*：一系列基础单位和有理数指数的集合，例如，kg^1 m^1/s^2。
*  *System* : A unit system is a collection of base units representing all the measurable entities of interest for a 
   specific problem. For example, the SI unit system defines seven base units : length (\[L\]) in meters, 
   mass (\[M\]) in kilograms, time (\[T\]) in seconds, current (\[I\]) in amperes, temperature (\[theta\]) in kelvin, 
   amount (\[N\]) in moles, and luminous intensity (\[J\]) in candelas. All measurable entities within the SI system can 
   be represented as products of various integer or rational powers of these seven base units.\n
   *系统*：一个单位系统是可以表达特定问题所有可度量实体的基础单位的集合。例如，SI单位系统定义了七个基础单位：
   长度(\[L\])使用米，质量(\[M\])使用千克，时间(\[T\])使用秒，电流(\[I\])使用安培，温度(\[theta\])使用开尔文，
   数量(\[N\])使用摩尔，亮度(\[J\])使用堪。SI系统的所有可计量实体都可以用这七个基础单位的不同有理数次方表示。
*  *Quantity* : A quantity represents a concrete amount of a unit. Thus, while the meter is the base 
   unit of length in the SI system, 5.5 meters is a quantity of length in that system.\n
   *量*：量表示一个单位的具体数量。也就是说，SI系统中米是长度的基础单位，5.5米是长度的量。

To begin, we present two short tutorials. [@../../libs/units/tutorial/tutorial_1.cpp Tutorial1] demonstrates the use of 
[@http://en.wikipedia.org/wiki/SI_units SI] units. After including the appropriate system headers 
and the headers for the various SI units we will need (all SI units can be included with  
[headerref boost/units/systems/si.hpp]) and for quantity I/O ([headerref boost/units/io.hpp]), we define 
a function that computes the work, in joules, done by exerting a force in newtons over a specified distance in meters 
and outputs the result to `std::cout`. The [___quantity] class accepts a second template parameter as its value type; 
this parameter defaults to
`double` if not otherwise specified. To demonstrate the ease of using user-defined types in dimensional
calculations, we also present code for computing the complex impedance using `std::complex<double>`
as the value type :\n
一上来，我们展示两个很短的教程。[@../../libs/units/tutorial/tutorial_1.cpp 教程1] 展示了对 [@http://en.wikipedia.org/wiki/SI_units SI］ 
单位的使用。包含了合适的系统和需要用的SI单位的头文件(所有的SI单位包含在 [headerref boost/units/systems/si.hpp] 中)和量的I/O 
([headerref boost/units/io.hpp])后，我们定义了一个函数来计算功，单位是焦耳，通过施加以牛顿为单位的力作用一段以米为单位的距离来计算，
并且将结果输出到 `std::cout`。[___quantity] 类的第二个模板参数作为它的值类型；这个参数默认是 `double`。 
为了展示在量纲计算中很容易使用用户自定义类型，我们使用 `std::complex<double>` 作为计算复数电阻的数值类型：

[import ../example/tutorial.cpp]

[tutorial_code]

The intent and function of the above code should be obvious; the output produced is :\n
上面代码的功能和作用是很明显的；输出如下：

[tutorial_output]

While this library attempts to make simple dimensional computations easy to code, it is in no way
tied to any particular unit system (SI or otherwise). Instead, it provides a highly flexible compile-time
system for dimensional analysis, supporting arbitrary collections of base dimensions, rational 
powers of units, and explicit quantity conversions. It accomplishes all of this via template metaprogramming techniques. With 
modern optimizing compilers, this results in zero runtime overhead for quantity computations relative to the 
same code without unit checking.\n
虽然Boost.Units库试图使得量纲计算简单，但并不会绑定到某个特定的单位系统(SI或其它)。 
相反，它提供了一个高度可伸缩的量纲分析的编译时系统，支持任意的基础量纲，有理数次方单位，显式的量值转换集合。
它通过使用模板元编程技术完成这一切。通过适当的优化，和没有单位检查比较，不会带来任何的运行时开销。

[endsect]

[section:Dimensional_Analysis Dimensional Analysis 量纲分析]

The concept of 
[@http://en.wikipedia.org/wiki/Dimensional_analysis dimensional analysis] 
is normally presented early on in introductory physics and engineering classes as a means of determining the  
correctness of an equation or computation by propagating the physical measurement
[@http://en.wikipedia.org/wiki/Units_of_measurement units]
of various quantities through the equation along with their numerical values. There are a number of standard 
unit systems in common use, the most prominent of which is the 
[@http://en.wikipedia.org/wiki/SI_units Systeme International] 
(also known as SI or MKS (meter-kilogram-second), which was a metric predecessor to the SI system named 
for three of the base units on which the system is based). The SI  
is the only official international standard unit system and is widely utilized in science and engineering. 
Other common systems include the [@http://en.wikipedia.org/wiki/Cgs_units CGS]
(centimeter-gram-second) system and the 
[@http://en.wikipedia.org/wiki/English_units English]
system still in use in some problem domains in the United States and elsewhere. In physics, 
there also exist a number of other systems that are in common use in specialized subdisciplines. These are 
collectively referred to as [@http://en.wikipedia.org/wiki/Natural_units natural units]. When 
quantities representing different measurables are combined, dimensional analysis provides the means of 
assessing the consistency of the resulting calculation. For example, the sum of two lengths is also a length, 
while the product of two lengths is an area, and the sum of a length and an area is undefined. The fact that the
arguments to many functions (such as exp, log, etc...) must be dimensionless quantities can be easily demonstrated by 
examining their series expansions in the context of dimensional analysis. This library facilitates the enforcement 
of this type of restriction in code involving dimensioned quantities where appropriate.\n
[@http://en.wikipedia.org/wiki/Dimensional_analysis 量纲分析] 的概念通常在物理和工程学上被引入，用来判断物理量 
[@http://en.wikipedia.org/wiki/Units_of_measurement 单位] 和数值在计算中的正确与否。
在日常使用中有很多标准的单位系统，其中最著名的就是 [@http://en.wikipedia.org/wiki/SI_units 国际单位制] 
(也被称为SI或MKS，SI单位之前公制系统的三个最基础单位)。SI是唯一一个官方的国际单位系统，广泛应用于科学和工程中。
另外一些常用系统，包括 [@http://en.wikipedia.org/wiki/Cgs_units CGS] (centimeter-gram-second) 和 
[@http://en.wikipedia.org/wiki/English_units English] 仍然被应用于美国和其它地区的一些问题领域中。 
在物理学领域中，仍然存在很多其他的单位系统被应用于特定的分支学科中。
它们被统称为 [@http://en.wikipedia.org/wiki/Natural_units natural units]。 
当表示不同度量的数值放在一起时，量纲分析提供了结果单位的一致性确定。
例如， 两个长度的和仍然是长度，而两个长度的乘积是面积，而长度和面积的和是没有意义的。 
许多函数(如exp，log等)的参数必须是无量纲的量，这可以很容易通过它们在量纲分析上下文中的指数来检测。
本库就提供了在代码中执行这种量纲分析约束的方便。

In the following discussion we view dimensional analysis as an abstraction in which an arbitrary set of 
[@http://en.wikipedia.org/wiki/Fundamental_units units] obey the rules of a specific algebra. 
We will refer to a pair of a base dimension and a rational exponent as a *fundamental dimension*, 
and a list composed of an arbitrary number of fundamental dimensions as a *composite dimension* or, simply,
*dimension*. In particular, given a set of [$../../libs/units/images/form_0.png] fundamental dimensions
denoted by [$../../libs/units/images/form_1.png] and a set of [$../../libs/units/images/form_0.png]
rational exponents [$../../libs/units/images/form_2.png], any possible (composite) dimension can be written
as [$../../libs/units/images/form_3.png].  \n
在下面的讨论中，我们看到量纲分析是在任意的符合特定代数规则的 [@http://en.wikipedia.org/wiki/Fundamental_units 单位] 上的一种抽象。 
下面我们将一个基础量纲和相应的有理数指数作为一个 *基本量纲*，任意数目的基本量纲的组合称为 *复合量纲*，或简称之为 *量纲*。
给定一组 [$../../libs/units/images/form_0.png] 个基本量纲，以 [$../../libs/units/images/form_1.png] 表示，
以及一组 [$../../libs/units/images/form_0.png] 个有理数指数 [$../../libs/units/images/form_2.png]，那么可能存在的(复合)量纲可以写成
[$../../libs/units/images/form_3.png]。

Composite dimensions obey the algebraic rules for dimensional analysis. In particular, for any scalar value,
[$../../libs/units/images/form_4.png], 
and composite dimensions [$../../libs/units/images/form_5.png]
and [$../../libs/units/images/form_6.png], where 
[$../../libs/units/images/form_7.png], we have:\n
复合量纲在量纲分析中遵循代数运算法则。具体地说，我们有一个标量，[$../../libs/units/images/form_4.png] 以及两个复合量纲 
[$../../libs/units/images/form_5.png] 和 [$../../libs/units/images/form_6.png]，其中 [$../../libs/units/images/form_7.png]，
我们可以得到：

[$../../libs/units/images/form_8.png]

Users of a dimensional analysis library should be able to specify an arbitrary list of base dimensions to 
produce a composite dimension. This potentially includes repeated tags. For example, 
it should be possible to express energy as [$../../libs/units/images/form_9.png], [$../../libs/units/images/form_10.png], 
[$../../libs/units/images/form_11.png], or any other permutation of mass, length, and time having aggregate exponents of 
1, 2, and -2, respectively.
In order to be able to perform computations on arbitrary sets of dimensions, 
all composite dimensions must be reducible to an unambiguous final composite dimension, which we will refer to as a 
*reduced dimension*, for which\n
量纲分析库的使用者应该可以任意指定一组基础量纲来生成一个复合量纲。 这可能会地包含潜在重复的标签。
例如，我们可以用 [$../../libs/units/images/form_9.png], [$../../libs/units/images/form_10.png], 
[$../../libs/units/images/form_11.png] 来表示能量，或任何其它质量、长度和时间的组合，只要它们的指数分别是1、2和-2。 
为了能够计算任意的量纲，所有的复合量纲必须能被归约到一个确定的最终的复合量纲，我们称其为 *归约量纲*，它有如下特点： 

# fundamental dimensions are consistently ordered\n
  其中的基本量纲被一致地排序 
# dimensions with zero exponent are elided. Note that reduced dimensions never have more than 
  [$../../libs/units/images/form_0.png] base dimensions, one for each distinct fundamental dimension, but may have fewer.\n
  以0为指数的量纲被忽略。一个归约量纲决不会有多于 [$../../libs/units/images/form_0.png] 
  个基础量纲，每一个对应不同的基本量纲，但可能少一些。

In our implementation, base dimensions are associated with tag types. As we will ultimately 
represent composite dimensions as typelists, we must provide some mechanism for  sorting
base dimension tags in order to make it possible to convert an arbitrary composite dimension
into a reduced dimension.  For this purpose, we assign a unique integer to each base dimension.
The [___base_dimension] class (found in [headerref boost/units/base_dimension.hpp]) uses the
curiously recurring template pattern (CRTP) technique to ensure that ordinals specified for
base dimensions are unique:\n
在我们的实现中，基础量纲被关联至标签类型。因为我们最后会使用 typelist 作为复合量纲，
我们必须提供一种机制来排序基础量纲使得任意的复合量纲最终可以被归为一个归约量纲。 
于是，我们为每个基础量纲指定一个唯一的整数。[___base_dimension] 类(定义于 [headerref boost/units/base_dimension.hpp])
使用CRTP技术来确保每个基础量纲的序数是不同的：

    template<class Derived, long N> struct base_dimension { ... };

With this, we can define the base dimensions for length, mass, and time as:\n
这样，我们就可以定义基础量纲了，如长度、质量、时间等：

[import ../example/test_system.hpp]
[test_system_snippet_1]

It is important to note that the choice of order is completely arbitrary as long as each tag has a unique enumerable
value; non-unique ordinals are flagged as errors at compile-time. Negative ordinals are reserved for use by the library.  
To define composite dimensions corresponding to the base dimensions, we
simply create MPL-conformant typelists of fundamental dimensions by using the [___dim] class to encapsulate pairs of base dimensions 
and [___static_rational] exponents.  The [___make_dimension_list] class acts as a wrapper to ensure
that the resulting type is in the form of a reduced dimension:\n
每个标签的顺序选择是任意的，只要唯一可以了；不唯一的序号会导致编译错误。负数的序号作为库的保留使用。 
为了根据基础量纲定义复合量纲，我们使用 [___dim] 类来封装基础量纲和相应的 [___static_rational] 指数，为基本量纲创建一个符合MPL的typelist。
[___make_dimension_list] 类作为一个外覆类用来保证结果的类型可以被归约为一个归约量纲： 

[test_system_snippet_2]

This can also be easily accomplished using a convenience typedef provided by [___base_dimension]:\n
这也可以用类 [___base_dimension] 提供的一个方便的 typedef 来完成：

[test_system_snippet_3]

so that the above code is identical to the full typelist definition. Composite dimensions are similarly defined via a typelist:\n
上面的代码和完整的typelist定义是一样的。复合量纲通过下面的typelist方式类似地定义：

[test_system_snippet_4]

A convenience class for composite dimensions with integer powers is also provided:\n
一个辅助类可以处理整数指数的复合量纲定义：

[test_system_snippet_5]

[endsect]

[section:Units Units 单位]

We define a *unit* as a set of base units each of which can be raised to an arbitrary rational
exponent.  Thus, the SI unit corresponding to the dimension of force is kg m s^-2, where kg, m,
and s are base units.  We use the notion of a *unit system* such as SI to specify the mapping
from a dimension to a particular unit so that instead of specifying the base units explicitly,
we can just ask for the representation of a dimension in a particular system.\n
我们把 *单位* 定义为一个基础单位的集合，其中各个基础单位可带有任意的有理数指数。 
例如，SI中力的单位是 kg m s^-2，其中 kg、m、s 都是基础单位。 
我们使用 *单位系统* (如SI)来表明从量纲到具体单位的映射，这样就不必总是明确指明基础单位，只是说明某个特定系统下的量纲就可以了。

Units are, like dimensions, purely compile-time variables with no associated value.
Units obey the same algebra as dimensions do; the presence of the unit system serves to ensure that units having identical
reduced dimension in different systems (like feet and meters) cannot be inadvertently mixed in computations.\n
单位和量纲一样，都是纯粹的编译时变量，并没有相关的值。单位同样遵循量纲的代数法则；
单位系统保证在不同系统中可以转换为相同归约量纲的单位(例如英尺和米)并不会在计算中被无意地混杂在一起。

There are two distinct types of systems that can be envisioned:\n
在想象中有两种不同类型的系统：

* *Homogeneous systems* : Systems which hold a linearly independent set of base units which
  can be used to represent many different dimensions. For example, the SI system has seven
  base dimensions and seven base units corresponding to them.  It can represent any unit which
  uses only those seven base dimensions.  Thus it is a homogeneous_system.\n
  *同构系统*：系统包含一系列线性无关的基础单位，可用来表示许多不同的量纲。例如，SI系统有7个基本量纳和7个相关的基础单位。 
  它可以使用这7个基本量纲表达任意单位。它就是一个同构系统。
* *Heterogeneous systems* : Systems which store the exponents of every base unit involved
  are termed heterogeneous.  Some units can only be represented in this way.  For example,
  area in m ft is intrinsically heterogeneous, because the base units of meters and feet
  have identical dimensions.  As a result, simply storing a dimension and a set of base
  units does not yield a unique solution.   A practical example of the need for heterogeneous
  units, is an empirical equation used in  aviation: H = (r/C)^2 where H is the radar beam
  height in feet and r is the radar range in nautical miles. In order to  enforce dimensional
  correctness of this equation, the constant, C, must be expressed in nautical miles per foot^(1/2),
  mixing two distinct base units of length.\n
  *异构系统*：保存了每个基础单位的指数的系统被称为异构的。某些单位只能用这种方式表示。
  例如，用m ft表示面积就是异构的，因为米和英尺这两个基础单位都对应同一个量纲。 
  其结果就是，只是简单地存储一个量纲和一系列基础单位并不能产生单一的解决方案。 
  一个需要异构单位的实际例子就是航空中的经验等式：H = (r/C)^2 其中H是雷达截面高度，单位是英尺，r是雷达范围，单位是海里。
  为了使这个等式的量纲正确，常数C的单位必须是 海里/英尺^(1/2)，混合了长度的两个不同的基础单位。

Units are implemented by the [___unit] template class defined in [headerref boost/units/unit.hpp] :\n
单位由定义在 [headerref boost/units/unit.hpp] 文件中的模板类 [___unit] 实现：

    template<class Dim,class System> class unit;

In addition to supporting the compile-time dimensional analysis operations, the +, -, *, and / runtime operators are provided
for [___unit] variables. Because the dimension associated with powers and roots must be computed at compile-time, it is not 
possible to provide overloads for `std::pow` that function correctly for [___unit]s. These operations are supported through 
free functions [___pow] and [___root] that are templated on integer and [___static_rational] values and can take as an argument 
any type for which the utility classes [___power_typeof_helper] and [___root_typeof_helper] have been defined.\n
为了支持编译时量纲分析，+、-、*、/等运行时操作符由 [___unit] 变量提供。 
因为乘方和开方的量纲必须在编译时计算，所以不太可能为 [___unit] 提供 `std::pow` 等函数的正确的重载。 
这些操作通过自由函数 [___pow] 和 [___root] 提供，这些函数都是基于整数和 [___static_rational] 的模板，并可以以工具类 
[___power_typeof_helper] 和 [___root_typeof_helper] 所定义的任意类型为参数。

[section:base_units Base Units 基础单位]

Base units are defined much like base dimensions.\n
基础单位的定义类似于基础量纲。 

    template<class Derived, class Dimensions, long N> struct base_unit { ... };

Again negative ordinals are reserved.\n
负数的序号再次被保留。

As an example, in the following we will implement a subset of the SI unit system based on the fundamental dimensions 
given above, demonstrating all steps necessary for a completely functional system. First, we simply define a unit system
that includes type definitions for commonly used units:\n
举个例子，下面我们将根据之前定义的基本量纲实现SI单位系统的一个子集，展示定义一个完整系统所必须的步骤。
首先，我们简单地定义一个单位系统包含常见单位的类型定义： 

[test_system_snippet_6]

The macro [___BOOST_UNITS_STATIC_CONSTANT] is provided in [headerref boost/units/static_constant.hpp] 
to facilitate ODR- and thread-safe constant definition in header files. We then define some constants for the supported units 
to simplify variable definitions:\n
宏 [___BOOST_UNITS_STATIC_CONSTANT] 定义于 [headerref boost/units/static_constant.hpp] 中，以方便地在头文件中实现 ODR- 
和线程安全的常量定义。我们接下来定义几个支持单位的常量来简化变量定义：

[test_system_snippet_7]

If support for textual output of units is desired, we can also specialize the [___base_unit_info] class for each fundamental 
dimension tag:\n
如果需要支持单位的文本输出，我们就要针对每个基本量纲标签来特化 [___base_unit_info] 类：

[test_system_snippet_8]

and similarly for `kilogram_base_unit` and `second_base_unit`. A future version of the library will provide a more flexible system
allowing for internationalization through a facet/locale-type mechanism. 
The `name()` and `symbol()` methods of [___base_unit_info] provide full and short names for the base unit. With these definitions, 
we have the rudimentary beginnings of our unit system, which can be used to determine reduced dimensions for arbitrary 
unit calculations.\n
`kilogram_base_unit` 和 `second_base_unit` 也是同样。未来的版本会通过 facet/locale-type 机制提供一个支持国际化的可伸缩系统。 
[___base_unit_info] 类的 `name()` 和 `symbol()` 方法提供了基础单位的全称和简称。 
通过这些定义，我们有了单位系统最基本的开始，能够为任意的单位运算提供归约量纲。

[endsect]

[section:scaled_base_units Scaled Base Units 成比例的基础单位]

Now, it is also possible to define a base unit as being a multiple of
another base unit.  For example, the way that `kilogram_base_unit` is
actually defined by the library is along the following lines\n
现在，我们有可能定义一个基础单位是另一个基础单位的倍数。例如，`kilogram_base_unit` 在库中就是下面这样定义的

    struct gram_base_unit : boost::units::base_unit<gram_base_unit, mass_dimension, 1> {};
    typedef scaled_base_unit<gram_base_unit, scale<10, static_rational<3> > > kilogram_base_unit;

This basically defines a kilogram as being 10^3 times a gram.\n
这里定义了千克是克的10^3倍。

There are several advantages to this approach.\n
这种做法有几种好处。

* It reflects the real meaning of these units better than treating them as independent units.\n
  它比孤立地处理单位要好，这样可以反应出这些单位的真实意义。
* If a conversion is defined between grams or kilograms and some other units,
  it will automatically work for both kilograms and grams, with only one specialization.\n
  如果克或者千克有一个与别的单位有转换关系，那么它会自动应用到克和千克两个上，只需要一个特化而已。
* Similarly, if the symbol for grams is defined as "g", then the symbol for kilograms
  will be "kg" without any extra effort.\n
  类似地，如果克的符号是 "g"，那么千克的符号就会自动被定义为 "kg"。 

[endsect]

[section:scaled_units Scaled Units 成比例的单位]

We can also scale a [___unit] as a whole, rather than scaling the individual
base units which comprise it.  For this purpose, we use the metafunction
[___make_scaled_unit].  The main motivation for this feature is the metric
prefixes defined in [headerref boost/units/systems/si/prefixes.hpp].\n
我们也可以直接为 [___unit] 定义比例，而不是为组合的每个基础单位定义比例。为了这个目的，我们可以使用元函数 [___make_scaled_unit]。 
这个特点主要的动机是为了定义在 [headerref boost/units/systems/si/prefixes.hpp] 文件中的公制前缀。 

A simple example of its usage would be.\n
一个简单用例如下。

    typedef make_scaled_unit<si::time, scale<10, static_rational<-9> > >::type nanosecond;

nanosecond is a specialization of [___unit], and can be
used in a quantity normally.\n
纳秒是一个特化的单位 [___unit]，可以像通常一样表示数量。 

    quantity<nanosecond> t(1.0 * si::seconds);
    std::cout << t << std::endl;    // prints 1e9 ns

[endsect]

[endsect]

[section:Quantities Quantities 数量]

A *quantity* is defined as a value of an arbitrary value type that is associated with a specific unit. For example,
while meter is a unit, 3.0 meters is a quantity. Quantities obey two separate algebras: the native algebra for their 
value type, and the dimensional analysis algebra for the associated unit. In addition, algebraic operations are defined
between units and quantities to simplify the definition of quantities; it is effectively equivalent to algebra with
a unit-valued quantity.\n
*数量* 被定义为一个任意值类型的数字和特定的单位。例如，米是一个单位，3.0米是一个数量。数量遵循两个独立的代数法则：
值类型本身的法则，和相关单位的量纲分析法则。另外，单位和数量之间定义了代数运算，用来简化数量的定义；这和unit-valued数量是相同的。

Quantities are implemented by the [___quantity] template class defined in [headerref boost/units/quantity.hpp] :\n
数量由定义在 [headerref boost/units/quantity.hpp] 中的模板类 [___quantity] 实现：

    template<class Unit,class Y = double> class quantity;

This class is templated on both unit type (`Unit`) and value type (`Y`), with the latter defaulting to double-precision
floating point if not otherwise specified.  The value type must have a normal copy constructor and copy
assignment operator.  Operators +, -, *, and / are provided for algebraic operations between 
scalars and units, scalars and quantities, units and quantities, and between quantities. In addition, integral and
rational powers and roots can be computed using the [___pow]<R> and [___root]<R> functions. Finally,  
the standard set of boolean comparison operators ( `==, !=,  <, <=, >, and >=` ) are provided to allow 
comparison of quantities from the same unit system.  All operators simply delegate to the
corresponding operator of the value type if the units permit.\n
这个类的模板参数为单位类型(`Unit`)和数值类型(`Y`)，数值类型默认为双精度符点数。数值类型必须有拷贝构造函数和赋值运算符。
+、-、*、和/运算符定义于标量和单位、标量和数量、单位和数量，以及数量和数量之间。 
另外，整数和有理数的乘方、开方可以用 [___pow]<R> 和 [___root]<R> 函数来计算。 
最后，标准的布尔比较运算符( `==, !=, <, <=, >, 和 >=` )提供同一个单位系统内的数量比较。 
所有的运算符在单位正确的情况下都会直接转发给相应的值类型的运算符。

[section:Heterogeneous_Operators Heterogeneous Operators 异构操作]

For most common value types, the result type of arithmetic operators is the same as the value type itself. For example, 
the sum of two double precision floating point numbers is another double precision floating point number. However, there 
are instances where this is not the case. A simple example is given by the [@http://en.wikipedia.org/wiki/Natural_number 
natural numbers] where the operator arithmetic obeys the following rules (using the standard notation for 
[@http://en.wikipedia.org/wiki/Number number systems]):\n
对于大多数值类型来说，算术运算的结果也是相同的值类型。例如，两个双精度浮点数的和同样是双精度浮点数。然而，也是有一些反例的。
比如说 [@http://en.wikipedia.org/wiki/Natural_number 自然数] 的算术运算就符合如下的规则(使用数字系统的标准符号)：

* [$../../libs/units/images/form_12.png]
* [$../../libs/units/images/form_13.png]
* [$../../libs/units/images/form_14.png]
* [$../../libs/units/images/form_15.png]

This library is designed to support arbitrary value type algebra for addition, subtraction, multiplication, division, and 
rational powers and roots.  It uses Boost.Typeof to deduce the result of these operators.  For compilers that
support `typeof`, the appropriate value type will be automatically deduced.  For compilers that do not provide
language support for `typeof` it is necessary to register all the types used.  For the case of natural numbers,
this would amount to something like the following:\n
Boost.Units 库被设计用来支持任意值类型 的加，减，乘，除，和有理数的乘方、开方。使用 Boost.Typeof 库来推断操作的结果类型。 
对于支持 `typeof` 的编译器，正确的值类型会被自动推断。对于不能为 `typeof` 提供语言支持的编译器，需要自行注册需要使用的类型。 
对于自然数来说，这意味着下面的事情：

    BOOST_TYPEOF_REGISTER_TYPE(natural);
    BOOST_TYPEOF_REGISTER_TYPE(integer);
    BOOST_TYPEOF_REGISTER_TYPE(rational);

[endsect]

[section:Conversions Conversions 转换]

Conversion is only meaningful for quantities as it implies the presence of at 
least a multiplicative scale factor and, possibly, and affine linear offset.
Macros for simplifying the definition of conversions between units can be found in
[headerref boost/units/conversion.hpp] and [headerref boost/units/absolute.hpp]
(for affine conversions with offsets). \n
转换只对数量有意义，它意味着至少一个乘法比例因子的存在，和仿射线性偏移的可能存在。 简化单位转换定义的宏可以在 
[headerref boost/units/conversion.hpp] 和 [headerref boost/units/absolute.hpp] (用于带偏移的仿射转换)中找到。

The macro [___BOOST_UNITS_DEFINE_CONVERSION_FACTOR] specifies a scale
factor for conversion from the first unit type to the second.  The
first argument must be a [___base_unit].  The second argument
can be either a [___base_unit] or a [___unit].\n
宏 [___BOOST_UNITS_DEFINE_CONVERSION_FACTOR] 定义了从第一个单位转换到第二个的比例因子。第一个参数必须是 [___base_unit]。 
第二个参数可以是 [___base_unit] 或 [___unit]。 

Let's declare a simple base unit:\n
我们定义一个简单的基础单位：

    struct foot_base_unit : base_unit<foot_base_unit, length_dimension, 10> { };

Now, we want to be able to convert feet to meters and vice versa.  The foot
is defined as exactly 0.3048 meters, so we can write the following\n
现在我们想要英尺和米之间的相互转换。一英尺被定义为0.3048米，于是我们这样写

    BOOST_UNITS_DEFINE_CONVERSION_FACTOR(foot_base_unit, meter_base_unit, double, 0.3048);

Alternately, we could use the SI length `typedef`:\n
或者，我们可以使用SI长度的 `typedef`：

    BOOST_UNITS_DEFINE_CONVERSION_FACTOR(foot_base_unit, SI::length, double, 0.3048);

Since the SI unit of length is the meter, these two definitions are equivalent.
If these conversions have been defined, then converting between
scaled forms of these units will also automatically work.\n
长度的SI单位是米，所以这两个定义是等价的。如果这些转换被定义了，那么从这些单位衍生的其它单位也可以自动地工作。

The macro [___BOOST_UNITS_DEFAULT_CONVERSION] specifies a conversion
that will be applied to a base unit when no direct conversion is
possible.  This can be used to make arbitrary conversions work
with a single specialization:\n
宏 [___BOOST_UNITS_DEFAULT_CONVERSION] 指明了当不存在直接转换时转换被应用到基础单位上。这可以只通过一个指明就使得任意的转换工作。

    struct my_unit_tag : boost::units::base_unit<my_unit_tag, boost::units::force_type, 1> {};
    // define the conversion factor
    BOOST_UNITS_DEFINE_CONVERSION_FACTOR(my_unit_tag, SI::force, double, 3.14159265358979323846);
    // make conversion to SI the default.
    BOOST_UNITS_DEFAULT_CONVERSION(my_unit_tag, SI::force);

[endsect]

[section:Quantity_Construction_and_Conversion Construction and Conversion of Quantities 数量的构造和转换]

This library is designed to emphasize safety above convenience when performing operations with dimensioned quantities.
Specifically, construction of quantities is required to fully specify both value and unit. Direct construction from a scalar value
is prohibited (though the static member function [___from_value] is provided to enable 
this functionality where it is necessary. In addition, a [___quantity_cast] to a reference allows direct access to the 
underlying value of a [___quantity] variable. An explicit constructor is provided to enable conversion between
dimensionally compatible quantities in different unit systems.  Implicit conversions between unit systems are
allowed only when the reduced units are identical, allowing, for example, trivial conversions between
equivalent units in different systems (such as SI seconds and CGS seconds) while simultaneously enabling
unintentional unit system mismatches to be caught at compile time and preventing potential loss of precision and
performance overhead from unintended conversions.  Assignment follows the same rules.
An exception is made for quantities for which the unit reduces to dimensionless; in this case, implicit conversion
to the underlying value type is allowed via class template specialization. Quantities of different value types are implicitly 
convertible only if the value types are themselves implicitly convertible. The [___quantity] class also defines
a `value()` member for directly accessing the underlying value.\n
Boost.Units 库被用来设计强调单位转换操作中的安全性。所以，数量的构造要求完全指定数值和单位。 
直接从标量数值构造数量是被禁止的(如果需要可以通过静态成员函数 [___from_value] 完成)。 
另外，[___quantity_cast] 应用于 [___quantity] 变量的引用之上可以直接读取其内部的数值。 
显式的构造函数可以从不同单位系统的兼容量纲的数量进行转换。在不同单位系统之间的隐式的转换只有当归约量纲一致时才可以进行，
不同单位系统之间等价单位的任意转换都是允许的(例如SI的秒和CGS的秒)，同时单位系统之间无意的不匹配会在编译时被捕获，
并且无意的精度损失和运行时开销都会被阻止。赋值运算也符合上面的规则。 当数量的单位被化简为无量纲是情况是不同的；
在这种情况下，内部的值类型之间的隐式转换是通过类模板的特化。不同值类型的数量之间只有当值类型可以隐式转换时才可以隐式转换。 
类 [___quantity] 也定义了成员函数 `value()` 来直接访问内部的数值。

To summarize, conversions are allowed under the following conditions :\n
总结一下，转换在如下情况下被允许：

* implicit conversion of `quantity<Unit,Y>` to `quantity<Unit,Z>` is allowed if `Y` and `Z` are implicitly convertible.\n
  当 `Y` 和 `Z` 可以隐式转换时，`quantity<Unit,Y>` 可以被隐式转换到 `quantity<Unit,Z>`。 
* assignment between `quantity<Unit,Y>` and `quantity<Unit,Z>` is allowed if `Y` and `Z` are implicitly convertible.\n
  当 `Y` 和 `Z` 可以隐式转换时，`quantity<Unit,Y>` 和 `quantity<Unit,Z>` 可以相互赋值。
* explicit conversion between `quantity<Unit1,Y>` and `quantity<Unit2,Z>` is allowed if `Unit1` and `Unit2` have the same dimensions
    and if `Y` and `Z` are implicitly convertible.\n
  当 `Unit1` 和 `Unit2` 拥有相同的量纲并且 `Y` 和 `Z` 可以隐式转换时，`quantity<Unit1,Y>` 和 `quantity<Unit2,Z>` 可以显式转换。
* implicit conversion between `quantity<Unit1,Y>` and `quantity<Unit2,Z>` is allowed if `Unit1` 
    reduces to exactly the same combination of base units as `Unit2` and if `Y` and `Z` are convertible.\n
  当 `Unit1` 和 `Unit2` 可以化简为相同的基础单位组合并且 `Y` 和 `Z` 可以转换时，`quantity<Unit1,Y>` 和 `quantity<Unit2,Z>` 可以隐式转换。
* assignment between `quantity<Unit1,Y>` and `quantity<Unit2,Z>` is allowed under the same
  conditions as implicit conversion.\n
  当可以隐式转换时，`quantity<Unit1,Y>` 和 `quantity<Unit2,Z>` 也可以相互赋值。
* `quantity<Unit,Y>` can be directly constructed from a value of type `Y` using the static member function [___from_value]. Doing so, 
  naturally, bypasses any type-checking of the newly assigned value, so this method should be used only when absolutely necessary.\n
  `quantity<Unit,Y>` 可以通过静态成员函数 [___from_value] 直接从值类型 `Y` 构造。 
  但这么做就跳过了所有的类型检查，所以只有当确实需要时才使用。

Of course, any time implicit conversion is allowed, an explicit conversion is
also legal.\n
当然，隐式转换可以时，显式转换都是可以的。

Because dimensionless quantities have no associated units, they behave as normal scalars, and allow implicit conversion to and from 
the underlying value type or types that are convertible to/from that value type.\n
无量纲数量没有相关的单位，它们和普通的标量一样，可以和内部数值类型之间进行隐式转换，或者其它可以和数值类型转换的类型。

[endsect]

[endsect]

[section:Examples Examples 示例]

[section:DimensionExample Dimension Example 量纲示例]

([@../../libs/units/example/dimension.cpp dimension.cpp])

By using MPL metafunctions and the template specializations for operations on composite dimensions
(defined in [headerref boost/units/dimension.hpp]) it is possible to perform compile time arithmetic
according to the dimensional analysis rules described [link boost_units.Dimensional_Analysis above]
to produce new composite dimensions :\n
在复合量纲(定义于 [headerref boost/units/dimension.hpp])
基础上通过MPL元函数和模板特化按照之前介绍的量纲分析法则执行编译时运算得到新的复合量纲： 

[import ../example/dimension.cpp]

[dimension_snippet_1]

outputting (with symbol demangling, implemented in [headerref boost/units/detail/utility.hpp])\n
通过在 [headerref boost/units/detail/utility.hpp] 中实现的符号重整后输出(下面的数字11、21应该是1、2，原文应该错了，译者注)

[dimension_output]

[endsect]

[section:UnitExample Unit Example 单位示例]

([@../../libs/units/example/unit.cpp unit.cpp])

This example demonstrates the use of the simple but functional unit system implemented in 
[headerref libs/units/example/test_system.hpp] :\n
这个例子展示了一个简单但实用的单位系统，在 [headerref libs/units/example/test_system.hpp] 中实现：

[import ../example/unit.cpp]

[unit_snippet_1]

We can perform various algebraic operations on these units, resulting in the following output:\n
我们可以在这些单位上执行很多代数运算，输出如下：

[unit_output]

[endsect]

[section:QuantityExample Quantity Example 数量示例]

([@../../libs/units/example/quantity.cpp quantity.cpp])

This example demonstrates how to use quantities of our toy unit system :\n
这个例子展示了如何在我们的单位系统上使用数量： 

[import ../example/quantity.cpp]

[quantity_snippet_1]

giving us the basic quantity functionality :\n
会有最基本的数量的功能：

[quantity_output_double]

As a further demonstration of the flexibility of the system, we replace the `double` value type 
with a `std::complex<double>` value type (ignoring the question of the meaningfulness of
complex lengths and energies) :\n
为了进一步展示系统的灵活性，我们把数值类型从 `double` 换成 `std::complex<double>` (请无视长度和能量的复数含义)： 

[quantity_snippet_2]

and find that the code functions exactly as expected with no additional work, delegating operations 
to `std::complex<double>` and performing the appropriate dimensional analysis :\n
这些代码只是把操作符转发给 `std::complex<double>` 类并执行了适当的量纲分析：

[quantity_output_complex]

[endsect]

[section:KitchenSinkExample Kitchen Sink Example ]

([@../../libs/units/example/kitchen_sink.cpp kitchen_sink.cpp])

This example provides a fairly extensive set of tests covering most of the [___quantity] functionality.
It uses the SI unit system defined in [headerref boost/units/systems/si.hpp].\n
这个例子为 [___quantity] 的功能提供了一个比较全面的测试，使用定义在 [headerref boost/units/systems/si.hpp] 中的SI单位系统。

If we define a few units and associated quantities,\n
我们定义几个单位和数量， 

[import ../example/kitchen_sink.cpp]

[kitchen_sink_snippet_1]

the various algebraic operations between scalars, units, and quantities give \n
这几个标量、单位和数量之间的代数运算结果是

[kitchen_sink_output_1]

Scalar/unit operations :\n
标量和单位之间的运算：

[kitchen_sink_output_2]

Unit/unit operations and integral/rational powers of units :\n
单位和单位之间的运算以及单位的整数/有理数乘方：

[kitchen_sink_output_3]

Scalar/quantity operations :\n
标量和数量之间的运算：

[kitchen_sink_output_4]

Unit/quantity operations :\n
单位和数量之间的运算：

[kitchen_sink_output_5]

Quantity/quantity operations and integral/rational powers of quantities :\n
数量和数量之间的运算以及数量的整数/有理数次乘方：

[kitchen_sink_output_6]

Logical comparison operators are also defined between quantities :\n
数量之间同样定义了逻辑比较运算：

[kitchen_sink_snippet_2]

giving\n
给出

[kitchen_sink_output_7]

Implicit conversion is allowed between dimensionless quantities and their corresponding value types :\n
无量纲数量和其数值类型之间可以隐式转换：

[kitchen_sink_snippet_3]

A generic function for computing mechanical work can be defined that takes force and distance arguments
in an arbitrary unit system and returns energy in the same system:\n
下面这个计算机械功的泛型函数接受任意单位系统的力和距离作为参数并返回相同系统的能量：

[kitchen_sink_function_snippet_3]

[kitchen_sink_snippet_4]

which functions as expected for SI quantities :\n
对于SI数量函数工作正确：

[kitchen_sink_output_9]

The ideal gas law can also be implemented in SI units :\n
理想气体定律同样可以用SI单位实现：

[kitchen_sink_function_snippet_4]

[kitchen_sink_snippet_5]

with the resulting output :\n
输出结果如下：

[kitchen_sink_output_10]

Trigonometric and inverse trigonometric functions can be implemented for any unit system
that provides an angular base dimension. For radians, these functions are found in 
[headerref boost/units/cmath.hpp] These behave as one expects, with trigonometric functions
taking an angular quantity and returning a dimensionless quantity, while the inverse trigonometric functions
take a dimensionless quantity and return an angular quantity :\n
三角函数和反三角函数也能在任意提供角度基础量纲的单位系统上实现。对于弧度，这些函数定义在 [headerref boost/units/cmath.hpp]。 
这些函数就像你想的那样，三角函数以弧度数量为参数返回一个无量纲数量，反三角函数以无量纲数量为参数返回一个弧度数量：

Defining a few angular quantities,\n
定义几个弧度数量，

[kitchen_sink_snippet_6]

yields\n
得到

[kitchen_sink_output_11]

Dealing with complex quantities is trivial. Here is the calculation of complex impedance :\n
复数的数量也是一样的。下面就是复数电阻的计算：

[kitchen_sink_snippet_7]

giving\n
给出

[kitchen_sink_output_12]

[section:UDT_Quantities User-defined value types 用户自定义的值类型]

User-defined value types that support the appropriate arithmetic operations are automatically supported
as quantity value types. The operators that are supported by default for quantity value types are unary plus, unary minus,
addition, subtraction, multiplication, division, equal-to, not-equal-to, less-than, less-or-equal-to, 
greater-than, and greater-or-equal-to. Support for rational powers and roots can be added by overloading
the [___power_typeof_helper] and [___root_typeof_helper] classes. Here we implement a user-defined `measurement`
class that models a numerical measurement with an associated measurement error and the appropriate algebra and
demonstrates its use as a quantity value type; the full code is found in [@../../libs/units/example/measurement.hpp measurement.hpp].\n
用户自定义的数值类型如果支持这些算术运算，就可以自动地支持数量的运算。 
数量的数值类型默认支持的运算有：取正、取负、加、减、乘、除、等于、不等于、小于、小于等于、大于和大于等于。 
支持有理数次乘方开方可以通过添加 [___power_typeof_helper] 和 [___root_typeof_helper] 
类的特化(原文为overload，但应该是特化，而不是重载，译者注)来实现。 
我们定义一个类 `measurement` 表示数字的度量，相关的度量错误和适当的代数运算，将它作为数量的数值类型；完整的代码请见 
[@../../libs/units/example/measurement.hpp measurement.hpp]。

Then, defining some `measurement` [___quantity] variables\n
然后定义一些 `measurement` [___quantity] 变量

[kitchen_sink_snippet_8]

gives\n
给出

[kitchen_sink_output_13]

If we implement the overloaded helper classes for rational powers and roots
then we can also compute rational powers of measurement quantities :\n
如果我们特化(overload，译者注)了乘方和开方的辅助类，就可以计算 `measurement` 数量的乘方了：

[kitchen_sink_output_14]

[endsect]

[endsect]

[section:ConversionExample Conversion Example 转换示例]

([@../../libs/units/example/conversion.cpp conversion.cpp])

This example demonstrates the various allowed conversions between SI and CGS units. Defining some
quantities\n
这个例子展示了SI和CGS单位之间的转换。先定义几个数量

[import ../example/conversion.cpp]

[conversion_snippet_1]

illustrates implicit conversion of quantities of different value types where implicit conversion 
of the value types themselves is allowed.  N.B. The conversion from double to int is treated
as an explicit conversion because there is no way to emulate the exact behavior of the built-in
conversion.  Explicit constructors allow conversions for two cases:\n
举例说明了当数值类型之间可以隐式转换的时候，数量才可以隐式转换。N.B. 从 double 到 int 
的转换是显式转换，因为没有办法模仿内置转换的准确行为。显式构造可以支持以下两种转换：

* explicit casting of a [___quantity] to a different `value_type` :\n
  显式将一个 [___quantity] 转换到不同的 `value type`： 

[conversion_snippet_3]

* and explicit casting of a [___quantity] to a different unit :\n
  显式将一个 [___quantity] 转换到不同的单位：

[conversion_snippet_4]

giving the following output :\n
给出以下输出：

[conversion_output_1]

A few more explicit unit system conversions :\n
几个单位系统之间的显式转换：

[conversion_snippet_5]

which produces the following output:\n
将产生以下输出：

[conversion_output_2]

[endsect]

[section:UDTExample User Defined Types 用户自定义类型]

([@../../libs/units/example/quaternion.cpp quaternion.cpp])

This example demonstrates the use of `boost::math::quaternion` as a value type for  [___quantity] and the converse.
For the first case, we first define specializations of [___power_typeof_helper] and [___root_typeof_helper] for 
powers and roots, respectively:\n
这个例子展示了使用 `boost::math::quaternion` 作为 [___quantity] 的数值类型以及反过来的情况。 
对于第一种情况，我们首先为乘方和开方定义 [___power_typeof_helper] 和 [___root_typeof_helper] 的特化 

[import ../example/quaternion.cpp]

[quaternion_class_snippet_1a]

[quaternion_class_snippet_1b]

We can now declare a [___quantity] of a `quaternion` :\n
现在我们可以声明一个 `quaternion` 的 [___quantity]：

[quaternion_snippet_1]

so that all operations that are defined in the `quaternion` class behave correctly. If rational
powers were defined for this class, it would be possible to compute rational powers and roots with
no additional changes. \n
现在，我们定义于类 `quaternion` 上的操作符都可以正确执行了。如果这个类定义了有理数乘方，那么就可以直接计算乘方和开方了。

[quaternion_output_1]

Now, if for some reason we preferred the [___quantity] to be the value type of the `quaternion` class we would have :\n
如果我们将 [___quantity] 作为 `quaternion` 的数值类型：

[quaternion_snippet_2]

Here, the unary plus and minus and addition and subtraction operators function correctly. Unfortunately, 
the multiplication and division operations fail because `quaternion` implements them in terms of the `*=` and 
`/=` operators, respectively, which are incapable of representing the heterogeneous unit algebra needed for 
quantities (an identical problem 
occurs with `std::complex<T>`, for the same reason). In order to compute rational powers and roots, we need to 
specialize [___power_typeof_helper] and [___root_typeof_helper] as follows:\n
现在，取正、取负、加和减的操作都是正确的。但不幸的是，乘和除失败了，因为 `quaternion` 是通过 `*=` 和 `/=` 实现的乘除。 
这不能满足数量的异构单位代数需要(同样的问题也出现在 `std::complex<T>` 上)。 
为了计算乘方和开方，我们需要特化 [___power_typeof_helper] 和 [___root_typeof_helper] ：

[quaternion_class_snippet_2a]

[quaternion_class_snippet_2b]

giving:\n
给出：

[quaternion_output_2]

[endsect]

[section:ComplexExample Complex Example 复数例子]

([@../../libs/units/example/complex.cpp complex.cpp])

This example demonstrates how to implement a replacement `complex` class that functions correctly both as a 
quantity value type and as a quantity container class, including heterogeneous multiplication and division 
operations and rational powers and roots. Naturally, heterogeneous operations are only supported on
compilers that implement `typeof`. The primary differences are that binary operations are not implemented
using the `op=` operators and use the utility classes [___add_typeof_helper], [___subtract_typeof_helper], 
[___multiply_typeof_helper], and [___divide_typeof_helper]. In addition, [___power_typeof_helper] and
[___root_typeof_helper] are defined for both cases :\n
这个例子展示了如何使用替代的 `complex` 类作为 `quantity` 的数值类型或 `quantity` 的存储类，包括异构的乘、除、乘方和开方。 
通常，异构的乘和除只有当编译器实现 `typeof` 的时候才被支持。 这些二元运算的主要差别在于不是使用 `op=` 操作符，而是使用工具类 
[___add_typeof_helper], [___subtract_typeof_helper], [___multiply_typeof_helper], 和 [___divide_typeof_helper]。 
另外，[___power_typeof_helper] 和 [___root_typeof_helper] 在两种情况下都会定义：

[import ../example/complex.cpp]

[complex_class_snippet_1]

With this replacement `complex` class, we can declare a complex variable :\n
使用这个替代的 `complex`，我们定义一个复数变量：

[complex_snippet_1]   

to get the correct behavior for all cases supported by [___quantity] with a `complex` value type :\n
能看到使用 `complex` 作为数值类型的 [___quantity] 支持的所有操作：

[complex_output_1]

and, similarly, `complex` with a [___quantity] value type \n
类似的，用 [___quantity] 作为数值类型的 `complex`：

[complex_snippet_2]

gives\n
给出

[complex_output_2]

[endsect]

[section:PerformanceExample Performance Example 性能示例]

([@../../libs/units/example/performance.cpp performance.cpp])

This example provides an ad hoc performance test to verify that zero runtime overhead 
is incurred when using [___quantity] in place of `double`. Note that performance 
optimization and testing is not trivial, so some care must be taken in profiling. It 
is also critical to have a compiler capable of optimizing the many template instantiations
and inline calls effectively to achieve maximal performance. Zero overhead for this test
has been verified using gcc 4.0.1, and icc 9.0, 10.0, and 10.1 on Mac OS 10.4 and 10.5, and
using msvc 8.0 on Windows XP.\n
这个例子展示了一个专门的性能测试来说明用 [___quantity] 代替 `double` 不会引入运行时开销。 
运行优化和测试不是微不足道的，所以在剖析时某些地方必须注意。编译器优化模板实例化的能力和内联调用的能力是很重要的。 
零开销已经在下面的编译器和平台上被证明了：gcc 4.0.1, icc 9.0, 10.0, 10.1 on Mac OS 10.4 及 10.5, 还有 msvc 8.0 on Windows XP。

[endsect]

[section:RadarBeamHeightExample Radar Beam Height 雷达截面高度]

([@../../libs/units/example/radar_beam_height.cpp radar_beam_height.cpp])

[import ../example/radar_beam_height.cpp]

This example demonstrates the implementation of two non-SI units of length, the 
nautical mile :\n
这个例子展示了两个非SI长度单位的实现，海里：

[radar_beam_height_class_snippet_1]

and the imperial foot :\n
和英制的尺：

[radar_beam_height_class_snippet_2]

These units include conversions between themselves and the meter. Three functions
for computing radar beam height from radar range and the local earth radius are 
defined. The first takes arguments in one system and returns a value in the same 
system :\n
这些单位和米之间都存在着转换关系。三个通过雷达范围和当地地球半径计算雷达截面高度的函数被定义了。 
第一个函数以一个单位系统为参数，返回同样单位系统的值：

[radar_beam_height_function_snippet_1]

The second is similar, but is templated on return type, so that the arguments are
converted to the return unit system internally :\n
第二个函数类似，只是将返回值模板化了，这样参数就在内部被转换为返回值的单位系统：

[radar_beam_height_function_snippet_2]

Finally, the third function is an empirical approximation that is only valid for
radar ranges specified in nautical miles, returning beam height in feet. This 
function uses the heterogeneous unit of nautical miles per square root of feet to
ensure dimensional correctness :\n
最后，第三个函数是一个经验公式，只有当雷达范围的单位是海里，返回的截面高度是英尺时才正确。 
这个函数使用了异构的单位，海里每英尺方根：

[radar_beam_height_function_snippet_3]

With these, we can compute radar beam height in various unit systems :\n
这样，我们可以用不同的单位系统来计算雷达截面高度：

[radar_beam_height_snippet_1]

giving\n
给出

[radar_beam_height_output]

[endsect]

[section:HeterogeneousUnitExample Heterogeneous Unit Example 异构单位示例]

([@../../libs/units/example/heterogeneous_unit.cpp heterogeneous_unit.cpp])

[import ../example/heterogeneous_unit.cpp]

Mixed units and mixed unit conversions.\n
混合单位及其转换。

This code:\n
以下代码：

[heterogeneous_unit_snippet_1]

gives\n
给出

[heterogeneous_unit_output_1]

Arbitrary conversions also work:\n
任意的转换也可以工作：

[heterogeneous_unit_snippet_2]

yielding\n
产生

[heterogeneous_unit_output_2]

[endsect]

[section:AbsoluteRelativeTemperatureExample Absolute and Relative Temperature Example 绝对与相对温度示例]

([@../../libs/units/example/temperature.cpp temperature.cpp])

[import ../example/temperature.cpp]

This example demonstrates using of absolute temperatures and relative temperature differences in Fahrenheit 
and converting between these and the Kelvin temperature scale. This issue touches on some surprisingly deep mathematical
concepts (see [@http://en.wikipedia.org/wiki/Affine_space Wikipedia] for a basic review), but for our purposes here, we
will simply observe that it is important to be able to differentiate between an absolute temperature measurement and a 
measurement of temperature difference. This is accomplished by using the [___absolute] wrapper class.\n
这个例子展示了使用绝对温度和华氏相对温度，以及与开尔文温度之间的转换。这部分会涉及到一些很深的数学概念(见 
[@http://en.wikipedia.org/wiki/Affine_space Wikipedia])，但对于我们来说，只是知道区分一个绝对的温度度量和温度差异度量是非常重要的。 
这是通过使用外覆类 [___absolute] 来实现的。

First we define a system using the predefined fahrenheit base unit:\n
首先，我们使用预定义的华氏基础单位来定义一个系统：

[temperature_snippet_1]

Now we can create some quantities:\n
然后创建一个数量：

[temperature_snippet_3]

Note the use of [___absolute] to wrap a unit. The resulting output is:\n
注意 [___absolute] 的使用。输出如下：

[temperature_output_1]

[endsect]

[section:RuntimeConversionFactorExample Runtime Conversion Factor Example 运行期转换的函数对象示例]

([@../../libs/units/example/runtime_conversion_factor.cpp runtime_conversion_factor.cpp])

[import ../example/runtime_conversion_factor.cpp]

The Boost.Units library does not require that the conversion factors be compile time constants,
as is demonstrated in this example:\n
Boost.Units 库并不要求转换因子是编译时常量，就像下面例子展示的：

[runtime_conversion_factor_snippet_1]

[endsect]

[section:UnitsWithNonbaseDimensions Units with Non-base Dimensions 无基础量纲的单位]

([@../../libs/units/example/non_base_dimension.cpp non_base_dimension.cpp])

[import ../example/non_base_dimension.cpp]

It is also possible to define base units that have derived rather than base dimensions:\n
同样可以不从基础量纲派生定义基础单位：

[non_base_dimension_snippet_1]

[endsect]

[section:OutputForCompositeUnits Output for Composite Units 复合单位的输出]

([@../../libs/units/example/composite_output.cpp composite_output.cpp])

[import ../example/composite_output.cpp]

If a unit has a special name and/or symbol, the free functions `name_string` and
`symbol_string` can be overloaded directly. \n
如果一个单位有特殊的名字和/或符号，自由函数 `name_string` 和 `symbol_string` 可以被直接重载。

[composite_output_snippet_1]

In this case, any unit that reduces 
to the overloaded unit will be output with the replacement symbol. \n
这样，任何可以化简到重载单位的单位输出都可以用这个替代符号。

Special names and symbols for the SI and CGS unit systems are found in 
[headerref boost/units/systems/si/io.hpp] and [headerref boost/units/systems/cgs/io.hpp], 
respectively. If these headers are not included, the output will simply follow
default rules using the appropriate fundamental dimensions. 
Note that neither of these functions is defined for quantities 
because doing so would require making assumptions on how the corresponding value
type should be formatted.\n
SI和CGS单位系统专门的名字和符号可以分别在 [headerref boost/units/systems/si/io.hpp] 和 
[headerref boost/units/systems/cgs/io.hpp] 文件中找到。如果这些头文件没有被包含，输出会简单地使用基本量纲的规则输出。 
这些函数都没有为数量定义，因为如果那么做的话就会要求假定相关的数值类型是如何输出的。

Three `ostream` formatters, `symbol_format`, `name_format`, and `typename_format`
are provided for convenience. These select the textual representation of units 
provided by `symbol_string` or `name_string` in the first two cases, while the
latter returns a demangled typename for debugging purposes. Formatting of scaled
unit is also done correctly.\n
三个 `ostream` 格式程序(`symbol_format`、`name_format` 和 `typename_format`)提供了方便。 
前两个使用 `symbol_string` 或 `name_string` 提供的字符串，后一个提供了调试用的重整过的类型定义。 
成比例单位同样能够被正确地格式化。

[endsect]

[section:ConversionFactor Conversion Factor 转换函数对象]

This code demonstrates the use of the `conversion_factor` free function to determine
the scale factor between two units.\n
这个例子展示了使用自由函数 `conversion_factor` 来确定两个单位之间的比例系数。

([@../../libs/units/example/conversion_factor.cpp conversion_factor.cpp])

[import ../example/conversion_factor.cpp]

[conversion_factor_snippet_1]

Produces\n
生成

[conversion_factor_output]

[endsect]

[section:RuntimeUnits Runtime Units 运行期单位]

([@../../libs/units/example/runtime_unit.cpp runtime_unit.cpp])

[import ../example/runtime_unit.cpp]

This example shows how to implement an interface that
allow different units at runtime while still maintaining
type safety for internal calculations.\n
这个例子展示了如何实现一个接口，能够在运行时接受不同的单位并维持类型安全和内部和计算。

[runtime_unit_snippet_1]

[endsect]

[section:lambda Interoperability with Boost.Lambda]

([@../../libs/units/example/lambda.cpp lambda.cpp])

[import ../example/lambda.cpp]

The header [headerref boost/units/lambda.hpp] provides overloads
and specializations needed to make Boost.Units usable with the
Boost.Lambda library.\n
头文件 [headerref boost/units/lambda.hpp] 中提供了 Boost.Units 被 Boost.Lambda 使用所需的重载和特化。

[lambda_snippet_1]

[endsect]

[endsect]

[section:Utilities Utilities 工具]

Relatively complete SI and CGS unit systems are provided in [headerref boost/units/systems/si.hpp] and
[headerref boost/units/systems/cgs.hpp], respectively. \n
相对完整的 SI 和 CGS 单位系统分别在 [headerref boost/units/systems/si.hpp] 和 [headerref boost/units/systems/cgs.hpp] 中提供。

[section:Metaprogramming_Classes Metaprogramming Classes 元编程的类]

    template<long N> struct ordinal<N>;

    template<typename T,typename V> struct get_tag< dim<T,V> >;
    template<typename T,typename V> struct get_value< dim<T,V> >;
    template<class S,class DT> struct get_system_tag_of_dim<S,DT>;
    template<typename Seq> struct make_dimension_list<Seq>;
    template<class DT> struct fundamental_dimension<DT>;
    template<class DT1,int E1,...> struct composite_dimension<DT1,E1,...>;

    template<class Dim,class System> struct get_dimension< unit<Dim,System> >;
    template<class Unit,class Y> struct get_dimension< quantity<Unit,Y> >;
    template<class Dim,class System> struct get_system< unit<Dim,System> >;
    template<class Unit,class Y> struct get_system quantity<Unit,Y> >;

    struct dimensionless_type;
    template<class System> struct dimensionless_unit<System>;
    template<class System,class Y> struct dimensionless_quantity<System,Y>;

    struct implicitly_convertible;
    struct trivial_conversion;
    template<class T,class S1,class S2> struct base_unit_converter<T,S1,S2>;

    template<class Q1,class Q2> class conversion_helper<Q1,Q2>;

[endsect]

[section:Metaprogramming_Predicates Metaprogramming Predicates 元编程的谓词]

    template<typename T,typename V> struct is_dim< dim<T,V> >;
    template<typename T,typename V> struct is_empty_dim< dim<T,V> >;

    template<typename Seq> struct is_dimension_list<Seq>;

    template<class S> struct is_system< homogeneous_system<S> >;
    template<class S> struct is_system< heterogeneous_system<S> >;
    template<class S> struct is_homogeneous_system< homogeneous_system<S> >;
    template<class S> struct is_heterogeneous_system< heterogeneous_system<S> >;

    template<class Dim,class System> struct is_unit< unit<Dim,System> >;
    template<class Dim,class System> struct is_unit_of_system< unit<Dim,System>,System >;
    template<class Dim,class System> struct is_unit_of_dimension< unit<Dim,System>,Dim >;

    template<class Unit,class Y> struct is_quantity< quantity<Unit,Y> >;
    template<class Dim,class System,class Y> struct is_quantity_of_system< quantity<unit<Dim,System>,Y>,System >;
    template<class Dim,class System,class Y> struct is_quantity_of_dimension< quantity<unit<Dim,System>,Y>,Dim >;

    template<class System> struct is_dimensionless< unit<dimensionless_type,System> >;
    template<class System> struct is_dimensionless_unit< unit<dimensionless_type,System> >;
    template<class System,class Y> struct is_dimensionless< quantity<unit<dimensionless_type,System>,Y> >;
    template<class System,class Y> struct is_dimensionless_quantity< quantity<unit<dimensionless_type,System>,Y> >; 

[endsect]

[endsect]

[section:Reference Reference 参考]

[xinclude units_reference.xml]

[xinclude dimensions_reference.xml]
[xinclude si_reference.xml]
[xinclude cgs_reference.xml]
[xinclude trig_reference.xml]
[xinclude temperature_reference.xml]
[xinclude abstract_reference.xml]

[section:base_units_by_category Base Units by Category 基础单位分类]

[xinclude angle_base_units_reference.xml]
[xinclude astronomical_base_units_reference.xml]
[xinclude cgs_base_units_reference.xml]
[xinclude imperial_base_units_reference.xml]
[xinclude metric_base_units_reference.xml]
[xinclude si_base_units_reference.xml]
[xinclude temperature_base_units_reference.xml]
[xinclude us_base_units_reference.xml]

[endsect]

[section:alphabetical_listing_of_base_units Alphabetical Listing of Base Units 基础单位按字母顺序列表]
[include base_units.qbk]
[endsect]

[endsect]

[section:Installation Installation 安装]

The core header files are located in `boost/units`. Unit system headers are 
located in `<boost/units/systems>`. There are no source files for the library
itself - the library is header-only. Example programs demonstrating various aspects of the library can be found in 
`boost/libs/units/example`. Programs for unit testing are provided in `boost/libs/units/test`.\n
核心头文件位于 `boost/units`。单位系统头文件位于 `<boost/units/systems>`。本库没有源文件 - 只有头文件。 
示例文件位于 `boost/libs/units/example`。单元测试程序位于 `boost/libs/units/test`。

[endsect]

[section:FAQ FAQ]

[section:Distinguishing_Quantities_With_Same_Units
How does one distinguish between quantities that are physically different but have the same units (such as 
energy and torque)? 
对于物理上不同但实际上拥有相同的单位的数量进行分析(例如能量和力矩)]

Because Boost.Units includes plane and solid angle units in the SI system, torque and energy 
are, in fact, distinguishable (see [@http://en.wikipedia.org/wiki/SI_units torque]). 
In addition, energy is a true
[@http://mathworld.wolfram.com/Scalar.html scalar] quantity, while torque, despite
having the same units as energy if plane angle is not included, is in fact a 
[@http://mathworld.wolfram.com/Pseudovector.html pseudovector]. Thus, a value type representing pseudovectors 
and encapsulating their algebra could also be implemented. \n
因为 Boost.Units 包含 SI 系统中平面和立体的角度单位，所以实际上，力矩和能量是可分辨的(见 
[@http://en.wikipedia.org/wiki/SI_units 力矩])。 实际上，能量是一个纯粹的 [@http://mathworld.wolfram.com/Scalar.html 标量]，
而力矩虽然如果不包含平面角度的话拥有与能量相同的单位，但实际上是 [@http://mathworld.wolfram.com/Pseudovector.html 伪矢量]。 
于是，一个表示伪矢量并封装其代数运算的数值类型是可以被实现的。

There are,
however, a few SI units that are dimensionally indistinguishable within the SI system. These
include the [@http://en.wikipedia.org/wiki/Becquerel becquerel], which has units identical to
frequency (Hz), and the [@http://en.wikipedia.org/wiki/Sievert sievert], which is degenerate
with the [@http://en.wikipedia.org/wiki/Gray_%28unit%29 gray]. In cases such as this, 
the proper way to treat this difference is to recognize that expanding the set of base dimensions
can provide disambiguation.  For example, adding a base dimension for radioactive decays would 
allow the becquerel to be written as decays/second, differentiating it from the signature of hertz,
which is simply 1/second.\n
确实是有一些 SI 单位的量纲是无法区分的。这其中包括 [@http://en.wikipedia.org/wiki/Becquerel 贝克]，和频率的单位是一样的(Hz)，又比如 
[@http://en.wikipedia.org/wiki/Sievert sievert]，是从 [@http://en.wikipedia.org/wiki/Gray_%28unit%29 gray] 退化而来的。 
这种情况下，对待这种差异的合适方法是识别和增加基础量纲来消除这种模棱两可的情况。 
例如，增加一种放射衰减的基础量纲可以使得贝克被写成decays/second，用来区分赫兹，1/second。

[endsect]

[section:Angle_Are_Units Angles are treated as units 角度被当成单位]

If you don't like this, you can just ignore the angle units and 
go on your merry way (periodically screwing up when a routine wants degrees and you give it 
radians instead...)\n
如果你不喜欢，就忽略它好了(当需要角度而你给了弧度的时候再想起好了...) 

[endsect]

[section:Why_Homogeneous_Systems Why are there homogeneous systems?  Aren't heterogeneous systems sufficient? 
为什么存在同构系统？异构系统不是足够了吗？]

Consider the following code:\n
考虑下面的代码：

    cout << sin(asin(180.0 * degrees));

What should this print?  If only heterogeneous
systems are available it would print 3.14159+ rad
Why?  Well, `asin` would return a `quantity<dimensionless>`
effectively losing the information that degrees
are being used.  In order to propogate this extra information
we need homogeneous systems.\n
应该打印什么呢？如果只有异构系统，那么应该打印3.14159+ rad，不是吗？`asin` 应该返回 `quantity<dimensionless>`，丢失了角度的信息。 
为了传递这个额外的信息我们需要同构系统。

[endsect]

[section:NoConstructorFromValueType Why can't I construct a quantity directly from the value type? 
为什么不能直接从数值类型构造数量]

This only breaks generic code--which ought to break anyway.  The only
literal value that ought to be converted to a quantity by generic code
is zero, which should be handled by the default constructor. In addition,
consider the search and replace problem allowing this poses:\n
这会中断泛型代码--本应该中断所有。泛型代码唯一接受的字面数值是0，被默认构造函数处理。另外，看一下下面的搜索和替换问题：

	quantity<si::length>    q(1.0);
	
Here, the intent is clear - we want a length of one in the SI system, which is one meter. However,
imagine some well-intentioned coder attempting to reuse this code, but to have it perform the
calculations in the CGS unit system instead. After searching for `si::` and replacing it with `cgs::` ,
we have:\n
意图很明显 - 我们需要一个SI系统的长度，也就是1米。但是，想象一下，当有人想用重用这段代码，但需要用CGS单位系统替代。 
用 `cgs::` 替换了 `si::` 以后：

	quantity<cgs::length>	q(1.0);
	
Unfortunately, the meaning of this statement has suddenly changed from one meter to one centimeter. In
contrast, as implemented, we begin with:\n
不幸的是，这段代码的意义变了，从1米变成了1分米。相反，就像现在实现的，我们这样写：

	quantity<si::length>	q(1.0*si::meter);
	
and, after search and replace:\n
经过搜索和替换后：

	quantity<cgs::length>	q(1.0*cgs::meter);
	
which gives us an error. Even if the code has a @using namespace boost::units::si; declaration, the latter
is still safe, with:\n
会有一个编译错误。即使是使用 @using namespace boost::units::si; 声明的代码，也是安全的：

	using namespace boost::units::si;
	quantity<length>	q(1.0*meter);
	
going to\n
改为

	using namespace boost::units::cgs;
	quantity<length>	q(1.0*meter);
	
The latter will involve an explicit conversion from meters to centimeters, but the value remains correct.\n
会导致一个从米到分米的显式转换，但值仍然是正确的。

[endsect]

[section:ExplicitConversions Why are conversions explicit by default? 为什么转换默认为显式的？]

Safety and the potential for unintended conversions leading to precision loss and hidden performance costs.
Options are provided for forcing implicit conversions between specific units to be allowed.\n
安全，防止无意间的精度损失，防止性能损失。提供选项使得特定单位之间的显式转换被允许。

[endsect]

[endsect]

[section:Acknowledgements Acknowledgements 鸣谢]

Matthias C. Schabel would like to acknowledge the Department of Defense for its support of this work under 
the Prostate Cancer Research Program New Investigator Award W81XWH-04-1-0042 and the National Institutes of Health for their
support of this work under the NIBIB Mentored Quantitative Research Development Award K25EB005077.

Thanks to David Walthall for his assistance in debugging and testing on a variety of platforms and Torsten Maehne for
his work on interfacing the Boost Units and Boost Lambda libraries.

Thanks to:

* Paul Bristow, 
* Michael Fawcett, 
* Ben FrantzDale, 
* Ron Garcia,
* David Greene,
* Peder Holt,
* Janek Kozicki, 
* Andy Little,
* Kevin Lynch,
* Torsten Maehne
* Noah Roberts,
* Andrey Semashev,
* David Walthall,
* Deane Yang, 

and all the members of the Boost mailing list who provided their input into 
the design and implementation of this library.

[endsect]

[section:HelpWanted Help Wanted 希望能得到的帮助]

 Any help in the following areas would be much appreciated:

* testing on other compilers and operating systems
* performance testing on various architectures
* tutorials 

[endsect]

[section:ReleaseNotes Release Notes 发布备注]

1.0.0 (August 1, 2008) :

* Initial release with Boost 1.36

0.7.1 (March 14, 2007) :

* Boost.Typeof emulation support
* attempting to rebind a heterogeneous_system to a different set of dimensions now fails.
* cmath.hpp now works with como-win32
* minor changes to the tests and examples to make msvc 7.1 happy

0.7.0 (March 13, 2007) :

* heterogeneous and mixed system functionality added
* added fine-grained implicit unit conversion on a per fundamental dimension basis
* added a number of utility metafunction classes and predicates
* [headerref boost/units/operators.hpp] now uses `BOOST_TYPEOF` when possible
* angular units added in [headerref boost/units/systems/trig.hpp] - implicit conversion
    of radians between trigonometric, SI, and CGS systems allowed
* a variety of [___unit] and [___quantity] tests added
* examples now provide self-tests

0.6.2 (February 22, 2007) :

*  changed template order in `unit` so dimension precedes unit system
*  added `homogeneous_system<S>` for unit systems
*  incorporated changes to [headerref boost/units/dimension.hpp] (compile-time sorting by predicate), 
   [headerref boost/units/conversion.hpp] (thread-safe implementation of quantity conversions), 
   and [headerref boost/units/io.hpp] (now works with any `std::basic_ostream`) by SW
* added abstract units in [headerref boost/units/systems/abstract.hpp] to allow abstract dimensional
  analysis
* new example demonstrating implementation of code based on requirements from 
  Michael Fawcett ([@../../libs/units/example/radar_beam_height.cpp radar_beam_height.cpp])

0.6.1 (February 13, 2007) :

* added metafunctions to test if a type is 
    * a valid dimension list (`is_dimension_list<D>`)
    * a unit (`is_unit<T>` and `is_unit_of_system<U,System>`)
    * a quantity (`is_quantity<T>` and `is_quantity_of_system<Q,System>`) 
* quantity conversion factor is now computed at compile time 
* static constants now avoid ODR problems
* unit_example_14.cpp now uses Boost.Timer
* numerous minor fixes suggested by SW

0.6.0 (February 8, 2007) :

* incorporated Steven Watanabe's optimized code for dimension.hpp, leading to *dramatic*
  decreases in compilation time (nearly a factor of 10 for unit_example_4.cpp in my tests).

0.5.8 (February 7, 2007) :

* fixed `#include` in [headerref boost/units/systems/si/base.hpp] (thanks to Michael Fawcett and 
  Steven Watanabe)
* removed references to obsolete `base_type` in [___unit_info] (thanks to Michael Fawcett)
* moved functions in [headerref boost/units/cmath.hpp] into `boost::units` namespace 
  (thanks to Steven Watanabe)
* fixed `#include` guards to be consistently named `BOOST_UNITS_XXX` (thanks to Steven 
  Watanabe)

0.5.7 (February 5, 2007) :

* changed quantity conversion helper to increase flexibility
* minor documentation changes
* submitted for formal review as a Boost library

0.5.6 (January 22, 2007) :

* added IEEE 1541 standard binary prefixes along with SI prefixes to and extended algebra of
  `scale` and `scaled_value` classes (thanks to Kevin Lynch)
* split SI units into separate header files to minimize the "kitchen sink" include problem
  (thanks to Janek Kozicki)
* added convenience classes for declaring fundamental dimensions and composite dimensions 
   with integral powers (`fundamental_dimension` and `composite_dimension` respectively)

0.5.5 (January 18, 2007) :

* template parameter order in `quantity` switched and default `value_type` of `double` added
  (thanks to Andrey Semashev and Paul Bristow)
* added implicit `value_type` conversion where allowed (thanks to Andrey Semashev)
* added `quantity_cast` for three cases (thanks to Andrey Semashev):
    * constructing `quantity` from raw `value_type`
    * casting from one `value_type` to another
    * casting from one `unit` to another (where conversion is allowed) 
* added` metre` and `metres` and related constants to the SI system for the convenience of
  our Commonwealth friends...

0.5.4 (January 12, 2007) :

* completely reimplemented unit conversion to allow for arbitrary unit conversions
  between systems
* strict quantity construction is default; quantities can be constructed from bare values 
  by using static member `from_value`

0.5.3 (December 12, 2006) :

* added Boost.Serialization support to `unit` and `quantity` classes
* added option to enforce strict construction of quantities (only constructible
  by multiplication of scalar by unit or quantity by unit) by preprocessor
  `MCS_STRICT_QUANTITY_CONSTRUCTION` switch

0.5.2 (December 4, 2006) :

* added `<cmath>` wrappers in the `std` namespace for functions that can support quantities 

0.5.1 (November 3, 2006) :

* converted to Boost Software License
* boostified directory structure and file paths

0.5 (November 2, 2006) :

* completely reimplemented SI and CGS unit systems and changed syntax for quantities
* significantly streamlined `pow` and `root` so for most applications it is only
  necessary to define `power_typeof_helper` and `root_typeof_helper` to gain this
  functionality
* added a selection of physical constants from the CODATA tables
* added a skeleton `complex` class that correctly supports both `complex<quantity<Y,Unit> >`
  and `quantity<complex<Y>,Unit>` as an example
* investigate using Boost.Typeof for compilers that do not support `typeof`

0.4 (October 13, 2006) : 

* `pow<R>` and `root<R>` improved for user-defined types
* added unary + and unary - operators
* added new example of interfacing with `boost::math::quaternion`
* added optional preprocessor switch to enable implicit unit conversions
  (`BOOST_UNITS_ENABLE_IMPLICIT_UNIT_CONVERSIONS`) 

0.3 (September 6, 2006) :

* Support for `op(X x,Y y)` for g++ added. This is automatically
  active when compiling with gcc and can be optionally enabled by defining the preprocessor
  constant `BOOST_UNITS_HAS_TYPEOF`

0.2 (September 4, 2006) : Second alpha release based on slightly modified code from 0.1 release

0.1 (December 13, 2003)  : written as a Boost demonstration of MPL-based dimensional analysis
in 2003.

[endsect]

[section:TODO TODO]

* Document concepts
* Implementation of I/O is rudimentary; consider methods of i18n using facets
* Consider runtime variant, perhaps using overload like `quantity<runtime,Y>`

[endsect]

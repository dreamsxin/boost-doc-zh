<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Filesystem Reference</title>

<link rel="stylesheet" type="text/css" href="../../../doc/html/minimal.css"></head>
<body>
<table style="border-collapse: collapse;" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0" width="710">
<tbody>
<tr>
<td width="277"> <a href="../../../index.htm">
<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" border="0" height="86" width="277"></a></td>
<td align="center" width="410"> <font size="7">Filesystem 库</font> </td>
</tr>
</tbody>
</table>
<table style="border-collapse: collapse;" bgcolor="#d7eeff" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">
<tbody>
<tr>
<td><a href="../../../index.htm">Boost Home</a>&nbsp;&nbsp;&nbsp;
<a href="index.htm">Library Home</a>&nbsp;
&nbsp; <a href="index.htm#tutorial">Tutorial</a>&nbsp;
&nbsp; <a href="reference.html"> Reference</a>&nbsp;&nbsp;
<a href="faq.htm">FAQ</a></td>
</tr>
</tbody>
</table>
<h1>参考文档</h1>
<h2><a name="TOC">目录</a></h2>
<table style="border-collapse: collapse;" border="0" bordercolor="#111111" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td valign="top" width="26%"><a href="#Introduction">简介</a><br>
<a href="#Definitions">定义</a><br>
<a href="#Requirements">要求</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Requirements-on-programs">对
程序的要求</a><br>
&nbsp; &nbsp; <a href="#Requirements-on-implementations">对
实现的要求</a><br>
<a href="#Header-filesystem-synopsis">头文件
&lt;filesystem&gt; 概要</a><br>
<a href="#Path-traits">Path traits</a><br>
<a href="#Class-template-basic_path">类模板 basic_path</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Pathname-formats">路
径名格式</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Pathname-grammar">路
径名语法</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Filename-conversion">文
件名转换</a><br>
&nbsp;&nbsp;&nbsp; <a href="#basic_path-requirements">要
求</a> </td>
<td valign="top" width="35%">&nbsp;类模板
basic_path (续)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-requirements">basic_path 构造函数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-assignments">basic_path 赋值</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-modifiers">basic_path 修改器</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-inserter-extractor">basic_path
操作符</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-observers">basic_path 观察器</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-iterators">basic_path 迭代器</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-non-member-functions">basic_path
非成员函数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_path-inserter-extractor">basic_path
插入器和提取器</a><span style="background-color: rgb(255, 255, 255);"><br>
</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Class-template-basic_filesystem_error">类模板
basic_filesystem_error</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_filesystem_error-constructors">basic_filesystem_error
构造函数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_filesystem_error-observers">basic_filesystem_error
观察器</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Class-template-basic_directory_entry">类模板
basic_directory_entry</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_directory_entry-constructors">basic_directory_entry
构造函数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_directory_entry-modifiers">basic_directory_entry
修改器</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_directory_entry-observers">basic_directory_entry
观察器</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_directory_entry-comparisons">basic_directory_entry
比较操作</a></td>
<td valign="top" width="89%">Filesystem 库 (续)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Class-template-basic_directory_iterator">类模板
basic_directory_iterator</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#basic_directory_iterator-constructors">basic_directory_iterator
构造函数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Class-template-basic_recursive_directory_iterator">类模板
basic_recursive_directory_iterator</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#file_status">类 file_status</a><br>
<a href="#Non-member-functions"> 非成员操作函数</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Status-functions">状
态函数</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Predicate-functions">谓
词函数</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Attribute-functions">属
性函数</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Operations-functions">其
它操作函数</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Convenience-functions">便
利函数</a><br>
<a href="#header-fstream">对头文件
&lt;fstream&gt; 的增加</a><br>
<a href="#Suggestions-for-fstream">对 <code>&lt;fstream&gt;</code>
实现的建议</a><br>
<a href="#Path-decomposition-table">路径分解表</a><br>
<a href="#Acknowledgements">鸣谢</a><br>
<a href="#References">参考</a><br>
&nbsp;</td>
</tr>
</tbody>
</table>
<p><i>本库早期版本中的有些函数已经改名或不再使用。请见 <a href="index.htm#Deprecated-names">不再使用的名称和特性</a>。</i></p><h2><a name="Introduction">简介</a></h2>
<p>本库的有些行为是通过引用 ISO/IEC 9945:2003, <i>
<a href="http://www.unix.org/single_unix_specification/">POSIX</a></i>
来规定的。这些行为如何实现则并没有规定。</p>
<blockquote>
<p>[<i>注：</i>这为与操作系统相关的行为的实现制定了一个"类似"规则。大概这些实现通常都会调用
原生的操作系统API. <i>--注完</i>]</p>
</blockquote>
<p>实现被鼓励，但不要求，支持 <i>POSIX</i> 所定义的行为。实现应该对与 <i>POSIX</i>
定义的行为有所不同的行为给出文档说明。实现如果由于操作系统和文件系统的局限，而不能支持精确的 <i>POSIX</i>
行为，则应尽量提供接近 <i>POSIX</i>
的合理行为。如果一个实现不能提供任何合理的行为，该实现应该以实现定义的方式报告一个错误。</p>
<blockquote>
<p>[<i>注：</i>这类错误可能通过一个 #error 指示, 一个 <code>
static_assert</code>, 一个 <code>basic_filesystem_error</code>
异常, 一个特定的返回值，或其它方式来报告。<i>--注完</i>]</p>
</blockquote>
<p>特定的操作系统，如 <i>OpenMVS</i>,
<i>UNIX</i>, 和 <i>Windows</i>
仅在示范或给出实现指导时提及。不提及其它操作系统是有意的。</p>
<p>在本参考手册中给出的函数的 <i>效果</i> 和 <i>后置条件</i>
可能不适用于 <a href="#Race-condition">竞争条件</a>
的情形。这类诊断并不被要求。</p>
<p>如果可能存在竞争条件，使得程序在调用函数之前测试某个前提条件变得不可靠，则不指定这样的 <i>
Requires</i>. 反之，这些条件被指定为 <i>Throws</i> 条件。</p>
<blockquote>
<p>[<i>注：</i>作为一个设计实践，如果要求一个程序在调用函数之前检查前提条件是不合理的，则这些
前提条件不会被规定。<i>
-- 注完</i>]</p>
</blockquote>
<h3><a name="Definitions">定义</a></h3>
<p>在本参考手册中，使用了以下定义：</p>
<p><i><a name="File">文件：</a></i>一个对
象，可以写入、读出或两者俱可。文件具有确定的属性，包括类型。文件类型包括有：普通文件、符号链接和目录。实现还可能支持其它文件类型。</p>
<p><i><a name="File-system">文件系统：</a></i>一
组文件和它们的属性。</p>
<p><i><a name="Filename">文件名：</a></i>文
件的名字。其格式由 <i>POSIX
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_169">文
件名Filename</a></i> 基本定义所指定。</p>
<p><i><a name="Path">路径：</a></i>一组元
素序列，用以标识文件系统中的某个位置。这些元素是 <i>root-name</i>, <i>
root-directory</i>, 以及各个连续的<i>文件名</i>。请见
<a href="#Pathname-grammar">路径名语法</a>。</p>
<p><i><a name="Pathname">路径名：</a></i>表
示一个路径的一个字符串。</p>
<p><i><a name="Link">链接：</a></i>一个目
录项对象，它关联某个文件的文件名。在某些文件系统中，多个目录项可以关联同一个文件名。</p>
<p><i><a name="Hard-link">硬链接：</a></i>到
一个已有文件的链接。有些文件系统支持同一个文件的多个硬链接。如果最后一个硬链接被删除，则文件本身被删除。</p>
<blockquote>
<p>[<i>注：</i>硬链接可以被视为一个文件的所有权共享智能指针<span style="font-style: italic;">。</span><i>-- 注完</i>]<i>
</i></p>
</blockquote>
<p><i><a name="Symbolic-link">符号链接：</a></i>一
种文件类型，在路径名解析过程中使用，文件中保存的字符串被用于修改路径名的解析。</p>
<blockquote>
<p>[<i>注：</i>符号链接可以被视为一个文件的原始指针。如果被指向的文件不存在，则该符号链接被称
为 "悬空" 的符号链接<span style="font-style: italic;">。</span><i>--
注完</i>]<i> </i></p>
</blockquote>
<p><i><a name="Slash">斜线符</a>:</i>
字符 <tt>'/'</tt>, 也称为斜线分隔符。</p>
<p><i><a name="Dot">点符</a>:</i> 字符
'.', 也称为句点。</p>
<p><i><a name="Race-condition">竞争条件：</a></i>当
多个线程、进程或计算机交错访问和修改文件系统中的同一个对象时发生的情形。</p>
<h3><a name="Requirements">要求</a></h3>
<h4><a name="Requirements-on-programs">对程序的要求</a></h4>
<p>在本文中名为 <code>Path</code>, <code>Path1</code>,
或 <code>Path2</code> 的模板参数都应为类型 <code>basic_path</code>,
或是派生自 <code>basic_path</code> 一某个类，除非特别说明。</p>
<h4><a name="Requirements-on-implementations">对实现的要求</a></h4>
<p>在本文中，有些函数模板具有名为 <code>Path</code>, <code>Path1</code>,
或 <code>Path2</code> 的模板参数。当以类型为 <code>char*</code>
或 <code>
std::string</code> 的参数 <code>s</code>
来调用这些函数时，实现应将这个参数视作为 <code>path(s)</code>. 当以类型为 <code>wchar_t*</code>
或 <code>std::wstring</code> 的参数 <code>s</code>
来调用这些函数时，<code></code>实现应将这个参数视作为 <code>wpath(s)</code>.
对于带两个参数的函数，实现不应支持将 <code>Path1</code> 和 <code>Path2</code>
作为不同类型来处理。</p>
<blockquote>
<p>[<i>注：</i>这个 "do-the-right-thing" 规则允许用户写象 <code>exists("foo")</code>
这样的代码，利用类 <code>basic_path</code> 的字符串转换构造函数，而不需要写又长又容易出错的
<code>exists(path("foo"))</code>.
这对于编写简单、类似于脚本的程序尤其重要，这也正是本库的一个主要应用。以不同类型的两个参数来调用函数的情况非常罕见，很可能是代码错误，所以这种情
形下的自动转换是不被支持的。</p>
<p>实现的技术并不特别规定。以 <code>exists()</code>
为例，以下是一种可能的实现技术：</p>
<blockquote>
<pre>template &lt;class Path&gt;<br> typename boost::enable_if&lt;is_basic_path&lt;Path&gt;,bool&gt;::type exists(const Path&amp; p);<br>inline bool exists(const path&amp; p) { return exists&lt;path&gt;(p); }<br>inline bool exists(const wpath&amp; p) { return exists&lt;wpath&gt;(p); }</pre>
</blockquote>
<p>对于C字符串或 <code> std::basic_string</code> 参数，<code>enable_if</code>
将会失败，这样就会通过适当的 <code>basic_path</code> 转换构造函数自动转换为 <code>basic_path</code>
对象。<i>-- 注完</i>]</p>
<p><span style="background-color: rgb(224, 224, 224);"><i>这
两个重载没有在正式文本中给出，是因为：</i></span></p>
<ul>
<li><span style="background-color: rgb(224, 224, 224);"><i>可
能会有更好的方法达到这一效果，如通过核心语言实现对 Concepts 的支持。</i></span></li>
<li><span style="background-color: rgb(224, 224, 224);"><i>实
现可能会选用其它技术，以便用于那些不支持 enable_if 的旧编译器。</i></span></li>
<li><span style="background-color: rgb(224, 224, 224);"><i>清
楚说明这些重载会使得文本更长，更难以阅读，而没有增加任何好处。</i></span></li>
<li><span style="background-color: rgb(224, 224, 224);"><i>对
于 char16_t 和 char32_t 可能需要更多的重载(或者规定它们不允许调用)，每一个都要讲清楚就更麻烦了。 </i></span>
</li>
</ul>
</blockquote>
<p>本文中的函数的实现可以调用由操作系统系统提供的API. 如果调用这些操作系统API产生了错误，则实现应通过抛出 <code>basic_filesystem_error</code>
异常来报告错误，除非特别说明。</p>
<blockquote>
<p>[<i>注：</i>这些异常及其抛出条件不会在本文的每一个 <i>Throws</i>
单元中说明。因为在文件系统操作中，硬件错误、网络失败、竞争条件和其它多种错误都会常常发生，用户应该知道，除非特别说明，任何的文件系统操作，无论看
起来多么没有危险，都可能会抛出异常。<i>-- 注完</i>]</p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);">对
于那些常常用在错误不被视为异常的环境中的函数，都有其它重载，接受一个额外的参数 </span><code><span style="background-color: rgb(255, 255, 255);">error_code&amp;
ec</span></code><span style="background-color: rgb(255, 255, 255);">.
这些函数重载不抛出异常。如果发生了错误，<code>ec</code> 将被设置为操作系统所报告的错误码，否则 <code>ec</code>
被设为 0. 如果没有类型 </span><code>
<span style="background-color: rgb(255, 255, 255);">error_code&amp;
ec</span></code><span style="background-color: rgb(255, 255, 255);"> 参数的重载是返回 void
的，则另一个重载(带有类型 </span><code>
<span style="background-color: rgb(255, 255, 255);">error_code&amp;
ec</span></code><span style="background-color: rgb(255, 255, 255);"> 参数的)将返回一个 <code>
error_code</code>，值为 ec.</span></p>
<h3><a name="Header-filesystem-synopsis">头文件 <code>&lt;boost/filesystem&gt;</code>
概要</a></h3>
<pre>  namespace boost<br>  {<br>    namespace filesystem<br>    {<br>      template &lt;class String, class Traits&gt; class <a href="#Class-template-basic_path">basic_path</a>;<br><br>      template&lt;class String, class Traits&gt;<br>      void swap(basic_path&lt;String, Traits&gt; &amp; lhs, basic_path&lt;String, Traits&gt; &amp; rhs);<br><br>      template&lt;class String, class Traits&gt; bool operator&lt;(<i>a</i> a, <i>b</i> b);<br>      template&lt;class String, class Traits&gt; bool operator==(<i>a</i> a, <i>b</i> b);<br>      template&lt;class String, class Traits&gt; bool operator!=(<i>a</i> a, <i>b</i> b);<br>      template&lt;class String, class Traits&gt; bool operator&gt;(<i>a</i> a, <i>b</i> b);<br>      template&lt;class String, class Traits&gt; bool operator&lt;=(<i>a</i> a, <i>b</i> b);<br>      template&lt;class String, class Traits&gt; bool operator&gt;=(<i>a</i> a, <i>b</i> b);<br>      template&lt;class String, class Traits&gt; bool operator/(<i>a</i> a, <i>b</i> b);<br><br>      template&lt;class Path&gt;<br>        basic_ostream&lt;typename Path::string_type::value_type, typename Path::string_type::traits_type&gt; &amp;<br>          operator&lt;&lt;(basic_ostream&lt;typename Path::string_type::value_type, typename Path::string_type::traits_type&gt;&amp; os, const Path &amp; ph);<br><br>      template&lt;class Path&gt;<br>        basic_istream&lt;typename Path::string_type::value_type, typename Path::string_type::traits_type&gt; &amp;<br>          operator&gt;&gt;(basic_istream&lt;typename Path::string_type::value_type, typename Path::string_type::traits_type&gt;&amp; is, Path &amp; ph);<br>      <br>      struct path_traits;<br>      struct wpath_traits;<br><br>      typedef basic_path&lt;std::string, path_traits&gt;    path;<br>      typedef basic_path&lt;std::wstring, wpath_traits&gt;  wpath;<br><br>      template&lt;class Path&gt; struct is_basic_path;<br><br>      template&lt;class Path&gt; struct slash { static const char value = '/'; };<br>      template&lt;class Path&gt; struct dot   { static const char value = '.'; };<br><span style="background-color: rgb(255, 255, 255);">      template&lt;class Path&gt; struct colon { static const char value = ':'; };</span><span style="background-color: rgb(255, 255, 0);"><br></span><br>      <span style="background-color: rgb(255, 255, 255);">class filesystem_error;</span><span style="background-color: rgb(255, 255, 0);"><br></span>      <br>      template &lt;class Path&gt; class <a href="#Class-template-basic_filesystem_error">basic_filesystem_error</a>;<br><br>      typedef basic_filesystem_error&lt;path&gt; filesystem_error;<br>      typedef basic_filesystem_error&lt;wpath&gt; wfilesystem_error;<br><br>      <span style="background-color: rgb(255, 255, 255);">template &lt;class Path&gt; class <a href="#Class-template-basic_directory_entry">basic_directory_entry</a>;<br><br>      typedef basic_directory_entry&lt;path&gt; directory_entry;<br>      typedef basic_directory_entry&lt;wpath&gt; wdirectory_entry;<br></span><br>      template &lt;class Path&gt; class <a href="#Class-template-basic_directory_iterator">basic_directory_iterator</a>;<br><br>      typedef basic_directory_iterator&lt;path&gt; directory_iterator;<br>      typedef basic_directory_iterator&lt;wpath&gt; wdirectory_iterator;<br><br>      template &lt;class Path&gt; class <a href="#Class-template-basic_recursive_directory_iterator">basic_recursive_directory_iterator</a>;<br><br>      typedef basic_recursive_directory_iterator&lt;path&gt; <a name="recursive_directory_iterator">recursive_directory_iterator</a>;<br>      typedef basic_recursive_directory_iterator&lt;wpath&gt; wrecursive_directory_iterator;<br><br>      enum file_type { status_unknown, file_not_found, regular_file, directory_file,<br>                       symlink_file, block_file, character_file, fifo_file, socket_file,<br>                       type_unknown<br>                     };<br><br>      class <a href="#file_status">file_status</a>;<br><br>      <span style="background-color: rgb(255, 255, 255);">struct space_info  // returned by </span><a style="text-decoration: none;" href="#space"><span style="background-color: rgb(255, 255, 255);">space</span></a><span style="background-color: rgb(255, 255, 255);"> function<br>      {<br>        uintmax_t capacity;<br>        uintmax_t free;<br>        uintmax_t available;<br>      };<br></span><br>      //  <a href="#Status-functions">status functions</a><br>      template &lt;class Path&gt; file_status status(const Path&amp; p);<br>      template &lt;class Path&gt; file_status status(const Path&amp; p, error_code&amp; ec);<br>      template &lt;class Path&gt; file_status symlink_status(const Path&amp; p);<br>      template &lt;class Path&gt; file_status symlink_status(const Path&amp; p, error_code&amp; ec);<br><br>      //  <a href="#Predicate-functions">predicate functions</a><br>      bool status_known( file_status s ); <br>      bool exists( file_status s );<br>      bool is_regular_file( file_status s ); <br>      bool is_directory( file_status s );<br>      bool is_symlink( file_status s );<br>      bool is_other( file_status s );<br><br>      template &lt;class Path&gt; bool exists(const Path&amp; p);<br>      template &lt;class Path&gt; bool is_directory(const Path&amp; p);<br>      template &lt;class Path&gt; bool is_regular_file(const Path&amp; p);<br>      template &lt;class Path&gt; bool is_other(const Path&amp; p);<br>      template &lt;class Path&gt; bool is_symlink(const Path&amp; p);<br>      template &lt;class Path&gt; bool is_empty(const Path&amp; p);<br><br>      template &lt;class Path1, class Path2&gt;<br>        bool equivalent(const Path1&amp; p1, const Path2&amp; p2);<br><br>      //  <a href="#Attribute-functions">attribute functions</a><br>      template &lt;class Path&gt; Path current_path();<br>      template &lt;class Path&gt; void current_path(const Path&amp; p);<br>      template &lt;class Path&gt; const Path&amp; initial_path();<br>      template &lt;class Path&gt; <span style="background-color: rgb(255, 255, 255);">uintmax_t</span> file_size(const Path&amp; p);<br><span style="background-color: rgb(255, 255, 255);">      template &lt;class Path&gt; space_info space(const Path&amp; p);</span><span style="background-color: rgb(255, 255, 0);"><br></span>      template &lt;class Path&gt; std::time_t last_write_time(const Path&amp; p);<br>      template &lt;class Path&gt;<br>        void last_write_time(const Path&amp; p, const std::time_t new_time);<br><br>      //  <a href="#Operations-functions">operations functions</a><br>      template &lt;class Path&gt; bool create_directory(const Path&amp; dp);<br>      template &lt;class Path1, class Path2&gt;<br>        void create_hard_link(const Path1&amp; old_fp, const Path2&amp; new_fp);<br><span style="background-color: rgb(255, 255, 255);">      template &lt;class Path1, class Path2&gt;<br>        error_code create_hard_link(const Path1&amp; old_fp, const Path2&amp; new_fp, error_code&amp; ec);<br>      template &lt;class Path1, class Path2&gt;<br>        void create_symlink(const Path1&amp; old_fp, const Path2&amp; new_fp);<br>      template &lt;class Path1, class Path2&gt;<br>        error_code create_symlink(const Path1&amp; old_fp, const Path2&amp; new_fp, error_code&amp; ec);<br></span>      template &lt;class Path&gt; bool remove(const Path&amp; p);<br>      template &lt;class Path1, class Path2&gt;<br>        void rename(const Path1&amp; from_p, const Path2&amp; to_p);<br><br>      BOOST_SCOPED_ENUM_START(<a name="copy_option">copy_option</a>)<br>        { fail_if_exists, overwrite_if_exists };<br>      BOOST_SCOPED_ENUM_END<br><br>      template &lt;class Path1, class Path2&gt;<br>        void copy_file(const Path1&amp; from_fp, const Path2&amp; to_fp,<br>          BOOST_SCOPED_ENUM(copy_option) option=copy_option::fail_if_exists);<br><br>      template &lt;class Path&gt; Path system_complete(const Path&amp; p);<br>      template &lt;class Path&gt; Path complete(const Path&amp; p, const Path&amp; base=initial_path&lt;Path&gt;());<br><br>      //  <a href="#Convenience-functions">convenience functions</a><br>      template &lt;class Path&gt; bool create_directories(const Path&amp; p);<br>      template &lt;class Path&gt; typename Path::string_type extension(const Path&amp; p);<br>      template &lt;class Path&gt; typename Path::string_type basename(const Path&amp; p);<br>      template &lt;class Path&gt;<br>        Path change_extension(const Path&amp; p, const typename Path::string_type&amp; new_extension);<br><br>    } // namespace filesystem<br>  } // namespace boost </pre>
<h3><a name="Path-traits">Path traits</a></h3>
<p>这一节定义了对表示路径行为的 traits&nbsp;类的要求，并且定义了两个类，分别满足对基于 string 和
wstring 的路径的这些要求。还定义了几个额外的 path traits 结构模板，以及这些模板的特化。</p>
<p>在本文中定义的类模板 <code>basic_path</code>
要求一些其它的类型、值和行为来完成对其语义的定义。</p>
<p>从作用上说，Traits 的行为就象它是一个带有一个被初始化为 false 的私有成员 bool
m_locked，以及一个已初始化的成员 std::locale m_locale 的类。 </p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">
<tbody>
<tr>
<td colspan="2" align="center" width="50%"><b><i>
<a name="Path-Behavior-Traits-Requirements">路径行为
Traits 要求</a></i></b></td>
</tr>
<tr>
<td align="center" width="38%"><b><i>表
达式</i></b></td>
<td align="center" width="62%"><b><i>要
求</i></b></td>
</tr>
<tr>
<td valign="top" width="38%"><code>Traits::external_string_type</code></td>
<td width="62%">一个 typedef，它是 <code>basic_string</code>
的一个特化。其 <code>value_type</code> 为操作系统用于表示路径名的字符类型。</td>
</tr>
<tr>
<td valign="top" width="38%"><code>Traits::internal_string_type</code></td>
<td width="62%">一个 typedef，它是 <code>basic_string</code>
的一个特化。其 <code>value_type</code> 为程序用于表示路径名的字符类型。要求它与 <code>basic_path
的 String</code> 模板参数具有相同类型。 </td>
</tr>
<tr>
<td valign="top" width="38%"><code>Traits::to_external(
p, is )</code></td>
<td width="62%"><code>is</code>, 被 <code>m_locale</code>
<code>codecvt</code> facet 转换为 <code>external_string_type</code>.</td>
</tr>
<tr>
<td valign="top" width="38%"><code>Traits::to_internal(
p, xs )</code></td>
<td width="62%"><code>xs</code>, 被 <code>m_locale</code>
<code>codecvt</code> facet 转换为 <code>internal_string_type</code>.</td>
</tr>
<tr>
<td valign="top" width="38%"><code>Traits::imbue(loc)</code></td>
<td width="62%"><i>作用：</i>如果 <code>m_locked</code>,
则抛出异常。否则&nbsp;<code>m_locked = true; m_locale = loc;<br>
</code><i>返回：</i><code>void</code><b><br>
</b><i>抛出：</i><code>basic_filesystem_error</code></td>
</tr>
<tr>
<td valign="top" width="38%"><code>Traits::imbue(loc,
std::nothrow)</code></td>
<td width="62%"><i>作用：</i><code>如果
&nbsp;(!m_locked) 则 m_locale = loc; bool temp(m_locked); m_locked =
true;<br>
</code><i>返回：</i><code>temp</code></td>
</tr>
</tbody>
</table>
<p>类型 <code>is_basic_path</code> 应该是一个 <i>UnaryTypeTrait</i>
(TR1, 4.1). 其主模板应直接或间接派生自 <code>
std::tr1::false_type</code>. 类型 <code>is_basic_path</code>
应针对 <code>path</code>, <code>wpath</code>,
和任何用户专有 <code>basic_path</code> 类型进行特化，而且这些特化都应直接或间接派生自 <code>std::tr1::true_type</code>.</p>
<p>结构模板 <code>slash</code>, <code>dot</code>,
和 <code>
<span style="background-color: rgb(255, 255, 255);">colon</span></code><span style="background-color: rgb(255, 255, 255);">
</span>用于提供类型为 <code>char</code> 的值。如果某个用户专有 <code>basic_path</code>
具有不可由 char 转换而得的 <code>
value_type</code> 类型，则模板 <code>slash</code> 和 <code>dot</code>
应被特化，以提供某种可转换为 <code>
basic_path::value_type</code> 的类型的值。</p>
<h3><a name="Class-template-basic_path">类模板 <code>basic_path</code></a></h3>
<p>类模板 <code>basic_path</code> 提供了一个在C++程序中表示 <a href="#Path">路径paths</a> 的可移植机制，它使用可移植的通用路径名<a href="#Pathname-grammar">语法</a>。当不需要可移植性时，可以使用原生文件系统的特定
格式。类模板
<code>basic_path</code>
只关心路径的词法和语法方面。该路径不要求在操作系统的文件系统中存在，也可能包含某些当前操作系统认为无效的名字。 </p>
<blockquote>
<p>[<i>注：</i>如果本库的函数只能使用C++或C风格的字符串，那么它们的可移植性只是幻想，因为
虽然函数调用的语法是可移植的，但函数所操作的字符串的语义却不可移植。<i>-- 注完</i>]</p>
</blockquote>
<pre>  namespace boost<br>  {<br>    namespace filesystem<br>    {<br>      template &lt;class String, class Traits&gt; class basic_path<br>      {<br>      public:<br>        typedef basic_path&lt;String, Traits&gt; path_type;<br>        typedef String string_type;<br>        typedef typename String::value_type value_type;<br>        typedef Traits traits_type;<br>        typedef typename Traits::external_string_type external_string_type; <br><br>        // <a href="#basic_path-constructors">constructors/destructor</a><br>        basic_path();<br>        basic_path(const basic_path&amp; p);<br>        basic_path(const string_type&amp; s);<br>        basic_path(const value_type* s);<br>        template &lt;class InputIterator&gt;<br>          basic_path(InputIterator first, InputIterator last);<br><br>       ~basic_path();<br><br>        // <a href="#basic_path-assignments">assignments</a><br>        basic_path&amp; operator=(const basic_path&amp; p);<br>        basic_path&amp; operator=(const string_type&amp; s);<br>        basic_path&amp; operator=(const value_type* s);<br>        template &lt;class InputIterator&gt;<br>          basic_path&amp; assign(InputIterator first, InputIterator last);<br><br>        // <a href="#basic_path-modifiers">modifiers</a><br>        basic_path&amp; operator/=(const basic_path&amp; rhs);<br>        basic_path&amp; operator/=(const string_type&amp; s);<br>        basic_path&amp; operator/=(const value_type* s);<br>        template &lt;class InputIterator&gt;<br>          basic_path&amp; append(InputIterator first, InputIterator last);<br><br>        <span style="background-color: rgb(255, 255, 255);">void clear();<br>        void swap( basic_path &amp; rhs );</span><br>        basic_path&amp; remove_filename();<br>        basic_path&amp; replace_extension(const string_type &amp; new_extension = "");<br><br>        // <a href="#basic_path-observers">observers</a><br>        const string_type string() const;<br>        const string_type file_string() const;<br>        const string_type directory_string() const;<br><br>        const external_string_type external_file_string() const;<br>        const external_string_type external_directory_string() const;<br><br>        string_type  root_name() const;<br>        string_type  root_directory() const;<br>        basic_path   root_path() const;<br>        basic_path   relative_path() const;<br><br>        basic_path   parent_path() const;<br>        string_type  filename() const;<br><br>        string_type  stem() const;<br>        string_type  extension() const;<br><br>        bool empty() const;<br>        bool is_complete() const;<br>        bool has_root_name() const;<br>        bool has_root_directory() const;<br>        bool has_root_path() const;<br>        bool has_relative_path() const;<br>        bool has_filename() const;<br>        bool has_parent_path() const;<br><br>        // <a href="#basic_path-iterators">iterators</a><br>        class iterator;<br>        typedef iterator const_iterator;<br><br>        iterator begin() const;<br>        iterator end() const;<br><br>      };<br><br>    } // namespace filesystem<br>  } // namespace boost</pre>
<p>一个 <code>basic_path</code> 对象可以保存空<a href="#Path">路径</a>。保存路径的内部形式并不指定。</p>
<p><a name="pathname-resolution">在本文中描述的访问文件及其属性的函数要将
一个</a> <code>basic_path</code>
对象解析为文件层次中的一个特定文件。路径名被合适地转换为操作系统所要求的字符串类型、格式和编码，按 <i>POSIX</i>
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap04.html#tag_04_11">Pathname
Resolution</a> 机制进行解析。结果路径名的编码由 <code>Traits::to_external</code>
转换函数决定。</p>
<blockquote>
<p>[<i>注：</i>并不保证保存在 <code>basic_path</code>
对象中的路径对于特定的操作系统或文件系统是有效的。<i>-- 注完</i>]</p>
</blockquote>
<p>本文中有些函数返回的 <code>basic_path</code>
对象部分或全部由得自操作系统的路径名组成。这些路径名被从由操作系统提供的真实格式和字符串类型进行合适的转换。结果路径的编码由 <code>Traits::to_internal</code>
转换函数决定。</p>
<p>那些返回 "<code>const string_type</code>" 或 "<code>const
external_string_type</code>" 的成员函数，允许被实现为分别返回 "<code>const
string_type&amp;</code>" 或 "<code>const
external_string_type&amp;</code>"。</p>
<blockquote>
<p>[<i>注：</i>这允许实现避免不必要的复制。指定以常量值返回可以确保在转换为以引用返回的实现时
不会破坏已有程序。<i>-- 注完</i>]</p>
</blockquote>
<h4><a name="Pathname-formats">路径名格式</a></h4>
<p>有两种格式的字符串或字符序列参数来表示一个路径：</p>
<ul>
<li>可移植的路径名格式，在 <a href="#Pathname-grammar"> 路径名语法</a>
中描述，由 <i>POSIX</i> <i><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_169">Filename</a>,
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_266">Pathname</a>
和</i><i> <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap04.html#tag_04_11">
Pathname Resolution</a></i> 定义。
<blockquote>
<p>[<i>注：</i><span style="background-color: rgb(255, 255, 255);"><i>POSIX</i>
格式是可移植格式的基础，因为它已经是一个ISO标准了，它也是广泛采用的<i>URL</i>格式，是类<i>UNIX</i>和
类<i>Windows</i>操作系统的原生格式或其子集，为广大程序员所熟悉。 </span></p>
<p>单靠使用可移植格式并不能保证可移植性；文件名也必须是可移植的。请见<span style="background-color: rgb(255, 255, 255);"> <a href="#Filename-conversion">文件名转换</a>。每个操作系统都有它自己的规则。使用
可移植格式并不能改变这些规则。</span> <i>-- 注完</i>]</p>
</blockquote>
</li>
<li>由操作系统定义的原生路径名格式。
<blockquote>
<p>[<i>注：</i>如果操作系统只支持<i>POSIX</i>
路径名格式，则可移植格式和原生格式就是一样的。 </p>
<p><span style="background-color: rgb(255, 255, 255);">确
定用户所提供的路径作为原生格式，是一种常见的需要，并且确保了最大的可移植性，虽然这并不是严格需要的，</span><span style="background-color: rgb(255, 255, 255);">除了在那些原生格式未被公认的系
统上。</span><span style="background-color: rgb(255, 255, 255);"></span></p>
<p><span style="background-color: rgb(255, 255, 255);">使
用硬编码原生格式的程序很可能是不可移植的。--</span><i><span style="background-color: rgb(255, 255, 255);"> end note</span></i><span style="background-color: rgb(255, 255, 255);">]</span></p>
</blockquote>
</li>
</ul>
<p><span style="background-color: rgb(255, 255, 255);">所
有 <code>basic_path</code>
的描述路径的字符串或字符序列参数都接受可移植路径名格式，也接受由原生格式转义序列前缀</span><span style="background-color: rgb(255, 255, 255);">"//:"</span><span style="background-color: rgb(255, 255, 255);">显式标识的原生格式。</span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);">[<i>注：</i><code></code></span><span style="background-color: rgb(255, 255, 255);"></span><span style="background-color: rgb(255, 255, 255);">"//:"</span><span style="background-color: rgb(255, 255, 255);"></span><span style="background-color: rgb(255, 255, 255);"><code>被选择
作为转义序列，是因为</code></span><span style="background-color: rgb(255, 255, 255);"></span><span style="background-color: rgb(255, 255, 255);">在POSIX中"//"是由实现
定义的，":"</span><span style="background-color: rgb(255, 255, 255);"></span><span style="background-color: rgb(255, 255, 255);"><code>则是<span style="font-family: sans;">不允许用于</span></code>Windows
文件，而且在任何系统中如果想表示以":"开头的文件名，可以使用单个"/"。以上因素一起消除了这个转义序列与某个真实文件名发生冲突的可能。--</span><i><span style="background-color: rgb(255, 255, 255);"> 注完</span></i><span style="background-color: rgb(255, 255, 255);">]</span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);">如
果在文字上可以区分开，实现最好可以直接接受原生的路径名格式。每个实现应该在文档中写明是否可以直接接受原生路径名格式。</span></p>
<blockquote>
<p>[<i>例如：</i></p>
<p><i>-- OpenVMS:</i> <code>"SYS1::DISK1:[JANE.TYLER.HARRY]</code>"
被视为带有系统名、驱动器名和三个目录文件名的原生路径名，而不是某个文件名的可移植路径名。</p>
<p><i>-- Windows: </i><code>"c:\\jane\\tyler\\harry"</code>
被视为带有驱动器名、根目录和三个文件名的原生路径名，而不是某个文件名的可移植路径名。</p>
<p><i>-- 反例1:</i>
某个操作系统允许在文件名中使用"/"，它使用"."作为目录分隔符。区分可移植格式和原生格式的字符串或字符序列是不可能的，如果没有其它可区分的语
法。所以实现不接受原生格式的路径名，除非指定一个原生参数。</p>
<p><i>-- 反例2:</i>
某个操作系统允许在文件名中使用"/"，它使用一些不常见的字符作为目录分隔符。这时实现不能接受不带有额外的原生参数的原生格式路径名，原生参数必须被
用于在文件名中含有"/"的原生格式参数。</p>
<p><i>-- 举例完</i>]</p>
<p>[<i>注：</i><i><a name="duck-rule">鸭
子规则duck-rule</a></i>
("如果某个东西看起来象鸭子，走起来象鸭子，叫进来象鸭子，那么它就是一只鸭子")消除了源自程序员错误和支持要求的格式混乱。<i>--
注完</i>]</p>
</blockquote>
<p>如果可以同时接受可移植格式和原生格式，则实现应该在文档中说明哪些字符或字符序列被用作区分可移植格式和原生格式。</p>
<blockquote>
<p>[<i>注：</i><i>Windows</i>
实现被鼓励将":"和"\"定义为区分原生格式和可移植格式的字符。<i>--注完</i>]</p>
</blockquote>
<h4><a name="Pathname-grammar">路径名语法</a></h4>
<p>可移植路径名格式的语法如下：</p>
<blockquote>
<p><i>pathname:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
root-name<sub>opt</sub> root-directory<sub>opt</sub>
relative-path<sub>opt</sub></i></p>
<p><i>root-name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
implementation-defined</i></p>
<p><i>root-directory:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
slash<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
root-directory slash<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
implementation-defined</i></p>
<p><i>relative-path:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
filename<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
relative-path slash<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
relative-path slash filename</i></p>
<p><i>filename:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dot<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dot dot</i></p>
<p><i>slash:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<code>slash&lt;Path&gt;::value</code></i></p>
<p><i>dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<code>dot&lt;Path&gt;::value</code></i></p>
</blockquote>
<p>该语法是参照 <i>POSIX 的</i> <i><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_169">Filename</a>,
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_266">
Pathname</a> 和</i><i>
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap04.html#tag_04_11">Pathname
Resolution</a></i> 定义的。该语法与 <i>
POSIX</i> 间的任何冲突都不是故意的。本技术报告遵守 <i>POSIX</i>.</p>
<blockquote>
<p><span style="background-color: rgb(224, 224, 224);"><i>以
上表达形式取自于 POSIX, 后者在多次使用该方式引向 C 标准。</i></span></p>
<p>[<i>注：Windows</i> 实现被鼓励将"//<i>name</i>"
定义为可允许的 <i>root-name</i>. <i>POSIX</i>
允许但不要求相关实现也这样做。<i>Windows</i> 实现被鼓励定义另一个 <i>root-directory</i>
元素 <i>
root_directory name.</i> 它只适用于 <i>root-name</i>
的&nbsp;"//<i>name</i>"&nbsp;格式。</p>
<p> <i>Windows</i> 实现被鼓励在 <i>name</i>
前加一个":"作为原生格式的 <i>root-name</i>, 将"\"作为与"/"等价的格式元素。<span style="font-style: italic;"></span><i>-- 注完</i>]</p>
</blockquote>
<h4><a name="Filename-conversion">文件名转换</a></h4>
<p>在将文件转换为原生操作系统格式时，建议但不要求实现将无效字符或字符序列转换为有效的字符或字符序列。这些转换是由实现定义的。</p>
<blockquote>
<p>[<i>注：</i>文件转换给了程序和文件名更大的可移植能力。</p>
<p>建议实现基于已有标准或实践之上进行转换。相关例子包括URL的转义语法，即在百分号(<code>'%'</code>)
后跟两位十六进制数字来表示字符值。在 <i>OpenVMS</i>, 不允许在文件名中出现百分号，所以使用美元符(<code>'$'</code>)
后跟两位十六进制数字，还有将小写字母转为大写。<i>-- 注完</i>]</p>
<p><span style="background-color: rgb(224, 224, 224);"><i>Windows
平台上的Boost实现目前不进行无效字符映射。来自LWG的未决反馈是，Boost可能决定用 % hex hex
作为转义序列。如果是这样，是否会有标准化的建议？</i></span></p>
</blockquote>
<h4><a name="basic_path-requirements">要求</a></h4>
<p>名为 <code>String</code> 的模板参数的实参应该是一个含有与类模板 <code>basic_string</code>
相同名字、类型、值和语义的成员的类。</p>
<p>名为 <code>Traits</code> 的模板参数的实参应该是一个满足
<a href="#Path-Behavior-Traits-Requirements">路径行为 Traits 要求</a>
表中给出的要求的类。</p>
<p>名为 <code>InputIterator</code>
的模板参数的实参应该满足输入迭代器的要求(C++标准，24.1.1，Input iterators
[lib.input.iterators])，并且应该具有可以转换为
<code>basic_path::value_type</code> 的值类型。 </p>
<p>有些带有 <code>InputIterator</code>
模板参数的函数模板还有其它非模板的重载形式。如果 <code>InputIterator</code> 的类型不是 <code>path_format_t</code>，
则实现应该只选择函数模板的重载。</p>
<blockquote>
<p>[<i>注：</i>"do-the-right-thing"
规则确保用户期望的重载会被选中。实现的技术并未规定 - 具体实现可以使用 <a href="http://www.boost.org/libs/utility/enable_if.html">enable_if</a>
或者其它技术来实现这一效果<span style="font-style: italic;">。</span><i>--
注完</i>]</p>
</blockquote>
<h4> <a name="basic_path-constructors"> <code>basic_path</code>
构造函数</a></h4>
<pre>basic_path();</pre>
<blockquote>
<p><i>后置条件:</i> <code>empty()</code>.</p>
</blockquote>
<pre>basic_path(const string_type&amp; s);<br>basic_path(const value_type * s);<br>template &lt;class InputIterator&gt;<br> basic_path(InputIterator s, InputIterator last);</pre>
<blockquote>
<p><i>备注:</i> 字符串 <code>s</code> 及字符序列
[<code>first</code>,<code>last</code>) 的格式在 <a href="#Pathname-formats">路径名格式</a> 中说明。</p>
<p><i>作用:</i> 保存字符串 <code>s</code>
或字符序列 [<code>first</code>,<code>last</code>)
中的路径元素。</p>
</blockquote>
<h4> <a name="basic_path-assignments"> <code>basic_path</code>
赋值</a></h4>
<pre>basic_path&amp; operator=(const string_type&amp; s);<br>basic_path&amp; operator=(const value_type* s);<br>template &lt;class InputIterator&gt;<br> basic_path&amp; assign(InputIterator first, InputIterator last);</pre>
<blockquote>
<p><i>备注:</i> 字符串 <code>s</code> 及字符序列
[<code>first</code>,<code>last</code>) 的格式在 <a href="reference.html#Pathname-formats">路径名格式</a> 中说明。</p>
<p><i>作用:</i> 保存字符串 <code>s</code>
或字符序列 [<code>first</code>,<code>last</code>)
中的路径元素。</p>
<p><i>返回: </i><code>*this</code></p>
</blockquote>
<h4> <a name="basic_path-modifiers"> <code>basic_path</code>
修改器</a></h4>
<pre>basic_path&amp; operator/=(const basic_path&amp; rhs);</pre>
<blockquote>
<p><i>作用:</i> 将保存在 <code>rhs</code>
中的路径增加到保存的路径中。</p>
<p><i>返回:</i> <code>*this</code></p>
</blockquote>
<pre>basic_path&amp; operator/=(const string_type&amp; s);<br>basic_path&amp; operator/=(const value_type* s);<br>template &lt;class InputIterator&gt;<br>basic_path&amp; append(InputIterator first, InputIterator last);</pre>
<blockquote>
<p><i>备注:</i> 字符串 <code>s</code> 及字符序列
[<code>first</code>,<code>last</code>) 的格式在 <a href="reference.html#Pathname-formats">路径名格式</a> 中说明。</p>
<p><i>作用:</i> 将字符串 <code>s</code>
或字符序列 [<code>first</code>,<code>last</code>)
中的路径元素增加到保存的路径中。</p>
<p><i>返回: </i><code>*this</code></p>
</blockquote>
<pre>void clear();</pre>
<blockquote>
<p><i>后置条件:</i> <code>this-&gt;empty()</code>
为真。</p>
</blockquote>
<pre><code><span style="background-color: rgb(255, 255, 255);">void swap( basic_path &amp; rhs );</span></code></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">作用:</span></i><span style="background-color: rgb(255, 255, 255);"> 交换两个路径的内容。</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">抛出:&nbsp;</span></i>无。<span style="background-color: rgb(255, 255, 255);"></span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">后置条件:</span></i><span style="background-color: rgb(255, 255, 255);"> </span><code><span style="background-color: rgb(255, 255, 255);">this-&gt;string()</span></code><span style="background-color: rgb(255, 255, 255);"> 包含与 </span><code><span style="background-color: rgb(255, 255, 255);"> rhs.string()</span></code><span style="background-color: rgb(255, 255, 255);"> 相同的字符序列, </span><code><span style="background-color: rgb(255, 255, 255);"> rhs.string()</span></code><span style="background-color: rgb(255, 255, 255);"> 则包含与 </span><code>
<span style="background-color: rgb(255, 255, 255);">this-&gt;string()</span></code><span style="background-color: rgb(255, 255, 255);"> 相同的字符序列。</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">复杂度: </span></i>
<span style="background-color: rgb(255, 255, 255);">常量时间。</span></p>
</blockquote>
<pre>basic_path&amp; remove_filename();<br></pre>
<blockquote>
<p><i>作用:</i> 如果 <code>has_</code><code>parent</code><code>_path()</code>
则从保存的路径中删除最后的 <i>filename</i>. 如果路径中剩下的最后的一个或多个"/"不是表示<i>根
目录</i>，就删除它们。</p>
<p><i>返回：</i><code>*this</code></p>
<p>[<i>注:</i> 该函数对于高效实现 <code>
basic_directory_iterator</code> 是必须的。它被设为公有的，可用于其它用途。<i>--
注完</i>]<br>
</p>
</blockquote>
<pre>basic_path&amp; replace_extension( const string_type &amp; new_extension = "" );<br></pre>
<blockquote>
<p><i>后置条件：</i><code>extension() == <i>replacement</i></code>,
其中 <code><i>replacement</i></code> 为 <code>new_extension</code>
如果 <code>new_extension.empty() || new_extension[0] ==</code>
'.'，否则 <code><i>replacement</i></code> 为'.'后跟
<code>new_extension</code>。</p>
<p><i>返回：</i><code>*this</code><br>
</p>
</blockquote>
<h4> <a name="basic_path-observers"> <code>basic_path</code>
观察器</a></h4>
<blockquote>
<p><span style="background-color: rgb(224, 224, 224);"><i>由
分解函数所返回的值的示例请见 <a href="#Path-decomposition-table">路径分解表</a>。</i></span></p>
</blockquote>
<pre>const string_type string() const;</pre>
<blockquote>
<p><i>返回:</i> 所保存的路径，按照 <a href="#Pathname-grammar">路径名语法</a> 规则进行格式化。</p>
</blockquote>
<pre>const string_type file_string() const;</pre>
<blockquote>
<p><i>返回:</i> 所保存的路径，按照操作系统关于常规文件路径名的规则进行格式化，带 <a href="#Filename-conversion">文件名转换</a>。</p>
<p>[<i>注:</i> 对于某些操作系统，包括 <i>POSIX</i>
和 <i>
Windows</i>, 常规文件和目录的路径名的原生格式是相同的，所以 <code>file_string()</code>
和 <code>directory_string()</code> 返回相同的字符串。但是在 OpenMVS
上，表达式 <code>path("/cats/jane").file_string()</code> 返回字符串 <code>"[CATS]JANE"</code>
而 <code>path("/cats/jane").directory_string()</code>
则返回字符串 <code>"[CATS.JANE]"</code>. <i>--&nbsp;注完</i>]</p>
</blockquote>
<pre>const string_type directory_string() const;</pre>
<blockquote>
<p><i>返回:</i> 所保存的路径，按照操作系统关于目录路径名的规则进行格式化，带 <a href="#Filename-conversion">文件名转换</a>。</p>
</blockquote>
<pre>const external_string_type external_file_string() const;</pre>
<blockquote>
<p><i>返回:</i> 所保存的路径，按照操作系统关于常规文件路径名的规则进行格式化，带 <a href="reference.html#Filename-conversion">文件名转换</a>，并由
<code>Traits::to_external</code> 转换函数进行编码。</p>
</blockquote>
<pre>const external_string_type external_directory_string() const;</pre>
<blockquote>
<p><i>返回:</i> 所保存的路径，按照操作系统关于目录路径名的规则进行格式化，带 <a href="reference.html#Filename-conversion">文件名转换</a>，并由
<code>Traits::to_external</code> 转换函数进行编码。</p>
</blockquote>
<pre>string_type root_name() const;</pre>
<blockquote>
<p><i>返回:</i> <i>root-name,</i>
如果所保存的路径中包含 <i>
root-name</i>, 否则返回 <code>string_type()</code>. </p>
</blockquote>
<pre>string_type root_directory() const;</pre>
<blockquote>
<p><i>返回:</i> <i>root-directory</i>,
如果所保存的路径中包含 <i>
root-directory</i>, 否则返回 <code>string_type()</code>.</p>
<p>如果 <i>root-directory</i> 由"/"加<span style="font-style: italic;"></span><i> name</i>
组成，则"/"被排除在返回字符串之外。</p>
</blockquote>
<pre>basic_path root_path() const;</pre>
<blockquote>
<p><i>返回:</i> <code>root_name() /
root_directory()</code></p>
</blockquote>
<pre>basic_path relative_path() const;</pre>
<blockquote>
<p><i>返回:</i> 从被保存的路径组成的 <code>basic_path</code>，
如果有则返回 <i>root-path</i> 加上第一个 <i>filename</i>。
否则返回空的 <code>basic_path</code>.</p>
</blockquote>
<pre>string_type filename() const;</pre>
<blockquote>
<p><i>返回:</i> <code>empty() ? string_type()
: *--end()</code></p>
</blockquote>
<pre>basic_path parent_path() const;</pre>
<blockquote>
<p><i>返回:</i> <code>(string().empty() ||
begin() == --end()) ? path_type("") : <i>br</i></code>,
其中 <code><i>br</i></code> 是这样构成的：以一个空的 <code>basic_path</code>
开始，对 <code>begin()</code>, <code> --end()</code>
间的每个元素相继应用 <code> operator/=</code> 。</p>
</blockquote>
<pre>string_type stem(const Path &amp; p) const;<br></pre>
<blockquote>
<p><i>返回</i><i>:</i> 如果 <code>p.filename()</code>
包含一个'.'，则返回 <code>p.filename()</code>
中从开头起至最后一个'.'的子串(不包含'.')。否则，返回 <code>p.filename()</code>。</p>
</blockquote>
<pre>string_type extension(const Path &amp; p) const;<br></pre>
<blockquote>
<p><i>返回</i><i>:</i> 如果 <code>p.filename()</code>
包含一个'.'，则返回 <code>p.filename()</code>
中从最右一个'.'起至末尾的子串。否则，返回一个空串。 </p>
<p>[<i>注:<b> </b></i>返回值中是包含'.'的，所以可以区分
无扩展名和空扩展名。 </p>
<p>具体实现可以允许但不要求为那些在扩展名上增加其它元素，如数据流或分区数据集名，的文件系统定义额外的行为。 <i>--
注完</i>]</p>
</blockquote>
<pre>bool empty() const;</pre>
<blockquote>
<p><i>返回:</i> <code>string().empty()</code>.</p>
</blockquote>
<pre>bool is_complete() const;</pre>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>返
回:</i> <code>true</code>, 如果 root_path()
的元素唯一地标识了一个目录，否则返回 <code>false</code>.</span></p>
</blockquote>
<pre>bool has_root_path() const;</pre>
<blockquote>
<p><i>返回:</i> <code>!root_path().empty()</code></p>
</blockquote>
<pre>bool has_root_name() const;</pre>
<blockquote>
<p><i>返回:</i> <code>!root_name().empty()</code></p>
</blockquote>
<pre>bool has_root_directory() const;</pre>
<blockquote>
<p><i>返回:</i> <code>!root_directory().empty()</code></p>
</blockquote>
<pre>bool has_relative_path() const;</pre>
<blockquote>
<p><i>返回:</i> <code>!relative_path().empty()</code></p>
</blockquote>
<pre>bool has_leaf() const;</pre>
<blockquote>
<p><i>返回:</i> <code>!leaf().empty()</code></p>
</blockquote>
<pre>bool has_branch_path() const;</pre>
<blockquote>
<p><i>返回:</i> <code>!branch_path().empty()</code></p>
</blockquote>
<h4> <a name="basic_path-iterators"> <code>basic_path</code>
迭代器</a></h4>
<p> <code>basic_path::iterator</code>
是一个常量迭代器，它满足双向迭代器(C++ 标准, 24.1.4 Bidirectional iterators
[lib.bidirectional.iterators])的所有要求。它的 <code>value_type</code>
为
<code>string_type</code>.</p>
<p>对一个 <code>basic_path</code> 对象的任何非常性成员函数的调用<code></code>将
使得引向该对象元素的所有迭代器均失效。</p>
<p>前向遍历的顺序如下：</p>
<ul>
<li><i>root-name</i> 元素，如果有的话。</li>
<li><i>root-directory</i> 元素，如果有的话。</li>
<li>每个相继的 <i>filename</i> 元素，如果有的话。</li>
<li><i>Dot</i>, 如果尾部有一个或多个非根的"/"字符。</li>
</ul>
<p>后向遍历的顺序与前向遍历相反。</p>
<pre>iterator begin() const;</pre>
<blockquote>
<p><i>返回:</i>
一个指向上述遍历列表中第一个有效元素的迭代器。如果没有这样的元素，返回结束迭代器。</p>
</blockquote>
<pre>iterator end() const;</pre>
<blockquote>
<p><i>返回:</i> 结束迭代器。</p>
</blockquote>
<h4> <a name="basic_path-non-member-functions">
<span style="background-color: rgb(255, 255, 255);">basic_path
非成员函数</span></a></h4>
<pre><span style="background-color: rgb(255, 255, 255);">template&lt;class String, class Traits&gt;<br>void swap( basic_path&lt;String, Traits&gt; &amp; lhs, basic_path&lt;String, Traits&gt; &amp; rhs )</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">作用: </span></i><code>
<span style="background-color: rgb(255, 255, 255);">lhs.swap(
rhs )</span></code></p>
</blockquote>
<h4><span style="background-color: rgb(255, 255, 255);">basic_path
非成员操作符</span></h4>
<p><span style="background-color: rgb(255, 255, 255);">basic_path
有七个非成员操作符(/, </span> <code><span style="background-color: rgb(255, 255, 255);">==</span></code><span style="background-color: rgb(255, 255, 255);">, </span>
<code> <span style="background-color: rgb(255, 255, 255);">!=</span></code><span style="background-color: rgb(255, 255, 255);">, </span>
<code><span style="background-color: rgb(255, 255, 255);">&lt;</span></code><span style="background-color: rgb(255, 255, 255);">, </span>
<code><span style="background-color: rgb(255, 255, 255);">&gt;</span></code><span style="background-color: rgb(255, 255, 255);">, </span>
<code><span style="background-color: rgb(255, 255, 255);">&lt;=</span></code><span style="background-color: rgb(255, 255, 255);">, </span>
<code><span style="background-color: rgb(255, 255, 255);">&gt;=</span></code><span style="background-color: rgb(255, 255, 255);">),
每个操作符有五个重载。为简单起见，以表格形式给出规格说明。得到的35个函数签名中的每一个都是一个模板，其模板参数列表为 template</span><code><span style="background-color: rgb(255, 255, 255);">&lt;class
String, class Traits&gt;</span></code><span style="background-color: rgb(255, 255, 255);">. 这些参数的格式在 </span>
<a href="#Pathname-formats"> <span style="background-color: rgb(255, 255, 255);">路径名格式</span></a><span style="background-color: rgb(255, 255, 255);"> 中描述。</span></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">
<tbody>
<tr>
<td width="100%">
<p align="center"><i><b><span style="background-color: rgb(255, 255, 255);">参数类型重载</span></b></i></p>
</td>
</tr>
<tr>
<td width="100%"><span style="background-color: rgb(255, 255, 255);"><code>
basic_path&lt;String, Traits&gt;&amp; a,
basic_path&lt;String, Traits&gt;&amp; b</code></span></td>
</tr>
<tr>
<td width="100%"><span style="background-color: rgb(255, 255, 255);"><code>const
typename basic_path&lt;String, Traits&gt;::string_type&amp;
a, basic_path&lt;String, Traits&gt;&amp; b</code></span></td>
</tr>
<tr>
<td width="100%"><span style="background-color: rgb(255, 255, 255);"><code>const
typename basic_path&lt;String,
Traits&gt;::string_type::value_type* a, basic_path&lt;String,
Traits&gt;&amp; b</code></span></td>
</tr>
<tr>
<td width="100%"><span style="background-color: rgb(255, 255, 255);"><code>const
basic_path&lt;String, Traits&gt;&amp; a, typename
basic_path&lt;String, Traits&gt;::string_type&amp; b</code></span></td>
</tr>
<tr>
<td width="100%"><span style="background-color: rgb(255, 255, 255);"><code>const
basic_path&lt;String, Traits&gt;&amp; a, typename
basic_path&lt;String, Traits&gt;::string_type::value_type* b</code></span></td>
</tr>
</tbody>
</table>
<p><span style="background-color: rgb(255, 255, 255);">在
</span><b><i> <span style="background-color: rgb(255, 255, 255);">basic_path
非成员操作符 </span></i></b><span style="background-color: rgb(255, 255, 255);">表中，</span><code><span style="background-color: rgb(255, 255, 255);">a</span></code><span style="background-color: rgb(255, 255, 255);"> 和 </span><code><span style="background-color: rgb(255, 255, 255);">b</span></code><span style="background-color: rgb(255, 255, 255);"> 为 </span><i><b>
<span style="background-color: rgb(255, 255, 255);">参数类型重载</span></b></i><span style="background-color: rgb(255, 255, 255);"> 表中给出的类型。如果 </span><code><span style="background-color: rgb(255, 255, 255);">a</span></code><span style="background-color: rgb(255, 255, 255);"> 或 </span><code><span style="background-color: rgb(255, 255, 255);">b</span></code><span style="background-color: rgb(255, 255, 255);"> 的类型为 </span><code><span style="background-color: rgb(255, 255, 255);">const
basic_path&lt;String, Traits&gt;&amp;</span></code><span style="background-color: rgb(255, 255, 255);">, 则 </span><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i></code><span style="background-color: rgb(255, 255, 255);"> 或 </span><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><span style="background-color: rgb(255, 255, 255);"> 分别为 </span><code><span style="background-color: rgb(255, 255, 255);">a</span></code><span style="background-color: rgb(255, 255, 255);"> 或 </span><code><span style="background-color: rgb(255, 255, 255);">b</span></code><span style="background-color: rgb(255, 255, 255);">. 否则 </span><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i></code><span style="background-color: rgb(255, 255, 255);"> 或 </span><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><span style="background-color: rgb(255, 255, 255);"> 分别表示从</span><span style="background-color: rgb(255, 255, 255);"> </span><code><span style="background-color: rgb(255, 255, 255);"> a</span></code><span style="background-color: rgb(255, 255, 255);"> 或 </span><code>
<span style="background-color: rgb(255, 255, 255);">b</span></code><span style="background-color: rgb(255, 255, 255);"> 构造的有名或无名的</span><span style="background-color: rgb(255, 255, 255);"> </span><code>
<span style="background-color: rgb(255, 255, 255);">basic_path&lt;String,
Traits&gt;</span></code><span style="background-color: rgb(255, 255, 255);"> 临时对象。</span><span style="background-color: rgb(255, 255, 255);"></span></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" height="280" width="100%">
<tbody>
<tr>
<td colspan="3" align="center" height="19" width="100%"><b><i> <span style="background-color: rgb(255, 255, 255);">basic_path
非成员操作符</span></i></b></td>
</tr>
<tr>
<td align="center" height="19" width="20%"><i><b>
<span style="background-color: rgb(255, 255, 255);">表
达式</span></b></i></td>
<td align="center" height="19" width="25%"><i><b>
<span style="background-color: rgb(255, 255, 255);">返
回类型</span></b></i></td>
<td align="center" height="19" width="55%"><i><b>
<span style="background-color: rgb(255, 255, 255);">语
义</span></b></i></td>
</tr>
<tr>
<td align="center" height="30" valign="top" width="20%"><code> <span style="background-color: rgb(255, 255, 255);">a / b</span></code></td>
<td align="center" height="30" valign="top" width="25%"><code> <span style="background-color: rgb(255, 255, 255);">basic_path&lt;String,
Traits&gt;</span></code></td>
<td height="30" width="55%"><code><span style="background-color: rgb(255, 255, 255);">
basic_path&lt;String, Traits&gt; tmp(a);<br>
return a /= </span></code><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);">;</span></code></td>
</tr>
<tr>
<td align="center" height="19" valign="top" width="20%"><code> <span style="background-color: rgb(255, 255, 255);">a &lt; b</span></code></td>
<td align="center" height="19" valign="top" width="25%"><code> <span style="background-color: rgb(255, 255, 255);">bool</span></code></td>
<td height="19" width="55%"><code><span style="background-color: rgb(255, 255, 255);"> return
lexicographical_compare(</span></code><span style="background-color: rgb(255, 255, 255);"><i><b>a</b></i></span><code><span style="background-color: rgb(255, 255, 255);"><i><b>'</b></i>.begin(),
</span></code><i><b> <span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><span style="background-color: rgb(255, 255, 255);"><i><b>'</b></i>.end(),
</span></code><i><b> <span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);">.begin(), </span></code><i><b>
<span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);">.end());</span></code></td>
</tr>
<tr>
<td align="center" height="19" valign="top" width="20%"><code> <span style="background-color: rgb(255, 255, 255);">a == b</span></code></td>
<td align="center" height="19" valign="top" width="25%"><code> <span style="background-color: rgb(255, 255, 255);">bool</span></code></td>
<td height="19" width="55%"><code><span style="background-color: rgb(255, 255, 255);"> return !(</span></code><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i><span style="background-color: rgb(255, 255, 255);"> &lt; </span></code><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);">)
&amp;&amp; !(</span></code><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);"> &lt; </span></code><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i><span style="background-color: rgb(255, 255, 255);">);</span></code></td>
</tr>
<tr>
<td align="center" height="19" valign="top" width="20%"><code> <span style="background-color: rgb(255, 255, 255);">a != b</span></code></td>
<td align="center" height="19" valign="top" width="25%"><code> <span style="background-color: rgb(255, 255, 255);">bool</span></code></td>
<td height="19" width="55%"><code><span style="background-color: rgb(255, 255, 255);"> return !(</span></code><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i><span style="background-color: rgb(255, 255, 255);"> == </span></code><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);">);</span></code></td>
</tr>
<tr>
<td align="center" height="19" valign="top" width="20%"><code> <span style="background-color: rgb(255, 255, 255);">a &gt; b</span></code></td>
<td align="center" height="19" valign="top" width="25%"><code> <span style="background-color: rgb(255, 255, 255);">bool</span></code></td>
<td height="19" width="55%"><code><span style="background-color: rgb(255, 255, 255);"> return </span></code><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);"> &lt; </span></code><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i><span style="background-color: rgb(255, 255, 255);">;</span></code></td>
</tr>
<tr>
<td align="center" height="19" valign="top" width="20%"><code> <span style="background-color: rgb(255, 255, 255);">a &lt;= b</span></code></td>
<td align="center" height="19" valign="top" width="25%"><code> <span style="background-color: rgb(255, 255, 255);">bool</span></code></td>
<td height="19" width="55%"><code><span style="background-color: rgb(255, 255, 255);"> return !(</span></code><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);"> &lt; </span></code><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i><span style="background-color: rgb(255, 255, 255);">);</span></code></td>
</tr>
<tr>
<td align="center" height="19" valign="top" width="20%"><code> <span style="background-color: rgb(255, 255, 255);">a &gt;= b</span></code></td>
<td align="center" height="19" valign="top" width="25%"><code> <span style="background-color: rgb(255, 255, 255);">bool</span></code></td>
<td height="19" width="55%"><code><span style="background-color: rgb(255, 255, 255);"> return !(</span></code><i><b><span style="background-color: rgb(255, 255, 255);">a</span></b></i><code><i><b><span style="background-color: rgb(255, 255, 255);">'</span></b></i><span style="background-color: rgb(255, 255, 255);"> &lt; </span></code><i><b><span style="background-color: rgb(255, 255, 255);">b'</span></b></i><code><span style="background-color: rgb(255, 255, 255);">);</span></code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);">[</span><i><span style="background-color: rgb(255, 255, 255);">注:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<a name="Path-equality"><span style="background-color: rgb(255, 255, 255);">路径等同性和路径等价性是具有不
同语义的。</span></a><span style="background-color: rgb(255, 255, 255);"></span></p>
<p><span style="background-color: rgb(255, 255, 255);">等
同性由 </span> <i> <span style="background-color: rgb(255, 255, 255);">basic_path</span></i><span style="background-color: rgb(255, 255, 255);"> 的非成员 </span>
<code><a href="#operator-eq"> <span style="background-color: rgb(255, 255, 255);">operator==</span></a></code><span style="background-color: rgb(255, 255, 255);">
判定，它只考虑两个路径的字面表示。路径 "abc" 和 "ABC" 是不等同的。</span></p>
<p><span style="background-color: rgb(255, 255, 255);">等
价性则由 </span> <a href="#equivalent"><span style="background-color: rgb(255, 255, 255);">equivalent()</span></a><span style="background-color: rgb(255, 255, 255);">
非成员函数来判定，它根据两个路径是否 </span> <a href="#pathname-resolution"><span style="background-color: rgb(255, 255, 255);">解析resolve</span></a><span style="background-color: rgb(255, 255, 255);">
为同一个文件系统实体来判定。路径 "abc" 和 "ABC" 可能是也可能不是被解析为同一个文件，这取决于文件系统。</span></p>
<p><span style="background-color: rgb(255, 255, 255);">想
要判断两个路径是否"相同"的程序员必须决定这里所说的"相同"是指"相同的表示法"还是"解析为同一个文件"，并据此选择适当的函数。</span>
<i> <span style="background-color: rgb(255, 255, 255);">--
注完</span></i><span style="background-color: rgb(255, 255, 255);">]</span></p>
</blockquote>
<h4><a name="basic_path-inserter-extractor"> <code>
<span style="background-color: rgb(255, 255, 255);">basic_path</span></code><span style="background-color: rgb(255, 255, 255);"> 插入器和提取器</span></a></h4>
<pre><span style="background-color: rgb(255, 255, 255);">template&lt;class Path&gt;<br> basic_istream&lt;typename Path::string_type::value_type, typename Path::string_type::traits_type&gt;&amp;<br> operator&gt;&gt;(basic_istream&lt; typename Path::string_type::value_type, typename Path::string_type::traits_type&gt;&amp; is,<br> Path&amp; ph );</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">作用:&nbsp; </span></i>
<code><span style="background-color: rgb(255, 255, 255);">typename
Path::string_type str;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is
&gt;&gt; str;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ph = str;</span></code></p>
<p><i><span style="background-color: rgb(255, 255, 255);">返回:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">is</span></code></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template&lt;class Path&gt;<br> basic_ostream&lt;typename Path::string_type::value_type, typename Path::string_type::traits_type&gt;&amp;<br> operator&lt;&lt;(basic_ostream&lt; typename Path::string_type::value_type, typename Path::string_type::traits_type&gt;&amp; os,<br> const Path&amp; ph );</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">作用:</span></i><span style="background-color: rgb(255, 255, 255);">&nbsp; </span>
<code><span style="background-color: rgb(255, 255, 255);">os
&lt;&lt; ph.string()</span></code></p>
<p><i><span style="background-color: rgb(255, 255, 255);">返回:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">os</span></code></p>
</blockquote>
<h3><a name="Class-template-basic_filesystem_error">类
模板 <code>basic_filesystem_error</code></a></h3>
<pre> namespace boost<br> {<br> namespace filesystem<br> {<br> template &lt;class Path&gt; class basic_filesystem_error : public <span style="background-color: rgb(255, 255, 255);">system</span>_error<br> {<br> public:<br> typedef Path path_type;<br><br> explicit basic_filesystem_error(const std::string&amp; <span style="background-color: rgb(255, 255, 255);">what_arg</span>, error_code ec);<br> basic_filesystem_error(const std::string&amp; <span style="background-color: rgb(255, 255, 255);">what_arg</span>, const path_type&amp; p1, error_code ec);<br> basic_filesystem_error(const std::string&amp; <span style="background-color: rgb(255, 255, 255);">what_arg</span>, const path_type&amp; p1, const path_type&amp; p2, error_code ec);<br><br> const path_type&amp; path1() const;<br> const path_type&amp; path2() const;<br><br> const char * what() const;<br> };<br> } // namespace filesystem<br> } // namespace boost</pre>
<p>类模板 <code>basic_filesystem_error</code>
定义了一个被抛出的异常对象类型，它用于报告由本文中所列函数产生的文件系统错误。</p>
<h4> <a name="basic_filesystem_error-constructors">
<code>basic_filesystem_error</code> 构造函数</a></h4>
<pre>explicit basic_filesystem_error(const std::string&amp; <span style="background-color: rgb(255, 255, 255);">what_arg</span>, error_code ec);</pre>
<blockquote>
<p><i>后置条件:</i></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="46%">
<tbody>
<tr>
<td width="18%"><b>表达式</b></td>
<td width="82%"><b>值</b></td>
</tr>
<tr>
<td bgcolor="#ffffff" width="18%"><code>
<span style="background-color: rgb(255, 255, 255);">runtime_error::what</span>()</code></td>
<td bgcolor="#ffffff" width="82%"><span style="background-color: rgb(255, 255, 255);"> <code><i>what_arg</i>.c_str()</code></span></td>
</tr>
<tr>
<td width="18%"><code>code()</code></td>
<td width="82%"><code>ec</code></td>
</tr>
<tr>
<td width="18%"><code>path1().empty()</code></td>
<td width="82%"><code>true</code></td>
</tr>
<tr>
<td width="18%"><code>path2().empty()</code></td>
<td width="82%"><code>true</code></td>
</tr>
</tbody>
</table>
</blockquote>
<pre>basic_filesystem_error(const std::string&amp; <span style="background-color: rgb(255, 255, 255);">what_arg</span>, const path_type&amp; p1, error_code ec);</pre>
<blockquote>
<p><i>后置条件:</i></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="46%">
<tbody>
<tr>
<td width="18%"><b>表达式</b></td>
<td width="82%"><b>值</b></td>
</tr>
<tr>
<td valign="top" width="18%"><code> <span style="background-color: rgb(255, 255, 255);">runtime_error::what</span>()</code></td>
<td width="82%"><span style="background-color: rgb(255, 255, 255);"> <code><i>what_arg</i>.c_str()</code></span></td>
</tr>
<tr>
<td valign="top" width="18%"><code>code()</code></td>
<td width="82%"><code>ec</code></td>
</tr>
<tr>
<td valign="top" width="18%"><code>path1()</code></td>
<td width="82%"><span style="background-color: rgb(255, 255, 255);">一个指向所保存的 </span>
<code>p1 拷贝的引用</code></td>
</tr>
<tr>
<td valign="top" width="18%"><code>path2().empty()</code></td>
<td width="82%"><code>true</code></td>
</tr>
</tbody>
</table>
</blockquote>
<pre>basic_filesystem_error(const std::string&amp; <span style="background-color: rgb(255, 255, 255);">what_arg</span>, const path_type&amp; p1, const path_type&amp; p2, error_code ec);</pre>
<blockquote>
<p><i>后置条件:</i></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="46%">
<tbody>
<tr>
<td width="18%"><b>表达式</b></td>
<td width="82%"><b>值</b></td>
</tr>
<tr>
<td width="18%"><code> <span style="background-color: rgb(255, 255, 255);">runtime_error::what</span>()</code></td>
<td width="82%"><span style="background-color: rgb(255, 255, 255);"> <u> <code><i>w</i></code></u><code><i>hat_arg</i>.c_str()</code></span></td>
</tr>
<tr>
<td width="18%"><code>code()</code></td>
<td width="82%"><code>ec</code></td>
</tr>
<tr>
<td width="18%"><code>path1()</code></td>
<td width="82%"><span style="background-color: rgb(255, 255, 255);">一个指向所保存的 </span>
<code>p1 拷贝的引用</code><code></code></td>
</tr>
<tr>
<td width="18%"><code>path2()</code></td>
<td width="82%"><span style="background-color: rgb(255, 255, 255);">一个指向所保存的 </span>
<code>p2 拷贝的引用</code><code></code></td>
</tr>
</tbody>
</table>
</blockquote>
<h4> <a name="basic_filesystem_error-observers"> <code>basic_filesystem_error</code>
观察器</a></h4>
<pre>const path_type&amp; path1() const;</pre>
<blockquote>
<p><i>返回:</i> 指向由构造函数所保存的 <code>p1</code>
拷贝的引用，或者如果没有这样的拷贝则返回空路径。</p>
</blockquote>
<pre>const path_type&amp; path2() const;</pre>
<blockquote>
<p><i>返回:</i> 指向由构造函数所保存的 <code>p2</code>
拷贝的引用，或者如果没有这样的拷贝则返回空路径。</p>
</blockquote>
<pre>const char * what() const;</pre>
<blockquote>
<p><i>返回: </i>一个字符串，包含 <code>runtime_error::what()</code>
及以 <code>code()</code> 作为第一参数调用 <code>system_message()</code>
所得的结果。精确的格式未指定。</p>
<p>实现应该提供一个特化的 <code>template&lt;&gt; const char
* basic_filesystem_error&lt;path&gt;::what() const</code>
返回一个字符串，其中包含 <code>runtime_error::what(),</code> 以 <code>code()</code>
作为第一参数调用 <code>
system_message()</code> 所得的结果，并且如果非空，则还有 <code>path1().file_string()</code>
和 <code>path2.file_string()</code>. 精确的格式未指定。</p>
<p>实现和用户都被允许提供 <code>what</code> 成员函数的其它特化。</p>
</blockquote>
<h3><a name="Class-template-basic_directory_entry">类模
板 <code>basic_directory_entry</code></a></h3>
<pre>  namespace boost<br>  {<br>    namespace filesystem<br>    {<br>      template &lt;class Path&gt; class basic_directory_entry<br>      {<br>      public:<br>        typedef Path path_type;<br>        typedef typename Path::string_type string_type;<br><br>        // <a href="#basic_directory_entry-constructors">constructors</a><br>        basic_directory_entry();<br>        explicit basic_directory_entry(const path_type&amp; p,<br>          <span style="background-color: rgb(255, 255, 255);">file_status</span> st=file_status(), <span style="background-color: rgb(255, 255, 255);">file_status</span> symlink_st=file_status());<br><br>        // <a href="#basic_directory_entry-modifiers">modifiers</a><br>        void assign(const path_type&amp; p, <span style="background-color: rgb(255, 255, 255);">file_status</span> st=file_status(), <span style="background-color: rgb(255, 255, 255);">file_status</span> symlink_st=file_status());<br>        void replace_filename(const string_type&amp; s, <span style="background-color: rgb(255, 255, 255);">file_status</span> st=file_status(), <span style="background-color: rgb(255, 255, 255);">file_status</span> symlink_st=file_status());<br><br>        // <a href="#basic_directory_entry-observers">observers</a><br>        const Path&amp; path() const;<br>        operator const Path&amp;() const;<br><span style="background-color: rgb(255, 255, 255);"><br>        file_status  status() const;<br>        file_status  status(error_code&amp; ec) const;<br>        file_status  symlink_status() const;<br>        file_status  symlink_status(error_code&amp; ec) const;<br></span><span style="background-color: rgb(255, 255, 0);"><br></span>        // <a href="#basic_directory_entry-comparisons">comparisons</a><br>        bool operator&lt;(const basic_directory_entry&lt;Path&gt;&amp; rhs);<br>        bool operator==(const basic_directory_entry&lt;Path&gt;&amp; rhs);<br>        bool operator!=(const basic_directory_entry&lt;Path&gt;&amp; rhs);<br>        bool operator&gt;(const basic_directory_entry&lt;Path&gt;&amp; rhs);<br>        bool operator&lt;=(const basic_directory_entry&lt;Path&gt;&amp; rhs);<br>        bool operator&gt;=(const basic_directory_entry&lt;Path&gt;&amp; rhs);<br><br>      private:<br>        path_type            m_path;           // for exposition only<br>        mutable <span style="background-color: rgb(255, 255, 255);">file_status</span>  m_status;         // for exposition only; stat()-like<br>        mutable <span style="background-color: rgb(255, 255, 255);">file_status</span>  m_symlink_status; // for exposition only; lstat()-like<br>      };<br><br>    } // namespace filesystem<br>  } // namespace boost</pre>
<p><code>basic_directory_entry</code> 对象保存了一个 <code>basic_path
对象，一个</code>用于非符号链接状态的 <code>file_status</code>
对象，以及一个用于符号链接状态的 <code>
file_status</code> 对象。<code>file_status</code>
对象担当值缓存的角色。</p>
<blockquote>
<p>[<i>注:</i> 因为一个路径名的 <code>status()</code>
可能是一个非常昂贵的操作，有些操作系统以目录迭代副产品的方式提供状态信息。缓存这些状态信息可以显著地节约时间。在有竞争条件的情况下，缓存与不缓存
的结果可能会有所不同。<i>-- 注完</i>]</p>
<p><span style="background-color: rgb(224, 224, 224);"><i>对
一个有15,047项的目录进行迭代，冷启动状态下以非缓存方式查询状态耗费6秒钟，而采用缓存方式查询状态则只要1秒钟。测试环境为：Windows
XP, 3.0 GHz 处理器，带一个较快的硬盘。在 Linux 和 BSD-系
Unix 上进行目录迭代的状态查询，也有类似的加速。</i></span></p>
</blockquote>
<h4> <a name="basic_directory_entry-constructors"> <code>basic_directory_entry
构造函数</code></a></h4>
<pre>basic_directory_entry();</pre>
<blockquote>
<p><i>后置条件:</i></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="36%">
<tbody>
<tr>
<td width="18%"><b>表达式</b></td>
<td width="82%"><b>值</b></td>
</tr>
<tr>
<td width="18%"><code>path().empty()</code></td>
<td width="82%"><code>true</code></td>
</tr>
<tr>
<td width="18%"><code>status()</code></td>
<td width="82%"><code>file_status()</code></td>
</tr>
<tr>
<td width="18%"><code>symlink_status()</code></td>
<td width="82%"><code>file_status()</code></td>
</tr>
</tbody>
</table>
</blockquote>
<pre>explicit basic_directory_entry(const path_type&amp; p, <span style="background-color: rgb(255, 255, 255);">file_status</span> st=file_status(), <span style="background-color: rgb(255, 255, 255);">file_status</span> symlink_st=file_status());</pre>
<blockquote>
<p><i>后置条件:</i></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="36%">
<tbody>
<tr>
<td width="18%"><b>表达式</b></td>
<td width="82%"><b>值</b></td>
</tr>
<tr>
<td width="18%"><code>path()</code></td>
<td width="82%"><code>p</code></td>
</tr>
<tr>
<td width="18%"><code>status()</code></td>
<td width="82%"><code>st</code></td>
</tr>
<tr>
<td width="18%"><code>symlink_status()</code></td>
<td width="82%"><code>symlink_st</code></td>
</tr>
</tbody>
</table>
</blockquote>
<h4> <a name="basic_directory_entry-modifiers"> <code>basic_directory_entry
</code>修改器</a></h4>
<pre>void assign(const path_type&amp; p, <span style="background-color: rgb(255, 255, 255);">file_status</span> st=file_status(), <span style="background-color: rgb(255, 255, 255);">file_status</span> symlink_st=file_status());</pre>
<blockquote>
<p><i>后置条件:</i></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="36%">
<tbody>
<tr>
<td width="18%"><b>表达式</b></td>
<td width="82%"><b>值</b></td>
</tr>
<tr>
<td width="18%"><code>path()</code></td>
<td width="82%"><code>p</code></td>
</tr>
<tr>
<td width="18%"><code>status()</code></td>
<td width="82%"><code>st</code></td>
</tr>
<tr>
<td width="18%"><code>symlink_status()</code></td>
<td width="82%"><code>symlink_st</code></td>
</tr>
</tbody>
</table>
</blockquote>
<pre>void replace_leaf(const string_type&amp; s, <span style="background-color: rgb(255, 255, 255);">file_status</span> st=file_status(), <span style="background-color: rgb(255, 255, 255);">file_status</span> symlink_st=file_status());</pre>
<blockquote>
<p><i>后置条件:</i></p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="43%">
<tbody>
<tr>
<td width="18%"><b>表达式</b></td>
<td width="82%"><b>值</b></td>
</tr>
<tr>
<td width="18%"><code>path()</code></td>
<td width="82%"><code>path().branch() / s</code></td>
</tr>
<tr>
<td width="18%"><code>status()</code></td>
<td width="82%"><code>st</code></td>
</tr>
<tr>
<td width="18%"><code>symlink_status()</code></td>
<td width="82%"><code>symlink_st</code></td>
</tr>
</tbody>
</table>
</blockquote>
<h4> <a name="basic_directory_entry-observers"> <code>basic_directory_entry</code>
观察器</a></h4>
<pre>const Path&amp; path() const;<br>operator const Path&amp;() const;</pre>
<blockquote>
<p><i>返回:</i> <code>m_path</code></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">file_status status() const;</span></pre>
<blockquote>
<p><span style="font-style: italic; background-color: rgb(255, 255, 255);">作
用:</span><span style="background-color: rgb(255, 255, 255);">
就象：</span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">if ( !status_known( m_status ) )<br>{<br> if ( status_known(m_symlink_status) &amp;&amp; !is_symlink(m_symlink_status) )<br> { m_status = m_symlink_status; }<br> else { m_status = status(m_path); }<br>}</span></pre>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>抛
出:</i> 参见 <code>status</code> 函数。</span></p>
<p><span style="background-color: rgb(255, 255, 255);"><i>返
回:</i> <code>m_status</code></span></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">file_status status(error_code&amp; ec) const;</span></pre>
<blockquote>
<p><span style="font-style: italic; background-color: rgb(255, 255, 255);">作
用:</span><span style="background-color: rgb(255, 255, 255);">
就象：</span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">if ( !status_known( m_status ) )<br>{<br> if ( status_known(m_symlink_status) &amp;&amp; !is_symlink(m_symlink_status) )<br> { m_status = m_symlink_status; }<br> else { m_status = status(m_path, ec); }<br>}<br>else ec = 0;</span></pre>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>返
回:</i> <code>m_status</code></span></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">file_status symlink_status() const;</span></pre>
<blockquote>
<p><span style="font-style: italic; background-color: rgb(255, 255, 255);">作
用:</span><span style="background-color: rgb(255, 255, 255);">
就旬：</span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">if ( !status_known( m_symlink_status ) )<br>{<br> m_symlink_status = symlink_status(m_path);<br>}</span></pre>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>抛
出:</i> 参见 <code>symlink_status</code> 函数。</span></p>
<p><span style="background-color: rgb(255, 255, 255);"><i>返
回:</i> <code> m_symlink_status</code></span></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">file_status symlink_status(error_code&amp; ec) const;</span></pre>
<blockquote>
<p><span style="font-style: italic; background-color: rgb(255, 255, 255);">作
用:</span><span style="background-color: rgb(255, 255, 255);">
就象：</span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">if ( !status_known( m_symlink_status ) )<br>{<br> m_symlink_status = symlink_status(m_path, ec);<br>}<br>else ec = 0;</span></pre>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>返
回:</i> <code>m_symlink_status</code></span></p>
</blockquote>
<h3><a name="Class-template-basic_directory_iterator">类
模板 <code>basic_directory_iterator</code></a></h3>
<pre>  namespace boost<br>  {<br>    namespace filesystem<br>    {<br>      template &lt;class Path&gt;<br>      class basic_directory_iterator :<br>        public iterator&lt;input_iterator_tag, basic_directory_entry&lt;Path&gt; &gt;<br>      {<br>      public:<br>        typedef Path path_type;<br><br>        // <a href="#basic_directory_iterator-constructors">constructors</a><br>        basic_directory_iterator();<br>        explicit basic_directory_iterator(const Path&amp; dp);<br>        basic_directory_iterator(const Path&amp; dp, error_code&amp; ec);<br>        basic_directory_iterator(const basic_directory_iterator&amp; bdi);<br>        basic_directory_iterator&amp; operator=(const basic_directory_iterator&amp; bdi);<br>       ~basic_directory_iterator();<br><br>        // other members as required by<br>        //  C++ Std, 24.1.1 Input iterators [lib.input.iterators]<br>      };<br><br>    } // namespace filesystem<br>  } // namespace boost</pre>
<p> <code>basic_directory_iterator</code>
符合输入迭代器的要求(C++ 标准, 24.1.1, Input iterators [lib.input.iterators])。</p>
<p><code>basic_directory_iterator</code>
从其构造的目录中持续读入元素，类似于调用 <i>POSIX</i>
<code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/readdir_r.html">readdir_r()</a></code>.
当一个 <code>basic_directory_iterator</code> 被构造后，每一次调用 <code>operator++</code>，
它读入并保存一个 <code>basic_directory_entry&lt;Path&gt;</code>
值及其可能带有的相关状态值。<code>operator++</code> 不保持等同性，即：<code>i
== j</code> 并不意味着
<code>++i == ++j</code>. </p>
<blockquote>
<p>[<i>注:</i> 不保持等同性的后果是，目录迭代器只能被用于单次遍历的算法。<i>--
注完</i>]</p>
</blockquote>
<p>如果到达目录元素的末尾，迭代器将变为等同于 end 迭代器值。不带参数的构造函数 <code>basic_directory_iterator()</code>
总是构造一个 end 迭代器对象，它是唯一一个用于结束条件的合法迭代器。一个 end 迭代器的 <code>
operator*</code> 结果是未定义的。对于其它迭代器值，则返回一个 <code>const
basic_directory_entry&lt;Path&gt;&amp;</code>. 一个 end
迭代器的
<code>operator-&gt;</code> 结果也是未定义的。对于其它迭代器，则返回一个 <code>const
basic_directory_entry&lt;Path&gt;*</code>. </p>
<p>两个 end 迭代器永远都是相等的。一个 end 迭代器则不会等于一个非-end迭代器。</p>
<blockquote>
<p><i><span style="background-color: rgb(224, 224, 224);">以上措词基于标准库的
istream_iterator 措词。注释被缩短并移至注解。</span></i></p>
</blockquote>
<p>对一个 <code>
basic_directory_iterator</code> 进行提领所得的 <code>
basic_directory_entry</code> 对象，调用其 <code>path()</code>
成员，将得到一个 <code>basic_path</code> 对象的引用，该对象由构造该迭代器的目录参数，通过 <code>
operator/=</code> 加上目录项文件名所组成。 </p>
<blockquote>
<p>[<i><a name="Example-program">示例</a>:
</i>该程序接受一个可选的命令行参数，如果该参数为目录路径名，则对该目录的内容进行遍历。对于每个目录项，输出名字，如果某项为常
规文件则输出文件的大小。</p>
<blockquote>
<pre>#include &lt;iostream&gt;<br>#include &lt;filesystem&gt;<br><br>using std::tr2::sys;<br>using std::cout;<br><br>int main(int argc, char* argv[])<br>{<br> std::string p(argc &lt;= 1 ? "." : argv[1]);<br><br> if (is_directory(p))<br> {<br> for (directory_iterator itr(p); itr!=directory_iterator(); ++itr)<br> {<br> cout &lt;&lt; itr-&gt;path().leaf() &lt;&lt; ' '; // 只显示文件名<br> if (is_regular(itr-&gt;status())) cout &lt;&lt; " [" &lt;&lt; file_size(itr-&gt;path()) &lt;&lt; ']';<br> cout &lt;&lt; '\n';<br> }<br> }<br> else cout &lt;&lt; (exists(p) ? "Found: " : "Not found: ") &lt;&lt; p &lt;&lt; '\n';<br><br> return 0;<br>}</pre>
</blockquote>
<p><i>-- 示例完</i>]</p>
</blockquote>
<p>目录的遍历不会产生当前目录(<i>dot</i>)和父目录(<i>dot dot</i>)
的目录项。</p>
<p>一个&nbsp;<code>basic_directory_iterator</code>&amp;
nbsp;持续递增及提领所得到的目录项的顺序未指定。</p>
<blockquote>
<p>[<i>注:</i>
执行目录遍历的程序可能想要测试从目录迭代器提领所得的路径是否真的存在。它可能是一个指向某个并不存在的文件的符号链接。对目录树进行递归遍历并进行删
除或改名操作的程序则可能希望避免进入符号链接。</p>
<p>如果在一个目录的 <code>basic_directory_iterator</code>
构造完成后，才在目录中删除或加入一个文件，则后续的迭代器递增过程中是否会得到指向被删或被加入项的迭代器，是未指定的。参见 <i>POSIX</i>
<code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/readdir_r.html">readdir_r()</a></code>.
<i>--注完</i>]</p>
</blockquote>
<h4><a name="basic_directory_iterator-constructors"><code>basic_directory_iterator</code>
构造函数</a></h4>
<p><code>basic_directory_iterator();</code></p>
<blockquote>
<p><i>作用:</i> 构造 end 迭代器。</p>
</blockquote>
<p><code>explicit basic_directory_iterator(const
Path&amp; dp);</code></p>
<blockquote>
<p><i>作用:</i> 构造一个迭代器，表示由 <code>dp</code>
所解析得到的目录中的第一项，否则为 end 迭代器。</p>
<p>[<i>注:</i> 要遍历当前目录，要写 <code>
directory_iterator(".")</code> 而不是 <code>directory_iterator("")</code>.
<i>-- 注完</i>]</p>
</blockquote>
<pre><code>basic_directory_iterator(const Path&amp; dp, error_code&amp; ec );</code></pre>
<blockquote>
<p><i>作用:</i> 构造一个迭代器，表示由 <code>dp</code>
所解析得到的目录中的第一项，否则为 end 迭代器。如果在得到结果时发生错误，则所得迭代器为 end 迭代器且 <code>ec</code>
被设置为操作系统所报告的错误代码，否则为 0.</p>
</blockquote>
<h3><a name="Class-template-basic_recursive_directory_iterator">类
模板 <code>basic_recursive_directory_iterator</code></a></h3>
<pre>  namespace boost<br>  {<br>    namespace filesystem<br>    {<br>      template &lt;class Path&gt;<br>      class basic_recursive_directory_iterator :<br>        public iterator&lt;input_iterator_tag, basic_directory_entry&lt;Path&gt; &gt;<br>      {<br>      public:<br>        typedef Path path_type;<br><br>        // constructors<br>        basic_recursive_directory_iterator();<br>        explicit basic_recursive_directory_iterator(const Path&amp; dp);<br>        basic_recursive_directory_iterator(const basic_recursive_directory_iterator&amp; brdi);<br>        basic_recursive_directory_iterator&amp; operator=(const basic_recursive_directory_iterator&amp; brdi);<br>       ~basic_recursive_directory_iterator();<br><br>        // observers<br>        int level() const;<br><br>        // modifiers<br>        void pop();<br>        void no_push();<br><br>        // other members as required by<br>        //  C++ Std, 24.1.1 Input iterators [lib.input.iterators]<br><br>      private:<br>        int m_level; // for exposition only<br>      };<br><br>    } // namespace filesystem<br>  } // namespace boost</pre>
<p><code>basic_recursive_directory_iterator</code>
的行为与 <code>basic_directory_iterator</code> 相同，除了特别说明。</p>
<ul>
<li>一个迭代器被构造后，<code>m_level</code> 设为 0;</li>
<li>递增一个迭代器时，如果 <code>it-&gt;is_directory()</code>
为 true 且 <code>no_push()</code> 没有紧接着最后一个递增操作(或构造时)调用，则 <code>m_level</code>
被递增，并进入该目录且递归遍历其内容。</li>
<li>当一个迭代器到达其当前遍历的目录末尾时，或者 <code>pop()</code> 被调用时，<code>m_level</code>
被递减，且后续将对父目录进行遍历，直至到达构造函数的参数所指定的目录。</li>
<li><code>level()</code>&nbsp;返回 <code>m_level</code>.</li>
<li><code>level()</code>, <code>pop()</code>,
和 <code>no_push()</code> 都要求该迭代器不是 end 迭代器。</li>
</ul>
<blockquote>
<p>[<i>注:</i>&nbsp;<code>no_push()</code>
的一个用法是防止递归进入符号链接的目录。为防止某些操作系统上的循环访问，这是必须的。<i>--注完</i>]</p>
</blockquote>
<h3><a name="file_status">类&nbsp;file_status</a></h3>
<pre>  namespace boost<br>  {<br>    namespace filesystem<br>    {<br>      class file_status<br>      {<br>      public:<br>        explicit file_status( file_type v = status_unknown );<br><br>        file_type type() const;<br>        void type( file_type v );<br>      };<br>    } // namespace filesystem<br>  } // namespace boost</pre>
<p><code>file_status</code>
对象保存了关于一个文件的状态的信息。所保存的信息的内部形式未指定。</p>
<blockquote>
<p><i>[注: </i>未来该类可能会被扩展，以保存更多的信息。<i>--注完]</i></p>
</blockquote>
<h4>成员</h4>
<pre>explicit file_status( file_type v = status_unknown );</pre>
<blockquote>
<p><i>作用:</i> 保存 <code>v</code>.</p>
</blockquote>
<pre>file_type type() const;</pre>
<blockquote>
<p><i>返回: </i>所保存的 <code>file_type</code>.</p>
</blockquote>
<pre>void type( file_type v );</pre>
<blockquote>
<p><i>作用:</i> 保存 <code>v</code>,
替换原先保存的值。</p>
</blockquote>
<h3><a name="Non-member-functions">非成员操作函数</a></h3>
<h4><a name="Status-functions">状态函数</a></h4>
<pre>template &lt;class Path&gt; file_status status(const Path&amp; p, error_code&amp; ec);<br>template &lt;class Path&gt; file_status <a name="symlink_status">symlink_status</a>(const Path&amp; p, error_code&amp; ec);</pre>
<blockquote>
<p><i>返回:</i></p>
<blockquote>对于 <code>status,</code> 确定 <code>p</code>
的属性就象<i> POSIX </i> <code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>,
而对于 <code>symlink_status</code> 确定的属性则象 <i>POSIX </i>
<code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/lstat.html">
lstat()</a></code>.
<blockquote>
<p>[<i>注:</i> 对于符号链接，<code>stat()</code>
会用符号链接的内容继续进行路径名解析，而 <code>lstat()</code> 则不会。<i>--
注完</i>]</p>
</blockquote>
<p>如果在属性确定过程中，操作系统报告了错误，则：</p>
<ul>
<li>如果错误说明 <code>p</code> 不能被解析，象 POSIX 的错误代码
ENOENT 或 ENOTDIR 那样，则设置 ec 为 0 并返回 <code>
file_status(not_found_flag)</code>.</li>
</ul>
<ul>
<li>否则，设置 ec 为操作系统报告的错误代码并返回 <code>
file_status(status_unknown)</code>.</li>
</ul>
否则：
<ul>
<li>如果属性显示是一个常规文件，如 <i>POSIX</i>&nbsp;S_<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">ISREG()</a>,
则返回 <code> file_status(regular_file)</code>.</li>
<li>否则如果属性显示是一个目录，如 <i>POSIX</i> S_<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">ISDIR()</a>,
则返回 <code> file_status(directory_file)</code>.</li>
<li>否则如果属性显示是一个符号链接，如 <i>POSIX</i> S_<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">ISLNK()</a>,
则返回 <code> file_status(symlink_file)</code>. <i>[注:
</i>只能用于 <code> symlink_status</code>. <i>--
注完]</i></li>
<li>否则如果属性显示是一个块设备文件，如 <i>POSIX</i> S_<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">ISBLK()</a>,
则返回 <code> file_status(block_file)</code>.</li>
<li>否则如果属性显示是一个字符设备文件，如 <i>POSIX</i> S_<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">ISCHR()</a>,
则返回 <code> file_status(character_file)</code>.</li>
<li>否则如果属性显示是一个 fifo 或管道文件，如 <i>POSIX</i> S_<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">ISFIFO()</a>,
则返回 <code> file_status(fifo_file)</code>.</li>
<li>否则如果属性显示是一个 socket, 如 <i>POSIX</i> S_<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">ISSOCK()</a>,
则返回 <code> file_status(socket_file)</code>.</li>
<li>否则返回 <code> file_status(type_unknown)</code>.</li>
</ul>
</blockquote>
<p>[<i>注:</i> <code>directory_file</code>
表示在这个文件上可以使用 <code>
basic_directory_iterator</code>，而 <code>
regular_file</code> 则表示可以使用适当的 <code>&lt;fstream&gt;</code>
操作，假如没有硬件、权限、访问和竞争条件的错误。对于 <code>regular_file,</code>
反之则不一定为真；不是 <code>regular_file</code> 并不一定就表示 <code>&lt;fstream&gt;</code>
操作不能用于目录。<i>-- 注完</i>]</p>
</blockquote>
<pre>template &lt;class Path&gt; file_status status(const Path&amp; p);</pre>
<blockquote>
<p><i>作用:</i> <code>system_error_code ec;</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<code>file_status stat(status(p, ec));</code></p>
<p><i>抛出:</i> <code>basic_filesystem_error&lt;Path&gt;</code>
如果 <code>ec != 0</code></p>
<p><i>返回:</i> <code>stat</code></p>
</blockquote>
<pre>template &lt;class Path&gt; file_status symlink_status(const Path&amp; p);</pre>
<blockquote>
<p><i>作用:</i> <code>system_error_code ec;</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<code>file_status stat(symlink_status(p, ec));</code></p>
<p><i>抛出:</i> <code>basic_filesystem_error&lt;Path&gt;</code>
如果 <code>ec != 0</code></p>
<p><i>返回: </i><code>stat</code></p>
</blockquote>
<h4><a name="Predicate-functions">谓词函数</a></h4>
<pre><span style="background-color: rgb(255, 255, 255);">bool <a name="status_known">status_known</a>(file_status s);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回:</span></i><span style="background-color: rgb(255, 255, 255);"> <code>s.type()
!= status_unknown</code></span></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">bool </span><a name="exists"><span style="background-color: rgb(255, 255, 255);">exists</span></a><span style="background-color: rgb(255, 255, 255);">(file_status</span><span style="background-color: rgb(255, 255, 255);"> s);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i><span style="background-color: rgb(255, 255, 255);">:</span></i><span style="background-color: rgb(255, 255, 255);"> <code>status_known(s)
&amp;&amp; s.type() != file_not_found</code></span></p>
</blockquote>
<pre>template &lt;class Path&gt; bool <a name="exists">exists</a>(const Path&amp; p);</pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i>:</i>
<code>exists( status(p) )</code></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">bool </span><code><span style="background-color: rgb(255, 255, 255);">is_regular</span></code><span style="background-color: rgb(255, 255, 255);">(file_status</span><span style="background-color: rgb(255, 255, 255);"> s);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i><span style="background-color: rgb(255, 255, 255);">:</span></i><span style="background-color: rgb(255, 255, 255);"> <code>s.type()
== regular_file</code></span></p>
</blockquote>
<pre><code>template &lt;class Path&gt; bool is_regular(const Path&amp; p);</code></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i>:</i>
<code>is_regular( status(p) )</code></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">bool </span><code><span style="background-color: rgb(255, 255, 255);">is_directory</span></code><span style="background-color: rgb(255, 255, 255);">(file_status</span><span style="background-color: rgb(255, 255, 255);"> s);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i><span style="background-color: rgb(255, 255, 255);">:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">s.type()
== directory_file</span></code></p>
</blockquote>
<pre><code>template &lt;class Path&gt; bool is_directory(const Path&amp; p);</code></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i>:</i>
<code>is_directory( status(p) )</code></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">bool <a name="exists">is_symlink</a>(file_status s);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i><span style="background-color: rgb(255, 255, 255);">:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">s.type()
== symlink_file</span></code></p>
</blockquote>
<pre><code>template &lt;class Path&gt; bool is_symlink(const Path&amp; p);</code></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i>:</i>
<code>is_symlink( symlink_status(p) )</code></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">bool <a name="exists">is_other</a>(file_status s);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i><span style="background-color: rgb(255, 255, 255);">:</span></i><span style="background-color: rgb(255, 255, 255);"> <code>return
exists(s) &amp;&amp; !is_regular(s) &amp;&amp;
!is_directory(s) &amp;&amp; !is_symlink(s)</code></span></p>
<p><span style="background-color: rgb(255, 255, 255);">[<i>注:&nbsp;</i><code>is_other()</code>
的规格保持不变，即使以后会加入 <code>is_xxx()</code> 函数。<i>-- 注完</i>]</span></p>
</blockquote>
<pre><code>template &lt;class Path&gt; bool is_other(const Path&amp; p);</code></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i>:</i>
<code>is_other( status(p) )</code></p>
</blockquote>
<pre><code>template &lt;class Path&gt; bool <span style="background-color: rgb(255, 255, 255); text-decoration: underline;">is_</span>empty(const Path&amp; p);</code></pre>
<blockquote>
<p><i>作用:</i> 确定 <code>file_status s</code>,
如 <code> status(p)</code>.</p>
<p><i>抛出:</i> <code>basic_filesystem_error&lt;Path&gt;</code>
如果 <code>!exist(s) || is_other(s)</code>.</p>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i>:</i>
<code>is_directory(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
? basic_directory_iterator&lt;Path&gt;(p) ==
basic_directory_iterator&lt;Path&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: file_size(p) == 0;</code></p>
</blockquote>
<pre><code>template &lt;class Path1, class Path2&gt; bool <a name="equivalent">equivalent</a>(const Path1&amp; p1, const Path2&amp; p2);</code></pre>
<blockquote>
<p><i>要求:</i> <code>Path1::external_string_type</code>
和 <code> Path2::external_string_type</code> 为相同类型。 </p>
<p><i>作用:</i> 确定 <code>file_status s1</code>
和 <code>s2</code>, 就如 <code>status(p1)</code>
和&nbsp; <code>status(p2)</code>.</p>
<p><i>抛出:</i> <code>basic_filesystem_error&lt;Path1&gt;</code><span style="background-color: rgb(255, 255, 255);"> </span>如
果 <code>(!exists(s1) &amp;&amp; !exists(s2)) ||
(is_other(s1) &amp;&amp; is_other(s2))</code>.</p>
<p><i><span style="background-color: rgb(255, 255, 255);">返回</span></i><i>:</i>
<code>true</code>, 如果 <code>sf1 == sf2</code>
且 <code>p1</code> 和 <code>p2</code>
解析为同一个文件系统实体，否则返回 <code>false</code>.</p>
<p>两个路径被认为是解析为同一个文件系统实体，如果这两个候选实体位于同一设备的同一位置。这就象 <i>POSIX</i>
<code> <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code>
结构的值所确定的那样，对两个路径调用 <code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>
所得到的值，具有相等的 <code>st_dev</code> 值和相等的 <code>st_ino</code>
值。</p>
<p>[<i>注:</i> <i>POSIX</i> 要求<i>"st_dev</i>
在一个LAN中必须是唯一的"。旧的 <i>POSIX</i> 实现可能还会检查 <code>st_size</code>
和 <code>st_mtime</code> 值是否相等。<i>Windows</i>
实现可能用 <code>GetFileInformationByHandle()</code> 代替 <code>
stat()</code>, 并认为"同一文件"是指 <code> dwVolumeSerialNumber</code>,
<code>nFileIndexHigh</code>, <code> nFileIndexLow</code>,
<code>nFileSizeHigh</code>, <code>nFileSizeLow</code>,
<code>ftLastWriteTime.dwLowDateTime</code>, 和 <code>
ftLastWriteTime.dwHighDateTime</code>&nbsp;值的相等。<i>-- 注完</i>]</p>
</blockquote>
<h4><a name="Attribute-functions">属性函数</a></h4>
<p>[<i>注:</i>
可提供的属性函数数量是严格受限的，因为只有少量文件系统属性是可移植的。即使提供了这些函数，在某些文件系统上也不可能实现。<i>--注
完</i>]</p>
<pre>template &lt;class Path&gt; const Path&amp; <a name="initial_path">initial_path</a>();</pre>
<blockquote>
<p><i>返回:</i> 进入&nbsp;<code>main()</code>
时的 <code>current_path()</code>.</p>
<p>[<i>注:</i> 该语义将一个危险的全局变量变为一个安全的全局常量。<i>--注完</i>]</p>
<p>[<i>注:</i>
完整的实现需要运行期库的支持。不能提供运行期库支持的实现被建议保存第一次调用 <a name="initial_path"><code>initial_path</code></a><code>()</code>
时所得的 <code>current_path()</code> 值<code></code>，
并在后续调用时返回该值。使用 <a name="initial_path"><code>initial_path</code></a><code>()</code>
的程序建议在进入 <code>main()</code> 后立即调用它，这样在这些实现中才可以正确工作。<i>--
注完</i>]</p>
</blockquote>
<pre>template &lt;class Path&gt; Path current_path();</pre>
<blockquote>
<p><i>返回:</i> 当前路径，如 <i>POSIX</i> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/getcwd.html">
<code>getcwd()</code></a>.</p>
<p><i>后置条件:</i> <code>current_path().is_complete()</code></p>
<p>[<i>注:</i>
许多操作系统返回的当前路径都是一个危险的全局变量。它可能会被某个第三方库或系统库的函数所修改，或者被其它线程修改。虽然危险，但是该函数在处理其它
库函数时非常有用。作为一个安全的选择，请见 <code><a href="#initial_path">initial_path()</a></code>.
选择 <code> current_path()</code>
这个名字，是为了强调返回的是一个完整的路径，而不是单个目录名。<i>-- </i><i>注完</i>]</p>
</blockquote>
<pre>template &lt;class Path&gt; void current_path(const Path&amp; p);</pre>
<blockquote>
<p><i>后置条件:</i> equivalent( p, current_path() );</p>
</blockquote>
<pre>template &lt;class Path&gt; <span style="background-color: rgb(255, 255, 255);">uintmax_t</span> file_size(const Path&amp; p);</pre>
<blockquote>
<p><i>返回:</i> 由 <code>p</code>
所解析得到的文件的字节大小，类似于由 <i>POSIX</i> <code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>
所得到的 <i>POSIX</i> <code> <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code>
结构的成员 <code>st_size</code> 中所确定的。</p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);"><a name="space">template</a> &lt;class Path&gt; space_info space(const Path&amp; p);</span></pre>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>返
回:</i> 一个 <code>space_info</code> 对象。该 <code>space_info</code>
对象的值按以下方法确定，用 </span> <i><span style="background-color: rgb(255, 255, 255);">POSIX</span></i><span style="background-color: rgb(255, 255, 255);"> <code>
<a href="http://www.opengroup.org/onlinepubs/000095399/functions/statvfs.html" style="text-decoration: none;"> statvfs()</a></code>
得到一个 <i>POSIX</i> 构造 <code> <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/statvfs.h.html" style="text-decoration: none;"> statvfs</a></code>,
然后以用其</span><span style="background-color: rgb(255, 255, 255);">
<code>f_frsize</code></span><span style="background-color: rgb(255, 255, 255);"> 成员与 <code>f_blocks</code>,
<code> f_bfree</code>, 和 <code>f_bavail</code>
成员相乘，将结果分别赋值给 <code>capacity</code>, <code>free</code>,
和 <code>available</code> 成员。无法确定值的成员将被设为 -1.</span></p>
</blockquote>
<pre>template &lt;class Path&gt; std::time_t last_write_time(const Path&amp; p);</pre>
<blockquote>
<p><i>返回:</i>&nbsp;<code>p</code>
的最后修改时间，即通过 <i>POSIX</i> <code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>
获得的 <i>POSIX</i> <code> <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code>
结构的成员 <code>st_mtime</code> 的值。</p>
</blockquote>
<pre>template &lt;class Path&gt; void last_write_time(const Path&amp; p, const std::time_t new_time);</pre>
<blockquote>
<p><i>作用:</i> 将 <code>p</code>
所解析得到的文件的最后修改时间设置为 <code>new_time</code>, 就象 <i>POSIX</i>
<code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>
后跟 <i>POSIX</i> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/utime.html">
<code>utime()</code></a>.</p>
<p>[<i>注:</i> 后置条件 <code>last_write_time(p)
== new_time</code> 未被指定，因为对于多数文件系统，由于时间机制的粒度较粗而未能保证该条件。<i>--
注完</i>]</p>
</blockquote>
<h4><a name="Operations-functions">其它操作函数</a></h4>
<pre>template &lt;class Path&gt; bool create_directory(const Path&amp; dp);</pre>
<blockquote>
<p><i>作用:</i> 尝试创建一个由 <code>dp</code>
解析得到的目录，如<i> POSIX </i><code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/mkdir.html">mkdir()</a></code>，
以 S_IRWXU|S_IRWXG|S_IRWXO 为第二参数。 </p>
<p><i>抛出:</i> <code>basic_filesystem_error&lt;Path&gt;</code>
如果上述<i>作用</i>因除目录已存在以外的原因而失败。</p>
<p><i>返回:</i> True 如果创建了新目录，否则返回 false.</p>
<p><i>后置条件:</i> <code>is_directory(dp)</code></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path1, class Path2&gt;<br> error_code create_hard_link(const Path1&amp; to_p, const Path2&amp; from_p, error_code&amp; ec);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">要求:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">Path1::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 和 </span>
<code> <span style="background-color: rgb(255, 255, 255);">Path2::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 为相同类型。</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">作用:</span></i><span style="background-color: rgb(255, 255, 255);"> 建立后置条件，如 </span>
<i><span style="background-color: rgb(255, 255, 255);">POSIX</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code> <a href="http://www.opengroup.org/onlinepubs/000095399/functions/link.html">
<span style="background-color: rgb(255, 255, 255);">link()</span></a></code><span style="background-color: rgb(255, 255, 255);">.</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">返回:</span></i><span style="background-color: rgb(255, 255, 255);">
如果后置条件不能建立，返回一个表示失败原因的系统错误代码，否则返回 0.</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">后置条件:</span></i></p>
<ul>
<li><span style="background-color: rgb(255, 255, 255);"></span><code><span style="background-color: rgb(255, 255, 255);">exists(to_p)
&amp;&amp; exists(from_p) &amp;&amp; equivalent(to_p,
from_p)</span></code></li>
<li><span style="background-color: rgb(255, 255, 255);"></span>&nbsp;<code><span style="background-color: rgb(255, 255, 255);">to_p</span></code><span style="background-color: rgb(255, 255, 255);">
所解析的文件或目录的内容不变。</span></li>
</ul>
<p><span style="background-color: rgb(255, 255, 255);">[</span><i><span style="background-color: rgb(255, 255, 255);">注:</span></i><span style="background-color: rgb(255, 255, 255);">
有些操作系统不支持硬链接或只对常规文件支持硬链接。有些操作系统则限制每个文件的链接数量。有些文件系统不支持硬链接 -
如用于软盘、存储卡和闪存盘的 FAT 系统。因此如果代码的移植性是关键，则应避免硬链接。</span> <i><span style="background-color: rgb(255, 255, 255);">-- 注完</span></i><span style="background-color: rgb(255, 255, 255);">]</span></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path1, class Path2&gt;<br> void create_hard_link(const Path1&amp; to_p, const Path2&amp; from_p);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">要求:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">Path1::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 和 </span>
<code> <span style="background-color: rgb(255, 255, 255);">Path2::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 为相同类型。</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">作用:</span></i><span style="background-color: rgb(255, 255, 255);"> 如 <code>system_error_code
ec( create_hard_link( to_p, from_p ) );</code></span></p>
<p><span style="font-style: italic; background-color: rgb(255, 255, 255);">抛
出:</span><span style="background-color: rgb(255, 255, 255);">
</span> <code>basic_filesystem_error&lt;Path1,
Path2&gt;</code><span style="background-color: rgb(255, 255, 255);"> 如果 <code>ec</code>
不为零。</span></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path1, class Path2&gt;<br> error_code create_symlink(const Path1&amp; to_p, const Path2&amp; from_p, error_code&amp; ec);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">要求:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">Path1::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 和 </span>
<code> <span style="background-color: rgb(255, 255, 255);">Path2::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 为相同类型。</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">作用:</span></i><span style="background-color: rgb(255, 255, 255);"> 建立后置条件，如 </span>
<i><span style="background-color: rgb(255, 255, 255);">POSIX</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code> <span style="background-color: rgb(255, 255, 255);">
<a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">
symlink()</a></span></code><span style="background-color: rgb(255, 255, 255);">.</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">返回:</span></i><span style="background-color: rgb(255, 255, 255);">
如果后置条件不能建立，则返回表示失败原因的系统错误代码，否则返回 0.</span></p>
<p><span style="background-color: rgb(255, 255, 255);"><i>后
置条件:</i> <code>from_p</code> 解析为一个符号链接文件，包含一个对 <code>to_p</code>
的未指定表示。</span></p>
<p><span style="background-color: rgb(255, 255, 255);">[</span><i><span style="background-color: rgb(255, 255, 255);">注:</span></i><span style="background-color: rgb(255, 255, 255);">
有些操作系统不支持符号链接或只对常规文件支持。因此如果代码的可移植性是关键，则应避免符号链接。</span><i><span style="background-color: rgb(255, 255, 255);">-- 注完</span></i><span style="background-color: rgb(255, 255, 255);">]</span></p>
</blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path1, class Path2&gt;<br> void create_symlink(const Path1&amp; to_p, const Path2&amp; from_p);</span></pre>
<blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">要求:</span></i><span style="background-color: rgb(255, 255, 255);"> </span>
<code><span style="background-color: rgb(255, 255, 255);">Path1::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 和 </span>
<code> <span style="background-color: rgb(255, 255, 255);">Path2::external_string_type</span></code><span style="background-color: rgb(255, 255, 255);"> 为相同类型。</span></p>
<p><i><span style="background-color: rgb(255, 255, 255);">作用:</span></i><span style="background-color: rgb(255, 255, 255);"> 如 <code>system_error_code
ec( create_symlink( to_p, from_p ) );</code></span></p>
<p><span style="font-style: italic; background-color: rgb(255, 255, 255);">抛
出:</span><span style="background-color: rgb(255, 255, 255);">
</span> <code>basic_filesystem_error&lt;Path1,
Path2&gt;</code><span style="background-color: rgb(255, 255, 255);"> 如果 <code>ec</code>
不为零。</span></p>
</blockquote>
<pre>template &lt;class Path&gt; void remove(const Path&amp; p, system::error_code &amp; ec = <i>singular</i> );<br></pre>
<blockquote>
<p><i>作用</i><i>:</i>&nbsp; 删除文件 <code>p</code>,
如<i> POSIX </i><code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.
如果底层实现没有错误报告或如果
<code>status(p).type() == file_not_found</code>, 则：</p>
<ul>
<li>如果 <code>ec != </code><i><code>singular</code></i>,
则 <code>ec.clear()</code>. </li>
</ul>
<p>否则，</p>
<ul>
<li>如果 <code>ec != </code><i><code>singular</code></i>,
则设置 <code>ec</code> 以表示该错误。 </li>
<li>否则，抛出 <code>basic_filesystem_error&lt;Path&gt;</code>
以表示该错误。如果 <code>ec != </code><i><code>singular</code></i>,
则 <code>ec.clear()</code> </li>
</ul>
<p><i>后置条件</i><i>:</i> <code>!exists(p)</code></p>
<p><i>抛出:</i> 参见 <i>作用</i>。</p>
<p>[<i>注:</i> 对于符号链接，其本身被删除，而不是其所解析的文件被删除。<i>--
注完</i>]<br>
</p>
</blockquote>
<pre>template &lt;class Path&gt; unsigned long remove_all(const Path&amp; p);<br></pre>
<blockquote>
<p><i>作用</i><i>:</i> 递归删除 p
中的内容如果它存在，则删除 <code>p</code> 文件本身，如<i> POSIX </i><code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
<p><i>返回</i><i>:</i> 删除文件的数量。</p>
<p><i>后置条件</i><i>:</i> <code>!exists(p)</code></p>
<p>[<i>注:</i>&nbsp;对于符号链接，其本身被删除，而不是其所解析的文件被删除。<i>--
注完</i>]</p>
</blockquote>
<pre>template &lt;class Path1, class Path2&gt; void rename(const Path1&amp; from_p, const Path2&amp; to_p);</pre>
<blockquote>
<p><i>要求:</i> <code>Path1::external_string_type</code>
和 <code> Path2::external_string_type</code> 为相同类型。 </p>
<p><i>作用:</i> 将 <code>from_p</code>
改名为 <code>to_p</code>, 如 <i>POSIX</i> <code>
<a href="http://www.opengroup.org/onlinepubs/000095399/functions/rename.html">
rename()</a></code>.</p>
<p><i>后置条件:</i> <code>!exists(from_p)
&amp;&amp; exists(to_p)</code>, 且原来名为 <code>from_p</code>
的文件的内容和属性不变。</p>
<p>[<i>注:</i> 如果 <code>from_p</code> 和
<code>to_p</code> 为同一文件，则无操作。否则，如果 <code>to_p</code>
为已有文件，则被删除。对于符号链接，其本身被改名，而不是其所指文件被改名。<i>-- 注完</i>]</p>
</blockquote>
<pre>template &lt;class Path1, class Path2&gt;<br>  void copy_file(const Path1&amp; from_fp, const Path2&amp; to_fp,<br>                 BOOST_SCOPED_ENUM(copy_option) option=<a href="#copy_option">copy_option</a>::fail_if_exists);</pre>
<blockquote>
<p><i>要求:</i> <code>Path1::external_string_type</code>
和 <code> Path2::external_string_type</code> 为相同类型。 </p>
<p><i>作用:</i> <code>from_fp</code>
所代表文件的内容和属性被复制至 <code>to_fp</code> 所代表的文件。</p>
<p><i>抛出:</i> <code>basic_filesystem_error&lt;Path&gt;</code> if <code>from_fp.empty() || 
to_fp.empty() ||!exists(from_fp) || !is_regular_file(from_fp) || (option==<a href="#copy_option">copy_option</a>::fail_if_exists &amp;&amp; 
exists(to_fp))</code><code></code></p>
</blockquote>
<pre>template &lt;class Path&gt; Path complete(const Path&amp; p, const Path&amp; base=initial_path&lt;Path&gt;());</pre>
<blockquote>
<p><i>作用:</i> 从 <code>p</code> 和 <code>base</code>
组合一个完整的路径，使用以下规则：</p>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0">
<tbody>
<tr>
<td align="center">&nbsp;</td>
<td align="center"><b><code>p.has_root_directory()</code></b></td>
<td align="center"><b><code>!p.has_root_directory()</code></b></td>
</tr>
<tr>
<td align="center"><b><code>p.has_root_name()</code></b></td>
<td align="center"><code>p</code></td>
<td align="center">前提条件不满足</td>
</tr>
<tr>
<td align="center"><b><code>!p.has_root_name()</code></b></td>
<td align="center"><code>base.root_name()<br>
/ p</code></td>
<td align="center"><code>base / p</code></td>
</tr>
</tbody>
</table>
<p><i>返回:</i> 组成的路径。</p>
<p><i>后置条件:</i> 对于返回的路径 <code>rp,</code>
<code> rp.is_complete()</code> 为 true.</p>
<p><i>抛出:</i> 如果<span style="background-color: rgb(255, 255, 255);"> </span>
<code> <span style="background-color: rgb(255, 255, 255);">!(base.is_complete()
&amp;&amp; (p.is_complete() || !p.has_root_name()))</span></code></p>
<p>[<i><a name="complete_note">注</a>:</i>
如果需要可移植的行为，请使用 <i>complete()</i>. 如果需要与操作系统相关的行为，则使用 <i>system_complete()</i>.</p>
<p>如果要处理程序内部创建的路径，则应使用可移植行为，特别是如果程序要在所有操作系统上表现出相同的行为。</p>
<p>如果要处理由用户输入的路径，或向用户输出，或用户期望的类似行为，则应使用与操作系统相关的行为<span style="font-style: italic;">。</span><i>-- 注完</i>]</p>
</blockquote>
<pre>template &lt;class Path&gt; Path system_complete(const Path&amp; p);</pre>
<blockquote>
<p><i>作用:</i> 从 <code>p</code>
组成一个完整路径，使用与操作系统解析一个传给标准库 open 函数的路径的相同规则。</p>
<p><i>返回:</i> 组成的路径。</p>
<p><i>后置条件:</i> 对于返回的路径 <code>rp,</code>
<code> rp.is_complete()</code> 为 true.</p>
<p><i>抛出:</i> 如果<span style="background-color: rgb(255, 255, 255);"> <code>p.empty()</code>.</span></p>
<p>[<i>注:</i> 对于 <i>POSIX</i>, <code>system_complete(p)</code>
具有与 <code>complete(p, current_path())</code> 相同的语义。</p>
<p><a name="windows_effects">对于 <i>Windows</i></a>,
如果 <code>p.is_complete() || !p.has_root_name()</code> 或 <code>p</code>
和 <code>base</code> 具有相同的 <code>root_name()，则 </code><code>system_complete(p)</code>
具有与 <code>complete(ph, current_path())</code> 相同的语义。否则类似于 <code>complete(p,
kinky)</code>, 其中 <code>kinky</code> 为 <code>p.root_name()</code>
驱动器的当前目录。它是该驱动器最后一次被设置的当前目录，因此可能是<span style="font-weight: bold;">命
令处理器所运行的上一个程序所遗留下来的</span>！虽然这些语义常常被用到，但也是非常容易出错的。</p>
<p>有关用法的建议，请见 <a href="#complete_note"> <i>complete()</i>
注解</a>。<i>-- 注完</i>]</p>
</blockquote>
<h4><a name="Convenience-functions">便利函数</a></h4>
<pre>template &lt;class Path&gt; bool create_directories(const Path &amp; p);</pre>
<blockquote>
<p><i>要求:</i> <code>p.empty() || <br>
对于所有 px: px == p || is_parent(px, p): is_directory(px) || !exists( px )</code>
</p>
<p><i>返回:</i> 达成后置条件之前的 <code>!exists(p)</code>
值。</p>
<p><i>后置条件:</i> <code>is_directory(p)</code></p>
<p><i>抛出:</i>&nbsp; <code>basic_filesystem_error&lt;Path&gt;</code>
如果<code> exists(p) &amp;&amp; !is_directory(p)</code></p>
</blockquote>
<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="1">
<tbody>
<tr>
<td>
<h4>不赞成使用的便利函数</h4>
<p>以下函数已被 <code>basic_path</code> 的成员函数 <code>extension()</code>,
<code>stem()</code>, 及 <code>replace_extension()</code>
所替代。</p>
<pre>template &lt;class Path&gt; typename Path::string_type extension(const Path &amp; p);</pre>
<blockquote>
<p><i>返回:</i> 如果 <code>p.leaf()</code>
包含一个 <i>dot</i>, 则返回 <code>p.leaf()</code>
的子串，从最右边的 <i>dot</i> 开始，以字符串的结尾结束。否则，返回一个空字符串。 </p>
<p>[<i>注:<b> </b></i>返回值中包含 <i>dot</i>，
所以可以区分无扩展名和空扩展名的情况。 </p>
<p>允许但不要求具体实现对于会为扩展名增加额外元素的文件系统定义额外的行为，如交替数据流或分区数据集的名字。<i>--
注完</i>]</p>
</blockquote>
<pre>template &lt;class Path&gt; typename Path::string_type basename(const Path &amp; p);</pre>
<blockquote>
<p><i>返回:</i> 如果 <code>p.leaf()</code>
包含一个 <i>dot</i>, 则返回 <code>p.leaf()</code>
的子串，从开头开始，以最后的 <i>dot</i> 结束(不包含 <i>dot</i>)。否
则返回 <code> p.leaf()</code>.</p>
</blockquote>
<pre>template &lt;class Path&gt;<br> Path change_extension(const Path &amp; p, const typename Path::string_type &amp; new_extension);</pre>
<blockquote>
<p><i>后置条件:</i> <code>basename(<i>return_value</i>)
== basename(p) &amp;&amp; extension(<i>return_value</i>)
== new_extension</code> </p>
<p>[<i>注:</i> 它跟随 <code>extension()</code>
的语义，即 <code>new_extension</code> 应包含 <i>dot</i>
以得到合理的结果。<i>-- 注完</i>]</p>
</blockquote>
</td>
</tr>
</tbody>
</table>
<br>
<h3><a name="header-fstream">对头文件</a> <code>&lt;fstream&gt;
的增加</code></h3>
<blockquote>
<p><span style="background-color: rgb(224, 224, 224); font-style: italic;">以
下新增的规格是经过仔细考虑，以避免破坏在常用操作环境，如</span><span style="background-color: rgb(224, 224, 224); font-style: italic;">
</span> <i><span style="background-color: rgb(224, 224, 224);">POSIX</span></i><span style="background-color: rgb(224, 224, 224); font-style: italic;">,
</span> <i> <span style="background-color: rgb(224, 224, 224);">Windows</span></i><span style="background-color: rgb(224, 224, 224); font-style: italic;">,
和 </span> <i><span style="background-color: rgb(224, 224, 224);">OpenVMS</span></i><span style="background-color: rgb(224, 224, 224); font-style: italic;">
中的已有代码。有关避免在其它环境中破坏已有代码，请参见</span><i><span style="background-color: rgb(224, 224, 224);"> </span><a href="#Suggestions-for-fstream"> <span style="background-color: rgb(224, 224, 224);">对 <code>&lt;fstream&gt;</code>
实现的建议</span></a><span style="background-color: rgb(224, 224, 224);">，尤其是在那些允许斜杠号出现在
文件名中的操作系统。</span></i></p>
<p><span style="background-color: rgb(255, 255, 255);">[<i>注:</i>
来自 <a href="#Requirements-on-implementations">
对实现的要求</a> 中的</span><span style="background-color: rgb(255, 255, 255);">"do-the-right-thing"
规则被应用于头文件</span><span style="background-color: rgb(255, 255, 255);"> <code>&lt;fstream&gt;</code>.</span></p>
<p><span style="background-color: rgb(255, 255, 255);">以
下给出的重载是新增的，而不是替换已有函数。这样保护了那些依赖于到</span><span style="background-color: rgb(255, 255, 255);"> <code>const
char*</code></span><span style="background-color: rgb(255, 255, 255);">
的自动转换的已有代码(可能使用了<a name="home-grown-path">自已的路径类</a>)。<i>--
注完</i>]</span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>在
27.8.1.1 Class template basic_filebuf [lib.filebuf] 概要的第1段，增加函数:</i></span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path&gt; </span><span style="background-color: rgb(255, 255, 255);">basic_filebuf</span><span style="background-color: rgb(255, 255, 255);">&lt;charT,traits&gt;* </span><span style="background-color: rgb(255, 255, 255);">open(const</span><span style="background-color: rgb(255, 255, 255);"> Path&amp; p, </span><span style="background-color: rgb(255, 255, 255);">ios_base::openmode</span><span style="background-color: rgb(255, 255, 255);"> mode);</span></pre>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>在
27.8.1.3 Member functions [lib.filebuf.members], 将上述增加到第2段的签名中，并替换句子:</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);">It
then opens a file, if possible, whose name is the NTBS s (“as if” by
calling <code>std::fopen(s ,<i>modstr</i> ))</code>.</span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>为:</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);">It
then opens, if possible, the file that <code>p</code> or <code>path(s)</code>
resolves to, “as if” by calling <code>std::fopen()</code>
with a second argument of <i>modstr</i>.</span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>在&nbsp;27.8.1.5
Class template basic_ifstream [lib.ifstream] 概要的第1段，增加函数:</i></span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path&gt; explicit basic_ifstream(const Path&amp; p, ios_base::openmode mode = ios_base::in);<br>template &lt;class Path&gt; void open(const Path&amp; p, ios_base::openmode mode = ios_base::in);</span></pre>
</blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">在&nbsp;27.8.1.6
basic_ifstream constructors [lib.ifstream.cons] </span></i>
<span style="background-color: rgb(255, 255, 255);"><i>中
增加上述构造函数到第2段的签名中，并替换</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(s,
mode | ios_base::in)</code></span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>为</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(path(s),
mode | ios_base::in)</code> or <code>rdbuf()-&gt;open(p,
mode | ios_base::in)</code> as appropriate</span></p>
</blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">在&nbsp;27.8.1.7
Member functions [lib.ifstream.members]
</span></i><span style="background-color: rgb(255, 255, 255);"><i>中增加上述
open 函数到第3段的签名中，并替换</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(s,
mode | ios_base::in)</code></span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>为</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(path(s),
mode | ios_base::in)</code> or <code>rdbuf()-&gt;open(p,
mode | ios_base::in)</code> as appropriate</span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>在&nbsp;27.8.1.8
Class template basic_ofstream [lib.ofstream] 概要的第1段，增加函数:</i></span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path&gt; explicit basic_ofstream(const Path&amp; p, ios_base::openmode mode = ios_base::out);<br>template &lt;class Path&gt; void open(const Path&amp; p, ios_base::openmode mode = ios_base::out);</span></pre>
</blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">在&nbsp;27.8.1.9
basic_ofstream constructors [lib.ofstream.cons] </span></i>
<span style="background-color: rgb(255, 255, 255);"><i>中
增加上述构造函数到第2段的签名中，并替换</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(s,
mode | ios_base::out)</code></span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>为</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(path(s),
mode | ios_base::out)</code> or <code>rdbuf()-&gt;open(p,
mode | ios_base::out)</code> as appropriate</span></p>
</blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">在&nbsp;27.8.1.10
Member functions [lib.ofstream.members]
</span></i><span style="background-color: rgb(255, 255, 255);"><i>中增加上述
open 函数到第3段的签名中，并替换</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(s,
mode | ios_base::out)</code></span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>为</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(path(s),
mode | ios_base::out)</code> or <code>rdbuf()-&gt;open(p,
mode | ios_base::out)</code> as appropriate</span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>在&nbsp;27.8.1.11
Class template basic_fstream [lib.fstream] 概要第1段，增加函数:</i></span></p>
<blockquote>
<pre><span style="background-color: rgb(255, 255, 255);">template &lt;class Path&gt; explicit basic_fstream(const Path&amp; p, ios_base::openmode mode = ios_base::in|ios_base::out);<br>template &lt;class Path&gt; void open(const Path&amp; p, ios_base::openmode mode = ios_base::in|ios_base::out);</span></pre>
</blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">在&nbsp;27.8.1.12
basic_fstream constructors [lib.fstream.cons] </span></i>
<span style="background-color: rgb(255, 255, 255);"><i>中
增加上述构造函数到第2段的签名中，并替换</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(s,
mode)</code></span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>为</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(path(s),
mode)</code> or <code>rdbuf()-&gt;open(p, mode)</code>
as appropriate</span></p>
</blockquote>
<p><i><span style="background-color: rgb(255, 255, 255);">在&nbsp;27.8.1.13
Member functions [lib.fstream.members]
</span></i><span style="background-color: rgb(255, 255, 255);"><i>中增加上述
open 函数到第3段的签名中，并替换</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(s,
mode)</code></span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>为</i></span></p>
<blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><code>rdbuf()-&gt;open(path(s),
mode)</code> or <code>rdbuf()-&gt;open(p, mode)</code>
as appropriate</span></p>
</blockquote>
<p><span style="background-color: rgb(255, 255, 255);"><i>建
议文本结束。</i></span></p>
<h2><a name="Path-decomposition-table">路径分解表</a></h2>
<p>该表由以 Boost 实现编译的程序生成。</p>
<p>有底色的项表示 <i>POSIX</i> 和 <i>Windows</i>
实现会产生不同结果。上方的值为
<i>POSIX</i> 结果而下方的值为 <i>Windows</i> 结果。<br>
&nbsp;
</p>
<p>
</p>
<table border="1" cellpadding="5" cellspacing="0" width="1066">
<tbody>
<tr>
<td width="112"><b>构造函数参数</b></td>
<td width="160"><b>遍历所找到的元素</b></td>
<td width="112"><b><code>string()</code></b></td>
<td width="112"><code><b>file_<br>
string()</b></code></td>
<td width="72"><b><code>root_<br>
path()<br>
.string()</code></b></td>
<td width="48"><b><code>root_<br>
name()</code></b></td>
<td width="88"><b><code>root_<br>
directory()</code></b></td>
<td width="96"><b><code>relative_<br>
path()<br>
.string()</code></b></td>
<td width="72"><b><code>parent</code></b><b><code>_<br>
path()<br>
.string()</code></b></td>
<td width="72"><b><code>filename</code></b><b><code>()</code></b></td>
</tr>
<tr>
<td width="112"><code>""</code></td>
<td width="160"><code>""</code></td>
<td width="112"><code>""</code></td>
<td width="112"><code>""</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>""</code></td>
<td width="72"><code>""</code></td>
<td width="72"><code>""</code></td>
</tr>
<tr>
<td width="112"><code>"."</code></td>
<td width="160"><code>"."</code></td>
<td width="112"><code>"."</code></td>
<td width="112"><code>"."</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"."</code></td>
<td width="72"><code>""</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>".."</code></td>
<td width="160"><code>".."</code></td>
<td width="112"><code>".."</code></td>
<td width="112"><code>".."</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>".."</code></td>
<td width="72"><code>""</code></td>
<td width="72"><code>".."</code></td>
</tr>
<tr>
<td width="112"><code>"foo"</code></td>
<td width="160"><code>"foo"</code></td>
<td width="112"><code>"foo"</code></td>
<td width="112"><code>"foo"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo"</code></td>
<td width="72"><code>""</code></td>
<td width="72"><code>"foo"</code></td>
</tr>
<tr>
<td width="112"><code>"/"</code></td>
<td width="160"><code>"/"</code></td>
<td width="112"><code>"/"</code></td>
<td bgcolor="#99ff66" width="112"><code>"/"<br>
"\"</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>""</code></td>
<td width="72"><code>""</code></td>
<td width="72"><code>"/"</code></td>
</tr>
<tr>
<td width="112"><code>"/foo"</code></td>
<td width="160"><code>"/","foo"</code></td>
<td width="112"><code>"/foo"</code></td>
<td bgcolor="#99ff66" width="112"><code>"/foo"<br>
"\foo"</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>"foo"</code></td>
<td width="72"><code>"/"</code></td>
<td width="72"><code>"foo"</code></td>
</tr>
<tr>
<td width="112"><code>"foo/"</code></td>
<td width="160"><code>"foo","."</code></td>
<td width="112"><code>"foo/"</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/"<br>
"foo\"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/"</code></td>
<td width="72"><code>"foo"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"/foo/"</code></td>
<td width="160"><code>"/","foo","."</code></td>
<td width="112"><code>"/foo/"</code></td>
<td bgcolor="#99ff66" width="112"><code>"/foo/"<br>
"\foo\"</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>"foo/"</code></td>
<td width="72"><code>"/foo"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"foo/bar"</code></td>
<td width="160"><code>"foo","bar"</code></td>
<td width="112"><code>"foo/bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/bar"<br>
"foo\bar"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/bar"</code></td>
<td width="72"><code>"foo"</code></td>
<td width="72"><code>"bar"</code></td>
</tr>
<tr>
<td width="112"><code>"/foo/bar"</code></td>
<td width="160"><code>"/","foo","bar"</code></td>
<td width="112"><code>"/foo/bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"/foo/bar"<br>
"\foo\bar"</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>"foo/bar"</code></td>
<td width="72"><code>"/foo"</code></td>
<td width="72"><code>"bar"</code></td>
</tr>
<tr>
<td width="112"><code>"///foo///"</code></td>
<td width="160"><code>"/","foo","."</code></td>
<td width="112"><code>"///foo///"</code></td>
<td bgcolor="#99ff66" width="112"><code>"///foo///"<br>
"\foo\\\"</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>"foo///"</code></td>
<td width="72"><code>"///foo"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"///foo///bar"</code></td>
<td width="160"><code>"/","foo","bar"</code></td>
<td width="112"><code>"///foo///bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"///foo///bar"<br>
"\foo\\\bar"</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>"foo///bar"</code></td>
<td width="72"><code>"///foo"</code></td>
<td width="72"><code>"bar"</code></td>
</tr>
<tr>
<td width="112"><code>"/."</code></td>
<td width="160"><code>"/","."</code></td>
<td width="112"><code>"/."</code></td>
<td bgcolor="#99ff66" width="112"><code>"/."<br>
"\."</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>"."</code></td>
<td width="72"><code>"/"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"./"</code></td>
<td width="160"><code>".","."</code></td>
<td width="112"><code>"./"</code></td>
<td bgcolor="#99ff66" width="112"><code>"./"<br>
".\"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"./"</code></td>
<td width="72"><code>"."</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"/.."</code></td>
<td width="160"><code>"/",".."</code></td>
<td width="112"><code>"/.."</code></td>
<td bgcolor="#99ff66" width="112"><code>"/.."<br>
"\.."</code></td>
<td width="72"><code>"/"</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>"/"</code></td>
<td width="96"><code>".."</code></td>
<td width="72"><code>"/"</code></td>
<td width="72"><code>".."</code></td>
</tr>
<tr>
<td width="112"><code>"../"</code></td>
<td width="160"><code>"..","."</code></td>
<td width="112"><code>"../"</code></td>
<td bgcolor="#99ff66" width="112"><code>"../"<br>
"..\"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"../"</code></td>
<td width="72"><code>".."</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"foo/."</code></td>
<td width="160"><code>"foo","."</code></td>
<td width="112"><code>"foo/."</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/."<br>
"foo\."</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/."</code></td>
<td width="72"><code>"foo"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"foo/.."</code></td>
<td width="160"><code>"foo",".."</code></td>
<td width="112"><code>"foo/.."</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/.."<br>
"foo\.."</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/.."</code></td>
<td width="72"><code>"foo"</code></td>
<td width="72"><code>".."</code></td>
</tr>
<tr>
<td width="112"><code>"foo/./"</code></td>
<td width="160"><code>"foo",".","."</code></td>
<td width="112"><code>"foo/./"</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/./"<br>
"foo\.\"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/./"</code></td>
<td width="72"><code>"foo/."</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"foo/./bar"</code></td>
<td width="160"><code>"foo",".","bar"</code></td>
<td width="112"><code>"foo/./bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/./bar"<br>
"foo\.\bar"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/./bar"</code></td>
<td width="72"><code>"foo/."</code></td>
<td width="72"><code>"bar"</code></td>
</tr>
<tr>
<td width="112"><code>"foo/.."</code></td>
<td width="160"><code>"foo",".."</code></td>
<td width="112"><code>"foo/.."</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/.."<br>
"foo\.."</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/.."</code></td>
<td width="72"><code>"foo"</code></td>
<td width="72"><code>".."</code></td>
</tr>
<tr>
<td width="112"><code>"foo/../"</code></td>
<td width="160"><code>"foo","..","."</code></td>
<td width="112"><code>"foo/../"</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/../"<br>
"foo\..\"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/../"</code></td>
<td width="72"><code>"foo/.."</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"foo/../bar"</code></td>
<td width="160"><code>"foo","..","bar"</code></td>
<td width="112"><code>"foo/../bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"foo/../bar"<br>
"foo\..\bar"</code></td>
<td width="72"><code>""</code></td>
<td width="48"><code>""</code></td>
<td width="88"><code>""</code></td>
<td width="96"><code>"foo/../bar"</code></td>
<td width="72"><code>"foo/.."</code></td>
<td width="72"><code>"bar"</code></td>
</tr>
<tr>
<td width="112"><code>"c:"</code></td>
<td width="160"><code>"c:"</code></td>
<td width="112"><code>"c:"</code></td>
<td width="112"><code>"c:"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td width="88"><code>""</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:"<br>
""</code></td>
<td width="72"><code>""</code></td>
<td width="72"><code>"c:"</code></td>
</tr>
<tr>
<td width="112"><code>"c:/"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:","."<br>
"c:","/"</code></td>
<td width="112"><code>"c:/"</code></td>
<td bgcolor="#99ff66" width="112"><code><span style="background-color: rgb(153, 255, 102);">"c:/"<br>
"c:\"</span></code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:/"<br>
""</code></td>
<td width="72"><code>"c:"</code></td>
<td bgcolor="#99ff66" width="72"><code>"."<br>
"/"</code></td>
</tr>
<tr>
<td width="112"><code>"c:foo"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:foo"<br>
"c:","foo"</code></td>
<td width="112"><code>"c:foo"</code></td>
<td width="112"><code>"c:foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td width="88"><code>""</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:foo"<br>
"foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:foo"<br>
"foo"</code></td>
</tr>
<tr>
<td width="112"><code>"c:/foo"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:","foo"<br>
"c:","/","foo"</code></td>
<td width="112"><code>"c:/foo"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:/foo"<br>
"c:\foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:/foo"<br>
"foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:"<br>
"c:/"</code></td>
<td width="72"><code>"foo"</code></td>
</tr>
<tr>
<td width="112"><code>"c:foo/"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:foo","."<br>
"c:","foo","."</code></td>
<td width="112"><code>"c:foo/"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:foo/"<br>
"c:foo\"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td width="88"><code>""</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:foo/"<br>
"foo/"</code></td>
<td width="72"><code>"c:foo"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"c:/foo/"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:","foo","."<br>
"c:","/","foo","."</code></td>
<td width="112"><code>"c:/foo/"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:/foo/"<br>
"c:\foo\"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:/foo/"<br>
"foo/"</code></td>
<td width="72"><code>"c:/foo"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"c:/foo/bar"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:","foo","bar"<br>
"c:","/","foo","bar"</code></td>
<td width="112"><code>"c:/foo/bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:/foo/bar"<br>
"c:\foo\bar"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:/foo/bar"<br>
"foo/bar"</code></td>
<td width="72"><code>"c:/foo"</code></td>
<td width="72"><code>"bar"</code></td>
</tr>
<tr>
<td width="112"><code>"prn:"</code></td>
<td width="160"><code>"prn:"</code></td>
<td width="112"><code>"prn:"</code></td>
<td width="112"><code>"prn:"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"prn:"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"prn:"</code></td>
<td width="88"><code>""</code></td>
<td bgcolor="#99ff66" width="96"><code>"prn:"<br>
""</code></td>
<td width="72"><code>""</code></td>
<td width="72"><code>"prn:"</code></td>
</tr>
<tr>
<td width="112"><code>"c:\"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:\"<br>
"c:","/"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:\"<br>
"c:/"</code></td>
<td width="112"><code>"c:\"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:\"<br>
""</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:\"<br>
"/"</code></td>
</tr>
<tr>
<td width="112"><code>"c:foo"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:foo"<br>
"c:","foo"</code></td>
<td width="112"><code>"c:foo"</code></td>
<td width="112"><code>"c:foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td width="88"><code>""</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:foo"<br>
"foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:foo"<br>
"foo"</code></td>
</tr>
<tr>
<td width="112"><code>"c:\foo"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:\foo"<br>
"c:","/","foo"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:\foo"<br>
"c:/foo"</code></td>
<td width="112"><code>"c:\foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:\foo"<br>
"foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:\foo"<br>
"foo"</code></td>
</tr>
<tr>
<td width="112"><code>"c:foo\"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:foo\"<br>
"c:","foo","."</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:foo\"<br>
"c:foo/"</code></td>
<td width="112"><code>"c:foo\"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td width="88"><code>""</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:foo\"<br>
"foo/"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:foo\"<br>
"."</code></td>
</tr>
<tr>
<td width="112"><code>"c:\foo\"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:\foo\"<br>
"c:","/","foo","."</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:\foo\"<br>
"c:/foo/"</code></td>
<td width="112"><code>"c:\foo\"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:\foo\"<br>
"foo/"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:\foo\"<br>
"."</code></td>
</tr>
<tr>
<td width="112"><code>"c:\foo/"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:\foo","."<br>
"c:","/","foo","."</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:\foo/"<br>
"c:/foo/"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:\foo/"<br>
"c:\foo\"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:\foo/"<br>
"foo/"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:\foo"<br>
"c:/foo"</code></td>
<td width="72"><code>"."</code></td>
</tr>
<tr>
<td width="112"><code>"c:/foo\bar"</code></td>
<td bgcolor="#99ff66" width="160"><code>"c:","foo\bar"<br>
"c:","/","foo","bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:/foo\bar"<br>
"c:/foo/bar"</code></td>
<td bgcolor="#99ff66" width="112"><code>"c:/foo\bar"<br>
"c:\foo\bar"</code></td>
<td bgcolor="#99ff66" width="72"><code>""<br>
"c:/"</code></td>
<td style="border-left-style: solid; border-left-width: 1px; border-right-style: solid; border-right-width: 1px; border-bottom-style: solid; border-bottom-width: 1px;" bgcolor="#99ff66" width="48"><code>""<br>
"c:"</code></td>
<td bgcolor="#99ff66" width="88"><code>""<br>
"/"</code></td>
<td bgcolor="#99ff66" width="96"><code>"c:/foo\bar"<br>
"foo/bar"</code></td>
<td bgcolor="#99ff66" width="72"><code>"c:"<br>
"c:/foo"</code></td>
<td bgcolor="#99ff66" width="72"><code>"foo\bar"<br>
"bar"</code></td>
</tr>
</tbody>
</table>
<p></p>
<h2><a name="Suggestions-for-fstream">对 <code>&lt;fstream&gt;</code></a>
实现的建议</h2>
<p><span style="background-color: rgb(255, 255, 255);">对
于接受 <code>const char*</code>
参数的函数的语义的改动会破坏已有代码，但是仅会发生在那些不支持 <a href="#Pathname-formats">隐
式接受原生格式路径名</a> 或允许斜杠号用于文件名的操作系统中。因此在 <i>POSIX</i>, <i>Windows,</i>
和 <i>OpenVMS</i> 上，如果实现遵守推荐行为就不会有问题。</span></p>
<p><span style="background-color: rgb(255, 255, 255);">对
于多数 Filesystem 库，并没有已有代码，所以在文件名中使用斜杠号的问题并不会发生。新代码只须使用带有</span><span style="background-color: rgb(255, 255, 255);"> <code>path_format_t</code></span><span style="background-color: rgb(255, 255, 255);"> 参数的
basic_path 构造函数。为保护那些在文件名中使用了斜杠号的已有 fstream
代码，实现可能要提供一个机制，如某个宏，来控制选用旧的行为。</span></p>
<p><span style="background-color: rgb(255, 255, 255);">TR
的前页已要求具体实现要提供一个机制，如某个宏，来控制头文件选用旧的行为(为了保护已有代码)或新的行为(用于新代码以及从其它系统移植来的代码)。因
为 Filesystem 库的其余部分的使用与 <code>&lt;fstream&gt;</code>
新增内容无关，所以建议受到影响的实现可以与其它TR特性分开，单独禁用 <code>&lt;fstream&gt;</code>
新增内容。</span></p>
<p><span style="background-color: rgb(255, 255, 255);">另
一种被拒绝的选择是，在名字空间</span><span style="background-color: rgb(255, 255, 255);"> <code>filesystem</code></span><span style="background-color: rgb(255, 255, 255);"> 中提供新的 fstream
类，它们派生自当前的类，覆盖各个构造函数和 open 函数，接受路径名参数，并提供其它重载。在 Lillehammer LWG members
中说明了这一方法的缺点，感觉上它的开销高于所获得的好处。</span><br>
</p>
<h2><a name="Acknowledgements">鸣谢</a></h2>
<p>This Filesystem Library is dedicated to my wife, Sonda, who
provided the support necessary to see both a trial implementation and
the proposal itself through to completion. She gave me the strength to
continue after a difficult year of cancer treatment in the middle of it
all.</p>
<p>Many people contributed technical comments, ideas, and
suggestions to the Boost Filesystem Library. See
<a href="http://www.boost.org/libs/filesystem/doc/index.htm#Acknowledgements">http://www.boost.org/libs/filesystem/doc/index.htm#Acknowledgements</a>.</p>
<p>Dietmar Kühl contributed the original Boost Filesystem Library
directory_iterator design. Peter Dimov, Walter Landry, Rob Stewart, and
Thomas Witt were particularly helpful in refining the library.</p>
<p>The create_directories, extension, basename, and
replace_extension functions were developed by Vladimir Prus.</p>
<p>Howard Hinnant and John Maddock reviewed a draft of the
proposal, and identified a number of mistakes or weaknesses, resulting
in a more polished final document.</p>
<h2><a name="References">参考</a></h2>
<table style="border-collapse: collapse;" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">
<tbody>
<tr>
<td valign="top" width="16%">[<a name="ISO_POSIX">ISO-POSIX</a>]</td>
<td width="84%">ISO/IEC 9945:2003,
IEEE&nbsp;Std&nbsp;1003.1-2001, and The Open Group Base
Specifications, Issue 6. Also known as The Single Unix<font face="Times New Roman">® Specification, Version 3. Available
from each of the organizations involved in its creation. For example,
read online or download from <a href="http://www.unix.org/single_unix_specification/">
www.unix.org/single_unix_specification/</a>.</font> The ISO
JTC1/SC22/WG15 - POSIX homepage is <a href="http://www.open-std.org/jtc1/sc22/WG15/">
www.open-std.org/jtc1/sc22/WG15/</a></td>
</tr>
<tr>
<td valign="top" width="16%">[Abrahams]</td>
<td width="84%">Dave Abrahams, Error and Exception
Handling, <a href="http://www.boost.org/more/error_handling.html">
www.boost.org/more/error_handling.html</a></td>
</tr>
</tbody>
</table>
<hr>
<p>© Copyright Beman Dawes, 2002, 2006, 2007</p>
<p>Distributed under the Boost Software License, Version 1.0. See
<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
<p>Revised <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->17 
May 2009</p>
</body></html>
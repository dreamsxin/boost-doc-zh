<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Introduction</title>
<link rel="stylesheet" href="../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.66.1">
<link rel="start" href="../index.html" title="Chapter 1. Fusion 2.0">
<link rel="up" href="../index.html" title="Chapter 1. Fusion 2.0">
<link rel="prev" href="preface.html" title="Preface">
<link rel="next" href="quick_start.html" title="Quick Start">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="preface.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="quick_start.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="fusion.introduction"></a><a href="introduction.html" title="Introduction">Introduction</a></h2></div></div></div>
<p>
      An advantage other languages such as Python and Lisp/ Scheme, ML and Haskell,
      etc., over C++ is the ability to have heterogeneous containers that can hold
      arbitrary element types. All the containers in the standard library can only
      hold a specific type. A <tt class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></tt>
      can only hold <tt class="computeroutput"><span class="keyword">int</span></tt>s. A <tt class="computeroutput"><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">&gt;</span></tt> can
      only hold elements of type <tt class="computeroutput"><span class="identifier">X</span></tt>,
      and so on.
      <br />
      其它语言例如 Python 和 Lisp / Scheme、ML 和 Haskell 等强于 C++ 的一个地方是能够存储任意元素类型的异构容器能力。
      标准库中所有容器只能存储特定类型。<tt class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></tt> 只能存储 <tt class="computeroutput"><span class="keyword">int</span></tt>。
      <tt class="computeroutput"><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">&gt;</span></tt> 只能存储类型为 <tt class="computeroutput"><span class="identifier">X</span></tt> 的元素，依此类推。
    </p>
<p>
      True, you can use inheritance to make the containers hold different types,
      related through subclassing. However, you have to hold the objects through
      a pointer or smart reference of some sort. Doing this, you'll have to rely
      on virtual functions to provide polymorphic behavior since the actual type
      is erased as soon as you store a pointer to a derived class to a pointer to
      its base. The held objects must be related: you cannot hold objects of unrelated
      types such as <tt class="computeroutput"><span class="keyword">char</span></tt>, <tt class="computeroutput"><span class="keyword">int</span></tt>, <tt class="computeroutput"><span class="keyword">class</span>
      <span class="identifier">X</span></tt>, <tt class="computeroutput"><span class="keyword">float</span></tt>,
      etc. Oh sure you can use something like <a href="http://boost.org/doc/html/any.html" target="_top">Boost.Any</a>
      to hold arbitrary types, but then you pay more in terms of runtime costs and
      due to the fact that you practically erased all type information, you'll have
      to perform dangerous casts to get back the original type.
      <br />
      是的，你可以使用继承，通过子类使得容器存储不同类型。但是，你需要以指针或某种智能引用的形式存储对象。
      这样做，你需要依赖于虚函数来提供多态行为，
      因为指向继承类的指针在以指向基类指针的形式存储时其实际类型信息已经被抹去了。
      被存储的对象必须是相关的：你不能存储像 <tt class="computeroutput"><span class="keyword">char</span></tt>、<tt class="computeroutput"><span class="keyword">int</span></tt>、<tt class="computeroutput"><span class="keyword">class</span> <span class="identifier">X</span></tt>、<tt class="computeroutput"><span class="keyword">float</span></tt> 这样无关类型的对象。
      当然，你可以使用像 <a href="../../../../../doc/html/any.html" target="_top">Boost.Any</a> 这样的东西来存储任意类型，
      但你会付出更多的运行时开销，并且实际上，你抹去了所有的类型信息，要想得到原来的类型，你需要执行危险的转换。
    </p>
<p>
      The <a href="http://www.boost.org/libs/tuple/doc/tuple_users_guide.html" target="_top">Boost.Tuple</a>
      library written by <a href="http://www.boost.org/people/jaakko_jarvi.htm" target="_top">Jaakko
      Jarvi</a> provides heterogeneous containers in C++. The <tt class="computeroutput"><span class="identifier">tuple</span></tt>
      is a basic data structure that can hold heterogeneous types. It's a good first
      step, but it's not complete. What's missing are the algorithms. It's nice that
      we can store and retrieve data to and from tuples, pass them around as arguments
      and return types. As it is, the <a href="http://www.boost.org/libs/tuple/doc/tuple_users_guide.html" target="_top">Boost.Tuple</a>
      facility is already very useful. Yet, as soon as you use it more often, usage
      patterns emerge. Eventually, you collect these patterns into algorithm libraries.
      <br />
      <a href="http://www.boost.org/people/jaakko_jarvi.htm" target="_top">Jaakko Jarvi</a> 写的 <a href="../../../../tuple/doc/tuple_users_guide.html" target="_top">Boost.Tuple</a> 库在 C++ 中提供了异构容器。
      这是非常棒的第一步，但还不够。还缺少的是算法。我们可以在元组中存储取回数据，将它作为参数和返回类型传递。
      <a href="../../../../tuple/doc/tuple_users_guide.html" target="_top">Boost.Tuple</a> 工具是非常有用的。
      但是，如果更经常使用，用法模式就会展现出来。逐渐，你将这些模式集成到算法库中。
    </p>
<p>
      Hmmm, kinda reminds us of STL right? Right! Can you imagine how it would be
      like if you used STL without the algorithms? Everyone will have to reinvent
      their own <span class="emphasis"><em>algorithm</em></span> wheels.
      <br />
      嗯，有点儿让我们想到 STL？是的！你能想象我们使用 STL 但没有算法吗？每个人都需要重要发明自己的<span class="emphasis"><em>算法</em></span>轮子。
    </p>
<p>
      Fusion is a library and a framework similar to both <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a>
      and the boost <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>.
      The structure is modeled after <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>,
      which is modeled after <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a>.
      It is named "fusion" because the library is reminiscent of the "fusion"
      of compile time meta-programming with runtime programming. The library inherently
      has some interesting flavors and characteristics of both <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>
      and <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a>.
      It lives in the twilight zone between compile time meta-programming and run
      time programming. <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a>
      containers work on values. MPL containers work on types. Fusion containers
      work on both types and values.
      <br />
      Fusion 是一个类似于 <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a> 和
      boost <a href="../../../../mpl/index.html" target="_top">MPL</a> 的库和框架。
      整个结构是模仿 <a href="../../../../mpl/index.html" target="_top">MPL</a>，后者又是模仿 <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a>。
      之所以命名为 "fusion"，是因为库是编译时元程序和运行时程序的 "混合"。
      库有一些 <a href="../../../../mpl/index.html" target="_top">MPL</a> 和 <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a> 的一些有趣的特点。
      这生活于编译时元程序和运行时程序的混合地带。
      <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a> 容器在值上工作。
      MPL 容器在类型上工作。Fusion 容器在类型和值上工作。
    </p>
<p>
      Unlike <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>, Fusion
      algorithms are lazy and non sequence-type preserving. What does that mean?
      It means that when you operate on a sequence through a Fusion algorithm that
      returns a sequence, the sequence returned may not be of the same class as the
      original. This is by design. Runtime efficiency is given a high priority. Like
      <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>, and unlike
      <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a>,
      fusion algorithms are functional in nature such that algorithms are non mutating
      (no side effects). However, due to the high cost of returning full sequences
      such as vectors and lists, <span class="emphasis"><em>Views</em></span> are returned from Fusion
      algorithms instead. For example, the <a href="algorithm/transformation/functions/transform.html" title="transform"><tt class="computeroutput"><span class="identifier">transform</span></tt></a> algorithm does not actually
      return a transformed version of the original sequence. <a href="algorithm/transformation/functions/transform.html" title="transform"><tt class="computeroutput"><span class="identifier">transform</span></tt></a> returns a <a href="view/transform_view.html" title="transform_view"><tt class="computeroutput"><span class="identifier">transform_view</span></tt></a>. This view holds a
      reference to the original sequence plus the transform function. Iteration over
      the <a href="view/transform_view.html" title="transform_view"><tt class="computeroutput"><span class="identifier">transform_view</span></tt></a>
      will apply the transform function over the sequence elements on demand. This
      <span class="emphasis"><em>lazy</em></span> evaluation scheme allows us to chain as many algorithms
      as we want without incurring a high runtime penalty.
      <br />
      不同于 <a href="../../../../mpl/index.html" target="_top">MPL</a>，Fusion 的算法是懒惰的，并且不保留序列类型。
      这是什么意思？就是说当你用 Fusion 算法操作于一个序列，返回序列时，返回的序列可能不是原来类型的。
      这是出于设计的考虑。运行时效率被给予最高优先级。
      类似于 <a href="../../../../mpl/index.html" target="_top">MPL</a>，不同于 <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_top">STL</a>，fusion 算法本质上是函数式的，即算法是不变的 (没有副作用)。
      然而，由于返回 vector 或 list 全部序列的高开销，Fusion 算法返回<span class="emphasis"><em>视图</em></span>。
      例如，<a href="algorithm/transformation/functions/transform.html" title="transform"><tt class="computeroutput"><span class="identifier">transform</span></tt></a> 算法并不实际返回原始序列的被转换版本。
      <a href="algorithm/transformation/functions/transform.html" title="transform"><tt class="computeroutput"><span class="identifier">transform</span></tt></a> 返回一个 <a href="view/transform_view.html" title="transform_view"><tt class="computeroutput"><span class="identifier">transform_view</span></tt></a>。
      这个视图存储指向原始序列的引用和转换函数。
      在 <a href="view/transform_view.html" title="transform_view"><tt class="computeroutput"><span class="identifier">transform_view</span></tt></a> 上进行迭代，会在需要时将转换函数应用于序列的元素。
      这个<span class="emphasis"><em>懒惰</em></span>的计算方案可以上我们将多个算法串连起来，并且不会引入很高的运行时惩罚。
    </p>
<p>
      The <span class="emphasis"><em>lazy</em></span> evaluation scheme where algorithms return views
      allows operations such as <a href="algorithm/transformation/functions/push_back.html" title="push_back"><tt class="computeroutput"><span class="identifier">push_back</span></tt></a> to be totally generic. In
      Fusion, <a href="algorithm/transformation/functions/push_back.html" title="push_back"><tt class="computeroutput"><span class="identifier">push_back</span></tt></a> is actually a generic algorithm
      that works on all sequences. Given an input sequence <tt class="computeroutput"><span class="identifier">s</span></tt>
      and a value <tt class="computeroutput"><span class="identifier">x</span></tt>, Fusion's <a href="algorithm/transformation/functions/push_back.html" title="push_back"><tt class="computeroutput"><span class="identifier">push_back</span></tt></a> algorithm simply returns
      a <a href="view/joint_view.html" title="joint_view"><tt class="computeroutput"><span class="identifier">joint_view</span></tt></a>:
      a view that holds a reference to the original sequence <tt class="computeroutput"><span class="identifier">s</span></tt>
      and the value <tt class="computeroutput"><span class="identifier">x</span></tt>. Functions
      that were once sequence specific and need to be implemented N times over N
      different sequences are now implemented only once.
      <br />
      算法返回视图的<span class="emphasis"><em>懒惰</em></span>计算方案使得像 <a href="algorithm/transformation/functions/push_back.html" title="push_back"><tt class="computeroutput"><span class="identifier">push_back</span></tt></a> 的操作可以完全泛型化。
      在 Fusion 中，<a href="algorithm/transformation/functions/push_back.html" title="push_back"><tt class="computeroutput"><span class="identifier">push_back</span></tt></a> 实际上是泛型算法，可以工作于所有序列上。
      给定一个输入序列 <tt class="computeroutput"><span class="identifier">s</span></tt> 和值 <tt class="computeroutput"><span class="identifier">x</span></tt>，
      Fusion 的 <a href="algorithm/transformation/functions/push_back.html" title="push_back"><tt class="computeroutput"><span class="identifier">push_back</span></tt></a> 算法简单地返回一个 <a href="view/joint_view.html" title="joint_view"><tt class="computeroutput"><span class="identifier">joint_view</span></tt></a>：
      存储指向原始序列 <tt class="computeroutput"><span class="identifier">s</span></tt> 的引用和值 <tt class="computeroutput"><span class="identifier">x</span></tt> 的视图。
      每个序列特定的，对于不同的 N 个序列需要实现 N 次的函数现在只需要实现一次。
    </p>
<p>
      Fusion provides full round compatibility with <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>.
      Fusion sequences are fully conforming <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>
      sequences and <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>
      sequences are fully compatible with Fusion. You can work with Fusion sequences
      on <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a> if you
      wish to work solely on types
      <sup>[<a name="id456112" href="#ftn.id456112">1</a>]</sup>
      . In <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>, Fusion
      sequences follow <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>'s
      sequence-type preserving semantics (i.e. algorithms preserve the original sequence
      type. e.g. transforming a vector returns a vector). You can also convert from
      an <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a> sequence
      to a Fusion sequence. For example, there are times when it is convenient to
      work solely on <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>
      using pure <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>
      sequences, then, convert them to Fusion sequences as a final step before actual
      instantiation of real runtime objects with data. You have the best of both
      worlds.
      <br />
      Fusion 提供了与 <a href="../../../../mpl/index.html" target="_top">MPL</a> 的完全兼容性。
      Fusion 序列和 <a href="../../../../mpl/index.html" target="_top">MPL</a> 序列完全一致，并且
      <a href="../../../../mpl/index.html" target="_top">MPL</a> 序列完全兼容于 Fusion 序列。
      如果你想要单独操作类型<sup>[<a name="id456112" href="#ftn.id456112">1</a>]</sup>，你可以使用 <a href="../../../../mpl/index.html" target="_top">MPL</a> 工作于 Fusion 序列。
      在 <a href="../../../../mpl/index.html" target="_top">MPL</a> 中，Fusion 序列遵循 <a href="../../../../mpl/index.html" target="_top">MPL</a> 序列类型的保持语义 (即算法保持原始类型，例如转换一个 vector 将返回 vector)。
      你也可以将 <a href="../../../../mpl/index.html" target="_top">MPL</a> 序列转换为 Fusion 序列。
      例如，单独使用 <a href="../../../../mpl/index.html" target="_top">MPL</a> 方便时，可以使用纯 <a href="../../../../mpl/index.html" target="_top">MPL</a> 序列，然后，在实际用数据实例化直接的运行时对象之前，将它们转换为 Fusion 序列。
      这样你就拥有了两个世界的好处。
    </p>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id456112" href="#id456112">1</a>] </sup>
          Choose <a href="http://www.boost.org/libs/mpl/index.html" target="_top">MPL</a>
          over fusion when doing pure type calculations. Once the static type calculation
          is finished, you can instantiate a fusion sequence (see <a href="container/conversion/functions.html" title="Functions">Conversion</a>)
          for the runtime part.
          <br />
          当进行纯粹的类型计算时，选择 <a href="../../../../mpl/index.html" target="_top">MPL</a> 而不是 fusion。
          静态类型计算完成后，可以为运行时部分实例化 fusion 序列 (参见 <a href="container/conversion/functions.html" title="Functions">Conversion</a>).
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001-2007 Joel de Guzman, Dan Marsden, Tobias
      Schwinger<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="preface.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="quick_start.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

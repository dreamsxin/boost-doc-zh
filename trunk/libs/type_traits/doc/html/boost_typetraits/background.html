<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Background and Tutorial &#32972;&#26223;&#21644;&#25351;&#21335;</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.TypeTraits">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.TypeTraits">
<link rel="prev" href="intro.html" title="Introduction &#31616;&#20171;">
<link rel="next" href="category.html" title="Type Traits by Category Type Traits&#20998;&#31867;">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="intro.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="category.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_typetraits.background"></a><a class="link" href="background.html" title="Background and Tutorial &#32972;&#26223;&#21644;&#25351;&#21335;"> Background and Tutorial &#32972;&#26223;&#21644;&#25351;&#21335;</a>
</h2></div></div></div>
<p>
      The following is an updated version of the article "C++ Type traits"
      by John Maddock and Steve Cleary that appeared in the October 2000 issue of
      <a href="http://www.ddj.com" target="_top">Dr Dobb's Journal</a>.<br> &#19979;&#38754;&#26159;
      John Maddock &#21644; Steve Cleary &#21457;&#34920;&#22312; 2000 &#24180; 10 &#26376;&#21495;&#30340; <a href="http://www.ddj.com" target="_top">Dr
      Dobb's Journal</a> &#19978;&#30340;&#25991;&#31456; "C++ Type traits" &#30340;&#20462;&#35746;&#29256;&#12290;
    </p>
<p>
      Generic programming (writing code which works with any data type meeting a
      set of requirements) has become the method of choice for providing reusable
      code. However, there are times in generic programming when "generic"
      just isn't good enough - sometimes the differences between types are too large
      for an efficient generic implementation. This is when the traits technique
      becomes important - by encapsulating those properties that need to be considered
      on a type by type basis inside a traits class, we can minimize the amount of
      code that has to differ from one type to another, and maximize the amount of
      generic code.<br> &#27867;&#22411;&#32534;&#31243;&#65288;&#20889;&#20986;&#30340;&#20195;&#30721;&#21487;&#20197;&#21644;&#20219;&#20309;&#19968;&#31181;&#31526;&#21512;&#19968;&#31995;&#21015;&#35201;&#27714;&#30340;&#25968;&#25454;&#31867;&#22411;&#19968;&#36215;&#24037;&#20316;&#65289;&#24050;&#32463;&#25104;&#20026;&#25552;&#20379;&#21487;&#22797;&#29992;&#20195;&#30721;&#30340;&#39640;&#21697;&#20301;&#36873;&#25321;&#12290;
      &#20294;&#26159;&#65292;&#26377;&#26102;&#27867;&#22411;&#32534;&#31243;&#20013;&#30340;&#8220;&#27867;&#22411;&#8221;&#21364;&#19981;&#22815;&#22909;&#8212;&#8212;&#26377;&#26102;&#19981;&#21516;&#31867;&#22411;&#20043;&#38388;&#30340;&#21306;&#21035;&#22826;&#22823;&#20102;&#65292;&#26080;&#27861;&#25552;&#20379;&#39640;&#25928;&#30340;&#27867;&#22411;&#23454;&#29616;&#12290;
      &#36825;&#23601;&#26159; traits &#25216;&#26415;&#22823;&#23637;&#36523;&#25163;&#30340;&#26102;&#20505;&#8212;&#8212;&#36890;&#36807;&#23558;&#37027;&#20123;&#38656;&#35201;&#32771;&#34385;&#30340;&#22522;&#20110;
      type by type &#30340;&#23646;&#24615;&#23553;&#35013;&#22312;&#19968;&#20010; traits &#31867;&#20013;&#65292;&#25105;&#20204;&#21487;&#20197;&#23558;&#19981;&#24471;&#19981;&#22312;&#19981;&#21516;&#31867;&#22411;&#38388;&#26377;&#25152;&#21306;&#21035;&#30340;&#20195;&#30721;&#37327;&#20943;&#21040;&#26368;&#23567;&#65292;&#24182;&#23558;&#27867;&#22411;&#20195;&#30721;&#37327;&#22686;&#21040;&#26368;&#22823;&#12290;
    </p>
<p>
      Consider an example: when working with character strings, one common operation
      is to determine the length of a null terminated string. Clearly it's possible
      to write generic code that can do this, but it turns out that there are much
      more efficient methods available: for example, the C library functions <code class="computeroutput"><span class="identifier">strlen</span></code> and <code class="computeroutput"><span class="identifier">wcslen</span></code>
      are usually written in assembler, and with suitable hardware support can be
      considerably faster than a generic version written in C++. The authors of the
      C++ standard library realized this, and abstracted the properties of <code class="computeroutput"><span class="keyword">char</span></code> and <code class="computeroutput"><span class="keyword">wchar_t</span></code>
      into the class <code class="computeroutput"><span class="identifier">char_traits</span></code>.
      Generic code that works with character strings can simply use <code class="computeroutput"><span class="identifier">char_traits</span><span class="special">&lt;&gt;::</span><span class="identifier">length</span></code> to determine the length of a null
      terminated string, safe in the knowledge that specializations of <code class="computeroutput"><span class="identifier">char_traits</span></code> will use the most appropriate
      method available to them.<br> &#32771;&#34385;&#19968;&#20010;&#20363;&#23376;&#65306;&#21644;&#23383;&#31526;&#20018;&#19968;&#36215;&#24037;&#20316;&#26102;&#65292;&#19968;&#31181;&#24120;&#35265;&#25805;&#20316;&#26159;&#27979;&#23450;&#20197;
      null &#32467;&#23614;&#30340;&#23383;&#31526;&#20018;&#30340;&#38271;&#24230;&#12290; &#24456;&#26174;&#28982;&#65292;&#20889;&#20986;&#20570;&#36825;&#31181;&#20107;&#24773;&#30340;&#27867;&#22411;&#20195;&#30721;&#26159;&#21487;&#33021;&#30340;&#65292;&#20294;&#26159;&#36824;&#26377;&#24456;&#22810;&#26356;&#26377;&#25928;&#29575;&#30340;&#26041;&#27861;&#21487;&#29992;&#65306;&#20363;&#22914;&#65292;C
      &#24211;&#20989;&#25968; strlen &#21644; wcslen &#36890;&#24120;&#29992;&#27719;&#32534;&#35821;&#35328;&#20889;&#25104;&#65292;&#22312;&#30456;&#24212;&#30340;&#30828;&#20214;&#25903;&#25345;&#19979;&#65292;&#27604;&#29992;
      C++ &#20889;&#30340;&#27867;&#22411;&#29256;&#26412;&#24555;&#24471;&#22810;&#12290; C++ &#26631;&#20934;&#24211;&#30340;&#20316;&#32773;&#35748;&#35782;&#21040;&#20102;&#36825;&#19968;&#28857;&#65292;&#20110;&#26159;&#25277;&#35937;&#20986;
      <code class="computeroutput"><span class="keyword">char</span></code> &#21644; <code class="computeroutput"><span class="keyword">wchar_t</span></code>
      &#30340;&#23646;&#24615;&#25918;&#21040;&#31867; <code class="computeroutput"><span class="identifier">char_traits</span></code>
      &#20013;&#12290; &#21644;&#23383;&#31526;&#20018;&#19968;&#36215;&#24037;&#20316;&#30340;&#27867;&#22411;&#20195;&#30721;&#21482;&#38656;&#35201;&#31616;&#21333;&#22320;&#20351;&#29992; <code class="computeroutput"><span class="identifier">char_traits</span><span class="special">&lt;&gt;::</span><span class="identifier">length</span></code> &#23601;&#21487;&#20197;&#30830;&#23450;&#19968;&#20010;&#20197; null &#32467;&#23614;&#30340;&#23383;&#31526;&#20018;&#30340;&#38271;&#24230;&#65292;&#26681;&#25454;&#32463;&#39564;&#21487;&#20197;&#32943;&#23450;&#65292;<code class="computeroutput"><span class="identifier">char_traits</span></code> &#30340;&#29305;&#21270;&#20351;&#29992;&#20102;&#23545;&#20110;&#23427;&#20204;&#26469;&#35828;&#26368;&#36866;&#21512;&#30340;&#26041;&#27861;&#12290;
    </p>
<a name="boost_typetraits.background.type_traits"></a><h5>
<a name="id5046333"></a>
      <a class="link" href="background.html#boost_typetraits.background.type_traits">Type Traits</a>
    </h5>
<p>
      Class <code class="computeroutput"><span class="identifier">char_traits</span></code> is a classic
      example of a collection of type specific properties wrapped up in a single
      class - what Nathan Myers termed a <span class="emphasis"><em>baggage class</em></span><a class="link" href="background.html#background.references">[1]</a>. In the Boost type-traits library,
      we<a class="link" href="background.html#background.references">[2]</a> have written a set of very
      specific traits classes, each of which encapsulate a single trait from the
      C++ type system; for example, is a type a pointer or a reference type? Or does
      a type have a trivial constructor, or a const-qualifier? The type-traits classes
      share a unified design: each class inherits from a the type <a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a>
      if the type has the specified property and inherits from <a class="link" href="reference/integral_constant.html" title="integral_constant">false_type</a>
      otherwise. As we will show, these classes can be used in generic programming
      to determine the properties of a given type and introduce optimizations that
      are appropriate for that case.<br> &#31867; <code class="computeroutput"><span class="identifier">char_traits</span></code>
      &#26159;&#25910;&#38598;&#31867;&#22411;&#29305;&#23450;&#23646;&#24615;&#24182;&#21253;&#35013;&#21040;&#19968;&#20010;&#21333;&#29420;&#31867;&#20013;&#30340;&#20856;&#22411;&#31034;&#20363;&#8212;&#8212;Nathan
      Myers &#32473;&#20986;&#19968;&#20010;&#26415;&#35821; /&#21253;&#35013;&#31867;(baggage class)/ <a class="link" href="background.html#background.references">[1]</a>&#12290;&#22312;
      Boost type-traits &#24211;&#20013;&#65292;&#25105;&#20204;<a class="link" href="background.html#background.references">[2]</a>&#20889;&#20102;&#19968;&#22871;&#38750;&#24120;&#35814;&#32454;&#30340;
      traits classes&#65288;&#29305;&#24449;&#31867;&#65289;&#65292;&#27599;&#19968;&#20010;&#23553;&#35013;&#19968;&#20010; C++ &#31867;&#22411;&#31995;&#32479;&#30340;&#21333;&#19968;&#29305;&#24449;&#12290;&#20363;&#22914;&#65292;&#26576;&#20010;&#31867;&#22411;&#26159;&#19968;&#20010;&#25351;&#38024;&#36824;&#26159;&#19968;&#20010;&#24341;&#29992;&#31867;&#22411;&#65311;
      &#25110;&#32773;&#26576;&#20010;&#31867;&#22411;&#26159;&#21542;&#26377;&#19968;&#20010; trivial&#65288;&#38750;&#29305;&#27530;&#65289;&#30340;&#26500;&#36896;&#20989;&#25968;&#25110;&#32773;&#26377;&#19968;&#20010;
      const &#20462;&#39280;&#31526;&#65311;&#36825;&#20123; type-traits &#31867;&#20849;&#20139;&#19968;&#20010;&#32479;&#19968;&#30340;&#35774;&#35745;&#65306; &#22914;&#26524;&#36825;&#20010;&#31867;&#22411;&#20855;&#26377;&#29305;&#23450;&#30340;&#23646;&#24615;&#65292;&#21017;&#20174;&#31867;&#22411;
      <a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a>
      &#32487;&#25215;&#65292;&#21542;&#21017;&#20174; <a class="link" href="reference/integral_constant.html" title="integral_constant">false_type</a>
      &#32487;&#25215;&#12290; &#23601;&#20687;&#25105;&#20204;&#23558;&#35201;&#23637;&#31034;&#30340;&#65292;&#36825;&#20123;&#31867;&#21487;&#20197;&#29992;&#22312;&#27867;&#22411;&#32534;&#31243;&#20013;&#65292;&#29992;&#20110;&#30830;&#23450;&#19968;&#20010;&#29305;&#23450;&#31867;&#22411;&#30340;&#23646;&#24615;&#65292;&#24182;&#24341;&#20837;&#26368;&#36866;&#21512;&#37027;&#31181;&#24773;&#20917;&#30340;&#20248;&#21270;&#12290;
    </p>
<p>
      The type-traits library also contains a set of classes that perform a specific
      transformation on a type; for example, they can remove a top-level const or
      volatile qualifier from a type. Each class that performs a transformation defines
      a single typedef-member <code class="computeroutput"><span class="identifier">type</span></code>
      that is the result of the transformation. All of the type-traits classes are
      defined inside namespace <code class="computeroutput"><span class="identifier">boost</span></code>;
      for brevity, namespace-qualification is omitted in most of the code samples
      given.<br> type-traits &#24211;&#36824;&#21253;&#21547;&#19968;&#22871;&#21487;&#20197;&#23545;&#26576;&#20010;&#31867;&#22411;&#25191;&#34892;&#29305;&#23450;&#36716;&#25442;&#30340;&#31867;&#65292;&#20363;&#22914;&#65292;&#20182;&#20204;&#21487;&#20197;&#20174;&#19968;&#20010;&#31867;&#22411;&#20013;&#31227;&#38500;&#19968;&#20010;&#39030;&#23618;&#30340;
      const &#25110; volatile &#20462;&#39280;&#31526;&#12290; &#27599;&#19968;&#20010;&#25191;&#34892;&#36716;&#25442;&#30340;&#31867;&#37117;&#20026;&#36716;&#25442;&#30340;&#32467;&#26524;&#23450;&#20041;&#20102;&#19968;&#20010;&#21333;&#29420;&#30340;
      typedef &#25104;&#21592; <code class="computeroutput"><span class="identifier">type</span></code>&#12290; &#25152;&#26377;
      type-traits &#31867;&#37117;&#23450;&#20041;&#22312;&#21517;&#23383;&#31354;&#38388; <code class="computeroutput"><span class="identifier">boost</span></code>
      &#20013;&#65292;&#20026;&#31616;&#20415;&#36215;&#35265;&#65292;&#22312;&#19979;&#38754;&#32473;&#20986;&#30340;&#22823;&#22810;&#25968;&#20195;&#30721;&#31034;&#20363;&#20013;&#30465;&#30053;&#20102;&#21517;&#23383;&#31354;&#38388;&#38480;&#23450;&#12290;
    </p>
<a name="boost_typetraits.background.implementation_______"></a><h5>
<a name="id5046543"></a>
      <a class="link" href="background.html#boost_typetraits.background.implementation_______">Implementation
      &#23454;&#29616;</a>
    </h5>
<p>
      There are far too many separate classes contained in the type-traits library
      to give a full implementation here - see the source code in the Boost library
      for the full details - however, most of the implementation is fairly repetitive
      anyway, so here we will just give you a flavor for how some of the classes
      are implemented. Beginning with possibly the simplest class in the library,
      <code class="computeroutput"><span class="identifier">is_void</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> inherits
      from <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a></code>
      only if <code class="computeroutput"><span class="identifier">T</span></code> is <code class="computeroutput"><span class="keyword">void</span></code>.<br> &#26377;&#30456;&#24403;&#22810;&#30340;&#29420;&#31435;&#31867;&#21253;&#21547;&#22312;
      type-traits &#24211;&#20013;&#65292;&#35201;&#22312;&#36825;&#37324;&#32473;&#20986;&#19968;&#20010;&#23436;&#25972;&#30340;&#23454;&#29616;&#26159;&#19981;&#21487;&#33021;&#30340;&#8212;&#8212;&#20851;&#20110;&#23436;&#25972;&#30340;&#32454;&#33410;&#21442;&#35265;
      Boost &#24211;&#20013;&#30340;&#28304;&#20195;&#30721;&#8212;&#8212;&#20294;&#26159;&#65292;&#32477;&#22823;&#22810;&#25968;&#23454;&#29616;&#20197;&#21508;&#31181;&#19981;&#21516;&#30340;&#26041;&#24335;&#21453;&#22797;&#20986;&#29616;&#65292;&#25152;&#20197;&#22312;&#36825;&#37324;&#25105;&#20204;&#20165;&#20165;&#32473;&#20320;&#23581;&#19968;&#28857;&#20851;&#20110;&#36825;&#20123;&#31867;&#26159;&#22914;&#20309;&#23454;&#29616;&#30340;&#28363;&#21619;&#12290;
      &#25105;&#20204;&#20174;&#21487;&#33021;&#26159;&#24211;&#20013;&#26368;&#31616;&#21333;&#30340;&#31867; <code class="computeroutput"><span class="identifier">is_void</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
      &#24320;&#22987;&#65292;&#21482;&#26377;&#24403; <code class="computeroutput"><span class="identifier">T</span></code> &#20026;<code class="computeroutput">
      <span class="keyword">void</span></code>&#65292;<code class="computeroutput"><span class="identifier">is_void</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
      &#25165;&#20174; <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a></code>
      &#32487;&#25215;&#12290;
    </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span> 
<span class="keyword">struct</span> <a class="link" href="reference/is_void.html" title="is_void">is_void</a> <span class="special">:</span> <span class="keyword">public</span> <a class="link" href="reference/integral_constant.html" title="integral_constant">false_type</a><span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span> 
<span class="keyword">struct</span> <a class="link" href="reference/is_void.html" title="is_void">is_void</a><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="special">:</span> <span class="keyword">public</span> <a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a><span class="special">{};</span>
</pre>
<p>
      Here we define a primary version of the template class <code class="computeroutput"><a class="link" href="reference/is_void.html" title="is_void">is_void</a></code>,
      and provide a full-specialization when <code class="computeroutput"><span class="identifier">T</span></code>
      is <code class="computeroutput"><span class="keyword">void</span></code>. While full specialization
      of a template class is an important technique, sometimes we need a solution
      that is halfway between a fully generic solution, and a full specialization.
      This is exactly the situation for which the standards committee defined partial
      template-class specialization. As an example, consider the class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_pointer</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>:
      here we needed a primary version that handles all the cases where T is not
      a pointer, and a partial specialization to handle all the cases where T is
      a pointer:<br> &#36825;&#37324;&#25105;&#20204;&#23450;&#20041;&#20102;&#27169;&#26495;&#31867; <code class="computeroutput"><a class="link" href="reference/is_void.html" title="is_void">is_void</a></code>
      &#30340;&#19968;&#20010;&#20027;&#20307;&#29256;&#26412;&#65292;&#24182;&#25552;&#20379;&#20102;&#19968;&#20010; <code class="computeroutput"><span class="identifier">T</span></code>
      &#20026; <code class="computeroutput"><span class="keyword">void</span></code> &#26102;&#30340;&#23436;&#20840;&#29305;&#21270;&#12290;
      &#34429;&#28982;&#27169;&#26495;&#31867;&#30340;&#23436;&#20840;&#29305;&#21270;&#26159;&#19968;&#39033;&#37325;&#35201;&#30340;&#25216;&#26415;&#65292;&#20294;&#26159;&#26377;&#26102;&#25105;&#20204;&#38656;&#35201;&#19968;&#20010;&#20301;&#20110;&#23436;&#20840;&#27867;&#21270;&#21644;&#23436;&#20840;&#29305;&#21270;&#20043;&#38388;&#30340;&#35299;&#20915;&#26041;&#26696;&#12290;
      &#36825;&#27491;&#22909;&#23601;&#26159;&#26631;&#20934;&#22996;&#21592;&#20250;&#23450;&#20041;&#30340; partial template-class specialization&#65288;&#27169;&#26495;&#31867;&#20559;&#29305;&#21270;&#65289;&#30340;&#29992;&#27494;&#20043;&#22320;&#12290;
      &#20363;&#22914;&#65292;&#32771;&#34385;&#31867; <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_pointer</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>&#65306;&#25105;&#20204;&#38656;&#35201;&#19968;&#20010;&#20027;&#20307;&#29256;&#26412;&#29992;&#26469;&#22788;&#29702;
      T &#19981;&#26159;&#19968;&#20010;&#25351;&#38024;&#26102;&#30340;&#25152;&#26377;&#24773;&#20917;&#65292;&#21644;&#19968;&#20010;&#20559;&#29305;&#21270;&#29256;&#26412;&#29992;&#26469;&#22788;&#29702;
      T &#26159;&#19968;&#20010;&#25351;&#38024;&#26102;&#30340;&#25152;&#26377;&#24773;&#20917;&#65306;
    </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span> 
<span class="keyword">struct</span> <a class="link" href="reference/is_pointer.html" title="is_pointer">is_pointer</a> <span class="special">:</span> <span class="keyword">public</span> <a class="link" href="reference/integral_constant.html" title="integral_constant">false_type</a><span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span> 
<span class="keyword">struct</span> <a class="link" href="reference/is_pointer.html" title="is_pointer">is_pointer</a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">*&gt;</span> <span class="special">:</span> <span class="keyword">public</span> <a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a><span class="special">{};</span>
</pre>
<p>
      The syntax for partial specialization is somewhat arcane and could easily occupy
      an article in its own right; like full specialization, in order to write a
      partial specialization for a class, you must first declare the primary template.
      The partial specialization contains an extra &lt;...&gt; after the class name
      that contains the partial specialization parameters; these define the types
      that will bind to that partial specialization rather than the default template.
      The rules for what can appear in a partial specialization are somewhat convoluted,
      but as a rule of thumb if you can legally write two function overloads of the
      form:<br> &#20559;&#29305;&#21270;&#30340;&#35821;&#27861;&#22810;&#23569;&#26377;&#20123;&#26214;&#28073;&#65292;&#32780;&#19988;&#22914;&#26524;&#35201;&#20840;&#38754;&#20171;&#32461;&#23427;&#21487;&#33021;&#20250;&#21344;&#25454;&#19968;&#31687;&#25991;&#31456;&#30340;&#31687;&#24133;&#65292;&#21644;&#23436;&#20840;&#29305;&#21270;&#19968;&#26679;&#65292;&#20026;&#19968;&#20010;&#31867;&#20889;&#19968;&#20010;&#20559;&#29305;&#21270;&#65292;&#20320;&#24517;&#39035;&#20808;&#22768;&#26126;&#20027;&#20307;&#27169;&#26495;&#12290;
      &#20559;&#29305;&#21270;&#22312;&#31867;&#21517;&#20043;&#21518;&#26377;&#19968;&#20010;&#39069;&#22806;&#30340; &lt;...&gt; &#29992;&#26469;&#21253;&#21547;&#20559;&#29305;&#21270;&#21442;&#25968;&#65292;&#36825;&#20123;&#34920;&#26126;&#36825;&#20010;&#31867;&#22411;&#23558;&#34987;&#32465;&#23450;&#21040;&#20559;&#29305;&#21270;&#29256;&#26412;&#32780;&#19981;&#26159;&#32570;&#30465;&#29256;&#26412;&#12290;
      &#23545;&#20110;&#20160;&#20040;&#19996;&#35199;&#33021;&#22815;&#20986;&#29616;&#22312;&#20559;&#29305;&#21270;&#29256;&#26412;&#20013;&#30340;&#35268;&#21017;&#22810;&#23569;&#26377;&#20123;&#36153;&#35299;&#65292;&#20294;&#26159;&#20316;&#20026;&#19968;&#26465;&#32463;&#39564;&#27861;&#21017;&#65292;&#22914;&#26524;&#20320;&#33021;&#20889;&#20986;&#22914;&#19979;&#24418;&#24335;&#30340;&#20004;&#20010;&#21512;&#27861;&#30340;&#20989;&#25968;&#37325;&#36733;&#65306;
    </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">T</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">U</span><span class="special">);</span>
</pre>
<p>
      Then you can also write a partial specialization of the form:<br> &#20320;&#23601;&#33021;&#20889;&#20986;&#22914;&#19979;&#24418;&#24335;&#30340;&#20559;&#29305;&#21270;&#65306;
    </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">c</span><span class="special">{</span> <span class="comment">/*details*/</span> <span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">c</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;{</span> <span class="comment">/*details*/</span> <span class="special">};</span>
</pre>
<p>
      This rule is by no means foolproof, but it is reasonably simple to remember
      and close enough to the actual rule to be useful for everyday use.<br> &#36825;&#20010;&#35268;&#21017;&#30456;&#24403;&#31616;&#21333;&#65292;&#20294;&#26159;&#23427;&#27604;&#36739;&#23481;&#26131;&#35760;&#20303;&#24182;&#38750;&#24120;&#25509;&#36817;&#23454;&#38469;&#35268;&#21017;&#65292;&#36866;&#21512;&#26085;&#24120;&#20351;&#29992;&#12290;
    </p>
<p>
      As a more complex example of partial specialization consider the class <code class="computeroutput"><span class="identifier">remove_extent</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>. This
      class defines a single typedef-member <code class="computeroutput"><span class="identifier">type</span></code>
      that is the same type as T but with any top-level array bounds removed; this
      is an example of a traits class that performs a transformation on a type:<br>
      &#20030;&#19968;&#20010;&#26356;&#22797;&#26434;&#30340;&#20559;&#29305;&#21270;&#30340;&#20363;&#23376;&#65292;&#32771;&#34385;&#31867; <code class="computeroutput"><span class="identifier">remove_extent</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>&#12290;&#36825;&#20010;&#31867;&#21482;&#23450;&#20041;&#19968;&#20010;&#21807;&#19968;&#30340;
      typedef &#25104;&#21592; <code class="computeroutput"><span class="identifier">type</span></code>&#65292;&#23427;&#21644;
      T &#26159;&#21516;&#19968;&#20010;&#31867;&#22411;&#65292;&#20294;&#20250;&#31227;&#38500;&#20219;&#20309;&#39030;&#23618;&#25968;&#32452;&#30340;&#30028;&#38480;&#65292;&#36825;&#26159;&#19968;&#20010;&#22312;&#19968;&#20010;&#23545;&#26576;&#20010;&#31867;&#22411;&#25191;&#34892;&#36716;&#25442;&#30340;
      traits &#31867;&#30340;&#20363;&#23376;&#65306;
    </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span> 
<span class="keyword">struct</span> <a class="link" href="reference/remove_extent.html" title="remove_extent">remove_extent</a>
<span class="special">{</span> <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">type</span><span class="special">;</span> <span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">N</span><span class="special">&gt;</span> 
<span class="keyword">struct</span> <a class="link" href="reference/remove_extent.html" title="remove_extent">remove_extent</a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">[</span><span class="identifier">N</span><span class="special">]&gt;</span>
<span class="special">{</span> <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">type</span><span class="special">;</span> <span class="special">};</span>
</pre>
<p>
      The aim of <code class="computeroutput"><a class="link" href="reference/remove_extent.html" title="remove_extent">remove_extent</a></code>
      is this: imagine a generic algorithm that is passed an array type as a template
      parameter, <code class="computeroutput"><a class="link" href="reference/remove_extent.html" title="remove_extent">remove_extent</a></code>
      provides a means of determining the underlying type of the array. For example
      <code class="computeroutput"><span class="identifier">remove_extent</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">[</span><span class="number">4</span><span class="special">][</span><span class="number">5</span><span class="special">]&gt;::</span><span class="identifier">type</span></code> would evaluate to the type <code class="computeroutput"><span class="keyword">int</span><span class="special">[</span><span class="number">5</span><span class="special">]</span></code>. This example also shows that the number of
      template parameters in a partial specialization does not have to match the
      number in the default template. However, the number of parameters that appear
      after the class name do have to match the number and type of the parameters
      in the default template.<br> <code class="computeroutput"><a class="link" href="reference/remove_extent.html" title="remove_extent">remove_extent</a></code>
      &#30340;&#30446;&#30340;&#26159;&#65306;&#35774;&#24819;&#19968;&#20010;&#27867;&#22411;&#31639;&#27861;&#34987;&#20256;&#36882;&#36807;&#26469;&#19968;&#20010;&#25968;&#32452;&#31867;&#22411;&#20316;&#20026;&#27169;&#26495;&#21442;&#25968;&#65292;<code class="computeroutput"><a class="link" href="reference/remove_extent.html" title="remove_extent">remove_extent</a></code>
      &#25552;&#20379;&#20102;&#19968;&#20010;&#26816;&#27979;&#36825;&#20010;&#25968;&#32452;&#30340;&#24213;&#23618;&#31867;&#22411;&#30340;&#25163;&#27573;&#12290;&#20363;&#22914; <code class="computeroutput"><span class="identifier">remove_extent</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">[</span><span class="number">4</span><span class="special">][</span><span class="number">5</span><span class="special">]&gt;::</span><span class="identifier">type</span></code> &#20250;&#34987;&#26816;&#27979;&#20986;&#31867;&#22411; <code class="computeroutput"><span class="keyword">int</span><span class="special">[</span><span class="number">5</span><span class="special">]</span></code>&#12290; &#36825;&#20010;&#20363;&#23376;&#20063;&#23637;&#31034;&#20102;&#20559;&#29305;&#21270;&#20013;&#30340;&#27169;&#26495;&#21442;&#25968;&#30340;&#20010;&#25968;&#21644;&#32570;&#30465;&#27169;&#26495;&#20013;&#30340;&#20010;&#25968;&#19981;&#24517;&#30456;&#21516;&#12290;
      &#20294;&#26159;&#65292;&#20986;&#29616;&#22312;&#31867;&#21517;&#21518;&#38754;&#30340;&#21442;&#25968;&#30340;&#20010;&#25968;&#21644;&#31867;&#22411;&#24517;&#39035;&#21644;&#32570;&#30465;&#27169;&#26495;&#30340;&#21442;&#25968;&#30340;&#20010;&#25968;&#21644;&#31867;&#22411;&#30456;&#21516;&#12290;
    </p>
<a name="boost_typetraits.background.optimized_copy_____________"></a><h5>
<a name="id5044390"></a>
      <a class="link" href="background.html#boost_typetraits.background.optimized_copy_____________">Optimized
      copy &#20248;&#21270;&#22797;&#21046;</a>
    </h5>
<p>
      As an example of how the type traits classes can be used, consider the standard
      library algorithm copy:<br> &#32473;&#19968;&#20010; type traits &#31867;&#22914;&#20309;&#20351;&#29992;&#30340;&#20363;&#23376;&#65292;&#32771;&#34385;&#27169;&#26495;&#24211;&#31639;&#27861;
      copy&#65306;
    </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iter1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Iter2</span><span class="special">&gt;</span>
<span class="identifier">Iter2</span> <span class="identifier">copy</span><span class="special">(</span><span class="identifier">Iter1</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iter1</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">Iter2</span> <span class="identifier">out</span><span class="special">);</span>
</pre>
<p>
      Obviously, there's no problem writing a generic version of copy that works
      for all iterator types <code class="computeroutput"><span class="identifier">Iter1</span></code>
      and <code class="computeroutput"><span class="identifier">Iter2</span></code>; however, there are
      some circumstances when the copy operation can best be performed by a call
      to <code class="computeroutput"><span class="identifier">memcpy</span></code>. In order to implement
      copy in terms of <code class="computeroutput"><span class="identifier">memcpy</span></code> all
      of the following conditions need to be met:<br> &#24456;&#26126;&#26174;&#65292;&#20889;&#19968;&#20010;&#36866;&#29992;&#20110;&#25152;&#26377;&#36845;&#20195;&#22120;&#31867;&#22411;
      <code class="computeroutput"><span class="identifier">Iter1</span></code> &#21644; <code class="computeroutput"><span class="identifier">Iter2</span></code>
      &#30340;&#27867;&#22411;&#29256;&#26412;&#27809;&#26377;&#38382;&#39064;&#65292;&#20294;&#26159;&#65292;&#22312;&#19968;&#20123;&#24773;&#24418;&#65292;&#26368;&#22909;&#33021;&#36890;&#36807;&#35843;&#29992;
      <code class="computeroutput"><span class="identifier">memcpy</span></code> &#26469;&#25191;&#34892;&#25335;&#36125;&#25805;&#20316;&#12290;
      &#20026;&#20102;&#20351;&#29992; <code class="computeroutput"><span class="identifier">memcpy</span></code> &#25191;&#34892;&#25335;&#36125;&#65292;&#38656;&#35201;&#28385;&#36275;&#19979;&#38754;&#30340;&#25152;&#26377;&#26465;&#20214;&#65306;
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Both of the iterator types <code class="computeroutput"><span class="identifier">Iter1</span></code>
          and <code class="computeroutput"><span class="identifier">Iter2</span></code> must be pointers.
          <br> &#36845;&#20195;&#22120;&#31867;&#22411; <code class="computeroutput"><span class="identifier">Iter1</span></code>
          &#21644; <code class="computeroutput"><span class="identifier">Iter2</span></code> &#24517;&#39035;&#37117;&#26159;&#25351;&#38024;&#12290;
        </li>
<li class="listitem">
          Both <code class="computeroutput"><span class="identifier">Iter1</span></code> and <code class="computeroutput"><span class="identifier">Iter2</span></code> must point to the same type - excluding
          const and volatile-qualifiers. <br> <code class="computeroutput"><span class="identifier">Iter1</span></code>
          &#21644; <code class="computeroutput"><span class="identifier">Iter2</span></code> &#24517;&#39035;&#37117;&#25351;&#21521;&#21516;&#26679;&#30340;&#31867;&#22411;&#8212;&#8212;
          const &#21644; volatile &#20462;&#39280;&#31526;&#21487;&#19981;&#20104;&#32771;&#34385;&#12290;
        </li>
<li class="listitem">
          The type pointed to by <code class="computeroutput"><span class="identifier">Iter1</span></code>
          must have a trivial assignment operator. <br> &#34987; <code class="computeroutput"><span class="identifier">Iter1</span></code>
          &#25351;&#21521;&#30340;&#31867;&#22411;&#24517;&#39035;&#26377;&#19968;&#20010; trivial&#65288;&#19981;&#29305;&#27530;&#65289;&#30340;&#36171;&#20540;&#25805;&#20316;&#31526;&#12290;
        </li>
</ul></div>
<p>
      By trivial assignment operator we mean that the type is either a scalar type<a class="link" href="background.html#background.references">[3]</a> or:<br> &#25152;&#35859; trivial&#65288;&#38750;&#29305;&#27530;&#65289;&#30340;&#36171;&#20540;&#25805;&#20316;&#31526;&#65292;&#25105;&#20204;&#25351;&#30340;&#26159;&#36825;&#20010;&#31867;&#22411;&#35201;&#20040;&#26159;&#19968;&#20010;
      scalar type&#65288;&#26631;&#37327;&#31867;&#22411;&#65289;<a class="link" href="background.html#background.references">[3]</a>
      &#35201;&#20040;&#65306;
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          The type has no user defined assignment operator. <br> &#36825;&#20010;&#31867;&#22411;&#27809;&#26377;&#29992;&#25143;&#23450;&#20041;&#30340;&#36171;&#20540;&#25805;&#20316;&#31526;&#12290;
        </li>
<li class="listitem">
          The type does not have any data members that are references. <br> &#36825;&#20010;&#31867;&#22411;&#27809;&#26377;&#20219;&#20309;&#19968;&#20010;&#25968;&#25454;&#25104;&#21592;&#26159;&#24341;&#29992;&#12290;
        </li>
<li class="listitem">
          All base classes, and all data member objects must have trivial assignment
          operators. <br> &#25152;&#26377;&#30340;&#22522;&#31867;&#65292;&#25110;&#25152;&#26377;&#25968;&#25454;&#25104;&#21592;&#23545;&#35937;&#24517;&#39035;&#26377;
          trivial&#65288;&#38750;&#29305;&#27530;&#65289;&#30340;&#36171;&#20540;&#25805;&#20316;&#31526;&#12290;
        </li>
</ul></div>
<p>
      If all these conditions are met then a type can be copied using <code class="computeroutput"><span class="identifier">memcpy</span></code> rather than using a compiler generated
      assignment operator. The type-traits library provides a class <code class="computeroutput"><a class="link" href="reference/has_trivial_assign.html" title="has_trivial_assign">has_trivial_assign</a></code>,
      such that <code class="computeroutput"><span class="identifier">has_trivial_assign</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span></code> is true only if T has a trivial assignment
      operator. This class "just works" for scalar types, but has to be
      explicitly specialised for class/struct types that also happen to have a trivial
      assignment operator. In other words if <a class="link" href="reference/has_trivial_assign.html" title="has_trivial_assign">has_trivial_assign</a>
      gives the wrong answer, it will give the "safe" wrong answer - that
      trivial assignment is not allowable.<br> &#22914;&#26524;&#36825;&#20123;&#26465;&#20214;&#37117;&#34987;&#28385;&#36275;&#65292;&#37027;&#20040;&#36825;&#20010;&#31867;&#22411;&#23601;&#21487;&#20197;&#29992;
      <code class="computeroutput"><span class="identifier">memcpy</span></code> &#25191;&#34892;&#25335;&#36125;&#65292;&#32780;&#19981;&#20351;&#29992;&#32534;&#35793;&#22120;&#29983;&#25104;&#30340;&#36171;&#20540;&#25805;&#20316;&#31526;&#12290;
      type-traits &#24211;&#25552;&#20379;&#20102;&#19968;&#20010;&#31867; <code class="computeroutput"><a class="link" href="reference/has_trivial_assign.html" title="has_trivial_assign">has_trivial_assign</a></code>&#65292;&#23427;&#30340;&#24847;&#24605;&#26159;&#21482;&#26377;
      T &#26377;&#19968;&#20010; trivial&#65288;&#19981;&#29305;&#27530;&#65289; &#30340;&#36171;&#20540;&#25805;&#20316;&#31526;&#65292;<code class="computeroutput"><span class="identifier">has_trivial_assign</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span></code> &#25165;&#25104;&#31435;&#12290;&#36825;&#20010;&#31867;&#20165;&#23545;&#26631;&#37327;&#31867;&#22411;&#33021;&#8220;&#27491;&#30830;&#22320;&#24037;&#20316;&#8221;&#65292;&#38500;&#38750;&#20026;&#20855;&#26377;&#19968;&#20010;
      trivial&#65288;&#38750;&#29305;&#27530;&#65289;&#30340;&#36171;&#20540;&#25805;&#20316;&#31526;&#30340; class/struct &#31867;&#22411;&#36827;&#34892;&#26174;&#24335;&#29305;&#21270;&#12290;
      &#25442;&#21477;&#35805;&#35828;&#65292;&#22914;&#26524; <a class="link" href="reference/has_trivial_assign.html" title="has_trivial_assign">has_trivial_assign</a>
      &#32473;&#20986;&#19968;&#20010;&#38169;&#35823;&#31572;&#26696;&#65292;&#23427;&#20250;&#32473;&#20986;&#19968;&#20010;&#8220;&#23433;&#20840;&#30340;&#8221;&#38169;&#35823;&#31572;&#26696;&#8212;&#8212;&#37027;&#20010;
      trivial&#65288;&#38750;&#29305;&#27530;&#65289;&#30340;&#36171;&#20540;&#26159;&#19981;&#34987;&#20801;&#35768;&#30340;&#12290;
    </p>
<p>
      The code for an optimized version of copy that uses <code class="computeroutput"><span class="identifier">memcpy</span></code>
      where appropriate is given in <a class="link" href="examples/copy.html" title="An Optimized Version of std::copy &#19968;&#20010;&#20248;&#21270;&#29256;&#26412;&#30340;std::copy">the
      examples</a>. The code begins by defining a template function <code class="computeroutput"><span class="identifier">do_copy</span></code> that performs a "slow but safe"
      copy. The last parameter passed to this function may be either a <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a></code>
      or a <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">false_type</a></code>.
      Following that there is an overload of <code class="computeroutput"><span class="identifier">do_copy</span></code>
      that uses <code class="computeroutput"><span class="identifier">memcpy</span></code>: this time
      the iterators are required to actually be pointers to the same type, and the
      final parameter must be a <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a></code>.
      Finally, the version of <code class="computeroutput"><span class="identifier">copy</span></code>
      calls <code class="computeroutput"><span class="identifier">do_copy</span></code>, passing <code class="computeroutput"><a class="link" href="reference/has_trivial_assign.html" title="has_trivial_assign">has_trivial_assign</a><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;()</span></code> as the final parameter: this will dispatch
      to the optimized version where appropriate, otherwise it will call the "slow
      but safe version".<br> &#20351;&#29992; <code class="computeroutput"><span class="identifier">memcpy</span></code>
      &#30340; copy &#30340;&#20248;&#21270;&#29256;&#26412;&#20195;&#30721;&#22312; <a class="link" href="examples/copy.html" title="An Optimized Version of std::copy &#19968;&#20010;&#20248;&#21270;&#29256;&#26412;&#30340;std::copy">&#31034;&#20363;</a>
      &#20013;&#32473;&#20986;&#12290; &#20195;&#30721;&#20197;&#23450;&#20041;&#19968;&#20010;&#27169;&#26495;&#20989;&#25968; <code class="computeroutput"><span class="identifier">do_copy</span></code>
      &#24320;&#22987;&#65292;&#36825;&#20010;&#20989;&#25968;&#25191;&#34892;&#19968;&#20010;&#8220;&#24930;&#20294;&#26159;&#23433;&#20840;&#8221;&#30340;&#25335;&#36125;&#12290; &#20256;&#32473;&#36825;&#20010;&#20989;&#25968;&#30340;&#26368;&#21518;&#19968;&#20010;&#21442;&#25968;&#26082;&#21487;&#33021;&#26159;&#19968;&#20010;
      <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a></code>&#65292;&#20063;&#21487;&#33021;&#26159;&#19968;&#20010;
      <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">false_type</a></code>&#12290;
      &#28982;&#21518;&#26377;&#19968;&#20010;&#20351;&#29992; <code class="computeroutput"><span class="identifier">memcpy</span></code>
      &#30340; <code class="computeroutput"><span class="identifier">do_copy</span></code> &#30340;&#37325;&#36733;&#65306;&#36825;&#26102;&#35201;&#27714;&#36845;&#20195;&#22120;&#23454;&#38469;&#19978;&#26159;&#19968;&#20010;&#25351;&#21521;&#30456;&#21516;&#31867;&#22411;&#30340;&#25351;&#38024;&#65292;&#32780;&#19988;&#26368;&#21518;&#19968;&#20010;&#21442;&#25968;&#24517;&#39035;&#26159;&#19968;&#20010;
      <code class="computeroutput"><a class="link" href="reference/integral_constant.html" title="integral_constant">true_type</a></code>&#12290;
      &#26368;&#21518;&#65292;<code class="computeroutput"><span class="identifier">copy</span></code> &#30340;&#36825;&#20010;&#29256;&#26412;&#35843;&#29992;
      <code class="computeroutput"><span class="identifier">do_copy</span></code>&#65292;&#23558; <code class="computeroutput"><a class="link" href="reference/has_trivial_assign.html" title="has_trivial_assign">has_trivial_assign</a><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;()</span></code> &#20316;&#20026;&#26368;&#21518;&#19968;&#20010;&#21442;&#25968;&#12290; &#22914;&#26524;&#20248;&#21270;&#29256;&#26412;&#26356;&#21512;&#36866;&#23601;&#20250;&#21305;&#37197;&#21040;&#20248;&#21270;&#29256;&#26412;&#65292;&#21542;&#21017;&#23601;&#35843;&#29992;&#8220;&#24930;&#20294;&#26159;&#23433;&#20840;&#30340;&#29256;&#26412;&#8221;&#12290;
    </p>
<a name="boost_typetraits.background.was_it_worth_it_______________________"></a><h5>
<a name="id5045274"></a>
      <a class="link" href="background.html#boost_typetraits.background.was_it_worth_it_______________________">Was
      it worth it? &#36825;&#26159;&#20540;&#24471;&#30340;&#21527;&#65311;</a>
    </h5>
<p>
      It has often been repeated in these columns that "premature optimization
      is the root of all evil" <a class="link" href="background.html#background.references">[4]</a>.
      So the question must be asked: was our optimization premature? To put this
      in perspective the timings for our version of copy compared a conventional
      generic copy<a class="link" href="background.html#background.references">[5]</a> are shown in table
      1.<br> &#26377;&#19968;&#21477;&#21517;&#35328;&#32463;&#24120;&#34987;&#37325;&#22797;&#25552;&#21040;&#65306;&#8220;&#19981;&#25104;&#29087;&#30340;&#20248;&#21270;&#26159;&#19968;&#20999;&#32618;&#24694;&#30340;&#26681;&#28304;&#8221;
      <a class="link" href="background.html#background.references">[4]</a>&#12290; &#25152;&#20197;&#24517;&#39035;&#35201;&#38382;&#65306;&#25105;&#20204;&#30340;&#20248;&#21270;&#26159;&#25104;&#29087;&#30340;&#21527;&#65311;&#25105;&#20204;&#29256;&#26412;&#30340;
      copy &#21644;&#20256;&#32479;&#27867;&#22411; copy <a class="link" href="background.html#background.references">[5]</a>
      &#30340;&#26102;&#38388;&#27604;&#36739;&#23637;&#31034;&#22312;&#34920;1&#20013;&#12290;
    </p>
<p>
      Clearly the optimization makes a difference in this case; but, to be fair,
      the timings are loaded to exclude cache miss effects - without this accurate
      comparison between algorithms becomes difficult. However, perhaps we can add
      a couple of caveats to the premature optimization rule:<br> &#24456;&#26126;&#26174;&#65292;&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#20248;&#21270;&#36896;&#25104;&#20102;&#21306;&#21035;&#65292;&#20294;&#26159;&#65292;&#20026;&#20102;&#20844;&#24179;&#65292;&#34920;&#20013;&#30340;&#26102;&#38388;&#25490;&#38500;&#20102;&#32531;&#23384;&#22833;&#35823;&#30340;&#24433;&#21709;
      &#8212;&#8212; &#22914;&#26524;&#19981;&#25490;&#38500;&#36825;&#19968;&#28857;&#65292;&#31639;&#27861;&#30340;&#31934;&#30830;&#27604;&#36739;&#26159;&#24456;&#22256;&#38590;&#30340;&#12290;&#26080;&#35770;&#22914;&#20309;&#65292;&#20063;&#35768;&#25105;&#20204;&#21487;&#20197;&#22686;&#21152;&#19968;&#20123;&#21578;&#35819;&#65292;&#20316;&#20026;&#21028;&#21035;&#19981;&#25104;&#29087;&#20248;&#21270;&#30340;&#27861;&#21017;&#65306;
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          If you use the right algorithm for the job in the first place then optimization
          will not be required; in some cases, memcpy is the right algorithm. <br>
          &#22914;&#26524;&#20320;&#19968;&#19978;&#26469;&#23601;&#20351;&#29992;&#20102;&#23545;&#20110;&#36825;&#20010;&#20219;&#21153;&#27491;&#30830;&#30340;&#31639;&#27861;&#65292;&#37027;&#20040;&#23601;&#19981;&#38656;&#35201;&#20248;&#21270;&#65292;&#22312;&#26576;&#20123;&#24773;&#20917;&#19979;&#65292;memcpy
          &#26159;&#27491;&#30830;&#30340;&#31639;&#27861;&#12290;
        </li>
<li class="listitem">
          If a component is going to be reused in many places by many people then
          optimizations may well be worthwhile where they would not be so for a single
          case - in other words, the likelihood that the optimization will be absolutely
          necessary somewhere, sometime is that much higher. Just as importantly
          the perceived value of the stock implementation will be higher: there is
          no point standardizing an algorithm if users reject it on the grounds that
          there are better, more heavily optimized versions available. <br> &#22914;&#26524;&#19968;&#20010;&#32452;&#20214;&#34987;&#24456;&#22810;&#20154;&#22312;&#24456;&#22810;&#22320;&#26041;&#22797;&#29992;&#65292;&#37027;&#20040;&#20248;&#21270;&#23601;&#26159;&#20540;&#24471;&#30340;&#65292;&#21363;&#20351;&#23545;&#20854;&#20013;&#30340;&#21333;&#29420;&#19968;&#31181;&#24773;&#20917;&#26469;&#35828;&#20063;&#35768;&#27809;&#26377;&#24517;&#35201;
          &#8212;&#8212; &#25442;&#21477;&#35805;&#35828;&#65292;&#20248;&#21270;&#22312;&#26159;&#26576;&#22320;&#26159;&#32477;&#23545;&#24517;&#35201;&#30340;&#36825;&#31181;&#21487;&#33021;&#24615;&#36824;&#26159;&#27604;&#36739;&#39640;&#30340;&#12290;
          &#19968;&#20010;&#24120;&#22791;&#23454;&#29616;&#30340;&#21487;&#24863;&#30693;&#20215;&#20540;&#24212;&#35813;&#27604;&#36739;&#39640;&#65292;&#36825;&#26159;&#38750;&#24120;&#37325;&#35201;&#30340;&#65306;&#22914;&#26524;&#29992;&#25143;&#24403;&#22330;&#25298;&#32477;&#19968;&#20010;&#31639;&#27861;&#65292;&#32780;&#20351;&#29992;&#26356;&#22909;&#30340;&#65292;
          &#20248;&#21270;&#24230;&#26356;&#39640;&#30340;&#29256;&#26412;&#65292;&#37027;&#20040;&#26631;&#20934;&#21270;&#36825;&#20010;&#31639;&#27861;&#23601;&#26159;&#27627;&#26080;&#36947;&#29702;&#30340;&#12290;
        </li>
</ul></div>
<div class="table">
<a name="id5096654"></a><p class="title"><b>Table&#160;1.1.&#160;Time taken to copy 1000 elements using `copy&lt;const T*, T*&gt;` (times
      in micro-seconds) &#20351;&#29992; copy&lt;const T*, T*&gt; &#25335;&#36125;1000&#20010;&#20803;&#32032;&#33457;&#36153;&#30340;&#26102;&#38388;(&#24494;&#31186;)</b></p>
<div class="table-contents"><table class="table" summary="Time taken to copy 1000 elements using `copy&lt;const T*, T*&gt;` (times
      in micro-seconds) &#20351;&#29992; copy&lt;const T*, T*&gt; &#25335;&#36125;1000&#20010;&#20803;&#32032;&#33457;&#36153;&#30340;&#26102;&#38388;(&#24494;&#31186;)">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Version &#29256;&#26412;
              </p>
            </th>
<th>
              <p>
                T
              </p>
            </th>
<th>
              <p>
                Time &#26102;&#38388;
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                "Optimized" copy "&#20248;&#21270;"&#22797;&#21046;
              </p>
            </td>
<td>
              <p>
                char
              </p>
            </td>
<td>
              <p>
                0.99
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Conventional copy &#27491;&#24120;&#22797;&#21046;
              </p>
            </td>
<td>
              <p>
                char
              </p>
            </td>
<td>
              <p>
                8.07
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                "Optimized" copy "&#20248;&#21270;"&#22797;&#21046;
              </p>
            </td>
<td>
              <p>
                int
              </p>
            </td>
<td>
              <p>
                2.52
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Conventional copy &#27491;&#24120;&#22797;&#21046;
              </p>
            </td>
<td>
              <p>
                int
              </p>
            </td>
<td>
              <p>
                8.02
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><a name="boost_typetraits.background.pair_of_references___________pair"></a><h5>
<a name="id5096815"></a>
      <a class="link" href="background.html#boost_typetraits.background.pair_of_references___________pair">Pair
      of References &#24341;&#29992;&#30340; Pair</a>
    </h5>
<p>
      The optimized copy example shows how type traits may be used to perform optimization
      decisions at compile-time. Another important usage of type traits is to allow
      code to compile that otherwise would not do so unless excessive partial specialization
      is used. This is possible by delegating partial specialization to the type
      traits classes. Our example for this form of usage is a pair that can hold
      references <a class="link" href="background.html#background.references">[6]</a>.<br> &#20248;&#21270;&#25335;&#36125;&#31034;&#20363;&#23637;&#31034;&#20102;
      type traits &#22914;&#20309;&#34987;&#29992;&#20110;&#32534;&#35793;&#26102;&#30340;&#20248;&#21270;&#20915;&#31574;&#12290; type traits &#30340;&#21478;&#19968;&#20010;&#37325;&#35201;&#29992;&#36884;&#26159;&#26159;&#20801;&#35768;&#37027;&#20123;&#22914;&#26524;&#19981;&#20351;&#29992;&#39069;&#22806;&#30340;&#20559;&#29305;&#21270;&#23601;&#26080;&#27861;&#32534;&#35793;&#30340;&#20195;&#30721;&#33021;&#22815;&#32534;&#35793;&#12290;
      &#36890;&#36807;&#23558;&#20559;&#29305;&#21270;&#22996;&#25176;&#32473; type traits &#31867;&#65292;&#23601;&#21487;&#33021;&#20570;&#21040;&#36825;&#19968;&#28857;&#12290; &#25105;&#20204;&#20026;&#36825;&#31181;&#20351;&#29992;&#26041;&#24335;&#25552;&#20379;&#30340;&#31034;&#20363;&#26159;&#19968;&#20010;&#21487;&#20197;&#25345;&#26377;&#24341;&#29992;&#30340;
      pair <a class="link" href="background.html#background.references">[6]</a>&#12290;
    </p>
<p>
      First, let us examine the definition of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>, omitting
      the comparison operators, default constructor, and template copy constructor
      for simplicity:<br> &#39318;&#20808;&#65292;&#25105;&#20204;&#20808;&#26816;&#26597;&#19968;&#19979; <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code> &#30340;&#23450;&#20041;&#65292;&#20026;&#20102;&#31616;&#21333;&#65292;&#25105;&#20204;&#24573;&#30053;&#27604;&#36739;&#25805;&#20316;&#31526;&#65292;&#32570;&#30465;&#26500;&#36896;&#20989;&#25968;&#21644;&#27169;&#26495;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#65306;
    </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span> 
<span class="keyword">struct</span> <span class="identifier">pair</span> 
<span class="special">{</span>
<span class="keyword">typedef</span> <span class="identifier">T1</span> <span class="identifier">first_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">T2</span> <span class="identifier">second_type</span><span class="special">;</span>

<span class="identifier">T1</span> <span class="identifier">first</span><span class="special">;</span>
<span class="identifier">T2</span> <span class="identifier">second</span><span class="special">;</span>

<span class="identifier">pair</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T1</span> <span class="special">&amp;</span> <span class="identifier">nfirst</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T2</span> <span class="special">&amp;</span> <span class="identifier">nsecond</span><span class="special">)</span>
<span class="special">:</span><span class="identifier">first</span><span class="special">(</span><span class="identifier">nfirst</span><span class="special">),</span> <span class="identifier">second</span><span class="special">(</span><span class="identifier">nsecond</span><span class="special">)</span> <span class="special">{</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      Now, this "pair" cannot hold references as it currently stands, because
      the constructor would require taking a reference to a reference, which is currently
      illegal <a class="link" href="background.html#background.references">[7]</a>. Let us consider what
      the constructor's parameters would have to be in order to allow "pair"
      to hold non-reference types, references, and constant references:<br> &#29616;&#22312;&#65292;&#36825;&#20010;
      "pair" &#19981;&#33021;&#25345;&#26377;&#24341;&#29992;&#20316;&#20026;&#23427;&#30340;&#24403;&#21069;&#25903;&#28857;&#65292;&#22240;&#20026;&#36825;&#26679;&#19968;&#26469;&#26500;&#36896;&#20989;&#25968;&#23601;&#35201;&#25509;&#21463;&#19968;&#20010;&#24341;&#29992;&#30340;&#24341;&#29992;&#65292;&#36825;&#22312;&#24403;&#21069;&#26159;&#38750;&#27861;&#30340;
      <a class="link" href="background.html#background.references">[7]</a>&#12290;&#25105;&#20204;&#26469;&#32771;&#34385;&#19968;&#19979;&#20026;&#20102;&#35753;
      "pair" &#25345;&#26377;&#38750;&#24341;&#29992;&#31867;&#22411;&#65292;&#24341;&#29992;&#65292;&#21644;&#24120;&#24341;&#29992;&#65292;&#26500;&#36896;&#20989;&#25968;&#30340;&#21442;&#25968;&#24517;&#39035;&#26159;&#20160;&#20040;&#26679;&#30340;&#65306;
    </p>
<div class="table">
<a name="id5097181"></a><p class="title"><b>Table&#160;1.2.&#160;Required Constructor Argument Types &#35201;&#27714;&#30340;&#26500;&#36896;&#20989;&#25968;&#21442;&#25968;&#31867;&#22411;</b></p>
<div class="table-contents"><table class="table" summary="Required Constructor Argument Types &#35201;&#27714;&#30340;&#26500;&#36896;&#20989;&#25968;&#21442;&#25968;&#31867;&#22411;">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Type of <code class="computeroutput"><span class="identifier">T1</span></code>
              </p>
            </th>
<th>
              <p>
                Type of parameter to initializing constructor &#20256;&#32473;&#21021;&#22987;&#26500;&#36896;&#20989;&#25968;&#30340;&#21442;&#25968;&#30340;&#31867;&#22411;
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                T
              </p>
            </td>
<td>
              <p>
                const T &amp;
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                T &amp;
              </p>
            </td>
<td>
              <p>
                T &amp;
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                const T &amp;
              </p>
            </td>
<td>
              <p>
                const T &amp;
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
      A little familiarity with the type traits classes allows us to construct a
      single mapping that allows us to determine the type of parameter from the type
      of the contained class. The type traits classes provide a transformation <a class="link" href="reference/add_reference.html" title="add_reference">add_reference</a>, which
      adds a reference to its type, unless it is already a reference.<br> &#21644; type
      traits &#31867;&#20801;&#35768;&#25105;&#20204;&#21019;&#24314;&#19968;&#20010;&#21333;&#19968;&#26144;&#23556;&#65292;&#20197;&#20415;&#25105;&#20204;&#25105;&#21487;&#20174; contained
      class &#30340;&#31867;&#22411;&#30830;&#23450;&#21442;&#25968;&#30340;&#31867;&#22411;&#26377;&#20123;&#31867;&#20284;&#12290; type traits &#31867;&#25552;&#20379;&#20102;&#19968;&#20010;&#36716;&#25442;
      <a class="link" href="reference/add_reference.html" title="add_reference">add_reference</a>&#65292;&#23427;&#21487;&#20197;&#20026;&#19968;&#20010;&#31867;&#22411;&#21152;&#19978;&#24341;&#29992;&#65292;&#38500;&#38750;&#23427;&#24050;&#32463;&#26159;&#19968;&#20010;&#24341;&#29992;&#12290;
    </p>
<div class="table">
<a name="id5097321"></a><p class="title"><b>Table&#160;1.3.&#160;Using add_reference to synthesize the correct constructor type &#20351;&#29992;
      add_reference &#21512;&#25104;&#27491;&#30830;&#30340;&#26500;&#36896;&#20989;&#25968;&#22411;</b></p>
<div class="table-contents"><table class="table" summary="Using add_reference to synthesize the correct constructor type &#20351;&#29992;
      add_reference &#21512;&#25104;&#27491;&#30830;&#30340;&#26500;&#36896;&#20989;&#25968;&#22411;">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Type of <code class="computeroutput"><span class="identifier">T1</span></code>
              </p>
            </th>
<th>
              <p>
                Type of <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">T1</span></code>
              </p>
            </th>
<th>
              <p>
                Type of <code class="computeroutput"><span class="identifier">add_reference</span><span class="special">&lt;</span><span class="keyword">const</span>
                <span class="identifier">T1</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                T
              </p>
            </td>
<td>
              <p>
                const T
              </p>
            </td>
<td>
              <p>
                const T &amp;
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                T &amp;
              </p>
            </td>
<td>
              <p>
                T &amp; [8]
              </p>
            </td>
<td>
              <p>
                T &amp;
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                const T &amp;
              </p>
            </td>
<td>
              <p>
                const T &amp;
              </p>
            </td>
<td>
              <p>
                const T &amp;
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
      This allows us to build a primary template definition for <code class="computeroutput"><span class="identifier">pair</span></code>
      that can contain non-reference types, reference types, and constant reference
      types:<br> &#36825;&#23601;&#20801;&#35768;&#25105;&#20204;&#21019;&#24314;&#19968;&#20010;&#21487;&#20197;&#21253;&#21547;&#38750;&#24341;&#29992;&#31867;&#22411;&#65292;&#24341;&#29992;&#31867;&#22411;&#65292;&#21644;&#24120;&#24341;&#29992;&#31867;&#22411;&#30340;
      <code class="computeroutput"><span class="identifier">pair</span></code> &#30340;&#20027;&#27169;&#26495;&#30340;&#23450;&#20041;&#65306;
    </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span> 
<span class="keyword">struct</span> <span class="identifier">pair</span> 
<span class="special">{</span>
<span class="keyword">typedef</span> <span class="identifier">T1</span> <span class="identifier">first_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">T2</span> <span class="identifier">second_type</span><span class="special">;</span>

<span class="identifier">T1</span> <span class="identifier">first</span><span class="special">;</span>
<span class="identifier">T2</span> <span class="identifier">second</span><span class="special">;</span>

<span class="identifier">pair</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><a class="link" href="reference/add_reference.html" title="add_reference">add_reference</a><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">T1</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">nfirst</span><span class="special">,</span>
      <span class="identifier">boost</span><span class="special">::</span><a class="link" href="reference/add_reference.html" title="add_reference">add_reference</a><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">T2</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">nsecond</span><span class="special">)</span>
<span class="special">:</span><span class="identifier">first</span><span class="special">(</span><span class="identifier">nfirst</span><span class="special">),</span> <span class="identifier">second</span><span class="special">(</span><span class="identifier">nsecond</span><span class="special">)</span> <span class="special">{</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      Add back in the standard comparison operators, default constructor, and template
      copy constructor (which are all the same), and you have a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code> that
      can hold reference types!<br> &#20877;&#21152;&#19978;&#26631;&#20934;&#30340;&#27604;&#36739;&#25805;&#20316;&#31526;&#65292;&#32570;&#30465;&#26500;&#36896;&#20989;&#25968;&#65292;&#21644;&#27169;&#26495;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#65288;&#37117;&#21644;&#21407;&#26469;&#30340;&#19968;&#26679;&#65289;&#65292;&#20320;&#23601;&#26377;&#20102;&#19968;&#20010;&#33021;&#22815;&#25345;&#26377;&#24341;&#29992;&#31867;&#22411;&#30340;
      <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>&#65281;
    </p>
<p>
      This same extension could have been done using partial template specialization
      of <code class="computeroutput"><span class="identifier">pair</span></code>, but to specialize
      <code class="computeroutput"><span class="identifier">pair</span></code> in this way would require
      three partial specializations, plus the primary template. Type traits allows
      us to define a single primary template that adjusts itself auto-magically to
      any of these partial specializations, instead of a brute-force partial specialization
      approach. Using type traits in this fashion allows programmers to delegate
      partial specialization to the type traits classes, resulting in code that is
      easier to maintain and easier to understand.<br> &#21516;&#26679;&#30340;&#25193;&#23637;&#21487;&#20197;&#20351;&#29992;
      <code class="computeroutput"><span class="identifier">pair</span></code> &#30340;&#27169;&#26495;&#20559;&#29305;&#21270;&#26469;&#20570;&#21040;&#65292;&#20294;&#35201;&#36825;&#26679;&#29305;&#21270;
      <code class="computeroutput"><span class="identifier">pair</span></code>&#65292;&#19968;&#20849;&#38656;&#35201;&#19977;&#20010;&#20559;&#29305;&#21270;&#65292;&#22806;&#21152;&#20027;&#27169;&#26495;&#12290;
      type traits &#20801;&#35768;&#25105;&#20204;&#23450;&#20041;&#19968;&#20010;&#21333;&#19968;&#30340;&#20027;&#27169;&#26495;&#65292;&#23427;&#21487;&#20197;&#35843;&#25972;&#33258;&#24049;&#20687;&#21464;&#39764;&#26415;&#19968;&#26679;&#21464;&#25104;&#20197;&#19978;&#20219;&#20309;&#19968;&#20010;&#20559;&#29305;&#21270;&#65292;&#32780;&#19981;&#38656;&#35201;&#24378;&#21046;&#30340;&#20559;&#29305;&#21270;&#27493;&#39588;&#12290;
      &#20197;&#36825;&#31181;&#26041;&#24335;&#20351;&#29992; type traits &#20801;&#35768;&#31243;&#24207;&#21592;&#23558;&#20559;&#29305;&#21270;&#22996;&#25176;&#32473; type
      traits &#31867;&#65292;&#20351;&#24471;&#20195;&#30721;&#26131;&#20110;&#32500;&#25252;&#21644;&#29702;&#35299;&#12290;
    </p>
<a name="boost_typetraits.background.conclusion_______"></a><h5>
<a name="id5097933"></a>
      <a class="link" href="background.html#boost_typetraits.background.conclusion_______">Conclusion &#32467;&#35770;</a>
    </h5>
<p>
      We hope that in this article we have been able to give you some idea of what
      type-traits are all about. A more complete listing of the available classes
      are in the boost documentation, along with further examples using type traits.
      Templates have enabled C++ uses to take the advantage of the code reuse that
      generic programming brings; hopefully this article has shown that generic programming
      does not have to sink to the lowest common denominator, and that templates
      can be optimal as well as generic.<br> &#25105;&#20204;&#24076;&#26395;&#25105;&#20204;&#33021;&#22312;&#36825;&#31687;&#25991;&#31456;&#20013;&#32473;&#20320;&#19968;&#20123;&#20851;&#20110;
      type-traits &#26159;&#20160;&#20040;&#30340;&#27010;&#24565;&#12290; boost &#25991;&#26723;&#20013;&#26377;&#19968;&#20010;&#21487;&#29992;&#31867;&#30340;&#26356;&#23436;&#25972;&#30340;&#21015;&#34920;&#65292;&#37027;&#37324;&#36824;&#26377;&#19968;&#20123;&#20351;&#29992;
      type traits &#30340;&#26356;&#36827;&#19968;&#27493;&#30340;&#31034;&#20363;&#12290; &#27169;&#26495;&#20351;&#24471; C++ &#33021;&#22815;&#21033;&#29992;&#27867;&#22411;&#32534;&#31243;&#24102;&#26469;&#30340;&#20195;&#30721;&#22797;&#29992;&#30340;&#22909;&#22788;&#65292;&#21516;&#26102;&#20063;&#24076;&#26395;&#36825;&#31687;&#25991;&#31456;&#21521;&#20320;&#23637;&#31034;&#27867;&#22411;&#32534;&#31243;&#24182;&#38750;&#26368;&#19981;&#24120;&#29992;&#30340;&#29305;&#24615;&#65292;&#32780;&#19988;&#27169;&#26495;&#21487;&#20197;&#21644;&#27867;&#22411;&#19968;&#26679;&#31934;&#24425;&#12290;
    </p>
<a name="boost_typetraits.background.acknowledgements_______"></a><h5>
<a name="id5097976"></a>
      <a class="link" href="background.html#boost_typetraits.background.acknowledgements_______">Acknowledgements
      &#40483;&#35874;</a>
    </h5>
<p>
      The authors would like to thank Beman Dawes and Howard Hinnant for their helpful
      comments when preparing this article.<br> &#24863;&#35874; Beman Dawes &#21644; Howard Hinnant
      &#22312;&#36825;&#31687;&#25991;&#31456;&#20934;&#22791;&#36807;&#31243;&#20013;&#25552;&#20986;&#30340;&#24110;&#21161;&#24615;&#24314;&#35758;&#12290;
    </p>
<a name="background.references"></a><a name="boost_typetraits.background.references_____________"></a><h5>
<a name="id5098011"></a>
      <a class="link" href="background.html#boost_typetraits.background.references_____________">References
      &#21442;&#32771;&#36164;&#26009;</a>
    </h5>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          Nathan C. Myers, C++ Report, June 1995.
        </li>
<li class="listitem">
          The type traits library is based upon contributions by Steve Cleary, Beman
          Dawes, Howard Hinnant and John Maddock: it can be found at www.boost.org.
          <br> type traits &#24211;&#22522;&#20110; Steve Cleary&#65292;Beman Dawes&#65292;Howard Hinnant
          &#21644; John Maddock &#30340;&#36129;&#29486;&#65306;&#23427;&#21487;&#20197;&#22312; www.boost.org &#25214;&#21040;&#12290;
        </li>
<li class="listitem">
          A scalar type is an arithmetic type (i.e. a built-in integer or floating
          point type), an enumeration type, a pointer, a pointer to member, or a
          const- or volatile-qualified version of one of these types. <br> &#19968;&#20010;
          scalar type&#65288;&#26631;&#37327;&#31867;&#22411;&#65289;&#26159;&#19968;&#20010;&#31639;&#26415;&#31867;&#22411;&#65288;&#20063;&#23601;&#26159;&#35828;&#65292;&#19968;&#20010;&#20869;&#24314;&#25972;&#25968;&#25110;&#28014;&#28857;&#25968;&#31867;&#22411;&#65289;&#65292;&#19968;&#20010;&#26522;&#20030;&#31867;&#22411;&#65292;
          &#19968;&#20010;&#25351;&#38024;&#65292;&#19968;&#20010;&#25104;&#21592;&#25351;&#38024;&#65292;&#25110;&#19968;&#20010;&#19978;&#36848;&#31867;&#22411;&#30340;&#24102;&#26377; const-
          &#25110; volatile- &#20462;&#39280;&#30340;&#29256;&#26412;&#12290;
        </li>
<li class="listitem">
          This quote is from Donald Knuth, ACM Computing Surveys, December 1974,
          pg 268. <br> &#36825;&#21477;&#24341;&#35328;&#20986;&#33258; Donald Knuth, ACM Computing Surveys,
          December 1974, pg 268&#12290;
        </li>
<li class="listitem">
          The test code is available as part of the boost utility library (see algo_opt_examples.cpp),
          the code was compiled with gcc 2.95 with all optimisations turned on, tests
          were conducted on a 400MHz Pentium II machine running Microsoft Windows
          98. <br> &#27979;&#35797;&#20195;&#30721;&#25104;&#20026; boost utility &#24211;&#30340;&#19968;&#37096;&#20998;&#65288;&#21442;&#35265; algo_opt_examples.cpp&#65289;&#65292;&#20195;&#30721;&#30001;
          gcc 2.95 &#32534;&#35793;&#65292;&#24182;&#25171;&#24320;&#20840;&#37096;&#20248;&#21270;&#65292;&#27979;&#35797;&#22312;&#19968;&#21488;&#36816;&#34892; Microsoft
          Windows 98 &#30340; 400 MHz Pentium II &#26426;&#22120;&#19978;&#36827;&#34892;&#12290;
        </li>
<li class="listitem">
          John Maddock and Howard Hinnant have submitted a "compressed_pair"
          library to Boost, which uses a technique similar to the one described here
          to hold references. Their pair also uses type traits to determine if any
          of the types are empty, and will derive instead of contain to conserve
          space -- hence the name "compressed". <br> John Maddock &#21644;
          Howard Hinnant &#20026; Boost &#25552;&#20132;&#20102;&#19968;&#20010; "compressed_pair" &#24211;&#65292;&#20351;&#29992;&#20102;&#19968;&#31181;&#31867;&#20284;&#20110;&#36825;&#37324;&#25551;&#36848;&#30340;&#29992;&#20197;&#25345;&#26377;&#24341;&#29992;&#30340;&#25216;&#26415;&#12290;
          &#23427;&#20204;&#30340; pair &#20063;&#20351;&#29992; type traits&#65292;&#29992;&#26469;&#21028;&#26029;&#22914;&#26524;&#20219;&#20309;&#31867;&#22411;&#20026;&#31354;&#65292;&#23601;&#29992;&#27966;&#29983;&#20195;&#26367;&#21253;&#21547;&#20197;&#33410;&#32422;&#31354;&#38388;&#8212;&#8212;&#22240;&#27492;&#21517;&#20026;
          "compressed"&#12290;
        </li>
<li class="listitem">
          This is actually an issue with the C++ Core Language Working Group (issue
          #106), submitted by Bjarne Stroustrup. The tentative resolution is to allow
          a "reference to a reference to T" to mean the same thing as a
          "reference to T", but only in template instantiation, in a method
          similar to multiple cv-qualifiers. <br> &#36825;&#23454;&#38469;&#19978;&#26159; C++ &#26680;&#24515;&#35821;&#35328;&#24037;&#20316;&#32452;&#30340;&#19968;&#20010;&#35758;&#39064;
          (issue #106)&#65292;&#30001; Bjarne Stroustrup &#25552;&#20132;&#12290; &#26242;&#23450;&#30340;&#35299;&#20915;&#26041;&#26696;&#26159;&#20801;&#35768;&#19968;&#20010;&#8220;T
          &#30340;&#24341;&#29992;&#30340;&#24341;&#29992;&#8221;&#21644;&#8220;T &#30340;&#24341;&#29992;&#8221;&#24847;&#21619;&#30528;&#21516;&#26679;&#30340;&#19996;&#35199;&#65292;&#20294;&#26159;&#36825;&#20165;&#23616;&#38480;&#20110;&#27169;&#26495;&#23454;&#20363;&#21270;&#25110;&#19968;&#20010;&#26041;&#27861;&#20013;&#65292;&#36825;&#23601;&#31867;&#20284;&#20110;&#22810;&#20010;
          cv &#20462;&#39280;&#31526;&#12290;
        </li>
<li class="listitem">
          For those of you who are wondering why this shouldn't be const-qualified,
          remember that references are always implicitly constant (for example, you
          can't re-assign a reference). Remember also that "const T &amp;"
          is something completely different. For this reason, cv-qualifiers on template
          type arguments that are references are ignored.<br> &#20320;&#21487;&#33021;&#20250;&#35273;&#24471;&#22855;&#24618;&#65292;&#20026;&#20160;&#20040;&#36825;&#37324;&#19981;&#24212;&#35813;&#34987;
          const &#20462;&#39280;&#65292;&#35760;&#20303;&#24341;&#29992;&#24635;&#26159;&#38544;&#21547;&#24120;&#37327;&#24615;&#30340;&#65288;&#20363;&#22914;&#65292;&#20320;&#19981;&#33021;&#20026;&#19968;&#20010;&#24341;&#29992;&#20877;&#36171;&#20540;&#65289;&#12290;
          &#21516;&#26102;&#65292;&#36824;&#35201;&#35760;&#20303; "const T &amp;" &#26159;&#23436;&#20840;&#19981;&#21516;&#30340;&#19996;&#35199;&#12290;&#22240;&#27492;&#65292;&#22312;&#27169;&#26495;&#31867;&#22411;&#21442;&#25968;&#26159;&#24341;&#29992;&#30340;&#26102;&#20505;&#65292;cv
          &#20462;&#39280;&#31526;&#26159;&#34987;&#24573;&#30053;&#30340;&#12290;
        </li>
</ol></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2000, 2006 Adobe Systems Inc, David Abrahams,
      Steve Cleary, Beman Dawes, Aleksey Gurtovoy, Howard Hinnant, Jesse Jones, Mat
      Marcus, Itay Maman, John Maddock, Alexander Nasonov, Thorsten Ottosen, Robert
      Ramey and Jeremy Siek<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="intro.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="category.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>

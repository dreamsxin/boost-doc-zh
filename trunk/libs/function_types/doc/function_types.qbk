[library Boost.FunctionTypes
  [quickbook 1.3]
  [version 2.5]
  [authors [Schwinger, Tobias]]
  [copyright 2004-2007 Tobias Schwinger]
  [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at 
        [@http://www.boost.org/LICENSE_1_0.txt])
  ]
  [purpose Meta-programming support library]
  [category template]
  [category generic]
  [last-revision $Date: 2009-11-20 05:13:51 -0500 (Fri, 20 Nov 2009) $]
]

[def __unspecified__ /unspecified/]

[def __mpl__ [@../../../mpl/index.html MPL]]
[def __mpl_integral_constant__ __mpl__ - [@../../../mpl/doc/refmanual/integral-constant.html Integral Constant]]
[def __mpl_fwd_seq__ __mpl__ - [@../../../mpl/doc/refmanual/forward-sequence.html Forward Sequence]]
[def __mpl_fb_ext_ra_seq__ __mpl__ - [@../../../mpl/doc/refmanual/front-extensible-sequence.html Front] / [@../../../mpl/doc/refmanual/back-extensible-sequence.html Back ][@../../../mpl/doc/refmanual/extensible-sequence.html Extensible ][@../../../mpl/doc/refmanual/random-access-sequence.html Random Access Sequence]]
[def __mpl_lambda_expression__  __mpl__ - [@../../../mpl/doc/refmanual/lambda-expression.html Lambda Expression]]

[def __is_function [link boost_functiontypes.reference.classification.is_function is_function]]
[def __is_function_pointer [link boost_functiontypes.reference.classification.is_function_pointer is_function_pointer]]
[def __is_function_reference [link boost_functiontypes.reference.classification.is_function_reference is_function_reference]]
[def __is_member_function_pointer [link boost_functiontypes.reference.classification.is_member_function_pointer is_member_function_pointer]]
[def __is_callable_builtin [link boost_functiontypes.reference.classification.is_callable_builtin is_callable_builtin]]
[def __is_nonmember_callable_builtin [link boost_functiontypes.reference.classification.is_nonmember_callable_builtin is_nonmember_callable_builtin]]

[def __components [link boost_functiontypes.reference.decomposition.components components]]
[def __parameter_types [link boost_functiontypes.reference.decomposition.parameter_types parameter_types]]
[def __function_arity [link boost_functiontypes.reference.decomposition.function_arity function_arity]]
[def __result_type [link boost_functiontypes.reference.decomposition.result_type result_type]]

[def __function_type [link boost_functiontypes.reference.synthesis.function_type function_type]]
[def __function_pointer [link boost_functiontypes.reference.synthesis.function_pointer function_pointer]]
[def __function_reference [link boost_functiontypes.reference.synthesis.function_reference function_reference]
[def __member_function_pointer [link boost_functiontypes.reference.synthesis.member_function_pointer member_function_pointer]]

[def __null_tag [link boost_functiontypes.reference.tag_types.null_tag null_tag]]

[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]

[section:introduction Introduction 简介]

Boost.FunctionTypes provides functionality to classify, decompose and synthesize
function, function pointer, function reference and pointer to member types.\n
Boost.FunctionTypes 提供了对函数、函数指针、函数引用和成员指针等类型进行分类、分解和合成的功能。

We collectively refer to these types as /callable builtin/ types.\n
我们将这些类型统称为 /可调用内建/ 类型。

In particular, the library can be used to:\n
特别是，本库可用于：

* test whether a type is a specific callable, builtin type,\n
  测试某个类型是否为特定的可调用内建类型，
* extract all component properties from callable, builtin types, and\n
  从可调用内建类型中提取所有构成属性，以及
* create callable, builtin types from specified properties.\n
  从特定的属性构建可调用内建类型。

The library is designed to work well with other Boost libraries and uses 
well-accepted concepts introduced by Boost and TR1.\n
本库被设计为可以与其它 Boost 库良好地合作，并使用由 Boost 和 TR1 所描述的被广泛接受的概念。

Templates that encapsulate boolean or numeric properties define a static member
constant called [^value].\n
封装了布尔或数字属性的模板定义了一个名为 [^value] 的静态成员常量。

  __is_function_pointer< bool(*)(int) >::value // == true 

  __function_arity< bool(*)(int) >::value // == 1

Templates that encapsulate properties that are single types contain a type 
member called [^type]. \n
封装了单个类型属性的模板含有一个名为 [^type] 的类型成员。

  __function_type< mpl::vector<bool,int> >::type // is bool(int)

  __result_type< bool(&)(int) >::type // is bool

Templates that encapsulate properties that are type lists model an 
MPL-compatible type sequence.\n
封装了类型列表属性的模板则依照 MPL 兼容的类型序列。

  __parameter_types< bool(int) > // models an MPL sequence 依照MPL序列

[endsect]

[section:use_cases Use Cases 用例]

Generic libraries that accept callable arguments are common in C++.
Accepting a callable argument of builin type often involves a lot of repetitive
code because the accepting function is overloaded for different function 
arities. Further, member functions may have [^const]/[^volatile]-qualifiers, 
a function may take a variable number of (additional, POD-typed) arguments (such
as [^printf]) and several C++ implementations encode a calling convention with
each function's type to allow calls across language or (sub-)system boundaries.\n
在C++中，泛型库接受可调用参数是很常见的。接受一个可调用内建类型的参数通常需要编写一堆重复的代码，
因为接受参数的函数要为不同的函数实体进行重载。此外，成员函数可能带有 [^const]/[^volatile]-限定符，
函数可能接受可变数量的(还有POD类型的)参数(如 [^printf])，还有几个C++实现会对每种函数类型编码一个调用习惯，
以允许跨语言或跨(子)系统边界进行调用。

  template<typename R>
  void accept_function(R(* func)());

  template<typename R>
  void accept_function(R(& func)());

  template<typename R, typename C>
  void accept_function(R(C::* func)());

  template<typename R, typename C>
  void accept_function(R(C::* func)() const);

  template<typename R, typename C>
  void accept_function(R(C::* func)() volatile);

  template<typename R, typename C>
  void accept_function(R(C::* func)() const volatile);

  template<typename R>
  void accept_function(R(* func)(...));

  template<typename R>
  void accept_function(R(& func)(...));

  template<typename R, typename C>
  void accept_function(R(C::* func)(...));

  template<typename R, typename C>
  void accept_function(R(C::* func)(...) const);

  template<typename R, typename C>
  void accept_function(R(C::* func)(...) volatile);

  template<typename R, typename C>
  void accept_function(R(C::* func)(...) const volatile);

  // ...

  // needs to be repeated for every additional function parameter
  // times the number of possible calling conventions
  // 需要对每一种函数参数重复，并乘以可能的调用习惯的数量

The "overloading approach" obviously does not scale well: There might be several
functions that accept callable arguments in one library and client code might
end up using several libraries that use this pattern. 
On the developer side, library developers spend their time solving the same 
problem, working around the same portability issues, and apply similar 
optimizations to keep the compilation time down.\n
这种 "重载方法" 显然扩展性不好：在一个库中可能会有几个函数是接受可调用参数的，而用户代码可能会使用几个使用这种模式的库。
从开发者的角度出发，库的开发者要花费一点时间来解决这个相同的问题，处理相同的可移植性问题，并使用相似的优化来减少编译的时间。

Using Boost.FunctionTypes it is possible to write a single function template
instead:\n
使用 Boost.FunctionTypes，你就只需要写一个函数模板：

  template<typename F>
  void accept_function(F f)
  {
    // ... use Boost.FunctionTypes to analyse F
    // ... 使用 Boost.FunctionTypes 来分析 F
  }

The combination with a tuples library that provides an invoker component, such
as [@../../../fusion/index.html Boost.Fusion], allows to build flexible callback 
facilities that are entirely free of repetitive code as shown by the 
[@../../../function_types/example/interpreter.hpp interpreter example].\n
与一个 tuples 库结合，以提供一个调用者组件，如 [@../../../fusion/index.html Boost.Fusion], 
就可以构建灵活的回调工具，完全可以避免象 [@../../../function_types/example/interpreter.hpp interpreter例子] 中那样的重复代码。

When taking the address of an overloaded function or function template, the 
type of the function must be known from the context the expression is used
in. The code below shows three examples for choosing the [^float(float)] 
overload of [^std::abs].\n
当接受一个重载函数或函数模板的地址时，必须要从所用表达式的上下文中得知函数的类型。
以下代码示范了三个选择 [^std::abs] 的 [^float(float)] 重载的例子。

  float (*ptr_absf)(float) = & std::abs;


  void foo(float(*func)(float));

  void bar() 
  { 
    foo(& std::abs); 
  }


  std::transform(b, e, o, static_cast<float(*)(float)>(& std::abs));

The library's type synthesis capabilities can be used to automate overload
selection and instantiation of function templates. Given an overloaded function
template\n
本库的类型合成功能可以被用于自动重载选择和函数模板实例化。给定一个重载的函数模板：

  template<typename R, typename T0>
  R overloaded(T0);

  template<typename R, typename T0, typename T1>
  R overloaded(T0,T1);

  template<typename R. typename T0, typename T1, typename T2>
  R overloaded(T0,T1,T2);

we can pick any of the three overloads and instantiate the template with 
template arguments from a type sequence in a single expression:\n
我们可以选出三个重载中的任意一个，并在一个表达式中，用来自一个类型序列的模板参数来实例化该模板：

  static_cast<__function_pointer<Seq>::type>(& overloaded)

This technique can be occasionally more flexible than template argument 
deduction from a function call because the exact types from the sequence
are used to specialize the template (including possibly cv-qualified 
reference types and the result type). It is applied twice in the 
[@../../../function_types/example/interface.hpp interface example].\n
该技术偶尔会比从一个函数调用进行模板参数推导更为灵活，因为来自序列中的准确类型被用于对模板的特化
(包括可能的 cv-限定的引用类型和结果类型)。在 [@../../../function_types/example/interface.hpp interface例子] 中该技术被应用了两次。

Another interersting property of callable, builtin types is that they can be
valid types for non-type template parameters. This way, a function can be 
pinpointed at compile time, allowing the compiler to eliminate the call by 
inlining. 
The [@../../../function_types/example/fast_mem_fn.hpp fast_mem_fn example]
exploits this characteristic and implements a potentially inlining version of 
[@../../../bind/mem_fn.html boost::mem_fn]
limited to member functions that are known at compile time. \n
可调用内建类型的另一个有趣的特性是，它们可以作为非类型模板参数的有效类型。
这种方法，一个函数可以在编译期被查明，让编译器可以通过内联消除调用。
[@../../../function_types/example/fast_mem_fn.hpp fast_mem_fn例子] 利用了这个特性，
并实现了 [@../../../bind/mem_fn.html boost::mem_fn] 的一个潜在的内联版本，仅限于在编译期可以获知的成员函数。

[endsect]


[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]
[section:about_tag_types About Tag Types 关于Tag类型]

Boost.FunctionTypes uses tag types to encode properties that are not types 
per se, such as calling convention or whether a function is variadic or cv-
qualified.\n
Boost.FunctionTypes 使用 tag 类型来对不属于类型本身的属性进行编码，如调用协定或函数是否为变长参数或 cv- 限定。

These tags can be used to determine whether one property of a type has a 
particular value.\n
这些 tags 可以用来判断类型的某个属性是否具有特定值。

  is_function<int(...), variadic>::value // == true
  is_function<int()   , variadic>::value // == false

A compound property tag describes a combination of possible values of different
properties. 
The type [^components<F>], where [^F] is a callable builtin type, is a compound
property tag that describes [^F].
The [^tag] class template can be used to combine property tags.\n
复合的属性 tag 描述了不同属性的可能值的组合。类型 [^components<F>], 其中 [^F] 为可调用内建类型，是描述 [^F] 的复合属性 tag。
类模板 [^tag] 可用于合成属性 tags。

  tag<non_const,default_cc> // combination of two properties 两个属性的组合

When several values for the same property are specified in [^tag]'s argument 
list, only the rightmost one is used; others are ignored.\n
当同一个属性的多个值在 [^tag] 的参数列表中被指定时，只使用最右边的一个；其它值会被忽略。

  tag<components<F>, default_cc> // overrides F's calling convention property 覆盖 F 的调用协定属性

When compound property tag is specified to analyse a type, all of its component
properties must match.\n
当复合属性 tag 被指定为分析一个类型，它的所有组成属性都必须匹配。

  is_member_function_pointer< F, tag<const_qualified,default_cc> >::value
  // true for 
  //   F = void(a_class::*)() const
  // false for
  //   F = void(a_class::*)()
  //   F = void(__fastcall a_class::*)() const

Default values are selected for properties not specified by the tag in the 
context of type synthesis.\n
在类型合成的上下文中，未通过 tag 指定的属性将选择缺省值。

  // given S = mpl::vector<int,a_class const &>
  // 给定 S = mpl::vector<int,a_class const &>

  member_function_pointer<S>::type // is int (a_class::*)() const
  // note: the cv-qualification is picked based on the class type,
  // a nonvariadic signature and the default calling convention 
  // are used
  // 注：基于类类型挑选cv-限定符，使用定长签名和缺省的调用协定

  member_function_pointer<S,non_const>::type // is int (a_class::*)()
  // no const qualification, as explicitly specified by the tag type
  // 非 const 限定，由 tag 类型显式指定

[endsect]


[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]

[section:reference Reference  参考]


[section:classification Class templates for type classification 用于类型分类的类模板]

[section:is_function is_function]

  template<typename T, typename Tag = __null_tag>
  struct is_function;

[*Header]

  #include <boost/function_types/is_function.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^Tag]][Further properties required for a positive result\n
  对于肯定结果所需的更多属性]]
  [[[^is_function<T,Tag>]][Predicate value as __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_function<T,Tag>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a function, possibly with
additional properties as specified by a property tag.\n
判定一个给定的类型是否为函数，可以通过属性标签额外指定属性。

[endsect]


[section:is_function_pointer is_function_pointer]

  template<typename T, typename Tag = __null_tag>
  struct is_function_pointer;

[*Header]

  #include <boost/function_types/is_function_pointer.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^Tag]][Further properties required for a positive result\n
  对于肯定结果所需的更多属性]]
  [[[^is_function_pointer<T,Tag>]][Predicate value __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_function_pointer<T,Tag>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a function pointer, possibly with
additional properties as specified by a property tag.\n
判定一个给定的类型是否为函数指针，可以通过属性标签额外指定属性。

[endsect]


[section:is_function_reference is_function_reference]

  template<typename T, typename Tag = __null_tag>
  struct is_function_reference;

[*Header]

  #include <boost/function_types/is_function_reference.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^Tag]][Further properties required for a positive result\n
  对于肯定结果所需的更多属性]]
  [[[^is_function_reference<T,Tag>]][Predicate value __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_function_reference<T,Tag>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a function reference, possibly with
additional properties as specified by a property tag.\n
判定一个给定的类型是否为函数引用，可以通过属性标签额外指定属性。

[endsect]


[section:is_member_pointer is_member_pointer]

  template<typename T, typename Tag = __null_tag>
  struct is_member_pointer;

[*Header]

  #include <boost/function_types/is_member_pointer.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^Tag]][Further properties required for a positive result\n
  对于肯定结果所需的更多属性]]
  [[[^is_member_pointer<T,Tag>]][Predicate value __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_member_pointer<T,Tag>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a pointer to member (object or function)
type, possibly with additional properties as specified by a property tag.\n
判定一个给定的类型是否为成员(对象或函数)指针类型，可以通过属性标签额外指定属性。

[endsect]


[section:is_member_object_pointer is_member_object_pointer]

  template<typename T>
  struct is_member_object_pointer;

[*Header]

  #include <boost/function_types/is_member_object_pointer.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^is_member_object_pointer<T>]][Predicate value __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_member_object_pointer<T>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a pointer to member object type. \n
判定一个给定的类型是否为成员对象指针类型。

[endsect]


[section:is_member_function_pointer is_member_function_pointer]

  template<typename T, typename Tag = __null_tag>
  struct is_member_function_pointer;

[*Header]

  #include <boost/function_types/is_member_function_pointer.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^Tag]][Further properties required for a positive result\n
  对于肯定结果所需的更多属性]]
  [[[^is_member_function_pointer<T,Tag>]][Predicate value __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_member_function_pointer<T,Tag>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a member function pointer, possibly with
additional properties as specified by a property tag.\n
判定一个给定的类型是否为成员函数指针，可以通过属性标签额外指定属性。

[endsect]


[section:is_callable_builtin is_callable_builtin]

  template<typename T, typename Tag = __null_tag>
  struct is_callable_builtin;

[*Header]

  #include <boost/function_types/is_callable_builtin.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^Tag]][Further properties required for a positive result\n
  对于肯定结果所需的更多属性]]
  [[[^is_callable_builtin<T,Tag>]][Predicate value as __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_callable_builtin<T,Tag>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a callable builtin, possibly with
additional properties as specified by a property tag.\n
判定一个给定的类型是否为可调用内建类型，可以通过属性标签额外指定属性。

[endsect]



[section:is_nonmember_callable_builtin is_nonmember_callable_builtin]

  template<typename T, typename Tag = __null_tag>
  struct is_nonmember_callable_builtin;

[*Header]

  #include <boost/function_types/is_nonmember_callable_builtin.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^Tag]][Further properties required for a positive result\n
  对于肯定结果所需的更多属性]]
  [[[^is_nonmember_callable_builtin<T,Tag>]][Predicate value as __mpl_integral_constant__\n
  谓词结果值，为 __mpl_integral_constant__]]
  [[[^is_nonmember_callable_builtin<T,Tag>::value]][Constant boolean value\n
  常量布尔值]]
]

Determines whether a given type is a callable builtin that is not a
member function pointer, possibly with
additional properties as specified by a property tag.\n
判定一个给定的类型是否为非成员函数指针的可调用内建类型，可以通过属性标签额外指定属性。

[endsect]


[endsect] [/ Class templates for type classification ]

[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]

[section:decomposition Class templates for type decomposition 用于类型分解的类模板]


[section:result_type result_type]

  template<typename F>
  struct result_type;

[*Header]

  #include <boost/function_types/result_type.hpp>

[variablelist
  [[[^F]][Type to analyze\n
  需要分析的类型]]
  [[[^result_type<F>::type]][Result type of [^F]\n
  [^F] 的结果类型]]
]

Extracts the result type of a callable, builtin type.\n
取出一个可调用内建类型的结果类型。

If [^F] is no callable, builtin type, any attempt to access the
[^type] member results in a compile error.\n
如果 [^F] 不是可调用内建类型，则任何访问 [^type] 成员的尝试都会引发编译错误。

[endsect]


[section:parameter_types parameter_types]

  template<typename F, class ClassTransform = add_reference<_> >
  struct parameter_types;

[*Header]

  #include <boost/function_types/parameter_types.hpp>

[variablelist
  [[[^F]][Type to analyze\n
  需要分析的类型]]
  [[[^ClassTransform]]
   [__mpl_lambda_expression__ to transform the 
    class type if [^F] is a member function pointer\n
    如果 [^F] 为成员函数指针，则为转换该类类型的 __mpl_lambda_expression__]]

  [[[^parameter_types<F,ClassTransform>]]
   [__mpl_fb_ext_ra_seq__ of parameter types\n
   参数类型的 __mpl_fb_ext_ra_seq__]]
]

Extracts the parameter types of a callable, builtin type.\n
取出一个可调用内建类型的参数类型。

If [^F] is no callable, builtin type, any attempt to access the
sequence results in a compile error.\n
如果 [^F] 不是可调用内建类型，则任何访问该结果序列的尝试都会引发编译错误。

[endsect]


[section:function_arity function_arity]

  template<typename F>
  struct function_arity;

[*Header]

  #include <boost/function_types/function_arity.hpp>

[variablelist
  [[[^F]][Callable builtin type\n
  可调用内建类型]]
  [[[^function_arity<F>]][Function arity as __mpl_integral_constant__\n
  函数参数数量，为 __mpl_integral_constant__]]
  [[[^function_arity<F>::value]][Constant value of the function arity\n
  函数参数数量的常量值]]
]

Extracts the function arity, that is the number of parameters. 
The hidden [^this] of member function pointers counts, in other words
the arity value is always greater than or equal to one if [^F] is a 
member function pointer.\n
取出函数的参数数量。成员函数指针的隐藏 [^this] 参数也计算在内，换言之，如果 [^F] 为成员函数指针，则它的参数数量肯定大于等于一。

If [^F] is no callable, builtin type, any attempt to access the
value results in a compile error.\n
如果 [^F] 不是可调用内建类型，则任何访问该结果值的尝试都会引发编译错误。

[endsect]


[section:components components]

  template<typename T, class ClassTransform = add_reference<_> >
  struct components;

[*Header]

  #include <boost/function_types/components.hpp>

[variablelist
  [[[^T]][Type to analyze\n
  需要分析的类型]]
  [[[^ClassTransform]]
   [__mpl_lambda_expression__ to transform the 
    class type if [^T] is a member function pointer\n
    如果 [^T] 为成员函数指针，则为转换该类类型的 __mpl_lambda_expression__]]

  [[[^components<T,ClassTransform>]]
   [__mpl_fb_ext_ra_seq__ of all 
     component types and property tag\n
     所有组成类型和属性标签的 __mpl_fb_ext_ra_seq__]]
  [[[^components<T,ClassTransform>::types]]
   [Decorated MPL Sequence, exposed for optimization\n
   被修饰的 MPL 序列，用于优化]]
]

Extracts all properties of a callable builtin type, that is the result type,
followed by the parameter types (including the type of [^this] for member 
function pointers).\n
取出一个可调用内建类型的所有属性，即结果类型及参数类型(对于成员函数指针还包括 [^this] 的类型)。 

If [^T] is no callable builtin type, the component types are an empty
sequence and the Tag's meaning is equivalent to the [^__null_tag].\n
如果 [^T] 不是可调用内建类型，则组成类型为一个空序列，且 Tag 等于 [^__null_tag]。

[endsect]

[endsect] [/ Class templates for type decomposition]

[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]

[section:synthesis Class templates for type synthesis 用于类型合成的类模板]


[section:function_type function_type]

  template<typename Types, typename Tag = __null_tag> 
  struct function_type;

[*Header]

  #include <boost/function_types/function_type.hpp>

[variablelist
  [[[^Types]][Component types in form of an __mpl_fwd_seq__ or another callable, builtin type\n
  用于组装的类型，格式为 __mpl_fwd_seq__ 或其它可调用内建类型]]
  [[[^Tag]][Further properties\n
  其它属性]]
  [[[^function_type<Types,Tag>::type]][Synthesized type\n
  合成的类型]]
]

Synthesizes a function type from given properties.\n
根据给定的属性合成一个函数类型。

If the template parameters do not describe a valid type, any attempt
to access the [^type] member will result in a compile error.\n
如果模板参数不是有效类型，则任何访问 [^type] 成员的尝试都会引发编译错误。

[endsect]


[section:function_pointer function_pointer]

  template<typename Types, typename Tag = __null_tag> 
  struct function_pointer;

[*Header]

  #include <boost/function_types/function_pointer.hpp>

[variablelist
  [[[^Types]][Component types in form of an __mpl_fwd_seq__ or another callable, builtin type\n
  用于组装的类型，格式为 __mpl_fwd_seq__ 或其它可调用内建类型]]
  [[[^Tag]][Further properties\n
  其它属性]]
  [[[^function_pointer<Types,Tag>::type]][Synthesized type\n
  合成的类型]]
]

Synthesizes a function pointer type from given properties.\n
根据给定的属性合成一个函数指针。

If the template parameters do not describe a valid type, any attempt
to access the [^type] member will result in a compile error.\n
如果模板参数不是有效类型，则任何访问 [^type] 成员的尝试都会引发编译错误。

[endsect]


[section:function_reference function_reference]

  template<typename Types, typename Tag = __null_tag> 
  struct function_reference;

[*Header]

  #include <boost/function_types/function_reference.hpp>

[variablelist
  [[[^Types]][Component types in form of an __mpl_fwd_seq__ or another callable, builtin type\n
  用于组装的类型，格式为 __mpl_fwd_seq__ 或其它可调用内建类型]]
  [[[^Tag]][Further properties\n
  其它属性]]
  [[[^function_reference<Types,Tag>::type]][Synthesized type\n
  合成的类型]]
]

Synthesizes a function reference type from given properties.\n
根据给定的属性合成一个函数引用。

If the template parameters do not describe a valid type, any attempt
to access the [^type] member will result in a compile error.\n
如果模板参数不是有效类型，则任何访问 [^type] 成员的尝试都会引发编译错误。

[endsect]


[section:member_function_pointer member_function_pointer]

  template<typename Types, typename Tag = __null_tag> 
  struct member_function_pointer;

[*Header]

  #include <boost/function_types/member_function_pointer.hpp>

[variablelist
  [[[^Types]][Component types in form of an __mpl_fwd_seq__ or another callable, builtin type\n
  用于组装的类型，格式为 __mpl_fwd_seq__ 或其它可调用内建类型]]
  [[[^Tag]][Further properties\n
  其它属性]]
  [[[^member_function_pointer<Types,Tag>::type]][Synthesized type\n
  合成的类型]]
]

Synthesizes a member function pointer type from given properties.\n
根据给定的属性合成一个成员函数指针。

An optional reference or possibly cv-qualified pointer is removed from
the second type in the sequence to determine the the class type. 
The cv-qualification of the resulting type applies to the member
function, unless otherwise explicitly specified by the property tag.\n
序列中的第二个类型如果带有引用或 cv-限定的指针，则会被去除，以确定类的类型。
结果类型的 cv-限定被应用于成员函数，除非另外通过属性标签进行显式指定。

If the template parameters do not describe a valid type, any attempt
to access the [^type] member will result in a compile error.\n
如果模板参数不是有效类型，则任何访问 [^type] 成员的尝试都会引发编译错误。

[endsect]


[endsect] [/ Class templates for type synthesis ]

[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]

[section:tag_types Tag Types 标签类型]

[section:variadic variadic]

  typedef __unspecified__ variadic;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type takes a variable number of arguments through 
an ellipsis parameter (such as [^printf]).\n
表示函数类型通过一个省略号参数接受变长数量的参数(例如 [^printf])。 

[endsect]

[section:non_variadic non_variadic]

  typedef __unspecified__ non_variadic;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type does not have an ellipsis parameter.\n
表示函数类型不带省略号参数。

[endsect]

[section:default_cc default_cc]

  typedef __unspecified__ default_cc;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type encodes the default calling convention.\n
表示函数类型按缺省的调用协定进行编码。

[endsect]

[section:const_qualified const_qualified]

  typedef __unspecified__ const_qualified;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is const qualified.\n
表示函数类型是 const 限定的。

[endsect]

[section:non_const non_const]

  typedef __unspecified__ non_const;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is not const qualified.\n
表示函数类型不是 const 限定的。

[endsect]

[section:volatile_qualified volatile_qualified]

  typedef __unspecified__ volatile_qualified;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is volatile qualified.\n
表示函数类型是 volatile 限定的。

[endsect]

[section:non_volatile non_volatile]

  typedef __unspecified__ non_volatile;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is not volatile qualified.\n
表示函数类型不是 volatile 限定的。

[endsect]

[section:non_cv non_cv]

  typedef __unspecified__ non_cv;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is neither const nor volatile qualified.
Equivalent to `__tag<__non_const,__non_volatile>`, but involves
fewer template instantiations when evaluated.\n
表示函数类型既不是 const 限定也不是 volatile 限定的。等价于 `__tag<__non_const,__non_volatile>`, 不过在求值时执行更少的模板实例化。

[endsect]

[section:const_non_volatile const_non_volatile]

  typedef __unspecified__ const_non_volatile;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is const but not volatile qualified.
Equivalent to `__tag<__const_qualified,__non_volatile>`, but involves
fewer template instantiations when evaluated.\n
表示函数类型是 const 限定但非 volatile 限定的。等价于 `__tag<__const_qualified,__non_volatile>`, 不过在求值时执行更少的模板实例化。

[endsect]

[section:volatile_non_const volatile_non_const]

  typedef __unspecified__ volatile_non_const;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is volatile but not const qualified.
Equivalent to `__tag<__volatile_qualified,__non_const>`, but involves
fewer template instantiations when evaluated.\n
表示函数类型是 volatile 限定但非 const 限定的。等价于 `__tag<__volatile_qualified,__non_const>`, 不过在求值时执行更少的模板实例化。

[endsect]

[section:cv_qualfied cv_qualfied]

  typedef __unspecified__ cv_qualified;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States that a function type is both const and volatile qualified.
Equivalent to `__tag<__const_qualified,__volatile_qualified>`, but involves
fewer template instantiations when evaluated.\n
表示函数类型同时是 const 和 volatile 限定的。等价于 `__tag<__const_qualified,__volatile_qualified>`, 不过在求值时执行更少的模板实例化。

[endsect]

[section:null_tag null_tag]

  typedef __unspecified__ null_tag;

[*Header]

  #include <boost/function_types/property_tags.hpp>

States nothing.\n
表示没有标签。

[endsect]

[section:tag tag]

  template<class Tag1, class Tag2, 
      class Tag3 = null_tag, class Tag4 = null_tag>
  struct tag;

[*Header]

  #include <boost/function_types/property_tags.hpp>

[variablelist
  [[[^Tag['N]]][Property tag\n
  属性标签]]
  [[[^tag<Tag1,Tag2...>]][Compound property tag\n
  合成的属性标签]]
]

Combination of up to four property tags.  If the arguments describe different 
values for the same property the value of the rightmost argument is used.\n
最多可组合四个属性标签。如果其参数中带有同一个属性的不同值，则使用其中最右边一个参数的值。

[endsect]

[endsect] [/ Tag Types]

[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]

[section:macros Macros 宏]

[section:BOOST_FT_MAX_ARITY BOOST_FT_MAX_ARITY]

Expands to a numeric value that describes the maximum function arity 
supported by the library.\n
扩展为一个数字值，表示本库支持的最大函数参数数量。

Defaults to 20 if not explicitly defined by the user before inclusion
of the first library header.\n
如果在首次包含本库头文件之前用户未显式定义该宏，则缺省为20。

[endsect]



[*The following macros do not need to be defined, unless to configure
the library to work with a compiler and/or calling convention not covered by 
the auto-detection mechanism in [^boost/function_types/config/compiler.hpp].\n
以下宏不需要定义，除非要将本库配置为在以下环境中使用，即所使用的编译器和/或调用协定无法被 
[^boost/function_types/config/compiler.hpp] 中的自动检测机制检测到。]


[section:BOOST_FT_CC_NAMES BOOST_FT_CC_NAMES]

Expands to a [@../../../preprocessor/doc/data/sequences.html sequence] of 
ternary [@../../../preprocessor/doc/data/tuples.html tuples] (these data 
types are defined in the [@../../../preprocessor/doc/index.html
documentation of the Boost Preprocessor library]). 
Each sequence element describes one calling convention specifier.
The first element in each tuple is the macro suffix for 
[link boost_functiontypes.reference.macros.BOOST_FT_CC [^BOOST_FT\_CC\_*]], 
the second element is the name of the tag that describes the calling 
convention and the third is the name of the specifier. 
The specifier is allowed to be an empty string, so the third tuple element
is either [@../../../preprocessor/doc/ref/empty.html [^BOOST_PP_EMPTY]] or 
[@../../../preprocessor/doc/ref/identity.html [^BOOST_PP_IDENTITY]][^(['name])].\n
扩展为一个三重 [@../../../preprocessor/doc/data/tuples.html 元组] 的 [@../../../preprocessor/doc/data/sequences.html 序列] 
(这两种数据类型在 [@../../../preprocessor/doc/index.html Boost Preprocessor 库的文档] 中定义)。
序列的每个元素表示一个调用协定指示符。每个元素的第一个元素为 
[link boost_functiontypes.reference.macros.BOOST_FT_CC [^BOOST_FT\_CC\_*]] 宏中的反缀，第二个元素则是标签名，
表示该调用协定，第三个元素是指示符的名字。指示符可以为空字符串，所以元组的第三个元素为 
[@../../../preprocessor/doc/ref/empty.html [^BOOST_PP_EMPTY]] 或 
[@../../../preprocessor/doc/ref/identity.html [^BOOST_PP_IDENTITY]][^(['name])]。

Define this macro to extend the set of possible names for custom calling
conventions. The macro expands to nothing by default.\n
定义该宏以对定制的调用协定的可能名字集进行扩展。缺省时该宏扩展为空。

The following names are predefined by the library and must not occur in the
definition of [^BOOST_FT_CC_NAMES]:\n
以下名字是本库预定义的，不能在 [^BOOST_FT_CC_NAMES] 的定义中出现：

  #define BOOST_FT_BUILTIN_CC_NAMES \
    (( IMPLICIT           , implicit_cc , BOOST_PP_EMPTY                ))\
    (( CDECL              , cdecl_cc    , BOOST_PP_IDENTITY(__cdecl   ) ))\
    (( STDCALL            , stdcall_cc  , BOOST_PP_IDENTITY(__stdcall ) ))\
    (( PASCAL             , pascal_cc   , BOOST_PP_IDENTITY(pascal    ) ))\
    (( FASTCALL           , fastcall_cc , BOOST_PP_IDENTITY(__fastcall) ))\
    (( CLRCALL            , clrcall_cc  , BOOST_PP_IDENTITY(__clrcall ) ))\
    (( THISCALL           , thiscall_cc , BOOST_PP_IDENTITY(__thiscall) ))\
    (( IMPLICIT_THISCALL  , thiscall_cc , BOOST_PP_EMPTY                )) 
  // Don't get confused by the last line, here (thiscall can't be specified
  // explicitly prior to MSVC 8).
  // 不要被最后一行迷惑(thiscall 在 MSVC 8 之前是不能显式指定的)

[endsect]

[section:BOOST_FT_CC BOOST_FT\_CC\_*]

Enables a specific calling convention. * denotes the macro suffix, as 
defined by
[link boost_functiontypes.reference.macros.BOOST_FT_CC_NAMES [^BOOST_FT_CC_NAMES]] 
or 
[link boost_functiontypes.reference.macros.BOOST_FT_CC_NAMES [^BOOST_FT_BUILTIN_CC_NAMES]].\n
激活一个特殊的调用协定。* 表示该宏的后缀，由 [link boost_functiontypes.reference.macros.BOOST_FT_CC_NAMES [^BOOST_FT_CC_NAMES]] 
或 [link boost_functiontypes.reference.macros.BOOST_FT_CC_NAMES [^BOOST_FT_BUILTIN_CC_NAMES]] 定义。

The macro expands to a list of restrictions, separated by the [^|] character.
Possible items are:\n
该宏扩展为一个约束列表，以 [^|] 符分隔。可能项有：

* callable_builtin
* member
* non_member
* variadic
* non_variadic

If no such macro is defined for a particular calling convention, it is disabled.
Example:\n
如果没有为某个特殊的调用协定定义该宏，则该调用协定被禁止。例如：

  #define BOOST_FT_CC_STDCALL non_variadic|callable_builtin
  // enables stdcall calling convention for all non-variadic, 
  // callable, builtin types
  // 对所有非变长的、可调用的内建类型激活 stdcall 调用协定

[endsect]

[section:BOOST_FT_COMMON_X86_CCs BOOST_FT_COMMON_X86_CCs]

Defining this macro causes the following macros to be defined, if not defined 
already:\n
定义这个宏将导致以下宏被定义，如果它们尚未定义：

  #define BOOST_FT_CC_CDECL BOOST_FT_COMMON_X86_CCs
  #define BOOST_FT_CC_STDCALL non_variadic|BOOST_FT_COMMON_X86_CCs
  #define BOOST_FT_CC_FASTCALL non_variadic|BOOST_FT_COMMON_X86_CCs

[endsect]

[section:BOOST_FT_SYNTAX BOOST_FT_SYNTAX]

This macro allows to change the syntax of callable builtin types.
It is useful to handle the compiler specific placement of the calling 
convention specifier.\n
该宏允许改变可调用内建类型的语法。它用于处理编译器的调用协定批示符的特殊位置。

The default definition is as follows:\n
缺省的定义如下：

  #define BOOST_FT_SYNTAX(result,lparen,cc_spec,type_mod,name,rparen) \
            result() lparen() cc_spec() type_mod() name() rparen()

[endsect]

[section:BOOST_FT_NULLARY_PARAM BOOST_FT_NULLARY_PARAM]

Set to [^void] for compilers that insist on a [^void] parameter for
nullary function types, empty by default.\n
对于那些要用一个 [^void] 参数来表示无参函数类型的编译器，该宏要设为 [^void]，缺省为空。 

[endsect]

[section:BOOST_FT_NO_CV_FUNC_SUPPORT BOOST_FT_NO_CV_FUNC_SUPPORT]

Disables support for cv-qualified function types.
Cv-qualified function types are illegal by the current standard
version, but there is a pending defect report on that issue.
It defaults to [^1] until the standard changes, setting this macro
to [^0] may not work.\n
禁止对 cv-限定的函数类型的支持。Cv-限定的函数类型在当前版本的标准中是非法的，但对于这个问题有一个未决缺陷报告。
它的缺省值为 [^1]，直至标准改变为止，将该宏设为 [^0] 将不能工作。

[endsect]



[*The following macros are useful for testing when changing the source code of
the library.\n
以下宏用于修改了本库的源代码后进行测试。]



[section:BOOST_FT_PREPROCESSING_MODE BOOST_FT_PREPROCESSING_MODE]

Makes the compiler preprocess as much as possible of the library code 
(rather than loading already-preprocessed header files) if defined.\n
如果定义了该宏，编译器将尽可能对本库代码进行预处理(而不是导入已经预处理的头文件)。

[endsect]

[section:BOOST_FT_CC_PREPROCESSING BOOST_FT_CC_PREPROCESSING]

Makes the compiler preprocess the loop over possible names for custom
calling conventions (rather than loading an already-preprocessed header
file) if defined.\n
如果定义了该宏，编译器将对定制的调用协定的可能名进行循环预处理(而不是导入已经预处理的头文件)。

This macro is defined automatically if 
[link boost_functiontypes.reference.macros.BOOST_FT_CC_NAMES [^BOOST_FT_CC_NAMES]] 
has been defined.\n
如果 [link boost_functiontypes.reference.macros.BOOST_FT_CC_NAMES [^BOOST_FT_CC_NAMES]] 已经定义，则该宏是自动定义的。

[endsect]

[endsect]

[endsect]

[/ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ]

[section:rationale Rationale 原理]

[heading Error handling rationale 错误处理原理]

The library does not define the required members of class templates in
case of an error. This technique causes the compiler to stop displaying
diagnostics in client code, at the point where the error actually is, 
instead of tracing template instantiations into the implementation of
the library. \n
本库在出错时没有定义所需的类模板成员。这一技术会让编译器在客户代码中显示论断信息，
在实际发生错误的点上，而不是跟踪模板的实例而进入到库的实现中。

The library's components have limited error conditions, so problematic
input can be spotted easily.\n
本库的组件已限制了错误条件，所以可以很容易找到有问题的输入。


[heading Why MPL Sequences? 为什么使用 MPL 序列？]

MPL provides algorithms on Sequences, so transformations (such as turning
by-value parameter types into const references for optimized forwarding
or computing a signature to specialize 
[@../../../function/index.html [^boost::function]] after applying 
[@../../../bind/index.html [^boost::bind]]) can be expressed more 
easily. The MPL Sequence concept is compatible with several other Boost 
libraries (most importantly [@../../../fusion/index.html Fusion]), 
so another reason is interoperability.\n
MPL 提供了序列的算法，这样可以更容易地进行转换(如：将按值传递的参数类型转换为 const 引用以优化传递，或者在使用 
[@../../../bind/index.html [^boost::bind]] 后计算出一个签名以特化 [@../../../function/index.html [^boost::function]])。
MPL 序列的概念与另外几个 Boost 库相兼容(最主要是 [@../../../fusion/index.html Fusion])，所以另一个原因就是互操作性。


[heading Pointer to member object types 成员对象类型的指针]

Despite their syntax, pointer to member object types can be seen as
dereferencing functionals. \n
不管它们的语法，成员对象类型的指针可以被视为解引用功能。


[heading The ClassTransform template parameter  ClassTransform模板参数]

[^This]-pointer, [^this]-reference or just the object (or maybe even a
smart pointer to the object) plus adjustments of cv-qualification - all
these cases have their place, somewhere and there is no single best answer.\n
[^This]-指针，[^this]-引用或是仅仅这个对象本身(或者可能是指向该对象的智能指针)，
再加上 cv-限定符的调整 - 所有这些情况都会存在，任何地方，没有唯一的最佳答案。

Special treatment of the class type within the sequence can significantly
complicate client code. A custom [^ClassTransform] argument allows the
client to adjust the class type before the sequence is formed and then
treat all parameters uniformly.\n
特殊对待序列中的类类型会显著增加客户代码的复杂度。一个定制的 [^ClassTransform] 参数可以让客户代码在形成该序列之前调整这些类的类型，
然后统一对待所有参数。


[heading Why tag types? 为什么使用标签类型？]

Let's consider the alternatives.\n
我们来想一下其它的方法。

The first one is just using more templates so every property has to be 
asked for explicitly. This approach results in more complicated client 
code if more than one propery has to be checked and in a exponentially 
larger library interface.\n
第一个方法是使用更多的模板，每个属性都必须被明确地查问。如果要检查一个以上的属性，
那么这一方法会使客户代码更为复杂，并且库的接口被指数级放大。

The second alternative is having the client pass in bit patterns via 
non-type template parameters. The logic has to be performed by the 
client and there are much more error conditions. Further, class templates
with non-type template parameters do not work within MPL lambda 
expressions and can cause problems with older compilers.\n
第二个方法是由客户代码以非类型模板参数的方式传入一个位组合。相关逻辑必须由客户代码执行，具有更多的错误条件。
此外，带有非类型模板参数的类模板不能与 MPL lambda 表达式一起使用，在老的编译器上会出现问题。

[heading Is it safe to have the synthesis templates take a callable 
builtin type or an MPL sequence as the first template argument?  
让合成模板接受一个可调用内建类型或者一个 MPL 序列作为第一个模板参数是否安全？]

Yes, but it isn't immediately obvious as the set of possible MPL sequences
isn't inherently disjoint from the set of callable builtin types.\n
是的，但这不是非常明显，因为可能的MPL序列集不是从可调用内建类型集中自然地分解出来的。

However, any attempt to make a builtin type work as an MPL sequence is
a bad idea, because builtin types are accessible before the headers that
make the type a sequence have been included, which can easily violate the
ODR. \n
不过，将一个内建类型作为一个MPL序列来使用是不好的，因为内建类型在将类型创建为序列的头文件被包含之前就可以被访问，这很容易违反 ODR。

[heading Why does the hidden [^this] parameter count for the 
function arity of member functions? 为什么隐藏的 [^this] 参数要计入成员函数的参数数量中？ ]

It was found preferable that the following condition holds:\n
这是最好的方法，以保证以下条件成立：

  mpl::size< __parameter_types<T> >::value == __function_arity<T>::value

[heading Why ignore top-level cv-qualifiers on pointers? 为什么要忽略指针的顶层 cv-限定符？]

A cv-qualified pointer is still a pointer. It usually doesn't matter and
even if it does, it's a job for 
[@../../../type_traits/index.html Boost.TypeTraits]. \n
一个 cv-限定的指针还是一个指针。即使这样做了通常也不会有问题，这是 [@../../../type_traits/index.html Boost.TypeTraits] 的一个职责。


[endsect]

[section:acknowledgements Acknowledgements 鸣谢]

Thanks go to the following people for supporting the development of this 
library in one or the other way:\n
感谢以下人员对本库的开发工作给予的各种支持：

* David Abrahams
* Tom Brinkman
* Aleksey Gurtovoy
* Jody Hagins
* Hartmut Kaiser 
* Andy Little
* John Maddock 
* Paul Mensonides
* Alexander Nasonov
* Richard Smith
* Rob Stewart
* Jonathan Turkanis
* Pavel Vozenilek
* Steven Watanabe
* K. Noel Belcourt

[endsect]


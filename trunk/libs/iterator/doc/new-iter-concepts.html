<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>








  
  
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />








  
  
  
  
  
  
  
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />









  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>New Iterator Concepts</title>
  <meta name="author" content="David Abrahams, Jeremy Siek, Thomas Witt" />








  
  
  
  
  
  
  
  <meta name="organization" content="Boost Consulting, Indiana University Open Systems Lab, Zephyr Associates, Inc." />








  
  
  
  
  
  
  
  <meta name="date" content="2006-09-11" />








  
  
  
  
  
  
  
  <meta name="copyright" content="Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003." />








  
  
  
  
  
  
  
  <link rel="stylesheet" href="../../../rst.css" type="text/css" />
</head>


<body>








<div class="document" id="new-iterator-concepts">
<h1 class="title">新的迭代器概念</h1>








<table class="docinfo" frame="void" rules="none">








  <col class="docinfo-name" />
  <col class="docinfo-content" />
  <tbody valign="top">








    <tr>







      <th class="docinfo-name">Author:</th>








      <td>David Abrahams, Jeremy Siek, Thomas Witt</td>







    </tr>








    <tr>







      <th class="docinfo-name">Contact:</th>








      <td><a class="first reference external" href="mailto:dave@boost-consulting.com">dave@boost-consulting.com</a>, <a class="reference external" href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>, <a class="last reference external" href="mailto:witt@styleadvisor.com">witt@styleadvisor.com</a></td>







    </tr>








    <tr>







      <th class="docinfo-name">Organization:</th>








      <td><a class="first reference external" href="http://www.boost-consulting.com">Boost Consulting</a>, Indiana University <a class="reference external" href="http://www.osl.iu.edu">Open Systems
Lab</a>, <a class="last reference external" href="http://www.styleadvisor.com">Zephyr Associates, Inc.</a></td>







    </tr>








    <tr>







      <th class="docinfo-name">Date:</th>








      <td>2006-09-11</td>







    </tr>








    <tr class="field">







      <th class="docinfo-name">Number:</th>







      <td class="field-body">This is a revised version of <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1550.html">n1550</a>=03-0133, which was
accepted for Technical Report 1 by the C++ standard
committee's library working group. This proposal is a
revision of paper <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2001/n1297.html">n1297</a>, <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1477.html">n1477</a>, and <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1531.html">n1531</a>.</td>








    </tr>








    <tr>







      <th class="docinfo-name">Copyright:</th>








      <td>Copyright David Abrahams, Jeremy Siek, and Thomas Witt
2003.</td>







    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<!-- Distributed under the Boost -->
<!-- Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Version 1.25 of this ReStructuredText document is the same as
n1550_, the paper accepted by the LWG. -->
<table class="docutils field-list" frame="void" rules="none">








  <col class="field-name" />
  <col class="field-body" />
  <tbody valign="top">








    <tr class="field">







      <th class="field-name">概要：</th>







      <td class="field-body">我们提出了一个新的迭代器概念系统，独立对待访问和定位。这样允许概念更为接近于算法的要求，并为实际使用提供更好的迭代器分类方法。</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<div class="contents topic" id="table-of-contents">
<p class="topic-title first">目录</p>








<ul class="simple">








  <li><a class="reference internal" href="#motivation" id="id1">动机</a></li>








  <li><a class="reference internal" href="#impact-on-the-standard" id="id2">对标准的影响</a>
    
    
    
    
    
    
    
    <ul>








      <li><a class="reference internal" href="#possible-but-not-proposed-changes-to-the-working-paper" id="id3">对工作文稿的可能的(但未被提议)修改</a>
        
        
        
        
        
        
        
        <ul>








          <li><a class="reference internal" href="#changes-to-algorithm-requirements" id="id4">对算法要求的修改</a></li>








          <li><a class="reference internal" href="#deprecations" id="id5">反对意见</a></li>








          <li><a class="reference internal" href="#vector-bool" id="id6"><tt class="docutils literal"><span class="pre">vector&lt;bool&gt;</span></tt></a></li>








        
        
        
        
        
        
        
        </ul>








      </li>








    
    
    
    
    
    
    
    </ul>








  </li>








  <li><a class="reference internal" href="#design" id="id7">设计</a></li>








  <li><a class="reference internal" href="#proposed-text" id="id8">提议文本</a>
    
    
    
    
    
    
    
    <ul>








      <li><a class="reference internal" href="#addition-to-lib-iterator-requirements" id="id9">添加到 [lib.iterator.requirements]</a>
        
        
        
        
        
        
        
        <ul>








          <li><a class="reference internal" href="#iterator-value-access-concepts-lib-iterator-value-access" id="id10">迭代器的值访问概念 [lib.iterator.value.access]</a>
            
            
            
            
            
            
            
            <ul>








              <li><a class="reference internal" href="#readable-iterators-lib-readable-iterators" id="id11">Readable Iterators 可读迭代器 [lib.readable.iterators]</a></li>








              <li><a class="reference internal" href="#writable-iterators-lib-writable-iterators" id="id12">Writable Iterators 可写迭代器 [lib.writable.iterators]</a></li>








              <li><a class="reference internal" href="#swappable-iterators-lib-swappable-iterators" id="id13">Swappable Iterators 可交换迭代器 [lib.swappable.iterators]</a></li>








              <li><a class="reference internal" href="#lvalue-iterators-lib-lvalue-iterators" id="id14">Lvalue Iterators 左值迭代器 [lib.lvalue.iterators]</a></li>








            
            
            
            
            
            
            
            </ul>








          </li>








          <li><a class="reference internal" href="#iterator-traversal-concepts-lib-iterator-traversal" id="id15">迭代器的遍历概念 [lib.iterator.traversal]</a>
            
            
            
            
            
            
            
            <ul>








              <li><a class="reference internal" href="#incrementable-iterators-lib-incrementable-iterators" id="id16">Incrementable Iterators 可递增迭代器 [lib.incrementable.iterators]</a></li>








              <li><a class="reference internal" href="#single-pass-iterators-lib-single-pass-iterators" id="id17">Single Pass Iterators 单遍迭代器 [lib.single.pass.iterators]</a></li>








              <li><a class="reference internal" href="#forward-traversal-iterators-lib-forward-traversal-iterators" id="id18">Forward Traversal Iterators 前向遍历迭代器 [lib.forward.traversal.iterators]</a></li>








              <li><a class="reference internal" href="#bidirectional-traversal-iterators-lib-bidirectional-traversal-iterators" id="id19">Bidirectional Traversal Iterators 双向遍历迭代器 [lib.bidirectional.traversal.iterators]</a></li>








              <li><a class="reference internal" href="#random-access-traversal-iterators-lib-random-access-traversal-iterators" id="id20">Random Access Traversal Iterators 随机访问遍历迭代器 [lib.random.access.traversal.iterators]</a></li>








              <li><a class="reference internal" href="#interoperable-iterators-lib-interoperable-iterators" id="id21">Interoperable Iterators 可交互迭代器 [lib.interoperable.iterators]</a></li>








            
            
            
            
            
            
            
            </ul>








          </li>








        
        
        
        
        
        
        
        </ul>








      </li>








      <li><a class="reference internal" href="#addition-to-lib-iterator-synopsis" id="id22">添加到 [lib.iterator.synopsis]</a></li>








      <li><a class="reference internal" href="#addition-to-lib-iterator-traits" id="id23">添加到 [lib.iterator.traits]</a></li>








    
    
    
    
    
    
    
    </ul>








  </li>








  <li><a class="reference internal" href="#footnotes" id="id24">脚注</a></li>








</ul>








</div>








<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id1">动机</a></h1>








<p>标准的迭代器分类和要求是有缺陷的，因为它用单个概念层次来处理两个正交的问题：<em>迭代器遍历</em> 和 <em>值访问</em>。因
此，按照此迭代器分类方式所编写的许多算法要求过于严格。另外，真实世界中的许多迭代器并不能被准确地归类。例如，一个可以随机访问遍历的基于代理的迭代
器只能被归类为"输入迭代器"，所以泛型算法不能从它的随机访问能力得到好处。当前的迭代器概念层次是以迭代器遍历方式来分级的(因此有了当前的分类
名)，而对于值访问的要求则被隐藏在不同的地方。下表总结了在当前迭代器分类中的值访问要求。</p>








<table class="docutils" border="1">








  <colgroup><col width="31%" /><col width="69%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="2">在现有迭代器分类中的值访问要求</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td>输出迭代器</td>








      <td><tt class="docutils literal"><span class="pre">*i</span> <span class="pre">=</span> <span class="pre">a</span></tt></td>








    </tr>








    <tr>







      <td>输入迭代器</td>








      <td><tt class="docutils literal"><span class="pre">*i</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">T</span></tt></td>








    </tr>








    <tr>







      <td>前向迭代器</td>








      <td><tt class="docutils literal"><span class="pre">*i</span></tt> 为 <tt class="docutils literal"><span class="pre">T&amp;</span></tt> (或 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></tt> 如果 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-active.html#200">issue 200</a>
被通过)</td>








    </tr>








    <tr>







      <td>随机访问迭代器</td>








      <td><tt class="docutils literal"><span class="pre">i[n]</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">T</span></tt> (对于可变迭代器，如果 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-active.html#299">issue 299</a>
被通过，则要加上 <tt class="docutils literal"><span class="pre">i[n]</span> <span class="pre">=</span> <span class="pre">t</span></tt>
的要求)</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<p>由于迭代器遍历和值访问两个问题被混合在单个层次中，所以许多有用的迭代器不能被正确地归类。例如，<tt class="docutils literal"><span class="pre">vector&lt;bool&gt;::iterator</span></tt> 几乎可以算是一个随机访问迭代器，但它的返回类型不是 <tt class="docutils literal"><span class="pre">bool&amp;</span></tt> (请见
<a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-active.html#96">issue 96</a> 和 Herb Sutter 的论文 J16/99-0008 = WG21
N1185)。因此，<tt class="docutils literal"><span class="pre">vector&lt;bool&gt;</span></tt> 的迭代器只能满足输入迭代器和输出迭代器的要求。这是非常不直观的，在这一点上 C++ 标准自相矛盾。在标准的 23.2.4/1，它说 <tt class="docutils literal"><span class="pre">vector</span></tt> 是一个支持随机访问迭代器的序列容器。</p>








<p>另一个难于归类的迭代器是转换迭代器，它是一个适配器，对某个底层迭代器的提领值执行一个单参函数对象(请见 <a class="reference external" href="http://www.boost.org/libs/utility/transform_iterator.htm">transform_iterator</a>)。对于象 <tt class="docutils literal"><span class="pre">times</span></tt> 这样的单参函数，<tt class="docutils literal"><span class="pre">operator*</span></tt> 的返回类型应该是函数对象的 <tt class="docutils literal"><span class="pre">result_type<span style="font-family: sans;">，它显然不是一个引用。因为随机访问迭代器要求</span></span></tt> <tt class="docutils literal"><span class="pre">operator*</span></tt> 返回一个左值，如果你用一个转换迭代器对 <tt class="docutils literal"><span class="pre">int*</span></tt> 进行包装，则不能得到如你所愿一个随机访问迭代器，而只是一个输入迭代器。</p>








<p>第三个例子是
<a class="reference external" href="http://www.boost.org/libs/graph/doc/table_of_contents.html">Boost Graph 库</a> 中的点和边迭代器。这些迭代器返回点和边的描述符，它们是就地创建的轻量级句柄。它们必须以值方式返回。因此，它们当前的迭代器分类为 <tt class="docutils literal"><span class="pre">input_iterator_tag</span></tt>, 这意味着严格地说，你不能将这些迭代器用于象 <tt class="docutils literal"><span class="pre">min_element()</span></tt> 这样的算法。作为临时的解决方法，引入了概念
<a class="reference external" href="http://www.boost.org/libs/utility/MultiPassInputIterator.html">Multi-Pass 输入迭代器</a> 来描述点和边描述符，但是正如该概念建议的设计注释所说，需要一个更好的解决方案。</p>








<p>简单地说，有许多有用的迭代器不能准确地归入当前的标准迭代器类别中。结果就导致了以下不好的后果：</p>








<ul class="simple">








  <li>迭代器常常被错误地归类。</li>








  <li>对算法的要求过于严格，因为它们不能将对随机访问或双向遍历的需要与对返回真实引用的需要分开。</li>








</ul>








</div>








<div class="section" id="impact-on-the-standard">
<h1><a class="toc-backref" href="#id2">对标准的影响</a></h1>








<p>这个对TR1的建议纯粹只是一个扩充。进一步说，这些新的迭代器概念是后向兼容于旧的迭代器要求的，而且旧的迭代器也前向兼容于新的迭代器概念。也就是说，满足旧要求的迭代器也满足新系统中的对应概念，符合新概念的迭代器也自动满足相应的旧要求。</p>








<!-- I think we need to say something about the resolution to allow
convertibility to any of the old-style tags as a TR issue (hope it
made it). -DWA -->
<!-- Hmm, not sure I understand. Are you talking about whether a
standards conforming input iterator is allowed to have
a tag that is not input_iterator_tag but that
is convertible to input_iterator_tag? -JGS -->
<div class="section" id="possible-but-not-proposed-changes-to-the-working-paper">
<h2><a class="toc-backref" href="#id3">对工作文稿的可能(但未被提议)的修改</a></h2>








<p>对于本文中建议的几个修改，我们可能会为下一个标准准备工作文稿。这些修改还不是 TR1 的正式部分。</p>








<div class="section" id="changes-to-algorithm-requirements">
<h3><a class="toc-backref" href="#id4">对算法要求的修改</a></h3>








<p>标准库中的算法可以从新的迭代器概念中获得好处，因为新的迭代器概念为它们对类型的要求提供了更精确的方法。结果是算法可以在更多的情形下使用，同时对类型的要求也更少。</p>








<p>对于下一个工作文稿(不是 TR1)，委员会将考虑对算法的类型要求作出以下修改。这些修改可称为文本替换，对以下列出的每个算法进行相应的文本替换。</p>








<p>前向迭代器 -&gt; 前向遍历迭代器及可读迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">find_end,</span> <span class="pre">adjacent_find,</span> <span class="pre">search,</span> <span class="pre">search_n,</span> <span class="pre">rotate_copy,</span>
  <span class="pre">lower_bound,</span> <span class="pre">upper_bound,</span> <span class="pre">equal_range,</span> <span class="pre">binary_search,</span>
  <span class="pre">min_element,</span> <span class="pre">max_element</span></tt></blockquote>








<p>前向迭代器(1) -&gt; 单遍迭代器及可读迭代器，前向迭代器(2) -&gt; 前向遍历迭代器及可读迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">find_first_of</span></tt></blockquote>








<p>前向迭代器 -&gt; 可读迭代器及可写迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">iter_swap</span></tt></blockquote>








<p>前向迭代器 -&gt; 单遍迭代器及可写迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">fill,</span> <span class="pre">generate</span></tt></blockquote>








<p>前向迭代器 -&gt; 前向迭代器及可交换迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">rotate</span></tt></blockquote>








<p>前向迭代器(1) -&gt; 可交换迭代器及单遍迭代器，前向迭代器(2) -&gt; 可交换迭代器及可递增迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">swap_ranges</span></tt></blockquote>








<dl class="docutils">








  <dt>前向迭代器 -&gt; 前向遍历迭代器及可读迭代器及可写迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">remove,</span> <span class="pre">remove_if,</span> <span class="pre">unique</span></tt></dd>








</dl>








<p>前向迭代器 -&gt; 单遍迭代器及可读迭代器及可写迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">replace,</span> <span class="pre">replace_if</span></tt></blockquote>








<dl class="docutils">








  <dt>双向迭代器 -&gt; 双向遍历迭代器及可交换迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">reverse</span></tt></dd>








  <dt>双向迭代器 -&gt; 双向遍历迭代器及可读迭代器及可交换迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">partition</span></tt></dd>








</dl>








<p>双向迭代器(1) -&gt; 双向遍历迭代器及可读迭代器，双向迭代器(2) -&gt; 双向遍历迭代器及可写迭代器</p>








<blockquote>
  <tt class="docutils literal"><span class="pre">copy_backwards</span></tt></blockquote>








<dl class="docutils">








  <dt>双向迭代器 -&gt; 双向遍历迭代器及可交换迭代器及可读迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">next_permutation,</span> <span class="pre">prev_permutation</span></tt></dd>








  <dt>双向迭代器 -&gt; 双向遍历迭代器及可读迭代器及可写迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">stable_partition,</span> <span class="pre">inplace_merge</span></tt></dd>








  <dt>双向迭代器 -&gt; 双向遍历迭代器及可读迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">reverse_copy</span></tt></dd>








  <dt>随机访问迭代器 -&gt; 随机访问遍历迭代器及可读迭代器及可写迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">random_shuffle,</span> <span class="pre">sort,</span> <span class="pre">stable_sort,</span> <span class="pre">partial_sort,</span> <span class="pre">nth_element,</span> <span class="pre">push_heap,</span> <span class="pre">pop_heap</span>
    <span class="pre">make_heap,</span> <span class="pre">sort_heap</span></tt></dd>








  <dt>输入迭代器(2) -&gt; 可递增迭代器及可读迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">equal,</span> <span class="pre">mismatch</span></tt></dd>








  <dt>输入迭代器(2) -&gt; 可递增迭代器及可读迭代器</dt>








  <dd><tt class="docutils literal"><span class="pre">transform</span></tt></dd>








</dl>








</div>








<div class="section" id="deprecations">
<h3><a class="toc-backref" href="#id5">反对意见</a></h3>








<p>对于下一个工作文稿(不是 TR1)，委员会将考虑取消旧的迭代器分类标志，以及
std::iterator_traits，因为它将被独立的
traits 元函数所取代。</p>








</div>








<div class="section" id="vector-bool">
<h3><a class="toc-backref" href="#id6"><tt class="docutils literal"><span class="pre">vector&lt;bool&gt;</span></tt></a></h3>








<p>对于下一个工作文稿(不是 TR1)，委员会将考虑将 <tt class="docutils literal"><span class="pre">vector&lt;bool&gt;::iterator</span></tt> 重新归类为随机访问遍历迭代器及可读迭代器及可写迭代器。</p>








</div>








</div>








</div>








<div class="section" id="design">
<h1><a class="toc-backref" href="#id7">设计</a></h1>








<p>迭代器的要求被分为两组。一组概念处理值访问的语法和语义：</p>








<ul class="simple">








  <li>可读迭代器</li>








  <li>可写迭代器</li>








  <li>可交换迭代器</li>








  <li>左值迭代器</li>








</ul>








<p>这个访问概念描述了对于 <tt class="docutils literal"><span class="pre">operator*</span></tt> 和
<tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> 的要求，包括 <tt class="docutils literal"><span class="pre">value_type</span></tt>, <tt class="docutils literal"><span class="pre">reference</span></tt>, 和
<tt class="docutils literal"><span class="pre">pointer</span></tt> 等关联类型。</p>








<p>另一组概念处理遍历：</p>








<ul class="simple">








  <li>可递增迭代器</li>








  <li>单遍迭代器</li>








  <li>前向遍历迭代器</li>








  <li>双向遍历迭代器</li>








  <li>随机访问遍历迭代器</li>








</ul>








<p>下图表示了以上遍历概念的强化关系。</p>








<img alt="traversal.png" src="traversal.png" />
<p>除了迭代器移动操作符如
<tt class="docutils literal"><span class="pre">operator++</span></tt> 之外，遍历概念还包括了对位置比较的要求，如 <tt class="docutils literal"><span class="pre">operator==</span></tt> 和 <tt class="docutils literal"><span class="pre">operator&lt;</span></tt>。将概念细分为可递增和单遍的，是为了提供对原有的输入和输出迭代器要求更为精确的匹配。</p>








<p>本建议中还包含一个概念，用于指定一个迭代器可以与另一个迭代器相互操作，如 <tt class="docutils literal"><span class="pre">int*</span></tt> 可以与 <tt class="docutils literal"><span class="pre">int</span> <span class="pre">const*</span></tt> 相互操作。</p>








<ul class="simple">








  <li>可交互迭代器</li>








</ul>








<p>下图表示了新的迭代器概念与旧的概念之间的关系。</p>








<img alt="oldeqnew.png" src="oldeqnew.png" />
<p>和旧的迭代器要求一样，我们提供了一些标志以实现基于遍历概念进行分派。这些标志通过继承相互联系，因此一个标志可以转换为另一个标志，如果与第一个标志相关的概念强化自第二个标志所对应的概念。</p>








<p>我们的设计重用了 <tt class="docutils literal"><span class="pre">iterator_traits&lt;Iter&gt;::iterator_category</span></tt> 来表示一个迭代器的遍历能力。要指定旧式迭代器分类所不包含的能力，迭代器的设计者可以用一个既可转换为最合适的旧迭代器类别，又可以转换为合适的新迭代器遍历标志的 <tt class="docutils literal"><span class="pre">iterator_category</span></tt> 类型。</p>








<!-- dwa2003/1/2: Note that we are not *requiring* convertibility to
a new-style traversal tag in order to meet new concepts.
Old-style iterators still fit, after all. -->
<p>我们不提供实现基于访问概念进行分派的标志，部分原因是我们没有办法自动地正确推断出旧式迭代器的访问标志。一个迭代器的可写性可能依赖于它的 <tt class="docutils literal"><span class="pre">value_type</span></tt> 的可赋值性，但我们没有办法检查一个任意类型是否可赋值的。还好，对基于访问能力进行分派的需求并没有基于遍历能力进行分派的需求那么迫切。</p>








<p>一个困难的设计决定是关于 <tt class="docutils literal"><span class="pre">operator[]</span></tt> 的。直接的方法是指定 <tt class="docutils literal"><span class="pre">operator[]</span></tt> 的返回某个类型的
<tt class="docutils literal"><span class="pre">reference</span></tt>; 和 <tt class="docutils literal"><span class="pre">operator*</span></tt> 一样。但是，沿着这个方向下去会发现，一个满足旧的随机访问迭代器要求的迭代器将不需要符合可读或可写左值迭代器。为此我们选择了另一个设计，与 <a class="reference external" href="http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-active.html#299">issue 299</a> 中的首选决议相同：<tt class="docutils literal"><span class="pre">operator[]</span></tt> 只被要求返回某个可转换为 <tt class="docutils literal"><span class="pre">value_type</span></tt>
的东西(对于可读迭代器)，以及被要求支持赋值
<tt class="docutils literal"><span class="pre">i[n]</span> <span class="pre">=</span> <span class="pre">t</span></tt> (对于可写迭代器)。</p>








</div>








<div class="section" id="proposed-text">
<h1><a class="toc-backref" href="#id8">提议文本</a></h1>








<div class="section" id="addition-to-lib-iterator-requirements">
<h2><a class="toc-backref" href="#id9">添加到 [lib.iterator.requirements]</a></h2>








<div class="section" id="iterator-value-access-concepts-lib-iterator-value-access">
<h3><a class="toc-backref" href="#id10">迭代器的值访问概念 [lib.iterator.value.access]</a></h3>








<p>在下表中，<tt class="docutils literal"><span class="pre">X</span></tt> 是一个迭代器类型，<tt class="docutils literal"><span class="pre">a</span></tt> 是类型 <tt class="docutils literal"><span class="pre">X</span></tt> 的一个常量对象，<tt class="docutils literal"><span class="pre">R</span></tt> 是
<tt class="docutils literal"><span class="pre">std::iterator_traits&lt;X&gt;::reference</span></tt>，<tt class="docutils literal"><span class="pre">T</span></tt> 是
<tt class="docutils literal"><span class="pre">std::iterator_traits&lt;X&gt;::value_type</span></tt>，<tt class="docutils literal"><span class="pre">v</span></tt> 是类型 <tt class="docutils literal"><span class="pre">T</span></tt> 的一个常量对象。</p>








<div class="section" id="readable-iterators-lib-readable-iterators">
<span id="readable-iterator"></span>
<h4><a class="toc-backref" href="#id11">可读迭代器 [lib.readable.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt>&nbsp;符合值类型 <tt class="docutils literal"><span class="pre">T</span></tt> 的 <em>Readable Iterator可读迭代器</em> 概念<tt class="docutils literal"><span class="pre"></span></tt>，如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是可赋值的和可复制构造的，且以下表达式有效并遵从规定的语义。<tt class="docutils literal"><span class="pre">U</span></tt> 为类型 <tt class="docutils literal"><span class="pre">T</span></tt> 的某个指定成员的类型。</p>








<table class="docutils" border="1">








  <colgroup><col width="28%" /><col width="20%" /><col width="52%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="3">可读迭代器要求 (除了可赋值和可复制构造以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">备注/前提条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">iterator_traits&lt;X&gt;::value_type</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">T</span></tt></td>








      <td>任意非引用、非-cv-限定的类型</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">*a</span></tt></td>








      <td>Convertible to <tt class="docutils literal"><span class="pre">T</span></tt></td>








      <td>
      
      
      
      
      
      
      
      <dl class="first last docutils">








        <dt>前提条件：<tt class="docutils literal"><span class="pre">a</span></tt> 是可提领的。如果 <tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt> 则 <tt class="docutils literal"><span class="pre">*a </span></tt>等价于 <tt class="docutils literal"><span class="pre">*b</span></tt></dt>








        



      
      
      
      
      
      
      
      </dl>








      </td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a-&gt;m</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">U&amp;</span></tt></td>








      <td>前提条件：<tt class="docutils literal"><span class="pre">(*a).m</span></tt> 有良好定义。等价于 <tt class="docutils literal"><span class="pre">(*a).m</span></tt>.</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<!-- We won't say anything about iterator_traits<X>::reference until the DR is resolved. -JGS -->
</div>








<div class="section" id="writable-iterators-lib-writable-iterators">
<span id="writable-iterator"></span>
<h4><a class="toc-backref" href="#id12">可写迭代器 [lib.writable.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 符合 <em>Writable Iterator可写迭代器</em> 概念，如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是可复制构造的，且以下表达式有效并遵从规定的语义。可写迭代器有一个关联的值类型组。</p>








<table class="docutils" border="1">








  <colgroup><col width="37%" /><col width="21%" /><col width="42%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="3">可写迭代器要求 (除了可复制构造以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">前提条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">*a</span> <span class="pre">=</span> <span class="pre">o</span></tt></td>








      <td>&nbsp;</td>








      <td>前提条件：<tt class="docutils literal"><span class="pre">o</span></tt>
的类型在 <tt class="docutils literal"><span class="pre">X</span></tt> 的值类型组中<tt class="docutils literal"><span class="pre"></span></tt></td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








</div>








<div class="section" id="swappable-iterators-lib-swappable-iterators">
<h4><a class="toc-backref" href="#id13">可交换迭代器 [lib.swappable.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 符合 <em>Swappable Iterator可交换机迭代器</em> 概念，如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是可复制构造的，且以下表达式有效并遵从规定的语义。</p>








<table class="docutils" border="1">








  <colgroup><col width="37%" /><col width="19%" /><col width="43%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="3">可交换迭代器要求 (除了可复制构造以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">后续条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">iter_swap(a,</span> <span class="pre">b)</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">void</span></tt></td>








      <td>所指向的值被交换</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<p>[<em>注：</em>一个同时符合 <a class="reference internal" href="#readable-iterator">可读迭代器</a> 和
<a class="reference internal" href="#writable-iterator">可写迭代器</a> 概念的迭代器也符合 <em>可交换迭代器</em>。  <em>--end note</em>]</p>








</div>








<div class="section" id="lvalue-iterators-lib-lvalue-iterators">
<h4><a class="toc-backref" href="#id14">左值迭代器 [lib.lvalue.iterators]</a></h4>








<p><em>Lvalue Iterator左值迭代器</em> 概念增加一个要求，即 <tt class="docutils literal"><span class="pre">operator*</span></tt> 的返回类型应为迭代器的值类型的引用。</p>








<table class="docutils" border="1">








  <colgroup><col width="22%" /><col width="19%" /><col width="59%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="3">左值迭代器要求</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">备注/断言</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">*a</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">T&amp;</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">T</span></tt> 为 <em>cv</em>
      <tt class="docutils literal"><span class="pre">iterator_traits&lt;X&gt;::value_type</span></tt>，其中 <em>cv</em> 是一个可选的
cv-限定符。<br />




前提条件：<tt class="docutils literal"><span class="pre">a</span></tt> 是可提领的。</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<p>如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是一个 <a class="reference internal" href="#writable-iterator">可写迭代器</a>，则 <tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt> 当且仅当
<tt class="docutils literal"><span class="pre">*a</span></tt> 与 <tt class="docutils literal"><span class="pre">*b</span></tt> 为同一个对象。如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是一个 <a class="reference internal" href="#readable-iterator">可读迭代器</a>，则 <tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt> 意味着 <tt class="docutils literal"><span class="pre">*a</span></tt> 与
<tt class="docutils literal"><span class="pre">*b</span></tt> 为同一个对象。</p>








</div>








</div>








<div class="section" id="iterator-traversal-concepts-lib-iterator-traversal">
<h3><a class="toc-backref" href="#id15">迭代器遍历概念 [lib.iterator.traversal]</a></h3>








<p>在下表中，<tt class="docutils literal"><span class="pre">X</span></tt> 是一个迭代器类型，<tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">b</span></tt> 是类型 <tt class="docutils literal"><span class="pre">X</span></tt> 的一个常量对象，<tt class="docutils literal"><span class="pre">r</span></tt> 和 <tt class="docutils literal"><span class="pre">s</span></tt> 是类型 <tt class="docutils literal"><span class="pre">X</span></tt><tt class="docutils literal"><span class="pre"> 的可变对象，</span></tt><tt class="docutils literal"><span class="pre">T</span></tt> 是
<tt class="docutils literal"><span class="pre">std::iterator_traits&lt;X&gt;::value_type</span></tt>，<tt class="docutils literal"><span class="pre">v</span></tt> 是类型 <tt class="docutils literal"><span class="pre">T</span></tt> 的一个常量对象。</p>




<div class="section" id="incrementable-iterators-lib-incrementable-iterators">
<h4><a class="toc-backref" href="#id16">可递增迭代器 [lib.incrementable.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 符合 <em>Incrementable Iterator可递增迭代嚣</em>
概念，如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是可赋值的和可复制构造的，且以下表达式有效并遵从规定的语义。</p>








<table class="docutils" border="1">








  <colgroup><col width="39%" /><col width="38%" /><col width="23%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="3">可递增迭代器要求 (除了可赋值和可复制构造以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">断言</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">++r</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X&amp;</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">&amp;r</span> <span class="pre">==</span> <span class="pre">&amp;++r</span></tt></td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">r++</span></tt></td>








      <td>&nbsp;</td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">*r++</span></tt></td>








      <td>&nbsp;</td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">iterator_traversal&lt;X&gt;::type</span></tt></td>








      <td>可转换为
      <tt class="docutils literal"><span class="pre">incrementable_traversal_tag</span></tt></td>








      <td>&nbsp;</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<p>如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是一个 <a class="reference internal" href="#writable-iterator">可写迭代器</a> 则 <tt class="docutils literal"><span class="pre">X</span> <span class="pre">a(r++);</span></tt> 等价于 <tt class="docutils literal"><span class="pre">X</span> <span class="pre">a(r);</span> <span class="pre">++r;</span></tt> 且 <tt class="docutils literal"><span class="pre">*r++</span> <span class="pre">=</span> <span class="pre">o</span></tt> 等价于  <tt class="docutils literal"><span class="pre">*r</span> <span class="pre">=</span> <span class="pre">o;</span> <span class="pre">++r</span></tt>. 如果 <tt class="docutils literal"><span class="pre">X</span></tt> 是一个 <a class="reference internal" href="#readable-iterator">可读迭代器</a> 则 <tt class="docutils literal"><span class="pre">T</span> <span class="pre">z(*r++);</span></tt> 等价于 <tt class="docutils literal"><span class="pre">T</span> <span class="pre">z(*r);</span> <span class="pre">++r;</span></tt>.</p>








<!-- TR1: incrementable_iterator_tag changed to
incrementable_traversal_tag for consistency. -->
</div>








<div class="section" id="single-pass-iterators-lib-single-pass-iterators">
<h4><a class="toc-backref" href="#id17">单遍迭代器 [lib.single.pass.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 符合 <em>Single Pass Iterator单遍迭代器</em>
概念，如果以下表达式有效且遵从规定的语义。</p>








<table class="docutils" border="1">








  <colgroup><col width="32%" /><col width="29%" /><col width="13%" /><col width="27%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="4">单遍迭代器要求 (除了可递增迭代器和可等价比较以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">操作语义</th>








    <th class="head">断言/前提条件/后续条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">++r</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X&amp;</span></tt></td>








      <td>&nbsp;</td>








      <td>前提：<tt class="docutils literal"><span class="pre">r</span></tt> 是可提领的；<br />



后续：<tt class="docutils literal"><span class="pre">r</span></tt> 是可提领的或 <tt class="docutils literal"><span class="pre">r</span></tt> 指向末尾</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td>&nbsp;</td>








      <td><tt class="docutils literal"><span class="pre">==</span></tt> 为该领域的一个等价关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">!(a</span> <span class="pre">==</span> <span class="pre">b)</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">iterator_traversal&lt;X&gt;::type</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">single_pass_traversal_tag</span></tt></td>








      <td>&nbsp;</td>








      <td>&nbsp;</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<!-- TR1: single_pass_iterator_tag changed to
single_pass_traversal_tag for consistency -->
</div>








<div class="section" id="forward-traversal-iterators-lib-forward-traversal-iterators">
<h4><a class="toc-backref" href="#id18">前向遍历迭代器 [lib.forward.traversal.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 符合 <em>Forward Traversal Iterator前向遍历迭代器</em>
概念，如果 <tt class="docutils literal"><span class="pre">X</span></tt> 符合可缺省构造和单遍迭代器的要求，且以下表达式有效并遵从规定的语义。</p>








<table class="docutils" border="1">








  <colgroup><col width="38%" /><col width="34%" /><col width="27%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="3">前向遍历迭代器要求 (除了可缺省构造和单遍迭代器以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">断言/备注</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">u;</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X&amp;</span></tt></td>








      <td>注：<tt class="docutils literal"><span class="pre">u</span></tt> 可以具有异常值</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">++r</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X&amp;</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">r</span> <span class="pre">==</span> <span class="pre">s</span></tt> 且 <tt class="docutils literal"><span class="pre">r</span></tt> 为可提领的则 <tt class="docutils literal"><span class="pre">++r</span> <span class="pre">==</span> <span class="pre">++s.</span></tt></td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">iterator_traits&lt;X&gt;::difference_type</span></tt></td>








      <td>一个有符号整型类型，表示两个迭代器间的距离</td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">iterator_traversal&lt;X&gt;::type</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">forward_traversal_tag</span></tt></td>








      <td>&nbsp;</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<!-- TR1: forward_traversal_iterator_tag changed to
forward_traversal_tag for consistency -->
</div>








<div class="section" id="bidirectional-traversal-iterators-lib-bidirectional-traversal-iterators">
<h4><a class="toc-backref" href="#id19">双向遍历迭代器 [lib.bidirectional.traversal.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 符合 <em>Bidirectional Traversal
Iterator双向遍历迭代器</em> 概念，如果 <tt class="docutils literal"><span class="pre">X</span></tt> 符合前向遍历迭代器的要求，且以下表达式有效并遵从规定的语义。</p>








<table class="docutils" border="1">








  <colgroup><col width="33%" /><col width="32%" /><col width="14%" /><col width="21%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="4">双向遍历迭代器要求 (除了前向遍历迭代器以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">操作语义</th>








    <th class="head">断言/前提/后续条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">--r</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X&amp;</span></tt></td>








      <td>&nbsp;</td>








      <td>
      
      
      
      
      
      
      
      <p class="first">前提：存在某个 <tt class="docutils literal"><span class="pre">s</span></tt> 使得 <tt class="docutils literal"><span class="pre">r</span>
      <span class="pre">==</span> <span class="pre">++s</span></tt>.&nbsp;</p>



      
      
      
      <p class="first">后续：<tt class="docutils literal"><span class="pre">s</span></tt> 为可提领的</p>








      
      
      
      
      
      
      
      <p class="last"><tt class="docutils literal"><span class="pre">++(--r)</span> <span class="pre">==</span> <span class="pre">r</span></tt>.
      <tt class="docutils literal"><span class="pre">--r</span> <span class="pre">==</span> <span class="pre">--s</span></tt> 意味着 <tt class="docutils literal"><span class="pre">r</span> <span class="pre">==</span>
      <span class="pre">s</span></tt>. <tt class="docutils literal"><span class="pre">&amp;r</span> <span class="pre">==</span> <span class="pre">&amp;--r</span></tt>.</p>








      </td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">r--</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">X&amp;</span></tt></td>








      <td>
      
      
      
      
      
      
      
      <pre class="first last literal-block">{<br />  X tmp = r;<br />  --r;<br />  return tmp;<br />}<br /></pre>








      </td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">iterator_traversal&lt;X&gt;::type</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">bidirectional_traversal_tag</span></tt></td>








      <td>&nbsp;</td>








      <td>&nbsp;</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<!-- TR1: bidirectional_traversal_iterator_tag changed to
bidirectional_traversal_tag for consistency -->
</div>








<div class="section" id="random-access-traversal-iterators-lib-random-access-traversal-iterators">
<h4><a class="toc-backref" href="#id20">随机访问遍历迭代器 [lib.random.access.traversal.iterators]</a></h4>








<p>一个类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 符合 <em>Random Access Traversal
Iterator随机访问遍历迭代器</em> 概念，如果以下表达式有效且遵从规定的语义。在下表中，<tt class="docutils literal"><span class="pre">Distance</span></tt> 是
<tt class="docutils literal"><span class="pre">iterator_traits&lt;X&gt;::difference_type</span></tt> 而 <tt class="docutils literal"><span class="pre">n</span></tt> 表示类型 <tt class="docutils literal"><span class="pre">Distance</span></tt> 的一个常量对象。</p>








<table class="docutils" border="1">








  <colgroup><col width="28%" /><col width="30%" /><col width="23%" /><col width="20%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head" colspan="4">随机访问遍历迭代器要求 (除了双向遍历迭代器以外)</th>








  </tr>








  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">操作语义</th>








    <th class="head">断言/前提条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">r</span> <span class="pre">+=</span> <span class="pre">n</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X&amp;</span></tt></td>








      <td>
      
      
      
      
      
      
      
      <pre class="first last literal-block">{<br />  Distance m = n;<br />  if (m &gt;= 0)<br />    while (m--)<br />      ++r;<br />  else<br />    while (m++)<br />      --r;<br />  return r;<br />}<br /></pre>








      </td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">n</span></tt>, <tt class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">a</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">{</span> <span class="pre">X</span> <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">a;</span> <span class="pre">return</span> <span class="pre">tmp</span>
      <span class="pre">+=</span> <span class="pre">n;</span> <span class="pre">}</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">r</span> <span class="pre">-=</span> <span class="pre">n</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X&amp;</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">return</span> <span class="pre">r</span> <span class="pre">+=</span> <span class="pre">-n</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">n</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">X</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">{</span> <span class="pre">X</span> <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">a;</span> <span class="pre">return</span> <span class="pre">tmp</span>
      <span class="pre">-=</span> <span class="pre">n;</span> <span class="pre">}</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">b</span> <span class="pre">-</span> <span class="pre">a</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">Distance</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">?</span>&nbsp; <span class="pre">distance(a,b)</span>
      <span class="pre">:</span> <span class="pre">-distance(b,a)</span></tt></td>








      <td>前提：存在一个<tt class="docutils literal"><span class="pre"></span></tt>
      <tt class="docutils literal"><span class="pre">Distance</span></tt> 的值 <tt class="docutils literal"><span class="pre">n</span></tt> 使得
      <tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">b</span></tt>.  <tt class="docutils literal"><span class="pre">b</span>
      <span class="pre">==</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">-</span> <span class="pre">a)</span></tt>.</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a[n]</span></tt></td>








      <td>可转换为 T</td>








      <td><tt class="docutils literal"><span class="pre">*(a</span> <span class="pre">+</span> <span class="pre">n)</span></tt></td>








      <td>前提：a 是一个 <a class="reference internal" href="#readable-iterator">可读迭代器</a></td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a[n]</span> <span class="pre">=</span> <span class="pre">v</span></tt></td>








      <td>可转换为&nbsp;T</td>








      <td><tt class="docutils literal"><span class="pre">*(a</span> <span class="pre">+</span> <span class="pre">n)</span> <span class="pre">=</span> <span class="pre">v</span></tt></td>








      <td>前提：a 是一个 <a class="reference internal" href="#writable-iterator">可写迭代器</a></td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">b</span> <span class="pre">-</span> <span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">&lt;</span></tt> 是一个全序关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">a</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">&gt;</span></tt> 是一个全序关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">!(a</span> <span class="pre">&lt;</span> <span class="pre">b)</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">!(a</span> <span class="pre">&gt;</span> <span class="pre">b)</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">iterator_traversal&lt;X&gt;::type</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">random_access_traversal_tag</span></tt></td>








      <td>&nbsp;</td>








      <td>&nbsp;</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<!-- TR1: random_access_traversal_iterator_tag changed to
random_access_traversal_tag for consistency -->
</div>








<div class="section" id="interoperable-iterators-lib-interoperable-iterators">
<h4><a class="toc-backref" href="#id21">可交互迭代器 [lib.interoperable.iterators]</a></h4>








<p>一个符合单遍迭代器概念的类或内建类型 <tt class="docutils literal"><span class="pre">X</span></tt> 与另一个也符合单遍迭代器概念的类或内建类型 <tt class="docutils literal"><span class="pre">Y</span></tt> 是&nbsp;<em>interoperable可交互的</em>，如果以下表达式有效且遵从规定的语义。在下表中，<tt class="docutils literal"><span class="pre">x</span></tt> 是类型 <tt class="docutils literal"><span class="pre">X</span></tt> 的一个对象，<tt class="docutils literal"><span class="pre">y</span></tt> 是类型 <tt class="docutils literal"><span class="pre">Y</span></tt> 的一个对象，<tt class="docutils literal"><span class="pre">Distance</span></tt> 是
<tt class="docutils literal"><span class="pre">iterator_traits&lt;Y&gt;::difference_type</span></tt>，而 <tt class="docutils literal"><span class="pre">n</span></tt> 表示类型 <tt class="docutils literal"><span class="pre">Distance</span></tt> 的一个常量对象。</p>








<table class="docutils" border="1">








  <colgroup><col width="13%" /><col width="27%" /><col width="60%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">断言/前提条件/后续条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">Y</span></tt></td>








      <td>后续条件：<tt class="docutils literal"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></tt></td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">Y(x)</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">Y</span></tt></td>








      <td><span style="font-family: monospace;">后续条件：</span><tt class="docutils literal"><span class="pre">Y(x)</span> <span class="pre">==</span> <span class="pre">x</span></tt></td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">==</span></tt> 是该领域的一个等价关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">==</span></tt> 是该领域的一个等价关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td>在该领域中 <tt class="docutils literal"><span class="pre">bool(a==b)</span> <span class="pre">!=</span> <span class="pre">bool(a!=b)</span></tt>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td>在该领域中 <tt class="docutils literal"><span class="pre">bool(a==b)</span> <span class="pre">!=</span> <span class="pre">bool(a!=b)</span></tt></td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








<p>如果 <tt class="docutils literal"><span class="pre">X</span></tt> 和 <tt class="docutils literal"><span class="pre">Y</span></tt> 都是随机访问遍历迭代器，则必须满足以下要求。</p>








<table class="docutils" border="1">








  <colgroup><col width="12%" /><col width="25%" /><col width="23%" /><col width="41%" /></colgroup>
  <thead valign="bottom">
  <tr>







    <th class="head">表达式</th>








    <th class="head">返回类型</th>








    <th class="head">操作语义</th>








    <th class="head">断言/前提条件</th>








  </tr>








  </thead>
  <tbody valign="top">








    <tr>







      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt></td>








      <td>可转换为 <tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">-</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">&lt;</span></tt> 是一个全序关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">x</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">&lt;</span></tt>&nbsp;是一个全序关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">x</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">&gt;</span></tt>&nbsp;是一个全序关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">&gt;</span></tt>&nbsp;是一个全序关系</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">!(x</span> <span class="pre">&lt;</span> <span class="pre">y)</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">!(y</span> <span class="pre">&lt;</span> <span class="pre">x)</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">!(x</span> <span class="pre">&gt;</span> <span class="pre">y)</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">x</span></tt></td>








      <td>可转换为&nbsp;<tt class="docutils literal"><span class="pre">bool</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">!(y</span> <span class="pre">&gt;</span> <span class="pre">x)</span></tt></td>








      <td>&nbsp;</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">y</span> <span class="pre">-</span> <span class="pre">x</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">Distance</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">distance(Y(x),y)</span></tt></td>








      <td>前提：存在一个&nbsp;<tt class="docutils literal"><span class="pre">Distance</span></tt> 的值 <tt class="docutils literal"><span class="pre">n</span></tt> 使得 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">y</span></tt>.
      <tt class="docutils literal"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">(y</span> <span class="pre">-</span> <span class="pre">x)</span></tt>.</td>








    </tr>








    <tr>







      <td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">Distance</span></tt></td>








      <td><tt class="docutils literal"><span class="pre">distance(y,Y(x))</span></tt></td>








      <td>前提：存在一个&nbsp;<tt class="docutils literal"><span class="pre">Distance</span></tt> 的值 <tt class="docutils literal"><span class="pre">n</span></tt> 使得 <tt class="docutils literal"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">x</span></tt>.
      <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">(x</span> <span class="pre">-</span> <span class="pre">y)</span></tt>.</td>








    </tr>








  
  
  
  
  
  
  
  </tbody>
</table>








</div>








</div>








</div>








<div class="section" id="addition-to-lib-iterator-synopsis">
<h2><a class="toc-backref" href="#id22">添加到 [lib.iterator.synopsis]</a></h2>








<pre class="literal-block">// lib.iterator.traits, traits 和 tags<br />template &lt;class Iterator&gt; struct is_readable_iterator;<br />template &lt;class Iterator&gt; struct iterator_traversal;<br /><br />struct incrementable_traversal_tag { };<br />struct single_pass_traversal_tag : incrementable_traversal_tag { };<br />struct forward_traversal_tag : single_pass_traversal_tag { };<br />struct bidirectional_traversal_tag : forward_traversal_tag { };<br />struct random_access_traversal_tag : bidirectional_traversal_tag { };<br /></pre>








</div>








<div class="section" id="addition-to-lib-iterator-traits">
<h2><a class="toc-backref" href="#id23">添加到 [lib.iterator.traits]</a></h2>








<p>类模板 <tt class="docutils literal"><span class="pre">is_readable_iterator</span></tt> 满足 <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1519.htm">UnaryTypeTrait</a> 的要求。</p>








<p>给定一个迭代器类型 <tt class="docutils literal"><span class="pre">X</span></tt>, <tt class="docutils literal"><span class="pre">is_readable_iterator&lt;X&gt;::value</span></tt> 为 <tt class="docutils literal"><span class="pre">true</span></tt> 如果对于类型&nbsp;<tt class="docutils literal"><span class="pre">X</span></tt> 的一个对象 <tt class="docutils literal"><span class="pre">a</span></tt><tt class="docutils literal"><span class="pre"></span></tt>, <tt class="docutils literal"><span class="pre">*a</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">iterator_traits&lt;X&gt;::value_type</span></tt>, 否则为 <tt class="docutils literal"><span class="pre">false</span></tt>.</p>








<p><tt class="docutils literal"><span class="pre">iterator_traversal&lt;X&gt;::type</span></tt> 为</p>








<pre class="literal-block"><em>category-to-traversal</em>(iterator_traits&lt;X&gt;::iterator_category)<br /></pre>








<p>其中 <em>category-to-traversal</em> 定义如下：</p>








<pre class="literal-block" id="category-to-traversal"><em>category-to-traversal</em>(C) =<br />    if (C 可转换为 incrementable_traversal_tag)<br />        return C;<br />    else if (C 可转换为 random_access_iterator_tag)<br />        return random_access_traversal_tag;<br />    else if (C 可转换为 bidirectional_iterator_tag)<br />        return bidirectional_traversal_tag;<br />    else if (C 可转换为 forward_iterator_tag)<br />        return forward_traversal_tag;<br />    else if (C 可转换为 input_iterator_tag)<br />        return single_pass_traversal_tag;<br />    else if (C 可转换为 output_iterator_tag)<br />        return incrementable_traversal_tag;<br />    else<br />        <em>程序有错误</em>
</pre>








</div>








</div>








<div class="section" id="footnotes">
<h1><a class="toc-backref" href="#id24">脚注</a></h1>








<p>UnaryTypeTrait 概念定义于 <a class="reference external" href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1519.htm">n1519</a>; LWG 正考虑增加一个要求，即特化类型要派生自它们的嵌套 <tt class="docutils literal"><span class="pre">::type</span></tt>.</p>








<!-- LocalWords:  Abrahams Siek Witt const bool Sutter's WG int UL LI href Lvalue
LocalWords:  ReadableIterator WritableIterator SwappableIterator cv pre iter
LocalWords:  ConstantLvalueIterator MutableLvalueIterator CopyConstructible TR
LocalWords:  ForwardTraversalIterator BidirectionalTraversalIterator lvalue
LocalWords:  RandomAccessTraversalIterator dereferenceable Incrementable tmp
LocalWords:  incrementable xxx min prev inplace png oldeqnew AccessTag struct
LocalWords:  TraversalTag typename lvalues DWA Hmm JGS mis enum -->
</div>








</div>








<div class="footer">
<hr class="footer" />
<a class="reference external" href="new-iter-concepts.rst">View document source</a>.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>








</body>
</html>

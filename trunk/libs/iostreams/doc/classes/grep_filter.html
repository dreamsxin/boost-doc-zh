<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type">
    
    <title>Class Template basic_grep_filter</title><link rel="stylesheet" href="../../../../boost.css">
    <link rel="stylesheet" href="../theme/iostreams.css"></head>

<body>

<!-- Begin Banner -->

    <h1 class="title">类模板 <code>basic_grep_filter</code></h1>
    <hr class="banner">

<!-- End Banner -->

<dl class="page-index">
  <dt><a href="#description">描述</a></dt>
  <dt><a href="#headers">头文件</a></dt>
  <dt><a href="#installation">安装</a></dt>
  <dt><a href="#reference">参考</a></dt>
</dl>

<hr>

<a name="description"></a>
<h2>描述</h2>

<p>类模板 <code>basic_grep_filter</code> 使用在构造时给定的某个正则表达式，逐行对字符序列进行过滤，类似于命令行工具 <i>grep</i> (<a class="bib_ref" href="../bibliography.html#grep">[IEEE]</a>)。这个过滤器使用了来自于 <a href="http://www.boost.org/libs/regex" target="_top">Boost Regular Expression 库</a>(<a class="bib_ref" href="../bibliography.html#maddock">[Maddock]</a>) 的正则表达式。
</p>
<p>缺省地，过滤后的字符序列由未过滤的原序列中含有与给定的正则表达式相匹配的子序列的那些行组成。通过在构造时指定适当的选项，<code>basic_grep_filter</code> 可以被构造为仅让那些与正则表达式精确匹配的行通过(就象将选项 <i>-x</i> 传递给命令行工具一样)，或者仅让那些<i>不</i>包含匹配序列的行通过(就象将选项 <i>-v</i> 传递给命令行工具一样)。
</p>
<p>可通过成员函数 <code><a href="#count">count</a></code> 获取过滤后的字符序列的行计数。
</p>

<a name="headers"></a>
<h2>头文件</h2>

<dl class="page-index">
  <dt><a class="header" href="../../../../boost/iostreams/filter/grep.hpp"><code>&lt;boost/iostreams/filter/grep.hpp&gt;</code></a></dt>
</dl>

<a name="installation"></a>
<h2>安装</h2>

<p>模板 <code>basic_grep_filter</code> 使用了 <a href="http://www.boost.org/libs/regex" target="_top">Boost Regular Expression 库</a>，该库必须独立构建。详情请见 <a href="http://www.boost.org/libs/regex/doc/html/boost_regex/install.html" target="_top">这里</a>。
</p>

<a name="reference"></a>
<h2>参考</h2>

<h4>摘要</h4>

<pre class="broken_ie"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> iostreams {<br><br><span class="preprocessor">#include</span> <a class="header" href="../../../../boost/function.hpp" target="_top"><span class="literal">&lt;boost/function.hpp&gt;</span></a>
<span class="preprocessor">#include</span> <a class="header" href="../../../../boost/regex.hpp" target="_top"><span class="literal">&lt;boost/regex.hpp&gt;</span></a>

<span class="keyword">namespace</span> grep {<br><br><span class="keyword">const</span> <span class="keyword">int</span> invert;<br><span class="keyword">const</span> <span class="keyword">int</span> whole_line;<br><br>}<br><br><span class="keyword">template</span>&lt; <span class="keyword">typename</span> <a href="#template_params" class="documented">Ch</a>,<br>          <span class="keyword">typename</span> <a href="#template_params" class="documented">Tr</a> = regex_traits&lt;Ch&gt;,<br>          <span class="keyword">typename</span> <a href="#template_params" class="documented">Alloc</a> = std::allocator&lt;Ch&gt; &gt;<br><span class="keyword">class</span> <a href="#template_params" class="documented">basic_grep_filter</a> {   <br><span class="keyword">public:</span>
    <a class="documented" href="#constructor">basic_grep_filter</a>( <span class="keyword">const</span> basic_regex&lt;Ch, Tr, Alloc&gt;&amp; pattern,<br>                       regex_constants::match_flag_type flags = <br>                           regex_constants::match_default,<br>                       <span class="keyword">int</span> options = <span class="numeric_literal">0</span> );<br>    <span class="keyword">int</span> <a class="documented" href="#count">count</a>() <span class="keyword">const</span>;<br>};<br><br><span class="keyword">typedef</span> basic_grep_filter&lt;<span class="keyword">char</span>&gt;     <span class="defined">grep_filter</span>;<br><span class="keyword">typedef</span> basic_grep_filter&lt;<span class="keyword">wchar_t</span>&gt;  <span class="defined">wgrep_filter</span>;<br><br>} } // End namespace boost::io</pre>

<a name="template_params"></a>
<h4>模板参数</h4>

<table style="margin-left: 2em;" border="0" cellpadding="2">
<tbody><tr>
    </tr><tr>
        <td valign="top"><i>Ch</i></td><td valign="top" width="2em">-</td>
        <td>字符类型</td>
    </tr>
    <tr>
        <td valign="top"><i>Tr</i></td><td valign="top" width="2em">-</td>
        <td><a href="http://www.boost.org/libs/regex/doc/html/boost_regex/ref/regex_traits.html" target="_top">正则表达式traits</a>的类型</td>
    </tr>
    <tr>
        <td valign="top"><i>Alloc</i></td><td valign="top" width="2em">-</td>
        <td>标准库的分配器类型(<a class="bib_ref" href="../bibliography.html#iso">[ISO]</a>, 20.1.5)，用于分配字符缓冲区</td>
    </tr>
</tbody></table>

<a name="constructor"></a>
<h4><code>basic_grep_filter::basic_grep_filter</code></h4>

<pre class="broken_ie">    <b>basic_grep_filter</b>( <span class="keyword">const</span> basic_regex&lt;Ch, Tr, Alloc&gt;&amp; pattern,<br>                       regex_constants::match_flag_type flags = <br>                           regex_constants::match_default,<br>                       <span class="keyword">int</span> options = <span class="numeric_literal">0</span> );</pre>
    
<p>根据给定的正则表达式、匹配标志和 grep 选项，构造一个 <code>basic_grep_filter</code>。各参数有以下解释：</p>

<table style="margin-left: 2em;" border="0" cellpadding="2">
<tbody><tr>
    </tr><tr>
        <td valign="top"><i>pattern</i></td><td valign="top" width="2em">-</td>
        <td>用于与未过滤数据流进行匹配的正则表达式</td>
    </tr>
    <tr>
        <td valign="top"><i>flags</i></td><td valign="top" width="2em">-</td>
        <td>传递给 <a href="http://www.boost.org/libs/regex/doc/html/boost_regex/ref/regex_search.html" target="_top">regex_search</a> 或 <a href="http://www.boost.org/libs/regex/doc/html/boost_regex/ref/regex_match.html" target="_top">regex_match</a> 的标志，以指定正则表达式的匹配行为</td>
    </tr>
    <tr>
        <td valign="top"><i>options</i></td><td valign="top" width="2em">-</td>
        <td>零或多个来自名字空间 <code>boost::iostreams::grep</code> 的常量的按位OR<code></code>。当前当前可识别两个常量：<code>grep::whole_line</code> 使得过滤器仅让那些与正则表达式精确匹配的行通过，而 <code>grep::invert</code> 则使得过滤器仅让那些<i>不</i>含有匹配的行通过。</td>
    </tr>
</tbody></table>

<p></p>

<a name="count"></a>
<h4><code>basic_grep_filter::count</code></h4>

<a name="second_constructor"></a>

<pre class="broken_ie">    <span class="keyword">int</span> count() <span class="keyword">const</span>;</pre>
    
<p>返回从未过滤字符序列过滤至过滤后字符序列的行计数。当过滤器处理一个新的字符序列时，该计数自动重置为零。</p>

<!-- Begin Footer -->

<hr>
<p class="copyright">Revised 28 May 2008</p>

<p class="copyright">© Copyright 2008 <a href="http://www.coderage.com/" target="_top">CodeRage, LLC</a></p>
<p class="copyright"> 
    Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>

<!-- End Footer -->

</body></html>
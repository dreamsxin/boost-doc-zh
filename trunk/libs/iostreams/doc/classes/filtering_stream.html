<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  
  
  
  
  
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">






    
    
  
  
  
  
  
  
  
  
  
  
  <title>Class Template filtering_stream</title>
  <link rel="stylesheet" href="../../../../boost.css">






    
  
  
  
  
  
  <link rel="stylesheet" href="../theme/iostreams.css">
</head>


<body>







<!-- Begin Banner -->

    
<h1 class="title">类模板 <code>filtering_stream</code></h1>






    
<hr class="banner">

<!-- End Banner -->

<dl class="page-index">






  <dt><a href="#description">描述</a></dt>






  <dt><a href="#headers">头文件</a></dt>






  <dt><a href="#reference">参考</a></dt>






</dl>







<hr>

<a name="description"></a>
<h2>描述</h2>







<p>派生自 <code>std::basic_istream</code>, <code>std::basic_ostream</code> 或 <code>std::basic_iostream</code>, 用于执行过滤。每个 <code>filtering_stream</code> 包含一个 <a href="chain.html">chain</a>，由零个或多个过滤器加一个最后的可选设备组成。如果链中包含一个设备，则 <code>filtering_stream</code> 是 <i>完全的</i> 且可用于执行 i/o. 当 <code>filtering_stream</code> 用于输出时，数据从链中的第一个过滤器流入，然后流过第二个过滤器，依此类推，最后到达位于链末尾的设备。当 <code>filtering_stream</code> 用于输入时，数据以相反方向流动，从位于链末尾的设备开始，按相反顺序流过各个过滤器。缺省地，如果位于链末尾的设备被弹出，或者 <code>filtering_stream</code> 被销毁时是完全的，则使用函数 <a href="../functions/close.html"><code>close</code></a> 关闭链中的所有过滤器和设备。这一行为可以通过成员函数 <a href="#set_auto_close"><code>set_auto_close</code></a> 来改变。
</p>







<p>
    <code>filtering_stream</code> 派生自 <code>std::basic_istream</code>, <code>std::basic_ostream</code> 或 <code>std::basic_iostream</code>, 取决于它的 <a href="#template_params"><code>Mode</code></a> 参数。
</p>







<a name="headers"></a>
<h2>头文件</h2>







<dl class="page-index">






  <dt><a class="header" href="../../../../boost/iostreams/filtering_stream.hpp"><code>&lt;boost/iostreams/filtering_stream.hpp&gt;</code></a></dt>






</dl>







<a name="reference"></a>
<h2>参考</h2>







<a name="synopsis"></a>
<h3>摘要</h3>







<pre class="broken_ie"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> iostreams {<br><br><span class="keyword">template</span>&lt; <span class="keyword">typename</span> <a class="documented" href="#template_params">Mode</a>,<br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Ch</a>     = <span class="keyword">char</span>,<br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Tr</a>     = std::char_traits&lt;Ch&gt;, <br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Alloc</a>  = std::allocator&lt;<code>Ch</code>&gt;, <br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Access</a> = public_ &gt;<br><span class="keyword">class</span> <a class="documented" href="#template_params">filtering_stream</a>;<br><br><span class="keyword">template</span>&lt; <span class="keyword">typename</span> <a class="documented" href="#template_params">Mode</a>,<br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Ch</a>     = <span class="keyword">wchar_t</span>,<br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Tr</a>     = std::char_traits&lt;Ch&gt;, <br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Alloc</a>  = std::allocator&lt;<code>Ch</code>&gt;, <br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Access</a> = public_ &gt;<br><span class="keyword">class</span> <a class="documented" href="#filtering_wstream">filtering_wstream</a>;<br><br><span class="keyword">typedef</span> filtering_stream&lt;input&gt;    <span class="defined">filtering_istream</span>;<br><span class="keyword">typedef</span> filtering_stream&lt;output&gt;   <span class="defined">filtering_ostream</span>;<br><span class="keyword">typedef</span> filtering_wstream&lt;input&gt;   <span class="defined">filtering_wistream</span>;<br><span class="keyword">typedef</span> filtering_wstream&lt;output&gt;  <span class="defined">filtering_wostream</span>;<br><br><span class="keyword">template</span>&lt; <span class="keyword">typename</span> <a class="documented" href="#template_params">Mode</a>,<br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Ch</a>     = <span class="keyword">char</span>,<br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Tr</a>     = std::char_traits&lt;Ch&gt;, <br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Alloc</a>  = std::allocator&lt;<code>Ch</code>&gt;, <br>          <span class="keyword">typename</span> <a class="documented" href="#template_params">Access</a> = public_ &gt;<br><span class="keyword">class</span> <a class="documented" href="#filtering_stream">filtering_stream</a> : <span class="keyword">public</span> <span class="omitted">implementation-defined stream type</span> {<br><span class="keyword">public</span>:<br>    <span class="keyword">typedef</span> Ch                      char_type;<br>    <span class="keyword">typedef</span> Mode                    mode;<br>    <span class="keyword">typedef</span> Alloc                   allocator_type;<br>    <span class="keyword">typedef</span> <span class="omitted">implementation-defined</span>  size_type;<br><br>    <a class="documented" href="#default_ctor">filtering_stream</a>();<br><br>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<br>    <a class="documented" href="#policy_ctor">filtering_stream</a>( <span class="keyword">const</span> T&amp; t,<br>                      std::streamsize buffer_size = <span class="omitted">default value</span>,<br>                      std::streamsize pback_size = <span class="omitted">default value</span> );<br><br>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> StreamOrStreambuf&gt;<br>    <a class="documented" href="#stream_ctor">filtering_stream</a>( StreamOrStreambuf&amp; t,<br>                      std::streamsize buffer_size = <span class="omitted">default value</span>,<br>                      std::streamsize pback_size = <span class="omitted">default value</span> );<br><br>    <span class="keyword">const</span> std::type_info&amp; <a class="documented" href="#component_type">component_type</a>(<span class="keyword">int</span> n) <span class="keyword">const</span>;<br><br>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<br>    T* <a class="documented" href="#component">component</a>(<span class="keyword">int</span> n) <span class="keyword">const</span>;<br><br>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<br>    <span class="keyword">void</span> <a class="documented" href="#policy_push">push</a>( <span class="keyword">const</span> T&amp; t,<br>               std::streamsize buffer_size = <span class="omitted">default value</span>,<br>               std::streamsize pback_size = <span class="omitted">default value</span> );<br><br>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> StreamOrStreambuf&gt;<br>    <span class="keyword">void</span> <a class="documented" href="#stream_push">push</a>( StreamOrStreambuf&amp; t,<br>               std::streamsize buffer_size = <span class="omitted">default value</span>,<br>               std::streamsize pback_size = <span class="omitted">default value</span> );<br>    <span class="keyword">void</span> <a class="documented" href="#pop">pop</a>();<br>    <span class="keyword">bool</span> <a class="documented" href="#empty">empty</a>() <span class="keyword">const</span>;<br>    size_type <a class="documented" href="#size">size</a>() <span class="keyword">const</span>;<br>    <span class="keyword">void</span> <a class="documented" href="#reset">reset</a>();<br>    <span class="keyword">bool</span> <a class="documented" href="#is_complete">is_complete</a>() <span class="keyword">const</span>;<br>    <span class="keyword">bool</span> <a class="documented" href="#is_complete">is_complete</a>() <span class="keyword">const</span>;<br>    <span class="keyword">bool</span> <a class="documented" href="#auto_close">auto_close</a>() <span class="keyword">const</span>;<br>    <span class="keyword">void</span> <a class="documented" href="#set_auto_close">set_auto_close</a>(<span class="keyword">bool</span> close);<br>    <span class="keyword">bool</span> <a class="documented" href="#sync">sync</a>();<br>    <span class="keyword">bool</span> <a class="documented" href="#strict_sync">strict_sync</a>();<br><br>        <span class="comment">// 被反对的成员</span>

    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;<br>    <span class="keyword">const</span> std::type_info&amp; <a class="documented" href="#component_type">component_type</a>() <span class="keyword">const</span>;<br><br>    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> T&gt;<br>    T* <a class="documented" href="#component">component</a>() <span class="keyword">const</span>;<br>};<br><br>} } // End namespace boost::io</pre>







<a name="filtering_stream"></a>
<h3>类模板 <code>filtering_stream</code></h3>







<a name="template_params"></a>
<h4>模板参数</h4>







<table style="margin-left: 2em;" border="0" cellpadding="2">






  <tbody>





    <tr>






    </tr>





    <tr>






        <td valign="top"><i>Mode</i></td>





      <td valign="top" width="2em">-</td>






        <td>一个 <a href="../guide/modes.html#mode_tags">mode tag</a>.</td>






    </tr>






    <tr>






        <td valign="top"><i>Ch</i></td>





      <td valign="top" width="2em">-</td>






        <td>字符类型</td>






    </tr>






    <tr>






        <td valign="top"><i>Tr</i></td>





      <td valign="top" width="2em">-</td>






        <td>traits 类型</td>






    </tr>






    <tr>






        <td valign="top"><i>Alloc</i></td>





      <td valign="top" width="2em">-</td>






        <td>一个标准库的分配器类型 (<a class="bib_ref" href="../bibliography.html#iso">[ISO]</a>, 20.1.5), 用于分配字符缓冲区</td>






    </tr>






    <tr>






        <td valign="top"><i>Access</i></td>





      <td valign="top" width="2em">-</td>






        <td><code>public_</code> 或 <code>protected_</code>, 表示链接口的访问级别。用于在定义一个 <code>filtering_stream</code> 的派生类时隐藏链接口<code></code></td>






    </tr>






  
  
  
  
  
  </tbody>
</table>







<a name="default_ctor"></a>
<h4><code>filtering_stream::filtering_stream</code></h4>







<pre class="broken_ie">    filtering_stream();</pre>







<p>以空的过滤器和设备链构造一个 <code>filtering_stream</code>&nbsp;.
</p>







<a name="policy_ctor"></a>
<h4><code>filtering_stream::push</code></h4>






<pre class="broken_ie">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<br>    filtering_stream( <span class="keyword">const</span> T&amp; t,<br>                      std::streamsize buffer_size,<br>                      std::streamsize pback_size );</pre>






<p>构造一个 <code>filtering_stream</code>，链中包含 <code>t</code> 的拷贝。其中的参数解释如下：
</p>







<table style="margin-left: 2em;" id="Table3" border="0" cellpadding="2">






  <tbody>





    <tr>






    </tr>





    <tr>






        <td valign="top"><i>T</i></td>





      <td valign="top" width="2em">-</td>






        <td>某个 <a href="../guide/concepts.html#filter_concepts">Filter</a> 或 <a href="../guide/concepts.html#device_concepts">Device</a> 概念的 <a href="../../../../doc/html/CopyConstructible.html" target="_top">CopyConstructible</a> model，其 <a href="../guide/traits.html#char_type">字符类型</a> 为 <a href="#template_params"><code>Ch</code></a> 且 <a href="../guide/modes.html">mode</a> 强化自 <a href="#template_params"><code>Mode</code></a></td>






    </tr>






    <tr>






        <td valign="top"><i>t</i></td>





      <td valign="top" width="2em">-</td>






        <td>一个 <i>T</i> 的实例<i></i></td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>buffer_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>需分配的缓冲区大小</td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>pback_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>putback 缓冲区的大小，只有 <code>Mode</code> 为 <a href="../guide/modes.html#input"><code>input</code></a> 的强化时有效<a href="../guide/modes.html#input"><code></code></a></td>






    </tr>






  
  
  
  
  
  </tbody>
</table>







<p><code>filtering_stream</code> 可构造自一个过滤器或设备类型 <code>T</code> 的实例，如果 <code>T</code> 不是 <a href="../../../../doc/html/CopyConstructible.html" target="_top">CopyConstructible</a> 的，可以有两种方法：
</p>






<ul>






    <li>使用 <a href="../../../../doc/html/ref.html" target="_top">reference wrapper</a>, 或者 
    </li>





  <li>如果 <code>T</code> 是标准流或流缓冲类型，使用带非-<code>const</code> 引用的构造函数。
  </li>





</ul>






<p>如果 T 是一个设备，则 <code>filtering_stream</code> 在构造后就是完全的，可以用于执行 i/o.
</p>







<a name="stream_ctor"></a>
<pre class="broken_ie">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> StreamOrStreambuffer&gt;<br>    filering_stream( StreamOrStreambuffer&amp; t,<br>                     std::streamsize buffer_size,<br>                     std::streamsize pback_size );</pre>







<p>构造一个 <code>filtering_stream</code>，其链中包含给定流或流缓冲的引用。参数解释如下：
</p>







<table style="margin-left: 2em;" id="Table4" border="0" cellpadding="2">






  <tbody>





    <tr>






    </tr>





    <tr>






        <td valign="top"><i>StreamOrStreambuffer</i></td>





      <td valign="top" width="2em">-</td>






        <td>一个标准的流或流缓冲类型，其 <a href="../guide/traits.html#char_type">字符类型</a> 为 <a href="#template_params"><code>Ch</code></a> 且 <a href="../guide/modes.html">mode</a> 强化自 <a href="#template_params"><code>Mode</code></a></td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>buffer_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>需分配的缓冲区大小</td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>pback_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>putback 缓冲区的大小，只有 <code>Mode</code> 为 <a href="../guide/modes.html#input"><code>input</code></a> 的强化时有效<a href="../guide/modes.html#input"><code></code></a></td>






    </tr>






  
  
  
  
  
  </tbody>
</table>







<p><code>filtering_stream</code> 在构造后就是完全的，可以用于执行 i/o.
</p>







<a name="component_type"></a>
<h4><code>filtering_stream::component_type</code></h4>







<pre class="broken_ie">    <span class="keyword">const</span> std::type_info&amp; component_type(<span class="keyword">int</span> n) <span class="keyword">const</span>;<br></pre>







<p>返回一个引用，引向一个 <code>std::type_info</code> 实例，对应于底层链中第n个过滤器或设备的类型，链的大小必须至少为 <code>n + 1</code>. 组件的计数从零起计。 
</p>







<pre class="broken_ie">    <span class="comment">// 被反对的</span>
    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;<br>    <span class="keyword">const</span> std::type_info&amp; component_type() <span class="keyword">const</span>;<br></pre>







<p>返回一个引用，引向一个 <code>std::type_info</code> 实例，对应于底层链中第N个过滤器或设备的类型，链的大小必须至少为 <code>N + 1</code>. 组件的计数从零起计。模板参数 <code>N</code> 无法被推断，因此必须显式指定。
</p>







<p>
      <i>该成员已经被反对使用；请使用带一个 int 参数的&nbsp;<code></code></i><i><code>component</code></i><i><code>_type</code></i><i> </i><i><code></code> 重载代替。</i><i></i>
</p>







<a name="component"></a>
<h4><code>filtering_stream::component</code></h4>







<pre class="broken_ie">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<br>    T* component(<span class="keyword">int</span> n) <span class="keyword">const</span>;<br></pre>







<p>返回一个指针，指向底层链中第n个过滤器或设备，链的大小必须至少为 <code>n + 1</code> 且第n个过滤器或设备的类型为 <code>T</code>. 否则返回空指针。模板参数 <code>T</code><code></code> 无法被推断，因此必须显式指定。
</p>






<p>Microsoft Visual Studio 版本 6.0-7.0 的用户必须用宏 <a href="../macros/workarounds.html#boost_iostreams_component"><code>BOOST_IOSTREAMS_COMPONENT</code></a> 来替代本函数。
</p>







<pre class="broken_ie">    <span class="comment">// 被反对的<br></span>   &nbsp;<span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">typename</span> T&gt;<br>    T* component() <span class="keyword">const</span>;<br></pre>







<p>返回一个指针，指向底层链中第N个过滤器或设备，链的大小必须至少为 <code>N + 1</code> 且第N个过滤器或设备的类型为 <code>T</code>. 否则返回空指针。模板参数 <code>N</code> 和 <code>T</code><code></code> 无法被推断，因此必须显式指定。
</p>






<p>
      <i>该成员已经被反对使用；请使用带一个 int 参数的&nbsp;<code></code></i><i><code>component</code></i><i><code></code></i><i> </i><i><code></code> 重载代替。</i><i></i>
</p>







<a name="policy_push"></a>
<h4><code>filtering_stream::push</code></h4>






<pre class="broken_ie">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<br>    void push( <span class="keyword">const</span> T&amp; t,<br>               std::streamsize buffer_size,<br>               std::streamsize pback_size );</pre>






<p>添加一个 <code>t</code> 的拷贝到底层的链中，链必须不是 <a href="#is_complete">complete</a> 的。参数的解释如下：
</p>







<table style="margin-left: 2em;" id="Table3" border="0" cellpadding="2">






  <tbody>





    <tr>






    </tr>





    <tr>






        <td valign="top"><i>T</i></td>





      <td valign="top" width="2em">-</td>






        <td><a href="../guide/concepts.html#filter_concepts">Filter</a> 或 <a href="../guide/concepts.html#device_concepts">Device</a> 概念的一个 <a href="../../../../doc/html/CopyConstructible.html" target="_top">CopyConstructible</a> model，其 <a href="../guide/traits.html#char_type">字符类型</a> 为 <a href="filtering_stream.html#template_params"><code>Ch</code></a><a href="chain.html#template_params"><code></code></a> 且 <a href="../guide/modes.html">mode</a> 强化自 <a href="filtering_stream.html#template_params"><code>Mode</code></a><a href="#template_params"><code></code></a></td>






    </tr>






    <tr>






        <td valign="top"><i>t</i></td>





      <td valign="top" width="2em">-</td>






        <td><i>T</i>&nbsp;的一个实例<i></i></td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>buffer_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>要分配的缓冲区大小</td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>pback_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>putback 缓冲区的大小，buffer, 仅当 <code>Mode</code> 为 <a href="../guide/modes.html#input"><code>input</code></a> 的强化时有用<a href="../guide/modes.html#input"><code></code></a></td>






    </tr>






  
  
  
  
  
  </tbody>
</table>







<p>
    过滤器或设备类型 <code>T</code> 如果不是 <a href="../../../../doc/html/CopyConstructible.html" target="_top">CopyConstructible</a> 的，其实例可以有两种方法添加到链中：
</p>






<ul>






    <li>使用 <a href="../../../../doc/html/ref.html" target="_top">reference wrapper</a>, 或者 
    </li>



  <li>如果 <code>T</code> 是一个标准流或流缓冲类型，使用带一个非-<code>const</code> 引用参数的 <a href="filtering_stream.html#stream_push"><code>push</code></a> 模板化重载。</li>



</ul>






<p>如果 T 是设备，则在本函数返回后 <code>filtering_stream</code> 就成为<span style="font-style: italic;">完全的</span>，可用于执行 i/o 了。
</p>







<a name="stream_push"></a>
<pre class="broken_ie">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> StreamOrStreambuffer&gt;<br>    void push( StreamOrStreambuffer&amp; t,<br>               std::streamsize buffer_size,<br>               std::streamsize pback_size );</pre>







<p>添加给定的流或流缓冲到底层的链中，链必须不是 <a href="filtering_stream.html#is_complete">complete</a> 的。参数的解释如下：
</p>







<table style="margin-left: 2em;" id="Table4" border="0" cellpadding="2">






  <tbody>





    <tr>






    </tr>





    <tr>






        <td valign="top"><i>StreamOrStreambuffer</i></td>





      <td valign="top" width="2em">-</td>






        <td>一个标准的流或流缓冲类型，其 <a href="../guide/traits.html#char_type">字符类型</a> 为 <a href="filtering_stream.html#template_params"><code>Ch</code></a> 且 <a href="../guide/modes.html">mode</a> 强化自 <a href="filtering_stream.html#template_params"><code>Mode</code></a><a href="chain.html#template_params"><code></code></a><a href="#template_params"><code></code></a></td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>buffer_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>要分配的缓冲区大小</td>






    </tr>






    <tr>






        <td valign="top"><a name="level"></a><i>pback_size</i></td>





      <td valign="top" width="2em">-</td>






        <td>putback 缓冲区的大小，buffer, 仅当 <code>Mode</code> 为 <a href="../guide/modes.html#input"><code>input</code></a> 的强化时有用<a href="../guide/modes.html#input"><code></code></a></td>






    </tr>






  
  
  
  
  
  </tbody>
</table>







<p>在本函数返回后，<code>filtering_stream</code> 就成为<span style="font-style: italic;">完全的</span>，可用于执行 i/o 了。
</p>







<a name="pop"></a>
<h4><code>filtering_stream::pop</code></h4>






<pre class="broken_ie">    <span class="keyword">void</span> pop();</pre>







<p>从底层的链中去掉最后一个过滤器或设备，链必须是非空的。如果链是 <a href="filtering_stream.html#is_complete">complete</a><a href="chain.html#is_complete"></a> 的，<code>pop</code> 将使用函数 <a href="../functions/close.html"><code>close</code></a> 关闭链中的每个过滤器和设备，除非你已经用 <a href="filtering_stream.html#set_auto_close"><code>set_auto_close</code></a><a href="chain.html#set_auto_close"><code></code></a> 禁止了自动关闭特性。<a href="#set_auto_close"><code></code></a></p>







<a name="empty"></a>
<h4><code>filtering_stream::empty</code></h4>






<pre class="broken_ie">    <span class="keyword">bool</span> empty() <span class="keyword">const</span>;</pre>







<p>如果底层的链为空则返回 <code>true</code>&nbsp;.</p>







<a name="size"></a>
<h4><code>filtering_stream::size</code></h4>






<pre class="broken_ie">    size_type size() <span class="keyword">const</span>;</pre>







<p>返回底层链中的过滤器或设备数量。</p>







<a name="reset"></a>
<h4><code>filtering_stream::reset</code></h4>






<pre class="broken_ie">    <span class="keyword">void</span> reset();</pre>







<p>清空底层的链。如果链是 <a href="filtering_stream.html#is_complete">complete</a><a href="chain.html#is_complete"></a> 的，<code>reset</code> 将使用函数 <a href="../functions/close.html"><code>close</code></a> 关闭链中的每个过滤器和设备。</p>







<a name="is_complete"></a>
<h4><code>filtering_stream::is_complete</code></h4>






<pre class="broken_ie">    <span class="keyword">bool</span> is_complete() <span class="keyword">const</span>;</pre>







<p>返回 <code>true</code> 如果底层的链以一个 <a href="../concepts/device.html">Device</a> 为结束。 </p>







<a name="auto_close"></a>
<h4><code>filtering_stream::auto_close</code></h4>






<pre class="broken_ie">    <span class="keyword">bool</span> auto_close() <span class="keyword">const</span>;</pre>







<p>表示当 <a href="filtering_stream.html#pop"><code>pop</code></a><a href="chain.html#pop"><code></code></a> 被调用且链为完全的时候，底层链中的过滤器和设备是否自动关闭。返回 <code>true</code> 除非已经用 <a href="filtering_stream.html#set_auto_close"><code>set_auto_close</code></a><a href="chain.html#set_auto_close"><code></code></a> 禁止了自动关闭特性。</p>







<a name="set_auto_close"></a>
<h4><code>filtering_stream::set_auto_close</code></h4>






<pre class="broken_ie">    <span class="keyword">void</span> set_auto_close(<span class="keyword">bool</span> close);</pre>







<p>指定当 <a href="filtering_stream.html#pop"><code>pop</code></a><a href="chain.html#pop"><code></code></a> 被调用且底层链为完全的时候，底层链中的过滤器和设备是否自动关闭。如果在析构时链是完全的，这不会影响链中的过滤器和设备自动关闭。</p>







<a name="sync"></a>
<h4><code>filtering_stream::sync</code></h4>






<pre class="broken_ie">    <span class="keyword">bool</span> sync();</pre>







<p>对底层链中的每个过滤器和设备调用函数 <a href="../functions/flush.html"><code>flush</code></a>，链必须是完全的。返回 <code>true</code> 除非至少有一个组件是 <a href="../concepts/flushable.html">Flushable</a> 的并且该组件执行 <a href="../functions/flush.html"><code>flush</code></a> 时返回 <code>false</code>&nbsp;. 返回值 <code>true</code> 表示没有错误发生，但不保证所有缓冲数据都已成功发送。</p>







<a name="strict_sync"></a>
<h4><code>filtering_stream::strict_sync</code></h4>






<pre class="broken_ie">    <span class="keyword">bool</span> strict_sync();</pre>







<p>与 <code>sync</code> 相同，除了返回值有所不同，它返回 <code>false</code> 除非链中的<span style="font-style: italic;">每个</span>过滤器都是 <a href="../concepts/flushable.html">Flushable</a> 的且对于<span style="font-style: italic;">每个</span>组件执行 <a href="../functions/flush.html"><code>flush</code></a> 都返回 <code>true</code>&nbsp;.  返回值 <code>true</code> 保证所有缓冲的数据都已成功发送。</p>







<a name="filtering_wstream"></a>
<h3>类模板 <code>filtering_wstream</code></h3>







<pre class="broken_ie"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Mode,<br>          <span class="keyword">typename</span> Ch     = <span class="keyword">wchar_t</span>,<br>          <span class="keyword">typename</span> Tr     = std::char_traits&lt;Ch&gt;, <br>          <span class="keyword">typename</span> Alloc  = std::allocator&lt;<code>Ch</code>&gt;, <br>          <span class="keyword">typename</span> Access = public_ &gt;<br><span class="keyword">class</span> filtering_wstream;</pre>







<p>与 <code>filtering_stream</code><code></code> 要同，除了缺省的字符类型不一样。
<!-- Begin Footer -->

</p>





<hr>
<p class="copyright">Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
20 May, 2004
<!--webbot bot="Timestamp" endspan i-checksum="38504" -->
</p>







<p class="copyright">&copy; Copyright <a href="http://www.kangaroologic.com" target="_top">Jonathan Turkanis</a>, 2004</p>






<p class="copyright"> 
    Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>







<!-- End Footer -->

</body>
</html>

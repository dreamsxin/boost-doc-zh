<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html><head>






    
  
  
  
  
  
  <meta name="generator" content="HTML Tidy for Windows (vers 1st August 2002), see www.w3.org">






    
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">







    
  
  
  
  
  
  <title>Header &lt;boost/operators.hpp&gt; Documentation</title></head>

<body alink="red" bgcolor="white" link="blue" text="black" vlink="purple">






    
<h1><img src="../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">头文件 <cite>&lt;<a href="../../boost/operators.hpp">boost/operators.hpp</a>&gt;</cite></h1>







    
<p>头文件 <cite>&lt;<a href="../../boost/operators.hpp">boost/operators.hpp</a>&gt;</cite> 提供了几组类模板(在名字空间 <code>boost 中</code>)。这些模板在名字空间范围中依据某个类提供的最小数量的基本操作符定义其它操作符。</p>







    
<h2><a name="contents">目录</a></h2>







    
<ul>






      <li><a href="#contents">目录</a></li>







      <li>
        <a href="#rationale">原理</a> 

        
    
    
    
    
    
    <ul>






          <li><a href="#semantics">模板语义概要</a></li>







          <li><a href="#concepts_note"><i>概念</i>的使用</a></li>






        
    
    
    
    
    
    </ul>






      </li>







      <li>
        <a href="#usage">用法</a> 

        
    
    
    
    
    
    <ul>






          <li>
            <a href="#two_arg">两参数模板形式</a> 

            
        
        
        
        
        
        <ul>






              <li><a href="#two_arg_gen">总则</a></li>







              <li><a href="#mixed_arithmetics">混合运算</a></li>






            
        
        
        
        
        
        </ul>






          </li>







          <li><a href="#chaining">基类链和对象大小</a></li>







          <li><a href="#explicit_instantiation">独立的显式实例化</a></li>







          <li><a href="#portability">可移植性的要求</a></li>






        
    
    
    
    
    
    </ul>






      </li>







      <li><a href="#example">例子</a></li>







      <li>
        <a href="#arithmetic">算术操作符</a> 

        
    
    
    
    
    
    <ul>






          <li>
            <a href="#smpl_oprs">简单算术操作符</a> 

            
        
        
        
        
        
        <ul>






              <li><a href="#ordering">顺序的说明</a></li>







              <li><a href="#symmetry">对称性的说明</a></li>






            
        
        
        
        
        
        </ul>






          </li>







          <li><a href="#grpd_oprs">组合算术操作符</a></li>







          <li><a href="#ex_oprs">模板例子</a></li>







          <li><a href="#a_demo">算术操作符的示例和测试程序</a></li>






        
    
    
    
    
    
    </ul>






      </li>







      <li>
        <a href="#deref">提领操作符和迭代器辅助类</a> 

        
    
    
    
    
    
    <ul>






          <li><a href="#dereference">提领操作符</a></li>







          <li><a href="#grpd_iter_oprs">组合迭代器操作符</a></li>







          <li>
            <a href="#iterator">迭代器辅助类</a> 

            
        
        
        
        
        
        <ul>






              <li><a href="#iterator_helpers_notes">迭代器辅助类的说明</a></li>






            
        
        
        
        
        
        </ul>






          </li>







          <li><a href="#i_demo">迭代器示例和测试程序</a></li>






        
    
    
    
    
    
    </ul>






      </li>







      <li><a href="#contributors">贡献者</a></li>







      <li><a href="#old_lib_note">旧版本用户的注意事项</a></li>






    
</ul>







    
<h2><a name="rationale">原理</a></h2>







    
<p>类类型的重载操作符通常都成组出现。如果你可以写 <code>x&nbsp;+&nbsp;y</code>, 你可能也想要可以写 <code>x += y</code>. 如果你可以写 <code>x &lt; y,</code> 你也会想要 <code>x &gt; y, x &gt;= y,</code> 和 <code>x &lt;= y</code>.
    而且，除非你的类真的有些令人惊讶的行为，否则这些相关的操作符中的一些应该可以由其它操作符定义(如 <code>x &gt;= y
    &lt;=&gt; !(x &lt; y)</code>)。在多个类中重复这些定义是乏味且易出错的。<cite><a href="../../boost/operators.hpp">boost/operators.hpp</a></cite> 中的模板帮助你在名字空间范围内基于已经在你的类中定义了的操作符，生成其它操作符。</p>







    
<p>例如，如果你声明了这样的一个类：</p>







    
<blockquote>
  
  
  
  
  
  <pre>class MyInt<br>    : boost::operators&lt;MyInt&gt;<br>{<br>    bool operator&lt;(const MyInt&amp; x) const; <br>    bool operator==(const MyInt&amp; x) const;<br>    MyInt&amp; operator+=(const MyInt&amp; x);    <br>    MyInt&amp; operator-=(const MyInt&amp; x);    <br>    MyInt&amp; operator*=(const MyInt&amp; x);    <br>    MyInt&amp; operator/=(const MyInt&amp; x);    <br>    MyInt&amp; operator%=(const MyInt&amp; x);    <br>    MyInt&amp; operator|=(const MyInt&amp; x);    <br>    MyInt&amp; operator&amp;=(const MyInt&amp; x);    <br>    MyInt&amp; operator^=(const MyInt&amp; x);    <br>    MyInt&amp; operator++();    <br>    MyInt&amp; operator--();    <br>};<br></pre>






    </blockquote>







    
<p>那么 <code><a href="#operators1">operators&lt;&gt;</a></code>
    模板添加了超过一打的操作符，如
    <code>operator&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, 和
    (二元) <code>+</code>. 此外还提供了模板的 <a href="#two_arg">两参数形式</a>，可以与其它类型进行互操作。</p>







    
<h3>模板语义概要<a name="semantics"></a></h3>







    
<ol>






      <li>每个操作符模板通过为目标类定义重载操作符来完成其表示的概念。</li>







      <li>一个操作符类模板的名字代表了其目标类应符合的 <a href="#concepts_note">概念</a>。</li>







      <li>通常，目标类将操作符类模板的一个实例用作基类。有些操作符模板支持 <a href="#explicit_instantiation">另一种方法</a>。</li>







      <li>概念可以被复合，即它可以表示其它更简单的概念的组合。</li>







      <li>多数操作符模板要求它们的目标类支持与该模板所提供的操作符相关的操作。根据广泛接受的 <a href="http://www.gotw.ca/gotw/004.htm">编码风格建议</a>，目标类通常被要求提供与概念的"主操作符"对应的赋值操作符。例如，可加模板要求 <code>operator+=(T
      const&amp;)</code> 进而提供 <code>operator+(T const&amp;, T
      const&amp;)</code>.</li>






    
</ol>







    
<h3><i><a name="concepts_note">concepts </a></i>的使用</h3>







    
<p>本文所讨论的概念并不象标准库中的概念(可复制构造，等等<i></i>)那样是必需的，虽然它们中有一些是；我们称它们为 <i>弱概念(concepts with a small 'c')</i>。具体地说，它们与前者的差别在于它们不描述操作符所要求定义的精确语义，除了以下要求：(a) 属于同一概念的多个操作符的语义必须一致(如，<code>a += b</code> 应该与
    <code>a&nbsp;=&nbsp;a&nbsp;+&nbsp;b</code> 表达式有相同操作)，以及 (b) 操作符的返回类型应该跟随内建类型的相应操作符的返回类型(如，<code>operator&lt;</code> 应返回一个可转换为 <code>bool</code> 的类型，而 <code>T::operator-=</code> 应返回可转换为 <code>T 的类型</code>)。这样的 "宽松" 要求使得 operators
    库可应用于不同领域的、更广泛的目标类，因而也更加有用。</p>







    
<h2><a name="usage">用法</a></h2>







    
<h3><a name="two_arg">两参数模板形式</a></h3>







    
<h4><a name="two_arg_gen">总则</a></h4>







    
<p>二元操作符的两个参数通常都是相同类型的，但通常都不想定义多个操作符来组合不同的类型。<a href="#example">例如</a>，你可能想将一个数学向量乘以一个比例系数。算术操作符模板的两参数模板形式就是为此目的而提出的。提供一个模板的两参数形式时，期望的操作符返回类型通常决定了我们讨论的两个类型中的哪一个应派生自操作符模板。例如，如果 <code>T&nbsp;+&nbsp;U</code> 的结果为类型 <code>T</code>, 则
    <code>T</code> (而不是 <code>U</code>) 应派生自 <code><a href="#addable2">addable&lt;T, U&gt;</a></code>. 但比较运算的模板
    (<code><a href="#less_than_comparable2">less_than_comparable&lt;T,
    U&gt;</a></code>, <code><a href="#equality_comparable2">equality_comparable&lt;T, U&gt;</a></code>,
    <code><a href="#equivalent2">equivalent&lt;T, U&gt;</a></code>, 和
    <code><a href="#partially_ordered2">partially_ordered&lt;T,
    U&gt;</a></code>) 除外，因为它们所定义的操作符的返回类型为 <code>bool</code>.</p>







    
<p>在不支持偏特化的编译器上，两参数形式必须使用结尾为'2'的名字来指定。而单参数形式也因为对称性而提供了结尾为'1'的名字，以便可用于使用 <a href="#chaining">基类链</a>
    技术的应用。</p>







    
<h4><a name="mixed_arithmetics">混合运算</a></h4>







    
<p>两参数模板形式的另一个应用是类型 T 和另一个可转换为 T 的类型 U 之间混合运算。这时两参数模板形式在两个方面有所帮助：一个是为操作符重载提供各自的符号特征，另一个是性能。</p>







    
<p>在操作符重载方面，假定 U 为 <code>int</code>, 而 <code>T</code> 是一个用户自定义的无限整数类型，且已经有一个 <code>double
    operator-(double, const T&amp;)</code>. 如果你想计算 <code>int - T</code> 而没有提供 <code>T operator-(int, const
    T&amp;)</code>, 那么编译器就是认为 <code>double operator-(double,
    const T&amp;)</code> 要比 <code>T operator-(const
    T&amp;, const T&amp;)</code> 更为适合，但这很可能不是用户的意图。为了定义一套完整的操作符符号特征，我们另外提供了两参数模板形式的 '左' 形式
    (<code><a href="#subtractable2_left">subtractable2_left&lt;T,
    U&gt;</a></code>, <code><a href="#dividable2_left">dividable2_left&lt;T,
    U&gt;</a></code>, <code><a href="#modable2_left">modable2_left&lt;T,
    U&gt;</a></code>)，以定义 U 出现在左边时的不可交换操作符的符号特征
    (<code>operator-(const U&amp;, const T&amp;)</code>,
    <code>operator/(const U&amp;, const T&amp;)</code>, <code>operator%(const
    U&amp;, const T&amp;)</code>).</p>







    
<p>在性能方面，我们注意到如果对混合类型运算使用单类型的二元操作符，那么类型 <code>U</code>
    的参数就必须被转换为类型 T。但是实际上，通常有更高效的实现，即使用 <code>T::operator-=(const U&amp;)</code>
以避免从 U 到 T 的转换。算术操作符的两参数模板形式创建了额外的操作符接口以使用更为高效的实现。不过对于 '左'
形式就不能获得更高的效率：它们仍然需要从 U 到 T 的转换，如果单类型二元操作符是最好的选择时，我们的实现就相当于编译器自动生成的代码。</p>







    
<h3><a name="chaining">基类链和对象大小</a></h3>







    
<p>除了 <a href="#ex_oprs">arithmetic examples</a> 和 <a href="#iterator">iterator
    helpers</a>, 每个操作符类模板都有一个额外但可选的模板类型参数
    <code>B</code>. 这个参数是实例化模板的一个公有派生基类。这意味着它必须是一个类类型。它可以用于避免对象大小的膨胀，该问题在从多个空基类进行多重继承时会经常遇到(详情请见 <a href="#old_lib_note">旧版本用户的注意事项</a>)。为提供对一组操作符的支持，可以使用 <code>B</code> 参数来将操作符模板串成一个单基类的类层次，示例请见 <a href="#example">用例</a>。这个技术也被用于将多个操作符模板组合为复合操作符的定义。如果链过长超出了编译器的支持范围，请尝试将某些操作符模板替换为单个复合操作符模板；长度的限制仅适用于链中的直接模板数量，而隐藏于复合模板中的模板则不算在内。</p>







    
<p><strong>警告:</strong> 在使用一个 Boost 操作符模板的 <a href="operators.htm#two_arg">单参数形式</a> 时，如果要链一个不是&nbsp;Boost 操作符模板的基类，你必须用结尾为'1'的名字来指定这个操作符模板。否则，本库会假定你想定义一个二元操作来组合那个你想用作基类的类和你正在派生的类。</p>







    
<h3>独立的显式实例化<a name="explicit_instantiation"></a></h3>







    
<p>在某些编译器上(<span style="font-style: italic;">如</span><i></i> Borland, GCC)，单继承也会在某些情况下引起对象大小的增加。如果你不是在定义一个类模板，你可以通过避免派生来获得更小的对象大小，而是象下面这样使用显式的操作符模板实例化：</p>







    
<blockquote>
  
  
  
  
  
  <pre>    class myclass // 没有继承...<br>    {<br>        //...<br>    };<br><br>    // 显式实例化我需要的操作符<br>    template struct less_than_comparable&lt;myclass&gt;;<br>    template struct equality_comparable&lt;myclass&gt;;<br>    template struct incrementable&lt;myclass&gt;;<br>    template struct decrementable&lt;myclass&gt;;<br>    template struct addable&lt;myclass,long&gt;;<br>    template struct subtractable&lt;myclass,long&gt;;<br></pre>






    </blockquote>







    
<p>注意，有些操作符模板不能用这个方法，而必须作为它们的主操作数类型的基类。这些模板定义的操作符必须是成员函数，而上述方法要求操作符是独立的友元函数。这类模板有：</p>







    
<ul>






      <li><code><a href="#dereferenceable">dereferenceable&lt;&gt;</a></code></li>







      <li><code><a href="#indexable">indexable&lt;&gt;</a></code></li>







      <li>任何至少包含以上之一的复合操作符模板</li>






    
</ul>







    
<p>正如 Daniel Krügler 提出的，这个技巧违犯了 14.6.5/2，是不可移植的。原因是，实例化所带入的操作符，如
    <code>less_than_comparable&lt;myclass&gt;</code> 根据 3.4.2/2 中的规则不能被 ADL 查找到，由于 myclass 不是
    <code>less_than_comparable&lt;myclass&gt;</code> 的关联类型。因此，应该只在其它方法都失败时才使用这个技巧。</p>







    
<h3>可移植性的要求<a name="portability"></a></h3>







    
<p>很多编译器(<span style="font-style: italic;">如</span><i></i> MSVC 6.3, GCC 2.95.2)并不强制执行在操作符模板表格中的要求，除非是真正使用时要依赖的操作。这不是符合标准的行为。具体地说，虽然从 <code><a href="#operators1">operators&lt;&gt;</a></code> 和 <code><a href="#operators2">operators2&lt;&gt;</a></code> 模板派生你的所有需要二元操作符的类，而不管它们是否实现了这些模板的所有要求的这种方法是很方便，但是这种取巧的方法是不可移植的。即使它们现在可以在你的编译器上使用，但可能以后就不行了。</p>







    
<h2><a name="example">例子</a></h2>







    
<p>这个例子示范了某些 <a href="#arithmetic">算术操作符模板</a> 如何被用于一个表示几何点的类(模板)。</p>






<pre>template &lt;class T&gt;<br>class point    // 注：这里使用私有继承是 OK 的！<br>    : boost::addable&lt; point&lt;T&gt;          // point + point<br>    , boost::subtractable&lt; point&lt;T&gt;     // point - point<br>    , boost::dividable2&lt; point&lt;T&gt;, T    // point / T<br>    , boost::multipliable2&lt; point&lt;T&gt;, T // point * T, T * point<br>      &gt; &gt; &gt; &gt;<br>{<br>public:<br>    point(T, T);<br>    T x() const;<br>    T y() const;<br><br>    point operator+=(const point&amp;);<br>    // point operator+(point, const point&amp;) 被 addalbe 自动生成<br><br>    point operator-=(const point&amp;);<br>    // point operator-(point, const point&amp;) 被 subtractable 自动生成<br><br>    point operator*=(T);<br>    // point operator*(point, const T&amp;) 和<br>    // point operator*(const T&amp;, point) 被 multipliable 自动生成<br><br>    point operator/=(T);<br>    // point operator/(point, const T&amp;) 被 dividable 自动生成<br>private:<br>    T x_;<br>    T y_;<br>};<br><br>// 现在使用 point&lt;&gt; 类:<br><br>template &lt;class T&gt;<br>T length(const point&lt;T&gt; p)<br>{<br>    return sqrt(p.x()*p.x() + p.y()*p.y());<br>}<br><br>const point&lt;float&gt; right(0, 1);<br>const point&lt;float&gt; up(1, 0);<br>const point&lt;float&gt; pi_over_4 = up + right;<br>const point&lt;float&gt; pi_over_4_normalized = pi_over_4 / length(pi_over_4);<br></pre>







    
<h2><a name="arithmetic">算术操作符</a></h2>







    
<p>算术操作符模板使得创建定制化的数字类型更为容易。给定一组核心的操作符，这些模板就会为该数字类型增加其它相关的操作符。这些操作符与标准算术类
型所有的操作符相类似，包括有比较、相加、递增、逻辑和位操作等。更进一步，由于多数数字类型需要多个操作符，所以还提供了一些模板来将多个基本操作符模
板组合成一个声明。</p>







    
<p>对于简单操作符模板实例化所用的类型应满足的要求，是按照有效表达式和表达式返回类型来指定的。而对于复合操作符模板，则只列出它们使用的模板。复合操作符模板所提供的操作和要求可以由所列出的组件的操作和要求来推断。</p>







    
<h3><a name="smpl_oprs">简单算术操作符</a></h3>







    
<p>我们说这些模板是"简单"的，因为它们提供的操作符是基于类型必须提供的某个单一操作的。它们都有一个额外的可选模板参数 <code>B</code> 以使用
    <a href="#chaining">基类链</a> 技巧，但下面不列出该参数。</p>







    
<table align="center" border="1" cellpadding="5">






      <caption>简单算术操作符模板类
      </caption>

      <tbody>





    <tr>






        <td colspan="3">
          
      
      
      
      
      
      <table align="center" border="1">






            <caption>
              <em>Key</em>
            </caption>

            <tbody>





          <tr>






              <td><code>T</code>: 主操作数的类型</td>







              <td><code>U</code>: 另一个操作数的类型</td>






            </tr>







            <tr>






              <td><code>t</code>, <code>t1</code>: 类型 <code>T 的值</code></td>







              <td><code>u</code>: 类型 <code>U 的值</code></td>






            </tr>






          
        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






        </td>






      </tr>







      <tr>






        <th>模板</th>







        <th>提供的操作</th>







        <th>要求</th>






      </tr>







      <tr>






        <td><code><a name="less_than_comparable1">less_than_comparable&lt;T&gt;</a></code><br>






         <code>less_than_comparable1&lt;T&gt;</code></td>







        <td><code>bool operator&gt;(const T&amp;, const T&amp;)</code><br>






         <code>bool operator&lt;=(const T&amp;, const T&amp;)</code><br>






         <code>bool operator&gt;=(const T&amp;, const T&amp;)</code></td>







        <td><code>t &lt; t1</code>.<br>


返回类型可转换为 <code>bool</code>. 请见 <a href="#ordering">Ordering Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="less_than_comparable2">less_than_comparable&lt;T,
        U&gt;</a></code><br>






         <code>less_than_comparable2&lt;T, U&gt;</code></td>







        <td><code>bool operator&lt;=(const T&amp;, const U&amp;)</code><br>






         <code>bool operator&gt;=(const T&amp;, const U&amp;)</code><br>






         <code>bool operator&gt;(const U&amp;, const T&amp;)</code><br>






         <code>bool operator&lt;(const U&amp;, const T&amp;)</code><br>






         <code>bool operator&lt;=(const U&amp;, const T&amp;)</code><br>






         <code>bool operator&gt;=(const U&amp;, const T&amp;)</code></td>







        <td><code>t &lt; u</code>. <code>t &gt; u</code>.<br>


返回类型可转换为 <code>bool</code>. 请见&nbsp;<a href="#ordering">Ordering Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="equality_comparable1">equality_comparable&lt;T&gt;</a></code><br>






         <code>equality_comparable1&lt;T&gt;</code></td>







        <td><code>bool operator!=(const T&amp;, const T&amp;)</code></td>







        <td><code>t == t1</code>.<br>


返回类型可转换为&nbsp;<code>bool</code>.</td>






      </tr>







      <tr>






        <td><code><a name="equality_comparable2">equality_comparable&lt;T,
        U&gt;</a></code><br>






         <code>equality_comparable2&lt;T, U&gt;</code></td>







        <td><code>bool operator==(const U&amp;, const T&amp;)</code><br>






         <code>bool operator!=(const U&amp;, const T&amp;)</code><br>






         <code>bool operator!=(const T&amp;, const U&amp;)</code></td>







        <td><code>t == u</code>.<br>


返回类型可转换为&nbsp;<code>bool</code>.</td>






      </tr>







      <tr>






        <td><code><a name="addable1">addable&lt;T&gt;</a></code><br>






         <code>addable1&lt;T&gt;</code></td>







        <td><code>T operator+(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp += t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见 <a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="addable2">addable&lt;T, U&gt;</a></code><br>






         <code>addable2&lt;T, U&gt;</code></td>







        <td><code>T operator+(const T&amp;, const U&amp;)</code><br>






         <code>T operator+(const U&amp;, const T&amp; )</code></td>







        <td><code>T temp(t); temp += u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="subtractable1">subtractable&lt;T&gt;</a></code><br>






         <code>subtractable1&lt;T&gt;</code></td>







        <td><code>T operator-(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp -= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="subtractable2">subtractable&lt;T,
        U&gt;</a></code><br>






         <code>subtractable2&lt;T, U&gt;</code></td>







        <td><code>T operator-(const T&amp;, const U&amp;)</code></td>







        <td><code>T temp(t); temp -= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="subtractable2_left">subtractable2_left&lt;T,
        U&gt;</a></code></td>







        <td><code>T operator-(const U&amp;, const T&amp;)</code></td>







        <td><code>T temp(u); temp -= t</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.</td>






      </tr>







      <tr>






        <td><code><a name="multipliable1">multipliable&lt;T&gt;</a></code><br>






         <code>multipliable1&lt;T&gt;</code></td>







        <td><code>T operator*(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp *= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="multipliable2">multipliable&lt;T,
        U&gt;</a></code><br>






         <code>multipliable2&lt;T, U&gt;</code></td>







        <td><code>T operator*(const T&amp;, const U&amp;)</code><br>






         <code>T operator*(const U&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp *= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="dividable1">dividable&lt;T&gt;</a></code><br>






         <code>dividable1&lt;T&gt;</code></td>







        <td><code>T operator/(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp /= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="dividable2">dividable&lt;T, U&gt;</a></code><br>






         <code>dividable2&lt;T, U&gt;</code></td>







        <td><code>T operator/(const T&amp;, const U&amp;)</code></td>







        <td><code>T temp(t); temp /= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="dividable2_left">dividable2_left&lt;T,
        U&gt;</a></code></td>







        <td><code>T operator/(const U&amp;, const T&amp;)</code></td>







        <td><code>T temp(u); temp /= t</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.</td>






      </tr>







      <tr>






        <td><code><a name="modable1">modable&lt;T&gt;</a></code><br>






         <code>modable1&lt;T&gt;</code></td>







        <td><code>T operator%(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp %= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="modable2">modable&lt;T, U&gt;</a></code><br>






         <code>modable2&lt;T, U&gt;</code></td>







        <td><code>T operator%(const T&amp;, const U&amp;)</code></td>







        <td><code>T temp(t); temp %= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="modable2_left">modable2_left&lt;T,
        U&gt;</a></code></td>







        <td><code>T operator%(const U&amp;, const T&amp;)</code></td>







        <td><code>T temp(u); temp %= t</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.</td>






      </tr>







      <tr>






        <td><code><a name="orable1">orable&lt;T&gt;</a></code><br>






         <code>orable1&lt;T&gt;</code></td>







        <td><code>T operator|(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp |= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="orable2">orable&lt;T, U&gt;</a></code><br>






         <code>orable2&lt;T, U&gt;</code></td>







        <td><code>T operator|(const T&amp;, const U&amp;)</code><br>






         <code>T operator|(const U&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp |= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="andable1">andable&lt;T&gt;</a></code><br>






         <code>andable1&lt;T&gt;</code></td>







        <td><code>T operator&amp;(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp &amp;= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="andable2">andable&lt;T, U&gt;</a></code><br>






         <code>andable2&lt;T, U&gt;</code></td>







        <td><code>T operator&amp;(const T&amp;, const U&amp;)</code><br>






         <code>T operator&amp;(const U&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp &amp;= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="xorable1">xorable&lt;T&gt;</a></code><br>






         <code>xorable1&lt;T&gt;</code></td>







        <td><code>T operator^(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp ^= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="xorable2">xorable&lt;T, U&gt;</a></code><br>






         <code>xorable2&lt;T, U&gt;</code></td>







        <td><code>T operator^(const T&amp;, const U&amp;)</code><br>






         <code>T operator^(const U&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp ^= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="incrementable">incrementable&lt;T&gt;</a></code></td>







        <td><code>T operator++(T&amp;, int)</code></td>







        <td><code>T temp(t); ++t</code><br>


返回类型可转换为&nbsp;<code>T</code>.</td>






      </tr>







      <tr>






        <td><code><a name="decrementable">decrementable&lt;T&gt;</a></code></td>







        <td><code>T operator--(T&amp;, int)</code></td>







        <td><code>T temp(t); --t;</code><br>


返回类型可转换为&nbsp;<code>T</code>.</td>






      </tr>







      <tr>






        <td><code><a name="left_shiftable1">left_shiftable&lt;T&gt;</a></code><br>






         <code>left_shiftable1&lt;T&gt;</code></td>







        <td><code>T operator&lt;&lt;(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp &lt;&lt;= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="left_shiftable2">left_shiftable&lt;T,
        U&gt;</a></code><br>






         <code>left_shiftable2&lt;T, U&gt;</code></td>







        <td><code>T operator&lt;&lt;(const T&amp;, const U&amp;)</code></td>







        <td><code>T temp(t); temp &lt;&lt;= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="right_shiftable1">right_shiftable&lt;T&gt;</a></code><br>






         <code>right_shiftable1&lt;T&gt;</code></td>







        <td><code>T operator&gt;&gt;(const T&amp;, const T&amp;)</code></td>







        <td><code>T temp(t); temp &gt;&gt;= t1</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="right_shiftable2">right_shiftable&lt;T,
        U&gt;</a></code><br>






         <code>right_shiftable2&lt;T, U&gt;</code></td>







        <td><code>T operator&gt;&gt;(const T&amp;, const U&amp;)</code></td>







        <td><code>T temp(t); temp &gt;&gt;= u</code>.<br>


返回类型可转换为&nbsp;<code>T</code>.&nbsp;请见&nbsp;<a href="#symmetry">Symmetry Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="equivalent1">equivalent&lt;T&gt;</a></code><br>






         <code>equivalent1&lt;T&gt;</code></td>







        <td><code>bool operator==(const T&amp;, const T&amp;)</code></td>







        <td><code>t &lt; t1</code>.<br>


返回类型可转换为 <code>bool</code>. 请见&nbsp;<a href="#ordering">Ordering Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="equivalent2">equivalent&lt;T, U&gt;</a></code><br>






         <code>equivalent2&lt;T, U&gt;</code></td>







        <td><code>bool operator==(const T&amp;, const U&amp;)</code></td>







        <td><code>t &lt; u</code>. <code>t &gt; u</code>.<br>


返回类型可转换为 <code>bool</code>. 请见&nbsp;<a href="#ordering">Ordering Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="partially_ordered1">partially_ordered&lt;T&gt;</a></code><br>






         <code>partially_ordered1&lt;T&gt;</code></td>







        <td><code>bool operator&gt;(const T&amp;, const T&amp;)</code><br>






         <code>bool operator&lt;=(const T&amp;, const T&amp;)</code><br>






         <code>bool operator&gt;=(const T&amp;, const T&amp;)</code></td>







        <td><code>t &lt; t1</code>. <code>t == t1</code>.<br>


返回类型可转换为 <code>bool</code>. 请见&nbsp;<a href="#ordering">Ordering Note</a>.</td>






      </tr>







      <tr>






        <td><code><a name="partially_ordered2">partially_ordered&lt;T,
        U&gt;</a></code><br>






         <code>partially_ordered2&lt;T, U&gt;</code></td>







        <td><code>bool operator&lt;=(const T&amp;, const U&amp;)</code><br>






         <code>bool operator&gt;=(const T&amp;, const U&amp;)</code><br>






         <code>bool operator&gt;(const U&amp;, const T&amp;)</code><br>






         <code>bool operator&lt;(const U&amp;, const T&amp;)</code><br>






         <code>bool operator&lt;=(const U&amp;, const T&amp;)</code><br>






         <code>bool operator&gt;=(const U&amp;, const T&amp;)</code></td>







        <td><code>t &lt; u</code>. <code>t &gt; u</code>. <code>t ==
        u</code>.<br>


返回类型可转换为 <code>bool</code>. 请见&nbsp;<a href="#ordering">Ordering Note</a>.</td>






      </tr>






    
  
  
  
  
  
  </tbody>
</table>







    
<h4><a name="ordering">顺序的说明</a></h4>







    
<p><code><a href="#less_than_comparable1">less_than_comparable&lt;T&gt;</a></code> 和
    <code><a href="#partially_ordered1">partially_ordered&lt;T&gt;</a></code>
    模板提供了两组相同的操作。但是，<code><a href="#less_than_comparable1">less_than_comparable&lt;T&gt;</a></code> 用于类型 T 的所有数值具有全序关系的情况。如果这不能满足(<span style="font-style: italic;">如</span><i></i> IEEE 浮点算术中的 Not-a-Number 值)，那就应该用 <code><a href="#partially_ordered1">partially_ordered&lt;T&gt;</a></code>.&nbsp; <code><a href="#partially_ordered1">partially_ordered&lt;T&gt;</a></code> 模板可以用于全序的类型，但是它不如
    <code><a href="#less_than_comparable1">less_than_comparable&lt;T&gt;</a></code> 高效。这一规则同样适用于对 T 和 U 的所有数值进行排序的 <code><a href="#less_than_comparable2">less_than_comparable&lt;T, U&gt;</a></code> 和
    <code><a href="#partially_ordered2">partially_ordered&lt;T,
    U&gt;</a></code>，以及两个版本的 <code><a href="#equivalent1">equivalent&lt;&gt;</a></code>. 对于 <code><a href="#equivalent1">equivalent&lt;&gt;</a></code>，解决方案是为目标类写一个定制的
    <code>operator==</code>&nbsp;.</p>







    
<h4><a name="symmetry">对称性的说明</a></h4>







    
<p>在讨论对称性之前，我们需要讨论一下优化的问题，搞清楚不同风格的操作符实现的原因。我们以一个类 T 的 <code>operator+</code> 为例：</p>






<pre>T operator+( const T&amp; lhs, const T&amp; rhs )<br>{<br>   return T( lhs ) += rhs;<br>}<br></pre>

这是 <code>operator+</code> 的一个普通实现，但不是最高效的。其中创建了一个 <code>lhs</code> 的匿名局部拷贝，并对其调用 <code>operator+=</code> 再将它复制到函数的返回值(类型 T 的另一个匿名对象<code></code>)。标准通常不允许将临时对象优化掉： 

    
<blockquote>
      3.7.2/2: 自动存储的持续时间<br>






      <br>

如果一个命名自动对象有带副作用的初始化或析构函数，那么它不应在代码块结束之前销毁，也不应被优化掉，即使它看起来是没用的，除了在 12.8 中指定的类对象或其拷贝可以被优化掉。
    </blockquote>

重要的是对 12.8 的引用： 

    
<blockquote>
      12.8/15: 复制类对象<br>






       ...<br>

对于一个返回类类型的函数，如果在返回语句中的表达式是一个局部对象的名字，且该局对象的cv-限定类型与函数的返回类型相同，实现中允许忽略掉这个持有函数返回值的临时对象的创建，即使该类的复制构造函数或析构函数带有副作用。
    </blockquote>

这种优化就是著名的 named return value optimization (NRVO),&nbsp;我们可以这样来实现
    <code>operator+</code>: 
<pre>T operator+( const T&amp; lhs, const T&amp; rhs )<br>{<br>   T nrv( lhs );<br>   nrv += rhs;<br>   return nrv;<br>}<br></pre>

在这个实现中，编译器就可以去掉临时对象了。不幸的是，不是所有编译器都实现了 NRVO,&nbsp;有些还以错误的方法实现 NRVO 使得在这里不能使用。即使没有 NRVO, 后一种写法也不会比前一种更差，不过还有另一种可能的实现，它有一些非常特别的地方： 
<pre>T operator+( T lhs, const T&amp; rhs )<br>{<br>   return lhs += rhs;<br>}<br></pre>

这里与第一个实现的差别在于，<code>lhs</code> 不再是接受一个常量引用再创建一个拷贝；取而代之的是
    <code>lhs</code> 作为一个传值的参数，因此它已经被拷贝了。这种方法允许在某些情况下执行另一种优化(12.2/2)。考虑 <code>a&nbsp;+&nbsp;b&nbsp;+&nbsp;c，其中</code> <code>a&nbsp;+&nbsp;b</code> 的结果不会在作为 lhs 与 c 相加时进行一次拷贝。这比原来的代码更高效，但不如使用 NRVO 的编译器高效。对于多数人来说，更可能的是编译器不支持 NRVO, 但是现在 <code>operator+</code> 的符号特征有所变化。另外，对于
    <code>(a&nbsp;+&nbsp;b&nbsp;)&nbsp;+&nbsp;c</code> 和 <code>a&nbsp;+&nbsp;(&nbsp;b&nbsp;+&nbsp;c&nbsp;)</code>，所创建的对象数量也会不同。多数情况下，这不是什么问题，但如果你的代码依赖于函数的符号特征，或者要求严格对称的行为，你就应该在你的 user-config 中设置
    <code>BOOST_FORCE_SYMMETRIC_OPERATORS</code>. 这样将强制使用上面第二种方法，即使编译器没有实现 NRVO. <br>






     <br>






     
    
<h3><a name="grpd_oprs">组合算术操作符</a></h3>







    
<p>以下模板提供了一些相关操作符的组合。例如，一个 addable 的类型通常也是&nbsp;subractable 的，所以 <code><a href="#additive1">additive</a></code> 模板提供了这两个操作符的组合。组合算术操作符模板有一个额外的模板参数 <code>B</code>，下面没有提到，用于 <a href="#chaining">基类链</a> 技巧。</p>







    
<table align="center" border="1" cellpadding="5">






      <caption>组合算术操作符模板类
      </caption>

      <tbody>





    <tr>






        <td colspan="2">
          
      
      
      
      
      
      <table align="center" border="1">






            <caption>
              <em>Key</em>
            </caption>

            <tbody>





          <tr>






              <td><code>T</code>: 主操作数的类型</td>







              <td><code>U</code>: 另一个操作数的类型</td>






            </tr>






          
        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






        </td>






      </tr>







      <tr>






        <th>模板</th>







        <th>操作符模板组件</th>






      </tr>







      <tr>






        <td><code><a name="totally_ordered1">totally_ordered&lt;T&gt;</a></code><br>






         <code>totally_ordered1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#less_than_comparable1">less_than_comparable&lt;T&gt;</a></code></li>







            <li><code><a href="#equality_comparable1">equality_comparable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="totally_ordered2">totally_ordered&lt;T,
        U&gt;</a></code><br>






         <code>totally_ordered2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#less_than_comparable2">less_than_comparable&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#equality_comparable2">equality_comparable&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="additive1">additive&lt;T&gt;</a></code><br>






         <code>additive1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#addable1">addable&lt;T&gt;</a></code></li>







            <li><code><a href="#subtractable1">subtractable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="additive2">additive&lt;T, U&gt;</a></code><br>






         <code>additive2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#addable2">addable&lt;T, U&gt;</a></code></li>







            <li><code><a href="#subtractable2">subtractable&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="multiplicative1">multiplicative&lt;T&gt;</a></code><br>






         <code>multiplicative1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#multipliable1">multipliable&lt;T&gt;</a></code></li>







            <li><code><a href="#dividable1">dividable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="multiplicative2">multiplicative&lt;T,
        U&gt;</a></code><br>






         <code>multiplicative2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#multipliable2">multipliable&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#dividable2">dividable&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="integer_multiplicative1">integer_multiplicative&lt;T&gt;</a></code><br>







         <code>integer_multiplicative1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#multiplicative1">multiplicative&lt;T&gt;</a></code></li>







            <li><code><a href="#modable1">modable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="integer_multiplicative2">integer_multiplicative&lt;T,
        U&gt;</a></code><br>






         <code>integer_multiplicative2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#multiplicative2">multiplicative&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#modable2">modable&lt;T, U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="arithmetic1">arithmetic&lt;T&gt;</a></code><br>






         <code>arithmetic1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#additive1">additive&lt;T&gt;</a></code></li>







            <li><code><a href="#multiplicative1">multiplicative&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="arithmetic2">arithmetic&lt;T, U&gt;</a></code><br>






         <code>arithmetic2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#additive2">additive&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#multiplicative2">multiplicative&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="integer_arithmetic1">integer_arithmetic&lt;T&gt;</a></code><br>






         <code>integer_arithmetic1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#additive1">additive&lt;T&gt;</a></code></li>







            <li><code><a href="#integer_multiplicative1">integer_multiplicative&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="integer_arithmetic2">integer_arithmetic&lt;T,
        U&gt;</a></code><br>






         <code>integer_arithmetic2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#additive2">additive&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#integer_multiplicative2">integer_multiplicative&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="bitwise1">bitwise&lt;T&gt;</a></code><br>






         <code>bitwise1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#xorable1">xorable&lt;T&gt;</a></code></li>







            <li><code><a href="#andable1">andable&lt;T&gt;</a></code></li>







            <li><code><a href="#orable1">orable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="bitwise2">bitwise&lt;T, U&gt;</a></code><br>






         <code>bitwise2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#xorable2">xorable&lt;T, U&gt;</a></code></li>







            <li><code><a href="#andable2">andable&lt;T, U&gt;</a></code></li>







            <li><code><a href="#orable2">orable&lt;T, U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="unit_steppable">unit_steppable&lt;T&gt;</a></code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#incrementable">incrementable&lt;T&gt;</a></code></li>







            <li><code><a href="#decrementable">decrementable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="shiftable1">shiftable&lt;T&gt;</a></code><br>






         <code>shiftable1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#left_shiftable1">left_shiftable&lt;T&gt;</a></code></li>







            <li><code><a href="#right_shiftable1">right_shiftable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="shiftable2">shiftable&lt;T, U&gt;</a></code><br>






         <code>shiftable2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#left_shiftable2">left_shiftable&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#right_shiftable2">right_shiftable&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ring_operators1">ring_operators&lt;T&gt;</a></code><br>






         <code>ring_operators1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#additive1">additive&lt;T&gt;</a></code></li>







            <li><code><a href="#multipliable1">multipliable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ring_operators2">ring_operators&lt;T,
        U&gt;</a></code><br>






         <code>ring_operators2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#additive2">additive&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#subtractable2_left">subtractable2_left&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#multipliable2">multipliable&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ordered_ring_operators1">ordered_ring_operators&lt;T&gt;</a></code><br>







         <code>ordered_ring_operators1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#ring_operators1">ring_operators&lt;T&gt;</a></code></li>







            <li><code><a href="#totally_ordered1">totally_ordered&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ordered_ring_operators2">ordered_ring_operators&lt;T,
        U&gt;</a></code><br>






         <code>ordered_ring_operators2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#ring_operators2">ring_operators&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#totally_ordered2">totally_ordered&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="field_operators1">field_operators&lt;T&gt;</a></code><br>






         <code>field_operators1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#ring_operators1">ring_operators&lt;T&gt;</a></code></li>







            <li><code><a href="#dividable1">dividable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="field_operators2">field_operators&lt;T,
        U&gt;</a></code><br>






         <code>field_operators2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#ring_operators2">ring_operators&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#dividable2">dividable&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#dividable2_left">dividable2_left&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ordered_field_operators1">ordered_field_operators&lt;T&gt;</a></code><br>







         <code>ordered_field_operators1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#field_operators1">field_operators&lt;T&gt;</a></code></li>







            <li><code><a href="#totally_ordered1">totally_ordered&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ordered_field_operators2">ordered_field_operators&lt;T,
        U&gt;</a></code><br>






         <code>ordered_field_operators2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#field_operators2">field_operators&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#totally_ordered2">totally_ordered&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="euclidian_ring_operators1">euclidian_ring_operators&lt;T&gt;</a></code><br>







         <code>euclidian_ring_operators1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#ring_operators1">ring_operators&lt;T&gt;</a></code></li>







            <li><code><a href="#dividable1">dividable&lt;T&gt;</a></code></li>







            <li><code><a href="#modable1">modable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="euclidian_ring_operators2">euclidian_ring_operators&lt;T,
        U&gt;</a></code><br>






         <code>euclidian_ring_operators2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#ring_operators2">ring_operators&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#dividable2">dividable&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#dividable2_left">dividable2_left&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#modable2">modable&lt;T, U&gt;</a></code></li>







            <li><code><a href="#modable2_left">modable2_left&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ordered_euclidian_ring_operators1">ordered_euclidian_ring_operators&lt;T&gt;</a></code><br>







         <code>ordered_euclidian_ring_operators1&lt;T&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#euclidian_ring_operators1">euclidian_ring_operators&lt;T&gt;</a></code></li>







            <li><code><a href="#totally_ordered1">totally_ordered&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="ordered_euclidian_ring_operators2">ordered_euclidian_ring_operators&lt;T,
        U&gt;</a></code><br>






         <code>ordered_euclidian_ring_operators2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#euclidian_ring_operators2">euclidian_ring_operators&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#totally_ordered2">totally_ordered&lt;T,
            U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>






    
  
  
  
  
  
  </tbody>
</table>







    
<h4>拼写：euclidean 与 euclidian</h4>
<p>旧版本的 Boost.Operators 库使用 "<code>euclidian</code>"，但却指出 "<code>euclidean</code>" 是更通用的拼写法。为了兼容旧版本，现在本库同时支持两种拼写法。 </p><h3><a name="ex_oprs">模板例子</a></h3>







    
<p>算术操作符类模板 <code><a href="#operators1">operators&lt;&gt;</a></code> 和 <code><a href="#operators2">operators2&lt;&gt;</a></code> 是不可扩展的操作符组合类的例子。它们是从旧版本遗留下来的类模板，不能用于 <a href="#chaining">基类链</a>。</p>







    
<table align="center" border="1" cellpadding="5">






      <caption>最终算术操作符模板类
      </caption>

      <tbody>





    <tr>






        <td colspan="2">
          
      
      
      
      
      
      <table align="center" border="1">






            <caption>
              <em>Key</em>
            </caption>

            <tbody>





          <tr>






              <td><code>T</code>: 主操作数的类型</td>







              <td><code>U</code>: 另一个操作数的类型</td>






            </tr>






          
        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






        </td>






      </tr>







      <tr>






        <th>模板</th>







        <th>操作符模板组件</th>






      </tr>







      <tr>






        <td><code><a name="operators1">operators&lt;T&gt;</a></code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#totally_ordered1">totally_ordered&lt;T&gt;</a></code></li>







            <li><code><a href="#integer_arithmetic1">integer_arithmetic&lt;T&gt;</a></code></li>







            <li><code><a href="#bitwise1">bitwise&lt;T&gt;</a></code></li>







            <li><code><a href="#unit_steppable">unit_steppable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="operators2">operators&lt;T, U&gt;</a></code><br>






         <code>operators2&lt;T, U&gt;</code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#totally_ordered2">totally_ordered&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#integer_arithmetic2">integer_arithmetic&lt;T,
            U&gt;</a></code></li>







            <li><code><a href="#bitwise2">bitwise&lt;T, U&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>






    
  
  
  
  
  
  </tbody>
</table>







    
<h3><a name="a_demo">算术操作符的示例和测试程序</a></h3>







    
<p><cite><a href="operators_test.cpp">operators_test.cpp</a></cite> 程序示范了算术操作符模板的使用，可用于验证正确的操作。有关各个平台上的测试结果，请查看 <a href="../../status/compiler_status.html">compiler status report</a>.</p>







    
<h2><a name="deref">提领操作符和迭代器辅助类</a></h2>







    
<p><a href="#iterator">迭代器辅助类</a> 模板简化了创建定制迭代器的工作。与算术类型相似，一个完整的迭代器也有许多操作符是 "冗余" 的，可以依据核心操作符来实现。</p>







    
<p><a href="#dereference">提领操作符</a> 是由 <a href="#iterator">迭代器辅助类</a> 所引出的，不过通常用于非迭代器的上下文。许多冗余的迭代器操作符同时也是算术操作符，所以迭代器辅助类借用了许多前文定义的操作符。事实上，只需要定义两个新的操作符(成员指针操作符 <code>operator-&gt;</code> 和下标操作符 <code>operator[]</code>)！</p>







    
<p>对于可用于提领操作符实例化的类型的要求，被指定为一些有效表达式及其返回类型。对于复合操作符模板，只列出它的组件模板，以及可能的其它要求。</p>







    
<h3><a name="dereference">提领操作符</a></h3>







    
<p>下表中的所有提领操作符接受一个可选的模板参数(未列出)，用于 <a href="#chaining">基类链</a>。</p>







    
<table align="center" border="1" cellpadding="5">






      <caption>提领操作符模板类
      </caption>

      <tbody>





    <tr>






        <td colspan="3">
          
      
      
      
      
      
      <table align="center" border="1">






            <caption>
              <em>Key</em>
            </caption>

            <tbody>





          <tr>






              <td><code>T</code>: 操作数的类型</td>







              <td><code>P</code>: 指针类型</td>






            </tr>







            <tr>






              <td><code>D</code>: <code>difference_type</code></td>







              <td><code>R</code>: 引用类型</td>






            </tr>







            <tr>






              <td><code>i</code>: 类型 <code>T</code> 的对象(一个迭代器)</td>







              <td><code>n</code>: 类型 <code>D</code> 的对象(一个下标索引)</td>






            </tr>






          
        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






        </td>






      </tr>







      <tr>






        <th>模板</th>







        <th>提供的操作</th>







        <th>要求</th>






      </tr>







      <tr>






        <td><code><a name="dereferenceable">dereferenceable&lt;T,
        P&gt;</a></code></td>







        <td><code>P operator-&gt;() const</code></td>







        <td><code>(&amp;*i)</code>. 返回类型可转换为 <code>P</code>.</td>






      </tr>







      <tr>






        <td><code><a name="indexable">indexable&lt;T, D,
        R&gt;</a></code></td>







        <td><code>R operator[](D n) const</code></td>







        <td><code>*(i&nbsp;+&nbsp;n)</code>. 返回类型为
        <code>R</code>.</td>






      </tr>






    
  
  
  
  
  
  </tbody>
</table>







    
<h3><a name="grpd_iter_oprs">组合迭代器操作符</a></h3>







    
<p>其有五个迭代器操作符类模板，每个对应不同的迭代器类别。下表列出了一个定制迭代器可定义的各个类别所对应的操作符组合。这些类模板有一个额外的可选模板参数 <code>B</code> (未列出)，以支持 <a href="#chaining">基类链</a>。</p>







    
<table align="center" border="1" cellpadding="5">






      <caption>迭代器操作符类模板
      </caption>

      <tbody>





    <tr>






        <td colspan="2">
          
      
      
      
      
      
      <table align="center" border="1">






            <caption>
              <em>Key</em>
            </caption>

            <tbody>





          <tr>






              <td><code>T</code>: 操作数的类型</td>







              <td><code>P</code>: <code>指针类型</code></td>






            </tr>







            <tr>






              <td><code>D</code>: <code>difference_type</code></td>







              <td><code>R</code>: 引用类型</td>






            </tr>







            <tr>






              <td><code>V</code>: <code>value_type</code></td>







              <td>
              </td>






            </tr>






          
        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






        </td>






      </tr>







      <tr>






        <th>模板</th>







        <th>操作符模板组件</th>






      </tr>







      <tr>






        <td><code><a name="input_iteratable">input_iteratable&lt;T,
        P&gt;</a></code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#equality_comparable1">equality_comparable&lt;T&gt;</a></code></li>







            <li><code><a href="#incrementable">incrementable&lt;T&gt;</a></code></li>







            <li><code><a href="#dereferenceable">dereferenceable&lt;T,
            P&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="output_iteratable">output_iteratable&lt;T&gt;</a></code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#incrementable">incrementable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="forward_iteratable">forward_iteratable&lt;T,
        P&gt;</a></code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#input_iteratable">input_iteratable&lt;T,
            P&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="bidirectional_iteratable">bidirectional_iteratable&lt;T,
        P&gt;</a></code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#forward_iteratable">forward_iteratable&lt;T,
            P&gt;</a></code></li>







            <li><code><a href="#decrementable">decrementable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr>






        <td><code><a name="random_access_iteratable">random_access_iteratable&lt;T, P, D,
        R&gt;</a></code></td>







        <td>
          
      
      
      
      
      
      <ul>






            <li><code><a href="#bidirectional_iteratable">bidirectional_iteratable&lt;T,
            P&gt;</a></code></li>







            <li><code><a href="#totally_ordered1">totally_ordered&lt;T&gt;</a></code></li>







            <li><code><a href="#additive2">additive&lt;T,
            D&gt;</a></code></li>







            <li><code><a href="#indexable">indexable&lt;T, D,
            R&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>






    
  
  
  
  
  
  </tbody>
</table>







    
<h3><a name="iterator">迭代器辅助类</a></h3>







    
<p>同样有五个迭代器辅助类模板，每一个对应不同的迭代器类别。这些类不能用于 <a href="#chaining">基类链</a>。以下概要列明了这些类模板同时支持来自于 <a href="#grpd_iter_oprs">迭代器操作符类模板</a> 的迭代器操作符和C++标准所要求的迭代器 typedef
    (<code>iterator_category</code>, <code>value_type</code>,
    <i>等等</i>)。</p>







    
<table align="center" border="1" cellpadding="5">






      <caption>迭代器辅助类模板
      </caption>

      <tbody>





    <tr>






        <td colspan="2">
          
      
      
      
      
      
      <table align="center" border="1">






            <caption>
              <em>Key</em>
            </caption>

            <tbody>





          <tr>






              <td><code>T</code>: 操作数的类型</td>







              <td><code>P</code>: 指针类型</td>






            </tr>







            <tr>






              <td><code>D</code>: <code>difference_type</code></td>







              <td><code>R</code>: 引用类型</td>






            </tr>







            <tr>






              <td><code>V</code>: <code>value_type</code></td>







              <td><code>x1, x2</code>: 类型 <code>T 的对象</code></td>






            </tr>






          
        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






        </td>






      </tr>







      <tr>






        <th>模板</th>







        <th>操作及要求</th>






      </tr>







      <tr valign="baseline">






        <td><code><a name="input_iterator_helper">input_iterator_helper&lt;T,
        V, D, P, R&gt;</a></code></td>







        <td>支持以下的操作并有相应要求 

          
      
      
      
      
      
      <ul>






            <li><code><a href="#input_iteratable">input_iteratable&lt;T,
            P&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr valign="baseline">






        <td><code><a name="output_iterator_helper">output_iterator_helper&lt;T&gt;</a></code></td>







        <td>支持以下的操作并有相应要求 

          
      
      
      
      
      
      <ul>






            <li><code><a href="#output_iteratable">output_iteratable&lt;T&gt;</a></code></li>






          
      
      
      
      
      
      </ul>
参见 [<a href="#1">1</a>], [<a href="#2">2</a>].
        </td>






      </tr>







      <tr valign="baseline">






        <td><code><a name="forward_iterator_helper">forward_iterator_helper&lt;T, V, D, P,
        R&gt;</a></code></td>







        <td>支持以下的操作并有相应要求 

          
      
      
      
      
      
      <ul>






            <li><code><a href="#forward_iteratable">forward_iteratable&lt;T,
            P&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr valign="baseline">






        <td><code><a name="bidirectional_iterator_helper">bidirectional_iterator_helper&lt;T,
        V, D, P, R&gt;</a></code></td>







        <td>支持以下的操作并有相应要求 

          
      
      
      
      
      
      <ul>






            <li><code><a href="#bidirectional_iteratable">bidirectional_iteratable&lt;T,
            P&gt;</a></code></li>






          
      
      
      
      
      
      </ul>






        </td>






      </tr>







      <tr valign="baseline">






        <td><code><a name="random_access_iterator_helper">random_access_iterator_helper&lt;T,
        V, D, P, R&gt;</a></code></td>







        <td>支持以下的操作并有相应要求 

          
      
      
      
      
      
      <ul>






            <li><code><a href="#random_access_iteratable">random_access_iteratable&lt;T, P, D,
            R&gt;</a></code></li>






          
      
      
      
      
      
      </ul>
要满足 <cite><a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">随机访问迭代器</a></cite>,
          还需要 <code>x1 - x2</code> 的返回类型可转换为 <code>D</code>.
        </td>






      </tr>






    
  
  
  
  
  
  </tbody>
</table>







    
<h4><a name="iterator_helpers_notes">迭代器辅助类的说明</a></h4>







    
<p><a name="1">[1]</a> 不象其它的迭代器辅助类模板，<code>output_iterator_helper</code> 只接受一个模板参数 -
    其目标类的类型。虽然有些人认为这是不必要的限制，但是标准要求任何输出迭代器的 <code>difference_type</code> 和 <code>value_type</code> 应该是 <code>void</code> (24.3.1 [lib.iterator.traits]), 而
    <code>output_iterator_helper</code> 模板遵从了这个要求。还有，标准中的输出迭代器具有 void 指针和引用类型<code>，所以</code> <code>output_iterator_helper</code>
    也一样。</p>







    
<p><a name="2">[2]</a> 因为 self-proxying 是实现输出迭代器的最容易和最常见的方法(例如，标准库中的插入迭代器 [24.4.2] 和流迭代器 [24.5]),
    <code>所以 output_iterator_helper</code> 也支持这种惯用法，将 <code>operator*</code> 和 <code>operator++</code> 成员函数定义为直接返回迭代器本身的一个非常量引用。对 self-proxying 的支持允许我们在大多数情况可以把编写一个输出迭代器的工作量减少至只需要写两个成员函数 - 一个适当的构造函数和一个复制赋值操作符。例如，以下是 <code><a href="../iterator/doc/function_output_iterator.html">boost::function_output_iterator</a></code>
    迭代器的一个可能的实现：</p>






<pre>template&lt;class UnaryFunction&gt;<br>struct function_output_iterator<br>    : boost::output_iterator_helper&lt; function_output_iterator&lt;UnaryFunction&gt; &gt;<br>{<br>    explicit function_output_iterator(UnaryFunction const&amp; f = UnaryFunction())<br>        : func(f) {}<br><br>    template&lt;typename T&gt;<br>    function_output_iterator&amp; operator=(T const&amp; value)<br>    {<br>        this-&gt;func(value); <br>        return *this; <br>    }<br><br> private:<br>    UnaryFunction func;<br>};<br></pre>







    
<p>注意，对 self-proxying 的支持并不妨碍你使用
    <code>output_iterator_helper</code> 来实现其它不同种类的输出迭代器。如果
    <code>output_iterator_helper</code> 的目标类型提供了它自己的 <code>operator*</code> 或/与 <code>operator++</code> 定义，那么这些操作符将被使用，而且
    <code>output_iterator_helper</code> 所提供的相同操作符不会被实例化。</p>







    
<h3><a name="i_demo">迭代器示例和测试程序</a></h3>







    
<p>The <cite><a href="iterators_test.cpp">iterators_test.cpp</a></cite> 程序示范了迭代器模板的使用，也可用于验证正确的操作。以下是该测试程序中定义的定制迭代器。它示范了对必须定义的核心操作的正确(虽然简单)实现，这样迭代器辅助类才可以 "补充" 其它的迭代器操作。</p>







    
<blockquote>
  
  
  
  
  
  <pre>template &lt;class T, class R, class P&gt;<br>struct test_iter<br>  : public boost::random_access_iterator_helper&lt;<br>     test_iter&lt;T,R,P&gt;, T, std::ptrdiff_t, P, R&gt;<br>{<br>  typedef test_iter self;<br>  typedef R Reference;<br>  typedef std::ptrdiff_t Distance;<br><br>public:<br>  explicit test_iter(T* i =0);<br>  test_iter(const self&amp; x);<br>  self&amp; operator=(const self&amp; x);<br>  Reference operator*() const;<br>  self&amp; operator++();<br>  self&amp; operator--();<br>  self&amp; operator+=(Distance n);<br>  self&amp; operator-=(Distance n);<br>  bool operator==(const self&amp; x) const;<br>  bool operator&lt;(const self&amp; x) const;<br>  friend Distance operator-(const self&amp; x, const self&amp; y);<br>};<br></pre>






    </blockquote>







    
<p>有关各个平台上的测试结果，请查看 <a href="../../status/compiler_status.html">compiler status
    report</a>.</p>






    
<hr>

    
<h2><a name="contributors">贡献者</a></h2>







    
<dl>






      <dt><a href="../../people/dave_abrahams.htm">Dave Abrahams</a></dt>







      <dd>Started the library and contributed the arithmetic operators in
      <cite><a href="../../boost/operators.hpp">boost/operators.hpp</a></cite>.</dd>







      <dt><a href="../../people/jeremy_siek.htm">Jeremy Siek</a></dt>







      <dd>Contributed the <a href="#deref">dereference operators and iterator
      helpers</a> in <cite><a href="../../boost/operators.hpp">boost/operators.hpp</a></cite>. Also
      contributed <cite><a href="iterators_test.cpp">iterators_test.cpp</a></cite>.</dd>







      <dt><a href="../../people/aleksey_gurtovoy.htm">Aleksey
      Gurtovoy</a></dt>







      <dd>Contributed the code to support <a href="#chaining">base class
      chaining</a> while remaining backward-compatible with old versions of
      the library.</dd>







      <dt><a href="../../people/beman_dawes.html">Beman Dawes</a></dt>







      <dd>Contributed <cite><a href="operators_test.cpp">operators_test.cpp</a></cite>.</dd>







      <dt><a href="../../people/daryle_walker.html">Daryle Walker</a></dt>







      <dd>Contributed classes for the shift operators, equivalence, partial
      ordering, and arithmetic conversions. Added the grouped operator
      classes. Added helper classes for input and output iterators.</dd>







      <dt>Helmut Zeisel</dt>







      <dd>Contributed the 'left' operators and added some grouped operator
      classes.</dd>







      <dt>Daniel Frey</dt>







      <dd>Contributed the NRVO-friendly and symmetric implementation of
      arithmetic operators.</dd>







    
</dl>







    
<h2>旧版本用户的注意事项<a name="old_lib_note"></a></h2>







    
<p><a href="#chaining">本库的接口及推荐用法的</a><a href="operators.htm#chaining">变更</a><a href="#chaining"></a> 来自于下面所讨论的几个实际问题。新版本的库仍然保持与旧版本的后向兼容(因此你不一定要修改现有代码)，但是旧的用法不被推荐使用。虽然它比使用 <a href="#chaining">基类链</a> 更简单也更直观，但是我们发现从多个操作符模板进行派生的旧方法会导致结果类远大于它们应有的大小。多数现代C++编译器在从多个空基类进行派生时都会导致类的大小显著膨胀，即使这些基类本身并没有状态。例如，这个&nbsp;<a href="operators.htm#example">例子</a> 中的
    <code>point&lt;int&gt;</code> 在Win32平台的多个编译器上的大小为 12-24 字节，而不是我们期望的 8 字节。</p>







    
<p>严格来说，这不是程序库的错误--语言的规则允许编译器在这种情况下对空基类进行优化。原则上任意数量的空基类可以被分配在同一个位置上，它们之中
没有共同的祖先(请见标准的 section 10.5 [class.derived] paragraph 5)。但是语言定义也没有<span style="font-style: italic;">要求</span>实现一定要执行这个优化，而当前的编译器只有少数在多重继承中实现这种优化。更糟的是，目前也看不到现有的编译器会有这方面的改进，因为这样会破坏由同一个编译器的两个不同版本所生成的代码之间的二进制兼容性。正如 Matt Austern
    所说，"One of the few times when you have the freedom to do this sort of
    thing is when you're targeting a new architecture...". 另一方面，许多常见编译器在单继承层次中会使用空基类优化。</p>







    
<p>在讨论了这个问题对于本库用户的重要性(本库的目标是用于编写轻量级的类，如
    <code>MyInt</code> 或 <code>point&lt;&gt;</code>)，
以及上面所说的各种压力之后，我们决定修改库的接口以解决对象大小膨胀的问题，即使是在只支持最简单方式的空基类优化的编译器上也不会出现此类问题。当前
的库接口就是这种改变的结果。虽然新的用法与旧的相比有点复杂，不过我们认为这是值得的，它使得该库在真实世界中更为有用。Alexy
Gurtovoy 贡献了支持新用法并保持后向兼容性的相关代码。</p>






    
<hr>

    
<p>Revised: 7 Aug 2008</p>
<p>Copyright © Beman Dawes, David Abrahams, 1999-2001.</p>
<p>Copyright © Daniel Frey, 2002-2009.</p><p>Use, modification, and distribution is subject to the Boost Software 
    License, Version 1.0. (See accompanying file
    <a href="../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at
    <a href="http://www.boost.org/LICENSE_1_0.txt">
    www.boost.org/LICENSE_1_0.txt</a>)</p>






  
</body></html>
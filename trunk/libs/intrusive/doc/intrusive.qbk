[/
 / Copyright (c) 2007-2009 Ion Gaztanaga
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[library Boost.Intrusive
    [quickbook 1.4]
    [authors [Krzikalla, Olaf], [Gaztanaga, Ion]]
    [copyright 2005 Olaf Krzikalla, 2006-2009 Ion Gaztanaga]
    [id intrusive]
    [dirname intrusive]
    [purpose Intrusive containers]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section:introduction Introduction 简介]

[section:introduction_presenting Presenting Boost.Intrusive 介绍Boost.Intrusive]

[*Boost.Intrusive] is a library presenting some intrusive containers to
the world of C++. Intrusive containers are special containers
that offer [link intrusive.performance better performance]
and exception safety guarantees than non-intrusive containers (like STL containers). \n
[*Boost.Intrusive] 是一个将介入式容器引入到C++世界的库。介入式容器是一种特殊的容器，
它提供比非介入式容器(如STL容器) [link intrusive.performance 更好的性能] 和异常安全保证。 

The performance benefits of intrusive containers makes them ideal as a building
block to efficiently construct complex containers like multi-index containers or
to design high performance code like memory allocation algorithms.\n
介入式容器的性能优点使得它们成为一种构建块，用以高效地构造复杂容器，如多索引容器，
或者用以设计高性能代码，如内存分配算法。

While intrusive containers were and are widely used in C, they
became more and more forgotten in C++ due to the presence of the standard
containers which don't support intrusive techniques.[*Boost.Intrusive] not only
reintroduces this technique to C++, but also encapsulates the implementation in
STL-like interfaces. Hence anyone familiar with standard containers can easily use
[*Boost.Intrusive].\n
虽然介入式容器在C中被广泛使用，但是在C++中却被日渐遗忘，这是由于不支持介入式技术的标准容器的出现。
[*Boost.Intrusive] 不仅重新将这一技术引入到C++，而且还将实现封装为类似于STL的接口。
所以每一个熟悉标准容器的人都可以很容易地使用 [*Boost.Intrusive]

[endsect]

[section:introduction_building_intrusive Building Boost.Intrusive 构建Boost.Intrusive ]

There is no need to compile anything to use [*Boost.Intrusive], since it's
a header only library. Just include your Boost header directory in your
compiler include path.\n
使用  [*Boost.Intrusive] 不需要编译任何东西，因为它是一个仅有头文件的库。
只需要将你的 Boost 头文件目录包含在你的编译器包含路径中就可以了。

[endsect]

[endsect]

[section:intrusive_vs_nontrusive Intrusive and non-intrusive containers 介入式和非介入式容器]

[section:differences_intrusive_vs_nontrusive Differences between intrusive and non-intrusive containers 介入式和非介入式容器的区别]

The main difference between intrusive containers and non-intrusive containers is
that in C++ non-intrusive containers store [*copies] of values passed by the user.
Containers use the `Allocator` template parameter to allocate the stored values:\n
介入式容器与非介入式容器的主要区别在于，在C++非介入式容器中保存的是由用户传入的值的[*拷贝]。
容器使用 Allocator 模块参数来分配被保存的值：

[c++]

   #include <list>
   #include <assert.h>

   int main()
   {
      std::list<MyClass> myclass_list;

      MyClass myclass(...);
      myclass_list.push_back(myclass);

      //The stored object is different from the original object
      //被保存的对象不同于原始对象
      assert(&myclass != &myclass_list.front());
      return 0;
   }


To store the newly allocated copy of `myclass`, the container needs additional
data: `std::list` usually allocates nodes that contain pointers to the
next and previous node and the value itself. Something similar to:\n
为了保存新分配的 `myclass` 拷贝，容器需要其它的数据：`std::list` 通常要分配节点，
节点中包含有到下一个和前一个节点的指针，和它本身的值。这类似于：

[c++]

   //A possible implementation of a std::list<MyClass> node
   //一个 std::list<MyClass> 节点的可能实现
   class list_node
   {
      list_node *next;
      list_node *previous;
      MyClass    value; 
   };


On the other hand, an intrusive container does not store copies of passed objects,
but it stores the objects themselves. The additional data needed to insert the object
in the container must be provided by the object itself. For example, to insert `MyClass`
in an intrusive container that implements a linked list, `MyClass` must contain the
needed ['next] and ['previous] pointers:\n
另一方面，介入式容器则不保存传入对象的拷贝，而是保存对象本身。需要插入到容器中对象里的额外数据必须由对象本身提供。
例如，要将 `MyClass` 插入到一个实现了链表功能的介入式容器中，`MyClass` 必须包含所需的 ['next] 和 ['previous] 指针：

[c++]

   class MyClass
   {
      MyClass *next;
      MyClass *previous;
      //Other members... 其它成员...
   };

   int main()
   {
      acme_intrusive_list<MyClass> list;

      MyClass myclass;
      list.push_back(myclass);

      //"myclass" object is stored in the list
      //"myclass" 对象保存在 list 中
      assert(&myclass == &list.front());
      return 0;
   }

As we can see, knowing which additional data the class should contain is not
an easy task. [*Boost.Intrusive] offers several intrusive containers and an easy
way to make user classes compatible with those containers.\n
正如我们所看到的，知道这个类要包含哪些额外的数据可不是一件容易的工作。[*Boost.Intrusive]
提供了多个介入式容器以及一个容易的方法来让用户类可以兼容于这些容器。

[endsect]

[section:properties_of_intrusive Properties of Boost.Intrusive containers  Boost.Intrusive容器的特点 ]

Semantically, a [*Boost.Intrusive] container is similar to a STL container 
holding pointers to objects. That is, if you have an intrusive list holding
objects of type `T`, then `std::list<T*>` would allow you to do quite the
same operations (maintaining and navigating a set of objects of type T and
types derived from it). \n
语义上，一个 [*Boost.Intrusive] 容器类似于一个保存对象指针的STL容器。即，
如果你有一个保存类型 `T` 的对象的介入式 list，那么 `std::list<T*>` 
也允许你做完全相同的操作(维护和操纵一组类型为 T 或其派生类的对象)。

A non-intrusive container has some limitations:\n
非介入式容器有一些限制：

*  An object can only belong to one container: If you want to share an object
   between two containers, you either have to store multiple copies of those
   objects or you need to use containers of pointers: `std::list<Object*>`.\n
   一个对象只能属于一个容器：如果你想在两个容器间共享一个对象，你要么必须保存多份拷贝，
   要么就需要使用指针容器：`std::list<Object*>`. 

*  The use of dynamic allocation to create copies of passed values can be a performance
   and size bottleneck in some applications. Normally, dynamic allocation imposes
   a size overhead for each allocation to store bookkeeping information and a
   synchronization to protected concurrent allocation from different threads.\n
   在一些应用中，为传入值创建拷贝所用的动态分配可能成为性能和空间的瓶颈。通常，
   动态分配需要为每次分配增加一些空间开销来保簿记信息，还有同步操作以保护来自不同线程的并发分配。

*  Only copies of objects are stored in non-intrusive containers. Hence copy
   or move constructors and copy or move assignment operators are required. Non-copyable
   and non-movable objects can't be stored in non-intrusive containers.\n
   在非介入式容器中只能保存对象的拷贝。因此，需要复制或移动构造函数和复制或移动赋值操作符。
   不可复制和不可移动的对象不能保存在非介入式容器中。

*  It's not possible to store a derived object in a STL-container while
   retaining its original type.\n
   不可能将一个派生类对象保存在STL容器中而且保留它的原本类型。

Intrusive containers have some important advantages: \n
介入式容器具有以下重要优点：

*  Operating with intrusive containers doesn't invoke any memory management at all.
   The time and size overhead associated with dynamic memory can be minimized.\n
   介入式容器的操作根本不会引发任何内存管理。动态内存分配所带来的时间和空间开销可以被最小化。

*  Iterating an Intrusive container needs less memory accesses than the semantically
   equivalent container of pointers: iteration is faster.\n
   介入式容器的迭代比相同语义的指针容器需要更少的内存访问：迭代可以更快。

*  Intrusive containers offer better exception guarantees than non-intrusive containers.
   In some situations intrusive containers offer a no-throw guarantee that can't be 
   achieved with non-intrusive containers.\n
   介入式容器提供了比非介入式容器更好的异常保证。在一些情形下，介入式容器提供了无抛出保证，
   而非介入式容器是不可能达到的。

*  The computation of an iterator to an element from a pointer or reference to that element
   is a constant time operation (computing the position of `T*` in a `std::list<T*>` has
   linear complexity).\n
   从一个元素的指针或引用计算该元素的迭代器是常量时间操作(而在 `std::list<T*>` 中计算一个 `T*` 
   的位置则具有线性复杂度)。 

*  Intrusive containers offer predictability when inserting and erasing objects since no
   memory management is done with intrusive containers. Memory management usually is not a predictable
   operation so complexity guarantees from non-intrusive containers are looser than the guarantees
   offered by intrusive containers.\n
   介入式容器在插入和删除对象时提供了可预见性，因为介入式容器不需要内存管理。内存管理通常都不是一个可预见的操作，
   因此非介入式容器的复杂度保证要比介入式容器所提供的保证宽松。

Intrusive containers have also downsides:\n
介入式容器也有缺点：

*  Each type stored in an intrusive container needs additional memory holding the 
   maintenance information needed by the container. Hence, whenever a certain type will
   be stored in an intrusive container [*you have to change the definition of that type]
   appropriately. Although this task is easy with [*Boost.Intrusive], touching the 
   definition of a type is sometimes a crucial issue.\n
   保存在介入式容器中的类型需要额外的内存来保存容器所需的维护信息。因此，当某个特定类型要被保存在介入式容器中时，
   [*你必须适当地修改该类型的定义]。虽然这一工作对于 [*Boost.Intrusive] 来说很容易，
   但是有时候触动类型的定义也是一个关键问题。 

*  In intrusive containers you don't store a copy of an object, [*but rather the original object
   is linked with other objects in the container]. Objects don't need copy-constructors or assignment
   operators to be stored in intrusive containers. But you have to take care of possible side effects, 
   whenever you change the contents of an object (this is especially important for 
   associative containers).\n
   在介入式容器中，你不能保存一个对象的拷贝，[*而是将原来的对象和容器中的其它对象链接起来]。
   对象不需要复制构造函数或赋值操作符来保存到介入式容器中。但是在修改对象的内容时，
   你必须小心可能存在的副作用(这对于关联式容器尤其重要)。 

*  The user [*has to manage the lifetime of inserted objects] independently from the
   containers.\n
   用户必须独立于容器[*管理被插入对象的生存期]。 

*  Again you have to be [*careful]: in contrast to STL containers [*it's easy to render an
   iterator invalid] without touching the intrusive container directly, because the object
   can be disposed before is erased from the container.\n
   你还必须[*小心]：与STL容器相比，[*它更容易引致迭代器失效]，即使没有直接触动介入式容器，
   因为对象可能在被从容器中移除之前就销毁。

*  [*Boost.Intrusive] containers are [*non-copyable and non-assignable]. Since intrusive
   containers don't have allocation capabilities, these operations make no sense. However,
   swapping can be used to implement move capabilities. To ease the implementation of
   copy constructors and assignment operators of classes storing [*Boost.Intrusive]
   containers, [*Boost.Intrusive] offers special cloning functions. See
   [link intrusive.clone_from Cloning [*Boost.Intrusive] containers] section for more information.\n
   [*Boost.Intrusive] 容器是[*不可复制和不可赋值的]。因为介入式容器没有分配内存的能力，
   所以这些操作是没有意义的。但是，交换操作可用于实现移动的能力。为了减轻保存在 [*Boost.Intrusive]
   容器中的类的复制构造函数和赋值操作符的实现难度，[*Boost.Intrusive] 提供了特殊的克隆函数。
   更多信息请见 [link intrusive.clone_from 克隆[*Boost.Intrusive]容器] 一节。 

*  Analyzing the thread safety of a program that uses containers is harder with intrusive containers, because
   the container might be modified indirectly without an explicit call to a container member.\n
   分析一个使用容器的程序的线程安全要比分析介入式容器更困难，因为可以无需显式调用容器的成员函数就间接修改该容器。

[table Summary of intrusive containers advantages and disadvantages 介入式容器优缺点总结
    [[Issue 问题]                                                                     [Intrusive 介入式]                         [Non-intrusive 非介入式 ]]
    [[Memory management\n内存管理]                                                         [External\n外部]                          [Internal through allocator\n内部，通过分配器]]
    [[Insertion/Erasure time\n插入/删除的时间]                                                    [Faster\n较快]                            [Slower\n较慢]]
    [[Memory locality\n内存局部性]                                                           [Better\n较好]                            [Worse\n较差]]
    [[Can hold non-copyable and non-movable objects by value\n可否以值方式保存不可复制和不可移动的对象]                    [Yes\n可以]                               [No\n不可]]
    [[Exception guarantees\n异常保证]                                                      [Better\n较好]                            [Worse\n较差]]
    [[Computation of iterator from value\n从值计算迭代器]                                        [Constant\n常量复杂度]                          [Non-constant\n非常量复杂度]]
    [[Insertion/erasure predictability\n插入/删除操作的可预见性]                                          [High\n高]                              [Low\n低]]
    [[Memory use\n内存占用]                                                                [Minimal\n最少]                           [More than minimal\n比最少多]]
    [[Insert objects by value retaining polymorphic behavior\n以值方式插入的对象保持多态行为]                    [Yes\n是]                               [No (slicing)\n不是(切片)]]
    [[User must modify the definition of the values to insert\n用户必须修改值的定义以便插入]                   [Yes\n是]                               [No\n否]]
    [[Containers are copyable\n容器是可复制的]                                                   [No\n否]                                [Yes\n是]]
    [[Inserted object's lifetime managed by\n被插入对象的生存期由谁管理]                                     [User (more complex)\n用户(较复杂)]               [Container (less complex)\n容器(较不复杂)]]
    [[Container invariants can be broken without using the container\n不使用容器也能破坏容器的不变式]            [Easier\n较容易]                            [Harder (only with containers of pointers)\n较难(只有使用指针容器才会)]]
    [[Thread-safety analysis线程安全性分析]                                                    [Harder\n较难]                            [Easier\n较容易]]
]

For a performance comparison between Intrusive and Non-intrusive containers see
[link intrusive.performance Performance] section.\n
有关介入式容器与非介入式容器的性能比较，请见 [link intrusive.performance 性能] 一节。

[endsect]

[endsect]

[section:usage How to use Boost.Intrusive 如何使用Boost.Intrusive]

If you plan to insert a class in an intrusive container, you have to make some decisions 
influencing the class definition itself. Each class that will be used in an intrusive 
container needs some appropriate data members storing the information needed by the 
container. We will take a simple intrusive container, the intrusive list
([classref boost::intrusive::list boost::intrusive::list]), for the following
examples, but all [*Boost.Intrusive] containers are very similar. To compile
the example using [classref boost::intrusive::list boost::intrusive::list],
just include:\n
如果你计划将一个类插入到介入式容器中，你必须作出一些影响这个类本身的定义的决定。
每一个要在介入式容器中使用的类都需要一些适当的数据成员，来保存容器所需的信息。
以下例子，我们将看到一个简单的介入式容器：介入式链表([classref boost::intrusive::list boost::intrusive::list])，
不过所有的 [*Boost.Intrusive] 容器都非常相似。要编译使用 [classref boost::intrusive::list boost::intrusive::list] 
的例子，只要包含：

[c++]

   #include <boost/intrusive/list.hpp>

Every class to be inserted in an intrusive container, needs to contain a hook that
will offer the necessary data and resources to be insertable in the container.
With [*Boost.Intrusive] you just choose the hook to be a public base class or
a public member of the class to be inserted.\n
每一个被插入到介入式容器中的类，为了可以插入到容器，都要包含一个钩子，它提供了必要的数据和资源。
对于 [*Boost.Intrusive]，你只需选择是用被插入类的公有基类，还是被插入类的公有成员来实现钩子。 

[section:usage_base_hook Using base hooks 使用基类钩子]

For [classref boost::intrusive::list list], you can publicly derive from 
[classref boost::intrusive::list_base_hook list_base_hook].\n
对于 [classref boost::intrusive::list list]，你可以公有派生自 [classref boost::intrusive::list_base_hook list_base_hook].

[c++]

   template <class ...Options>
   class list_base_hook;

The class can take several options. [*Boost.Intrusive] classes receive arguments in the
form `option_name<option_value>`. You can specify the following options:   \n
该类可以接受几个选项。[*Boost.Intrusive] 以 `option_name<option_value>` 的形式来接受实参。你可以指定以下选项： 

*  [*`tag<class Tag>`]: this argument serves as a tag, so you can derive from more than one
   [classref boost::intrusive::list_base_hook list_base_hook] and hence put an object in
   multiple intrusive lists at the same time. An incomplete type can serve as a tag.
   If you specify two base hooks, you [*must] specify a different
   tag for each one. Example: `list_base_hook< tag<tag1> >`. If no tag is specified
   a default one will be used (more on default tags later).\n
   [*`tag<class Tag>`]: 该实参被作为一个标记，这样你就可以派生自多个 [classref boost::intrusive::list_base_hook list_base_hook]，
   从而将一个对象同时放入多个介入式链表。一个不完整的类型就可以作为标记。如果你指定了两个基类钩子，
   你[*必须]为每一个指定不同的标记。例如：`list_base_hook< tag<tag1> >`。如果未指定标记，
   则使用一个缺省值(稍后对缺省标记再作说明)。

*  [*`link_mode<link_mode_type LinkMode>`]: The second template argument controls the
   linking policy. [*Boost.Intrusive] currently supports
   3 modes: `normal_link`, `safe_link` and `auto_unlink`. By default, `safe_link`
   mode is used. More about these in sections
   [link intrusive.safe_hook Safe hooks] and [link intrusive.auto_unlink_hooks Auto-unlink hooks].
   Example: `list_base_hook< link_mode<auto_unlink> >`\n
   [*`link_mode<link_mode_type LinkMode>`]: 第二个模板实参控制链接策略。目前 [*Boost.Intrusive] 支持3种模式：
   `normal_link`, `safe_link` 和 `auto_unlink`。缺省使用 `safe_link` 模式。更多说明在 
   [link intrusive.safe_hook 安全钩子] 和 [link intrusive.auto_unlink_hooks 自断钩子] 章节。
   例如：`list_base_hook< link_mode<auto_unlink> >` 

*  [*`void_pointer<class VoidPointer>`]: this option is the pointer type to be used
   internally in the hook. The default value is `void *`, which means that raw pointers
   will be used in the hook. More about this in the section titled
   [link intrusive.using_smart_pointers Using smart pointers with Boost.Intrusive containers].
   Example: `list_base_hook< void_pointer< my_smart_ptr<void> >`\n
   [*`void_pointer<class VoidPointer>`]: 这一选项是钩子内部所使用的指针类型。缺省值为 `void *`，
   这意味着在钩子中将使用裸指针。更多说明在 [link intrusive.using_smart_pointers 在 Boost.Intrusive 容器中使用智能指针] 一节。
   例子：`list_base_hook< void_pointer< my_smart_ptr<void> >` 

For the following examples, let's forget the options and use the default values:\n
以下例子中，让我们忘记这些选项，只使用缺省值：

[c++]

   #include <boost/intrusive/list.hpp>

   using namespace boost::intrusive;

   class Foo
      //Base hook with default tag, raw pointers and safe_link mode
      //带缺省标记、裸指针和 safe_link 模式的基类钩子
      :  public list_base_hook<>
   { /**/ };

After that, we can define the intrusive list:\n
然后，我们就可以定义介入式链表：

[c++]

   template <class T, class ...Options>
   class list;

`list` receives the type to be inserted in the container (`T`) as the first parameter
and optionally, the user can specify options. We have 3 option types:\n
`list` 将被插入到容器中的类型(`T`) 作为第一个参数，并接受其它由用户指定的可选项。我们有3个选项类型： 

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: All these options specify the relationship
   between the type `T` to be inserted in the list and the hook (since we can
   have several hooks in the same `T` type). `member_hook` will be explained
   a bit later and `value_traits` will be explained in the 
   [link intrusive.value_traits Containers with custom ValueTraits] section.
   [*If no option is specified, the container will be configured to use the base
   hook with the default tag].
   Some options configured for the hook (the type of the pointers, link mode, etc.)
   will be propagated to the container.\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 所有这些选项都是指定插入到链表中的类型 `T` 与钩子之间的关系
   (因为对于同一个类型 `T`，我们可以有多个钩子)。`member_hook` 稍后解释，`value_traits` 则将在 
   [link intrusive.value_traits 带定制化 ValueTraits 的容器] 一节中解释。[*如果未指定选项，
   容器将被配置为使用带缺省标记的基类钩子]。为钩子所配置的选项(指针类型、链接模式等等)将被传到容器。

*  [*`constant_time_size<bool Enabled>`]: Specifies if a constant time `size()`
   function is demanded for the container. This will instruct the intrusive
   container to store an additional member to keep track of the current size of the
   container. By default, constant-time size is activated.\n
   [*`constant_time_size<bool Enabled>`]: 指定容器是否需要一个常量时间的 `size()` 函数。
   它将通知介入式容器保存一个额外成员，以跟踪容器的当前大小。缺省情况下，常量时间大小被激活。 

*  [*`size_type<bool Enabled>`]: Specifies a type that can hold
   the size of the container. This type will be the type returned by `list.size()`
   and the type stored in the intrusive container if `constant_time_size<true>`
   is requested.
   The user normally will not need to change this type, but some
   containers can have a `size_type` that might be different from `std::size_t`
   (for example, STL-like containers use the `size_type` defined by their allocator).
   [*Boost.Intrusive] can be used to implement such containers specifying the
   the type of the size. By default the type is `std::size_t`.\n
   [*`size_type<bool Enabled>`]: 指定一个可以保存容器大小的类型。如果 `constant_time_size<true>` 被请求，
   则该类型将作为 `list.size()` 的返回类型并保存在介入式容器中。用户通常不需要修改这一类型，
   不过有些容器可能具有一个不同于 `std::size_t` 的 `size_type` (例如，类-STL容器使用由它们的分配器所定义的
   `size_type`)。[*Boost.Intrusive] 可以用于实现指定大小类型的容器。该类型的缺省值为 `std::size_t`. 

Example of a constant-time size intrusive list that will store Foo objects, using
the base hook with the default tag:\n
以下例子是一个保存 Foo 对象，使用基类钩子，带缺省标记，含常量时间大小函数的介入式链表：

[c++]

   typedef list<Foo> FooList;

Example of a intrusive list with non constant-time size that will store Foo objects:\n
以下例子是一个保存 Foo 对象，不含常量时间大小函数的介入式链表：

[c++]

   typedef list<Foo, constant_time_size<false> > FooList;

Remember that the user must specify the base hook if the base hook has no default tag
(e.g: if more than one base hook is used):\n
请记住，如果基类钩子没有缺省标记，用户必须指定该基类钩子(如：如果有一个以上的基类钩子)：

[c++]

   #include <boost/intrusive/list.hpp>

   using namespace boost::intrusive;
   
   struct my_tag;

   typedef list_base_hook< tag<my_tag> > BaseHook;
   class Foo   :  public BaseHook
   { /**/ };

   typedef list< Foo, base_hook<BaseHook> > FooList;

Once the list is defined, we can use it:\n
定义了该链表后，我们就可以使用它了：

[c++]

   //An object to be inserted in the list
   //插入到链表中的对象
   Foo foo_object;
   FooList list;

   list.push_back(object);

   assert(&list.front() == &foo_object);

[endsect]

[section:usage_member_hook Using member hooks 使用成员钩子]

Sometimes an 'is-a' relationship between list hooks and the list value types
is not desirable. In this case, using a member hook as a data member instead of
'disturbing' the hierarchy might be the right way: you can add a public data
member `list_member_hook<...>` to your class.
This class can be configured with the same options as `list_base_hook`
except the option `tag`:\n
有时候，链表钩子和链表值类型之间的 'is-a' 关系是不合理的。这时，使用一个成员钩子作为数据成员，
而不是'打乱'类的继承层次，可能是正确的方法：你可增加一个公有数据成员 `list_member_hook<...>` 到你的类中。
该类可以用和 `list_base_hook` 一样的选项来配置，除了 `tag` 选项：

[c++]

   template <class ...Options>
   class list_member_hook;

Example:\n
例如：

[c++]

   #include <boost/intrusive/list.hpp>

   class Foo 
   {
      public:
      list_member_hook<> hook_;  
      //...
   };

When member hooks are used, the `member_hook` option is used to configure the
list:\n
使用成员钩子时，`member_hook` 选项被用于配置链表：

[c++]

   //This option will configure "list" to use the member hook
   //这个选项将 "list" 配置为使用成员钩子
   typedef member_hook<Foo, list_member_hook<>, &Foo::hook_> MemberHookOption;

   //This list will use the member hook
   //这个 list 将使用成员钩子
   typedef list<Foo, MemberHookOption> FooList;

Now we can use the container:\n
现在我们就可以使用这个容器了：

[c++]

   //An object to be inserted in the list
   //被插入到链表中的对象
   Foo foo_object;
   FooList list;

   list.push_back(object);

   assert(&list.front() == &foo_object);

[endsect]

[section:usage_both_hooks Using both hooks 使用两种钩子]

You can insert the same object in several intrusive containers at the same time, 
using one hook per container. This is a full example using base and member hooks:\n
你可以将同一个对象同时插入到多个介入式容器中，每个容器使用一个钩子。以下是一个使用基类钩子和成员钩子的完整例子：

[import ../example/doc_how_to_use.cpp]
[doc_how_to_use_code]

[endsect]

[section:usage_lifetime Object lifetime 对象的生存期]

Even if the interface of [classref boost::intrusive::list list] is similar to
`std::list`, its usage is a bit different: You always have to keep in mind that 
you directly store objects in intrusive containers, not copies. The lifetime of a 
stored object is not bound to or managed by the container:\n
虽然 [classref boost::intrusive::list list] 的接口与 `std::list` 类似，但是它的用法有些不一样：
你必须紧记你是直接将对象保存到介入式容器中，而不是其拷贝。被保存对象的生存期未被绑定到容器，
也不是由容器负责管理： 

*  When the container gets destroyed before the object, the object is not destroyed,
   so you have to be careful to avoid resource leaks.\n
   如果容器在对象之前被销毁，则对象不会被销毁，因此你必须小心以防止资源泄漏。
   
*  When the object is destroyed before the container, your program is likely to crash,
   because the container contains a pointer to an non-existing object.\n
   如果对象在容器之前被销毁，你的程序很可能会崩溃，因为容器中包含了一个指针，指向不存在的对象。

[endsect]

[endsect]

[section:usage_when When to use? 何时使用？]

Intrusive containers can be used for highly optimized algorithms, where speed is a crucial
issue and:\n
介入式容器可用于速度是关键问题的高度优化的算法，以及：

*  additional memory management should be avoided.\n
   要避免额外的内存管理。
*  the programmer needs to efficiently track the construction and destruction of objects.\n
   程序员需要高效地跟踪对象的构造和析构。
*  exception safety, especially the no-throw guarantee, is needed.\n
   需要异常安全，尤其是无抛出保证。
*  the computation of an iterator to an element from a pointer or reference
   to that element should be a constant time operation.\n
   从某个元素的指针或引用得到该元素的迭代器的计算要求是常量时间的操作。
*  it's important to achieve a well-known worst-time system response.\n
   实现可预知的最坏系统响应时间是重要的。
*  localization of data (e.g. for cache hit optimization) leads to measurable effects.\n
   数据局部性(例如，为了缓存命中优化)会导致可测量的影响。

The last point is important if you have a lot of containers over a set of elements. E.g. if 
you have a vector of objects (say, `std::vector<Object>`), and you also have a list
storing a subset of those objects (`std::list<Object*>`), then operating on an Object
from the list iterator (`std::list<Object*>::iterator`) requires two steps:\n
如果你有多个容器建立在同一组元素之上，那么最后一点就很重要了。例如，如果你有一组对象的 vector 
(即 `std::vector<Object>`)，而且你还有一个链表保存了这些对象的一个子集(`std::list<Object*>`)，
那么从这个链表的迭代器(`std::list<Object*>::iterator`)操作一个 Object 就需要两步：

*  Access from the iterator (usually on the stack) to the list node storing a pointer to `Object`.\n
   从迭代器(通常是在栈上)访问保存了 `Object` 指针的链表节点。
*  Access from the pointer to `Object` to the Object stored in the vector.\n
   从 `Object` 指针访问保存在 vector 中的 Object。

While the objects themselves are tightly packed in the memory of the vector
(a vector's memory is guaranteed to be contiguous), and form something
like a data block, list nodes may be dispersed in the heap memory.
Hence depending on your system you might get a lot of cache misses. The same doesn't hold
for an intrusive list. Indeed, dereferencing an iterator from an intrusive list is performed in
the same two steps as described above. But the list node is already embedded in the Object, so
the memory is directly tracked from the iterator to the Object. \n
虽然这些对象本身是被紧紧地压缩在 vector 的内存中的(vector 的内存是保证连续的)，
形成了象一个数据块那样的东西，但是链表结点却可能分散在堆内存中。因此，取决于你的系统，
你可能会遇到大量的缓存失失败。对于介入式链表则不会这样。事实上，
解引用一个来自于介入式链表的迭代器同样要执行以上两步。但是由于链表结点已经被嵌入在 Object 中，
所以访问 Object 迭代器时就直接留下了这些内存。

It's also possible to use intrusive containers when the objects to be stored can
have different or unknown size. This allows storing base and derived objects
in the same container, as shown in the following example: \n
当被保存的对象的大小未知或很难获知时，也可以使用介入式容器。
它允许将基类对象和派生类对象保存在同一个容器中，示范如下：

[import ../example/doc_window.cpp]
[doc_window_code]

Due to certain properties of intrusive containers 
they are often more difficult to use than their STL-counterparts. That's why you
should avoid them in public interfaces of libraries. Classes to be stored in intrusive
containers must change their implementation to store the hook and this is not always
possible or desirable.\n
由于介入式容器的特性，通常它们要比STL中的对应容器更难使用。所以你应该在库的公有接口中避免使用它们。
保存在介入式容器中的类必须修改其实现，以保存钩子，这并非总是可以或合理的。

[endsect]

[section:concepts_summary Concept summary 概念摘要]

Here is a small summary of the basic concepts that will be used in the following
chapters:\n
以下是对在后续章节中将要用到的一些基本概念的小结：

[variablelist Brief Concepts Summary 主要概念摘要
[[Node Algorithms 节点算法][A class containing typedefs and static functions that define 
   basic operations that can be applied to a group of nodes. It's independent
   from the node definition and configured using a NodeTraits template
   parameter that describes the node.\n
   一个包含了一些 typedef 和静态函数的类，定义了可应用于一组节点的一些基本操作。
   它独立于节点的定义，并且可以用一个描述该节点的 NodeTraits 模板参数来进行配置。]]
[[Node Traits 节点Traits ][A class that stores basic information and operations to insert a node into a group of nodes.\n
一个保存了基本信息和将节点插入到节点组中的操作的类。]]
[[Hook 钩子][A class that a user must add as a base class or as a member to make the user class compatible with intrusive containers.\n
一个类，用户必须将它作为基类或作为成员加入到用户类中，使得用户类兼容于介入式容器。]]
[[Intrusive Container 介入式容器][A class that stores user classes that have the needed hooks. It takes a ValueTraits template parameter as configuration information.\n
一个保存了具有所需钩子的用户类的类。它接受一个 ValueTraits 模板参数作为配置信息。]]
[[Semi-Intrusive Container 半介入式容器][Similar to an intrusive container but a semi-intrusive container needs additional memory (e.g. an auxiliary array) to work.\n
类似于介入式容器，但需要额外的内存(如一个辅助数组)才能工作。]]
[[Value Traits 值Traits][A class containing typedefs and operations to obtain the node to be used by Node Algorithms from the user class and the inverse.\n
一个类，包含了一些 typedef 和从用户类获得由节点算法使用的节点的操作，以及相反的操作。]]
]

[endsect]

[section:presenting_containers Presenting Boost.Intrusive containers 介绍 Boost.Intrusive 容器]

[*Boost.Intrusive] offers a wide range of intrusive containers:\n
[*Boost.Intrusive] 提供了大量的介入式容器：

*  [*slist]: An intrusive singly linked list. The size overhead is very small
   for user classes (usually the size of one pointer) but many operations have linear
   time complexity, so the user must be careful if he wants to avoid performance problems.\n
   [*slist]: 介入式的单链表。对于用户类的空间开销非常小(通常只有一个指针的大小)，
   但多数操作具有线性的时间复杂度，因此，如果用户想避免性能问题，就要小心使用。

*  [*list]: A `std::list` like intrusive linked list. The size overhead is quite
   small for user classes (usually the size of two pointers). Many operations have
   constant time complexity.\n
   [*list]: 一个类似于 `std::list` 的介入式链表。对于用户类的空间开销非常小(通常只有两个指针的大小)。
   多数操作具有线性的时间复杂度。

*  [*set/multiset/rbtree]: `std::set/std::multiset` like intrusive associative containers
   based on red-black trees.
   The size overhead is moderate for user classes (usually the size of three pointers).
   Many operations have logarithmic time complexity.\n
   [*set/multiset/rbtree]: 类似于 `std::set/std::multiset` 的介入式关联容器，基于红黑树。
   对于用户类的空间开销适中(通常为三个指针的大小)。多数操作具有对数时间复杂度。

*  [*avl_set/avl_multiset/avltree]: A `std::set/std::multiset` like intrusive associative
   containers based on AVL trees.
   The size overhead is moderate for user classes (usually the size of three pointers).
   Many operations have logarithmic time complexity.\n
   [*avl_set/avl_multiset/avltree]: 类似于 `std::set/std::multiset` 的介入式关联容器，基于 AVL 树。
   对于用户类的空间开销适中(通常为三个指针的大小)。多数操作具有对数时间复杂度。

*  [*splay_set/splay_multiset/splaytree]: `std::set/std::multiset` like intrusive associative
   containers based on splay trees. Splay trees have no constant operations, but they  
   have some interesting caching properties.
   The size overhead is moderate for user classes (usually the size of three pointers).
   Many operations have logarithmic time complexity.\n
   [*splay_set/splay_multiset/splaytree]: 类似于 `std::set/std::multiset` 的介入式关联容器，基于 splay 树。
   splay 树不具有常量性的操作，不过它有一些有趣的缓存特性。对于用户类的空间开销适中(通常为三个指针的大小)。
   多数操作具有对数时间复杂度。

*  [*sg_set/sg_multiset/sgtree]: A `std::set/std::multiset` like intrusive associative
   containers based on scapegoat trees. Scapegoat can be configured with the desired
   balance factor to achieve the desired rebalancing frequency/search time compromise.
   The size overhead is moderate for user classes (usually the size of three pointers).
   Many operations have logarithmic time complexity.\n
   [*sg_set/sg_multiset/sgtree]: 类似于 `std::set/std::multiset` 的介入式关联容器，基于 scapegoat 树。
   scapegoat 树可以按所期望的平衡因子来配置，以达到所希望的重新平衡频度和查找时间之间的折衷。
   对于用户类的空间开销适中(通常为三个指针的大小)。多数操作具有对数时间复杂度。

[*Boost.Intrusive] also offers semi-intrusive containers:\n
[*Boost.Intrusive] 还提供了半介入式容器：

*  [*unordered_set/unordered_multiset]: `std::tr1::unordered_set/std::tr1::unordered_multiset`
   like intrusive unordered associative containers.
   The size overhead is moderate for user classes (an average of two pointers per element).
   Many operations have amortized constant time complexity.\n
   [*unordered_set/unordered_multiset]: 类似于 `std::tr1::unordered_set/std::tr1::unordered_multiset`
   的介入式无序关联容器。对于用户类的空间开销适中(平均为每个元素两个指针)。多数操作具有分期常量时间复杂度。

Most of these intrusive containers can be configured with constant or linear time
size:\n
这些介入式容器中的多数可以被配置为带有常量时间复杂度或线性时间复杂度的 size 函数：

*  [*Linear time size]: The intrusive container doesn't hold a size member that is
updated with every insertion/erasure. This implies that the `size()` function doesn't have constant
time complexity. On the other hand, the container is smaller, and some operations, like
`splice()` taking a range of iterators in linked lists, have constant time complexity
instead of linear complexity.\n
[*线性时间的 size]: 此类介入式容器不存在一个在每次插入/删除时更新的 size 成员。这意味着 `size()` 函数不具有常量时间复杂度。
另一方面，容器可以更小，而且某些操作，如接受一个在链表中的迭代器区间的 `splice()`，则具有常量时间复杂度而不是线性复杂度。

*  [*Constant time size]: The intrusive container holds a size member that is updated
with every insertion/erasure. This implies that the `size()` function has constant time
complexity. On the other hand, increases the size of the container, and some operations,
like `splice()` taking a range of iterators, have linear time complexity in linked lists.\n
[*常量时间的 size]: 此类介入式容器保存了一个在每次插入/删除时更新的 size 成员。这意味着 `size()` 函数具有常量时间复杂度。
另一方面，这增加了容器的大小，而且某些操作，如接受一个在链表中的迭代器区间的 `splice()`，则具有线性复杂度。

To make user classes compatible with these intrusive containers [*Boost.Intrusive]
offers two types of hooks for each container type:\n
为了让用户类兼容于这些介入式容器，[*Boost.Intrusive] 为每种容器类型提供了两类钩子：

*  [*Base hook]: The hook is stored as a public base class of the user class.\n
   [*基类钩子]：钩子被保存为用户的一个公有基类。

*  [*Member hook]: The hook is stored as a public member of the user class.\n
   [*成员钩子]：钩子被保存为用户的一个公有成员。

Apart from that, [*Boost.Intrusive] offers additional features:\n
除此以外，[*Boost.Intrusive] 还提供了以下特性：

*  [*Safe mode hooks]: Hook constructor initializes the internal data to a well-known
   safe state and intrusive containers check that state before inserting a value in the
   container. When erasing an element from the container, the container puts the hook
   in the safe state again. This allows a safer use mode and it can be used to detect
   programming errors. It implies a slight performance overhead in some operations
   and can convert some constant time operations to linear time operations.\n
   [*安全模式钩子]：钩子的构造函数将内部数据初始化为一种可知的安全状态，介入式容器在插入一个值之前检查该状态。
   从容器中删除一个元素时，容器再次将钩子置回安全状态。这样就允许了一种安全的使用模式，它可以被用于检测程序的错误。
   它意味着某些操作会有轻微的性能开销，也可能将一些常量时间的操作变为线性时间。

*  [*Auto-unlink hooks]: The hook destructor removes the object from the container
   automatically and the user can safely unlink the object from the container without
   referring to the container.\n
   [*自断钩子]：钩子的析构函数自动将对象从容器中移除，用户无需知道容器就可以安全地将对象从容器断开。

*  [*Non-raw pointers]: If the user wants to use smart pointers instead of raw pointers, 
   [*Boost.Intrusive] hooks can
   be configured to use any type of pointer. This configuration information is also
   transmitted to the containers, so all the internal pointers used by intrusive containers
   configured with these hooks will be smart pointers. As an example,
   [*Boost.Interprocess] defines a smart pointer compatible with shared memory,
   called `offset_ptr`. [*Boost.Intrusive] can be configured to use this smart pointer
   to allow shared memory intrusive containers.\n
   [*非裸指针]：如果用户想用智能指针代替裸指针，[*Boost.Intrusive] 钩子可以被配置为使用任意类型的指针。
   这一配置信息也被转送到容器，所以以这些钩子进行配置的介入式容器所使用的所有内部指针都会是智能指针。
   例如，[*Boost.Interprocess] 定义了一个兼容于共享内存的智能指针，名为 `offset_ptr`。 [*Boost.Intrusive]
   可以被配置为使用此智能指针，就可以使用共享内存介入式容器。

[endsect]

[section:safe_hook Safe hooks 安全钩子]

[section:features Features of the safe mode 安全模式的特点]

[*Boost.Intrusive] hooks can be configured to operate in safe-link mode.
The safe mode is activated by default, but it can be also explicitly activated:\n
[*Boost.Intrusive] 钩子可以被配置为以安全链接模式操作。安全模式缺省是激活的，不过也可以明确激活：

[c++]

   //Configuring the safe mode explicitly
   //显式配置安全模式
   class Foo : public list_base_hook< link_mode<safe_link> >
   {};

With the safe mode the user can detect if the object
is actually inserted in a container without any external reference. Let's review the basic features of the safe mode:\n
通过使用安全模式，用户可以检测实际插入到容器中的对象是否没有任何外部引用。我们来复习一下安全模式的基本特点：

*  Hook's constructor puts the hook in a well-known default state.\n
   钩子的构造函数将钩子置于一个可知的缺省状态。

*  Hook's destructor checks if the hook is in the well-known default state. If not,
   an assertion is raised.\n
   钩子的析构函数检查钩子是否处于缺省状态。如否，则引发断言。

*  Every time an object is inserted in the intrusive container, the container
   checks if the hook is in the well-known default state. If not,
   an assertion is raised.\n
   每当有对象被插入到介入式容器中时，容器检查其钩子是否处于缺省状态。如否，则引发断言。

*  Every time an object is being erased from the intrusive container, the container
   puts the erased object in the well-known default state.\n
   每当从介入式容器移除对象时，容器将被移除对象重置回缺省状态。 

With these features, without any external reference the user can know if the object
has been inserted in a container by calling the `is_linked()` member function.
If the object is not actually inserted 
in a container, the hook is in the default state, and if it is inserted in a container, the
hook is not in the default state.\n
有了这些特性，无须任何外部引用，用户可以通过调用 `is_linked()` 成员函数就知道对象是否已被插入到某个容器中。
如果该对象未被实际插入到容器中，则其钩子处于缺省状态，如果它已被插入到容器中，则其钩子就处于非缺省状态。 

[endsect]

[section:configuring Configuring safe-mode assertions 配置安全模式的断言]

By default, all safe-mode assertions raised by [*Boost-Intrusive] hooks
and containers in are implemented using `BOOST_ASSERT`, which can be configured by
the user. See [@http://www.boost.org/libs/utility/assert.html] for more
information about `BOOST_ASSERT`.\n
缺省情况下，所有由 [*Boost-Intrusive] 钩子和容器引发的安全模式断言都是用 `BOOST_ASSERT` 实现的，
可以由用户配置。有关 `BOOST_ASSERT` 的更多信息请见 [@http://www.boost.org/libs/utility/assert.html]。 

`BOOST_ASSERT` is globally configured, so the user might
want to redefine intrusive safe-mode assertions without modifying the global
`BOOST_ASSERT`. This can be achieved redefining the following macros:\n
`BOOST_ASSERT` 是全局配置的，因此用户可能会想不修改全局的 `BOOST_ASSERT` 而重新定义介入式安全模式的断言。
这可以通过重定义以下宏来实现： 

*  `BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT`: This assertion will be
   used in insertion functions of the intrusive containers to check that
   the hook of the value to be inserted is default constructed.\n
   `BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT`: 该断言在介入式容器的插入函数中被用于检查插入值的钩子是否缺省构造。
*  `BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT`: This assertion will be
   used in hooks' destructors to check that the hook is in a default state.\n
   `BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT`: 该断言在钩子的析构函数中被用于检查钩子是否处于缺省状态。 

If any of these macros is not redefined, the assertion will default to `BOOST_ASSERT`.
If `BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT` or `BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT`
is defined and the programmer needs to include a file to configure that assertion, it can define
`BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT_INCLUDE` or `BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT_INCLUDE`
with the name of the file to include:\n
如果这两个宏的任何一个未重定义，则断言缺省为 `BOOST_ASSERT`。如果定义了 `BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT` 
或 `BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT` 且程序员需要包含一个文件来对断言进行配置，则可以定义带有该文件名的 
`BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT_INCLUDE` 或 `BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT_INCLUDE` 来包含：

[c++]

   #define BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT          MYASSERT
   #define BOOST_INTRUSIVE_SAFE_HOOK_DESTRUCTOR_ASSERT_INCLUDE <myassert.h>

[endsect]

[endsect]

[section:auto_unlink_hooks Auto-unlink hooks 自断钩子]

[section:auto_unlink_hooks_what What's an auto-unlink hook? 什么是自断钩子？]

[*Boost.Intrusive] offers additional hooks with unique features:\n
[*Boost.Intrusive] 提供了其它具有特色的钩子：

*  When the destructor of the hook is called, the hook checks if the node is inserted
   in a container. If so, the hook removes the node from the container.\n
   当钩子的析构函数被调用时，钩子会检查该节点是否已被插入到某个容器中。如果是，则钩子将节点从容器中移除。
*  The hook has a member function called `unlink()` that can be used to unlink the
   node from the container at any time, without having any reference to the container,
   if the user wants to do so.\n
   钩子具有一个名为 `unlink()` 的成员函数，它可用于随时将节点从容器移除，而无需具有到容器的引用，
   如果用户想这样做的话。

These hooks have exactly the same size overhead as their analog non auto-unlinking
hooks, but they have a restriction: they can only be used with
[link intrusive.presenting_containers non-constant time containers].
There is a reason for this: \n
这些钩子与非自断钩子具有完全相同的空间开销，但是它们有一个限制：它们只能用于 
[link intrusive.presenting_containers 非常量时间的容器]。这是因为：

* Auto-unlink hooks don't store any reference to the container where they are inserted.\n
  自断钩子并没有保存任何到它们所插入的容器的引用。
* Only containers with non constant-time `size()` allow removing an object from the container
  without referring to the container. \n
  只有带有非常量时间 `size()` 的容器允许无需知道容器就可以从容器中移除一个对象。

This auto-unlink feature is useful in certain applications
but it must be used [*very carefully]:\n
在特定的应用程序中，这个自断钩子特性是很有用的，但是必须[*非常小心地]使用

*  If several threads are using the same container the destructor of the auto-unlink
   hook will be called without any thread synchronization so removing the object is
   thread-unsafe.\n
   如果有多个线程使用同一个容器，由于自断钩子的析构函数被调用时没有线程同步，所以移除对象不是线程安全的。

*  Container contents change silently without modifying the container directly.
   This can lead to surprising effects.\n
   容器的内容会未经直接修改容器就悄然改变。这可能会导致令人惊讶的效果。

These auto-unlink hooks have also safe-mode properties:\n
这些自断钩子也有安全模式属性：

*  Hooks' constructors put the hook in a well-known default state.\n
   钩子的构造函数将钩子置于一个可知的缺省状态。

*  Every time an object is inserted in the intrusive container, the container
   checks if the hook is in the well-known default state. If not,
   an assertion is raised.\n
   每当有对象被插入到介入式容器中时，容器检查其钩子是否处于缺省状态。如否，则引发断言。

*  Every time an object is erased from an intrusive container, the container
   puts the erased object in the well-known default state.\n
   每当从介入式容器移除对象时，容器将被移除对象重置回缺省状态。

[endsect]

[section:auto_unlink_hooks_example Auto-unlink hook example 自断钩子的例子]

Let's see an example of an auto-unlink hook:\n
我们来看一个自断钩子的例子：

[import ../example/doc_auto_unlink.cpp]
[doc_auto_unlink_code]

[endsect]

[section:auto_unlink_and_constant_time Auto-unlink hooks and containers with constant-time `size()`\n
自断钩子与带有常量时间 `size()` 的容器]

As explained, [*Boost.Intrusive] auto-unlink hooks are incompatible with containers
that have constant-time `size()`, so if you try to define such container with an
auto-unlink hook's value_traits, you will get a static assertion:\n
如上所说，[*Boost.Intrusive] 自断钩子不能兼容于带有常量时间 `size()` 的容器，因此，
如果你想定义一个这样的容器并带有自断钩子 value_traits，你将得到一个静态断言：

[c++]
   
   #include <boost/intrusive/list.hpp>

   using boost::intrusive;

   struct MyTag;

   class MyClass : public list_base_hook< link_mode<auto_unlink> >
   {/**/};

   list <MyClass, constant_time_size<true> > bad_list;

   int main()
   {
      bad_list list;
      return 0;
   }

leads to an error similar to:\n
将引发一个如下的错误：

[pre
  error : use of undefined type 'boost::STATIC_ASSERTION_FAILURE<false>'
]

Pointing to code like this:\n
指向如下代码：

[c++]

   //Constant-time size is incompatible with auto-unlink hooks!
   //常量时间 size 不兼容于自断钩子！
   BOOST_STATIC_ASSERT(!(constant_time_size && ((int)value_traits::link_mode == (int)auto_unlink)));

This way, there is no way to compile a program if you try to use auto-unlink hooks
in constant-time size containers.\n
这样，如果你试图在一个带有常量时间 size 函数的容器中使用自断钩子，则无法编译程序。

[endsect]

[endsect]

[section:slist Intrusive singly linked list: slist 介入式单链表：slist]

[classref boost::intrusive::slist slist] is the simplest intrusive container of
[*Boost.Intrusive]: a singly linked list. The memory overhead
it imposes is 1 pointer per node. The size of an empty, non constant-time size 
[classref boost::intrusive::slist slist] is the size of 1 pointer. This
lightweight memory overhead comes with drawbacks, though: many operations have
linear time complexity, even some that usually are constant time, like
[classref boost::intrusive::slist::swap swap]. [classref boost::intrusive::slist slist]
only provides forward iterators.\n
[classref boost::intrusive::slist slist] 是最简单的 [*Boost.Intrusive] 介入式容器：单链表。
它所带来的内存开销是每节点一个指针。一个空的、不带常量时间 size 的 [classref boost::intrusive::slist slist]
的大小为一个指针。不过，这种轻量级的内存代价带来了一些缺点：很多操作具有线性时间复杂度，
但也有一些是常量时间的，如 [classref boost::intrusive::slist::swap swap]。
[classref boost::intrusive::slist slist] 只提供前向迭代器。

For most cases, a doubly linked list is preferable because it offers more
constant-time functions with a slightly bigger size overhead.
However, for some applications like
constructing more elaborate containers, singly linked lists are essential
because of their low size overhead.\n
多数情况下，双链表应是首选，因为它提供了更多的常量时间函数，只增加很少一点空间代价。
不过，对于一些应用，象构建一些更精细的容器，单链表由于其低空间开销的特点而成本基本要素。

[section:slist_hooks slist hooks 钩子]

Like the rest of [*Boost.Intrusive] containers,
[classref boost::intrusive::slist slist] has two hook types:\n
和其它 [*Boost.Intrusive] 容器一样，[classref boost::intrusive::slist slist] 有两种钩子：

[c++]

   template <class ...Options>
   class slist_base_hook;

*  [classref boost::intrusive::slist_base_hook slist_base_hook]:
   the user class derives publicly from
   [classref boost::intrusive::slist_base_hook slist_base_hook] to make
   it [classref boost::intrusive::slist slist]-compatible.\n
   [classref boost::intrusive::slist_base_hook slist_base_hook]: 用户类公有派生自 
   [classref boost::intrusive::slist_base_hook slist_base_hook] 以兼容于 [classref boost::intrusive::slist slist]。

[c++]

   template <class ...Options>
   class slist_member_hook;

*  [classref boost::intrusive::slist_member_hook slist_member_hook]:
   the user class contains a public 
   [classref boost::intrusive::slist_member_hook slist_member_hook] to make
   it [classref boost::intrusive::slist slist]-compatible.\n
   [classref boost::intrusive::slist_member_hook slist_member_hook]: 用户类包含一个公有的 
   [classref boost::intrusive::slist_member_hook slist_member_hook] 以兼容于 [classref boost::intrusive::slist slist]。 

[classref boost::intrusive::slist_base_hook slist_base_hook] and
[classref boost::intrusive::slist_member_hook slist_member_hook]
receive the same options explained in
the section [link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::slist_base_hook slist_base_hook] 和 
[classref boost::intrusive::slist_member_hook slist_member_hook] 接受相同的选项，
在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明： 

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one slist hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`.

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。缺省值：`link_mode<safe_link>`. 

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。
   缺省值：`void_pointer<void*>`. 

[endsect]

[section:slist_container slist container  slist 容器]

[c++]

   template <class T, class ...Options>
   class slist;

[classref boost::intrusive::slist slist] receives the options explained in
the section [link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::slist slist] 接受以下选项，具体解释在 
[link intrusive.usage 如何使用 Boost.Intrusive] 一节中： 

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container. (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。
   (要学习有关 value traits 的知识，请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器])。

*  [*`constant_time_size<bool Enabled>`]: To activate the constant-time `size()` operation.
   Default: `constant_time_size<true>`\n
   [*`constant_time_size<bool Enabled>`]: 激活常量时间的 `size()` 操作。缺省值：`constant_time_size<true>`

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`.\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`. 

[classref boost::intrusive::slist slist] can receive additional options:\n
[classref boost::intrusive::slist slist] 还可以接受其它选项：

*  [*`linear<bool Enable>`]: the singly linked list is implemented as a
   null-terminated list instead of a circular list. This allows `O(1)` swap,
   but losses some operations like `container_from_end_iterator`.\n
   [*`linear<bool Enable>`]: 将单链表实现为以 null 结尾的链表，而不是循环链表。
   这样可以进行 `O(1)` 的 swap，但就失去了一些如 `container_from_end_iterator` 的操作。
*  [*`cache_last<bool Enable>`]: the singly linked also stores a pointer to the
   last element of the singly linked list. This allows `O(1)` swap,
   `splice_after(iterator, slist &)` and makes the list offer new functions
   like `push_back(reference)` and `back()`. Logically, the size an empty list is
   increased in `sizeof(void_pointer)` and the the cached last node pointer must
   be updated in every operation, and that might incur in a slight performance impact.\n
   [*`cache_last<bool Enable>`]: 单链表保存一个指针指向链表的最后一个元素。这样可以进行 `O(1)` swap, 
   `splice_after(iterator, slist &)`，并可提供象 `push_back(reference)` 和 `back()` 这些新函数。
   逻辑上，空链表的大小要增加 `sizeof(void_pointer)`，且必须在每次操作中更新缓存的最后节点指针，
   这可能会导致轻微的性能影响。

`auto_unlink` hooks are not usable if `linear<true>` and/or `cache_last<true>` options are
used. If `auto_unlink` hooks are used and those options are specified, a static
assertion will be raised.\n
如果使用了 `linear<true>` 和/或 `cache_last<true>` 选项，则不能使用 `auto_unlink` 钩子。
如果使用了 `auto_unlink` 钩子并指定以上选项，将引发一个静态断言。

[endsect]

[section:slist_example Example 例子]

Now let's see a small example using both hooks:\n
现在我们来看一个使用两种钩子的小例子：

[import ../example/doc_slist.cpp]
[doc_slist_code]

[endsect]

[endsect]

[section:list Intrusive doubly linked list: list 介入式双链表：list]

[classref boost::intrusive::list list] is a doubly linked list. The memory overhead
it imposes is 2 pointers per node. An empty, non constant-time size [classref boost::intrusive::list list]
also has the size of 2 pointers. [classref boost::intrusive::list list]
has many more constant-time operations than [classref boost::intrusive::slist slist]
and provides a bidirectional iterator. It is recommended to use
[classref boost::intrusive::list list] instead of
[classref boost::intrusive::slist slist] if the size overhead is acceptable:\n
[classref boost::intrusive::list list] 是一个双链表。它所带来的内存开销是每节点2个指针。
一个空的、不带常量时间 size 的 [classref boost::intrusive::list list] 的大小为2个指针。
[classref boost::intrusive::list list] 具有比 [classref boost::intrusive::slist slist] 更多的常量时间操作，
且提供双向迭代器。如果空间代价可以接受，建议使用 [classref boost::intrusive::list list] 而不是 
[classref boost::intrusive::slist slist]。  

[section:list_hooks list hooks  list钩子]

Like the rest of [*Boost.Intrusive] containers,
[classref boost::intrusive::list list] has two hook types:\n
和其它 [*Boost.Intrusive] 容器一样，[classref boost::intrusive::list list] 有两种钩子：

[c++]

   template <class ...Options>
   class list_base_hook;

*  [classref boost::intrusive::list_base_hook list_base_hook]: the user class
   derives publicly from [classref boost::intrusive::list_base_hook list_base_hook]
   to make it [classref boost::intrusive::list list]-compatible.\n
   [classref boost::intrusive::list_base_hook list_base_hook]: 用户类公有派生自 
   [classref boost::intrusive::list_base_hook list_base_hook] 以兼容于 [classref boost::intrusive::list list]。 

[c++]

   template <class ...Options>
   class list_member_hook;

*  [classref boost::intrusive::list_member_hook list_member_hook]: 
   the user class contains a public 
   [classref boost::intrusive::list_member_hook list_member_hook] to make
   it [classref boost::intrusive::list list]-compatible.\n
   [classref boost::intrusive::list_member_hook list_member_hook]: 用户类公有派生自 
   [classref boost::intrusive::list_member_hook list_member_hook] 以兼容于 [classref boost::intrusive::list list]。 

[classref boost::intrusive::list_base_hook list_base_hook] and
[classref boost::intrusive::list_member_hook list_member_hook] receive
the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::list_base_hook list_base_hook] 和 [classref boost::intrusive::list_member_hook list_member_hook]
接受相同的选项，在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明：

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one list hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`.

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。缺省值：`link_mode<safe_link>`. 

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。
   缺省值：`void_pointer<void*>`.

[endsect]

[section:list_container list container  list容器]

[c++]

   template <class T, class ...Options>
   class list;

[classref boost::intrusive::list list] receives the same options explained in
the section [link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::list list] 接受以下选项，具体解释在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中：  

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container. (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。
   (要学习有关 value traits 的知识，请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器]) 

*  [*`constant_time_size<bool Enabled>`]: To activate the constant-time `size()` operation.
   Default: `constant_time_size<true>`\n
   [*`constant_time_size<bool Enabled>`]: 激活常量时间的 `size()` 操作。缺省值：`constant_time_size<true>`

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`.

[endsect]

[section:list_example Example 例子]

Now let's see a small example using both hooks:\n
现在我们来看一个使用两种钩子的小例子：

[import ../example/doc_list.cpp]
[doc_list_code]

[endsect]

[endsect]

[section:set_multiset Intrusive associative containers: set, multiset, rbtree 介入式关联容器：set, multiset, rbtree]

[*Boost.Intrusive] also offers associative containers that can be very useful
when creating more complex associative containers, like containers maintaining
one or more indices with different sorting semantics. Boost.Intrusive associative 
containers, like most STL associative container implementations are based on
red-black trees.\n
[*Boost.Intrusive] 也提供了关联容器，可用于创建更为复杂的关联容器，如维护一个或多个具有不同排序语义的索引的容器。
Boost.Intrusive 的关联容器与多数 STL 关联容器的实现一样，是基于红黑树的。 

The memory overhead of these containers is usually 3 pointers and a bit (with
alignment issues, this means 3 pointers and an integer).
This size can be reduced to 3 pointers if pointers have even alignment
(which is usually true in most systems).\n
此类容器的空间代价通常是3个指针多一点(由于对齐的问题，这相当于3个指针加1个整数)。
如果指针恰好是对齐的(在多数系统中通常都能满足)，那么这个大小可以减少为3个指针。

An empty, non constant-time size [classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset] or
[classref boost::intrusive::rbtree rbtree]
has also the size of 3 pointers and an integer (3 pointers when optimized for size).
These containers have logarithmic complexity in many
operations like
searches, insertions, erasures, etc. [classref boost::intrusive::set set] and
[classref boost::intrusive::multiset multiset] are the
intrusive equivalents of standard `std::set` and `std::multiset` containers.\n
一个空的、不带常量时间 size 的 [classref boost::intrusive::set set], [classref boost::intrusive::multiset multiset] 
或 [classref boost::intrusive::rbtree rbtree] 的大小为3个指针加1个整数(按空间优化时为3个指针)。
这些容器的多数操作具有对数时间复杂度，如查找、插入、删除等。[classref boost::intrusive::set set] 和 
[classref boost::intrusive::multiset multiset] 是标准的 `std::set` 和 `std::multiset` 容器的介入式等价物。 

[classref boost::intrusive::rbtree rbtree] is a superset of 
[classref boost::intrusive::set set] and
[classref boost::intrusive::multiset multiset] containers that offers
functions to insert unique and multiple keys.\n
[classref boost::intrusive::rbtree rbtree] 是 [classref boost::intrusive::set set] 和 
[classref boost::intrusive::multiset multiset] 容器的超集，提供了插入唯一和非唯一键值的函数。 

[section:set_multiset_hooks set, multiset and rbtree hooks  set, multiset 和 rbtree 钩子 ]

[classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset] and
[classref boost::intrusive::rbtree rbtree] share the same hooks.
This is an advantage, because the same
user type can be inserted first in a [classref boost::intrusive::multiset multiset]
and after that in [classref boost::intrusive::set set] without
changing the definition of the user class.\n
[classref boost::intrusive::set set], [classref boost::intrusive::multiset multiset] 和 
[classref boost::intrusive::rbtree rbtree] 共享相同的钩子。这是一个优点，因为同一个用户类型可以先被插入到 
[classref boost::intrusive::multiset multiset] 中，然后再插入到 [classref boost::intrusive::set set] 中，
而无需修改用户类的定义。

[c++]

   template <class ...Options>
   class set_base_hook;

*  [classref boost::intrusive::set_base_hook set_base_hook]:
   the user class derives publicly from
   [classref boost::intrusive::set_base_hook set_base_hook] to make
   it [classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset]-compatible.\n
   [classref boost::intrusive::set_base_hook set_base_hook]: 用户类公有派生自 
   [classref boost::intrusive::set_base_hook set_base_hook] 以兼容于 
   [classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset]。 

[c++]

   template <class ...Options>
   class set_member_hook;

*  [classref boost::intrusive::set_member_hook set_member_hook]:
   the user class contains a public
   [classref boost::intrusive::set_member_hook set_member_hook] to make
   it [classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset]-compatible.\n
   [classref boost::intrusive::set_member_hook set_member_hook]: 用户类包含一个公有的 
   [classref boost::intrusive::set_member_hook set_member_hook] 以兼容于 
   [classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset]。 

[classref boost::intrusive::set_base_hook set_base_hook] and
[classref boost::intrusive::set_member_hook set_member_hook] receive
the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive] plus a size optimization option:\n
[classref boost::intrusive::set_base_hook set_base_hook] 和 [classref boost::intrusive::set_member_hook set_member_hook] 
接受在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的各种选项，再加一个空间优化选项： 

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one base hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`. 

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。缺省值：`link_mode<safe_link>`. 

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。
   缺省值：`void_pointer<void*>`. 

*  [*`optimize_size<bool Enable>`]: The hook will be optimized for size
   instead of speed. The hook will embed the color bit of the red-black
   tree node in the parent pointer if pointer alignment is even.
   In some platforms, optimizing the size might reduce speed performance a bit
   since masking operations will be needed to access parent pointer and color attributes,
   in other platforms this option improves performance due to improved memory locality.
   Default: `optimize_size<false>`.\n
   [*`optimize_size<bool Enable>`]: 钩子将被按空间优化而非按时间优化。如果指针是恰好对齐的，
   则钩子将红黑树节点的颜色位嵌入到父指针中。空间优化会降低一点点速度，因为需要对父节点和颜色属性使用掩码操作。
   缺省值：`optimize_size<false>`. 

[endsect]

[section:set_multiset_containers set, multiset and rbtree containers  set, multiset 和 rbtree 容器]

[c++]

   template <class T, class ...Options>
   class set;

   template <class T, class ...Options>
   class multiset;

   template <class T, class ...Options>
   class rbtree;

These containers receive the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
这些容器接受在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的选项： 

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container. (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。
   (要学习有关 value traits 的知识，请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器])。

*  [*`constant_time_size<bool Enabled>`]: To activate the constant-time `size()` operation.
   Default: `constant_time_size<true>`\n
   [*`constant_time_size<bool Enabled>`]: 激活常量时间的 `size()` 操作。缺省值：`constant_time_size<true>` 

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`. 

And they also can receive an additional option:\n
它们还可以接受另一个选项： 

*  [*`compare<class Compare>`]: Comparison function for the objects to be inserted
   in containers. The comparison functor must induce a strict weak ordering.
   Default: `compare< std::less<T> >`\n
   [*`compare<class Compare>`]: 被插入到容器中的对象所用的比较函数。这个比较函数必须实现一个严格弱序。
   缺省值：`compare< std::less<T> >` 

[endsect]

[section:set_multiset_example Example  例子]

Now let's see a small example using both hooks and both containers:\n
现在我们来看一个使用这些钩子和容器的小例子：

[import ../example/doc_set.cpp]
[doc_set_code]

[endsect]

[endsect]

[section:unordered_set_unordered_multiset Semi-Intrusive unordered associative containers: unordered_set, unordered_multiset\n
介入式无序关联容器：unordered_set, unordered_multiset]

[*Boost.Intrusive] also offers hashed containers that can be very useful to implement
fast-lookup containers.  These containers
([classref boost::intrusive::unordered_set unordered_set] and [classref boost::intrusive::unordered_multiset unordered_multiset])
are semi-intrusive containers: they need additional memory apart from the hook
stored in the `value_type`. This additional
memory must be passed in the constructor of the container.\n
[*Boost.Intrusive] 也提供了散列容器，对于实现快速查找的容器非常有用。这些容器
([classref boost::intrusive::unordered_set unordered_set] 和 [classref boost::intrusive::unordered_multiset unordered_multiset])
是半介入式容器：除了保存在 `value_type` 中的内部钩子以外，它们还需要额外的内存。这些额外内存必须被传入至容器的构造函数。

Unlike C++ TR1 unordered associative containers (which are also hashed containers),
the contents of these semi-intrusive containers are not rehashed to maintain a
load factor: that would require memory management and intrusive containers don't
implement any memory management at all. However, the user can request an explicit
rehashing passing a new bucket array.
This also offers an additional guarantee over TR1 unordered associative containers:
[*iterators are not invalidated when inserting an element] in the container. \n
和 C++ TR1 无序关联容器(它们也是散列容器)不同，这些半介入式容器中的内容是不能重散列以维护负载因子的：
这样会需要内存管理，而介入式容器是不实现任何内存管理的。不过，用户可以传入一个新的桶数组来请求一次明确的重散列。
这种方式也比 TR1 无序关联容器多了一个保证：在容器中[*插入元素时不会导致迭代器失效]。 

As with TR1 unordered associative containers, rehashing invalidates iterators,
changes ordering between elements and changes which buckets elements appear in,
but does not invalidate pointers or references to elements. \n
和 TR1 无序关联容器一样，重散列会使得迭代器失效，改变元素间的顺序，改变元素所在的桶，
但不会导致元素的指针或引用失效。

Apart from expected hash and equality function objects, [*Boost.Intrusive] unordered
associative containers' constructors take an argument specifying an auxiliary
bucket vector to be used by the container.\n
除了所需的散列和相等性这两个函数对象以外，[*Boost.Intrusive] 无序关联容器的构造函数还要接受一个参数，
指定一个被容器使用的辅助桶 vector。

[section:unordered_set_unordered_multiset_performance unordered_set and unordered_multiset performance notes\n
unordered_set 和 unordered_multiset 的性能说明]

The size overhead for a hashed container is moderate: 1 pointer per value plus
a bucket array per container. The size of an element of the bucket array
is usually one pointer. To obtain a good performance hashed container,
the bucket length is usually the same as the number of elements that the
container contains, so a well-balanced hashed container (`bucket_count()` is 
equal to `size()` ) will have an equivalent overhead of two pointers per element.\n
散列容器的空间开销为中等：每个值1个指针，再加上每个容器一个桶数组。桶数组中每个元素的大小通常为1个指针。
要提供一个优越性能的散列容器，桶的长度通常要和容器中的元素数量相等，因此一个正常的散列容器(`bucket_count()` 
等于 `size()`)的空间开销相当于每个元素2个指针。

An empty, non constant-time size [classref boost::intrusive::unordered_set unordered_set] or
[classref boost::intrusive::unordered_multiset unordered_multiset]
has also the size of `bucket_count()` pointers. \n
一个空的、不带常量时间 size 的 [classref boost::intrusive::unordered_set unordered_set] 或 
[classref boost::intrusive::unordered_multiset unordered_multiset] 也具有 `bucket_count()` 个指针的大小。

Insertions, erasures, and searches, have amortized constant-time complexity in
hashed containers. However, some worst-case guarantees are linear. See
[classref boost::intrusive::unordered_set unordered_set] or
[classref boost::intrusive::unordered_multiset unordered_multiset] for complexity guarantees
of each operation.\n
散列容器的插入、删除和查找操作具有分期常量时间复杂度。但是，有些最坏情况的保证为线性复杂度。
各个操作的复杂度保证请见 [classref boost::intrusive::unordered_set unordered_set] 或 
[classref boost::intrusive::unordered_multiset unordered_multiset]。 

[*Be careful with non constant-time size hashed containers]: some operations, like
`empty()`, have linear complexity, unlike other [*Boost.Intrusive] containers.\n
[*留意不带常量时间 size 的散列容器]：有些操作，如 `empty()`，具有线性复杂度，这与其它 [*Boost.Intrusive] 容器不同。

[endsect]

[section:unordered_set_unordered_multiset_hooks unordered_set and unordered_multiset hooks\n
unordered_set 和 unordered_multiset 钩子]

[classref boost::intrusive::unordered_set unordered_set] and [classref boost::intrusive::unordered_multiset unordered_multiset] share the same hooks. This is an advantage, because the same
user type can be inserted first in a [classref boost::intrusive::unordered_multiset unordered_multiset] and after that in [classref boost::intrusive::unordered_set unordered_set] without
changing the definition of the user class.\n
[classref boost::intrusive::unordered_set unordered_set] 和 [classref boost::intrusive::unordered_multiset unordered_multiset] 
共享相同的钩子。这是一个优点，因为同一个用户类型可以先被插入到 [classref boost::intrusive::unordered_multiset unordered_multiset] 
中，然后再插入到 [classref boost::intrusive::unordered_set unordered_set] 中，而无需修改用户类的定义。

[c++]

   template <class ...Options>
   class unordered_set_base_hook;

*  [classref boost::intrusive::unordered_set_base_hook unordered_set_base_hook]:
   the user class derives publicly from
   [classref boost::intrusive::unordered_set_base_hook unordered_set_base_hook] to make
   it [classref boost::intrusive::unordered_set unordered_set]/[classref boost::intrusive::unordered_multiset unordered_multiset]-compatible.\n
   [classref boost::intrusive::unordered_set_base_hook unordered_set_base_hook]: 用户类公有派生自 
   [classref boost::intrusive::unordered_set_base_hook unordered_set_base_hook] 以兼容于 
[classref boost::intrusive::unordered_set unordered_set]/[classref boost::intrusive::unordered_multiset unordered_multiset]。 

[c++]

   template <class ...Options>
   class unordered_set_member_hook;

*  [classref boost::intrusive::unordered_set_member_hook unordered_set_member_hook]:
   the user class contains a public
   [classref boost::intrusive::unordered_set_member_hook unordered_set_member_hook] to make
   it [classref boost::intrusive::unordered_set unordered_set]/[classref boost::intrusive::unordered_multiset unordered_multiset]-compatible.\n
   [classref boost::intrusive::unordered_set_member_hook unordered_set_member_hook]: 用户类包含一个公有的 
   [classref boost::intrusive::unordered_set_member_hook unordered_set_member_hook] 以兼容于 
   [classref boost::intrusive::unordered_set unordered_set]/[classref boost::intrusive::unordered_multiset unordered_multiset]。 

[classref boost::intrusive::unordered_set_base_hook unordered_set_base_hook] and
[classref boost::intrusive::unordered_set_member_hook unordered_set_member_hook] receive
the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::unordered_set_base_hook unordered_set_base_hook] 和 
[classref boost::intrusive::unordered_set_member_hook unordered_set_member_hook] 接受在 
[link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的各种选项：  

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one base hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`. 

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。缺省值：`link_mode<safe_link>`. 

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。
   缺省值：`void_pointer<void*>`. 

Apart from them, these hooks offer additional options:\n
除此之外，这些钩子还提供了其它选项：

*  [*`store_hash<bool Enabled>`]: This option reserves additional space in
   the hook to store the hash value of the object once it's introduced in the
   container. When this option is used, the unordered container will store
   the calculated hash value in the hook and rehashing operations won't need
   to recalculate the hash of the value.
   This option will improve the performance of unordered containers when
   rehashing is frequent or hashing the value is a slow operation.
   Default: `store_hash<false>`.\n
   [*`store_hash<bool Enabled>`]: 这一选项在钩子中保留额外的空间，在对象被加入到容器中时保存它的散列值。
   使用该选项时，无序容器将已经计算过的散列值保存在钩子中，这样在进行重散列时就无需重新计算散列值。
   如果重散列频繁或散列值的计算较慢，则这一选项可以提高无序容器的性能。缺省值：`store_hash<false>`. 

*  [*`optimize_multikey<bool Enabled>`]: This option reserves additional space in
   the hook that will be used to group equal elements in unordered multisets,
   improving significantly the performance when many equal values are inserted
   in these containers. Default: `optimize_multikey<false>`.\n
   [*`optimize_multikey<bool Enabled>`]: 这一选项在钩子中保留额外的空间，用于将无序 multiset 中的相等元素聚在一起，
   当向容器中插入大量相等元素时，该选项可以显著改进性能。缺省值：`optimize_multikey<false>`.  

[endsect]

[section:unordered_set_unordered_multiset_containers unordered_set and unordered_multiset containers\n
unordered_set 和 unordered_multiset 容器]

[c++]

   template<class T, class ...Options>
   class unordered_set;

   template<class T, class ...Options>
   class unordered_multiset;

As mentioned, unordered containers need an auxiliary array to work. [*Boost.Intrusive]
unordered containers receive this auxiliary array packed in a type called `bucket_traits`
(which can be also customized by a container option). All unordered containers receive
a `bucket_traits` object in their constructors. The default `bucket_traits` class
is initialized with a pointer to an array of buckets and its size:\n
如上所述，无序容器需要一个辅助的数组来工作。[*Boost.Intrusive] 无序容器接受一个包装在 `bucket_traits`
(也可以由容器的选项来定制化)类型中的辅助数组。所有无序容器在它们的构造函数中接受一个 `bucket_traits` 对象。
缺省的 `bucket_traits` 类以一个桶数组指针及其大小来初始化：

[c++]

   #include <boost/intrusive/unordered_set.hpp>

   using namespace boost::intrusive;

   struct MyClass : public unordered_set_base_hook<>
   {};

   typedef unordered_set<MyClass>::bucket_type     bucket_type;
   typedef unordered_set<MyClass>::bucket_traits   bucket_traits;

   int main()
   {
      bucket_type buckets[100];
      unordered_set<MyClass> uset(bucket_traits(buckets, 100));
      return 0;
   }

Each hashed container needs [*its own bucket traits], that is, [*its own
bucket vector]. Two hashed containers
[*can't] share the same `bucket_type` elements. The bucket array [*must] be
destroyed [*after] the container using it is destroyed, otherwise, the result
is undefined.\n
散列容器需要[*它自己的桶 traits]，即是[*它自己的桶 vector]。两个散列容器[*不能]共享同一个 `bucket_type` 元素。
桶数组[*必须]在使用它的容器被销毁[*之后]销毁，否则，结果将是未定义的。 

[classref boost::intrusive::unordered_set unordered_set] and
[classref boost::intrusive::unordered_multiset unordered_multiset]
receive the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::unordered_set unordered_set] 和 [classref boost::intrusive::unordered_multiset unordered_multiset]
接受在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的选项： 

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container. (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。(要学习有关 value traits 的知识，
   请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器])。

*  [*`constant_time_size<bool Enabled>`]: To activate the constant-time `size()` operation.
   Default: `constant_time_size<true>`\n
   [*`constant_time_size<bool Enabled>`]: 激活常量时间的 `size()` 操作。缺省值：`constant_time_size<true>`

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`

And they also can receive additional options:\n
它们还可以接受其它选项： 

*  [*`equal<class Equal>`]: Equality function for the objects to be inserted
   in containers. Default: `equal< std::equal_to<T> >`\n
   [*`equal<class Equal>`]: 被插入到容器中的对象所用的相等性函数。缺省值：`equal< std::equal_to<T> >` 

*  [*`hash<class Hash>`]: Hash function to be used in the container.
   Default: `hash< boost::hash<T> >`\n
   [*`hash<class Hash>`]: 容器所用的散列函数。缺省值：`hash< boost::hash<T> >`

*  [*`bucket_traits<class BucketTraits>`]: A type that wraps the bucket vector to
   be used by the unordered container. Default: a type initialized by the address
   and size of a bucket array and stores both variables internally.\n
   [*`bucket_traits<class BucketTraits>`]: 无序容器所用的某个包装了桶 vector 的类型。
   缺省值：一个由桶数组的地址及大小进行初始化并在内部保存这两个变量的类型。

*  [*`power_2_buckets<bool Enabled>`]: The user guarantees that only bucket arrays
   with power of two length will be used. The container will then use masks instead of modulo
   operations to obtain the bucket number from the hash value. Masks are faster than
   modulo operations and for some applications modulo operations can impose
   a considerable overhead. In debug mode an assertion will be raised if the user
   provides a bucket length that is not power of two.
   Default: `power_2_buckets<false>`.\n
   [*`power_2_buckets<bool Enabled>`]: 用户保证只使用长度为2的幂数的桶数组。容器将使用掩码操作代替模操作来从散列值获得桶的数字。
   掩码操作比模操作更快，对于某些应用来说，模操作会带来显著的开销。在调试模式下，如果用户提供的桶的长度不是2的幂数，
   将引起一个断言。缺省值：`power_2_buckets<false>`. 

*  [*`cache_begin<bool Enabled>`]:
   [*Note: this option is not compatible with `auto_unlink` hooks].
   Due to its internal structure, finding the first
   element of an unordered container (`begin()` operation) is
   amortized constant-time. It's possible to speed up `begin()` and other operations
   related to it (like `clear()`) if the container caches internally the position
   of the first element. This imposes the overhead of one pointer to the size
   of the container. Default: `cache_begin<false>`.\n
   [*`cache_begin<bool Enabled>`]: [*注意：该选项与 `auto_unlink` 钩子相互不兼容]。
   由于内部结构的原因，查找无序容器的第一个元素(`begin()` 操作)是分期常量时间复杂度的。
   如果容器在内部对第一个元素的位置进行缓存，那么就可以提高 `begin()` 和其它相关操作(如 `clear()`)的速度。
   这意味着容器的大小要增加1个指针的开销。缺省值：`cache_begin<false>`. 

*  [*`compare_hash<bool Enabled>`]:
   [*Note: this option requires `store_hash<true>` option in the hook].
   When the comparison function is expensive,
   (e.g. strings with a long common predicate) sometimes (specially when the
   load factor is high or we have many equivalent elements in an
   [classref boost::intrusive::unordered_multiset unordered_multiset] and
   no `optimize_multikey<>` is activated in the hook)
   the equality function is a performance problem. Two equal values must have
   equal hashes, so comparing the hash values of two elements before using the
   comparison functor can speed up some implementations.\n
   [*`compare_hash<bool Enabled>`]: [*注意：本选项要求钩子中使用 `store_hash<true>` 选项]。
   如果比较函数开销较大(如带有常见谓词的字符串)，有时(尤其是负载因子较高或在 
   [classref boost::intrusive::unordered_multiset unordered_multiset] 中有很多相等元素且钩子中没有激活 
   `optimize_multikey<>` 的时候)相等性函数会存在性能的问题。两个相等的值必然具有相等的散列值，
   所以在使用比较函数对象之前先比较散列值可以加快某些实现的速度。

*  [*`incremental<bool Enabled>`]: Activates incremental hashing (also known as Linear Hashing).
   This option implies `power_2_buckets<true>` and the container will require power of two buckets.
   For more information on incremental hashing, see 
   [@http://en.wikipedia.org/wiki/Linear_hashing `Linear hash` on Wikipedia]
   Default: `incremental<false>`\n
   [*`incremental<bool Enabled>`]: 激活递增散列(又称线性散列)。该选项意味着 `power_2_buckets<true>` 
   以及该容器将要求桶数量为2的幂数。有关递增散列的更多信息，请见 
   [@http://en.wikipedia.org/wiki/Linear_hashing `Linear hash` on Wikipedia]。缺省值：`incremental<false>` 

[endsect]

[section:unordered_set_unordered_multiset_example Example 例子]

Now let's see a small example using both hooks and both containers:\n
现在我们来看一个使用这些钩子和容器的小例子：

[import ../example/doc_unordered_set.cpp]
[doc_unordered_set_code]

[endsect]

[section:custom_bucket_traits Custom bucket traits 定制化桶 traits]

Instead of using the default `bucket_traits` class to store the bucket array, a user
can define his own class to store the bucket array using the [*['bucket_traits<>]]
option. A user-defined bucket-traits must fulfill the following interface:\n
除了使用缺省的 `bucket_traits` 类来保存桶数组以外，用户也可以使用 [*['bucket_traits<>]] 选项来定义自己的类，
以保存桶数组。用户自定义的 bucket-traits 必须遵守以下接口：

[c++]

   class my_bucket_traits
   {
      bucket_ptr        bucket_begin();
      const_bucket_ptr  bucket_begin() const;
      std::size_t bucket_count() const;
   };


The following bucket traits just stores a pointer to the bucket
array but the size is a compile-time constant. Note the use of the auxiliary
[classref boost::intrusive::unordered_bucket unordered_bucket] and 
[classref boost::intrusive::unordered_bucket_ptr unordered_bucket_ptr]
utilities to obtain the type of the bucket and its pointer before defining
the unordered container:\n
以下的桶 traits 只保存一个桶数组的指针，而桶数组的大小是一个编译期常数。注意，在定义无序容器之前，使用辅助的 
[classref boost::intrusive::unordered_bucket unordered_bucket] 和 
[classref boost::intrusive::unordered_bucket_ptr unordered_bucket_ptr] 工具可以得到桶的类型及其指针：

[import ../example/doc_bucket_traits.cpp]
[doc_bucket_traits]

[endsect]

[endsect]

[section:splay_set_multiset Intrusive splay tree based associative containers: splay_set, splay_multiset and , splay_tree\n
基于 splay 树的介入式关联容器：splay_set, splay_multiset 和 splay_tree]

C++ associative containers are usually based on red-black tree implementations (e.g.: STL,
Boost.Intrusive associative containers). However, there are other interesting data
structures that offer some advantages (and also disadvantages).\n
C++关联容器通常都是基于红黑树来实现的(如：STL, Boost.Intrusive 关联容器)。但是，
还有其它的有趣的数据结构可以提供一些优点(也有缺点)。

Splay trees are self-adjusting binary search trees used typically in caches, memory
allocators and other applications, because splay trees have a "caching effect": recently
accessed elements have better access times than elements accessed less frequently.
For more information on splay trees see [@http://en.wikipedia.org/wiki/Splay_tree Wikipedia entry].\n
Splay 树是一种自调整的二分查找树，通常用于缓存、内存分配器和其它应用程序，因为 splay 树具有一种 "缓存效果"：
最近访问的元素比较少访问的元素具有更好的访问时间。有关 splay 树的更多信息，请见 
[@http://en.wikipedia.org/wiki/Splay_tree Wikipedia 相关条目]。

[*Boost.Intrusive] offers 3 containers based on splay trees:
[classref boost::intrusive::splay_set splay_set],
[classref boost::intrusive::splay_multiset splay_multiset] and
[classref boost::intrusive::splaytree splaytree]. The first two are similar to
[classref boost::intrusive::set set] or
[classref boost::intrusive::multiset multiset] and the latter is a generalization
that offers functions both to insert unique and multiple keys.\n
[*Boost.Intrusive] 提供了3种基于 splay 树的容器：[classref boost::intrusive::splay_set splay_set],
[classref boost::intrusive::splay_multiset splay_multiset] 和 [classref boost::intrusive::splaytree splaytree]。
前两种类似于 [classref boost::intrusive::set set] 或 [classref boost::intrusive::multiset multiset]，
而最后一种则是一个提供了插入唯一键和重复键功能的泛型。

The memory overhead of these containers with Boost.Intrusive hooks is usually 3 pointers.
An empty, non constant-time size splay container has also a size of 3 pointers.\n
这些带有 Boost.Intrusive 钩子的容器的空间开销通常为3个指针。一个空的、不带常量时间 size 的 splay 容器也具有3个指针的大小。

[section:splay_set_multiset_disadvantages Advantages and disadvantages of splay tree based containers 基于splay树的容器的优缺点]

Splay tree based intrusive containers have logarithmic complexity in many
operations like searches, insertions, erasures, etc., but if some elements are
more frequently accessed than others, splay trees perform faster searches than equivalent
balanced binary trees (such as red-black trees).\n
基于 Splay 树的介入式容器的多数操作具有对数复杂度，如查找、插入、删除等等，
但是如果有些元素比较其它元素的使用更为频繁，那么 splay 树可以提供比同等的平衡二叉树(如红黑树)更快的查找速度。

The caching effect offered by splay trees comes with a cost: the tree must be
rebalanced when an element is searched. This disallows const versions of search
functions like `find()`, `lower_bound()`, `upper_bound()`, `equal_range()`,
`count()`, etc.\n
splay 树所提供的缓存效果是有代价的：在查找元素时，该树必须被重新平衡。这样就禁止了查找函数的常量版本，
如 `find()`, `lower_bound()`, `upper_bound()`, `equal_range()`, `count()` 等等。 

Because of this, splay-tree based associative containers are not drop-in
replacements of [classref boost::intrusive::set set]/
[classref boost::intrusive::multiset multiset].\n
因此，基于 splay 树的关联容器不能替代 [classref boost::intrusive::set set]/
[classref boost::intrusive::multiset multiset]。

Apart from this, if element searches are randomized, the tree will be rebalanced
without taking advantage of the cache effect, so splay trees can offer worse
performance than other balanced trees for some search patterns.\n
除此之外，如果元素的查找是随机的，那么该树既要进行重新平衡，又得不到缓存效果的好处，
所以 splay 树对于这种查找模式将提供比其它平衡树更差的性能。

[endsect]

[section:splay_set_multiset_hooks splay_set, splay_multiset and splaytree hooks\n
splay_set, splay_multiset 和 splaytree 钩子]

[classref boost::intrusive::splay_set splay_set],
[classref boost::intrusive::splay_multiset splay_multiset] and
[classref boost::intrusive::splaytree splaytree]
share the same hooks.\n
[classref boost::intrusive::splay_set splay_set], [classref boost::intrusive::splay_multiset splay_multiset] 
和 [classref boost::intrusive::splaytree splaytree] 共享相同的钩子。

[c++]

   template <class ...Options>
   class splay_set_base_hook;

*  [classref boost::intrusive::splay_set_base_hook splay_set_base_hook]:
   the user class derives publicly from this class to make
   it compatible with splay tree based containers.\n
   [classref boost::intrusive::splay_set_base_hook splay_set_base_hook]: 用户类公有派生自此类以兼容于基于 splay 树的容器。

[c++]

   template <class ...Options>
   class splay_set_member_hook;

*  [classref boost::intrusive::set_member_hook set_member_hook]:
   the user class contains a public member of this class to make
   it compatible with splay tree based containers.\n
   [classref boost::intrusive::set_member_hook set_member_hook]: 用户类包含一个此类的公有成员以兼容于基于 splay 树的容器。

[classref boost::intrusive::splay_set_base_hook splay_set_base_hook] and
[classref boost::intrusive::splay_set_member_hook splay_set_member_hook] receive
the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::splay_set_base_hook splay_set_base_hook] 和 
[classref boost::intrusive::splay_set_member_hook splay_set_member_hook] 接受在 
[link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的各种选项：

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one base hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`. 

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。缺省值：`link_mode<safe_link>`. 

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。缺省值：`void_pointer<void*>`.

[endsect]

[section:set_multiset_containers splay_set, splay_multiset and splaytree containers\n
splay_set, splay_multiset 和 splaytree 容器]

[c++]

   template <class T, class ...Options>
   class splay_set;

   template <class T, class ...Options>
   class splay_multiset;

   template <class T, class ...Options>
   class splaytree;

These containers receive the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
这些容器接受在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的选项：

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container.  (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。
   (要学习有关 value traits 的知识，请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器])。 

*  [*`constant_time_size<bool Enabled>`]: To activate the constant-time `size()` operation.
   Default: `constant_time_size<true>`\n
   [*`constant_time_size<bool Enabled>`]: 激活常量时间的 size() 操作。缺省值：`constant_time_size<true>`

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`

And they also can receive an additional option:\n
它们还可以接受其它选项：

*  [*`compare<class Compare>`]: Comparison function for the objects to be inserted
   in containers. The comparison functor must induce a strict weak ordering.
   Default: `compare< std::less<T> >`\n
   [*`compare<class Compare>`]: 被插入到容器中的对象所用的比较函数。这个比较函数必须实现一个严格弱序。
   缺省值：`compare< std::less<T> >`

[endsect]

[section:splay_set_bst_hook Splay trees with BST hooks 带有BST钩子的splay树 ]

Intrusive splay containers can also use plain binary search tree hooks
[classref boost::intrusive::bs_set_base_hook bs_set_base_hook] and
[classref boost::intrusive::bs_set_base_hook bs_set_base_hook].
These hooks can be used by other intrusive containers like
intrusive scapegoat containers
[classref boost::intrusive::sg_set sg_set] and
[classref boost::intrusive::sg_multiset sg_multiset]. A programmer
might prefer using a binary search tree hook so that the same type
can be inserted in some situations in a splay container but
also inserted in other compatible containers when
the hook is not being used in a splay container.\n
介入式 splay 容器也可以使用普通的二分查找树钩子 [classref boost::intrusive::bs_set_base_hook bs_set_base_hook] 
和 [classref boost::intrusive::bs_set_base_hook bs_set_member_hook]。这些钩子可以被其它介入式容器使用，
如介入式 scapegoat 容器 [classref boost::intrusive::sg_set sg_set] 和 [classref boost::intrusive::sg_multiset sg_multiset]。
程序员可能更喜欢使用二分查找树钩子，这样同一个类型可以在某些情况下插入到 splay 容器中，
当这些钩子不是在 splay 容器中使用时，也可以插入到其它兼容的容器中。 

[classref boost::intrusive::bs_set_base_hook bs_set_base_hook] and
[classref boost::intrusive::bs_set_base_hook bs_set_member_hook] admit
the same options as [classref boost::intrusive::splay_set_base_hook splay_set_base_hook].\n
[classref boost::intrusive::bs_set_base_hook bs_set_base_hook] 和 
[classref boost::intrusive::bs_set_base_hook bs_set_member_hook] 接受与 
[classref boost::intrusive::splay_set_base_hook splay_set_base_hook] 相同的选项。

[endsect]

[section:splay_set_multiset_example Example 例子]

Now let's see a small example using both splay hooks,
binary search tree hooks and
[classref boost::intrusive::splay_set splay_set]/
[classref boost::intrusive::splay_multiset splay_multiset]
containers:\n
现在我们来看一个使用 splay 钩子、二分查找树钩子和 [classref boost::intrusive::splay_set splay_set]/
[classref boost::intrusive::splay_multiset splay_multiset] 容器的小例子：

[import ../example/doc_splay_set.cpp]
[doc_splay_set_code]

[endsect]

[endsect]

[section:avl_set_multiset Intrusive avl tree based associative containers: avl_set, avl_multiset and avltree\n
基于 avl 树的介入式关联容器：avl_set, avl_multiset 和 avltree]

Similar to red-black trees, AVL trees are balanced binary trees. 
AVL trees are often compared with red-black trees because they support the same set of operations
and because both take O(log n) time for basic operations. 
AVL trees are more rigidly balanced than Red-Black trees, leading to slower insertion and
removal but faster retrieval, so AVL trees perform better
than red-black trees for lookup-intensive applications. \n
和红黑树相似，AVL 树也是一种平衡二叉树。AVL 树通常会与红黑树相比较，因为它们都支持相同的操作集，
且对于基本操作都具有 O(log n) 的时间复杂度。AVL 树比红黑树更为严格地平衡，这导致了更慢的插入和删除操作，
但取出操作则要快一点，所以对于查找操作较多的应用来说，AVL 树要比红黑树表现得好一些。

[*Boost.Intrusive] offers 3 containers based on avl trees:
[classref boost::intrusive::avl_set avl_set],
[classref boost::intrusive::avl_multiset avl_multiset] and
[classref boost::intrusive::avltree avltree]. The first two are similar to
[classref boost::intrusive::set set] or
[classref boost::intrusive::multiset multiset] and the latter is a generalization
that offers functions both to insert unique and multiple keys.\n
[*Boost.Intrusive] 提供了3种基于 splay 树的容器：[classref boost::intrusive::avl_set avl_set],
[classref boost::intrusive::avl_multiset avl_multiset] 和 [classref boost::intrusive::avltree avltree]。
前两种类似于 [classref boost::intrusive::set set] 或 [classref boost::intrusive::multiset multiset]，
而最后一种则是一个提供了插入唯一键和重复键功能的泛型。 

The memory overhead of these containers with Boost.Intrusive hooks is usually 3
pointers and 2 bits (due to alignment, this usually means 3 pointers plus an integer).
This size can be reduced to 3 pointers if pointers have 4 byte alignment
(which is usually true in 32 bit systems).\n
这些带有 Boost.Intrusive 钩子的容器的空间开销通常为3个指针加2个bits(由于要对齐，通常是3个指针加1个整数)。
如果指针是4字节对齐的(在32位系统上通常都是如此)，则大小被压缩为3个指针。

An empty, non constant-time size [classref boost::intrusive::avl_set avl_set],
[classref boost::intrusive::avl_multiset avl_multiset] or
[classref boost::intrusive::avltree avltree]
also has a size of 3 pointers and an integer (3 pointers when optimized for size).\n
一个空的、不带常量时间 size 的 [classref boost::intrusive::avl_set avl_set],
[classref boost::intrusive::avl_multiset avl_multiset] 或 [classref boost::intrusive::avltree avltree]
容器也具有3个指针加1个整数的大小(当按空间优化时为3个指针)。

[section:avl_set_multiset_hooks avl_set, avl_multiset and avltree hooks\n
avl_set, avl_multiset 和 avltree 钩子]

[classref boost::intrusive::avl_set avl_set],
[classref boost::intrusive::avl_multiset avl_multiset] and
[classref boost::intrusive::avltree avltree]
share the same hooks.\n
[classref boost::intrusive::avl_set avl_set], [classref boost::intrusive::avl_multiset avl_multiset] 
和 [classref boost::intrusive::avltree avltree] 共享相同的钩子。

[c++]

   template <class ...Options>
   class avl_set_base_hook;

*  [classref boost::intrusive::avl_set_base_hook avl_set_base_hook]:
   the user class derives publicly from this class to make
   it compatible with avl tree based containers.\n
   [classref boost::intrusive::avl_set_base_hook avl_set_base_hook]: 用户类公有派生自此类以兼容于基于 avl 树的容器。

[c++]

   template <class ...Options>
   class avl_set_member_hook;

*  [classref boost::intrusive::set_member_hook set_member_hook]:
   the user class contains a public member of this class to make
   it compatible with avl tree based containers.\n
   [classref boost::intrusive::set_member_hook set_member_hook]: 用户类包含一个此类的公有成员以兼容于基于 avl 树的容器。

[classref boost::intrusive::avl_set_base_hook avl_set_base_hook] and
[classref boost::intrusive::avl_set_member_hook avl_set_member_hook] receive
the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive] plus an option to optimize
the size of the node:\n
[classref boost::intrusive::avl_set_base_hook avl_set_base_hook] 和
[classref boost::intrusive::avl_set_member_hook avl_set_member_hook] 接受在 
[link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的各种选项，外加一个优化节点大小的选项：

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one base hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`. 

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。缺省值：`link_mode<safe_link>`.

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。缺省值：`void_pointer<void*>`.

*  [*`optimize_size<bool Enable>`]: The hook will be optimized for size
   instead of speed. The hook will embed the balance bits of the AVL
   tree node in the parent pointer if pointer alignment is multiple of 4.
   In some platforms, optimizing the size might reduce speed performance a bit
   since masking operations will be needed to access parent pointer and balance factor attributes,
   in other platforms this option improves performance due to improved memory locality.
   Default: `optimize_size<false>`.\n
   [*`optimize_size<bool Enable>`]: 钩子将被按空间优化而不是按速度优化。如果指针是按4的倍数对齐的，
   钩子会将 AVL 树的平衡位嵌入到父节点中。空间优化会稍微降低速度性能，
   因为访问父节点和平衡因子属性的时候需要进行掩码操作。缺省值：`optimize_size<false>`.

[endsect]

[section:set_multiset_containers avl_set, avl_multiset and avltree containers\n
avl_set, avl_multiset 和 avltree 容器]

[c++]

   template <class T, class ...Options>
   class avl_set;

   template <class T, class ...Options>
   class avl_multiset;

   template <class T, class ...Options>
   class avltree;

These containers receive the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
这些容器接受在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的选项：

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container. (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。(要学习有关 value traits 的知识，
   请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器])。 

*  [*`constant_time_size<bool Enabled>`]: To activate the constant-time `size()` operation.
   Default: `constant_time_size<true>`\n
   [*`constant_time_size<bool Enabled>`]: 激活常量时间的 size() 操作。缺省值：`constant_time_size<true>`

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`

And they also can receive an additional option:\n
它们还可以接受其它选项：

*  [*`compare<class Compare>`]: Comparison function for the objects to be inserted
   in containers. The comparison functor must induce a strict weak ordering.
   Default: `compare< std::less<T> >`\n
   [*`compare<class Compare>`]: 被插入到容器中的对象所用的比较函数。这个比较函数必须实现一个严格弱序。
   缺省值：`compare< std::less<T> >`

[endsect]

[section:avl_set_multiset_example Example 例子]

Now let's see a small example using both hooks and
[classref boost::intrusive::avl_set avl_set]/
[classref boost::intrusive::avl_multiset avl_multiset]
containers:\n
现在我们来看一个使用钩和 [classref boost::intrusive::avl_set avl_set]/
[classref boost::intrusive::avl_multiset avl_multiset] 容器的小例子：

[import ../example/doc_avl_set.cpp]
[doc_avl_set_code]

[endsect]

[endsect]


[section:sg_set_multiset Intrusive scapegoat tree based associative containers: sg_set, sg_multiset and sgtree\n
基于替罪羊树的介入式关联容器：sg_set, sg_multiset 和 sgtree]

A scapegoat tree is a self-balancing binary search tree, that provides worst-case O(log n)
lookup time, and O(log n) amortized insertion and deletion time.
Unlike other self-balancing binary search trees that provide worst case O(log n) lookup
time, scapegoat trees have no additional per-node overhead compared to a regular binary
search tree.\n
替罪羊树是一种自平衡的二分查找树，它提供了最坏情况下的 O(log n) 查找时间，以及 O(log n) 的分期插入和删除时间。
和其它的提供了最坏情况 O(log n) 查找时间的自平衡二分查找树不同，替罪羊树与普通的二分查找树相比，
并没有对每个节点增加额外的开销。

A binary search tree is said to be weight balanced if half the nodes are on the left
of the root, and half on the right. An a-height-balanced tree is defined with defined
with the following equation:\n
一个二分查找树被称为是重量平衡的，如果它的一半节点在根的左边，另一半节点在根的右边。
而一个a高度平衡的树则由以下公式定义：

[*['height(tree) <= log1/a(tree.size())]]

*  [*['a == 1]]: A tree forming a linked list is considered balanced.
   [*['a == 1]]: 一棵形成一个链表的树被认为是平衡的。
*  [*['a == 0.5]]: Only a perfectly balanced binary is considered balanced.
   [*['a == 0.5]]: 只有一棵完美的平衡二叉树才被认为是平衡的。

Scapegoat trees are loosely ['a-height-balanced] so:\n
替罪羊树是非严格的 ['a高度平衡]，因此：

[*['height(tree) <= log1/a(tree.size()) + 1]]

Scapegoat trees support any a between 0.5 and 1. If a is higher, the tree is rebalanced
less often, obtaining quicker insertions but slower searches. Lower
a values improve search times. Scapegoat-trees implemented in [*Boost.Intrusive] offer the possibility of
[*changing a at run-time] taking advantage of the flexibility of scapegoat trees.
For more information on scapegoat trees see [@http://en.wikipedia.org/wiki/Scapegoat_tree Wikipedia entry].\n
替罪羊树支持位于 0.5 到 1 之间的任意 a。如果 a 较高，则树会较少被重新平衡，插入较快但查找较慢。
较低的值则提高查找的速度。在 [*Boost.Intrusive] 中实现的替罪羊树提供了[*在运行期改变 a 值]的可能性，
利用了替罪羊树的灵活性。有关替罪羊树的更多信息，请见 [@http://en.wikipedia.org/wiki/Scapegoat_tree Wikipedia 的相关条目]。 

Scapegoat trees also have downsides:\n
替罪羊树也具有弱点：

*  They need additional storage of data on the
   root (the size of the tree, for example) to achieve logarithmic complexity operations
   so it's not possible to offer `auto_unlink` hooks. The size of an empty scapegoat
   tree is also considerably increased.\n
   它需要在根上的额外数据存储(例如，树的大小)，以实现对数复杂度的操作，因此它不能提供 `auto_unlink` 钩子。
   一个空的替罪羊树的大小也有显著增加。

*  The operations needed to determine if the tree is unbalanced require floating-point
   operations like ['log1/a]. If the system has no floating point operations (like some
   embedded systems), scapegoat tree operations might become slow.\n
   需要判断树是否不平衡的操作要求浮点运算，如 ['log1/a]。如果系统不提供浮点运算(如某些嵌入式系统)，
   替罪羊树的操作可能会变慢。

[*Boost.Intrusive] offers 3 containers based on scapegoat trees:
[classref boost::intrusive::sg_set sg_set],
[classref boost::intrusive::sg_multiset sg_multiset] and
[classref boost::intrusive::sgtree sgtree]. The first two are similar to
[classref boost::intrusive::set set] or
[classref boost::intrusive::multiset multiset] and the latter is a generalization
that offers functions both to insert unique and multiple keys.\n
[*Boost.Intrusive] 提供了3种基于 splay 树的容器：[classref boost::intrusive::sg_set sg_set],
[classref boost::intrusive::sg_multiset sg_multiset] 和 [classref boost::intrusive::sgtree sgtree]。
前两种类似于 [classref boost::intrusive::set set] 或 [classref boost::intrusive::multiset multiset]，
而最后一种则是一个提供了插入唯一键和重复键功能的泛型。

The memory overhead of these containers with Boost.Intrusive hooks is 3
pointers.\n
这些带有 Boost.Intrusive 钩子的容器的空间开销通常为3个指针。

An empty, [classref boost::intrusive::sg_set sg_set],
[classref boost::intrusive::sg_multiset sg_multiset] or
[classref boost::intrusive::sgtree sgtree]
has also the size of 3 pointers, two integers and two floating point values
(equivalent to the size of 7 pointers on most systems).\n
一个空的 [classref boost::intrusive::sg_set sg_set], [classref boost::intrusive::sg_multiset sg_multiset] 或 
[classref boost::intrusive::sgtree sgtree] 也具有3个指针、2个整数和2个浮点值的大小(在多数系统上相当于7个指针的大小)。

[section:sg_set_multiset_hooks Using binary search tree hooks: bs_set_base_hook and bs_set_member_hook\n
使用二分查找树钩子：bs_set_base_hook 和 bs_set_member_hook]

[classref boost::intrusive::sg_set sg_set],
[classref boost::intrusive::sg_multiset sg_multiset] and
[classref boost::intrusive::sgtree sgtree] don't use their
own hooks but plain binary search tree hooks. This has many advantages
since binary search tree hooks can also be used to insert values in
splay and treap containers.\n
[classref boost::intrusive::sg_set sg_set], [classref boost::intrusive::sg_multiset sg_multiset] 和
[classref boost::intrusive::sgtree sgtree] 不使用它们自己的钩子，而是使用普通的二分查找树钩子。
这有许多优点，因为二分查找树钩子还可以用于将值插入到 splay 容器中。

[c++]

   template <class ...Options>
   class bs_set_base_hook;

*  [classref boost::intrusive::bs_set_base_hook bs_set_base_hook]:
   the user class derives publicly from this class to make
   it compatible with scapegoat tree based containers.\n
   [classref boost::intrusive::bs_set_base_hook bs_set_base_hook]: 用户类公有派生自本类以兼容于基于替罪羊树的容器。

[c++]

   template <class ...Options>
   class bs_set_member_hook;

*  [classref boost::intrusive::set_member_hook set_member_hook]:
   the user class contains a public member of this class to make
   it compatible with scapegoat tree based containers.\n
   [classref boost::intrusive::set_member_hook set_member_hook]: 用户类包含一个本类的公有成员以兼容于基于替罪羊树的容器。

[classref boost::intrusive::bs_set_base_hook bs_set_base_hook] and
[classref boost::intrusive::bs_set_member_hook bs_set_member_hook] receive
the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::bs_set_base_hook bs_set_base_hook] 和 
[classref boost::intrusive::bs_set_member_hook bs_set_member_hook] 接受在 
[link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的各种选项：

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one base hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`.

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。缺省值：`link_mode<safe_link>`.

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。
   缺省值：`void_pointer<void*>`.

[endsect]

[section:sg_set_multiset_containers sg_set, sg_multiset and sgtree containers\n
sg_set, sg_multiset 和 sgtree 容器]

[c++]

   template <class T, class ...Options>
   class sg_set;

   template <class T, class ...Options>
   class sg_multiset;

   template <class T, class ...Options>
   class sgtree;

These containers receive the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
这些容器接受在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的选项：

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container. (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。(要学习有关 value traits 的知识，
   请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器])。

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`

And they also can receive additional options:\n
它们还可以接受其它的选项：

*  [*`compare<class Compare>`]: Comparison function for the objects to be inserted
   in containers. The comparison functor must induce a strict weak ordering.
   Default: `compare< std::less<T> >`\n
   [*`compare<class Compare>`]: 被插入到容器中的对象所用的比较函数。这个比较函数必须实现一个严格弱序。
   缺省值：`compare< std::less<T> >`

*  [*`floating_point<bool Enable>`]: 
   When this option is deactivated, the scapegoat tree loses the ability to change
   the balance factor a at run-time, but the size of an empty container is reduced
   and no floating point operations are performed, normally increasing container
   performance. The fixed a factor that is used when this option is activated
   is ['1/sqrt(2) ~ 0,70711]. Default: `floating_point<true>`\n
   [*`floating_point<bool Enable>`]: 当这一选项被去激活时，替罪羊树将失去在运行期改变平衡因子的能力，
   但空容器的大小将会减少，并且不再执行浮点运算，通常会提高容器的性能。
   当该选项被激活时使用的因子为 ['1/sqrt(2) ~ 0,70711]。缺省值：`floating_point<true>`

[endsect]

[section:sg_set_multiset_example Example 例子]

Now let's see a small example using both hooks and
[classref boost::intrusive::sg_set sg_set]/
[classref boost::intrusive::sg_multiset sg_multiset]
containers:\n
现在我们来看一个使用这些钩子和 [classref boost::intrusive::sg_set sg_set]/
[classref boost::intrusive::sg_multiset sg_multiset] 容器的小例子：

[import ../example/doc_sg_set.cpp]
[doc_sg_set_code]

[endsect]

[endsect]


[section:treap_set_multiset Intrusive treap based associative containers: treap_set, treap_multiset and treap\n
基于treap的介入式关联容器：treap_set, treap_multiset 和 treap]

The name ['treap] is a mixture of ['tree] and ['heap] indicating that Treaps exhibit the properties of both
binary search trees and heaps. A treap is a binary search tree that orders the nodes
by a key but also by a priority attribute. The nodes are ordered so that the keys form a binary search tree and
the priorities obey the max heap order property. \n
名称 ['treap] 是 ['tree] 和 ['heap] 的混合，可见treap同时具有二叉树和堆的特点。treap是这样的一棵二叉树，
其节点既要按键值排序，也要按优先级排序。因为节点是有序的，所以其键值形成一个二叉树，而优先级则满足最大堆的顺序属性。 

* If v is a left descendant of u, then key[v] < key[u];\n
  如果 v 是 u 的左子树，则 key[v] < key[u]; 
* If v is a right descendant of u, then key[v] > key[u];\n
  如果 v 是 u 的右子树，则 key[v] > key[u]; 
* If v is a child of u, then priority[v] <= priority[u];\n
  如果 v 是 u 的子树，则 priority[v] <= priority[u]; 

If priorities are non-random, the tree will usually be unbalanced; this worse theoretical average-case
behavior may be outweighed by better expected-case behavior, as the most important items will be near the root.
This means most important objects will be retrieved faster than less important items and for items keys with equal keys
most important objects will be found first. These properties are important for some applications.\n
如果优先级是非随机的，则该树通常会是不平衡的；最坏的理论平均情况可能会被较好的期望情况超出，因为最重要的项比较接近根。
这意味着最重要的对象要比较不重要的更快取出，对于具有相同键值的项来说，较重要的会先被找到。对于某些应用来说，这一点是很重要的。

The priority comparison will be provided just like the key comparison, via a function object that will be
stored in the intrusive container. This means that the priority can be stored in the value to be introduced
in the treap or computed on flight (via hashing or similar).\n
优先级的比较和键值的比较一样，通过一个保存在介入式容器中的函数对象来提供。这意味着优先级可以被保存在引入到treap中的值当中，
或者在需要的时候即时计算得到(通过散列或类似的方法)。

[*Boost.Intrusive] offers 3 containers based on treaps:
[classref boost::intrusive::treap_set treap_set],
[classref boost::intrusive::treap_multiset treap_multiset] and
[classref boost::intrusive::treap treap]. The first two are similar to
[classref boost::intrusive::set set] or
[classref boost::intrusive::multiset multiset] and the latter is a generalization
that offers functions both to insert unique and multiple keys.\n
[*Boost.Intrusive] 提供了3种基于treap的容器：[classref boost::intrusive::treap_set treap_set],
[classref boost::intrusive::treap_multiset treap_multiset] 和 [classref boost::intrusive::treap treap]。
前两个类似于 [classref boost::intrusive::set set] 和 [classref boost::intrusive::multiset multiset]，
后一个则是一个泛化容器，提供了插入唯一或非唯一键值的函数。

The memory overhead of these containers with Boost.Intrusive hooks is 3
pointers.\n
这些带有 Boost.Intrusive 钩子的容器的空间开销通常为3个指针。

An empty, [classref boost::intrusive::treap_set treap_set],
[classref boost::intrusive::treap_multiset treap_multiset] or
[classref boost::intrusive::treap treap]
has also the size of 3 pointers and an integer (supposing empty function objects for key and priority
comparison and constant-time size).\n
一个空的 [classref boost::intrusive::treap_set treap_set], [classref boost::intrusive::treap_multiset treap_multiset] 
或 [classref boost::intrusive::treap treap] 也具有3个指针和1个整数的大小(假设键值比较和优先级比较的函数对象为空，
且容器带有常量时间的size函数)。

[section:treap_set_multiset_hooks Using binary search tree hooks: bs_set_base_hook and bs_set_member_hook\n
使用二分查找树钩子：bs_set_base_hook 和 bs_set_member_hook]

[classref boost::intrusive::treap_set treap_set],
[classref boost::intrusive::treap_multiset treap_multiset] and
[classref boost::intrusive::treap treap] don't use their
own hooks but plain binary search tree hooks. This has many advantages
since binary search tree hooks can also be used to insert values in
splay containers and scapegoat trees.\n
[classref boost::intrusive::treap_set treap_set], [classref boost::intrusive::treap_multiset treap_multiset]
和 [classref boost::intrusive::treap treap] 不使用它们自己的钩子，而是使用普通的二分查找树钩子。
这有许多优点，因为二分查找树钩子还可以用于将值插入到 splay 容器和替罪羊树中。

[c++]

   template <class ...Options>
   class bs_set_base_hook;

*  [classref boost::intrusive::bs_set_base_hook bs_set_base_hook]:
   the user class derives publicly from this class to make
   it compatible with scapegoat tree based containers.\n
   [classref boost::intrusive::bs_set_base_hook bs_set_base_hook]: 用户类公有派生自本类以兼容于基于替罪羊树的容器。

[c++]

   template <class ...Options>
   class bs_set_member_hook;

*  [classref boost::intrusive::set_member_hook set_member_hook]:
   the user class contains a public member of this class to make
   it compatible with scapegoat tree based containers.\n
   [classref boost::intrusive::set_member_hook set_member_hook]: 用户类包含一个公有的本类以兼容于基于替罪羊树的容器。

[classref boost::intrusive::bs_set_base_hook bs_set_base_hook] and
[classref boost::intrusive::bs_set_member_hook bs_set_member_hook] receive
the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
[classref boost::intrusive::bs_set_base_hook bs_set_base_hook] 和 
[classref boost::intrusive::bs_set_member_hook bs_set_member_hook] 接受在 
[link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的各种选项：

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one base hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`.

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`] 链接策略。缺省值：`link_mode<safe_link>`.

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。
   缺省值：`void_pointer<void*>`.

[endsect]

[section:treap_set_multiset_containers treap_set, treap_multiset and treap containers\n
treap_set, treap_multiset 和 treap 容器]

[c++]

   template <class T, class ...Options>
   class treap_set;

   template <class T, class ...Options>
   class treap_multiset;

   template <class T, class ...Options>
   class treap;

These containers receive the same options explained in the section
[link intrusive.usage How to use Boost.Intrusive]:\n
这些容器接受在 [link intrusive.usage 如何使用 Boost.Intrusive] 一节中说明的选项：

*  [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: To specify the hook type or value traits used
   to configure the container. (To learn about value traits go to the section
   [link intrusive.value_traits Containers with custom ValueTraits].)\n
   [*`base_hook<class Hook>`] / [*`member_hook<class T, class Hook, Hook T::* PtrToMember>`] / 
   [*`value_traits<class ValueTraits>`]: 指定用于配置容器的钩子类型或 value traits。
   (要学习有关 value traits 的知识，请见 [link intrusive.value_traits 带定制化 ValueTraits 的容器])。 

*  [*`constant_time_size<bool Enabled>`]: To activate the constant-time `size()` operation.
   Default: `constant_time_size<true>`\n
   [*`constant_time_size<bool Enabled>`]: 激活常量时间的 `size()` 操作。缺省值：`constant_time_size<true>`

*  [*`size_type<bool Enabled>`]: To specify the type that will be used to store the size
   of the container. Default: `size_type<std::size_t>`\n
   [*`size_type<bool Enabled>`]: 指定用于保存容器大小的类型。缺省值：`size_type<std::size_t>`

And they also can receive additional options:\n
它们还可以接受其它的选项：

*  [*`compare<class Compare>`]: Comparison function for the objects to be inserted
   in containers. The comparison functor must induce a strict weak ordering.
   Default: `compare< std::less<T> >`\n
   [*`compare<class Compare>`]: 被插入到容器中的对象所用的比较函数。这个比较函数必须实现一个严格弱序。
   缺省值：`compare< std::less<T> >`

*  [*`priority<class PriorityCompare>`]: Priority Comparison function for the objects to be inserted
   in containers. The comparison functor must induce a strict weak ordering.
   Default: `priority< priority_compare<T> >`\n
   [*`priority<class PriorityCompare>`]: 被插入到容器中的对象所用的优先级比较函数。这个比较函数必须实现一个严格弱序。
   缺省值：`priority< priority_compare<T> >`

The default `priority_compare<T>` object function will call an unqualified function `priority_order`
passing two constant `T` references as arguments and should return true if the first argument has
higher priority (it will be searched faster), inducing strict weak ordering.
The function will be found using ADL lookup so that
the user just needs to define a `priority_order` function in the same namespace as his class:\n
缺省的 `priority_compare<T>` 对象函数会调用一个非受限的函数 `priority_order`，传入两个常量的 `T` 引用作为参数，
如果第一个参数具有较高优先级(该对象将被较快地查找到)，则返回 true，这个函数实现一个严格弱序。
该函数由ADL规则来查找，因此用户只需要在他的类所在的名字空间中定义一个 `priority_order` 函数即可：

[c++]

   struct MyType
   {
      friend bool priority_order(const MyType &a, const MyType &b)
      {...}
   };

or\n或

   namespace mytype {

   struct MyType{ ... };

   bool priority_order(const MyType &a, const MyType &b)
   {...}

   }  //namespace mytype {

[endsect]

[section:treap_set_exceptions Exception safety of treap-based intrusive containers\n
基于treap的介入式容器的异常安全性]

In general, intrusive containers offer strong safety guarantees, but treap containers must deal
with two possibly throwing functors (one for value ordering, another for priority ordering).
Moreover, treap erasure operations require rotations based on the priority order function and
this issue degrades usual `erase(const_iterator)` no-throw guarantee. However, intrusive offers
the strongest possible behaviour in these situations. In summary:\n
通常，介入式容器提供强异常安全保证，但是 treap 容器必须处理两个可能发生异常的函数对象
(一个用于值排序，另一个用于优先级排序)。此外，treap 的删除操作要求基于优先级排序函数的旋转，
这会降低普通的 `erase(const_iterator)` 的无抛出保证。不过，本库提供了在此条件下可能的最强保证。总的来说：

*  If the priority order functor does not throw, treap-based containers, offer exactly the same
   guarantees as other tree-based containers.\n
   如果优先级排序函数无抛出，则基于 treap 的容器提供与其它基于树的容器完全相同的保证。

*  If the priority order functor throws, treap-based containers offer strong guarantee.\n
   如果优先级排序函数有抛出，则基于 treap 的容器提供强异常安全性保证。

[endsect]

[section:treap_set_multiset_example Example 例子]

Now let's see a small example using both hooks and
[classref boost::intrusive::treap_set treap_set]/
[classref boost::intrusive::treap_multiset treap_multiset]
containers:\n
现在我们来看一个使用这些钩子和 [classref boost::intrusive::treap_set treap_set]/
[classref boost::intrusive::treap_multiset treap_multiset] 容器的小例子：

[import ../example/doc_treap_set.cpp]
[doc_treap_set_code]

[endsect]

[endsect]


[section:advanced_lookups_insertions Advanced lookup and insertion functions for associative containers\n
关联容器的高级查找和插入函数]

[section:advanced_lookups Advanced lookups 高级查找]

[*Boost.Intrusive] associative containers offer the same interface as STL associative
containers. However, STL and TR1 ordered and unordered simple associative containers 
(`std::set`, `std::multiset`, `std::tr1::unordered_set` and `std::tr1::unordered_multiset`)
have some inefficiencies caused by the interface: the user can only operate with `value_type`
objects. When using these containers we must use `iterator find(const value_type &value)`
to find a value. The same happens in other functions
like `equal_range`, `lower_bound`, `upper_bound`, etc.\n
[*Boost.Intrusive] 关联容器提供了和 STL 关联容器一样的接口。但是，STL 和 TR1 的有序及无序简单关联容器
(`std::set`, `std::multiset`, `std::tr1::unordered_set` 和 `std::tr1::unordered_multiset`) 
因为其接口而显得有些低效：用户只能操作 `value_type` 对象。在使用这些容器时，我们必须用 `iterator find(const value_type &value)`
来查找一个值。对于其它函数也一样，如 `equal_range`, `lower_bound`, `upper_bound`, 等等。 

However, sometimes the object to be searched is quite expensive to construct:\n
但是有时候，被查找的对象的构造非常昂贵：

[import ../example/doc_assoc_optimized_code.cpp]
[doc_assoc_optimized_code_normal_find]

`Expensive` is an expensive object to construct. If "key" c-string is quite long
`Expensive` has to construct a `std::string` using heap memory. Like
`Expensive`, many times the only member taking part in ordering issues is just
a small part of the class. For example, with `Expensive`, only the internal
`std::string` is needed to compare the object. \n
`Expensive` 是一个构造代价昂贵的对象。如果c字符串 "key" 非常长，则 `Expensive` 必须使用堆内存来构造一个 `std::string`。
象 `Expensive` 这样，很多时候参与排序的只是类的一小部分。例如，对于 `Expensive`，比较对象时只需要其内部的 `std::string`。

In both containers, if we call `get_from_set/get_from_unordered_set` in a loop, we might get a performance penalty,
because we are forced to create a whole `Expensive` object to be able to find an
equivalent one.\n
在这两个容器中，如果我们在一个循环中调用 `get_from_set/get_from_unordered_set`，我们就有可能遇到性能的问题，
因为我们被迫创建整个 `Expensive` 对象才能查找相等的元素。 

Sometimes this interface limitation is severe, because
we [*might not have enough information to construct the object] but we might
[*have enough information to find the object]. In this case, a name is enough
to search `Expensive` in the container but constructing an `Expensive`
might require more information that the user might not have.\n
有时候，这种接口的限制是严重的，因为我们[*可能没有足够的信息来构造这个对象]，不过我们可能有足够的信息来找到这个对象。
在这种情况下，有一个名字就足以在容器中查找 `Expensive`，而构造一个 `Expensive` 则可能需要用户也许没有的信息。 

To solve this, [classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset]
offer alternative functions, which take any type comparable with the value and a 
functor that should be compatible with the 
ordering function of the associative container.
[classref boost::intrusive::unordered_set unordered_set]/[classref boost::intrusive::unordered_multiset unordered_multiset]
offers functions that take any key type and compatible hash and equality functions. Now, let's see the
optimized search function:\n
为了解决这一问题，[classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset]
提供了替代的函数，它接受可以与元素值相比较的任何类型，以及一个兼容于关联容器的排序函数的仿函数。
[classref boost::intrusive::unordered_set unordered_set]/[classref boost::intrusive::unordered_multiset unordered_multiset]
则提供了接受任何关键字类型的函数，以及兼容的散列函数和相等性函数。现在，我们来看一看优化后的查找函数：

[doc_assoc_optimized_code_optimized_find]

This new arbitrary key overload is also available for other functions taking
values as arguments:\n
这个新的任意键的重载对于其它以元素值作为参数的函数也可用：

*  equal_range
*  lower_bound
*  upper_bound
*  count
*  find
*  erase

Check [classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset],
[classref boost::intrusive::unordered_set unordered_set],
[classref boost::intrusive::unordered_multiset unordered_multiset]
references to know more about those functions.\n
请查阅 [classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset],
[classref boost::intrusive::unordered_set unordered_set],
[classref boost::intrusive::unordered_multiset unordered_multiset] 
的参考手册，了解有关这些函数的更多信息。 

[endsect]

[section:advanced_insertions Advanced insertions 高级插入]

A similar issue happens with insertions in simple ordered and unordered associative
containers with unique keys (`std::set` and `std::tr1::unordered_set`). In these containers,
if a value is already present, the value to be inserted is discarded. With expensive
values, if the value is already present, we can suffer efficiency problems.\n
在往简单的具有唯一键的有序和无序关联容器(`std::set` 和 `std::tr1::unordered_set`) 中进行插入时也有类似问题。
在这些容器中，如果一个值已经存在，则被插入的值将被丢弃。对于代价昂贵的值，如果值已经存在，则我们会经受效率的问题。

[classref boost::intrusive::set set] and [classref boost::intrusive::unordered_set unordered_set]
have insertion functions to check efficiently, without
constructing the value, if a value is present or not and if it's not present, a
function to insert it immediately without any further lookup.
For example, using the same `Expensive` class,
this function can be inefficient:\n
[classref boost::intrusive::set set] 和 [classref boost::intrusive::unordered_set unordered_set]
具有无须构造插入值即可高效检查该值是否存在的插入函数，如果该值不存在，则另一个函数立即将它插入，
不需要任何多余的查找。例如，使用相同的 `Expensive` 类，以下函数是低效的：

[doc_assoc_optimized_code_normal_insert]
 
If the object is already present, we are constructing an `Expensive` that
will be discarded, and this is a waste of resources. Instead of that, let's use
`insert_check` and `insert_commit` functions:\n
如果对象已存在，那么我们就构造了一个将被丢弃的 `Expensive`，这是资源的浪费。
相反，我们来使用 `insert_check` 和 `insert_commit` 函数：

[doc_assoc_optimized_code_optimized_insert]

`insert_check` is similar to a normal `insert` but:\n
`insert_check` 类似于普通的 `insert`，不过：

*  `insert_check` can be used with arbitrary keys\n
   `insert_check` 可以使用任意键
*  if the insertion is possible (there is no equivalent value) `insert_check` collects all the needed information
in an `insert_commit_data` structure, so that `insert_commit`:\n
   如果插入是可以的(没有相同的值)，则 `insert_check` 将所有需要的信息收集到一个 `insert_commit_data` 结构中，这样
   `insert_commit` 就：
   *   [*does not execute] further comparisons\n
       [*不执行]多余的比较。
   *   can be executed with [*constant-time complexity]\n
       可以以[*常数时间复杂度]执行。
   *   has [*no-throw guarantee].\n
       具有[*无抛出保证]。

These functions must be used with care, since
no other insertion or erasure must be executed between an `insert_check` and an `insert_commit`
pair. Otherwise, the behaviour is undefined.
`insert_check` and `insert_commit` will come in handy
for developers programming efficient non-intrusive associative containers.
See [classref boost::intrusive::set set]
and [classref boost::intrusive::unordered_set unordered_set] reference for more information about
`insert_check` and `insert_commit`.\n
这些函数必须小心使用，因为在一对 `insert_check` 和 `insert_commit` 之间必须不能有其它插入或删除。
否则，行为将是未定义的。`insert_check` 和 `insert_commit` 对于编写高效的非介入式关联容器也能派上用场。
有关 `insert_check` 和 `insert_commit` 的更多信息，请见 [classref boost::intrusive::set set] 和 
[classref boost::intrusive::unordered_set unordered_set] 的参考手册。

With multiple ordered and unordered associative containers
([classref boost::intrusive::multiset multiset] and 
[classref boost::intrusive::unordered_multiset unordered_multiset]) there  is
no need for these advanced insertion functions, since insertions are always successful.\n
对于非唯一的有序和无序关联容器([classref boost::intrusive::multiset multiset] 和 
[classref boost::intrusive::unordered_multiset unordered_multiset])，不需要这些插入函数，因为插入操作总是成功的。

[endsect]

[section:positional_insertions Positional insertions 定位插入]

Some ordered associative containers offer low-level functions to bypass ordering
checks and insert nodes directly in desired tree positions. These functions are
provided for performance reasons when values to be inserted in the container are
known to fulfill order (sets and multisets) and uniqueness (sets) invariants. A
typical usage of these functions is when intrusive associative containers are used
to build non-intrusive containers and the programmer wants to speed up assignments
from other associative containers: if the ordering and uniqueness properties are the same,
there is no need to waste time checking the position of each source value, because values
are already ordered: back insertions will be much more efficient.\n
有一些有序关联容器会提供一些低级函数来绕过顺序检查并直接在树中指定位置插入节点。
提供这些函数通常是由于性能的原因，且被插入容器中的值已知是符合顺序不变式(对于 sets 和 multisets)
以及唯一性(对于 sets)的。这些函数的一个典型用法是，当介入式关联容器被用于构建非介入式容器，
且程序员想加快从其它关联容器赋值的速度时：如果顺序性与唯一性是相同的，就没有必要浪费时间去检查来源的每一个值的位置，
因为这些值已经是有序的：反向插入将更加高效。

[*Note:] These functions [*don't check preconditions] so they must used with care. These
are functions are low-level operations [*will break container invariants if
ordering and uniqueness preconditions are not assured by the caller.]\n
[*注：]这些函数 [*不会检查先决条件]，因此必须非常小心地使用它们。
这些函数是低级操作，[*如果顺序性和唯一性条件不能满足，将会破坏容器的不变式]。

Let's see an example:\n
我们来看一个例子：

[import ../example/doc_positional_insertion.cpp]
[doc_positional_insertion]


[endsect]

For more information about advanced lookup and insertion functions see
associative containers' documentation (e.g. 
[classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset],
[classref boost::intrusive::unordered_set unordered_set] and
[classref boost::intrusive::unordered_multiset unordered_multiset] references).\n
有关高级查找和插入函数的更多信息，请见相关关联容器的文档(如 [classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset],
[classref boost::intrusive::unordered_set unordered_set] 和 
[classref boost::intrusive::unordered_multiset unordered_multiset] 的参考手册)。

[endsect]

[section:erasing_and_disposing Erasing and disposing values from Boost.Intrusive containers\n
从 Boost.Intrusive 容器中移除和处置值]

One of the most tedious tasks when using intrusive containers is the management of the erased elements.
When using STL containers, the container itself unlinks and destroys the contained elements, but with
intrusive containers, the user must explicitly destroy the object after erasing an element from the container.
This makes STL-like functions erasing multiple objects unhelpful: the user can't destroy every erased element.
For example, let's take the function `remove_if` from [classref boost::intrusive::list list]:\n
使用介入式容器时最乏味的工作之一就是已删除元素的管理的。使用 STL 容器时，容器本身负责删除和销毁所含的元素，
但对于介入式容器，用户必须在从容器中删除对象后再明确地销毁它。这使得类似于 STL 的删除多个对象的函数没用了：
用户不能销毁每一个被删除的元素。例如，我们看一下来自于 [classref boost::intrusive::list list] 的 `remove_if`：

[c++]

   template<class Pred>
   void remove_if(Pred pred);

How can the user destroy the elements (say, using `operator delete`) that will be erased according
to the predicate? [*Boost.Intrusive] containers offer additional functions that take a function
object that will be called after the element has been erased from the container. For example,
[classref boost::intrusive::list list] offers:\n
用户怎么能够销毁(即使用 `operator delete`)依据谓词被删除的元素呢？[*Boost.Intrusive] 容器提供了另一个函数，
接受一个函数对象，该函数对象将在从容器中删除某个元素后被调用。例如，[classref boost::intrusive::list list] 提供了：

[c++]

   template<class Pred, class Disposer>
   void remove_and_dispose_if(Pred pred, Disposer disposer)

With this function the user can efficiently remove and destroy elements if the disposer
function destroys an object: `remove_and_dispose_if` 
will call the "disposer" function object for every removed element. [classref boost::intrusive::list list] offers
more functions taking a disposer function object as argument, like `erase_and_dispose`, `clear_and_dispose`,
`remove_and_dispose`, etc. \n
如果 disposer 函数是销毁一个对象的话，用户就可以用这个函数高效地移除并销毁元素：`remove_and_dispose_if` 
将对每一个被移除的元素调用 "disposer" 函数对象。[classref boost::intrusive::list list] 提供了多个接受一个 
disposer 函数对象参数的函数，如 `erase_and_dispose`, `clear_and_dispose`, `remove_and_dispose`, 等等。

Note that the disposing function does not need to just destroy the object. It can
implement any other operation like inserting the remove object in another container.
Let's see a small example:\n
注意，处置函数并不必只是销毁对象。它可以实现其它任何操作，如将移除的元素插入到另一个容器中。
我们来看一个小例子：

[import ../example/doc_erasing_and_disposing.cpp]
[doc_erasing_and_disposing]

All [*Boost.Intrusive] containers offer these "erase + dispose" additional members for all functions
that erase an element from the container.\n
所有 [*Boost.Intrusive] 容器都为所有从容器中移除元素的函数提供了这些 "移除 + 处置" 的成员。


[endsect]

[section:clone_from Cloning [*Boost.Intrusive] containers 克隆 Boost.Intrusive 容器]

As previously mentioned, [*Boost.Intrusive] containers are [*non-copyable and non-assignable], because
intrusive containers don't allocate memory at all. To implement a copy-constructor or assignment operator,
the user must clone one by one all the elements of the container and insert them in another intrusive container.
However, cloning by hand is usually more inefficient than a member cloning function and a specialized cloning
function can offer more guarantees than the manual cloning (better exception safety guarantees, for example).\n
前面提到，[*Boost.Intrusive] 容器是[*不可复制和不可赋值的]，因为介入式容器根本不进行内存分配。
要实现一个复制构造函数或赋值操作符，用户必须从容器逐个对象进行克隆并将它们插入到另一个介入式容器中。
但是，手工进行克隆通常要比成员克隆函数低效，而且一个专门的克隆函数可以提供比手工克隆更多的保证(例如，更好的异常安全性保证)。

To ease the implementation of copy constructors and assignment operators of classes containing [*Boost.Intrusive]
containers, all [*Boost.Intrusive] containers offer a special cloning function called `clone_from`.\n
为了便于包含有 [*Boost.Intrusive] 容器的类实现复制构造函数和赋值操作符，所有 [*Boost.Intrusive] 
容器都提供了一个名为 `clone_from` 的专用克隆函数。

Apart from the container to be cloned, `clone_from` takes two function objects as arguments. For example, consider the
`clone_from` member function of [classref boost::intrusive::list list]:\n
除了要进行克隆的容器之外，`clone_from` 还有两个函数对象参数。例如，[classref boost::intrusive::list list] 的 `clone_from` 成员函数：

[c++]

   template <class Cloner, class Disposer>
   void clone_from(const list &src, Cloner cloner, Disposer disposer);
   
This function will make `*this` a clone of `src`. Let's explain the arguments:\n
该函数把 `*this` 变为 `src` 的克隆。下面解释一下这些参数：

*   The first parameter is the list to be cloned.\n
    第一个参数为要进行克隆的链表。
*   The second parameter is a function object that will clone `value_type` objects and
   return a pointer to the clone. It must implement the following function:
   `pointer operator()(const value_type &)`.\n
   第二个参数是一个函数对象，用于克隆 `value_type` 对象并返回一个克隆物的指针。它必须实现以下函数：
   `pointer operator()(const value_type &)`.
*   The second parameter is a function object that will dispose `value_type` objects. It's used first
   to empty the container before cloning and to dispose the elements if an exception is thrown.\n
   下一个参数也是一个处置 `value_type` 对象的函数对象。用于在克隆之前清空容器，以及当有异常抛出时对元素进行处置。
   
The cloning function works as follows:\n
克隆函数工作如下：

*   First it clears and disposes all the elements from *this using the disposer function object.\n
    首先使用 disposer 函数对象清理并处置来自 *this 的所有元素。
*   After that it starts cloning all the elements of the source container using the cloner function object.
    然后开始用 cloner 函数对象克隆源容器的所有元素。
*   If any operation in the cloning function (for example, the cloner function object) throws,
   all the constructed elements are disposed using the disposer function object.\n
   如果在克隆函数中的任何操作(例如 cloner 函数对象)抛出异常，则使用 disposer 函数对象处置所有已构造的元素。


Here is an example of `clone_from`:\n
以下是一个 `clone_from` 例子：

[import ../example/doc_clone_from.cpp]
[doc_clone_from]

[endsect]

[section:using_smart_pointers Using smart pointers with Boost.Intrusive containers 让 Boost.Intrusive 容器使用智能指针]

[*Boost.Intrusive] hooks can be configured to use other pointers than raw pointers.
When a [*Boost.Intrusive] hook is configured with a smart pointer as an argument,
this pointer configuration is passed to the containers. For example, if the following
hook is configured with a smart pointer (for example, an offset pointer from
[*Boost.Interprocess]):\n
[*Boost.Intrusive] 钩子可以被配置为使用裸指针以外的其它指针。当一个 [*Boost.Intrusive] 钩子被用智能指针作为参数来配置时，
该指针的配置会被传递到容器。例如，如果以下钩子是用智能指针(如 [*Boost.Interprocess] 的偏移量指针)来配置的：

[import ../example/doc_offset_ptr.cpp]
[doc_offset_ptr_0]

Any intrusive list constructed using this hook will be ready for shared memory,
because the intrusive list will also use offset pointers internally. For example,
we can create an intrusive list in shared memory combining [*Boost.Interprocess]
and [*Boost.Intrusive]:\n
任何用这个钩子构造的介入式链表都可以使用共享内存，因为介入式链表内部也是使用偏移量指针。
例如，我们可以结合 [*Boost.Interprocess] 和 [*Boost.Intrusive] 在共享内存中创建一个介入式链表：

[doc_offset_ptr_1]

[section:smart_pointers_requirements Requirements for smart pointers compatible with Boost.Intrusive\n
兼容于 Boost.Intrusive 的智能指针的要求]

Not every smart pointer is compatible with [*Boost.Intrusive]; the smart pointer must
have the following features:\n
不同每个智能指针都能兼容于 [*Boost.Intrusive]；智能指针必须具有以下特点：

*  It must support the same operations as a raw pointer, except casting.\n
    它必须支持和裸指针一样的操作，除了转型。
*  It must be convertible to a raw pointer and constructible from a raw pointer.\n
    它必须可以转型为裸指针，以及可以从裸指针构造。
*  It must have the same ownership semantics as a raw pointer. This means that
   resource management smart pointers (like `boost::shared_ptr`) can't be used.\n
   它必须具有与裸指针相同的拥有权语义。即资源管理类的智能指针(如 `boost::shared_ptr`)不可使用。

The conversion from the smart pointer to a raw pointer must be implemented following
Boost smart pointer `detail::get_pointer()` function. This function will be found using
ADL. For example, for `boost::interprocess::offset_ptr`, `detail::get_pointer` is defined
as follows:\n
从智能指针到裸指针的转换必须实现为以下 Boost 智能指针 `detail::get_pointer()` 函数。
该函数将通过 ADL 被发现。例如，对于 `boost::interprocess::offset_ptr`, `detail::get_pointer`，定义如下：

[c++]

   template<class T>
   T * detail::get_pointer(boost::interprocess::offset_ptr<T> const & p)
   {  return p.get();   }

[endsect]

[endsect]

[section:obtaining_iterators_from_values Obtaining iterators from values 从值取得迭代器]

[*Boost.Intrusive] offers another useful feature that's not present in STL
containers: it's possible to obtain an iterator to a value from the value itself.
This feature is implemented in [*Boost.Intrusive] containers by a 
function called `iterator_to`:\n
[*Boost.Intrusive] 提供了 STL 容器中没有的一个很有用的特性：它可以从值获得一个指向该值的迭代器。
[*Boost.Intrusive] 容器的这一特性是通过一个名为 `iterator_to` 的函数实现的：

[c++]

   iterator iterator_to(reference value);
   const_iterator iterator_to(const_reference value);

For [*Boost.Intrusive] containers that have local iterators, like unordered
associative containers, we can also obtain local iterators:\n
对于具有局部迭代器的 [*Boost.Intrusive] 容器，如无序关联容器，我们也可以取得局部迭代器：

[c++]

   local_iterator local_iterator_to(reference value);
   const_local_iterator local_iterator_to(const_reference value) const;

For most [*Boost.Intrusive] containers
([classref boost::intrusive::list list],
[classref boost::intrusive::slist slist],
[classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset]) we have an alternative 
static `s_iterator_to` function.\n
对于多数 [*Boost.Intrusive] 容器([classref boost::intrusive::list list],
[classref boost::intrusive::slist slist], [classref boost::intrusive::set set],
[classref boost::intrusive::multiset multiset])，我们有另一个静态的 `s_iterator_to` 函数。

For unordered associative containers
([classref boost::intrusive::unordered_set unordered_set],
[classref boost::intrusive::multiset multiset]),
`iterator_to` has no static alternative function.
On the other hand, `local_iterator_to` functions
have their `s_local_iterator_to` static alternatives.\n
对于无序关联容器([classref boost::intrusive::unordered_set unordered_set],
[classref boost::intrusive::multiset multiset]), `iterator_to` 没有静态的函数。
另一方面，`local_iterator_to` 函数则具有 `s_local_iterator_to` 静态替代物。

Alternative static functions are available under certain circumstances
explained in the [link intrusive.value_traits.stateful_value_traits Stateful value traits] section;
if the programmer uses hooks provided by [*Boost.Intrusive], those functions
will be available.\n
替代的静态函数在 [link intrusive.value_traits.stateful_value_traits 带状态的值 traits] 一节中所说明的特定环境下可用；
如果程序员使用了由 [*Boost.Intrusive] 提供的钩子，这些函数就是可用的。

Let's see a small function that shows the use of `iterator_to` and 
`local_iterator_to`:\n
我们来看一个示范 `iterator_to` 和 `local_iterator_to` 用法的小例子：

[import ../example/doc_iterator_from_value.cpp]
[doc_iterator_from_value]

[endsect]

[section:any_hooks Any Hooks: A single hook for any Intrusive container 任意钩子：单个钩子用于任意介入式容器]

Sometimes, a class programmer wants to place a class in several intrusive
containers but no at the same time. In this case, the programmer might
decide to insert two hooks in the same class.\n
有时候，程序员想将某个类放入多个介入式容器，但不是同时放入。在这种情况下，
程序员可能决定在同一个类中插入两个钩子。

[c++]

   class MyClass
      : public list_base_hook<>, public slist_base_hook<> //...
   {};

However, there is a more size-efficient alternative in [*Boost.Intrusive]: "any" hooks
([classref boost::intrusive::any_base_hook any_base_hook] and
[classref boost::intrusive::any_member_hook any_member_hook]).
These hooks can be used to store a type in several containers
offered by [*Boost.Intrusive] minimizing the size of the class.\n
不过，[*Boost.Intrusive] 中有一个更为节省空间的办法："任意"钩子([classref boost::intrusive::any_base_hook any_base_hook] 
和 [classref boost::intrusive::any_member_hook any_member_hook])。这些钩子可以用于将一个类型存入由 [*Boost.Intrusive]
提供的多种容器，并且使得类的大小最小化。

These hooks support these options:\n
这些钩子支持以下选项：

*  [*`tag<class Tag>`] (for base hooks only): This argument serves as a tag,
   so you can derive from more than one slist hook.
   Default: `tag<default_tag>`.\n
   [*`tag<class Tag>`] (只用于基类钩子)：该参数作为一个标记，这样你可以派生自多个 slist 钩子。
   缺省值：`tag<default_tag>`.

*  [*`link_mode<link_mode_type LinkMode>`]: The linking policy.
   `link_mode<auto_unlink>` is [*not] supported and `link_mode<safe_mode>`
   might offer weaker error detection in any hooks than in other hooks.
   Default: `link_mode<safe_link>`.\n
   [*`link_mode<link_mode_type LinkMode>`]: 链接策略。`link_mode<auto_unlink>` [*不被]支持，而 `link_mode<safe_mode>`
   则可能在"任意"钩子中提供与其它钩子相比较弱的错误检测能力。缺省值：`link_mode<safe_link>`.

*  [*`void_pointer<class VoidPointer>`]: The pointer type to be used
   internally in the hook and propagated to the container.
   Default: `void_pointer<void*>`.\n
   [*`void_pointer<class VoidPointer>`]: 在钩子内部使用并被传递给容器的指针类型。缺省值：`void_pointer<void*>`.

`auto_unlink` can't be supported because the hook does not know in which type of
container might be currently inserted. Additionally, these hooks don't support `unlink()` and
`swap_nodes()` operations for the same reason.\n
`auto_unlink` 不被支持，因为钩子不知道它可能被插入到哪一类容器中。另外，因为同样的原因，
这些钩子也不支持 `unlink()` 和 `swap_nodes()` 操作。

Here is an example that creates a class with two any hooks, and uses one to insert the
class in a [classref slist] and the other one in a [classref list].\n
以下例子创建了一个带有两个任意钩子的类，使用其中一个钩子将类插入到一个 [classref slist] 
并用另一个钩子插入到一个 [classref list] 中。

[import ../example/doc_any_hook.cpp]
[doc_any_hook]

[endsect]

[section:concepts Concepts explained 概念解释]

This section will expand the explanation of previously presented basic concepts
before explaining the customization options of [*Boost.Intrusive].\n
在说明 [*Boost.Intrusive] 的定制化选项之前，本节先展开对先前提出的基本概念的解释。

*  [*Node Algorithms]: A set of static functions that implement basic operations
   on a group of nodes: initialize a node, link_mode_type a node to a group of nodes,
   unlink a node from another group of nodes, etc. For example, a circular
   singly linked list is a group of nodes, where each node has a pointer to the
   next node. [*Node Algorithms] just require a [*NodeTraits]
   template parameter and they can work with any [*NodeTraits] class that fulfills
   the needed interface. As an example, here is a class that implements operations7'
   to manage a group of nodes forming a circular singly linked list:\n
   [*节点算法]：一组静态函数，实现在一组节点上的基本操作：初始化一个节点，将一个节点 link_mode_type 至一组节点，
   将一个节点从另一组节点中断开，等等。例如，一个循环单链表就是一组节点，其中每个节点都带有一个指向下一个节点的指针。
   [*结点算法] 只要求一个 [*NodeTraits] 模板参数，它们可以用于任何符合所需接口的 [*NodeTraits] 类。
   例如，下面的类实现了管理一组形成循环单链表的节点的操作：

[c++]

   template<class NodeTraits>
   struct my_slist_algorithms
   {
      typedef typename NodeTraits::node_ptr       node_ptr;
      typedef typename NodeTraits::const_node_ptr const_node_ptr;

      //Get the previous node of "this_node" 取得 "this_node" 的前一个节点
      static node_ptr get_prev_node(node_ptr this_node)
      {
         node_ptr p = this_node;
         while (this_node != NodeTraits::get_next(p))
            p = NodeTraits::get_next(p);
         return p;
      }

      // number of elements in the group of nodes containing "this_node"
      // 含有 "this_node" 的节点组的元素数量
      static std::size_t count(const_node_ptr this_node) 
      {
         std::size_t result = 0;
         const_node_ptr p = this_node;
         do{
            p = NodeTraits::get_next(p);
            ++result;
         } while (p != this_node);
         return result;
      }

      // More operations 更多操作
      // ...
   };

*  [*Node Traits]: A class that encapsulates the basic information and
   operations on a node within a group of nodes:
   the type of the node, a function to obtain the pointer to the next node, etc. 
   [*Node Traits] specify the configuration information [*Node Algorithms]
   need. Each type of [*Node Algorithm] expects an interface that compatible
   [*Node Traits] classes must implement.
   As an example, this is the definition of a [*Node Traits] class that
   is compatible with the previously presented `my_slist_algorithms`:\n
   [*节点 Traits]: 一个封装了一组节点中某个节点的基本信息和操作的类：节点的类型，
   取得下一个节点的函数，等等。[*节点 Traits] 给出了 [*结点算法] 所需的配置信息。
   每一类 [*节点算法] 都有一个接口要求，与其兼容的 [*节点 Traits] 类必须实现这一接口。
   例如，以下是一个 [*节点 Traits] 类的定义，它兼容于前面所给出的 `my_slist_algorithms`：

[c++]

   struct my_slist_node_traits
   {
      //The type of the node 节点的类型
      struct node
      {
         node *next_;
      };      
     
      typedef node *       node_ptr;
      typedef const node * const_node_ptr;

      //A function to obtain a pointer to the next node
      //取得指向下一个节点的指针的函数
      static node_ptr get_next(const_node_ptr n)
      {  return n->next_;  }  

      //A function to set the pointer to the next node
      //设置下一个节点的指针的函数
      static void set_next(node_ptr n, node_ptr next)
      {  n->next_ = next;  }  
   };


*  [*Hook]: A class that the user must add as a base class or as a member to his own
   class to make that class insertable in an intrusive container. Usually the hook
   contains a node object that will be used to form the group of nodes:
   For example, the following class is a [*Hook] that the user can add as a base class,
   to make the user class compatible with a singly linked list container:\n
   [*钩子]：一个类，用户必须将它作为一个基类或一个成员加入到用户自己的类中，
   以使得用户类可以被插入到介入式容器中。钩子通常包含一个节点对象，用于形成节点组：
   例如，下面这个类就是一个 [*钩子]，用户可以将它作为一个基类加入到用户类中，
   以使得用户类兼容于单链表容器：

[c++]

   class my_slist_base_hook
         //This hook contains a node, that will be used
         //to link the user object in the group of nodes
         //这个钩子包含一个节点，用于将用户对象链接到节点组
      : private my_slist_node_traits::node
   {
      typedef my_slist_node_traits::node_ptr       node_ptr;
      typedef my_slist_node_traits::const_node_ptr const_node_ptr;

      //Converts the generic node to the hook 将普通节点转换为钩子
      static my_slist_base_hook *to_hook_ptr(node_ptr p)
      {  return static_cast<my_slist_base_hook*>(p); }

      //Returns the generic node stored by this hook
      //返回由本钩子保存的普通节点
      node_ptr to_node_ptr()
      { return static_cast<node *const>(this); }

      // More operations 更多操作
      // ...
   };

   //To make MyClass compatible with an intrusive singly linked list
   //derive our class from the hook.
   //要使得 MyClass 兼容于介入式单链表，从钩子派生我们的类
   class MyClass
      :  public my_slist_base_hook
   {
      void set(int value);
      int get() const;

      private:
      int value_;
   };

*  [*Intrusive Container]: A container that offers a STL-like interface to store
   user objects. An intrusive container can be templatized to store different
   value types that use different hooks. An intrusive container is also more elaborate
   than a group of nodes: it can store the number of elements to achieve constant-time
   size information, it can offer debugging facilities, etc.
   For example, an [classref boost::intrusive::slist slist] container 
   (intrusive singly linked list) should
   be able to hold `MyClass` objects that might have decided to store the hook
   as a base class or as a member. Internally, the container will use [*Node Algorithms]
   to implement its operations, and an intrusive container is configured using
   a template parameter called [*ValueTraits]. [*ValueTraits] will contain
   the information to convert user classes in nodes compatible with [*Node Algorithms].
   For example, this a possible [classref boost::intrusive::slist slist] implementation:\n
   [*介入式容器]：一个提供了类似于STL接口来保存用户对象的容器。介入式容器可以被模板化，
   以保存使用不同钩子的值类型。介入式容器要比一组节点更为精细：它可以保存元素的数量，
   以实现常量时间的 size 信息，它还可以提供调试工具，等等。例如，一个 [classref boost::intrusive::slist slist]
   容器(介入式单链表)可以保存 `MyClass` 对象，后者可以决定以基类方式或成员方式保存钩子。
   在容器的内部，使用 [*节点算法] 来实现各种操作，并且，介入式容器使用一个名为 [*ValueTraits] 的模板参数进行配置上。
   [*ValueTraits] 包含有一些信息，以将用户类转换为与 [*节点算法] 相兼容的节点。例如，下面是一个可能的 
   [classref boost::intrusive::slist slist] 实现：

[c++]

   template<class ValueTraits, ...>
   class slist
   {
      public:
      typedef typename ValueTraits::value_type value_type;

      //More typedefs and functions 更多 typedef 和函数
      // ...

      //Insert the value as the first element of the list
      void push_front (reference value) 
      {
         node_ptr to_insert(ValueTraits::to_node_ptr(value));
         circular_list_algorithms::link_after(to_insert, get_root_node()); 
      }

      // More operations 更多操作
      // ...
   };

*  [*Semi-Intrusive Container]: A semi-intrusive container is similar to an
   intrusive container, but apart from the values to be inserted in the container,
   it needs additional memory (for example, auxiliary arrays or indexes).\n
   [*半介入式容器]：半介入式容器类似于介入式容器，除了被插入到容器中的值以外，
   它需要额外的内存(例如，辅助数组或索引)。

*  [*Value Traits]: As we can see, to make our classes intrusive-friendly we add
   a simple hook as a member or base class. The hook contains a generic node
   that will be inserted in a group of nodes. [*Node Algorithms] just work
   with nodes and don't know anything about user classes. On the other
   hand, an intrusive container needs to know how to obtain a node from a user class,
   and also the inverse operation.   
   So we can define [*ValueTraits] as the glue between user classes and nodes
   required by [*Node Algorithms].
   Let's see a possible implementation of a value traits class that glues MyClass
   and the node stored in the hook:\n
   [*值 Traits]：正如我们可以看到的，为了让我们的类可用于介入，我们增加了一个简单的钩子，
   作为一个成员或一个基类。这个钩子包含了将被插入到节点组中的一个普通节点。[*节点算法] 只对节点操作，
   并不知晓任意关于用户类的信息。另一方面，介入式容器需要知道如何从用户类取得节点，以及相反的操作。
   因此我们可以将 [*ValueTraits] 定义为 [*节点算法] 所需的用户类与节点之间的粘合剂。
   我们来看一个可能的值 traits 类的实现，它粘合了 MyClass 和保存在钩子中的节点：

[c++]

   struct my_slist_derivation_value_traits
   {
      public:
      typedef slist_node_traits           node_traits;
      typedef MyClass                     value_type;
      typedef node_traits::node_ptr       node_ptr;
      typedef value_type*                 pointer;
      //...

      //Converts user's value to a generic node 将用户的值转换为普通节点
      static node_ptr to_node_ptr(reference value)
      { return static_cast<slist_base_hook &>(value).to_node_ptr(); }

      //Converts a generic node into user's value 将普通节点转换为用户值
      static value_type *to_value_ptr(node_traits::node *n) 
      { static_cast<value_type*>(slist_base_hook::to_hook_ptr(n)); }

      // More operations 更多操作
      // ...
   };

[endsect]

[section:node_algorithms Node algorithms with custom NodeTraits 定制化 NodeTraits 的节点算法]

As explained in the [link intrusive.concepts Concepts] section, [*Boost.Intrusive]
containers are implemented using node algorithms that work on generic nodes.\n
正如在 [link intrusive.concepts 概念] 一节中所说的，[*Boost.Intrusive] 容器是使用操作于普通节点上的节点算法来实现的。

Sometimes, the use of intrusive containers is expensive for some environments
and the programmer might want to avoid all the template instantiations
related to [*Boost.Intrusive] containers. However, the user can still benefit
from [*Boost.Intrusive] using the node algorithms, because some of those algorithms,
like red-black tree algorithms, are not trivial to write.\n
有时候，在某些环境下使用介入式容器是昂贵的，程序员也许想避免所有与 [*Boost.Intrusive] 容器相关的模板实例化。
不过，用户还是可以通过使用节点算法从 [*Boost.Intrusive] 获得好处，因为其中的某些算法还是不容易编写的，如红黑树算法。

All node algorithm classes are
templatized by a `NodeTraits` class. This class encapsulates the needed internal
type declarations and operations to make a node compatible with node algorithms.
Each type of node algorithms has its own requirements:\n
所有节点算法类都是由一个 `NodeTraits` 类来模板化的。这个类封装了所需的内部类型声明和操作，
以使得某种节点可以兼容于节点算法。每一种节点算法类型都有它自己的要求：

[section:circular_slist_algorithms Intrusive singly linked list algorithms 介入式单链表算法]

These algorithms are static
members of the [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms] class:\n
这些算法是 [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms] 类的静态成员：

[c++]

   template<class NodeTraits>
   struct circular_slist_algorithms;

An empty list is formed by a node whose pointer to the next node points
to itself. [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms]
is configured with a NodeTraits class, which encapsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:\n
空的链表由一个节点表示，它的下个节点指针指向它自己。
[classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms] 用一个 NodeTraits 类来配置，
它封装了被操纵的节点的信息。NodeTraits 必须支持以下接口：

[*Typedefs]:

*  `node`: The type of the node that forms the circular list\n
   `node`: 形成这个循环链表的节点的类型

*  `node_ptr`: The type of a pointer to a node (usually node*)\n
   `node_ptr`: 节点指针的类型(通常为 node*) 

*  `const_node_ptr`: The type of a pointer to a const node (usually const node*)\n
   `const_node_ptr`: 常量节点指针的类型(通常为 const node*) 

[*Static functions 静态函数]:

*  `static node_ptr get_next(const_node_ptr n);`:
   Returns a pointer to the next node stored in "n".\n
   `static node_ptr get_next(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的下个节点指针。

*  `static void set_next(node_ptr n, node_ptr next);`:
   Sets the pointer to the next node stored in "n" to "next".\n
   `static void set_next(node_ptr n, node_ptr next);`: 将 "n" 中的下个节点指针设置为 "next"。

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:\n
只要我们有一个节点 traits 配置，我们就可以将 [*Boost.Intrusive] 算法用于我们的节点：

[import ../example/doc_slist_algorithms.cpp]
[doc_slist_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms reference].\n
函数的完整列表，请见 [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms 参考手册]。

[endsect]

[section:circular_list_algorithms Intrusive doubly linked list algorithms 介入式双链表算法]

These algorithms are static
members of the [classref boost::intrusive::circular_list_algorithms circular_list_algorithms] class:\n
这些算法是 [classref boost::intrusive::circular_list_algorithms circular_list_algorithms] 类的静态成员：

[c++]

   template<class NodeTraits>
   struct circular_list_algorithms;

An empty list is formed by a node whose pointer to the next node points
to itself. [classref boost::intrusive::circular_list_algorithms circular_list_algorithms]
is configured with a NodeTraits class, which encapsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:\n
空的链表由一个节点表示，它的下个节点指针指向它自己。
[classref boost::intrusive::circular_list_algorithms circular_list_algorithms] 
用一个 NodeTraits 类来配置，它封装了被操纵的节点的信息。NodeTraits 必须支持以下接口：

[*Typedefs]:

*  `node`: The type of the node that forms the circular list\n
   `node`: 形成这个循环链表的节点的类型

*  `node_ptr`: The type of a pointer to a node (usually node*)\n
   `node_ptr`: 节点指针的类型(通常为 node*) 

*  `const_node_ptr`: The type of a pointer to a const node (usually const node*)\n
   `const_node_ptr`: 常量节点指针的类型(通常为 const node*)

[*Static functions 静态函数]:

*  `static node_ptr get_next(const_node_ptr n);`:
   Returns a pointer to the next node stored in "n".\n
   `static node_ptr get_next(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的下个节点指针。

*  `static void set_next(node_ptr n, node_ptr next);`:
   Sets the pointer to the next node stored in "n" to "next".\n
   `static void set_next(node_ptr n, node_ptr next);`: 将 "n" 中的下个节点指针设置为 "next"。 

*  `static node_ptr get_previous(const_node_ptr n);`:
   Returns a pointer to the previous node stored in "n".\n
   `static node_ptr get_previous(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的前个节点指针。

*  `static void set_previous(node_ptr n, node_ptr prev);`:
   Sets the pointer to the previous node stored in "n" to "prev".\n
   `static void set_previous(node_ptr n, node_ptr prev);`: 将 "n" 中的前个节点指针设置为 "prev"。 

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:\n
只要我们有一个节点 traits 配置，我们就可以将 [*Boost.Intrusive] 算法用于我们的节点：

[import ../example/doc_list_algorithms.cpp]
[doc_list_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::circular_list_algorithms circular_list_algorithms reference].\n
函数的完整列表，请见 [classref boost::intrusive::circular_list_algorithms circular_list_algorithms 参考手册]。 

[endsect]

[section:rbtree_algorithms Intrusive red-black tree algorithms 介入式红黑树算法]

These algorithms are static
members of the [classref boost::intrusive::rbtree_algorithms rbtree_algorithms] class:\n
这些算法是 [classref boost::intrusive::rbtree_algorithms rbtree_algorithms] 类的静态成员：

[c++]

   template<class NodeTraits>
   struct rbtree_algorithms;


An empty tree is formed by a node whose pointer to the parent node is null,
the left and right node pointers point to itself, and whose color is red.
[classref boost::intrusive::rbtree_algorithms rbtree_algorithms]
is configured with a NodeTraits class, which encapsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:\n
空的树由一个节点表示，它的父节点指针为 null，它的左节点和右节点指针指向它自己，且颜色为红色。
[classref boost::intrusive::rbtree_algorithms rbtree_algorithms] 用一个 NodeTraits 类来配置，
它封装了被操纵的节点的信息。NodeTraits 必须支持以下接口：

[*Typedefs]:

*  `node`: The type of the node that forms the circular rbtree\n
   `node`: 形成这个循环红黑树的节点的类型 

*  `node_ptr`: The type of a pointer to a node (usually node*)\n
   `node_ptr`: 节点指针的类型(通常为 node*) 

*  `const_node_ptr`: The type of a pointer to a const node (usually const node*)\n
   `const_node_ptr`: 常量节点指针的类型(通常为 const node*) 

*  `color`: The type that can store the color of a node\n
   `color`: 保存节点颜色的类型

[*Static functions 静态函数]:

*  `static node_ptr get_parent(const_node_ptr n);`:
   Returns a pointer to the parent node stored in "n".\n
   `static node_ptr get_parent(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的父节点指针。

*  `static void set_parent(node_ptr n, node_ptr p);`:
   Sets the pointer to the parent node stored in "n" to "p".\n
   `static void set_parent(node_ptr n, node_ptr p);`: 将 "n" 中的父节点指针设置为 "p"。 

*  `static node_ptr get_left(const_node_ptr n);`:
   Returns a pointer to the left node stored in "n".\n
   `static node_ptr get_left(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的左节点指针。

*  `static void set_left(node_ptr n, node_ptr l);`:
   Sets the pointer to the left node stored in "n" to "l".\n
   `static void set_left(node_ptr n, node_ptr l);`: 将 "n" 中的左节点指针设置为 "l"。

*  `static node_ptr get_right(const_node_ptr n);`:
   Returns a pointer to the right node stored in "n".\n
   `static node_ptr get_right(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的右节点指针。

*  `static void set_right(node_ptr n, node_ptr r);`:
   Sets the pointer to the right node stored in "n" to "r".\n
   `static void set_right(node_ptr n, node_ptr r);`: 将 "n" 中的右节点指针设置为 "r"。

*  `static color get_color(const_node_ptr n);`:
   Returns the color stored in "n".\n
   `static color get_color(const_node_ptr n);`: 返回保存在 "n" 中的颜色。

*  `static void set_color(node_ptr n, color c);`:
   Sets the color stored in "n" to "c".\n
   `static void set_color(node_ptr n, color c);`: 将 "n" 中的颜色设置为 "c"。

*  `static color black();`:
   Returns a value representing the black color.\n
   `static color black();`: 返回表示黑色的值。 

*  `static color red();`:
   Returns a value representing the red color.\n
   `static color red();`: 返回表示红色的值。

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:\n
只要我们有一个节点 traits 配置，我们就可以将 [*Boost.Intrusive] 算法用于我们的节点：

[import ../example/doc_rbtree_algorithms.cpp]
[doc_rbtree_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::rbtree_algorithms rbtree_algorithms reference].\n
函数的完整列表，请见 [classref boost::intrusive::rbtree_algorithms rbtree_algorithms 参考手册]。 

[endsect]

[section:splaytree_algorithms Intrusive splay tree algorithms 介入式 splay 树算法]

These algorithms are static
members of the [classref boost::intrusive::splaytree_algorithms splaytree_algorithms] class:\n
这些算法是 [classref boost::intrusive::splaytree_algorithms splaytree_algorithms] 类的静态成员：

[c++]

   template<class NodeTraits>
   struct splaytree_algorithms;


An empty tree is formed by a node whose pointer to the parent node is null,
and whose left and right nodes pointers point to itself.
[classref boost::intrusive::splaytree_algorithms splaytree_algorithms]
is configured with a NodeTraits class, which encapsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:\n
空的树由一个节点表示，它的父节点指针为 null，它的左节点和右节点指针指向它自己。
[classref boost::intrusive::splaytree_algorithms splaytree_algorithms] 用一个 NodeTraits 类来配置，
它封装了被操纵的节点的信息。NodeTraits 必须支持以下接口：

[*Typedefs]:

*  `node`: The type of the node that forms the circular splaytree\n
   `node`: 形成这个循环splay树的节点的类型

*  `node_ptr`: The type of a pointer to a node (usually node*)\n
   `node_ptr`: 节点指针的类型(通常为 node*) 

*  `const_node_ptr`: The type of a pointer to a const node (usually const node*)\n
   `const_node_ptr`: 常量节点指针的类型(通常为 const node*) 

[*Static functions 静态函数]:

*  `static node_ptr get_parent(const_node_ptr n);`:
   Returns a pointer to the parent node stored in "n".\n
   `static node_ptr get_parent(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的父节点指针。

*  `static void set_parent(node_ptr n, node_ptr p);`:
   Sets the pointer to the parent node stored in "n" to "p".\n
   `static void set_parent(node_ptr n, node_ptr p);`: 将 "n" 中的父节点指针设置为 "p"。

*  `static node_ptr get_left(const_node_ptr n);`:
   Returns a pointer to the left node stored in "n".\n
   `static node_ptr get_left(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的左节点指针。

*  `static void set_left(node_ptr n, node_ptr l);`:
   Sets the pointer to the left node stored in "n" to "l".\n
   `static void set_left(node_ptr n, node_ptr l);`: 将 "n" 中的左节点指针设置为 "l"。

*  `static node_ptr get_right(const_node_ptr n);`:
   Returns a pointer to the right node stored in "n".\n
   `static node_ptr get_right(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的右节点指针。

*  `static void set_right(node_ptr n, node_ptr r);`:
   Sets the pointer to the right node stored in "n" to "r".\n
   `static void set_right(node_ptr n, node_ptr r);`: 将 "n" 中的右节点指针设置为 "r"。

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:\n
只要我们有一个节点 traits 配置，我们就可以将 [*Boost.Intrusive] 算法用于我们的节点：

[import ../example/doc_splaytree_algorithms.cpp]
[doc_splaytree_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::splaytree_algorithms splaytree_algorithms reference].\n
函数的完整列表，请见 [classref boost::intrusive::splaytree_algorithms splaytree_algorithms 参考手册]。

[endsect]

[section:avltree_algorithms Intrusive avl tree algorithms 介入式 avl 树算法]

[classref boost::intrusive::avltree_algorithms avltree_algorithms] have the same
interface as [classref boost::intrusive::rbtree_algorithms rbtree_algorithms].\n
[classref boost::intrusive::avltree_algorithms avltree_algorithms] 具有与 
[classref boost::intrusive::rbtree_algorithms rbtree_algorithms] 相同的接口。

[c++]

   template<class NodeTraits>
   struct avltree_algorithms;

[classref boost::intrusive::avltree_algorithms avltree_algorithms]
is configured with a NodeTraits class, which encapsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:\n
[classref boost::intrusive::avltree_algorithms avltree_algorithms] 用一个 NodeTraits 类来配置，
它封装了被操纵的节点的信息。NodeTraits 必须支持以下接口：

[*Typedefs]:

*  `node`: The type of the node that forms the circular avltree\n
   `node`: 形成这个循环avl树的节点的类型

*  `node_ptr`: The type of a pointer to a node (usually node*)\n
   `node_ptr`: 节点指针的类型(通常为 node*) 

*  `const_node_ptr`: The type of a pointer to a const node (usually const node*)\n
   `const_node_ptr`: 常量节点指针的类型(通常为 const node*) 

*  `balance`: A type that can represent 3 balance types (usually an integer)\n
   `balance`: 表示3种平衡类型的类型(通常为整数

[*Static functions 静态函数]:

*  `static node_ptr get_parent(const_node_ptr n);`:
   Returns a pointer to the parent node stored in "n".\n
   `static node_ptr get_parent(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的父节点指针。

*  `static void set_parent(node_ptr n, node_ptr p);`:
   Sets the pointer to the parent node stored in "n" to "p".\n
   `static void set_parent(node_ptr n, node_ptr p);`: 将 "n" 中的父节点指针设置为 "p"。 

*  `static node_ptr get_left(const_node_ptr n);`:
   Returns a pointer to the left node stored in "n".\n
   `static node_ptr get_left(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的左节点指针。

*  `static void set_left(node_ptr n, node_ptr l);`:
   Sets the pointer to the left node stored in "n" to "l".\n
   `static void set_left(node_ptr n, node_ptr l);`: 将 "n" 中的左节点指针设置为 "l"。

*  `static node_ptr get_right(const_node_ptr n);`:
   Returns a pointer to the right node stored in "n".\n
   `static node_ptr get_right(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的右节点指针。

*  `static void set_right(node_ptr n, node_ptr r);`:
   Sets the pointer to the right node stored in "n" to "r".\n
   `static void set_right(node_ptr n, node_ptr r);`: 将 "n" 中的右节点指针设置为 "r"。

*  `static balance get_balance(const_node_ptr n);`:
   Returns the balance factor stored in "n".\n
   `static balance get_balance(const_node_ptr n);`: 返回保存在 "n" 中的平衡因子。

*  `static void set_balance(node_ptr n, balance b);`:
   Sets the balance factor stored in "n" to "b".\n
   `static void set_balance(node_ptr n, balance b);`: 将 "n" 中的平衡因子设置为 "b"。

*  `static balance negative();`:
   Returns a value representing a negative balance factor.\n
   `static balance negative();`: 返回表示负平衡因子的值。

*  `static balance zero();`:
   Returns a value representing a zero balance factor.\n
   `static balance zero();`: 返回表示零平衡因子的值。

*  `static balance positive();`:
   Returns a value representing a positive balance factor.\n
   `static balance positive();`: 返回表示正平衡因子的值。

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:\n
只要我们有一个节点 traits 配置，我们就可以将 [*Boost.Intrusive] 算法用于我们的节点：

[import ../example/doc_avltree_algorithms.cpp]
[doc_avltree_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::avltree_algorithms avltree_algorithms reference].\n
函数的完整列表，请见 [classref boost::intrusive::avltree_algorithms avltree_algorithms 参考手册]。

[endsect]


[section:treap_algorithms Intrusive treap algorithms 介入式 treap 算法]

[classref boost::intrusive::treap_algorithms treap_algorithms] have the same
interface as [classref boost::intrusive::rbtree_algorithms rbtree_algorithms].\n
[classref boost::intrusive::treap_algorithms treap_algorithms] 具有与 
[classref boost::intrusive::rbtree_algorithms rbtree_algorithms] 相同的接口。

[c++]

   template<class NodeTraits>
   struct treap_algorithms;

[classref boost::intrusive::treap_algorithms treap_algorithms]
is configured with a NodeTraits class, which encapsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:\n
[classref boost::intrusive::treap_algorithms treap_algorithms] 用一个 NodeTraits 类来配置，
它封装了被操纵的节点的信息。NodeTraits 必须支持以下接口：  

[*Typedefs]:

*  `node`: The type of the node that forms the circular treap\n
   `node`: 形成这个循环treap的节点的类型 

*  `node_ptr`: The type of a pointer to a node (usually node*)\n
   `node_ptr`: 节点指针的类型(通常为 node*) 

*  `const_node_ptr`: The type of a pointer to a const node (usually const node*)\n
   `const_node_ptr`: 常量节点指针的类型(通常为 const node*) 

[*Static functions 静态函数]:

*  `static node_ptr get_parent(const_node_ptr n);`:
   Returns a pointer to the parent node stored in "n".\n
   `static node_ptr get_parent(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的父节点指针。

*  `static void set_parent(node_ptr n, node_ptr p);`:
   Sets the pointer to the parent node stored in "n" to "p".\n
   `static void set_parent(node_ptr n, node_ptr p);`: 将 "n" 中的父节点指针设置为 "p"。 

*  `static node_ptr get_left(const_node_ptr n);`:
   Returns a pointer to the left node stored in "n".\n
   `static node_ptr get_left(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的左节点指针。

*  `static void set_left(node_ptr n, node_ptr l);`:
   Sets the pointer to the left node stored in "n" to "l".\n
   `static void set_left(node_ptr n, node_ptr l);`: 将 "n" 中的左节点指针设置为 "l"。 

*  `static node_ptr get_right(const_node_ptr n);`:
   Returns a pointer to the right node stored in "n".\n
   `static node_ptr get_right(const_node_ptr n);`: 返回一个指针，指向保存在 "n" 中的右节点指针。

*  `static void set_right(node_ptr n, node_ptr r);`:
   Sets the pointer to the right node stored in "n" to "r".\n
   `static void set_right(node_ptr n, node_ptr r);`: 将 "n" 中的右节点指针设置为 "r"。 

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:\n
只要我们有一个节点 traits 配置，我们就可以将 [*Boost.Intrusive] 算法用于我们的节点：

[import ../example/doc_treap_algorithms.cpp]
[doc_treap_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::treap_algorithms treap_algorithms reference].\n
函数的完整列表，请见 [classref boost::intrusive::treap_algorithms treap_algorithms 参考手册]。 

[endsect]


[/
/
/[section:sgtree_algorithms Intrusive sg tree algorithms]
/
/
/[classref boost::intrusive::sgtree_algorithms sgtree_algorithms] have the same
/interface as [classref boost::intrusive::rbtree_algorithms rbtree_algorithms].
/
/[c++]
/
/   template<class NodeTraits>
/   struct sgtree_algorithms;
/
/[classref boost::intrusive::sgtree_algorithms sgtree_algorithms]
/is configured with a NodeTraits class, which encapsulates 
/the information about the node to be manipulated. NodeTraits must support the
/following interface:
/
/[*Typedefs]:
/
/*  `node`: The type of the node that forms the circular sgtree
/
/*  `node_ptr`: The type of a pointer to a node (usually node*)
/
/*  `const_node_ptr`: The type of a pointer to a const node (usually const node*)
/
/[*Static functions]:
/
/*  `static node_ptr get_parent(const_node_ptr n);`:
/   Returns a pointer to the parent node stored in "n".
/
/*  `static void set_parent(node_ptr n, node_ptr p);`:
/   Sets the pointer to the parent node stored in "n" to "p".
/
/*  `static node_ptr get_left(const_node_ptr n);`:
/   Returns a pointer to the left node stored in "n".
/
/*  `static void set_left(node_ptr n, node_ptr l);`:
/   Sets the pointer to the left node stored in "n" to "l".
/
/*  `static node_ptr get_right(const_node_ptr n);`:
/   Returns a pointer to the right node stored in "n".
/
/*  `static void set_right(node_ptr n, node_ptr r);`:
/   Sets the pointer to the right node stored in "n" to "r".
/
/Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
/with our nodes:
/
/[import ../example/doc_sgtree_algorithms.cpp]
/[doc_sgtree_algorithms_code]
/
/For a complete list of functions see
/[classref boost::intrusive::sgtree_algorithms sgtree_algorithms reference].
/
/[endsect]
/]
[endsect]

[section:value_traits Containers with custom ValueTraits 带定制化 ValueTraits 的容器]

As explained in the [link intrusive.concepts Concepts] section, [*Boost.Intrusive]
containers need a `ValueTraits` class to perform transformations between nodes and
user values. `ValueTraits` can be explicitly configured (using the `value_traits<>` option)
or implicitly configured (using hooks and their `base_hook<>`/`member_hook<>` options).
`ValueTraits` contains
all the information to glue the `value_type` of the containers and the node to be
used in node algorithms, since these types can be different. Apart from this,
`ValueTraits` also stores information about the link policy of the values to be inserted.\n
正如在 [link intrusive.concepts 概念] 一节所说的，[*Boost.Intrusive] 容器需要一个 `ValueTraits`
类来执行节点与用户值之间的转换。`ValueTraits` 可以显式配置(使用 `value_traits<>` 选项)或隐式配置
(使用钩子和它们的 `base_hook<>`/`member_hook<>` 选项)。`ValueTraits` 包含了用于将容器的 `value_type`
与节点算法中所使用的节点粘合起来的所有信息，因为这两种类型是不同的。除此之外，`ValueTraits` 
还保存了有关被插入的值的链接策略的信息。

Instead of using [*Boost.Intrusive] predefined hooks
a user might want to develop customized containers, for example, using nodes that are
optimized for a specific
application or that are compatible with a legacy ABI. A user might want
to have only two additional pointers in his class and insert the class in a doubly
linked list sometimes and in a singly linked list in other situations. You can't
achieve this using [*Boost.Intrusive] predefined hooks. Now, instead of using
`base_hook<...>` or `member_hook<...>` options the user will specify the
`value_traits<...>` options. Let's see how we can do this:\n
用户可能不想使用 [*Boost.Intrusive] 预定义的钩子，而想开发定制化的容器，例如，
使用一些为特定应用优化的节点，或者是兼容于遗留ABI的节点。用户可能只是想为他的类增加两个指针，
并且有时将这个类插入到一个双链表中，有时又插入到一个单链表中。你不能用 [*Boost.Intrusive] 
预定义的钩子来完成这一任务。现在，不要使用 `base_hook<...>` 或 `member_hook<...>` 选项，
用户要给出 `value_traits<...>` 选项。我们来看看该怎样做： 

[section:value_traits_interface ValueTraits interface  ValueTraits 接口]

`ValueTraits` has the following interface:\n
`ValueTraits` 具有以下接口：

[c++]

   #include <boost/pointer_to_other.hpp>
   #include <boost/intrusive/link_mode.hpp>

   struct my_value_traits
   {
      typedef implementation_defined                                    node_traits;
      typedef implementation_defined                                    value_type;
      typedef node_traits::node_ptr                                     node_ptr;
      typedef node_traits::const_node_ptr                               const_node_ptr;
      typedef boost::pointer_to_other<node_ptr, value_type>::type       pointer;
      typedef boost::pointer_to_other<node_ptr, const value_type>::type const_pointer;

      static const link_mode_type link_mode = some_linking_policy;

      static node_ptr       to_node_ptr    (value_type &value);
      static const_node_ptr to_node_ptr    (const value_type &value);
      static pointer        to_value_ptr   (node_ptr n);
      static const_pointer  to_value_ptr   (const_node_ptr n);
   };

Let's explain each type and function:\n
我们来解释一下各个类型和函数：

*  [*['node_traits]]: The node configuration that is needed by node algorithms.
   These node traits and algorithms are
   described in the previous chapter: [link intrusive.node_algorithms Node Algorithms].\n
   [*['node_traits]]: 节点算法所需的节点配置信息。这些节点 traits 和算法在前面的章节中已有说明：
   [link intrusive.node_algorithms 节点算法]。

   *  If my_value_traits is meant to be used with [classref boost::intrusive::slist slist],
      `node_traits` should follow
      the interface needed by [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms].\n
      如果 my_value_traits 打算要用于 [classref boost::intrusive::slist slist]，则 `node_traits` 
      应遵循 [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms] 所需的接口。

   *  If my_value_traits is meant to be used with [classref boost::intrusive::list list],
      `node_traits` should follow
      the interface needed by [classref boost::intrusive::circular_list_algorithms circular_list_algorithms].\n
      如果 my_value_traits 打算要用于 [classref boost::intrusive::list list]，则 `node_traits` 
      应遵循 [classref boost::intrusive::circular_list_algorithms circular_list_algorithms] 所需的接口。

   *  If my_value_traits is meant to be used with [classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset],
      `node_traits` should follow
      the interface needed by [classref boost::intrusive::rbtree_algorithms rbtree_algorithms].\n
      如果 my_value_traits 打算要用于 [classref boost::intrusive::set set]/[classref boost::intrusive::multiset multiset]，
      则 `node_traits` 应遵循 [classref boost::intrusive::rbtree_algorithms rbtree_algorithms] 所需的接口。

   *  If my_value_traits is meant to be used with [classref boost::intrusive::unordered_set unordered_set]/
      [classref boost::intrusive::unordered_multiset unordered_multiset], `node_traits`
      should follow the interface needed by [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms].\n
      如果 my_value_traits 打算要用于 [classref boost::intrusive::unordered_set unordered_set]/
      [classref boost::intrusive::unordered_multiset unordered_multiset]，则 `node_traits` 应遵循 
      [classref boost::intrusive::circular_slist_algorithms circular_slist_algorithms] 所需的接口。

*  [*['node_ptr]]: A typedef for `node_traits::node_ptr`.\n
   [*['node_ptr]]: node_traits::node_ptr 的 typedef。

*  [*['const_node_ptr]]: A typedef for `node_traits::const_node_ptr`.\n
   [*['const_node_ptr]]: `node_traits::const_node_ptr` 的 typedef。 
   
*  [*['value_type]]: The type that the user wants to insert in the container. This type can be
   the same as `node_traits::node` but it can be different (for example, `node_traits::node`
   can be a member type of `value_type`). If `value_type` and `node_traits::node` are the
   same type, the `to_node_ptr` and `to_value_ptr` functions are trivial.\n
   [*['value_type]]: 用户想要插入到容器中的类型。该类型可以与 `node_traits::node` 相同，也可以不同
   (例如，`node_traits::node` 可以是 `value_type` 的一个成员类型)。如果 `value_type` 和 `node_traits::node` 
   为相同类型，则 `to_node_ptr` 和 `to_value_ptr` 函数就是平凡的。 
   
*  [*['pointer]]: The type of a pointer to a `value_type`. It must be the same pointer type
   as `node_ptr`: If `node_ptr` is `node*`, `pointer` must be `value_type*`. If
   `node_ptr` is `smart_ptr<node_traits::node>`, `pointer` must be `smart_ptr<value_type>`.
   This can be generically achieved using `boost::pointer_to_other` utility from [*Boost SmartPointers]
   defined in `<boost/pointer_to_other.hpp>`.\n
   [*['pointer]]: `value_type` 的指针类型。它必须是与 `node_ptr` 相同的指针类型：如果 `node_ptr` 为 `node*`，
   则 `pointer` 必须是 `value_type*`。如果 `node_ptr` 是 `smart_ptr<node_traits::node>`，则 `pointer` 必须是 
   `smart_ptr<value_type>`。这可以用 [*Boost SmartPointers] 中的 `boost::pointer_to_other` 工具来泛型地实现，
   其定义在 `<boost/pointer_to_other.hpp>`。 
   
*  [*['const_pointer]]: The type of a pointer to a `const value_type`. It must be the same pointer type
   as `node_ptr`: If `node_ptr` is `node*`, `const_pointer` must be `const value_type*`. If
   `node_ptr` is `smart_ptr<node_traits::node>`, `const_pointer` must be `smart_ptr<const value_type>`
   This can be generically achieved using `boost::pointer_to_other` utility from [*Boost SmartPointers]
   defined in `<boost/pointer_to_other.hpp>`.\n
   [*['const_pointer]]: `const value_type` 的指针类型。它必须是与 `node_ptr` 相同的指针类型：
   如果 `node_ptr` 为 `node*`，则 `const_pointer` 必须是 `const value_type*`。如果 `node_ptr` 
   是 `smart_ptr<node_traits::node>`，则 `const_pointer` 必须是 `smart_ptr<const value_type>`。
   这可以用 [*Boost SmartPointers] 中的 `boost::pointer_to_other` 工具来泛型地实现，
   其定义在 `<boost/pointer_to_other.hpp>`。
     
*  [*['link_mode]]: Indicates that `value_traits` needs some additional work or checks from the
   container. The types are enumerations defined in the `link_mode.hpp` header.
   These are the possible types:\n
   [*['link_mode]]: 表示 `value_traits` 需要来自容器的其它工作或检查。该类型是枚举类型，
   定义于 `link_mode.hpp` 头文件。有以下可能的类型： 

   *  [*`normal_link`]: If this linking policy is specified in a `ValueTraits` class
      as the link mode, containers
      configured with such `ValueTraits` won't set the hooks
      of the erased values to a default state. Containers also won't
      check that the hooks of the new values are default initialized.\n
      [*`normal_link`]: 如果在一个 `ValueTraits` 类中指定此链接策略为链接模式，那么以这个 `ValueTraits` 
      配置的容器不会将移除值的钩子设置为缺省状态。容器也不会检查某个新值的钩子是否为缺省初始化。

   *  [*`safe_link`]: If this linking policy is specified as the link mode 
      in a `ValueTraits` class, containers
      configured with this `ValueTraits` will set the hooks
      of the erased values to a default state. Containers also will
      check that the hooks of the new values are default initialized.\n
      [*`safe_link`]: 如果在一个 `ValueTraits` 类中指定此链接策略为链接模式，
      那么以这个 `ValueTraits` 配置的容器将会把移除值的钩子设置为缺省状态。
      容器也会检查新值的钩子是否为缺省初始化。

   *  [*`auto_unlink`]: Same as "safe_link" but containers with
      constant-time size features won't be
      compatible with `ValueTraits` configured with this policy.
      Containers also know that a value can be silently erased from
      the container without using any function provided by the containers.\n
      [*`auto_unlink`]: 与 "safe_link" 相同，但是带有常量时间 size 函数的容器不兼容于以此策略配置的 
      `ValueTraits`。容器也将得知它所含的值可以不通过容器所提供的函数就被悄悄地移除。

*  [*['static node_ptr to_node_ptr (value_type &value)]] and
   [*['static const_node_ptr to_node_ptr (const value_type &value)]]:
   These functions take a reference to a value_type and return a pointer to the node
   to be used with node algorithms.\n
   [*['static node_ptr to_node_ptr (value_type &value)]] and
   [*['static const_node_ptr to_node_ptr (const value_type &value)]]: 这两个函数接受一个 
   value_type 的引用，返回一个可用于节点算法的、指向该节点的指针。

*  [*['static pointer to_value_ptr (node_ptr n)]] and
   [*['static const_pointer to_value_ptr (const_node_ptr n)]]:
   These functions take a pointer to a node and return a pointer to the value
   that contains the node.\n
   [*['static pointer to_value_ptr (node_ptr n)]] and
   [*['static const_pointer to_value_ptr (const_node_ptr n)]]: 这两个函数接受一个节点指针，
   返回指向包含该节点的值的指针。

[endsect]

[section:value_traits_example Custom ValueTraits example  定制化 ValueTraits 的例子]

Let's define our own `value_traits` class to be able to use [*Boost.Intrusive]
containers with an old C structure whose definition can't be changed. 
That legacy type has two pointers that can be used to build singly and doubly linked
lists: in singly linked lists we only need a pointer, whereas in doubly
linked lists, we need two pointers. Since we only have two pointers, we can't insert
the object in both a singly and a doubly linked list at the same time. 
This is the definition of the old node:\n
下面我们用一个不可修改定义的、旧的C结构来定义一个我们自己的、可用于 [*Boost.Intrusive] 
的 `value_traits` 类。这个旧的类型有两个指针可用于构建单链表和双链表：在单链表中我们只需要一个指针，
而在双链表中我们需要两个指针。因为我们只有两个指针，所以我们不能将这个对象同时插入到一个单链表和一个双链表中。
以下是旧节点结构的定义：

[import ../example/doc_value_traits.cpp]
[doc_value_traits_code_legacy]

Now we have to define a NodeTraits class that will implement the functions/typedefs
that will make the legacy node compatible with [*Boost.Intrusive] algorithms. After that,
we'll define a ValueTraits class that will configure [*Boost.Intrusive] containers:\n
现在我们必须定义一个 NodeTraits 类来实现一些函数和 typedefs，以使得这个旧节点可以兼容于 
[*Boost.Intrusive] 的算法。之后，我们将定义一个 ValueTraits 类，用于配置 [*Boost.Intrusive] 容器：

[doc_value_traits_value_traits]

Defining a value traits class that simply defines `value_type` as 
`legacy_node_traits::node` is a common approach when defining customized
intrusive containers, so [*Boost.Intrusive] offers a templatized
[classref boost::intrusive::trivial_value_traits trivial_value_traits] class
that does exactly what we want:\n
在定义定制化的介入式容器时，定义一个值 traits 类，并将其中的 `value_type` 
简单地定义为 `legacy_node_traits::node` 是一个常见的方法，因此 [*Boost.Intrusive] 
提供了一个模板化的 [classref boost::intrusive::trivial_value_traits trivial_value_traits] 
类来完成我们想要做的事情：

[c++]
   
   #include <boost/intrusive/trivial_value_traits.hpp>

   //Now we can define legacy_value_traits just with a single line
   //现在我们可以只用一行来定义 legacy_value_traits
   using namespace boost::intrusive;
   typedef trivial_value_traits<legacy_node_traits, normal_link> legacy_value_traits;
   

Now we can just define the containers that will store the legacy abi objects and write
a little test:\n
现在我们可以定义保存这个传统 abi 对象的容器并编写一个小的测试：

[doc_value_traits_test]

As seen, several key elements of [*Boost.Intrusive] can be reused with custom user types,
if the user does not want to use the provided [*Boost.Intrusive] facilities.\n
可见，[*Boost.Intrusive] 的多个关键元素都可以重用于用户类型，如果用户不想使用已提供的 [*Boost.Intrusive] 工具。

[endsect]

[section:reusing_node_algorithms Reusing node algorithms for different values  为不同值重用节点算法]

In the previous example, `legacy_node_traits::node` type and
`legacy_value_traits::value_type` are the same type, but this is not necessary. It's possible
to have several `ValueTraits` defining the same `node_traits` type (and thus, the same `node_traits::node`).
This reduces the number of node algorithm instantiations, but 
now `ValueTraits::to_node_ptr` and `ValueTraits::to_value_ptr` functions need to offer
conversions between both types. Let's see a small example:\n
在前面的例子中，`legacy_node_traits::node` 类型和 `legacy_value_traits::value_type` 是同一个类型，
但这不是必需的。可以有多个 `ValueTraits` 都定义相同的 `node_traits` 类型(即，相同的 `node_traits::node`)。
这减少了节点算法实例化的数量，不过现在 `ValueTraits::to_node_ptr` 和 `ValueTraits::to_value_ptr` 
函数必须提供两种类型之间的转换。我们来看一个小例子：

First, we'll define the node to be used in the algorithms. For a linked list,
we just need a node that stores two pointers:\n
首先，我们定义要在算法中使用的节点。对于一个链表而言，我们只需要一个保存两个指针的节点：

[import ../example/doc_advanced_value_traits.cpp]
[doc_advanced_value_traits_code]

Now we'll define two different types that will be inserted in intrusive lists and
a templatized `ValueTraits` that will work for both types:\n
现在，我们来定义两个要插入到介入式链表中的不同类型，以及一个与这两个类型一起使用的模板化 `ValueTraits`：

[doc_advanced_value_traits_value_traits]

Now define two containers. Both containers will instantiate the same list algorithms
(`circular_list_algorithms<simple_node_traits>`),
due to the fact that the value traits used to define the containers provide the same `node_traits` type:\n
现在再定义两个容器。这两个容器都将实例化同一个链表算法(`circular_list_algorithms<simple_node_traits>`)，
因为用于定义这两个容器的值 traits 实际上提供了同一个 `node_traits` 类型：

[doc_advanced_value_traits_containers]

All [*Boost.Intrusive] containers using predefined hooks use this technique to minimize code size:
all possible [classref boost::intrusive::list list] containers
created with predefined hooks that define the same `VoidPointer` type
share the same list algorithms.\n
所有使用预定义钩子的 [*Boost.Intrusive] 容器都使用了这一技巧来最小化代码的大小：以定义了相同的 `VoidPointer` 
类型的预定义钩子所创建出来的所有可能的 [classref boost::intrusive::list list] 容器都共享同一个链表算法。

[endsect]

[section:simplifying_value_traits Simplifying value traits definition 简化 value traits 的定义]

The previous example can be further simplified using the
[classref boost::intrusive::derivation_value_traits derivation_value_traits]
class to define a value traits class with a value that stores the
`simple_node` as a base class:\n
前面的例子还可以进一步简化，用 [classref boost::intrusive::derivation_value_traits derivation_value_traits] 
类来为将 `simple_node` 作为基类保存的值定义 value traits 类：

[c++]

   #include <boost/intrusive/derivation_value_traits.hpp>

   //value_1, value_2, simple_node and simple_node_traits are defined
   //as in the previous example...
   //和前面的例子一样，定义 value_1, value_2, simple_node 和 simple_node_traits
   //...

   using namespace boost::intrusive;

   //Now define the needed value traits using 
   //现在定义所需的 value traits
   typedef derivation_value_traits<value_1, simple_node_traits, normal_link> ValueTraits1;
   typedef derivation_value_traits<value_2, simple_node_traits, normal_link> ValueTraits2;

   //Now define the containers 现在定义容器
   typedef list <value1, value_traits<ValueTraits1> > Value1List;
   typedef list <value2, value_traits<ValueTraits2> > Value2List;

We can even choose to store `simple_node` as a member of `value_1` and `value_2`
classes and use [classref boost::intrusive::member_value_traits member_value_traits]
to define the needed value traits classes:\n
我们甚至可以选择将 `simple_node` 作为 `value_1` 和 `value_2` 类的成员来保存，并使用 
[classref boost::intrusive::member_value_traits member_value_traits] 来定义所需的 value traits 类：

[import ../example/doc_advanced_value_traits2.cpp]
[doc_advanced_value_traits2_value_traits]

[endsect]

[section:stateful_value_traits Stateful value traits 有状态的 value traits]

Until now all shown custom value traits are stateless, that is, [*the transformation between nodes
and values is implemented in terms of static functions]. It's possible to use [*stateful] value traits
so that we can separate nodes and values and [*avoid modifying types to insert nodes].
[*Boost.Intrusive] differentiates between stateful and stateless value traits by checking if all
Node <-> Value transformation functions are static or not (except for Visual 7.1, since overloaded 
static function detection is not possible, in this case the implementation checks if the class is empty):\n
到目前为止，所有看到的定制化 value traits 都是无状态的，即[*节点与值之间的转换是以静态函数来实现的]。
我们也可以使用[*有状态的] value traits，这样我们就可以把节点和值独立开，并[*避免修改类型以插入节点]。
[*Boost.Intrusive] 是通过检查是否所有 节点 <-> 值 变换函数都是静态的来区分有状态和无状态的 value traits 的
(除了 Visual 7.1, 因为重载静态函数的检测是不可用的，这时我们会检查该类是否为空)：

*  If all Node <-> Value transformation functions are static , a [*stateless]
   value traits is assumed.  transformations must be static functions.\n
   如果所有 节点 <-> 值 转换函数都是静态的，则假设为 [*无状态] value traits。
   转换必须是静态函数。
*  Otherwise a [*stateful] value traits is assumed.\n
   否则假设为 [*有状态] value traits。

Using stateful value traits it's possible to create containers of non-copyable/movable objects [*without modifying]
the definition of the class to be inserted. This interesting property is achieved without using global variables
(stateless value traits could use global variables to achieve the same goal), so:\n
使用有状态的 value traits，可以创建不可复制/不可移动对象的容器，而[*无需修改]被插入类的定义。
这个有趣的特性无需使用全局变量即可实现(无状态 value traits 可以通过使用全局变量实现相同的目标)，因此：

*  [*Thread-safety guarantees]: Better thread-safety guarantees can be achieved with stateful
   value traits, since accessing global resources might require synchronization primitives that
   can be avoided when using internal state.\n
   [*线程安全性保证]：使用有状态 value traits 可以实现更好的线程安全性保证，
   因为访问全局变量有可能需要同步原语，而使用内部状态则可以避免它。
*  [*Flexibility]: A stateful value traits type can be configured at run-time.\n
   [*灵活性]：有状态 value traits 类型可以在运行期进行配置。
*  [*Run-time polymorphism]: A value traits might implement node <-> value
   transformations as virtual functions. A single container type could be
   configured at run-time to use different node <-> value relationships.\n
   [*运行期多态]：value traits 可以将节点 <-> 值的转换实现为虚拟函数。
   一个容器类型可以在运行期配置为使用不同的 节点 <-> 值 关系。

Stateful value traits have many advantages but also some downsides:\n
有状态的 value traits 具有很多优点，但是也有缺点：

*  [*Performance]: Value traits operations should be very efficient since they are basic operations used by containers.
   [*A heavy node <-> value transformation will hurt intrusive containers' performance].\n
   [*性能]：Value traits 操作应该是非常高效的，因为它们是容器要使用的基本操作。
   [*一个笨重的 节点 <-> 值 转换会损害介入式容器的性能]。
*  [*Exception guarantees]: The stateful ValueTraits must maintain no-throw guarantees, otherwise, the
   container invariants won't be preserved.\n
   [*异常安全性]：有状态 ValueTraits 必须提供无抛出的保证，否则容器的不变式将得不到保护。
*  [*Static functions]: Some static functions offered by intrusive containers are not
   available because node <-> value transformations are not static.\n
   [*静态函数]：介入式容器提供的某些静态函数将会无效，因为 节点 <-> 值 的转换是非静态的。
*  [*Bigger iterators]: The size of some iterators is increased because the iterator
   needs to store a pointer to the stateful value traits to implement node to value
   transformations (e.g. `operator*()` and `operator->()`).\n
   [*更大的迭代器]：有些迭代器的大小将有所增加，因为迭代器需要保存一个指向有状态 value traits 
   的指针以实现节点到值的转换(如 `operator*()` 和 `operator->()`)。

An easy and useful example of stateful value traits is when an array of values can be indirectly introduced
in a list guaranteeing no additional allocation apart from the initial resource reservation:\n
有状态 value traits 的一个简易且有用的例子是，将一个值数组间接地传入到链表中，且保证除了初始的资源保留以外，
没有其它的内存分配：

[import ../example/doc_stateful_value_traits.cpp]
[doc_stateful_value_traits]

[endsect]

[endsect]

[section:thread_safety Thread safety guarantees  线程安全性保证]

Intrusive containers have thread safety guarantees similar to STL containers.\n
介入式容器具有与STL容器相似的线程安全性保证。

*  Several threads having read or write access to different instances is safe as long as inserted
   objects are different.\n
   多个线程同时对不同实例进行读写访问是安全的，只要被插入的对象是不同的。
*  Concurrent read-only access to the same container is safe.\n
   对同一个容器进行并发的只读访问是安全的。

Some Intrusive hooks (auto-unlink hooks, for example) modify containers without
having a reference to them: this is considered a write access to the container.\n
有一些介入式钩子(如自断钩子)可以在没有容器的引用的情况下修改容器：这被视为对容器进行写访问。

Other functions, like checking if an object is already inserted in a container using the `is_linked()`
member of safe hooks, constitute read access on the container without having a reference to it, so no other
thread should have write access (direct or indirect) to that container.\n
其它函数，如使用安全钩子的 `is_linked()` 成员函数检查某个对象是否已被插入到容器中，形成了没有容器引用的读访问，
因此其它线程不能对该容器进行写访问(直接或间接)。

Since the same object can be inserted in several containers at the same time using different hooks,
the thread safety of [*Boost.Intrusive] is related to the containers and also to the object whose lifetime
is manually managed by the user.\n
因为同一个对象可以同时被使用不同的钩子插入到多个容器中，所以 [*Boost.Intrusive] 的线程安全性既与容器有关，
也与由用户手工管理生存期的对象有关。

As we can see, the analysis of the thread-safety of a program using [*Boost.Intrusive] is harder
than with non-intrusive containers.\n
如我们所见，一个使用 [*Boost.Intrusive] 的程序的线程安全性分析要比使用非介入式容器困难。

To analyze the thread safety, consider the following points:\n
要分析线程安全性，考虑以下方面：

*  The auto-unlink hook's destructor and `unlink()` functions modify the container indirectly.\n
   自断钩子的析构函数和 `unlink()` 函数会间接修改容器。
*  The safe mode and auto-unlink hooks' `is_linked()` functions are a read access to the container.\n
   安全模式钩子和自断钩子的 `is_linked()` 函数是对容器的读访问。
*  Inserting an object in containers that will be modified by different threads has no thread safety
   guarantee, although in most platforms it will be thread-safe without locking.\n
   向一个会被其它线程修改的容器插入对象是没有线程安全性保证的，虽然在多数平台上，它是无锁定线程安全的。

[endsect]

[section:obtaining_same_type_reducing_space Obtaining the same types and reducing symbol length 获得相同类型以及缩短符号长度]

The flexible option specification mechanism used by [*Boost.Intrusive] for hooks and containers
has a couple of downsides:\n
[*Boost.Intrusive] 对钩子和容器所使用的灵活的选项说明机制有两个缺点：

*  If a user specifies the same options in different order or specifies some options and leaves the
   rest as defaults, the type of the created container/hook will be different. Sometimes
   this is annoying, because two programmers specifying the same options might end up with incompatible
   types. For example, the following two lists, although using the same options, do not have
   the same type:\n
   如果以不同的顺序指定相同的选项，或者指定一些选项而保留其它选项为缺省值，那么所创建的容器/钩子将是不同的。
   有时候这是很讨厌的，因为两个指定了相同选项的程序员可能最终得到的是不兼容的类型。例如，
   以下两个链表虽然使用了相同的选项，却不是相同的类型：

[c++]

   #include <boost/intrusive/list.hpp>

   using namespace boost::intrusive;

   //Explicitly specify constant-time size and size type
   //显式指定常量时间的 size 和 size 类型
   typedef list<T, constant_time_size<true>, size_type<std::size_t> List1;

   //Implicitly specify constant-time size and size type
   //隐式指定常量时间的 size 和 size 类型
   typedef list<T> List2;
   
*  Option specifiers lead to long template symbols for classes and functions. Option specifiers themselves
   are verbose and without variadic templates, several default template parameters are assigned for
   non-specified options. Object and debugging information files can grow and compilation times
   may suffer if long names are produced.\n
   选项规格说明导致了类和函数的超长模板符号。选项规格说明本身是冗长的且无变长模板的，
   对于未指定的选项要赋予缺省的模板参数。如果产生了长名字，那么目标文件和调试信息文件会变大，编译时间也会变久。

To solve these issues [*Boost.Intrusive] offers some helper metafunctions that reduce symbol lengths
and create the same type if the same options (either explicitly or implicitly) are used. These also
improve compilation times. All containers and hooks have their respective `make_xxx` versions.
The previously shown example can be rewritten like this to obtain the same list type:\n
为解决这些问题，[*Boost.Intrusive] 提供了一些辅助元函数来缩短符号长度，并且在使用相同选项(不论显式或隐式)时创建相同的类型。
这样也可以加快编译的时间。所有的容器和钩子都具有各自的 `make_xxx` 版本。前面所示的例子可以如下重写，以获得相同的 list 类型：


[c++]

  #include <boost/intrusive/list.hpp>

   using namespace boost::intrusive;

   #include <boost/intrusive/list.hpp>

   using namespace boost::intrusive;

   //Explicitly specify constant-time size and size type
   //显式指定常量时间的 size 和 size 类型 
   typedef make_list<T, constant_time_size<true>, size_type<std::size_t>::type List1;

   //Implicitly specify constant-time size and size type
   //隐式指定常量时间的 size 和 size 类型
   typedef make_list<T>::type List2;

Produced symbol lengths and compilation times will usually be shorter and object/debug files smaller.
If you are concerned with file sizes and compilation times, this option is your best choice.\n
这样所产生的符号长度和编译时间通常都更短，目标文件和调试文件也更小。如果你关注文件的大小和编译时间，这是你最好的选择。

[endsect]

[section:design_notes Design Notes 设计说明]

When designing [*Boost.Intrusive] the following guidelines have been taken into account:\n
在设计 [*Boost.Intrusive] 时，下列准则已被考虑到：

[section: Boost.Intrusive in performance sensitive environments 性能敏感环境下的 Boost.Intrusive]

[*Boost.Intrusive] should be a valuable tool in performance sensitive environments,
and following this guideline, [*Boost.Intrusive] has been designed to offer well
known complexity guarantees. Apart from that, some options, like optional 
constant-time, have been designed to offer faster complexity guarantees in some
functions, like `slist::splice`.\n
[*Boost.Intrusive] 应该是性能敏感环境下的一个有用的工具，依据这一准则，[*Boost.Intrusive] 
被设计为提供众所周知的时间复杂度保证。除此以外，还设计了一些选项，如可选的常量时间，
以为某些函数提供更快的时间复杂度保证，如 `slist::splice`。

The advanced lookup and insertion functions for associative containers, taking
an arbitrary key type and predicates, were designed to avoid unnecessary object
constructions.\n
关联容器的高级查找和高级插入函数，接受任意的键值类型和谓词，这一设计是为了避免不必要的对象构造。

[endsect]

[section: Boost.Intrusive in space constrained environments 空间受限环境下的 Boost.Intrusive]

[*Boost.Intrusive] should be useful in space constrained environments,
and following this guideline [*Boost.Intrusive] separates node algorithms
and intrusive containers to avoid instantiating node algorithms for each
user type. For example, a single class of red-black algorithms will be instantiated
to implement all set and multiset containers using raw pointers. This way,
[*Boost.Intrusive] seeks to avoid any code size overhead associated with templates.\n
[*Boost.Intrusive] 在空间受限环境下应该是有用的，依据这一准则，[*Boost.Intrusive] 
分离了节点算法和介入式容器，以避免为每个用户类型实例化节点算法。例如，只实例化一个红黑树算法类，
就可以实现所有使用裸指针的 set 和 multiset 容器。使用这一方式，[*Boost.Intrusive] 
避免了与模板相关的任何代码空间的开销。 

Apart from that, [*Boost.Intrusive] implements some size improvements: for example,
red-black trees embed the color bit in the parent pointer lower bit, if nodes
are two-byte aligned. The option to forgo constant-time size operations can
reduce container size, and this extra size optimization is noticeable
when the container is empty or contains few values.\n
此外，[*Boost.Intrusive] 实现了一些空间改进：例如，如果节点是双字节对齐的，
红黑树就将颜色位嵌入到父指针的低位。放弃常量时间的 size 操作的选项可以缩小容器的大小，
当容器为空或只包含少量值的时间，这个空间优化是很显著的。

[endsect]

[section: Boost.Intrusive as a basic building block 作为基本构建块的 Boost.Intrusive]

[*Boost.Intrusive] can be a basic building block to build more complex containers
and this potential has motivated many design decisions. For example, the ability
to have more than one hook per user type opens the opportunity to implement multi-index
containers on top of [*Boost.Intrusive].\n
[*Boost.Intrusive] 可以被作为基本构建块来构建更为复杂的容器，这一潜能已经推动了许多设计决定。
例如，每个用户类型可以具有多个钩子就提供了在 [*Boost.Intrusive] 之上实现多索引容器的机会。

[*Boost.Intrusive] containers implement advanced functions taking function objects
as arguments (`clone_from`, `erase_and_dispose`, `insert_check`, etc.). These
functions come in handy when implementing non-intrusive containers
(for example, STL-like containers) on top of intrusive containers.\n
[*Boost.Intrusive] 容器实现了以函数对象为参数的高级函数(`clone_from`, `erase_and_dispose`, 
`insert_check`, 等等)。当要在介入式容器之上实现非介入式容器(如类似于STL的容器)时，
这些函数就非常方便使用。

[endsect]

[section: Extending Boost.Intrusive 扩展 Boost.Intrusive]

[*Boost.Intrusive] offers a wide range of containers but also allows the
construction of custom containers reusing [*Boost.Intrusive] elements.
The programmer might want to use node algorithms directly or
build special hooks that take advantage of an application environment.\n
[*Boost.Intrusive] 提供了大量的容器，但是也允许重用 [*Boost.Intrusive] 元素来构造定制化的容器。
程序员可能想直接使用节点算法，或者构建利用应用程序环境的特殊钩子。 

For example, the programmer can customize parts of [*Boost.Intrusive]
to manage old data structures whose definition can't be changed.\n
例如，程序员可以定制化 [*Boost.Intrusive] 的一部分，以管理那些不能修改定义的旧数据结构。

[endsect]

[endsect]

[section:performance Performance 性能]

[*Boost.Intrusive] containers offer speed improvements compared to non-intrusive containers
primarily because:\n
[*Boost.Intrusive] 容器与非介入式容器相比，提高了速度，主要是因为：

*  They minimize memory allocation/deallocation calls.\n
   它们最小化了对内存分配/释放的调用。
*  They obtain better memory locality.\n
   它们有更好的内存局部化。

This section will show performance tests comparing some operations on 
`boost::intrusive::list` and `std::list`:\n
这一节将展示在 `boost::intrusive::list` 和 `std::list` 之上的一些操作的性能测试比较： 

*  Insertions using `push_back` and container destruction will show the
   overhead associated with memory allocation/deallocation.\n
   用 `push_back` 进行插入，以及析构容器，展示与内存分配/释放相关的开销。
*  The `reverse` member function will show the advantages of the compact
   memory representation that can be achieved with intrusive containers.\n
   `reverse` 成员函数将展示由介入式容器所实现的紧凑内存表示的好处。
*  The `sort` and `write access` tests will show the advantage of intrusive containers
   minimizing memory accesses compared to containers of pointers.\n
   `sort` 和 `write access` 测试将展示介入式容器与指针容器相比，在最小化内存访问方面的优势。

Given an object of type `T`, [classref boost::intrusive::list boost::intrusive::list<T>]
can replace `std::list<T>` to avoid memory allocation overhead,
or it can replace `std::list<T*>` when the user wants containers with
polymorphic values or wants to share values between several containers.
Because of this versatility, the performance tests will be executed for 6 different
list types:\n
给定一个类型为 `T` 的对象，[classref boost::intrusive::list boost::intrusive::list<T>] 
可以替代 `std::list<T>`，以避免内存分配的开销，在用户希望容器保存多态值或者想在多个容器间共享保存的值时，
则可以替代 `std::list<T*>`。因为这种多功能性，以下的性能测试将对6种不同的链表类型进行测试： 

*  3 intrusive lists holding a class named `itest_class`,
   each one with a different linking policy (`normal_link`, `safe_link`, `auto_unlink`).
   The `itest_class` objects will be tightly packed in a `std::vector<itest_class>` object.\n
   3种保存名为 `itest_class` 的类的介入式链表，每种具有不同的链接策略(`normal_link`, `safe_link`, 
   `auto_unlink`)。所有 `itest_class` 对象被紧密地压缩在一个 `std::vector<itest_class>` 对象中。

*  `std::list<test_class>`, where `test_class` is exactly the same as `itest_class`,
   but without the intrusive hook.\n
   `std::list<test_class>`，其中 `test_class` 与 `itest_class` 相同，但没有介入式钩子。 

*  `std::list<test_class*>`. The list will contain pointers to `test_class` objects
   tightly packed in a `std::vector<test_class>` object. We'll call this configuration ['compact pointer list]\n
   `std::list<test_class*>`。该链表将包含有指向被紧密压缩在一个 `std::vector<test_class>` 
   对象中的 `test_class` 对象的指针。我们把这一配置称为 ['紧凑指针链表]。

*  `std::list<test_class*>`. The list will contain pointers to `test_class` objects owned by a
   `std::list<test_class>` object. We'll call this configuration ['disperse pointer list].\n
   `std::list<test_class*>`。该链表将包含有指向被一个 `std::list<test_class>` 对象所拥有的 
   `test_class` 对象的指针。我们把这一配置称为 ['松散指针链表]。

Both `test_class` and `itest_class` are templatized classes that can be configured with
a boolean to increase the size of the object. This way, the tests can be executed with
small and big objects. Here is the first part of the testing code, which shows
the definitions of `test_class` and `itest_class` classes, and some other
utilities:\n
`test_class` 和 `itest_class` 都是模板化类，它们可以用一个布尔值来配置以增加对象的大小。
这样，测试可以分别对小对象和大对象执行。以下是测试代码的开始部分，展示了 `test_class` 和 
`itest_class` 类的定义，以及一些其它工具：

[import ../perf/perf_list.cpp]
[perf_list_value_type]

As we can see, `test_class` is a very simple class holding an `int`. `itest_class`
is just a class that has a base hook ([classref boost::intrusive::list_base_hook list_base_hook])
and also derives from `test_class`.\n
正如我们看到的，`test_class` 是一个非常简单的类，它持有一个 `int`。`itest_class` 
则只是一个带有基类钩子([classref boost::intrusive::list_base_hook list_base_hook]) 
且派生自 `test_class` 的类。

`func_ptr_adaptor` is just a functor adaptor to convert function objects taking
`test_list` objects to function objects taking pointers to them.\n
`func_ptr_adaptor` 是一个函数对象适配器，将一个接受 `test_list` 对象的函数对象转换为接受对象指针的函数对象。

You can find the full test code code in the 
[@../../libs/intrusive/perf/perf_list.cpp perf_list.cpp] source file.\n
你可以在 [@../../libs/intrusive/perf/perf_list.cpp perf_list.cpp] 源文件中找到完整的测试代码。

[section:performance_results_push_back Back insertion and destruction 后端插入和析构]

The first test will measure the benefits we can obtain with intrusive containers
avoiding memory allocations and deallocations. All the objects to be
inserted in intrusive containers are allocated in a single allocation call,
whereas `std::list` will need to allocate memory for each object and deallocate it
for every erasure (or container destruction).\n
第一个测试将测量由于介入式容器避免了内存分配和释放而获得的优势。
所有被插入到介入式容器中的对象都是在一次内存分配调用中分配的，而 `std::list` 
则需要为每一个对象分配一次内存，并为每一次删除(或是容器的析构)释放一次内存。

Let's compare the code to be executed for each container type for different insertion tests:\n
我们来比较一下对于各种容器类型、对于各种不同的插入测试所要执行的代码：

[perf_list_push_back_intrusive]

For intrusive containers, all the values are created in a vector and after that
inserted in the intrusive list.\n
对于介入式容器，所有值在一个 vector 中创建，稍后被插入到介入式链表中。

[perf_list_push_back_stdlist]

For a standard list, elements are pushed back using push_back().\n
对于标准 list，使用 push_back() 将元素插入到后端。

[perf_list_push_back_stdptrlist]

For a standard compact pointer list, elements are created in a vector and pushed back
in the pointer list using push_back().\n
对于标准的紧凑指针链表，元素在一个 vector 中创建，并用 push_back() 插入到指针链表的后端。

[perf_list_push_back_disperse_stdptrlist]

For a ['disperse pointer list], elements are created in a list and pushed back
in the pointer list using push_back().\n
对于 ['松散指针链表]，元素在一个 list 中创建，并用 push_back() 插入到指针链表的后端。

These are the times in microseconds for each case, and the normalized time:\n
以下是在各种情况下测试得到的毫秒时间，以及规格化时间：

[table Back insertion + destruction times 后端插入 + 析构的时间, for Visual C++ 7.1 / Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list\n`normal_link` 介入式链表]     [5000 / 22500]                        [1 / 1]]
    [[`safe_link` intrusive list\n`safe_link` 介入式链表]       [7812 / 32187]                        [1.56 / 1.43]]
    [[`auto_unlink` intrusive list\n`auto_unlink` 介入式链表]     [10156 / 41562]                       [2.03 / 1.84]]
    [[Standard list\n标准链表]                    [76875 / 97500]                       [5.37 / 4.33]]
    [[Standard compact pointer list\n标准的紧凑指针链表]    [76406 / 86718]                      [15.28 / 3.85]]
    [[Standard disperse pointer list\n标准的松散指针链表]  [146562 / 175625]                     [29.31 / 7.80]]
]

[table Back insertion + destruction times 后端插入 + 析构的时间, for GCC 4.1.1 / MinGW over Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [4375 / 22187]                  [1 / 1]]
    [[`safe_link` intrusive list]       [7812 / 32812]                  [1.78 / 1.47]]
    [[`auto_unlink` intrusive list]     [10468 / 42031]                 [2.39 / 1.89]]
    [[Standard list]                    [81250 / 98125]                [18.57 / 4.42]]
    [[Standard compact pointer list]    [83750 / 94218]                [19.14 / 4.24]]
    [[Standard disperse pointer list]  [155625 / 175625]                [35.57 / 7.91]]
]

[table Back insertion + destruction times 后端插入 + 析构的时间, for GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [4792 / 20495]                  [1 / 1]]
    [[`safe_link` intrusive list]       [7709 / 30803]                  [1.60 / 1.5]]
    [[`auto_unlink` intrusive list]     [10180 / 41183]                 [2.12 / 2.0]]
    [[Standard list]                    [17031 / 32586]                 [3.55 / 1.58]]
    [[Standard compact pointer list]    [27221 / 34823]                 [5.68 / 1.69]]
    [[Standard disperse pointer list]  [102272 / 60056]                [21.34 / 2.93]]
]

The results are logical: intrusive lists just need one allocation. The destruction
time of the `normal_link` intrusive container is trivial (complexity: `O(1)`),
whereas `safe_link` and `auto_unlink` intrusive containers need to put the hooks of
erased values in the default state (complexity: `O(NumElements)`). That's why
`normal_link` intrusive list shines in this test.\n
结果是符合逻辑的：介入式链表只需要一次内存分配。`normal_link` 介入式容器的析构时间是平凡的
(复杂度：`O(1)`)，而 `safe_link` 和 `auto_unlink` 介入式容器则需要将被移除值的钩子设置为缺省状态
(复杂度：`O(NumElements)`)。这正是 `normal_link` 介入式链表在这个测试中胜出的原因。

Non-intrusive containers need to make many more allocations and that's why they
lag behind. The `disperse pointer list` needs to make `NumElements*2` allocations,
so the result is not surprising.\n
非介入式容器需要进行多次的内存分配，这正是它们落在后面的原因。`disperse pointer list` 
需要进行 `NumElements*2` 次分配，所以结果并不意外。

The Linux test shows that standard containers perform very well against intrusive containers
with big objects. Nearly the same GCC version in MinGW performs worse, so maybe
a good memory allocator is the reason for these excellent results.\n
Linux 上的测试显示，对于大的对象，标准容器和介入式容器一样好。而在 MinGW 平台上的相近版本的 GCC 
则较差，因此也许一个好的内存分配器是这一卓越结果的原因。

[endsect]

[section:performance_results_reversing Reversing 反序]

The next test measures the time needed to complete calls to the member function `reverse()`.
Values (`test_class` and `itest_class`) and lists are created as explained in the
previous section.\n
下一个测试测量完成对成员函数 `reverse()` 的调用所需的时间。值(`test_class` 和 `itest_class`)
和链表同样是按上一节所说的那样创建。

Note that for pointer lists, `reverse` [*does not need to access `test_class` values
stored in another list or vector],
since this function just needs to adjust internal pointers, so in theory all tested
lists need to perform the same operations.\n
注意，对于指针链表，`reverse` [*并不需要访问保存在另一个 list 或 vector 中的 `test_class` 值]，
因为该函数只需调整内部的指针，所以理论上所有被测试的链表都只需完成相同的操作。

These are the results:\n
结果如下：

[table Reverse times 反序时间，for Visual C++ 7.1 / Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [2656 / 10625]                 [1 / 1.83]]
    [[`safe_link` intrusive list]       [2812 / 10937]                 [1.05 / 1.89]]
    [[`auto_unlink` intrusive list]     [2710 / 10781]                 [1.02 / 1.86]]
    [[Standard list]                    [5781 / 14531]                 [2.17 / 2.51]]
    [[Standard compact pointer list]    [5781 / 5781]                  [2.17 / 1]]
    [[Standard disperse pointer list]  [10781 / 15781]                 [4.05 / 2.72]]
]

[table Reverse times 反序时间，for GCC 4.1.1 / MinGW over Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [2656 / 10781]                 [1 / 2.22]]
    [[`safe_link` intrusive list]       [2656 / 10781]                 [1 / 2.22]]
    [[`auto_unlink` intrusive list]     [2812 / 10781]                 [1.02 / 2.22]]
    [[Standard list]                    [4843 / 12500]                 [1.82 / 2.58]]
    [[Standard compact pointer list]    [4843 / 4843]                  [1.82 / 1]]
    [[Standard disperse pointer list]   [9218 / 12968]                 [3.47 / 2.67]]
]

[table Reverse times 反序时间，for GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [2742 / 10847]                 [1 / 3.41]]
    [[`safe_link` intrusive list]       [2742 / 10847]                 [1 / 3.41]]
    [[`auto_unlink` intrusive list]     [2742 / 11027]                 [1 / 3.47]]
    [[Standard list]                    [3184 / 10942]                 [1.16 / 3.44]]
    [[Standard compact pointer list]    [3207 / 3176]                  [1.16 / 1]]
    [[Standard disperse pointer list]   [5814 / 13381]                 [2.12 / 4.21]]
]

For small objects the results show that the compact storage of values in intrusive
containers improve locality and reversing is faster than with standard containers,
whose values might be dispersed in memory because each value is independently
allocated. Note that the dispersed pointer list (a list of pointers to values
allocated in another list) suffers more because nodes of the pointer list
might be more dispersed, since allocations from both lists are interleaved
in the code:\n
对于小对象，介入式容器中的值的紧凑存储提高了局部性，其反序操作比标准容器快一些，
标准容器的值可能会松散分布在内存中，因为它的每一个值都是独立分配的。注意，
松散指针链表(其值在另一个 list 中分配的指针链表)更差一些，因为该指针链表的节点可能更加分散，
在代码中的两个链表的分配是交错的：

[c++]

   //Object list (holding `test_class`) 对象链表(保存 `test_class`)
   stdlist objects;

   //Pointer list (holding `test_class` pointers) 指针链表(保存 `test_class` 指针)
   stdptrlist l;

   for(int i = 0; i < NumElements; ++i){
      //Allocation from the object list 从对象链表分配
      objects.push_back(stdlist::value_type(i));
      //Allocation from the pointer list 从指针链表分配
      l.push_back(&objects.back());
   }

For big objects the compact pointer list wins because the reversal test doesn't need access
to values stored in another container. Since all the allocations for nodes of
this pointer list are likely to be close (since there is no other allocation in the
process until the pointer list is created) locality is better than with intrusive
containers. The dispersed pointer list, as with small values, has poor locality.\n
对于大对象，紧凑指针链表胜出，因为反序测试无需访问保存在另一个容器中的值。
由于这个指针链表的节点的所有分配可能非常靠近(因为在该指针链表创建完成之前没有其它的分配)，
其局部性比介入式容器更好。和小对象的情况一样，松散指针链表具有较差的局部性。

[endsect]

[section:performance_results_sorting Sorting 排序]

The next test measures the time needed to complete calls to the member function
`sort(Pred pred)`. Values (`test_class` and `itest_class`) and lists are created as explained in the
first section. The values will be sorted in ascending and descending order each
iteration. For example, if ['l] is a list:\n
下一个测试测量完成对成员函数 `sort(Pred pred)` 的调用所需的时间。值(`test_class` 和 `itest_class`)
和链表同样是按第一节所说的那样创建。在每次循环中，这些值将以升序和降序排序。例如，如果 ['l] 为一个链表：

[c++]

   for(int i = 0; i < NumIter; ++i){
      if(!(i % 2))
         l.sort(std::greater<stdlist::value_type>());
      else
         l.sort(std::less<stdlist::value_type>());
   }

For a pointer list, the function object will be adapted using `func_ptr_adaptor`:\n
对于指针链表，将使用 `func_ptr_adaptor` 对函数对象进行适配：

[c++]

   for(int i = 0; i < NumIter; ++i){
      if(!(i % 2))
         l.sort(func_ptr_adaptor<std::greater<stdlist::value_type> >());
      else
         l.sort(func_ptr_adaptor<std::less<stdlist::value_type> >());
   }

Note that for pointer lists, `sort` will take a function object that [*will access
`test_class` values stored in another list or vector], so pointer lists will suffer
an extra indirection: they will need to access the `test_class` values stored in
another container to compare two elements.\n
注意，对于指针链表，`sort` 将接受一个[*要访问保存在另一个 list 或 vector 中的 `test_class` 值]的函数对象，
所以指针链表需要多一个间接层：它们需要访问保存在另一个容器中的 `test_class` 值来比较两个元素。

These are the results:\n
结果如下：

[table Sort times 排序时间，for Visual C++ 7.1 / Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [16093 / 38906]                [1 / 1]]
    [[`safe_link` intrusive list]       [16093 / 39062]                [1 / 1]]
    [[`auto_unlink` intrusive list]     [16093 / 38906]                [1 / 1]]
    [[Standard list]                    [32343 / 56406]                [2.0 / 1.44]]
    [[Standard compact pointer list]    [33593 / 46093]                [2.08 / 1.18]]
    [[Standard disperse pointer list]   [46875 / 68593]                [2.91 / 1.76]]
]

[table Sort times 排序时间，for GCC 4.1.1 / MinGW over Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [15000 / 39218]                [1 / 1]]
    [[`safe_link` intrusive list]       [15156 / 39531]                [1.01 / 1.01]]
    [[`auto_unlink` intrusive list]     [15156 / 39531]                [1.01 / 1.01]]
    [[Standard list]                    [34218 / 56875]                [2.28 / 1.45]]
    [[Standard compact pointer list]    [35468 / 49218]                [2.36 / 1.25]]
    [[Standard disperse pointer list]   [47656 / 70156]                [3.17 / 1.78]]
]

[table Sort times 排序时间，for GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [18003 / 40795]                [1 / 1]]
    [[`safe_link` intrusive list]       [18003 / 41017]                [1 / 1]]
    [[`auto_unlink` intrusive list]     [18230 / 40941]                [1.01 / 1]]
    [[Standard list]                    [26273 / 49643]                [1.45 / 1.21]]
    [[Standard compact pointer list]    [28540 / 43172]                [1.58 / 1.05]]
    [[Standard disperse pointer list]   [35077 / 57638]                [1.94 / 1.41]]
]

The results show that intrusive containers are faster than standard
containers. We can see that the pointer
list holding pointers to values stored in a vector is quite fast, so the extra
indirection that is needed to access the value is minimized because all the values
are tightly stored, improving caching. The disperse list, on the other hand, is
slower because the indirection to access values stored in the object list is
more expensive than accessing values stored in a vector.\n
结果显示，介入式容器快于标准容器。我们可以看到，持有保存在 vector 的值的指针的指针链表速度很快，
访问值时所需的额外间接性是最小的，因为所有的值被紧密保存，这提升了缓存的作用。另一方面，
松散链表较慢，因为访问保存在 list 中的值的间接性要比访问保存在 vector 中值耗费更多。

[endsect]

[section:performance_results_write_access Write access 写访问]

The next test measures the time needed to iterate through all the elements of a list, and
increment the value of the internal `i_` member:\n
下一个测试测量遍历一个链表中所有元素所需的时间，并将内部的 `i_` 成员的值加一：

[c++]

   stdlist::iterator it(l.begin()), end(l.end());
   for(; it != end; ++it)
      ++(it->i_);

Values (`test_class` and `itest_class`) and lists are created as explained in
the first section. Note that for pointer lists, the iteration will suffer
an extra indirection: they will need to access the `test_class` values stored in
another container:\n
值(`test_class` 和 `itest_class`)和链表同样是按第一节所说的那样创建。注意，对于指针链表，
遍历操作需要多一个间接层：它们需要访问保存在另一个容器中的 `test_class` 值：

[c++]

   stdptrlist::iterator it(l.begin()), end(l.end());
   for(; it != end; ++it)
      ++((*it)->i_);

These are the results:\n
结果如下：

[table Write access times 写访问时间，for Visual C++ 7.1 / Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [2031 / 8125]                 [1 / 1]]
    [[`safe_link` intrusive list]       [2031 / 8281]                 [1 / 1.01]]
    [[`auto_unlink` intrusive list]     [2031 / 8281]                 [1 / 1.01]]
    [[Standard list]                    [4218 / 10000]                [2.07 / 1.23]]
    [[Standard compact pointer list]    [4062 / 8437]                 [2.0 / 1.03]]
    [[Standard disperse pointer list]   [8593 / 13125]                [4.23 / 1.61]]
]

[table Write access times 写访问时间，for GCC 4.1.1 / MinGW over Windows XP
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [2343 / 8281]                 [1 / 1]]
    [[`safe_link` intrusive list]       [2500 / 8281]                 [1.06 / 1]]
    [[`auto_unlink` intrusive list]     [2500 / 8281]                 [1.06 / 1]]
    [[Standard list]                    [4218 / 10781]                [1.8 / 1.3]]
    [[Standard compact pointer list]    [3906 / 8281]                 [1.66 / 1]]
    [[Standard disperse pointer list]   [8281 / 13750]                [3.53 / 1.66]]
]

[table Write access times 写访问时间，for GCC 4.1.2 / Linux Kernel 2.6.18 (OpenSuse 10.2)
    [[Container\n容器]                       [Time in us/iteration (small object / big object)\n毫秒/次循环 (小对象/大对象) 
] [Normalized time (small object / big object)\n规格化时间 (小对象/大对象)]]
    [[`normal_link` intrusive list]     [2286 / 8468]                 [1 / 1.1]]
    [[`safe_link` intrusive list]       [2381 / 8412]                 [1.04 / 1.09]]
    [[`auto_unlink` intrusive list]     [2301 / 8437]                 [1.01 / 1.1]]
    [[Standard list]                    [3044 / 9061]                 [1.33 / 1.18]]
    [[Standard compact pointer list]    [2755 / 7660]                 [1.20 / 1]]
    [[Standard disperse pointer list]   [6118 / 12453]                [2.67 / 1.62]]
]

As with the read access test, the results show that intrusive containers outperform
all other containers if the values are tightly packed in a vector.
The disperse list is again the slowest.\n
和读访问测试一样，结果显示如果元素值是紧密压缩在一个 vector 中的话，介入式容器要比所有其它容器都好。
松散链表又一次成为最慢的。

[endsect]

[section:performance_results_conclusions Conclusions 结论]

Intrusive containers can offer performance benefits that cannot be achieved with
equivalent non-intrusive containers. Memory locality improvements are noticeable
when the objects to be inserted are small. Minimizing memory allocation/deallocation calls is also
an important factor and intrusive containers make this simple if the user allocates
all the objects to be inserted in intrusive containers in containers like `std::vector` or `std::deque`.\n
介入式容器可以提供对等的非介入式容器不能实现的性能优势。当插入的对象较小时，内存局部性的提升是显著的。
内存分配和释放调用的次数最小化也是一个重要的因素，如果用户将要插入到介入式容器中的所有对象分配到一个象 
`std::vector` 或 `std::deque` 的容器中，那么介入式容器就很简单了。

[endsect]

[endsect]

[section:release_notes Release Notes 发布说明]

[section:release_notes_boost_1_40_00 Boost 1.40 Release]

*  Code cleanup in tree_algorithms.hpp and avl_tree_algorithms.hpp\n
   tree_algorithms.hpp 和 avl_tree_algorithms.hpp 中的代码清理 
*  Fixed bug
  [@https://svn.boost.org/trac/boost/ticket/3164 #3164].\n
  修复缺陷 [@https://svn.boost.org/trac/boost/ticket/3164 #3164].

[endsect]


[section:release_notes_boost_1_39_00 Boost 1.39 Release]

*  Optimized `list::merge` and `slist::merge`\n
   经过优化的 `list::merge` 和 `slist::merge` 
*  `list::sort` and `slist::sort` are now stable.\n
   `list::sort` 和 `slist::sort` 现在是稳定的。
*  Fixed bugs
  [@https://svn.boost.org/trac/boost/ticket/2689 #2689],
  [@https://svn.boost.org/trac/boost/ticket/2755 #2755],
  [@https://svn.boost.org/trac/boost/ticket/2786 #2786],
  [@https://svn.boost.org/trac/boost/ticket/2807 #2807],
  [@https://svn.boost.org/trac/boost/ticket/2810 #2810],
  [@https://svn.boost.org/trac/boost/ticket/2862 #2862].\n
  修复缺陷 [@https://svn.boost.org/trac/boost/ticket/2689 #2689],
  [@https://svn.boost.org/trac/boost/ticket/2755 #2755],
  [@https://svn.boost.org/trac/boost/ticket/2786 #2786],
  [@https://svn.boost.org/trac/boost/ticket/2807 #2807],
  [@https://svn.boost.org/trac/boost/ticket/2810 #2810],
  [@https://svn.boost.org/trac/boost/ticket/2862 #2862].

[endsect]

[section:release_notes_boost_1_38_00 Boost 1.38 Release]

*  New treap-based containers: treap, treap_set, treap_multiset.\n
   新增了基于 treap 的容器：treap, treap_set, treap_multiset.
*  Corrected compilation bug for Windows-based 64 bit compilers.\n
   修正了基于Windows的64位编译器上的编译缺陷。
*  Corrected exception-safety bugs in container constructors.\n
   修正了容器构造函数中的异常安全性。
*  Updated documentation to show rvalue-references functions instead of emulation functions.\n
   更新了文档，反映了右值引用函数对仿真函数的替代。

[endsect]

[section:release_notes_boost_1_37_00 Boost 1.37 Release]

*  Intrusive now takes advantage of compilers with variadic templates.\n
   伸入式容器现在可以利用支持可变数量模板的编译器。
*  `clone_from` functions now copy predicates and hash functions of associative containers.\n
   `clone_from` 函数现在会复制关联容器的谓词和散列函数。
*  Added incremental hashing to unordered containers via `incremental<>` option.\n
   通过 `incremental<>` 选项为无序容器增加了递增散列。
*  Update some function parameters from `iterator` to `const_iterator` in containers
   to keep up with the draft of the next standard.\n
   将容器中一些函数参数由 `iterator` 改为 `const_iterator` 以符合下一标准的草案。
*  Added an option to specify include files for intrusive configurable assertion macros.\n  
   增加一个选项，为介入式的可配置断言宏包含头文件。

[endsect]

[section:release_notes_boost_1_36_00 Boost 1.36 Release]

*  Added `linear<>` and `cache_last<>` options to singly linked lists.\n
   单链表增加了 `linear<>` 和 `cache_last<>` 选项。
*  Added `optimize_multikey<>` option to unordered container hooks.\n
   无序容器钩子增加了 `optimize_multikey<>` 选项。
*  Optimized unordered containers when `store_hash` option is used in the hook.\n
   当在钩子中使用 `store_hash` 选项时，对无序容器进行优化。
*  Implementation changed to be exception agnostic so that it can be used
   in environments without exceptions.\n
   实现改为异常不可知的，以便可在无异常的环境中使用。
*  Added `container_from_iterator` function to tree-based containers.\n
   基于树的容器增加了 `container_from_iterator` 函数。

[endsect]

[endsect]

[section:tested_compilers Tested compilers 已测试的编译器]

[*Boost.Intrusive] has been tested on the following compilers/platforms:\n
[*Boost.Intrusive] 已经在以下编译器/平台上测试： 

*  Visual 7.1/WinXP
*  Visual 8.0/WinXP
*  Visual 9.0/WinXP
*  GCC 4.1.1/MinGW
*  GCC 3.4.4/Cygwin
*  Intel 9.1/WinXP
*  GCC 4.1.2/Linux
*  GCC 3.4.3/Solaris 11
*  GCC 4.0/Mac Os 10.4.1

[endsect]

[section:references References 参考资料]

* SGI's [@http://www.sgi.com/tech/stl/ STL Programmer's Guide].
   [*Boost.Intrusive] is based on STL concepts and interfaces.\n
   SGI 的 [@http://www.sgi.com/tech/stl/ STL 程序员指南]。[*Boost.Intrusive] 是基于 STL 的概念和接口的。

* Dr. Dobb's, September 1, 2005: [@http://www.ddj.com/architect/184402007 ['Implementing Splay Trees in C++] ].
   [*Boost.Intrusive] splay containers code is based on this article.\n
   Dr. Dobb's, September 1, 2005: [@http://www.ddj.com/architect/184402007 ['在 C++ 中实现 Splay 树]]。
   [*Boost.Intrusive] 的 splay 容器代码基于此论文。

* Olaf's original intrusive container library: [@http://freenet-homepage.de/turtle++/intrusive.html ['STL-like intrusive containers] ].\n
   Olaf 原来的介入式容器库：[@http://freenet-homepage.de/turtle++/intrusive.html ['类似于 STL 的介入式容器]]。

[endsect]

[section:acknowledgements Acknowledgements 鸣谢]

[*Olaf Krzikalla] would like to thank:

*  [*Markus Schaaf] for pointing out the possibility and the advantages of the derivation 
approach. 

*  [*Udo Steinbach] for encouragements to present this work for boost, a lot of fixes and
helpful discussions. 

*  [*Jaap Suter] for the initial hint, which eventually lead to the member value_traits.

[*Ion Gaztanaga] would like to thank:

*  [*Olaf Krzikalla] for the permission to continue his great work.

*  [*Joaquin M. Lopez Munoz] for his thorough review, help, and ideas.

*  [*Cory Nelson], [*Daniel James], [*Dave Harris], [*Guillaume Melquiond],
   [*Henri Bavestrello], [*Herv茅 Bronnimann], [*Kai Bruning], [*Kevin Sopp],
   [*Paul Rose], [*Pavel Vozelinek], [*Howard Hinnant], [*Olaf Krzikalla],
   [*Samuel Debionne], [*Stjepan Rajko], [*Thorsten Ottosen], [*Tobias Schwinger],
   [*Tom Brinkman] and [*Steven Watanabe]
   for their comments and reviews in the Boost.Intrusive formal review.

*  Thanks to [*Julienne Walker] and [*The EC Team] ([@http://eternallyconfuzzled.com])
   for their great algorithms.

*  Thanks to [*Daniel K. O.] for his AVL tree rebalancing code.

*  Thanks to [*Ralf Mattethat] for his splay tree article and code.

*  Special thanks to [*Steven Watanabe] and [*Tobias Schwinger] for their
   invaluable suggestions and improvements.

[endsect]

[xinclude autodoc.xml]

[section:license_notices License notices 许可证说明]

Most of the internal implementation of red-black trees is based on that of SGI STL stl_tree.h file:

['Copyright (c) 1996,1997 Silicon Graphics Computer Systems, Inc. 
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Silicon Graphics makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty.]

['Copyright (c) 1994 Hewlett-Packard Company 
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Hewlett-Packard Company makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty.]

The tree destruction algorithm is based on Julienne Walker and The EC Team code:

['This code is in the public domain. Anyone may
use it or change it in any way that they see
fit. The author assumes no responsibility for 
damages incurred through use of the original
code or any variations thereof.]

['It is requested, but not required, that due
credit is given to the original author and
anyone who has modified the code through
a header comment, such as this one.]

[endsect]

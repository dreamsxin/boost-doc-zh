<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html><head>



  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">




  
  
  
  
  
  <title>Boost.MultiIndex Documentation - Tutorial - Index types</title><link rel="stylesheet" href="../style.css" type="text/css">



  
  
  <link rel="start" href="../index.html">



  
  
  <link rel="prev" href="basics.html">



  
  
  <link rel="up" href="index.html">



  
  
  <link rel="next" href="key_extraction.html"></head>

<body>



<h1><img src="../../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">Boost.MultiIndex 指南: 索引类型</h1>




<div class="prev_link"><a href="basics.html"><img src="../prev.gif" alt="basics" border="0"><br>



Basics基础
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex tutorial" border="0"><br>



Boost.MultiIndex 指南
</a></div>



<div class="next_link"><a href="key_extraction.html"><img src="../next.gif" alt="key estraction" border="0"><br>



Key extraction键提取
</a></div>


<br style="" clear="all">




<hr>

<h2>Contents目录</h2>




<ul>



  <li><a href="#classification">Classification分类</a>
  </li>


  <li><a href="#hashed_indices">Hashed indices散列索引</a>
    
    
    
    <ul>



      <li><a href="#hash_unique_non_unique">Unique and non-unique variants</a><a href="#hash_unique_non_unique">唯一与非唯一的区别</a></li>



      <li><a href="#hash_spec">Specification</a><a href="#hash_spec">规范</a></li>



      <li><a href="#hash_lookup">Lookup</a><a href="#hash_lookup">查找</a></li>



      <li><a href="#hash_updating">Updating</a><a href="#hash_updating">更新</a></li>



      <li><a href="#guarantees">Guarantees on iterator validity and exception safety</a><a href="#guarantees">迭代器有效性与异常安全性的保证</a></li>



    
    
    
    </ul>



  </li>



  <li><a href="#rnd_indices">Random access indices随机访问索引</a>
    
    
    
    <ul>



      <li><a href="#rnd_spec">Specification规范</a></li>



	  <li><a href="#rnd_interface">Interface接口</a></li>



      <li><a href="#rnd_vs_vector">Comparison with <code>std::vector 与std::vector的比较</code></a></li>



	
    
    
    </ul>



  </li>



  <li><a href="#rearrange">Index rearranging索引重排</a></li>
  <li><a href="#iterator_to"><code>iterator_to</code></a></li>



  <li><a href="#ordered_node_compression">Ordered indices node compression有序索引节点的压缩</a></li>



</ul>




<h2><a name="classification">Classification分类</a></h2>




<p>
Boost.MultiIndex 提供了六种不同的索引类型，分类与下表所示。<a href="basics.html#ord_indices">Ordered有序索引</a> 和
<a href="basics.html#seq_indices">sequenced序列索引</a> 是最常使用的，在“基础”一节中已经解释过了；其它索引类型可看作是提供了更多优点、功能或性能的变体。
</p>




<p align="center">
</p>


<table cellspacing="0">



  <caption><b>Boost.MultiIndex 索引</b></caption>
  <tbody>


    <tr>



  <th colspan="2" align="center">类型</th>



  <th align="center">详细说明</th>



    </tr>



    <tr>



  <td rowspan="4" align="center">&nbsp; 基于键的 &nbsp;</td>



  <td rowspan="2" align="center">&nbsp; 有序的 &nbsp;</td>



  <td align="center">&nbsp;&nbsp;<code>ordered_unique</code> 有序唯一&nbsp;</td>



    </tr>



    <tr class="odd_tr">



  <td align="center">&nbsp;&nbsp;<code>ordered_non_unique</code> 有序非唯一&nbsp;</td>



    </tr>



    <tr>



  <td rowspan="2" align="center">&nbsp; 散列的 &nbsp;</td>



  <td align="center">&nbsp;&nbsp;<code>hashed_unique</code> 散列唯一&nbsp;</td>



    </tr>



    <tr class="odd_tr">



  <td align="center">&nbsp;&nbsp;<code>hashed_non_unique</code> 散列非唯一&nbsp;</td>



    </tr>



    <tr>



  <td rowspan="2" colspan="2" align="center">&nbsp; 非基于键的 &nbsp;</td>



  <td align="center"><code>&nbsp;&nbsp;sequenced 序列&nbsp;</code></td>



    </tr>



    <tr class="odd_tr">



  <td align="center"><code>&nbsp;&nbsp;random_access 随机访问&nbsp;</code></td>



    </tr>


  
  
  </tbody>
</table>





<p>基于键的索引，其中有序索引是最常见的，基于称为<span style="font-style: italic;">元素键</span>的信息片断提供了高效的元素查找操作：有一个
<a href="key_extraction.html">key extraction</a>
工具类的扩展套件可用于指定这个键。快速查找需要对索引加以内部管理，所以不允许用户修改索引；另一方面，非基于键的索引则可随意进行重排而不会影响查找。以 <code>std::list 的接口建模</code>的序列索引<code>，是</code>非基于键的索引的常用例子。
</p>




<h2><a name="hashed_indices">Hashed indices散列索引</a></h2>




<p>散列索引与有序索引互有优劣：如果使用正确，它可以提供更快的元素查找操作，但将牺牲排序的信息。我们再来看看 <code>employee_set</code> 
的例子：假设加入了一个保存社会保险号的字段，而且对此号码的查找操作要求尽可能地快。我们需要使用散列索引，而不是有序索引：
</p>




<blockquote>
  
  
  <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index_container</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">hashed_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">ordered_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">identity</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">member</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">employee</span>
<span class="special">{</span>
  <span class="keyword">int</span>         <span class="identifier">id</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">;</span>
  <span class="keyword">int</span>         <span class="identifier">ssnumber</span><span class="special">;</span>

  <span class="identifier">employee</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">id</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">,</span><span class="keyword">int</span> <span class="identifier">ssnumber</span><span class="special">):</span>
    <span class="identifier">id</span><span class="special">(</span><span class="identifier">id</span><span class="special">),</span><span class="identifier">name</span><span class="special">(</span><span class="identifier">name</span><span class="special">),</span><span class="identifier">ssnumber</span><span class="special">(</span><span class="identifier">ssnumber</span><span class="special">){}</span>

  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">employee</span><span class="special">&amp;</span> <span class="identifier">e</span><span class="special">)</span><span class="keyword">const</span><span class="special">{</span><span class="keyword">return</span> <span class="identifier">id</span><span class="special">&lt;</span><span class="identifier">e</span><span class="special">.</span><span class="identifier">id</span><span class="special">;}</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span>
  <span class="identifier">employee</span><span class="special">,</span>
  <span class="identifier">indexed_by</span><span class="special">&lt;</span>
    <span class="comment">// </span><span class="comment">按 employee::operator&lt; 排序</span><span class="comment"></span>
    <span class="identifier">ordered_unique</span><span class="special">&lt;</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
    
    <span class="comment">// </span><span class="comment">对name按 less&lt;string&gt; 排序</span><span class="comment"></span>
    <span class="identifier">ordered_non_unique</span><span class="special">&lt;</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">name</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
    
    <span class="comment">// </span><span class="comment">对ssnumber散列</span><span class="comment"></span>
    <span class="identifier">hashed_unique</span><span class="special">&lt;</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">,</span><span class="keyword">int</span><span class="special">,&amp;</span><span class="identifier">employee</span><span class="special">::</span><span class="identifier">ssnumber</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">&gt;</span>
<span class="special">&gt;</span> <span class="identifier">employee_set</span>
  </pre>


</blockquote>




<p>
</p>


<p>注意，散列索引并不保证元素的顺序，所以我们不能高效地查询SSN大于给定号码的员工。通常，在决定使用散列索引来替代有序索引时，你必须考虑这些限制。</p>


<p>如果你对于某些编译器厂家提供的非标准 <code>hash_set</code> 比较熟悉的话，那么学习使用散列索引是很简单的。但是，散列索引的接口是参照
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">C++ Standard
Library Technical Report</a> (TR1)的无序关联式容器规范来设计的，它与现有的某些非标准实现有些不同：&nbsp;
</p>


<ul>



  <li>由于不考虑关键字的排序，因此&nbsp;<a href="#hash_lookup">查找接口</a>&nbsp;不提供 <code>lower_bound</code> 或 <code>upper_bound</code> 成员函数(与Dinkumware的方案不同)。 </li>



  <li>提供了一组成员函数用于处理散列索引所使用的内部桶结构。包括&nbsp;<a href="../reference/hash_indices.html#hash_policy">rehashing重散列</a>，负载系数(元素数量除以桶数量)控制，以及检视桶的内容。非标准实现没有这些额外的功能。</li>


 
</ul>


关于散列索引接口的完整说明，请查阅 <a href="../reference/hash_indices.html">reference参考</a> 一节，实际应用请见 <a href="../examples.html#example8">example 8</a> 和
<a href="../examples.html#example9">example 9</a>。




<h3><a name="hash_unique_non_unique">Unique and non-unique variants</a>唯一与非唯一的区别</h3>




<p>与有序索引一样，散列索引也有唯一与非唯一之分，分别以 <code>hashed_unique</code> 和 
<code>hashed_non_unique</code> 
表示。后一种情形中，具有相同键值的元素将被放在一起，并通过<code>equal_range</code>成员函数一起取出。</p>


<h3><a name="hash_spec">Specification规范</a></h3>




<p>散列索引的声明有两种语法，分别为给出
<a href="basics.html#tagging">tags</a> 或不给出：
</p>




<blockquote>
  
  
  <pre><span class="special">(</span><span class="identifier">hashed_unique</span> <span class="special">|</span> <span class="identifier">hashed_non_unique</span><span class="special">)<br>  </span><span class="special">&lt;[</span><i>(tag)</i><span class="special">[,</span><i>(key extractor)</i><span class="special">[,</span><i>(hash function)</i><span class="special">[,</span><i>(equality predicate)</i><span class="special">]]]]&gt;</span>

<span class="special">(</span><span class="identifier">hashed_unique</span> <span class="special">|</span> <span class="identifier">hashed_non_unique</span><span class="special">)</span>
  <span class="special">&lt;[</span><i>(key extractor)</i><span class="special">[,</span><i>(hash function)</i><span class="special">[,</span><i>(equality predicate)</i><span class="special">]]]&gt;</span>
  </pre>


</blockquote>




<p>键提取器参数的使用与
<a href="basics.html#key_extraction">ordered indices有序索引</a>&nbsp;一样；查找、插入等操作要以键提取器返回的键而不是整个元素作为参数。
</p>




<p>散列函数是散列索引得以快速查找的核心所在：散列器hasher是一个 <a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary
Function一元函数</code></a>，接受一个键值并返回一个 <code>std::size_t</code> 
值。通常，不太可能每一个键值对应一个不同的散列值，键值的空间大于散列码的可取值范围：制作一个好的散列器的关键是使得冲突(两个不同键值具有相同的散列值)的可能性尽可能接近于零。这是与给定应用相关的键值分布的统计特性，因此没有一个通用的散列函数对于<span style="font-style: italic;">每个</span>应用都适用；该参数的缺省值为
<a href="../../../functional/hash/index.html">Boost.Hash</a>，它通常可以提供不错的结果。
</p>




<p>等价性谓词用于判定两个键是否一样。其缺省值为 
<code>std::equal_to&lt;KeyFromValue::result_type&gt;</code>，对于大多数情况都是适用的，因此很少机会你要自己提供一个谓词。注意，散列索引要求两个等价的键值必须具有相同的散列值，实际上这大大减少了等价性谓词的选择空间。</p>


<h3><a name="hash_lookup">Lookup查找</a></h3>




<p>散列索引的查找接口包括成员函数 <code>find</code>, <code>count</code> 和 
<code>equal_range</code>。注意，没有<code>lower_bound</code> 和 
<code>upper_bound</code>，由于散列索引中不存在键值的排序。</p>


<p>与有序索引一样，这些成员函数以键值而不是整个对象作为查找参数。你应该还记得，有序索引的查找操作可以接受<i>兼容键值</i>，又称为“子键”。对于散列索引，同样也有
<a href="../reference/hash_indices.html#lookup">compatible key兼容键值</a> 的概念，但它的用途要小得多：基本上，兼容键值就是一个完全等价于<code>key_type</code>对象的一个对象，只是内部表示有所不同而已：
</p>




<blockquote>
  
  
  <pre><span class="comment">// </span><span class="comment">US SSN 编码布局</span><span class="comment"></span>
<span class="keyword">struct</span> <span class="identifier">ssn</span>
<span class="special">{</span>
  <span class="identifier">ssn</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">area_no</span><span class="special">,</span><span class="keyword">int</span> <span class="identifier">group_no</span><span class="special">,</span><span class="keyword">int</span> <span class="identifier">serial_no</span><span class="special">):</span>
    <span class="identifier">area_no</span><span class="special">(</span><span class="identifier">area_no</span><span class="special">),</span><span class="identifier">group_no</span><span class="special">(</span><span class="identifier">group_no</span><span class="special">),</span><span class="identifier">serial_no</span><span class="special">(</span><span class="identifier">serial_no</span><span class="special">)</span>
  <span class="special">{}</span>

  <span class="keyword">int</span> <span class="identifier">to_int</span><span class="special">()</span><span class="keyword">const</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">serial_no</span><span class="special">+</span><span class="number">10000</span><span class="special">*</span><span class="identifier">group_no</span><span class="special">+</span><span class="number">1000000</span><span class="special">*</span><span class="identifier">area_no</span><span class="special">;</span>
  <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
  <span class="keyword">int</span> <span class="identifier">area_no</span><span class="special">;</span>
  <span class="keyword">int</span> <span class="identifier">group_no</span><span class="special">;</span>
  <span class="keyword">int</span> <span class="identifier">serial_no</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// </span><span class="comment">以int形式</span><span class="comment">与SSN互操作</span><br><span class="comment"></span><span class="keyword">struct</span> <span class="identifier">ssn_equal</span>
<span class="special">{</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ssn</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">int</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">to_int</span><span class="special">()==</span><span class="identifier">y</span><span class="special">;</span>
  <span class="special">}</span>

  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">ssn</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">x</span><span class="special">==</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">to_int</span><span class="special">();</span>
  <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">ssn_hash</span>
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ssn</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;()(</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">to_int</span><span class="special">());</span>
  <span class="special">}</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;()(</span><span class="identifier">x</span><span class="special">);</span>
  <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">employee_set</span><span class="special">::</span><span class="identifier">nth_index</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">employee_set_by_ssn</span><span class="special">;</span>

<span class="identifier">employee_set</span>         <span class="identifier">es</span><span class="special">;</span>
<span class="identifier">employee_set_by_ssn</span><span class="special">&amp;</span> <span class="identifier">ssn_index</span><span class="special">=</span><span class="identifier">es</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;();</span>
<span class="special">...</span>
<span class="comment">// </span><span class="comment">按ssn查找一位员工</span><span class="comment"></span>
<span class="identifier">employee</span> <span class="identifier">e</span><span class="special">=*(</span><span class="identifier">ssn_index</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">ssn</span><span class="special">(</span><span class="number">12</span><span class="special">,</span><span class="number">1005</span><span class="special">,</span><span class="number">20678</span><span class="special">),</span><span class="identifier">ssn_hash</span><span class="special">(),</span><span class="identifier">ssn_equal</span><span class="special">()));</span>
  </pre>


</blockquote>




<p>上例中，我们提供了一个散列函数 <code>ssn_hash</code> 和一个等价性谓词 <code>ssn_equal</code>，该谓词可以在 
<code>ssn</code> 对象与<code>employee_set</code>中保存的表示<code>SSN</code>的 
<code>int</code> 之间互相操作。</p>


<p>迄今为止，散列索引中兼容关键字的最大用处就是实现与
<a href="key_extraction.html#composite_keys">composite keys组合键</a> 的无缝使用。
</p>




<h3><a name="hash_updating">Updating更新</a></h3>




<p>散列索引提供了
<a href="../reference/hash_indices.html#replace"><code>replace</code></a>, 
<a href="../reference/hash_indices.html#modify"><code>modify</code></a> 和
<a href="../reference/hash_indices.html#modify_key"><code>modify_key</code></a>
成员函数，它们的功能与有序索引中的一样。
</p>




<h3><a name="guarantees">Guarantees on iterator validity and exception safety</a>迭代器有效性与异常安全性的保证</h3>




<p>得益于Boost.MultiIndex框架的内部约束，散列索引在迭代器有效性与异常安全性上的保证要强于C++标准库技术报告(TR1)中的无序关联式容器的要求：</p>


<ul>



  <li>任何插入与重散列操作都保证迭代器的有效性，TR1则允许重散列(隐式或显式)时迭代器无效。</li>


  <li>通过迭代器删除一个或一组元素不会抛出异常，因为不会产生对内部散列函数和等价性谓词对象的调用。</li>


  <li><code>rehash</code> 
提供无条件的强异常安全性保证。TR1则仅当内部散列函数和等价性谓词对象不抛出异常时有此保证。令人惊讶的是，TR1的无序关联式容器在重散列时如果发生异常抛出，有可能会删除元素！</li>


</ul>


通常，这些强保证有利于用户的方便使用，特别是有利于迭代器的稳定性，尽管这些需要降低一点点(最低限度的)性能。&nbsp;


<h2><a name="rnd_indices">Random access indices随机访问索引</a></h2>




<p>随机访问索引提供与
<a href="basics.html#seq_indices">sequenced indices序列索引</a> 同样的功能，它的优势在于其迭代器是随机访问的，并且提供了 <code>operator[]</code> 和 <code>at()</code> 用于以元素在索引中的位置来访问元素。我们来用随机访问索引替代序列索引，重写一下前一个 <a href="basics.html#list_fast_lookup">example例子</a> 中用到的容器：
</p>




<blockquote>
  
  
  <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index_container</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">random_access_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">ordered_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">identity</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// 文本容器带有基于随机访问索引的快速查找</span>
<span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span>
  <span class="identifier">indexed_by</span><span class="special">&lt;</span>
    <span class="identifier">random_access</span><span class="special">&lt;&gt;,</span>
    <span class="identifier">ordered_non_unique</span><span class="special">&lt;</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">&gt;</span>
<span class="special">&gt;</span> <span class="identifier">text_container</span><span class="special">;</span>

<span class="comment">// 全局文本容器对象</span>
<span class="identifier">text_container</span> <span class="identifier">tc</span><span class="special">;</span>
  </pre>


</blockquote>




<p>随机访问的能力让我们可以写出以下代码：
</p>




<blockquote>
  
  
  <pre><span class="keyword">void</span> <span class="identifier">print_page</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">page_num</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">words_per_page</span><span class="special">=</span><span class="number">50</span><span class="special">;</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">pos0</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">min</span><span class="special">(</span><span class="identifier">tc</span><span class="special">.</span><span class="identifier">size</span><span class="special">(),</span><span class="identifier">page_num</span><span class="special">*</span><span class="identifier">words_per_page</span><span class="special">);</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">pos1</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">min</span><span class="special">(</span><span class="identifier">tc</span><span class="special">.</span><span class="identifier">size</span><span class="special">(),</span><span class="identifier">pos0</span><span class="special">+</span><span class="identifier">words_per_page</span><span class="special">);</span>

  <span class="comment">// 注意，随机访问迭代器可以与偏移量相加</span><br>  <span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span>
    <span class="identifier">tc</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()+</span><span class="identifier">pos0</span><span class="special">,</span><span class="identifier">tc</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()+</span><span class="identifier">pos1</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">));</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">print_random_word</span><span class="special">()</span>
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="identifier">tc</span><span class="special">[</span><span class="identifier">rand</span><span class="special">()%</span><span class="identifier">tc</span><span class="special">.</span><span class="identifier">size</span><span class="special">()];</span>
<span class="special">}</span>
  </pre>


</blockquote>







<p>这个增加的灵活性是有代价的：在不是索引的末尾位置进行插入和删除操作是线性时间复杂度的，而在序列索引中这些操作是常量时间复杂度的。这种情形让人想起了 <code>std::list</code> 和
<code>std::vector 之间的复杂度差别：但毕竟对于随机访问索引而言，插入和删除操作并不会导致任何元素的复制动作，所以这些操作的实际性能还是可以接受的，虽然理论上这与序列索引相比是劣势。</code></p>

<p><code>例子一节中的 </code><a href="../examples.html#example10">Example 10</a> 和
<a href="../examples.html#example11">example 11</a> 使用了随机访问索引。
</p>




<h3><a name="rnd_spec">Specification规范</a></h3>




<p>随机访问索引用&nbsp;<code>random_access</code> 结构指定，其中的 <a href="basics.html#tagging">tag</a> 参数为可选： 
</p>




<blockquote>
  
  
  <pre><span class="identifier">random_access</span><span class="special">&lt;[</span><i>(tag)</i><span class="special">]&gt;</span>
  </pre>


</blockquote>




<h3><a name="rnd_interface">Interface接口</a></h3>




<p>序列索引提供的所有公有函数随机访问索引都有提供，因此后者可以完成替代前者(除了复杂度条件之外，前文已有解释)。此外，随机访问索引提供了 <code>operator[]</code> 和 <code>at()</code> 用于按位置访问元素，还有成员函数
<a href="../reference/rnd_indices.html#capacity_memfun"><code>capacity</code></a> 和
<a href="../reference/rnd_indices.html#reserve"><code>reserve</code></a>
用于控制内部分配，和 <code>std::vector</code> 上的同名函数相似。详情请见
<a href="../reference/rnd_indices.html">reference参考</a>。
</p>




<h3><a name="rnd_vs_vector">与&nbsp;<code>std::vector 的比较</code></a></h3>




<p>在使用Boost.MultiIndex时，很容易就把随机访问索引看成是 <code>std::vector</code>，但这种看法是不正确的，虽然两个结构在许多方面很相似，但是在语义上是有区别的。随机访问索引的优势在于，它的迭代器，即元素的引用，是<span style="font-style: italic;">稳定的</span>，即在任意的插入和删除后可以保持有效性。另一方面，随机访问索引与 <code>std::vector</code> 相比有以下劣势：
</p>


<ul>



  <li>它们不提供<span style="font-style: italic;">内存连续性</span>，而 <code>std::vector</code> 的元素是连续存放于单块内存中的。
  </li>



  <li>如&nbsp;Boost.MultiIndex 中常见的，随机访问索引的元素是不可变的，只能通过成员函数
    <a href="../reference/rnd_indices.html#replace"><code>replace</code></a> 和
	<a href="../reference/rnd_indices.html#modify"><code>modify</code></a> 来修改。这使得许多可用于 <code>std::vector</code>s 的修改元素的算法不能用于随机访问索引。
  </li>



</ul>

后一个缺点可以通过索引所提供的
<a href="#rearrange">rearranging interface重排接口</a> 得到部分的改善。


<p>一般而言，应把随机访问索引视为序列索引的一个提供随机访问语义的变体，而不要视为与 <code>std::vector 相仿</code>。
</p>




<h2><a name="rearrange">Index rearranging索引重排</a></h2>




<p>按照设计，索引元素是不可变的，即对迭代器只能使用常量性访问，只有通过库提供的更新接口(<code>replace</code>, <code>modify</code> 和
<code>modify_key</code>)才能更改元素。这个约束是要保障基于键的索引的内部不变式不会被破坏(例如，在有序索引中的元素是按升序排列的)，但这在非基于键的索引中会导致重要的限制：
</p>




<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span>
  <span class="keyword">int</span><span class="special">,</span>
  <span class="identifier">indexed_by</span><span class="special">&lt;</span>
    <span class="identifier">random_access</span><span class="special">&lt;&gt;,</span>
    <span class="identifier">ordered_unique</span><span class="special">&lt;</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">&gt;</span>
<span class="special">&gt;</span> <span class="identifier">container</span><span class="special">;</span>	<br><br><span class="identifier">container</span> <span class="identifier">c</span><span class="special">;</span>
<span class="special">...</span>
<span class="comment">// 编译错误：向只读对象赋值</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">random_shuffle</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
  </pre>


</blockquote>




<p>在这个例子中，<code>std::random_shuffle</code> 执行的操作其实是满足 <code>multi_index_container</code> 的不变式的，它的结果是在随机访问索引上进行元素的随机排列，并没有实际修改到元素本身。在C++标准库中还有很多这样的兼容算法，例如所有排序和分区函数。
</p>




<p>序列索引和随机访问索引提供了一个方法来发挥这些外部算法的优势。为了介绍这个方法，我们需要先讲一个概念：一个索引的<span style="font-style: italic;">视图</span>是指，在该索引的元素之上的一个迭代器范围，所有元素都包含在这个范围之内且只出现一次。继续我们的例子，我们可以将
<code>std::random_suffle</code> 应用于从容器即时生成的一个视图：
</p>




<blockquote>
  
  
  <pre><span class="comment">// 注意，视图的元素并不c中元素的拷贝，而是它们的引用</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>
<span class="identifier">BOOST_FOREACH</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">,</span><span class="identifier">c</span><span class="special">)</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span>

<span class="comment">// 编译OK, 因为reference_wrappers是可赋值的</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">random_shuffle</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
  </pre>


</blockquote>




<p><code>v</code> 的元素是 multi_index 容器中各元素的 <code>reference_wrapper</code>s (来自
<a href="../../../../doc/html/ref.html">Boost.Ref</a>)。这些对象还是不允许去修改被引用的实体，但它们本身是
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable可赋值的</code></a>,
而这正是 <code>std::random_suffle</code> 所要求的。一旦我们对视图完成了所需的重排，就可以用以下方法把它转换到容器中：
</p>




<blockquote>
  
  
  <pre><span class="identifier">c</span><span class="special">.</span><span class="identifier">rearrange</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
  </pre>


</blockquote>




<p>
<code>rearrange</code> 接受一个输入迭代器，以标记外部视图的开始(结束迭代器是不需要的，因为视图的长度与索引的长度是相同的)，它在内部重新部署索引的元素，以使得它们的顺序与视图相同。虽然有些绕，但 <code>rearrange</code> 使得各种算法都可以应用于非基于键的索引。请注意，视图的概念是非常通用的，并不依赖于上例中的特殊实现。例如，一个 <code>multi_index_container</code> 的索引也可以被看作是该容器的非基于键的索引的视图：
</p>




<blockquote>
  
  
  <pre><span class="comment">// 以 index #1 (按升序) 重排</span>
<span class="identifier">c</span><span class="special">.</span><span class="identifier">rearrange</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;().</span><span class="identifier">begin</span><span class="special">());</span>

<span class="comment">// 以降序重排</span>
<span class="identifier">c</span><span class="special">.</span><span class="identifier">rearrange</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;().</span><span class="identifier">rbegin</span><span class="special">());</span>
  </pre>


</blockquote>




<p>对于视图来说，唯一重要的要求是，它们必须是<span style="font-style: italic;">自由的</span><i></i>，即它们不受底层索引重新布置的影响：因此，<code>rearrange</code> 不能这样使用：
</p>




<blockquote>
  
  
  <pre><span class="comment">// 未定义行为：[rbegin(),rend()) 对于底层索引而言不是自由的</span>
<span class="identifier">c</span><span class="special">.</span><span class="identifier">rearrange</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">rbegin</span><span class="special">());</span></pre>


</blockquote>




<p>视图的详细定义请见
<a href="../reference/indices.html#views">reference参考</a>。对于 rearrange 的使用示范请见例子一节中的 <a href="../examples.html#example11">example 11</a>。</p>
<h2><a name="iterator_to"><code>iterator_to</code></a></h2>

<p>所有 Boost.MultiIndex 的索引都提供了一个名为 
<code>iterator_to</code> 的成员函数，它返回一个迭代器，指向容器中某个给定元素： </p>

<blockquote>
  <pre><span class="identifier">multi_index_container</span><span class="special">&lt;</span><br>  <span class="keyword">int</span><span class="special">,</span><br>  <span class="identifier">indexed_by</span><span class="special">&lt;</span><span class="identifier">sequenced</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">c</span><span class="special">;</span><br><span class="special">...</span><br><span class="comment">// 实现 c.pop_back() 的复杂办法</span> <br><span class="identifier">c</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">iterator_to</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">back</span><span class="special">()));</span> <br><br><span class="comment">// 以下方法虽然和前面的代码很相似，但不能用：<br>// iterator_to 接受一个对容器中某个元素的<br>// 引用，而不是拷贝</span><br><span class="keyword">int</span> <span class="identifier">x</span><span class="special">=</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">back</span><span class="special">();</span><br><span class="identifier">c</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">iterator_to</span><span class="special">(</span><span class="identifier">x</span><span class="special">));</span> <span class="comment">// 运行期错误</span>
  </pre>
</blockquote>

<p><code>iterator_to</code> 提供了一个方法，从某个元素的指针取得指向该元素的迭代器，这样在多数情况下，迭代器和指针就可以互换用于元素的指定(而不是用于遍历)。虽然如此，但是
<code>iterator_to</code> 目的并不是提倡使用指针来替代真正的迭代器：迭代器是专门设计用于处理容器中的元素的，不仅有利于面向迭代器的容器接口，还可以比裸指针揭露更多的编程错误，包括编译期和运行期的。因此，<code>iterator_to</code> 应该用于不适合或不能使用迭代器进行访问的情形： 
</p>
<ul>
  <li>与已有的基于指针或引用的API进行互操作。 
  </li>
  <li>发布基于指针的接口(例如，设计一个C兼容的库)。 
  </li>
  <li>以指针代替迭代器，可以用作一种<span style="font-style: italic;">类型擦除</span>的屏障，有效地解耦用户的代码和特定容器的实现细节。类似的技术，如著名的 Pimpl 惯用法，被用在一些大型项目中，以减少依赖和构建的时间。 
  </li>
  <li>自引用的上下文，一个元素要依赖于其所属容器且没有指向它本身的迭代器可用。 </li>
</ul>




<h2><a name="ordered_node_compression">Ordered indices node compression有序索引节点的压缩</a></h2>




<p>有序索引是依赖于名为<span style="font-style: italic;">红-黑树</span>的数据结构实现的。红-黑树的节点包含了指向父节点和两个子节点的指针，再加1-bit来表示<span style="font-style: italic;">节点的颜色</span>(这
正是该数据结构的名字来源)。由于对齐的问题，在许多体系架构中，这个颜色字段占用了一个字的空间，即在32位系统中占4个字节，在64位环境中则占8个
字节。这些空间浪费可以通过将颜色位嵌入到某个节点指针中来避免，如果指针表示中不是每个位都包含有效信息的话：这一点在许多体系中恰好是满足的，因为每
个节点都要对齐到偶地址，这意味着地址的最低位总会是0。
</p>




<p>Boost.MultiIndex
的有序索引在允许的情况下提供了这种节点压缩。与STL容器stl::set的一般实现相比较，节点压缩可以将头部压缩超过25%
(在32位体系中从16字节减少至12字节，在64位系统中从32字节减少至24字节)。经检验，对于典型大小的容器，这种优化所引起的性能影响可忽略不
计，但对于包含大量元素(十万以上)的容器，该优化速度更快，这得益于
L1 和 L2 缓冲。 </p>




<p>节点压缩可以通过设置宏
<code>BOOST_MULTI_INDEX_DISABLE_COMPRESSED_ORDERED_INDEX_NODES</code> 来关闭。
</p>




<hr>

<div class="prev_link"><a href="basics.html"><img src="../prev.gif" alt="basics" border="0"><br>



Basics基础
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex tutorial" border="0"><br>



Boost.MultiIndex 指南
</a></div>



<div class="next_link"><a href="key_extraction.html"><img src="../next.gif" alt="key estraction" border="0"><br>



Key extraction键提取
</a></div>


<br style="" clear="all">




<br>




<p>Revised October 15th 2007</p>




<p>© Copyright 2003-2007 Joaquín M López Muñoz.
Distributed under the Boost Software 
License, Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>




</body></html>
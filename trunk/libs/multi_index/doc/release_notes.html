<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Boost.MultiIndex Documentation - Release notes</title>

<link rel="stylesheet" href="style.css" type="text/css">
<link rel="start" href="index.html">
<link rel="prev" href="future_work.html">
<link rel="up" href="index.html">
<link rel="next" href="acknowledgements.html"></head>
<body>
<h1><img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">Boost.MultiIndex Release notes</h1>
<div class="prev_link"><a href="future_work.html"><img src="prev.gif" alt="future work" border="0"><br>
未来的工作
</a></div>
<div class="up_link"><a href="index.html"><img src="up.gif" alt="index" border="0"><br>
目录
</a></div>
<div class="next_link"><a href="acknowledgements.html"><img src="next.gif" alt="acknowledgements" border="0"><br>
鸣谢
</a></div>
<br style="" clear="all">
<hr>
<h2>Contents目录</h2>
<ul>
<li><a href="#boost_1_36">Boost 1.36 发布</a></li>
<li><a href="#boost_1_35">Boost 1.35 发布</a></li>
<li><a href="#boost_1_34">Boost 1.34 发布</a></li>
<li><a href="#boost_1_33_1">Boost 1.33.1 发布</a></li>
<li><a href="#boost_1_33">Boost 1.33 发布</a></li>
</ul>
<h2><a name="boost_1_36">Boost 1.36 发布</a></h2>
<ul>
<a name="stable_update"><li>在本库以前的版本中，散列索引的 <a href="tutorial/indices.html#hash_updating">update
成员函数</a> 可以改变一个元素的位置，即使在这次更新中关联的键值没有变化。这是合法的，但可能不是预期的行为。该
函数已被重写，以提供额外的保证，确保对于键值未变化的元素，其在散列索引中的位置不会改变，就象在有序索引中的情况那样。该保证已记录在参考手册。 
</li></a><li>增
加了构造函数 <code>multi_index_container::multi_index_container(const
allocator_type&amp;)</code>，以效仿STL序列容器中的对应接口。 </li>
<li>维护性修复。 </li>
</ul>
<h2><a name="boost_1_35">Boost 1.35 发布</a></h2>
<ul>
<li>新的 <a href="tutorial/key_extraction.html#global_fun"><code>global_fun</code></a>
预定义键提取器。 </li>
<li>加入 <a href="tutorial/indices.html#iterator_to"><code>iterator_to</code></a>
工具。 </li>
<li>增加了 <a href="tutorial/creation.html#special_allocator">对
非标准分配器的支持</a>，如 <a href="../../interprocess/index.html">Boost.Interprocess</a>
中的分配器，这样 <code>multi_index_container</code>s 就可以放在共享内存中。 </li>
<li>新版本的带回滚的 <code>modify</code> 和 <code>modify_key</code>,
正如在&nbsp;<a href="tutorial/basics.html#ord_updating">指南</a>
所介绍的。 </li>
<li>索引提供了新的 <code>cbegin</code>, <code>cend</code>
以及可应用时的 <code>crbegin</code> 和 <code>crend</code>
成员函数，与最后一版C++标准草本一致。 </li>
<li>有序索引的带提示插入完全符合C++标准库 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">Defect
Report 233</a> 的决议。对插入点的新要求是，要尽可能接近提示，与以前的 Boost.MultiIndex
版本的行为有所不同，可能导致后向兼容的问题；无论如何，在真实情况下发生这种兼容性问题的可能性非常低。 </li>
<li>序列索引和随机访问索引现在遵循了C++标准中对序列容器关于操作 <code>assign(f,l)</code>
和 <code>insert(p,f,l)</code> 的要求(23.1.1/9): 如果 <code>f</code>
和 <code>l</code> 是相同的整数类型，则这些成员函数的基于迭代器的重载将被消除：
<blockquote>
<pre><span class="keyword">typedef</span> <span class="identifier">multi_index_container</span><span class="special">&lt;</span><br><span class="keyword">int</span><span class="special">,</span><span class="identifier">indexed_by</span><span class="special">&lt;</span><span class="identifier">sequenced</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">sequenced_container</span><span class="special">;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">l</span><span class="special">(...);</span><br><span class="identifier">sequenced_container</span> <span class="identifier">c</span><span class="special">;</span><br><span class="comment">// 基于迭代器的 assign 重载</span><br><span class="identifier">c</span><span class="special">.</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">l</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">l</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span> <br><br><span class="comment">// 以下等价于<br>// c.assign(<br>// static_cast&lt;sequenced_container::size_type&gt;(10),100);<br>// 即，"10" 和 "100" 不会被视为象前一个表达式中的迭代器。</span><br><span class="identifier">c</span><span class="special">.</span><span class="identifier">assign</span><span class="special">(</span><span class="number">10</span><span class="special">,</span><span class="number">100</span><span class="special">);</span>
</pre>
</blockquote>
</li>
<li>改进了有序索引的 <code>range</code> 和 <code>equal_range</code>
的性能。 </li>
<li>维护性修复。</li>
</ul>
<h2><a name="boost_1_34">Boost 1.34 发布</a></h2>
<ul>
<li>增中了 <a href="tutorial/indices.html#rnd_indices">随
机访问索引</a>。 </li>
<li>非基于键的索引提供了新的 <a href="tutorial/indices.html#rearrange">重
排工具</a> ，允许与外部的可变算法进行交互。 </li>
<li>所有预定义的 Boost.MultiIndex 键提取器对给定的类型 <code>T</code>
进行实例化后，可以处理派生自 <code>T</code> 或可转换为 <code>T</code>
(以及它们的 <a href="reference/key_extraction.html#chained_pointers">链
式指针</a>)的类型的对象。以前，只有精确的特定类型的对象(以及它们的 <code>reference_wrapper</code>s
和链式指针)可以被接受。 </li>
<li><a href="reference/key_extraction.html#composite_key_compare"><code>composite_key_compare</code></a>
及相关类可以接受未包含在 tuples 中的操作数，就好象这些操作数是以长度为1的 tuple
来传递一样；这样用户可以在只提供第一个键值的组合键查找操作中省略 tuple 包装。 </li>
<li>有序索引的核心算法被优化，估计可以减少5%的插入时间。 </li>
<li>在多数平台上，有序索引的节点头文件大小减少了25%，使用了著名的 <a href="tutorial/indices.html#ordered_node_compression">优化技术</a>。
</li>
<li>重构"指南"文档，增加新的例子。</li>
<li>维护性修复。</li>
</ul>
<h2><a name="boost_1_33_1">Boost 1.33.1 发布</a></h2>
<ul>
<li>对于有序索引和散列索引，<code>erase(it)</code> 和 <code>erase(first,last)</code>
现在返回一个指向被删元素之后的元素的迭代器(以前不返回任何东西)，与C++标准库 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">Defect
Report 130</a> 以及 TR1 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf">Issues
List</a> 的 issue 6.19 保持一致。 </li>
<li>Boost.MultiIndex 为多数STL实现所提供的多线程代码提供通常的保证：
<ol>
<li>并行访问不同容器是安全的。</li>
<li>并行只读访问同一个容器是安全的。</li>
</ol>
在本库的先前版本，后一个保证不能正确维护，如果设置了 <a href="tutorial/debug.html#safe_mode">安
全模式</a>。该问题现在已修正。 </li>
<li>维护性修复。</li>
</ul>
<h2><a name="boost_1_33">Boost 1.33 发布</a></h2>
<ul>
<li>增加了 <a href="tutorial/indices.html#hashed_indices">散
列索引</a>，其接口基于C++标准库TR1的无序关联容器规范。 </li>
<li>为 <a href="../../serialization/index.html">Boost.Serialization</a>&amp;
nbsp;增加了 <a href="tutorial/creation.html#serialization">序列
化支持</a> 。 </li>
<li><code>multi_index_container</code>s 的析构及 <code>clear</code>
成员函数现在执行得更快了。 </li>
<li>内部有一些变化，为了减少编译器所生成的符号名长度；与 Boost 1.32
相比缩短了最多50%。结果是错误信息更短更易读，对于对符号名长度有严格要求的编译器也有好处。另外，增加了一节 <a href="compiler_specifics.html#symbol_reduction">缩短符号名长度</a>。
</li>
<li>重构了部分文档，增加新的例子。</li>
<li>维护性修复。</li>
</ul>
<hr>
<div class="prev_link"><a href="future_work.html"><img src="prev.gif" alt="future work" border="0"><br>
</a><a href="future_work.html">
未来的工作</a><a href="future_work.html">
</a></div>
<div class="up_link"><a href="index.html"><img src="up.gif" alt="index" border="0"><br>
目录
</a></div>
<div class="next_link"><a href="acknowledgements.html"><img src="next.gif" alt="acknowledgements" border="0"><br>
鸣谢
</a></div>
<br style="" clear="all">
<br>
<p>Revised October 11th 2007</p>
<p>© Copyright 2003-2007 Joaquín M López Muñoz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>
</body></html>
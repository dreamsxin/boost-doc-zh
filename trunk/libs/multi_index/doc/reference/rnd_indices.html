<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html><head>




  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">





  
  
  
  
  
  
  
  <title>Boost.MultiIndex Documentation - Random access indices reference</title><link rel="stylesheet" href="../style.css" type="text/css">




  
  
  
  <link rel="start" href="../index.html">




  
  
  
  <link rel="prev" href="seq_indices.html">




  
  
  
  <link rel="up" href="index.html">




  
  
  
  <link rel="next" href="key_extraction.html"></head>

<body>




<h1><img src="../../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">Boost.MultiIndex 随机访问索引参考</h1>





<div class="prev_link"><a href="seq_indices.html"><img src="../prev.gif" alt="sequenced indices" border="0"><br>



序列索引
</a></div>




<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>




Boost.MultiIndex 参考
</a></div>




<div class="next_link"><a href="key_extraction.html"><img src="../next.gif" alt="key extraction" border="0"><br>



键提取器
</a></div>



<br style="" clear="all">





<hr>

<h2>Contents目录</h2>





<ul>




  <li><a href="#rnd_index_fwd_synopsis">头文件 <code>"boost/multi_index/random_access_index_fwd.hpp"</code> 摘要</a></li>




  <li><a href="#synopsis">头文件 <code>"boost/multi_index/random_access_index.hpp"</code> 摘要</a>
    
    
    
    
    <ul>




      <li><a href="#random_access"><code>random_access</code> 索引说明</a></li>




      <li><a href="#rnd_indices">随机访问索引</a>
        
        
        
        
        <ul>




          <li><a href="#complexity_signature">复杂度署名</a></li>




          <li><a href="#instantiation_types">实例化的类型</a></li>




          <li><a href="#constructors">构造函数，复制和赋值</a></li>
          <li><a href="#iterators">迭代器</a></li>




          <li><a href="#capacity">容量操作</a></li>




          <li><a href="#modifiers">修饰器</a></li>




          <li><a href="#list_operations">List 操作</a></li>




          <li><a href="#rearrange_operations">重排操作</a></li>




          <li><a href="#serialization">序列化</a></li>




        
        
        
        
        </ul>




      </li>




    
    
    
    
    </ul>




  </li>




</ul>





<h2>
<a name="rnd_index_fwd_synopsis">头文件 </a><a href="../../../../boost/multi_index/random_access_index_fwd.hpp"><code>"boost/multi_index/random_access_index_fwd.hpp"</code></a> 摘要</h2>





<blockquote>
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="comment">// random_access 索引说明</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TagList</span><span class="special">=</span><span class="identifier">tag</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">random_access</span><span class="special">;</span>

<span class="comment">// 索引</span>
<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span> <span class="keyword">class</span> <b>index class name implementation defined</b><span class="special">;</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>



</blockquote>





<p>
<code>random_access_index_fwd.hpp</code> 提供了 
<a href="#random_access"><code>random_access</code></a> 索引说明和相关 <a href="#rnd_indices">random access index随机访问索引</a> 类的前向声明。
</p>





<h2>
<a name="synopsis">头文件 </a><a href="../../../../boost/multi_index/random_access_index.hpp"><code>"boost/multi_index/random_access_index.hpp"</code></a> 摘要</h2>





<blockquote>
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="comment">// random_access 索引说明</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TagList</span><span class="special">=</span><span class="identifier">tag</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">random_access</span><span class="special">;</span>

<span class="comment">// 索引</span>
<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span> <span class="keyword">class</span> <b>index class name implementation defined</b><span class="special">;</span>

<span class="comment">// 索引比较:</span>

<span class="comment">// <b>OP</b> is any of ==,&lt;,!=,&gt;,&gt;=,&lt;=</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="comment">// 索引特定算法:</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>



</blockquote>





<h3><a name="random_access">
<code>random_access</code> 索引说明
</a></h3>





<p>以下索引说明用于插入一个 <a href="#rnd_indices">random
access index随机访问索引</a>。</p>





<blockquote>
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TagList</span><span class="special">=</span><span class="identifier">tag</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">random_access</span><span class="special">;</span>
  </pre>



</blockquote>





<p>如果有，则 <code>TagList</code> 必须是
<a href="indices.html#tag"><code>tag</code></a> 的实例。
</p>





<h3><a name="rnd_indices">随机访问索引</a></h3>





<p>随机访问索引是一个无序的序列，提供常量时间的位置访问和随机访问迭代器。随机访问索引中的元素缺省按它们插入的顺序来排列：即通过
multi_index_container
的其它索引所插入的新元素被加到随机访问索引的末尾；另外，还提供了更多的对元素进行重排的工具。随机访问索引的公有接口包含了 
<a href="seq_indices.html">sequenced indices序列索引</a> 的接口，但操作的复杂度不同，另外还有位置访问的操作(<code>operator[]</code> 和 <code>at()</code>)以及容量处理。在所有操作中，元素的迭代器和引用均保持有效，不管容量的状态如何。
</p>





<p>就象序列索引那样，随机访问索引与 STL 序列容器相比有以下限制：
</p>



<ul>




  <li>随机访问索引不是 <a href="http://www.sgi.com/tech/stl/Assignable.html">
    <code>Assignable可赋值的</code></a> (与其它索引一样)。</li>




  <li>随机访问索引的插入操作可能由于其它索引的禁止而失败。这改变了 STL 序列容器所提供的对应操作的语义。
  </li>




  <li>随机访问索引中的元素不是可变的，只能通过 <a href="#replace"><code>replace</code></a> 和
	<a href="#modify"><code>modify</code></a> 成员函数来修改。
  </li>




</ul>

除了以上限制，随机访问索引符合 <a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">
<code>Random Access Container</code></a> 和
<a href="http://www.sgi.com/tech/stl/BackInsertionSequence.html">
<code>Back Insertion Sequence</code></a>. 但是不符合
<a href="http://www.sgi.com/tech/stl/FrontInsertionSequence.html">
<code>Front Insertion Sequence</code></a>, 因为在前部的插入和删除是线性时间的，虽然如此，为了匹配序列索引，还是提供了前部的操作。下面我们只对不符合以上概念或不满足上述容器类型要求的类型和操作进行描述。


<blockquote>
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined: dependent on types Value, Allocator, TagList</b><span class="special">&gt;</span>
<span class="keyword">class</span> <b>name is implementation defined</b>
<span class="special">{</span> <br><span class="keyword">public</span><span class="special">:</span>
  <span class="comment">// 类型:</span>

  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">node_type</span><span class="special">::</span><span class="identifier">value_type</span>             <span class="identifier">value_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">tuples</span><span class="special">::</span><span class="identifier">null_type</span>                          <span class="identifier">ctor_args</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span>                         <span class="identifier">allocator_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">reference</span>         <span class="identifier">reference</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">const_reference</span>   <span class="identifier">const_reference</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined</b>                     <span class="identifier">iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined</b>                     <span class="identifier">const_iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span>                                <span class="identifier">size_type</span><span class="special">;</span>      <br>  <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span>                             <span class="identifier">difference_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">pointer</span>           <span class="identifier">pointer</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">const_pointer</span>     <span class="identifier">const_pointer</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>equivalent to<br>    std::reverse_iterator&lt;iterator&gt;</b>                  <span class="identifier">reverse_iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>equivalent to<br>    std::reverse_iterator&lt;const_iterator&gt;</b>            <span class="identifier">const_reverse_iterator</span><span class="special">;</span>

  <span class="comment">// 构造/复制/析构:</span>

  <b>index class name</b><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">InputIterator</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">assign</span><span class="special">(</span><span class="identifier">InputIterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">InputIterator</span> <span class="identifier">last</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">assign</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span>
    
  <span class="identifier">allocator_type</span> <span class="identifier">get_allocator</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 迭代器:</span>

  <span class="identifier">iterator</span>               <span class="identifier">begin</span><span class="special">();</span>
  <span class="identifier">const_iterator</span>         <span class="identifier">begin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">iterator</span>               <span class="identifier">end</span><span class="special">();</span>
  <span class="identifier">const_iterator</span>         <span class="identifier">end</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">reverse_iterator</span>       <span class="identifier">rbegin</span><span class="special">();</span>
  <span class="identifier">const_reverse_iterator</span> <span class="identifier">rbegin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">reverse_iterator</span>       <span class="identifier">rend</span><span class="special">();</span>
  <span class="identifier">const_reverse_iterator</span> <span class="identifier">rend</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br>  <span class="identifier">const_iterator</span>         <span class="identifier">cbegin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br>  <span class="identifier">const_iterator</span>         <span class="identifier">cend</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br>  <span class="identifier">const_reverse_iterator</span> <span class="identifier">crbegin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br>  <span class="identifier">const_reverse_iterator</span> <span class="identifier">crend</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br><br>  <span class="identifier">iterator</span>       <span class="identifier">iterator_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br>  <span class="identifier">const_iterator</span> <span class="identifier">iterator_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;<br><br></span>&nbsp;<span class="comment">// 容量:</span>

  <span class="keyword">bool</span>      <span class="identifier">empty</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">max_size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">capacity</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">void</span>      <span class="identifier">reserve</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">m</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">resize</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">=</span><span class="identifier">value_type</span><span class="special">());</span>

  <span class="comment">// 访问:</span>

  <span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">const_reference</span> <span class="identifier">at</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">const_reference</span> <span class="identifier">front</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">const_reference</span> <span class="identifier">back</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 修饰器:</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">push_front</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">void</span>                     <span class="identifier">pop_front</span><span class="special">();</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">void</span>                     <span class="identifier">pop_back</span><span class="special">();</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">size_type</span> <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">InputIterator</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">InputIterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">InputIterator</span> <span class="identifier">last</span><span class="special">);</span>

  <span class="identifier">iterator</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">);</span>
  <span class="identifier">iterator</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">);</span>

  <span class="keyword">bool</span> <span class="identifier">replace</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Modifier</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">modify</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">Modifier</span> <span class="identifier">mod</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">clear</span><span class="special">();</span>

  <span class="comment">// list 操作:</span>

  <span class="keyword">void</span> <span class="identifier">splice</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">splice</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">i</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">splice</span><span class="special">(</span>
    <span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">remove</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">remove_if</span><span class="special">(</span><span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">unique</span><span class="special">();</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BinaryPredicate</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">unique</span><span class="special">(</span><span class="identifier">BinaryPredicate</span> <span class="identifier">binary_pred</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">merge</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">merge</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="identifier">Compare</span> <span class="identifier">comp</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">sort</span><span class="special">();</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">sort</span><span class="special">(</span><span class="identifier">Compare</span> <span class="identifier">comp</span><span class="special">);</span>

  <span class="keyword">void</span> <span class="identifier">reverse</span><span class="special">();</span>

  <span class="comment">// 重排操作:</span>

  <span class="keyword">void</span> <span class="identifier">relocate</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">i</span><span class="special">);</span> <br>  <span class="keyword">void</span> <span class="identifier">relocate</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">InputIterator</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">rearrange</span><span class="special">(</span><span class="identifier">InputIterator</span> <span class="identifier">first</span><span class="special">);</span>
<span class="special">}</span>

<span class="comment">// 索引比较:</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">size</span><span class="special">()==</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">size</span><span class="special">()&amp;&amp;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">lexicographical_compare</span><span class="special">(</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="special">!(</span><span class="identifier">x</span><span class="special">==</span><span class="identifier">y</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span>
  <span class="special">,</span><span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">y</span><span class="special">&lt;</span><span class="identifier">x</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="special">!(</span><span class="identifier">x</span><span class="special">&lt;</span><span class="identifier">y</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="special">!(</span><span class="identifier">x</span><span class="special">&gt;</span><span class="identifier">y</span><span class="special">);</span>
<span class="special">}</span>

<span class="comment">// 索引特定算法:</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>



</blockquote>





<h4><a name="complexity_signature">复杂度署名</a></h4>





<p>
在这里以及后续对随机访问索引的操作描述中，我们采用了在 
<a href="indices.html#complexity_signature">complexity signature 复杂度署名一节</a> 中的记法。随机访问索引的复杂度署名是：
</p>



<ul>




  <li>复制: <code>c(n)=n*log(n)</code>,</li>




  <li>插入: <code>i(n)=1</code> (分期常量),</li>




  <li>带提示的插入: <code>h(n)=1</code> (分期常量),</li>




  <li>删除: <code>d(n)=m</code>, <code>m</code> 为从被删元素到序列尾部的距离,</li>




  <li>替换: <code>r(n)=1</code> (常量),</li>




  <li>修改: <code>m(n)=1</code> (常量).</li>




</ul>

以下表达式用于更方便地写出一些复杂度公式：


<blockquote>
  <code>shl(a,b)</code> = <code>a+b</code> 如果 a 非零, 否则为 <code>0</code>.<br>




  <code>rel(a,b,c)</code> = 如果 <code>a&lt;b</code>, <code>则 c-a</code>, 否则 <code>a-b</code>,
</blockquote>



 

<p>
(<code>shl</code> 和 <code>rel</code> 分别表示 <i>左移</i> 和
<i>重定位</i>)。
</p>





<h4><a name="instantiation_types">实例化的类型</a></h4>





<p>随机访问索引在 <code>multi_index_container</code> 的内部进行实例化，并且使用带 <a href="rnd_indices.html#random_access"><code>random_access</code></a> 索引说明<a href="ord_indices.html#unique_non_unique"><code></code></a>的 <a href="indices.html#indexed_by"><code>indexed_by</code></a> 来指定。实例化依赖于以下类型：
</p>



<ul>




  <li><code>Value</code> 来自于 <code>multi_index_container</code>,</li>




  <li><code>Allocator</code> 来自于 <code>multi_index_container</code>,</li>




  <li><code>TagList</code>&nbsp;来自于索引说明 (如果有).</li>




</ul>




<code>TagList</code> 必须是
<a href="indices.html#tag"><code>tag</code></a> 的实例。


<h4><a name="constructors">构造函数，复制和赋值</a></h4>





<p>如 <a href="indices.html#index_concepts">index
concepts 索引概念一节</a> 中的说明，索引没有公有的构造函数或析构函数。但是赋值操作则有提供。
</p>





<code><b>index class name</b>&amp; operator=(const <b>index class name</b>&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="identifier">a</span><span class="special">=</span><span class="identifier">b</span><span class="special">;</span>
    </pre>



  </blockquote>







其中 <code>a</code> 和 <code>b</code> <code>分别</code>是 <code>*this</code> 和 <code>x</code>&nbsp;<code>所属的 multi_index_container</code>
对象。<br>








  <span style="font-weight: bold;">返回</span><b>:</b> <code>*this</code>.<br>




</blockquote>





<code>template &lt;class InputIterator&gt;<br>




void assign(InputIterator first,InputIterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>InputIterator</code> 为一个
  <a href="http://www.sgi.com/tech/stl/InputIterator.html">
  <code>Input Iterator输入迭代器</code></a>，其指向的元素的类型是
  <code>value_type</code> 或可转换为 <code>value_type</code>.
  <code>first</code> 和 <code>last</code> 不可以是索引所属 <code>multi_index_container</code> 的任意索引的迭代器。<code>last</code> 可从 <code>first 到达。<span style="font-weight: bold;"><br>



效果</span></code><b>:</b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="identifier">clear</span><span class="special">();</span>
<span class="identifier">insert</span><span class="special">(</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">last</span><span class="special">);</span>
    </pre>



  </blockquote>




</blockquote>





<code>void assign(size_type n,const value_type&amp; value);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="identifier">clear</span><span class="special">();</span>
<span class="keyword">for</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span><span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">n</span><span class="special">;++</span><span class="identifier">n</span><span class="special">)</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">v</span><span class="special">);</span>
    </pre>



  </blockquote>




</blockquote>





<h4><a name="iterators">迭代器</a></h4>
<code>iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator_to(const 
value_type&amp; x);<br>
const_iterator iterator_to(const value_type&amp; 
x)const;</code> 
<blockquote><b>要求：</b><code>x</code> 是容器中某个元素的引用。<br>
  <b>返回：</b>指向 
  <code>x</code> 的一个迭代器。<br>
  <b>复杂度：</b>常数。<br>
  <b>异常安全性：</b><code>不抛出。</code><br>
</blockquote>
<h4><a name="capacity">容量操作</a></h4>





<a name="capacity_memfun"><code>size_type capacity()const;</code></a>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> 元素 c 的总数量，如果
  <code>size()&lt;c</code>, 尾部插入为常量时间(通常情况描述为
  <a href="#complexity_signature"><code>i(n)</code></a> 是分期常量时间)。<br>




  <b>注意:</b> 在所有插入操作中，不管容量状态如何，元素的迭代器和引用均保持有效。
</blockquote>





<a name="reserve"><code>void reserve(size_type m);</code></a>
<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 如果之前的 <code>capacity()</code>
大于等于 <code>m</code>, 则无操作；否则修改内部容量使得
  <code>capacity()&gt;=m</code>.<br>



 
  <span style="font-weight: bold;">复杂度</span><b>:</b> 如果容量不变，则为常量时间；否则为 <code>O(n)</code>.<br>




  <b>异常安全性:</b> 如果容量不变，则不抛出；否则为强异常安全。<br>




</blockquote>





<code>void resize(size_type n,const value_type&amp; x=value_type());</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="keyword">if</span><span class="special">(</span><span class="identifier">n</span><span class="special">&gt;</span><span class="identifier">size</span><span class="special">())</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier">n</span><span class="special">-</span><span class="identifier">size</span><span class="special">(),</span><span class="identifier">x</span><span class="special">);</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="special">(</span><span class="identifier">n</span><span class="special">&lt;</span><span class="identifier">size</span><span class="special">())</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">begin</span><span class="special">()+</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">end</span><span class="special">());</span>
    </pre>



  </blockquote>




  <span style="font-weight: bold;">注意</span><b>:</b> 如果是请求扩展容量，则扩展后的索引大小并不保证是 <code>n</code> (其它索引可能禁止插入)。
</blockquote>





<h4><a name="modifiers">修饰器</a></h4>





<code>std::pair&lt;iterator,bool&gt; push_front(const value_type&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 将 <code>x</code> 插入到序列的开头，如果 <code>multi_index_container </code>没有其它的索引禁止插入。<br>





  <b>返回:</b> 返回值是一个 pair <code>p</code>. <code>p.second</code>
为 <code>true</code> 当且仅当插入成功。插入成功时，<code>p.first</code> 指向插入的元素；否则，<code>p.first</code> 指向导致插入失败的元素。注意，可能存在一个以上的元素导致插入失败。<br>





  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(</code><code>n+</code><code>I(n))</code>.<br>





  <b>异常安全性:</b> 强。
</blockquote>




  
<code>std::pair&lt;iterator,bool&gt; push_back(const value_type&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 将 <code>x</code> 插入到序列的末尾，如果 <code>multi_index_container </code>没有其它的索引禁止插入。<br>





  <b>返回:</b> 返回值是一个 pair <code>p</code>. <code>p.second</code>
为 <code>true</code> 当且仅当插入成功。插入成功时，<code>p.first</code> 指向插入的元素；否则，<code>p.first</code> 指向导致插入失败的元素。注意，可能存在一个以上的元素导致插入失败。<br>





  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(I(n))</code>.<br>





  <b>异常安全性:</b> 强。
</blockquote>





<code>std::pair&lt;iterator,bool&gt; insert(iterator position,const value_type&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的有效迭代器。<span style="font-weight: bold;"><br>



  </span><b>效果:</b> 将 <code>x</code> 插入到 position 之前，如果 <code>multi_index_container 的</code>其它索引都允许。<br>





  <b>返回:</b> 返回值是一个 pair <code>p</code>. <code>p.second</code>
为 <code>true</code> 当且仅当插入成功。插入成功时，<code>p.first</code> 指向插入的元素；否则，<code>p.first</code> 指向导致插入失败的元素。注意，可能存在一个以上的元素导致插入失败。<br>





  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(</code><code>shl(end()-position,1) + </code><code>I(n))</code>.<br>





  <b>异常安全性:</b> 强。
</blockquote>





<code>void insert(iterator position,size_type m,const value_type&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的有效迭代器。<span style="font-weight: bold;"><br>



  </span><b>效果:</b><b></b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="keyword">for</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span><span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">m</span><span class="special">;++</span><span class="identifier">i</span><span class="special">)</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">position</span><span class="special">,</span><span class="identifier">x</span><span class="special">);</span>
    </pre>



  </blockquote>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(shl(end()-position,m) + m*I(n+m))</code>.
</blockquote>





<code>template&lt;typename InputIterator&gt;<br>




void insert(iterator position,InputIterator first,InputIterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的有效迭代器。<code>InputIterator</code> 为一个
  <a href="http://www.sgi.com/tech/stl/InputIterator.html">
  <code>Input Iterator输入迭代器</code></a>，其指向的元素的类型是
  <code>value_type</code> 或可转换为 <code>value_type</code>.
  <code>first</code> 和 <code>last</code> 不可以是索引所属 <code>multi_index_container</code> 的任意索引的迭代器。<code>last</code> 可从 <code>first 到达。<span style="font-weight: bold;"><br>



效果</span></code><b>:</b><b></b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="keyword">while</span><span class="special">(</span><span class="identifier">first</span><span class="special">!=</span><span class="identifier">last</span><span class="special">)</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">position</span><span class="special">,*</span><span class="identifier">first</span><span class="special">++);</span>
    </pre>



  </blockquote>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(shl(end()-position,m) + m*I(n+m))</code>,
  <code>m</code> 为
[<code>first</code>,<code>last</code>) 中的元素数量。<br>




  <b>异常安全性</b><b>:</b> 基本。
</blockquote>





<code>iterator erase(iterator position);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 为索引的有效可提领迭代器。<span style="font-weight: bold;"><br>



效果</span><b>:</b> 删除 <code>position</code> 所指元素。<br>





  <b>返回:</b> 指向被删元素之后的元素的迭代器，如果该元素不存在，则返回 <code>end()</code>.<br>






  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(D(n))</code>.<br>






  <b>异常安全性:</b> 不抛出异常。<br>




</blockquote>





<code>iterator erase(iterator first,iterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> [<code>first</code>,<code>last</code>) 为索引的有效区间。<br>






  <b>效果:</b> 删除 [<code>first</code>,<code>last</code>) 中的元素。<br>






  <b>返回:</b> <code>last</code>.<br>






  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(m*D(n))</code>,&nbsp;<code>m</code> 为 [<code>first</code>,<code>last</code>) 中的元素数量。<br>






  <b>异常安全性:</b> 不抛出异常。<br>




</blockquote>





<a name="replace"><code>bool replace(iterator position,const value_type&amp; x);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 为索引的有效可提领迭代器。<br>




  <b>效果:</b> 将值&nbsp;<code>x</code> 赋给 <code>position</code> 所指元素，如果
  <code>multi_index_container 的其它索引允许该替换。<br>



  </code><span style="font-weight: bold;">后续条件</span><b>:</b> 任何情况下均保证 <code>position</code> 的有效性。<br>






  <b>返回:</b> 如果替换成功则返回 true，否则返回<code></code>
  <code>false</code>.<br>






  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(R(n))</code>.<br>






  <b>异常安全性:</b> 强。如果某个用户提供的操作抛出异常，则索引所属的 <code>multi_index_container</code> 将保留原有状态。
</blockquote>




  
<a name="modify">
<code>template&lt;typename Modifier&gt; bool modify(iterator position,Modifier mod);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>Modifier</code> 为
  <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
  <code>Unary Function一元函数</code></a>，接受一个类型为
  <code>value_type&amp;</code> 的参数。<code>position</code>&nbsp;为索引的有效可提领迭代器。<span style="font-weight: bold;"><br>




效果</span><b>:</b> 调用 <code>mod(e)，其中</code> <code>e</code> 为 <code>position</code> 所指元素，并对 multi_index_container 的所有索引重排 <code>*position</code><code></code>. 随机访问索引不会改变元素在该索引中的位置；其它索引的重排可能成功也可能不成功，如果重排失败，该元素将被删除。<br>






  <span style="font-weight: bold;">后续条件</span><b>:</b> 如果操作成功，将保证 <code>position</code> 的有效性。<br>






  <b>返回:</b> 如果操作成功则返回 <code>true，否则返回</code> <code>false</code>.<br>






  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(M(n))</code>.<br>






  <b>异常安全性:</b> 基本。如果某个用户提供的操(除了 <code>mod</code>)作抛出异常，则 position 所指元素将被删除。
</blockquote>





<h4 style="font-weight: normal;"><code>template&lt;typename Modifier,typename 
Rollback&gt;<br>
bool modify(iterator position,Modifier mod,Rollback 
back);</code> </h4>

<blockquote><b>要求：</b><code>Modifier</code> 和 <code>Rollback</code> 均为 <a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary 
Function一元函数</code></a>，接受类型为 <code>value_type&amp;</code> 
的参数。<code>position</code> 为索引的一个有效可提领迭代器。顺序操作 <code>mod(e)</code>, 
  <code>back(e)</code>, 其中 <code>e</code> 为 <code>position</code> 
所指向的元素，可以将元素的所有键恢复为原来的状态。<br>
  <b>作用：</b>调用 <code>mod(e)</code>，其中 <code>e</code> 
是 <code>position</code> 所指的元素，并对 <code>multi_index_container</code> 的所有索引重排 
  <code>*position</code>。其它索引的重排可能成功也可能不成功，如果重排失败，则 <code>back(e)</code> 
被调用，该元素的所有索引恢复到原来的位置。<br>
  <b>后续条件:</b>&nbsp;<code>position</code> 
的有效性将被保证，除非在下述情况下元素被删除。<br>
  <b>返回:</b> <code>true</code> 如果操作成功，否则返回 
  <code>false</code>.<br>
  <b>复杂度:</b> <code>O(M(n))</code>.<br>
  <b>异常安全性:</b> 强，除非 
  <code>back</code> 抛出异常，这种情况下已修改元素将被删除。如果 <code>back</code> 
是在用户提供的操作抛出异常后的处理代码中抛出的，则由 <code>back</code> 生成的异常被重抛出。 </blockquote>
<h4><a name="list_operations">List 操作</a></h4>





<p>
随机访问索引重复了序列索引的接口，从而也包含了 std::list 提供的 list 操作。这些操作的语法和行为与序列索引中的对应相同，但相关的复杂度通常不一样。
</p>





<code>void splice(iterator position,<b>index class name</b>&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的有效迭代器，且
  <code>&amp;x!=this</code>.
  <br>



  <span style="font-weight: bold;">效果</span><b>:</b> 将 x 的内容插入到 <code>position 之前，按照在 x 中的相同顺序。插入成功的元素将从 x 中删除。</code><br>





  <b>复杂度:</b> <code>O(</code><code>shl(end()-position,x.size()) + </code><code>x.size()*I(n+x.size()) + x.size()*D(x.size()))</code>.<br>





  <b>异常安全性:</b> 基本。<br>




</blockquote>





<code>void splice(iterator position,<b>index class name</b>&amp; x,iterator i);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的有效迭代器。<code>i</code> 是 x 的一个有效可提领迭代器。<br>





  <b>效果:</b> 将 i 所指的元素插入到
  <code>position 之前</code>: 如果插入成功，该元素从
  <code>x 中删除。在特殊情况</code> <code>&amp;x==this</code> 时，不执行任何复制和删除，且操作总是成功的。如果
  <code>position==i</code>, 没有操作被执行。<br>





  <span style="font-weight: bold;">后续条件</span><b>:</b> 如果 <code>&amp;x==this</code>, 则没有迭代器或引用会无效。<br>





  <b>复杂度:</b> 如果 <code>&amp;x==this</code>, 常量; 否则
  <code>O(</code><code>shl(end()-position,1) + </code><code>I(n) + D(n))</code>.<br>



  <span style="font-weight: bold;">异常安全性</span><b>:</b> 如果 <code>&amp;x==this</code>, 不抛出异常；否则为强异常安全。<br>




</blockquote>





<code>void splice(iterator position,<b>index class name&amp;</b> x,iterator first,iterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 为索引的有效迭代器。<code>first</code> 和 <code>last</code> 为 x 的有效迭代器。<code>last</code> 可以从 <code>first 到达。</code><code>position</code>
不在区间 [<code>first</code>,<code>last</code>) 中。<br>





  <b>效果:</b> 对于区间 [<code>first</code>,<code>last</code>) 中的每个元素，试图将其插入到 <code>position 之前；如果插入成功，则从</code> <code>x 中删除该元素。在特殊情况</code> case
  <code>&amp;x==this 时</code>, 不执行任何复制和删除，且插入总是成功的。<br>





  <span style="font-weight: bold;">后续条件</span><b>:</b> 如果 <code>&amp;x==this</code>, 则没有迭代器或引用会无效。<br>





  <b>复杂度:</b> 如果 <code>&amp;x==this</code>,&nbsp;<code>O(rel(position,first,last))</code>; 否则
  <code>O(</code><code>shl(end()-position,m) + </code><code>m*I(n+m) + m*D(x.size()))</code> 其中 <code>m</code> 为 [<code>first</code>,<code>last</code>) 中的元素数量。<br>





  <span style="font-weight: bold;">异常安全性</span><b>:</b> 如果 <code>&amp;x==this</code>, 不抛出异常；否则为基本异常安全。<br>




</blockquote>





<code>void remove(const value_type&amp; value);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 删除所有等于 value 的元素。<br>





  <b>复杂度:</b> <code>O(n + m*D(n))</code>, <code>m</code>
为被删元素数量。<br>





  <b>异常安全性:</b> 基本。
</blockquote>




  
<code>template&lt;typename Predicate&gt; void remove_if(Predicate pred);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 删除所有满足 <code>pred(x)</code> 的元素 x.<br>





  <b>复杂度:</b> <code>O(n + m*D(n))</code>, <code>m</code>
为被删元素数量。<br>





  <b>异常安全性:</b> 基本。
</blockquote>





<code>void unique();</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 对于每个连续的相等元素块，删掉除第一个元素以外的其它元素，即对于区间
[<code>first+1</code>,<code>last</code>) 中的迭代器 i，删除满足 <code>*i==*(i-1)</code> 的元素。<br>





  <b>复杂度:</b> <code>O(n + m*D(n))</code>, <code>m</code>
为被删元素数量。<br>





  <b>异常安全性:</b> 基本。
</blockquote>





<code>template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 对于区间
[<code>first+1</code>,<code>last</code>) 中的迭代器 i，删除满足&nbsp;<code>binary_pred(*i,*(i-1))</code><code></code> 的元素。<br>





  <b>复杂度:</b> <code>O(n + m*D(n))</code>, <code>m</code>
为被删元素数量。<br>





  <b>异常安全性:</b> 基本。
</blockquote>





<code>void merge(index class name&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>std::less&lt;value_type&gt;</code> 是 value_type 的一个
  <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
  <code>Strict Weak Ordering严格弱序</code></a>。索引本身以及 <code>x</code> 均依照
  <code>std::less&lt;value_type&gt; 来排序。</code><br>





  <b>效果:</b> 试图将 x 的每一个元素插入到索引的对应位置中(按顺序)。成功插入的元素将从 x 中删除。结果序列是稳定的，即每个容器的相等元素保持它们的相对位置。在特殊情况 <code>&amp;x==this 下，不执行操作。</code><br>





  <b>后续条件:</b> 索引中的元素以及 x 中剩余的元素都是已排序的。索引中的迭代器以及 x 中未删除元素的迭代器均保持有效。<br>





  <b>复杂度:</b> 如果 <code>&amp;x==this</code>, 常量; 否则
  <code>O(n + x.size()*I(n+x.size()) + x.size()*D(x.size()))</code>.<br>





  <span style="font-weight: bold;">异常安全性</span><b>:</b> 如果 <code>&amp;x==this</code>, 不抛出异常；否则为基本异常安全。<br>




</blockquote>




  
<code>template &lt;typename Compare&gt; void merge(index class name&amp; x,Compare comp);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>Compare</code> 是 value_type 的一个
  <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
  <code>Strict Weak Ordering</code></a><a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code>严格弱序</code></a>。索引本身以及 <code>x</code> 均依照&nbsp;<code>comp</code><code> 来排序。</code><br>





  <b>效果:</b> 试图将 x 的每一个元素插入到索引的对应位置中(按 comp 排序)。成功插入的元素将从 x 中删除。结果序列是稳定的，即每个容器的相等元素保持它们的相对位置。在特殊情况 <code>&amp;x==this 下，不执行操作。</code><br>





  <b>后续条件:</b> 索引中的元素以及 x 中剩余的元素都是按照 comp&nbsp;排好序的。索引中的迭代器以及 x 中未删除元素的迭代器均保持有效。<br>





  <b>复杂度:</b> 如果 <code>&amp;x==this</code>, 常量; 否则
  <code>O(n + x.size()*I(n+x.size()) + x.size()*D(x.size()))</code>.<br>





  <span style="font-weight: bold;">异常安全性</span><b>:</b> 如果 <code>&amp;x==this</code>, 不抛出异常；否则为基本异常安全。<br>




</blockquote>





<code>void sort();</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>std::less&lt;value_type&gt;</code> 是 value_type 的一个
  <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
  <code>Strict Weak Ordering严格弱序</code></a>。<br>





  <b>效果:</b> 按照
  <code>std::less&lt;value_type&gt; 对索引进行排序。排序是稳定的，即相等的元素保持它们的相对位置。</code><br>





  <b>后续条件:</b> 迭代器和引用的有效性被保持。<br>





  <b>复杂度:</b> <code>O(n*log(n))</code>.<br>





  <b>异常安全性:</b>&nbsp;<code></code>基本异常安全。
</blockquote>





<code>template &lt;typename Compare&gt; void sort(Compare comp);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b>&nbsp;<code>Compare</code> 是 value_type 的一个
  <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
  <code>Strict Weak Ordering严格弱序</code></a>。<br>





  <b>效果:</b> 按照 <code>comp 对索引进行排序。排序是稳定的，即相等的元素保持它们的相对位置。</code><br>





  <b>后续条件:</b> 迭代器和引用的有效性被保持。<br>





  <b>复杂度:</b> <code>O(n*log(n))</code>.<br>





  <b>异常安全性:</b>&nbsp;<code></code>基本异常安全。
</blockquote>





<code>void reverse();</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 将索引的元素顺序颠倒。<br>





  <b>后续条件:</b> 迭代器和引用的有效性被保持。<br>





  <b>复杂度:</b>&nbsp;<code>O(n)</code>.<br>





  <b>异常安全性:</b>&nbsp;不抛出异常。
</blockquote>





<h4><a name="rearrange_operations">重排操作</a></h4>





<p>这个操作在STL序列容器中没有相似的操作(虽然 <code>std::list::</code><code>splice</code> 提供了部分重叠的功能), 它对索引中的元素执行个别的和全局的重定位。
</p>





<code>void relocate(iterator position,iterator i);</code>

<blockquote>
  <b>要求:</b> <code>position</code> 是索引的有效迭代器。<code>i</code> 是索引的有效可提领迭代器。<br>





  <b>效果:</b> 将 i 所指元素重定位到
  <code>position 之前。如果</code> <code>position==i</code>, 则不执行操作。<br>





  <b>后续条件:</b> 没有迭代器或引用变为无效。<br>





  <b>复杂度:</b>&nbsp;<code>O(rel(position,i,i+1))</code>。<br>





  <b>异常安全性:</b>&nbsp;不抛出异常。<br>




</blockquote>





<code>void relocate(iterator position,iterator first,iterator last);</code>

<blockquote>
  <b>要求:</b> <code>position</code> 是索引的有效迭代器。f<code>irst 和 last</code> 是索引的有效迭代器。last 可以从 first 到达。position 不在区间 [<code>first</code>,<code>last</code>) 中。<br>





  <b>效果:</b> 将 [<code>first</code>,<code>last</code>) 中的元素重定位到
  <code>position 之前</code>。<br>





  <b>后续条件:</b> 没有迭代器或引用变为无效。<br>





  <b>复杂度:</b>&nbsp;<code>O(rel(position,first,last))</code>。<br>





  <b>异常安全性:</b>&nbsp;不抛出异常。<br>




</blockquote>





<a name="rearrange"><code>template&lt;typename InputIterator&gt; void rearrange(InputIterator first);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 区间 [<code>first</code>,
  <code>std::advance(first,n)</code>) 为索引的
  <a href="indices.html#views">free view自由视图</a>,
其中 <code>n</code> 为索引的大小。<br>





  <span style="font-weight: bold;">效果</span><b>:</b> 元素被重排，以符合前述视图的顺序。<br>





  <b>后续条件:</b> 没有迭代器或引用变为无效。<br>





  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(n)</code>.<br>





  <b>异常安全性:</b> 基本。<br>




</blockquote>





<h4><a name="serialization">序列化</a></h4>





<p>索引不可以自行序列化，只能作为所嵌入的
<code>multi_index_container</code> 的一部分。在描述有序索所属容器的序列化所要满足的前提条件和相关保证时，我们使用在 <code>multi_index_container</code>
<a href="multi_index_container.html#serialization">序列化一节</a> 中定义的概念。
</p>









操作: 保存一个 <code>multi_index_container</code> <code>m</code> 到一个输出档案(XML档案) <code>ar</code>.

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 没有额外的要求。</blockquote>





操作: 从一个输入档案(XML档案) <code>ar 导入一个</code> <code>multi_index_container</code> <code>m</code><code></code><code>'</code>.

<blockquote>
  <b>要求:</b> 没有额外要求。<br>








  <b>后续条件:</b> 若导入成功，[<code>begin()</code>, <code>end()</code>) 的每个元素为 [<code>m.get&lt;i&gt;().begin()</code>, <code>m.get&lt;i&gt;().end()</code>) 中各对应元素的恢复拷贝，i 为随机访问索引在容器中的位置。</blockquote>









操作: 保存一个迭代器或常量性迭代器
<code>it </code>到一个输出档案(XML档案) <code>ar</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 
  <code>it </code>须为索引的有效迭代器。相应的
  <code>multi_index_container</code> 在之前已保存。</blockquote>





操作: 从一个输入档案(XML档案) <code>ar 导入一个</code>代器或常量性迭代器 <code>it'</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">后续条件</span><b>:</b>&nbsp;导入成功时，若迭代器
  <code>it </code>可提领则 <code>*it'</code> 为 <code>*it 的恢复拷贝</code>, 否则
  <code>it'==end()</code>.<br>








  <span style="font-weight: bold;">注意</span><b>:</b> 允许以下情况，<code>it</code> 为常量性迭代器而恢复的 <code>it'</code> 为迭代器，或反之。</blockquote>

<hr>

<div class="prev_link"><a href="seq_indices.html"><img src="../prev.gif" alt="sequenced indices" border="0"><br>

序列索引
</a></div>




<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>




Boost.MultiIndex 参考
</a></div>




<div class="next_link"><a href="key_extraction.html"><img src="../next.gif" alt="key extraction" border="0"><br>

键提取
</a></div>



<br style="" clear="all">





<br>
<p>Revised June 25th 2008</p>

<p>© Copyright 2003-2008 Joaquín M López Muñoz. Distributed under the Boost 
Software License, Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) 
</p>
</body></html>
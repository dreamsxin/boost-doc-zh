<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html><head>




  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">





  
  
  
  
  
  
  
  <title>Boost.MultiIndex Documentation - Hashed indices reference</title><link rel="stylesheet" href="../style.css" type="text/css">




  
  
  
  <link rel="start" href="../index.html">




  
  
  
  <link rel="prev" href="ord_indices.html">




  
  
  
  <link rel="up" href="index.html">




  
  
  
  <link rel="next" href="seq_indices.html"></head>
<body>




<h1><img src="../../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">Boost.MultiIndex Hashed indices reference</h1>





<div class="prev_link"><a href="ord_indices.html"><img src="../prev.gif" alt="ordered indices" border="0"><br>



有序索引
</a></div>




<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>




Boost.MultiIndex 参考
</a></div>




<div class="next_link"><a href="seq_indices.html"><img src="../next.gif" alt="sequenced indices" border="0"><br>



序列索引
</a></div>



<br style="" clear="all">





<hr>

<h2>Contents目录</h2>





<ul>




  <li><a href="#hash_index_fwd_synopsis">头文件 <code>"boost/multi_index/hashed_index_fwd.hpp"</code> 摘要</a></li>




  <li><a href="#synopsis">头文件 <code>"boost/multi_index/hashed_index.hpp"</code> 摘要</a>
    
    
    
    
    <ul>




      <li><a href="#unique_non_unique">索引说明 <code>hashed_unique</code> 和 <code>hashed_non_unique</code>
        </a></li>




      <li><a href="#hash_indices">散列索引</a>
        
        
        
        
        <ul>




          <li><a href="#complexity_signature">复杂度署名</a></li>




          <li><a href="#instantiation_types">实例化类型</a></li>




          <li><a href="#types">嵌入类型</a></li>




          <li><a href="#constructors">构造函数、复制和赋值</a></li>
          <li><a href="#iterators">迭代器</a> </li>




          <li><a href="#modifiers">修饰器</a></li>




          <li><a href="#observers">观察员</a></li>




          <li><a href="#lookup">查找</a></li>
          <li><a href="#bucket_interface">桶接口</a></li>




          <li><a href="#hash_policy">散列策略</a></li>




          <li><a href="#serialization">序列化</a></li>




        
        
        
        
        </ul>




      </li>




    
    
    
    
    </ul>




  </li>




</ul>





<h2>
<a name="hash_index_fwd_synopsis">头文件 </a><a href="../../../../boost/multi_index/hashed_index_fwd.hpp"><code>"boost/multi_index/hashed_index_fwd.hpp"</code></a> 摘要</h2>





<blockquote>
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="comment">// 索引说明 hashed_unique 和 hashed_non_unique</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>consult hashed_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">hashed_unique</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><b>consult hashed_non_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">hashed_non_unique</span><span class="special">;</span>

<span class="comment">// 索引</span>
<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span> <span class="keyword">class</span> <b>index name is implementation defined</b><span class="special">;</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>



</blockquote>





<p>
<code>hashed_index_fwd.hpp</code> 提供了索引说明 
<a href="#unique_non_unique"><code>hashed_unique</code> 和 <code>hashed_non_unique</code></a> 及其相关的 <a href="hash_indices.html#hash_indices">hashed index散列索引</a> 类的前向说明。
</p>





<h2>
<a name="synopsis">头文件 </a><a href="../../../../boost/multi_index/hashed_index.hpp"><code>"boost/multi_index/hashed_index.hpp"</code></a> 摘要</h2>





<blockquote>
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="comment">// 索引说明 hashed_unique 和 hashed_non_unique</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>consult hashed_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">hashed_unique</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><b>consult hashed_non_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">hashed_non_unique</span><span class="special">;</span>

<span class="comment">// 索引</span>
<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span> <span class="keyword">class</span> <b>index class name implementation defined</b><span class="special">;</span>

<span class="comment">// 索引特定算法：</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>



</blockquote>





<h3><a name="unique_non_unique">索引说明 <code>hashed_unique</code> 和 <code>hashed_non_unique</code>
</a></h3>





<p>这两个 <a href="indices.html#index_specification">索引说明</a> 分别用于插入不允许和允许重复的 <a href="#hash_indices">散列索引</a>。<code>hashed_unique</code> 和 <code>hashed_non_unique</code> 的语法是一样的，因此我们一起来介绍它们。<code>hashed_unique</code> 和 <code>hashed_non_unique</code> 各有两种不同的实例化形式，分别是带或不带标志列表：
</p>





<blockquote>
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">KeyFromValue</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">Hash</span><span class="special">=</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">&gt;,</span>
  <span class="keyword">typename</span> <span class="identifier">Pred</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">&gt;</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="special">(</span><span class="identifier">hashed_unique</span> <span class="special">|</span> <span class="identifier">hashed_non_unique</span><span class="special">)</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">TagList</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">KeyFromValue</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">Hash</span><span class="special">=</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">&gt;,</span>
  <span class="keyword">typename</span> <span class="identifier">Pred</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">&gt;</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="special">(</span><span class="identifier">hashed_unique</span> <span class="special">|</span> <span class="identifier">hashed_non_unique</span><span class="special">)</span><span class="special">;</span>
  </pre>



</blockquote>





<p>如果有，<code>TagList</code> 必须是类模板
<a href="indices.html#tag"><code>tag</code></a> 的实例。所使用的模板参数依赖于索引的实现，可接受的类型值的相关解释请参见 <a href="#hash_indices">散列索引</a> 参考一节。
</p>





<h3><a name="hash_indices">散列索引</a></h3>





<p>散列索引通过散列技术提供了对 <code>multi_index_container</code> 中的元素的快速取出。散列索引的接口和语义是依照 C++
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">Proposed
Draft Tecnhical Report on Standard Library Extensions</a> (即TR1)中的非有序关联式容器的建议来设计的。散列索引通过一个给定的
<a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>，一个散列函数对象和一个二元谓词 Pred
来指定，键提取器从 <code>multi_index_container</code> 的元素中取出键值，散列函数对象返回键值的散列值，Pred 则用于判断键值的等价关系。
</p>





<p>有两类散列索引：<i>unique唯一的</i>, 它不允许重复的元素(以相关的等价谓词判断) 和 <i>non-unique非唯一的</i>, 它接受重复。这两类索引的接口是一样的，所以我们把它们一起介绍，只在有不同的时候明确指出。
</p>





<p>除非有特别声明，散列索引(包含唯一和非唯一的)是符合非有序关联式容器<code>的，即</code>
<code>std::tr1::unordered_set</code>s. 在任何情况下指向元素的迭代器和引用的有效性都被保护。有些时候还可以提供强于扩展草案所要求的异常安全保证。下面我们只对不符合该概念或不满足非有序关联式容器要求的部分类型和操作进行描述。
</p>





<blockquote>
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined: dependent on types Value, Allocator,<br>  TagList, KeyFromValue, Hash, Pred</b><span class="special">&gt;</span>
<span class="keyword">class</span> <b>name is implementation defined</b>
<span class="special">{</span> <br><span class="keyword">public</span><span class="special">:</span>
  <span class="comment">// 类型:</span>

  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span>         <span class="identifier">key_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Value</span>                                      <span class="identifier">value_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">KeyFromValue</span>                               <span class="identifier">key_from_value</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Hash</span>                                       <span class="identifier">hasher</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Pred</span>                                       <span class="identifier">key_equal</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">tuple</span><span class="special">&lt;</span>
    <span class="identifier">size_type</span><span class="special">,</span><span class="identifier">key_from_value</span><span class="special">,</span><span class="identifier">hasher</span><span class="special">,</span><span class="identifier">key_equal</span><span class="special">&gt;</span>       <span class="identifier">ctor_args</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Allocator</span>                                  <span class="identifier">allocator_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">pointer</span>                <span class="identifier">pointer</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">const_pointer</span>          <span class="identifier">const_pointer</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">reference</span>              <span class="identifier">reference</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">const_reference</span>        <span class="identifier">const_reference</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">size_type</span><span class="special">;</span>      <br>  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">difference_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">const_iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">local_iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">const_local_iterator</span><span class="special">;</span>

  <span class="comment">// 构造/析构/复制:</span>

  <b>index class name</b><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="identifier">allocator_type</span> <span class="identifier">get_allocator</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 大小和容量:</span>

  <span class="keyword">bool</span>      <span class="identifier">empty</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">max_size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 迭代器:</span>

  <span class="identifier">iterator</span>       <span class="identifier">begin</span><span class="special">();</span>
  <span class="identifier">const_iterator</span> <span class="identifier">begin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">iterator</span>       <span class="identifier">end</span><span class="special">();</span>
  <span class="identifier">const_iterator</span> <span class="identifier">end</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br>  <span class="identifier">const_iterator</span> <span class="identifier">cbegin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br>  <span class="identifier">const_iterator</span> <span class="identifier">cend</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span><br> <br>  <span class="identifier">iterator</span>       <span class="identifier">iterator_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br>  <span class="identifier">const_iterator</span> <span class="identifier">iterator_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><span class="special"></span>
 
  <span class="comment">// 修饰器:</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="identifier">iterator</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">InputIterator</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">InputIterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">InputIterator</span> <span class="identifier">last</span><span class="special">);</span>

  <span class="identifier">iterator</span>  <span class="identifier">erase</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">);</span>
  <span class="identifier">size_type</span> <span class="identifier">erase</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">key_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="identifier">iterator</span>  <span class="identifier">erase</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">);</span>

  <span class="keyword">bool</span> <span class="identifier">replace</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Modifier</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">modify</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">Modifier</span> <span class="identifier">mod</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Modifier</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">modify_key</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">Modifier</span> <span class="identifier">mod</span><span class="special">);</span>
  
  <span class="keyword">void</span> <span class="identifier">clear</span><span class="special">();</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="comment">// 观察员:</span>

  <span class="identifier">key_from_value</span> <span class="identifier">key_extractor</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">hasher</span>         <span class="identifier">hash_function</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">key_equal</span>      <span class="identifier">key_eq</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 查找:</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">find</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleHash</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">CompatiblePred</span>
  <span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">find</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleHash</span><span class="special">&amp;</span> <span class="identifier">hash</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatiblePred</span><span class="special">&amp;</span> <span class="identifier">eq</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <br><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">size_type</span> <span class="identifier">count</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleHash</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">CompatiblePred</span>
  <span class="special">&gt;</span>
  <span class="identifier">size_type</span> <span class="identifier">count</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleHash</span><span class="special">&amp;</span> <span class="identifier">hash</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatiblePred</span><span class="special">&amp;</span> <span class="identifier">eq</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="identifier">iterator</span><span class="special">&gt;</span> <span class="identifier">equal_range</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleHash</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">CompatiblePred</span>
  <span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="identifier">iterator</span><span class="special">&gt;</span> <span class="identifier">equal_range</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,<br>    </span><span class="keyword">const</span> <span class="identifier">CompatibleHash</span><span class="special">&amp;</span> <span class="identifier">hash</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatiblePred</span><span class="special">&amp;</span> <span class="identifier">eq</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 桶接口:</span>

  <span class="identifier">size_type</span> <span class="identifier">bucket_count</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">max_bucket_count</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">bucket_size</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">bucket</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">key_type</span><span class="special">&amp;</span> <span class="identifier">k</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="identifier">local_iterator</span>       <span class="identifier">begin</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">);</span>
  <span class="identifier">const_local_iterator</span> <span class="identifier">begin</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">local_iterator</span>       <span class="identifier">end</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">);</span>
  <span class="identifier">const_local_iterator</span> <span class="identifier">end</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 散列策略:</span>

  <span class="keyword">float</span> <span class="identifier">load_factor</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">float</span> <span class="identifier">max_load_factor</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">void</span>  <span class="identifier">max_load_factor</span><span class="special">(</span><span class="keyword">float</span> <span class="identifier">z</span><span class="special">);</span>
  <span class="keyword">void</span>  <span class="identifier">rehash</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">);</span>
<span class="special">};</span>

<span class="comment">// 索引特定的算法:</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>



</blockquote>





<h4><a name="complexity_signature">复杂度署名</a></h4>





<p>在以下对散列索引操作的描述中，我们采用在 
<a href="indices.html#complexity_signature">complexity signature
一节</a> 中描述的方案。散列索引的复杂度署名如下：
</p>



<ul>




  <li>复制: <code>c(n)=n*log(n)</code>,</li>




  <li>插入: 平均情况 <code>i(n)=1</code> (常量),
    最坏情况 <code>i(n)=n</code>,</li>




  <li>带提示的插入: 平均情况 <code>h(n)=1</code> (常量), 最坏情况 <code>h(n)=n</code>,</li>




  <li>删除: 平均情况 <code>d(n)=1</code> (常量), 最坏情况 <code>d(n)=n</code>,</li>




  <li>替换:
    
    
    
    
    <ul>




      <li>如果新元素的键值与原来的相等, <code>r(n)=1</code> (常量),</li>




      <li>否则, 平均情况 <code>r(n)=1</code> (常量), 最坏情况 <code>r(n)=n</code>,</li>




    
    
    
    
    </ul>



  </li>




  <li>修改: 平均情况 <code>m(n)=1</code> (常量), 最坏情况 <code>m(n)=n</code>.</li>




</ul>






<h4><a name="instantiation_types">实例化类型</a></h4>





<p>散列索引在 <code>multi_index_container</code> 的内部进行实例化，以带&nbsp;<a href="hash_indices.html#unique_non_unique"><code>hashed_unique</code> 和 <code>hashed_non_unique 索引说明</code></a> 的 <a href="indices.html#indexed_by"><code>indexed_by</code></a>
表示。实例化依赖于以下类型：
</p>



<ul>




  <li><code>Value</code> 来自于 <code>multi_index_container</code>,</li>




  <li><code>Allocator</code> 来自于 <code>multi_index_container</code>,</li>




  <li><code>TagList</code> 来自于索引说明(如果有),</li>




  <li><code>KeyFromValue</code> 来自于索引说明,</li>




  <li><code>Hash</code> 来自于索引说明,</li>




  <li><code>Pred</code>&nbsp;来自于索引说明.</li>




</ul>




<code>TagList</code> 必须是
<a href="indices.html#tag"><code>tag</code></a> 的一个实例。类型 <code>KeyFromValue</code>,
用于决定从 Value 取出键值的方法，必须是一个作用于 Value 的 <a href="key_extraction.html#key_extractors">
<code>Key Extractor键提取器</code></a><code></code>. <code>Hash</code> 是一个
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary Function一元函数</code></a>，接受一个类型为 <code>KeyFromValue::result_type</code> 的参数并返回一个类型为 <code>std::size_t</code> 的值，返回值的范围为
<code>[0, std::numeric_limits&lt;std::size_t&gt;::max())</code>.
<code>Pred</code> 是一个
<a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
<code>Binary Predicate二元谓词</code></a>，用于判断 <code>KeyFromValue::result_type 元素间的等价关系。对于按 Pred 相等的键值，要求 Hash 对象返回相同的值。</code>


<h4><a name="types">嵌套类型</a></h4>





<code>ctor_args</code>

<blockquote>这个 tuple 的第一个元素表示在索引构造时设置的桶的最小数量。如果使用了缺省值0，则以实现定义的数量来替代。
</blockquote>





<code>iterator<br>




const_iterator<br>




local_iterator<br>




const_local_iterator</code>

<blockquote>以上类型符合 <a href="http://www.sgi.com/tech/stl/ForwardIterator.html"><code>Forward
Iterator前向迭代器</code></a>.
</blockquote>





<h4><a name="constructors">构造函数，复制和赋值</a></h4>





<p>正如 <a href="indices.html#index_concepts">index
concepts 一节</a> 中的解释，索引没有公有的构造函数和析构函数。而赋值是有提供的。在构造时，<code>max_load_factor()</code> 为 1.0.
</p>





<code><b>index class name</b>&amp; operator=(const <b>index class name</b>&amp; x);</code>

<blockquote>
  <b>效果:</b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="identifier">a</span><span class="special">=</span><span class="identifier">b</span><span class="special">;</span>
    </pre>



  </blockquote>




其中 <code>a</code> 和 <code>b</code> 分别为 *this 和 x 所属的 <code>multi_index_container</code>
对象。<br>




  <b>返回:</b> <code>*this</code>.<br>




</blockquote>





<h4><a name="iterators">迭代器</a></h4>
<code>iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator_to(const 
value_type&amp; x);<br>
const_iterator iterator_to(const value_type&amp; 
x)const;</code> 
<blockquote><b>要求：</b><code>x</code> 是容器中某个元素的引用。<br>
  <b>返回：</b>指向 
  <code>x</code> 的一个迭代器。<br>
  <b>复杂度：</b>常数。<br>
  <b>异常安全性：</b><code>不抛出。</code><br>
</blockquote>
<h4><a name="modifiers">修饰器</a></h4>





<code>std::pair&lt;iterator,bool&gt; insert(const value_type&amp; x);</code>

<blockquote>
  <b>效果:</b> 将 <code>x</code> 插入到索引所属的 <code>multi_index_container，如果</code>
  
  
  
  <ul>




  <li>索引是非唯一的或者没有其它相等键值的元素存在,</li>




  <li>并且插入操作被
    <code>multi_index_container</code> 的其它所有索引所允许。</li>




  
  
  
  </ul>




  <b>返回:</b> 返回值为 pair <code>p</code>. <code>p.second</code>
为真当且仅当插入成功。插入成功时，<code>p.first</code> 指向被插入的元素；否则，<code>p.first</code>
指向导致插入失败的元素。注意，可能存在一个以上的元素导致插入失败。<br>




  <b>复杂度:</b> <code>O(I(n))</code>.<br>




  <b>异常安全性:</b> 强。<br>




</blockquote>





<code>iterator insert(iterator position,const value_type&amp; x);</code>

<blockquote>
  <b>要求:</b> <code>position</code> 为索引的有效迭代器。<br>


  <b>效果:</b> 将 <code>x</code> 插入到索引所属的 <code>multi_index_container，如果</code>
  
  
  
  <ul>


    <li>索引是非唯一的或者没有其它相等键值的元素存在,</li>


    <li>并且插入操作被
    <code>multi_index_container</code> 的其它所有索引所允许。</li>


  
  
  </ul>


  <code>position</code> 用于提示以提高插入操作的效率。<br>




  <b>返回:</b> 插入成功时，返回新插入元素的迭代器。否则，返回指向导致插入失败的元素的迭代器。注意，可能存在一个以上的元素导致插入失败。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(H(n))</code>.<br>




  <b>异常安全性:</b> 强。<br>




</blockquote>





<code>template&lt;typename InputIterator&gt;<br>




void insert(InputIterator first,InputIterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>InputIterator</code> 符合
  <a href="http://www.sgi.com/tech/stl/InputIterator.html">
  <code>Input Iterator输入迭代器</code></a>，其指向的元素类型为
  <code>value_type</code> 或可转换为 <code>value_type</code>.
  <code>first</code> 和 <code>last</code> 不可以是索引所属 <code>multi_index_container</code> 的任意索引的迭代器。<code>last</code> 可从 <code>first 到达。<br>


  </code><span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  <blockquote>
    
    
    
    <pre><span class="identifier">iterator</span> <span class="identifier">hint</span><span class="special">=</span><span class="identifier">end</span><span class="special">();</span>
<span class="keyword">while</span><span class="special">(</span><span class="identifier">first</span><span class="special">!=</span><span class="identifier">last</span><span class="special">)</span><span class="identifier">hint</span><span class="special">=</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">hint</span><span class="special">,*</span><span class="identifier">first</span><span class="special">++);</span>
    </pre>



  </blockquote>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(m*H(n+m))</code>,&nbsp;<code>m</code> 为 [<code>first</code>,
  <code>last</code>) 中的元素数量。<br>




  <b>异常安全性:</b><b></b> 基本。<br>




</blockquote>





<code>iterator erase(iterator position);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 为索引的有效可提领迭代器。<br>


  <b>效果:</b> 删除 <code>position</code> 所指的元素。<br>




  <b>返回:</b> 指向被删元素之后的元素的迭代器，如果该元素不存在，则返回 <code>end()</code>.<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(D(n))</code>.<br>




  <b>异常安全性:</b><b></b> 不抛出异常。<br>




</blockquote>





<code>size_type erase(const key_type&amp; x);</code>

<blockquote>
  <b>效果:</b> 删除键值等于 <code>x</code> 的元素。<br>




  <b>返回:</b> 删除的元素数量。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况, <code>O(1 + m*D(n))</code>, 最坏情况
  <code>O(n + m*D(n))</code>,&nbsp;<code>m</code> 为删除的元素数量。<br>




  <b>异常安全性:</b> 基本。<br>




</blockquote>





<code>iterator erase(iterator first,iterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> [<code>first</code>,<code>last</code>) 为索引的有效区间。<br>




  <b>效果:</b> 删除 [<code>first</code>,<code>last</code>) 中的元素。<br>




  <b>返回:</b> <code>last</code>.<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(m*D(n))</code>,&nbsp;<code>m</code> 为 [<code>first</code>,<code>last</code>) 中的元素数量。<br>




  <b>异常安全性:</b> 不抛出异常。<br>




</blockquote>





<a name="replace"><code>bool replace(iterator position,const value_type&amp; x);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 为索引的有效可提领迭代器。<br>


  <b>效果:</b> 将值&nbsp;<code>x</code> 赋给 <code>position</code> 所指元素，如果：<code></code>
  
  
  
  <ul>




  <li>索引是非唯一的或者没有其它相等键值的元素(除了 <code>*position</code> 以外)存在,</li>


    <li>并且插入操作被
    <code>multi_index_container</code> 的其它所有索引所允许。</li>


  
  
  </ul>




  <span style="font-weight: bold;">后续条件</span><b>:</b> 任何情况下均保证 <code>position</code> 的有效性。如果新值的键值与原值相等，则元素的位置不变。<br>




  <b>返回:</b> 如果替换成功则返回 true，否则返回<code></code>
  <code>false</code>.<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(R(n))</code>.<br>




  <b>异常安全性:</b> 强。如果某个用户提供的操作抛出异常，则索引所属的 <code>multi_index_container</code> 将保留原有状态。
</blockquote>




  
<a name="modify">
<code>template&lt;typename Modifier&gt; bool modify(iterator position,Modifier mod);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>Modifier</code> 为
  <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
  <code>Unary Function一元函数</code></a>，接受一个类型为
  <code>value_type&amp;</code> 的参数。<code>position</code>&nbsp;为索引的有效可提领迭代器。<span style="font-weight: bold;"><br>


效果</span><b>:</b> 调用 <code>mod(e)，其中</code> <code>e</code> 为 <code>position</code> 所指元素，并对 multi_index_container 的所有索引重排 <code>*position</code><code></code>. 重排将成功，如果
  
  
  
  <ul>




  <li>索引是非唯一的或者没有其它相等键值的元素存在,</li>


    <li>并且重排被
    <code>multi_index_container</code> 的其它所有索引所允许。</li>


  
  
  </ul>


如果重排失败，该元素将被删除。<br>




  <span style="font-weight: bold;">后续条件</span><b>:</b> 如果操作成功，将保证 <code>position</code> 的有效性。如果新值的键值与原值相等，则元素的位置不变。<br>




  <b>返回:</b> 如果操作成功则返回 <code>true，否则返回</code> <code>false</code>.<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(M(n))</code>.<br>




  <b>异常安全性:</b> 基本。如果某个用户提供的操(除了 <code>mod</code>)作抛出异常，则 position 所指元素将被删除。
</blockquote>





    
<code>template&lt;typename Modifier,typename Rollback&gt;<br>
bool 
modify(iterator position,Modifier mod,Rollback back);</code> 
<blockquote><b>要求：</b><code>Modifier</code> 和 <code>Rollback</code> 均为 <a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary 
Function一元函数</code></a>，接受类型为 <code>value_type&amp;</code> 
的参数。<code>position</code> 为索引的一个有效可提领迭代器。顺序操作 <code>mod(e)</code>, 
  <code>back(e)</code>, 其中 <code>e</code> 为 <code>position</code> 
所指向的元素，可以将元素的所有键恢复为原来的状态。<br>
  <b>作用：</b>调用 <code>mod(e)</code>，其中 <code>e</code> 
是 <code>position</code> 所指的元素，并对 <code>multi_index_container</code> 的所有索引重排 
  <code>*position</code>。重排将在满足以下条件时成功： 
  <ul>
    <li>索引是非唯一的或者没有其它元素具有相等的键值， 
    </li>
    <li>并且重排被 <code>multi_index_container</code> 的其它所有索引所允许。 </li>
  </ul>
如果重排失败，则 
  <code>back(e)</code> 被调用，该元素的所有索引恢复到原来的位置。<br>
  <b>后续条件:</b>&nbsp;<code>position</code> 
的有效性将被保证，除非在下述情况下元素被删除。如果新值的键值与原值相等，则元素的位置不变。<br>
  <b>返回:</b> <code>true</code> 如果操作成功，否则返回 
  <code>false</code>.<br>
  <b>复杂度:</b> <code>O(M(n))</code>.<br>
  <b>异常安全性:</b> 强，除非 
  <code>back</code> 抛出异常，这种情况下已修改元素将被删除。如果 <code>back</code> 
是在用户提供的操作抛出异常后的处理代码中抛出的，则由 <code>back</code> 生成的异常被重抛出。 </blockquote>
<a name="modify_key"><code>template&lt;typename Modifier&gt; bool modify_key(iterator position,Modifier mod);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>key_from_value</code> 是 value_type 的一个读/写
  <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>。<code>Modifier</code> 是一个
  <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
  <code>Unary Function一元函数</code></a>，接受一个类型为
  <code>key_type&amp; 的参数。</code><code>position</code> 为索引的有效可提领迭代器。<span style="font-weight: bold;"><br>


效果</span><b>:</b> 调用&nbsp;<code>mod(k)，其中</code> <code>k</code>&nbsp;通过索引内部的 <code>KeyFromValue</code> 对象从 position 所指元素获得，并对 multi_index_container 的所有索引重排 <code>*position</code><code></code>. 重排将成功，如果
  
  
  
  <ul>


    <li>索引是非唯一的或者没有其它相等键值的元素存在,</li>


    <li>并且重排被
    <code>multi_index_container</code> 的其它所有索引所允许。</li>


  
  
  </ul>


如果重排失败，该元素将被删除。<br>




  <span style="font-weight: bold;">后续条件</span><b>:</b> 如果操作成功，将保证 <code>position</code> 的有效性。<br>




  <b>返回:</b> 如果操作成功则返回 <code>true，否则返回</code> <code>false</code>.<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(M(n))</code>.<br>




  <b>异常安全性:</b> 基本。如果某个用户提供的操(除了 <code>mod</code>)作抛出异常，则 position 所指元素将被删除。
</blockquote>





<h4 style="font-weight: normal;"><code>template&lt;typename Modifier,typename 
Rollback&gt;<br>
bool modify_key(iterator position,Modifier mod,Rollback 
back);</code> </h4>

<blockquote><span style="font-weight: bold;">要求</span><b>:</b> 
  <code>key_from_value</code> 是一个用于 <code>value_type</code> 的读/写 <a href="key_extraction.html#key_extractors"><code>Key 
Extractor键提取器</code></a>。<code>Modifier</code><code></code> 和 
  <code>Rollback</code> 是 <a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary 
Function一元函数</code></a>，接受类型为 <code>key_type&amp; 
的参数</code>。<code>position</code> 是索引的有效可提领迭代器。顺序操作 <code>mod(k)</code>, 
  <code>back(k)</code>, 其中 <code>k</code> 为 <code>position</code> 所指向的元素的键，可以将 k 
恢复为原来的状态。<span style="font-weight: bold;"></span><br>
  <span style="font-weight: bold;">效果：</span>等价于 
  <code>modify(position,mod',back')</code>, 其中 <code>mod'</code> 和 
  <code>back</code> 按如下方式定义，<code>mod'(x)</code> 等同于 <code>mod(key(x))</code> 而 
  <code>back'(x)</code> 等同于 <code>back(key(x))</code>, 其中 <code>key</code> 是索引内部的 
  <code>KeyFromValue</code> 对象。 </blockquote>
<h4><a name="observers">观察员</a></h4>





<p>除了标准的 <code>hash_function</code> 和 <code>key_eq</code> 以外，散列索引还有一个成员函数用于取出内部的键提取器。
</p>





<code>key_from_value key_extractor()const;</code>

<blockquote>返回用于索引构造的 <code>key_from_value</code> 对象的一个拷贝。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 常量时间。
</blockquote>





<h4><a name="lookup">查找</a></h4>





<p>散列索引提供了非有序关联式容器所要求的所有查找功能，如 <code>find</code>,
<code>count</code>, 和 <code>equal_range</code>. 另外，这些成员函数都被模板化，可以接受非标准的参数，扩展了查找操作所允许的类型。可用于调用查找成员函数的参数种类定义为以下概念。
</p>





<p>考虑一个 pair (<code>Hash</code>, <code>Pred</code>)，其中
<code>Hash</code> 为类型 Key 的一个散列函数对象，而 <code>Pred</code> 为判断 Key 的等价关系的
<a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
<code>Binary Predicate二元谓词</code></a>，且规定相等键值必有相同散列值。一个三元类型组 (<code>CompatibleKey</code>, <code>CompatibleHash</code>,
<code>CompatiblePred</code>) 被称为 (<code>Hash</code>, <code>Pred</code>) 的 <i>兼容扩展</i>，如果
</p>



<ol>




  <li><code>CompatibleHash</code> 为类型 <code>CompatibleKey</code> 的一个散列函数对象,</li>




  <li><code>CompatiblePred</code> 为 (<code>Key</code>,
    <code>CompatibleKey</code>) 之上的
    <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
    <code>Binary Predicate二元谓词</code></a>,</li>




  <li><code>CompatiblePred</code> 为 (<code>CompatibleKey</code>,
    <code>Key</code>) 之上的
    <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
    <code>Binary Predicate二元谓词</code></a>,</li>




  <li>如果 <code>c_eq(ck,k1)</code> 则 <code>c_eq(k1,ck)</code>,</li>




  <li>如果 <code>c_eq(ck,k1)</code> 且 <code>eq(k1,k2)</code> 则
    <code>c_eq(ck,k2)</code>,</li>




  <li>如果 <code>c_eq(ck,k1)</code> 且 <code>c_eq(ck,k2)</code> 则
    <code>eq(k1,k2)</code>,</li>




  <li>如果 <code>c_eq(ck,k1)</code> 则 <code>c_hash(ck)==hash(k1)</code>,</li>




</ol>


其中 <code>c_hash</code> 的类型为 <code>CompatibleHash</code>,
<code>c_eq</code> 的类型为 <code>CompatiblePred</code>,
<code>hash</code> 的类型为 <code>Hash</code>,
<code>eq</code> 的类型为 <code>Pred</code>, <code>ck</code> 的类型为
<code>CompatibleKey</code>，<code>k1</code>, <code>k2</code> 的类型为
<code>Key</code>.


<p>另外，类型 <code>CompatibleKey</code> 被称为 (<code>Hash</code>, <code>Pred</code>) 的<i>兼容键</i>，如果 (<code>CompatibleKey</code>, <code>Hash</code>, <code>Pred</code>)
为 (<code>Hash</code>, <code>Pred</code>) 的兼容扩展。这意味着 <code>Hash</code> 和 <code>Pred</code> 可以接受类型为 <code>CompatibleKey 的参数，通常存在相应的多个重载的</code> <code>operator()</code>
成员函数。
</p>





<p>在兼容扩展或兼容键的上下文中，表达式
"等价键" 采用其普通意义的解释。
</p>





<code>template&lt;typename CompatibleKey&gt; iterator find(const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>CompatibleKey</code> 为
(<code>hasher</code>, <code>key_equal</code>) 的兼容键。<br>


  <span style="font-weight: bold;">效果</span><b>:</b> 返回一个指针，指向键值等价于 x 的元素，如果该元素不存在，返回 <code>end()</code>.<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况 <code>O(1)</code> (常量), 最坏情况
  <code>O(n)</code>.<br>




</blockquote>





<code>template&lt;<br>




&nbsp;&nbsp;typename CompatibleKey,typename CompatibleHash, typename CompatiblePred<br>




&gt;<br>




iterator find(<br>




&nbsp;&nbsp;const CompatibleKey&amp; x,<br>




&nbsp;&nbsp;const CompatibleHash&amp; hash,const CompatiblePred&amp; eq)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> (<code>CompatibleKey</code>, <code>CompatibleHash</code>,
  <code>CompatiblePred</code>) 为
(<code>hasher</code>, <code>key_equal</code>) 的兼容扩展。<br>


  <b>效果:</b> 返回一个指针，指向键值等价于 x 的元素，如果该元素不存在，返回 <code>end()</code>.<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况 <code>O(1)</code> (常量), 最坏情况
  <code>O(n)</code>.<br>




</blockquote>





<code>template&lt;typename CompatibleKey&gt;<br>




size_type count(const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>CompatibleKey</code> 为
(<code>hasher</code>, <code>key_equal</code>) 的兼容键。<br>


  <b>效果:</b> 返回键值等于 x 的元素数量。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况&nbsp;<code>O(count(x))</code>, 最坏情况
  <code>O(n)</code>.<br>




</blockquote>





<code>template&lt;<br>




&nbsp;&nbsp;typename CompatibleKey,typename CompatibleHash, typename CompatiblePred<br>




&gt;<br>




size_type count(<br>




&nbsp;&nbsp;const CompatibleKey&amp; x,<br>




&nbsp;&nbsp;const CompatibleHash&amp; hash,const CompatiblePred&amp; eq)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b>&nbsp;(<code>CompatibleKey</code>, <code>CompatibleHash</code>,
  <code>CompatiblePred</code>) 为
(<code>hasher</code>, <code>key_equal</code>) 的兼容扩展。<span style="font-weight: bold;"><br>


  </span><b>效果:</b> 返回键值等于 x 的元素数量。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况&nbsp;<code>O(count(x</code><code>,hash,eq</code><code>))</code>, 最坏情况
  <code>O(n)</code>.<br>




</blockquote>





<code>template&lt;typename CompatibleKey&gt;<br>




std::pair&lt;iterator,iterator&gt; equal_range(const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:&nbsp;</b><code>CompatibleKey</code> 为
(<code>hasher</code>, <code>key_equal</code>) 的兼容键。<br>


  <span style="font-weight: bold;">效果</span><b>:</b> 返回包含所有键值等于 x 的元素(且仅这些元素)的区间。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况&nbsp;<code>O(count(x))</code>, 最坏情况
  <code>O(n)</code>.<br>




</blockquote>





<code>template&lt;<br>




&nbsp;&nbsp;typename CompatibleKey,typename CompatibleHash, typename CompatiblePred<br>




&gt;<br>




std::pair&lt;iterator,iterator&gt; equal_range(
&nbsp;&nbsp;const CompatibleKey&amp; x,<br>




&nbsp;&nbsp;const CompatibleHash&amp; hash,const CompatiblePred&amp; eq)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b>&nbsp;(<code>CompatibleKey</code>, <code>CompatibleHash</code>,
  <code>CompatiblePred</code>) 为
(<code>hasher</code>, <code>key_equal</code>) 的兼容扩展。<span style="font-weight: bold;"><br>


  </span><span style="font-weight: bold;">效果</span><b>:</b> 返回包含所有键值等于 x 的元素(且仅这些元素)的区间。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况&nbsp;<code>O(count(x</code><code>,hash,eq</code><code>))</code>, 最坏情况
  <code>O(n)</code>.<br>




</blockquote>






<h4><a name="bucket_interface">桶接口</a></h4>
<code>local_iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_iterator_to(const 
value_type&amp; x);<br>
const_local_iterator local_iterator_to(const 
value_type&amp; x)const;</code> 
<blockquote><b>要求：</b><code>x</code> 是容器中某个元素的引用。<br>
  <b>返回：</b>指向
  <code>x</code> 的一个迭代器。<br>
  <b>复杂度：</b>常数。<br>
  <b>异常安全性：</b> 不抛出。<br>
</blockquote>
<h4><a name="hash_policy">散列策略</a></h4>





<code>void rehash(size_type n);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 如果需要，增加内部桶的数量，以使得 <code>size()/bucket_count()</code> 不超过最大负载因子，且 <code>bucket_count()&gt;=n</code>.<br>




  <span style="font-weight: bold;">后续条件</span><b>:</b> 所含元素的迭代器和引用的有效性被保证。<br>




  <span style="font-weight: bold;">复杂度</span><b>:</b> 平均情况 <code>O(size())</code>, 最坏情况
  <code>O(size(n)<sup>2</sup>)</code>.<br>




  <b>异常安全性:</b> 强。
</blockquote>





<h4><a name="serialization">序列化</a></h4>





<p>索引不可以自行序列化，只能作为所嵌入的
<code>multi_index_container</code> 的一部分。在描述有序索所属容器的序列化所要满足的前提条件和相关保证时，我们使用在 <code>multi_index_container</code>
<a href="multi_index_container.html#serialization">序列化一节</a> 中定义的概念。
</p>







操作: 保存一个 <code>multi_index_container</code> <code>m</code> 到一个输出档案(XML档案) <code>ar</code>.

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 没有额外的要求。</blockquote>



操作: 从一个输入档案(XML档案) <code>ar 导入一个</code> <code>multi_index_container</code> <code>m</code><code></code><code>'</code>.

<blockquote>
  <b>要求:</b> 有额外要求，<code>key_eq</code><code>()</code> 必须与 <code>m.get&lt;i&gt;().</code><code>key_eq</code><code>()</code> 序列化兼容,
其中 <code>i</code> 为有序索引在容器中的位置。<br>






  <b>后续条件:</b> 若导入成功，[<code>begin()</code>, <code>end()</code>) 的每个元素为 [<code>m.get&lt;i&gt;().begin()</code>, <code>m.get&lt;i&gt;().end()</code>) 中各对应元素的恢复拷贝，但不需要顺序相同。
</blockquote>







操作: 保存一个迭代器或常量性迭代器
<code>it </code>到一个输出档案(XML档案) <code>ar</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 
  <code>it </code>须为索引的有效迭代器。相应的
  <code>multi_index_container</code> 在之前已保存。</blockquote>



操作: 从一个输入档案(XML档案) <code>ar 导入一个</code>代器或常量性迭代器 <code>it'</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">后续条件</span><b>:</b>&nbsp;导入成功时，若
  <code>it </code>可提领则 <code>*it'</code> 为 <code>*it 的恢复拷贝</code>, 否则
  <code>it'==end()</code>.<br>






  <span style="font-weight: bold;">注意</span><b>:</b> 允许以下情况，<code>it</code> 为常量性迭代器而恢复的 <code>it'</code> 为迭代器，或反之。</blockquote>


操作: 保存一个 <code>local_iterator</code> 或
<code>const_local_iterator</code>
<code>it</code> 到一个输出档案(XML档案) <code>ar</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b>&nbsp;
  <code>it </code>须为索引的有效迭代器。相应的
  <code>multi_index_container</code> 在之前已保存。
</blockquote>





操作: 从一个输入档案(XML档案) <code>ar 导入一个</code> <code>local_iterator</code> 或
<code>const_local_iterator</code>
<code>it'</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">后续条件</span><b>:</b>&nbsp;导入成功时，若迭代器可提领则 <code>*it'</code> 为 <code>*it 的恢复拷贝</code>；如果对于某个 n ，it 为 <code>m.get&lt;i&gt;().end(n)</code>,&nbsp;则&nbsp;<code>it'==m'.get&lt;i&gt;().end(n) (其中 m 为原来的</code>
  <code>multi_index_container</code>，<code>m'</code> 为 m 的恢复拷贝，<code>i</code> 为索引序号)。<br>






  <span style="font-weight: bold;">注意</span><b>:</b> 允许以下情况，<code>it</code> 为 <code>const_local_iterator</code> 而恢复的 <code>it'</code> 为 <code>local_iterator</code>，或反之。
</blockquote>





<hr>

<div class="prev_link"><a href="ord_indices.html"><img src="../prev.gif" alt="ordered indices" border="0"><br>


有序索引
</a></div>




<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>




Boost.MultiIndex 参考
</a></div>




<div class="next_link"><a href="seq_indices.html"><img src="../next.gif" alt="sequenced indices" border="0"><br>




序列索引
</a></div>



<br style="" clear="all">





<br>
<p>Revised June 25th 2008</p>

<p>© Copyright 2003-2008 Joaquín M López Muñoz. Distributed under the Boost 
Software License, Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</body></html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Root Finding With Derivatives</title>
<link rel="stylesheet" href="../../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_2006-12-17_0120">
<link rel="start" href="../../../index.html" title="Math Toolkit">
<link rel="up" href="../internals1.html" title="Reused Utilities">
<link rel="prev" href="rational.html" title="Polynomial and Rational Function Evaluation">
<link rel="next" href="roots2.html" title="Root Finding Without Derivatives">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="rational.html"><img src="../../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../internals1.html"><img src="../../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="roots2.html"><img src="../../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div>
  <h4 class="title">
<a name="math_toolkit.toolkit.internals1.roots"></a><a href="roots.html" title="Root Finding With Derivatives"> 使用导数查找根(Root Finding
        With Derivatives)</a>
</h4>
</div></div></div>
<a name="math_toolkit.toolkit.internals1.roots.synopsis"></a>
<h5>
<a name="id781954"></a>
          <a href="roots.html#math_toolkit.toolkit.internals1.roots.synopsis">概要</a>
  </h5>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">tools</span><span class="special">/</span><span class="identifier">roots</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
  </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">math</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">tools</span><span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">newton_raphson_iterate</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">max</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">digits</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">newton_raphson_iterate</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">max</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">digits</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">halley_iterate</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">max</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">digits</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">halley_iterate</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">max</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">digits</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">schroeder_iterate</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">max</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">digits</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">schroeder_iterate</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">max</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">digits</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>

<span class="special">}}}</span> <span class="comment">// namespaces
</span></pre>
<a name="math_toolkit.toolkit.internals1.roots.description"></a>
<h5>
<a name="id783109"></a>
          <a href="roots.html#math_toolkit.toolkit.internals1.roots.description">说明</a>
  </h5>
<p>
          这些函数都进行迭代根查找：<code class="computeroutput"><span class="identifier">newton_raphson_iterate</span></code>
          进行二阶<a href="roots.html#newton">Newton Raphson iteration</a>，而<code class="computeroutput"><span class="identifier">halley_iterate</span></code> 和 <code class="computeroutput"><span class="identifier">schroeder_iterate</span></code> 分别进行三阶<a href="roots.html#halley">Halley</a> 和 <a href="roots.html#schroeder">Schroeder</a>
        迭代。</p>
<p>
  这些函数都带有同样的参数：</p>
<div class="variablelist">
<p class="title"><b>根查找函数的参数</b></p>
<dl>
<dt><span class="term">F
          f</span></dt>
<dd>
<p>
        类型F必须是一个可调用的函数对象，接收一个参数并返回一个元组(tuple)：</p>
</dd>
<dd>
                <p>对于二阶迭代算法 (Newton Raphson) 这个元组必须包含两个元素：函数的值以及它的一阶导数。</p>
        <p>
        对于三阶迭代算法 (Halley and Schroeder)这个元组应当有三个元素：包含函数的值以及它的一阶和二阶导数。</p>
</dd>
<dt><span class="term">T guess</span></dt>
<dd>
  <p>
            起始值。</p>
</dd>
<dt><span class="term">T min</span></dt>
<dd>
  <p>
            结果的最小可能值，这个值作为区间的下边界值。</p>
</dd>
<dt><span class="term">T max</span></dt>
<dd>
  <p>
              结果的最大可能值，这个值作为区间的上边界值。</p>
</dd>
<dt><span class="term">int digits</span></dt>
<dd>
  <p>
            预期的二进制数字个数。</p>
</dd>
<dt><span class="term">uintmax_t max_iter</span></dt>
<dd>
  <p>
            一个可选的进行迭代的最大次数。</p>
</dd>
</dl>
</div>
<p>
  当使用这些函数时，你应当注意：</p>
<div class="itemizedlist"><ul type="disc">
<li>
      对于初始估计值这些函数是非常敏感的(sensitive)，如果初始值有两个到三个数字是正确的，那么这些函数就会收敛很快。然而，收敛不会好于二分法，或者在某些罕见的情况下，如果初始值偏离正确值很远且导数接近于0，那么收敛方法甚至比二分法还要差。</li>
<li>
      这些函数包含首先处理一阶导数为0的特殊情况，并后退到使用二分法。然而，如果函数F定义为返回一个符号正确的任意小的值而不是0将会很有帮助。</li>
<li>如果当前对结果的最佳猜测值的导数是无限值(或者非常接近于无限值)，那么这些函数会过早终止。一个非常大的一阶导数导致下一步计算非常慢，触发终止条件。基于迭代的导数在这种情况下可能并不合适。</li>
<li>如果下一个计算步骤所使用的下一个计算值会超出范围，那么这些函数会退回到使用二分法。在每一个步都会更新边界值来确保可以收敛。然而，一个好的初始估测值将会使性能的提升很多而不再依赖于二分法。</li>
<li>            <span class="emphasis"><em>digits</em></span> 值对这些函数的性能至关重要，如果设置得太高，最好情况下，你会多使用一次迭代，最坏情况下，最后的一些计算步骤将会使用二分法。记住：返回值永远不会比函数 f(x)计算的值更精确，如果在 f(x)趋于0的时候出现消去错误(cancellation error)，那么计算步骤将会是有效地随机值。<span class="emphasis"><em>digits</em></span> 的值应当设置为在达到这一点之前迭代就会终止：对于二阶和三阶方法，正确数字的个数在每一步都会增加相当多，<span class="emphasis"><em>digits</em></span>
            应当通过普测来设定，使得最后一次迭代仅将下一个值引入区间，在这个区间中 f(x) 变得不精确。</li>
<li>最后：
      通过手工写的代码你可能可以做得更好，使得它们可以定制成一个特定的函数。你可能也可以更高效地计算这些函数所使用的导数的比值。和以前一样，代数简化(algebraic simplification)可以是一个巨大的胜利。</li>
</ul>
</div>
<a name="newton"></a><p>
        </p>
<a name="math_toolkit.toolkit.internals1.roots.newton_raphson_method"></a>
<h5>
<a name="id783430"></a>
          <a href="roots.html#math_toolkit.toolkit.internals1.roots.newton_raphson_method">Newton
          Raphson 算法</a>
  </h5>
<p>
  给定一个初始的估测值 x0 ，后续的值使用下面的等式计算：</p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/roots1.png"></span>
  </p>
<p>
  超出范围之后 回退到当前范围的二分逼近。</p>
<p>
  在理想情况下，在每次迭代中，正确的数字个数都在成倍增加。</p>
<a name="halley"></a><p>
        </p>
<a name="math_toolkit.toolkit.internals1.roots.halley_s_method"></a>
<h5>
<a name="id783512"></a>
          <a href="roots.html#math_toolkit.toolkit.internals1.roots.halley_s_method">Halley's
          算法</a>
  </h5>
<p>
          给定一个初始的估测值 x0 ，后续的值使用下面的等式计算：</p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/roots2.png"></span>
  </p>
<p>
          由二阶导数的过度补偿(Over-compensation)(会在错误的方向进行下去)引起这个算法退回到 Newton-Raphson 。 </p>
<p>
          超出范围之后 回退到当前范围的二分逼近。</p>
<p>
          在理想情况下，在每次迭代中，正确的数字个数都在成三倍地增加。</p>
<a name="schroeder"></a><p>
        </p>
<a name="math_toolkit.toolkit.internals1.roots.schroeder_s_method"></a>
<h5>
<a name="id783598"></a>
          <a href="roots.html#math_toolkit.toolkit.internals1.roots.schroeder_s_method">Schroeder's
          算法</a>
  </h5>
<p>
          给定一个初始的估测值 x0 ，后续的值使用下面的等式计算：</p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/roots3.png"></span>
  </p>
<p>
  由二阶导数的过度补偿(Over-compensation)(会在错误的方向进行下去)引起这个算法退回到 Newton-Raphson 。类似地，无论何时如果Newton步骤可以将下一个值改变超过10%，那么将会使用 Newton 步骤。</p>
<p>
          超出范围之后 回退到当前范围的二分逼近。</p>
<p> 在理想情况下，在每次迭代中，正确的数字个数都在成三倍地增加。</p>
<a name="math_toolkit.toolkit.internals1.roots.example"></a>
<h5>
<a name="id783678"></a>
          <a href="roots.html#math_toolkit.toolkit.internals1.roots.example">例子</a>
  </h5>
<p>
  假设我们想要计算一个数的立方根，我们将求解的等式以及它的导数是：</p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/roots4.png"></span>
  </p>
<p>
  让我们使用 Newton Raphson 迭代开始，我们将定义一个返回求解的函数的计算方法的函数对象，以及它的一阶导数：</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">cbrt_functor</span>
<span class="special">{</span>
   <span class="identifier">cbrt_functor</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">a</span><span class="special">(</span><span class="identifier">target</span><span class="special">){}</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">z</span><span class="special">)</span>
   <span class="special">{</span>
      <span class="identifier">T</span> <span class="identifier">sqr</span> <span class="special">=</span> <span class="identifier">z</span> <span class="special">*</span> <span class="identifier">z</span><span class="special">;</span>
      <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">sqr</span> <span class="special">*</span> <span class="identifier">z</span> <span class="special">-</span> <span class="identifier">a</span><span class="special">,</span> <span class="number">3</span> <span class="special">*</span> <span class="identifier">sqr</span><span class="special">);</span>
   <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
   <span class="identifier">T</span> <span class="identifier">a</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
  实现立方根现在非常简单了，最难的部分是查找一个好的逼近值：在这种情况下，我们将仅仅把指数除以3：</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">cbrt</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">z</span><span class="special">)</span>
<span class="special">{</span>
   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">;</span>
   <span class="keyword">int</span> <span class="identifier">exp</span><span class="special">;</span>
   <span class="identifier">frexp</span><span class="special">(</span><span class="identifier">z</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">exp</span><span class="special">);</span>
   <span class="identifier">T</span> <span class="identifier">min</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="number">0.5</span><span class="special">,</span> <span class="identifier">exp</span><span class="special">/</span><span class="number">3</span><span class="special">);</span>
   <span class="identifier">T</span> <span class="identifier">max</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="number">2.0</span><span class="special">,</span> <span class="identifier">exp</span><span class="special">/</span><span class="number">3</span><span class="special">);</span>
   <span class="identifier">T</span> <span class="identifier">guess</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="number">1.0</span><span class="special">,</span> <span class="identifier">exp</span><span class="special">/</span><span class="number">3</span><span class="special">);</span>
   <span class="keyword">int</span> <span class="identifier">digits</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">tools</span><span class="special">::</span><span class="identifier">newton_raphson_iterate</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">cbrt_functor</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">z</span><span class="special">),</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">max</span><span class="special">,</span> <span class="identifier">digits</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          使用 libs/math/test/cbrt_test.cpp 中的测试数据，在每种情况下，发现这种计算精确到最后一个数字，并且在double精确度时不超过6次迭代。然而，你会发现在这个例子中使用了一个更高的精度，精度是在早一些的时候在这个文档中提醒的那样！在这个特殊的例子中，可以精确地计算函数f(x)而不会有过度的消去错误(cancellation error )，所以，一个高的限制并不是一个太大的问题。然而将限制降低到<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits</span>
  <span class="special">*</span> <span class="number">2</span> <span class="special">/</span> <span class="number">3</span></code> 在所有的测试情况下(除了一个)给出了完全的精度。最大的迭代次数仍为6，但在大多数的情况下减少了一次迭代。</p>
<p>
          注意，上面的代码忽略了错误处理，并且没有正确地处理z的负值。这将留作读者的一个练习！</p>
<p>
  现在让我们稍微修改一下这个函数对象来返回二阶导数：</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">cbrt_functor</span>
<span class="special">{</span>
   <span class="identifier">cbrt_functor</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">a</span><span class="special">(</span><span class="identifier">target</span><span class="special">){}</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">z</span><span class="special">)</span>
   <span class="special">{</span>
      <span class="identifier">T</span> <span class="identifier">sqr</span> <span class="special">=</span> <span class="identifier">z</span> <span class="special">*</span> <span class="identifier">z</span><span class="special">;</span>
      <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">sqr</span> <span class="special">*</span> <span class="identifier">z</span> <span class="special">-</span> <span class="identifier">a</span><span class="special">,</span> <span class="number">3</span> <span class="special">*</span> <span class="identifier">sqr</span><span class="special">,</span> <span class="number">6</span> <span class="special">*</span> <span class="identifier">z</span><span class="special">);</span>
   <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
   <span class="identifier">T</span> <span class="identifier">a</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          并且将函数<code class="computeroutput"><span class="identifier">cbrt</span></code>
          修改为使用 Halley 迭代：</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">cbrt</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">z</span><span class="special">)</span>
<span class="special">{</span>
   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">;</span>
   <span class="keyword">int</span> <span class="identifier">exp</span><span class="special">;</span>
   <span class="identifier">frexp</span><span class="special">(</span><span class="identifier">z</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">exp</span><span class="special">);</span>
   <span class="identifier">T</span> <span class="identifier">min</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="number">0.5</span><span class="special">,</span> <span class="identifier">exp</span><span class="special">/</span><span class="number">3</span><span class="special">);</span>
   <span class="identifier">T</span> <span class="identifier">max</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="number">2.0</span><span class="special">,</span> <span class="identifier">exp</span><span class="special">/</span><span class="number">3</span><span class="special">);</span>
   <span class="identifier">T</span> <span class="identifier">guess</span> <span class="special">=</span> <span class="identifier">ldexp</span><span class="special">(</span><span class="number">1.0</span><span class="special">,</span> <span class="identifier">exp</span><span class="special">/</span><span class="number">3</span><span class="special">);</span>
   <span class="keyword">int</span> <span class="identifier">digits</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">digits</span> <span class="special">/</span> <span class="number">2</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">tools</span><span class="special">::</span><span class="identifier">halley_iterate</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">cbrt_functor</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">z</span><span class="special">),</span> <span class="identifier">guess</span><span class="special">,</span> <span class="identifier">min</span><span class="special">,</span> <span class="identifier">max</span><span class="special">,</span> <span class="identifier">digits</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
  注意，在精度仅为完全精度的一半时，迭代就被设置为终止，即使是这样，没有一个测试情况有一个bit错误。更重要的是，最大的迭代次数现在仅为4。</p>
<p>
          让我进行进一步的完善，在最后一个例子中，我们调用<code class="computeroutput"><span class="identifier">schroeder_iterate</span></code>
          ：而实际上，在这个特殊的例子中，在精度和迭代次数上并没有产生差别。然而，这两种方法的相关的性能依赖于函数
  f(x)的性质，以及初始的估测值可以计算到的精度。除了“尝试并观察”，似乎没有通用的方法。</p>
<p>
          最后，我们已经使用精确度为1000 bit 的 <a href="http://shoup.net/ntl/doc/RR.txt" target="_top">NTL::RR</a>
          库调用函数cbrt，只需要7次迭代就可以获得完全的精度。将精度增加一个数量为20的因子，迭代次数的增加少于2倍。这仅仅是为了强调所有的迭代次数都在获取最开始的正确数字时用完了：在这之后，这些方法可以以很高的效率计算出更多的正确数字。或者用另一种方式来陈述：<span class="emphasis"><em>没有什么可以打败一个好的初始估测值!</em></span>
  </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright ?2006 , 2007, 2008 John Maddock, Paul A. Bristow, Hubert
      Holin, Xiaogang Zhang and Bruno Lalande<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="rational.html"><img src="../../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../internals1.html"><img src="../../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="roots2.html"><img src="../../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

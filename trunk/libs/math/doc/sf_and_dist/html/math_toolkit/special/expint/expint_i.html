<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Exponential Integral Ei</title>
<link rel="stylesheet" href="../../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_2006-12-17_0120">
<link rel="start" href="../../../index.html" title="Math Toolkit">
<link rel="up" href="../expint.html" title="Exponential Integrals">
<link rel="prev" href="expint_n.html" title="Exponential Integral En">
<link rel="next" href="../powers.html" title="Logs, Powers, Roots and Exponentials">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="expint_n.html"><img src="../../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../expint.html"><img src="../../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../powers.html"><img src="../../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div>
  <h4 class="title">
<a name="math_toolkit.special.expint.expint_i"></a><a href="expint_i.html" title="Exponential Integral Ei"> 指数积分Ei</a>
</h4>
</div></div></div>
<a name="math_toolkit.special.expint.expint_i.synopsis"></a>
<h5>
<a name="id726494"></a>
          <a href="expint_i.html#math_toolkit.special.expint.expint_i.synopsis">概要</a>
  </h5>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">special_functions</span><span class="special">/</span><span class="identifier">expint</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
  </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">math</span><span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<a href="../../main_overview/result_type.html" title="Calculation of the Type of the Result"><span class="emphasis"><em>calculated-result-type</em></span></a> <span class="identifier">expint</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">z</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <a href="../../policy.html" title="Policies">Policy</a><span class="special">&gt;</span>
<a href="../../main_overview/result_type.html" title="Calculation of the Type of the Result"><span class="emphasis"><em>calculated-result-type</em></span></a> <span class="identifier">expint</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">z</span><span class="special">,</span> <span class="keyword">const</span> <a href="../../policy.html" title="Policies">Policy</a><span class="special">&amp;);</span>

<span class="special">}}</span> <span class="comment">// namespaces
</span></pre>
<p>
          函数返回值的类型使用<a href="../../main_overview/result_type.html" title="Calculation of the Type of the Result"><span class="emphasis"><em>返回值类型推导法则</em></span></a>来确定：如果T是int型，那么返回值的类型是double, 否则返回值类型为T.
  </p>
<p>
  </p>
<p>
            最后一个<a href="../../policy.html" title="Policies">策略</a> 参数是可选的并且可以用来控制函数的行为: 如何处理错误, 使用哪种层次的精度等等. 参见<a href="../../policy.html" title="Policies">策略文档</a>了解更多信息。 </p>
<p>
  </p>
<a name="math_toolkit.special.expint.expint_i.description"></a>
<h5>
<a name="id726870"></a>
          <a href="expint_i.html#math_toolkit.special.expint.expint_i.description">说明</a>
  </h5>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<a href="../../main_overview/result_type.html" title="Calculation of the Type of the Result"><span class="emphasis"><em>calculated-result-type</em></span></a> <span class="identifier">expint</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">z</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <a href="../../policy.html" title="Policies">Policy</a><span class="special">&gt;</span>
<a href="../../main_overview/result_type.html" title="Calculation of the Type of the Result"><span class="emphasis"><em>calculated-result-type</em></span></a> <span class="identifier">expint</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">z</span><span class="special">,</span> <span class="keyword">const</span> <a href="../../policy.html" title="Policies">Policy</a><span class="special">&amp;);</span>
</pre>
<p>
          返回z的<a href="http://mathworld.wolfram.com/ExponentialIntegral.html" target="_top">指数积分</a></p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/expint_i_1.png"></span>
  </p>
<p>
          <span class="inlinemediaobject"><img src="../../../../graphs/expint_i.png" align="middle"></span>
  </p>
<a name="math_toolkit.special.expint.expint_i.accuracy"></a>
<h5>
<a name="id727148"></a>
          <a href="expint_i.html#math_toolkit.special.expint.expint_i.accuracy">准确性</a>
  </h5>
<p>
          下面的表显示了不同平台上的不同浮点类型的峰值误差 (10的-5次方数量级) , 以及与 Cody 的SPECFUN 以及<a href="http://www.gnu.org/software/gsl/" target="_top">GSL-1.9</a>
          库的比较. 除非指定了任意的更窄的浮点类型，否则返回值会具有 <a href="../../backgrounders/relative_error.html#zero_error">有效的零误差</a>.
  </p>
<div class="table">
<a name="id727188"></a>
<p class="title"><b>表46.函数expint(z)的出错率(Errors Rates)</b></p>
<div class="table-contents"><table class="table" summary="Errors In the Function expint(z)">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                有效数字位数</p>
            </th>
<th>
              <p>
                平台和编译器</p>
            </th>
<th>
              <p>
                误差</p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                53
              </p>
            </td>
<td>
              <p>
                Win32, Visual C++ 8
              </p>
            </td>
<td>
              <p>
                峰值=2.4 均值=0.6
              </p>
              <p>
                GSL 峰值=8.9 均值=0.7
              </p>
              <p>
                SPECFUN (Cody) 峰值=2.5 均值=0.6
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                64
              </p>
            </td>
<td>
              <p>
                RedHat Linux IA_EM64, gcc-4.1
              </p>
            </td>
<td>
              <p>
                峰值=5.1 均值=0.8
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                64
              </p>
            </td>
<td>
              <p>
                Redhat Linux IA64, gcc-4.1
              </p>
            </td>
<td>
              <p>
                峰值=5.0 均值=0.8
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                113
              </p>
            </td>
<td>
              <p>
                HPUX IA64, aCC A.06.06
              </p>
            </td>
<td>
              <p>
                峰值=1.9 均值=0.63
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
<p>
          需要指出的是上面的三个库提供 在它们大多数的作用范围上提供小于10的-5次方的精度.
        </p>
<p>
          在En的正根附近，GSL库存在很大困难, 而 Cody 的
          SPECFUN库在及这个库在区间 [4,6]上的出错率增长十分缓慢</p>
<a name="math_toolkit.special.expint.expint_i.testing"></a>
<h5>
<a name="id727372"></a>
          <a href="expint_i.html#math_toolkit.special.expint.expint_i.testing">测试</a>
  </h5>
<p>
          这些函数的测试由两部分构成: 基本的合理性测试(sanity checks)使用<a href="http://functions.wolfram.com/webMathematica/FunctionEvaluation.jsp?name=ExpIntegralEi" target="_top">Mathworld's
          online evaluator</a>计算出的测试数据，而精度测试使用精度为1000-bit的<a href="http://shoup.net/ntl/doc/RR.txt" target="_top">NTL::RR</a>
          库和这个库的实现产生的数据. 注意：这些函数的通用和类型特定的版本在内部使用不同的实现, 因北这就可以给出相互独立的测试数据. 使用我们的测试数据来测试"已知良好的(known good)" 的实现同样也给出一个合理性的测试(sanity checks).
  </p>
<a name="math_toolkit.special.expint.expint_i.implementation"></a>
<h5>
<a name="id727425"></a>
          <a href="expint_i.html#math_toolkit.special.expint.expint_i.implementation">实现</a>
  </h5>
<p>
          对于 x &lt; 0，这个函数仅仅调用<a href="expint_n.html" title="Exponential Integral En">zeta</a>(1,
          -x): 当x的精度少于113bit 的时候，这个zeta函数又是通过有理数逼近的方式来实现的。</p>
<p>
          对于 x &gt; 0 ，一般的版本使用下面的无限级数来实现:
  </p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/expint_i_2.png"></span>
  </p>
<p>
          然而, 当类型的精度在编译时已知且精度是113 bits或更少, 那么将会使用同 <a href="../../backgrounders/implementation.html#math_toolkit.backgrounders.implementation.rational_approximations_used"> JM</a>发明的方法 </p>
<p>
  对于 0 &lt; z &lt; 6 ,使用下面的存根 (root-preserving)逼近形式：</p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/expint_i_3.png"></span>
  </p>
<p>
          其中 z<sub>0</sub> 是函数的正根, 且 R(z/3 - 1) 是有理数极值逼近的尺度，使得其在区间
          [-1,1]上计算。注意：虽然在区间上 [0,6]上的有理逼近逼近很快收敛到极值解，但在实际应用中， 这是很病态的( ill-conditioned) ,
          Cody 和Thacher
          <sup>[<a name="id727563" href="#ftn.id727563">1</a>]</sup>
          也表明了相同的观点并且将这个多项式转化为 


 赛贝谢夫形式 来确保计算的稳定性. 通过实验我们发现这个多项式和这个多项式的赛贝谢夫形式一样稳定 ，前提是它们在区间 [-1,1]上计算。</p>
<p>
          在区间 [a,b] 和区间 [b,INF] 上，这个有理逼近使用下面的形式:
  </p>
<p>
          <span class="inlinemediaobject"><img src="../../../../equations/expint_i_4.png"></span>
  </p>
<p>
          其中 <span class="emphasis"><em>c</em></span> 是一个常量, 而 R(t) 是与c相比较的较低的绝对误差极值. 当范围是无限的，变量<span class="emphasis"><em>t</em></span> 是 <code class="computeroutput"><span class="number">1</span><span class="special">/</span><span class="identifier">z，</span></code>否则是  <code class="computeroutput"><span class="number">2</span><span class="identifier">z</span><span class="special">/(</span><span class="identifier">b</span><span class="special">-</span><span class="identifier">a</span><span class="special">)</span>
          <span class="special">-</span> <span class="special">(</span><span class="number">2</span><span class="identifier">a</span><span class="special">/(</span><span class="identifier">b</span><span class="special">-</span><span class="identifier">a</span><span class="special">)</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span></code>: 其作用在于可以将t的区间扩展到区间[-1,1]. 和前面一样，在任意区间上的有理逼近是病态的: Cody 和 Thacher通过将这个多项式转化为  J-Fraction 等式来解决这个问题. 然而 ,
          如果运算的区间是 [-1,1] 且项数经过精心选择,那么多项式可以被计算到合适的精度: 
           与Cody 和 Thacher 使用
          J-Fractions相比 ，误差率是 2 到 3 个 10的-5次方数量级, 但在最低 限度上更高效一些，因为使用更少的除法.
  </p>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id727563" href="#id727563">1</a>] </sup>
              W. J. Cody and H. C. Thacher, Jr., Rational Chebyshev approximations
              for the exponential integral E<sub>1</sub>(x), Math. Comp. 22 (1968), 641-649,
              and W. J. Cody and H. C. Thacher, Jr., Chebyshev approximations for
              the exponential integral Ei(x), Math. Comp. 23 (1969), 289-303.
            </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright ?2006 , 2007, 2008 John Maddock, Paul A. Bristow, Hubert
      Holin, Xiaogang Zhang and Bruno Lalande<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="expint_n.html"><img src="../../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../expint.html"><img src="../../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../powers.html"><img src="../../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

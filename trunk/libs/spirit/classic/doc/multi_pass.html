<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>The multi_pass</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="theme/style.css" type="text/css"></head>
<body>
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr> 
    <td width="10"> 
    <br>
</td>
    <td width="85%"> <font face="Verdana, Arial, Helvetica, sans-serif" size="6"><b>The 
      multi_pass</b></font> </td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0" height="48" width="112"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr>
    <td width="10"><br>
</td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="trees.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="file_iterator.html"><img src="theme/r_arr.gif" border="0"></a></td>
   </tr>
</tbody></table>
<p>Backtracking in Spirit requires the use of the following types of iterator: 
  forward, bidirectional, or random access. Because of backtracking, input iterators 
  cannot be used. Therefore, the standard library classes istreambuf_iterator 
  and istream_iterator, that fall under the category of input iterators, cannot 
  be used. Another input iterator that is of interest is one that wraps a lexer, 
  such as LEX.<br>Spirit
中的回溯要求使用以下迭代器类型：前向迭代器、双向迭代器或随机访问迭代器。因为要回溯，所以输入迭代器不能使用。因此，标准库类
istreambuf_iterator 和 istream_iterator 均属于输入迭代器类别，都不能使用。另一个感兴趣的输入迭代器是
lexer 的封装，如 LEX.</p>
<table align="center" border="0" width="80%">
  <tbody><tr> 
    <td class="note_box"> <img src="theme/note.gif" height="16" width="16"> <b>Input 
      Iterators</b> 输入迭代器 <br>
      <br>
      In general, Spirit is a backtracking parser. This is not an absolute requirement 
      though. In the future, we shall see more deterministic parsers that require 
      no more than 1 character (token) of lookahead. Such parsers allow us to 
      use input iterators such as the istream_iterator as is.<br>通常，Spirit是一个回溯分析器。但这不是绝对的要求。未来我们将会看到更为确定的分析器，要求前向环视不超过1个字符(记号)。这样的分析器允许我们使用输入迭代器，如 istream_iterator 等等。 </td>
  </tr>
</tbody></table>
<p> Unfortunately, with an input iterator, there is no way to save an iterator 
  position, and thus input iterators will not work with backtracking in Spirit. 
  One solution to this problem is to simply load all the data to be parsed into 
  a container, such as a vector or deque, and then pass the begin and end of the 
  container to Spirit. This method can be too memory intensive for certain applications, 
  which is why the multi_pass iterator was created.<br>不
幸的是，使用输入迭代器没有办法保存迭代器的位置，因此输入迭代器不能用于Spirit中的回溯。这个问题的一个解决办法是，将要分析的所有数据导入到一
个容器中，如 vector 或 deque，然后将该容器的 begin 和 end 传给
Spirit。这个方法对于某个应用可能要耗费大量内存，这正是为什么要创建 multi_pass 迭代器的原因。</p>
<p> The multi_pass iterator will convert any input iterator into a forward iterator 
  suitable for use with Spirit. multi_pass will buffer data when needed and will 
  discard the buffer when only one copy of the iterator exists.<br>multi_pass 迭代器可以将任意输入迭代器转换为适合Spirit使用的前向迭代器。multi_pass 会在需要时缓冲数据，也会在只有一份迭代器拷贝时略过缓冲。</p>
<p> A grammar must be designed with care if the multi_pass iterator is used. Any rule that may 
  need to backtrack, such as one that contains an alternative, will cause data to be buffered. The rules that are optimal to 
  use are sequence and repetition. Sequences of the form <tt>a &gt;&gt; b</tt> 
  will not buffer data at all. Any rule that repeats, such as kleene_star (<tt>*a</tt>) 
  or positive such as (<tt>+a</tt>), will only buffer the data for the current 
  repetition.<br>如果要使用 multi_pass 迭代器，语法就必须小心地设计。任何规则都可能需要回溯，例如一个含有选择的规则，这将导致数据被缓存。这些规则最好使用序列和重复。形如 <tt>a &gt;&gt; b</tt> 
  的序列根本不会缓存数据。任何带有重复的规则，如 kleene_star (<tt>*a</tt>) 
  或加号如 (<tt>+a</tt>)，则只缓存当前重复的数据。</p>
<p> In typical grammars, ambiguity and therefore lookahead is often localized. 
  In fact, many well designed languages are fully deterministic and require no 
  lookahead at all. Peeking at the first character from the input will immediately 
  determine the alternative branch to take. Yet, even with highly ambiguous grammars, 
  alternatives are often of the form <tt>*(a | b | c | d)</tt>. The input iterator 
  moves on and is never stuck at the beginning. Let's look at a Pascal snippet 
  for example:<br>在典型的语法中，模糊性以及所引起的前向环视通常是局部性的。事实上，许多精心设计的语言是完全确定性的，根本不需要前向环视。从读进输入的第一个字符开始，并立即决定选择哪个分支。然而，即使是非常模糊的语法，选择通常也是 <tt>*(a | b | c | d)</tt> 这样的形式。输入迭代器向前移动，永远不会停留在开始处。我们看一个Pascal片断的例子：</p>
<pre>    <code><span class="identifier">program </span><span class="special">=<br>    </span><span class="identifier">    programHeading </span><span class="special">&gt;&gt; </span><span class="identifier">block </span><span class="special">&gt;&gt; </span><span class="literal">'.'<br>    </span><span class="special">    ;<br><br>    </span><span class="identifier">block </span><span class="special">=<br>       *(    </span><span class="identifier">labelDeclarationPart<br>        </span><span class="special">|    </span><span class="identifier">constantDefinitionPart<br>        </span><span class="special">|    </span><span class="identifier">typeDefinitionPart<br>      </span><span class="special">  |    </span><span class="identifier">variableDeclarationPart<br>        </span><span class="special">|  </span><span class="identifier">  procedureAndFunctionDeclarationPart<br>      </span><span class="special">  )<br>        &gt;&gt;   </span><span class="identifier">statementPart<br>        </span><span class="special">;<br></span></code></pre>
<p> Notice the alternatives inside the Kleene star in the rule block . The rule 
  gobbles the input in a linear manner and throws away the past history with each 
  iteration. As this is fully deterministic LL(1) grammar, each failed alternative 
  only has to peek 1 character (token). The alternative that consumes more than 
  1 character (token) is definitely a winner. After which, the Kleene star moves 
  on to the next.<br>留
意规则块中在 Kleene 星内部的多项选择。该规则以线性方式吞进输入，并丢掉每次迭代的历史。因为这是完全确定性的 LL(1)
语法，每个失败的选择都只需检查1个字符(记号)。消耗1个以上字符(记号)的选择项肯定是胜者。之后，Kleene 星前移至下一个。</p>
<p>Be mindful if you use the free parse functions. 
  All of these make a copy of the iterator passed to them.<br>紧记，如果你使用自由的 parse 函数。所有这些会对传给它们的迭代器复制一份拷贝。<br>
</p>
<p>Now, after the lecture on the features to be careful with when using
multi_pass,
you may think that multi_pass is way too restrictive to use.
&nbsp;That's
not the case. &nbsp;If your grammar is deterministic, you can make use
of flush_multi_pass in your grammar to ensure that data is not buffered
when unnecessary.<br>现在，在介绍了使用
multi_pass 时应注意的特性之后，你可能认为 multi_pass 过多限制难以使用。其实不然。如果你的语法是确定性的，你就可以在你的语法中使用 flush_multi_pass 来确保数据在不需要的时候不会被缓冲。<br>
</p>

<p> Again, following up the example we started to use in the section on the scanner 
  . Here's an example using the multi_pass: This time around we are extracting 
  our input from the input stream using an istreambuf_iterator.<br>同样，跟着我们在扫描器一章中的例子。以下是一个使用 multi_pass 的例子：这次我们使用一个 istreambuf_iterator 从输入流中取出我们的输入。</p>
<pre>    <span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>    <br><code><span class="preprocessor">    #include </span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">iterator</span><span class="special">/</span><span class="identifier">multi_pass</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="comment">

    </span><span class="keyword">using namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">;<br>    </span><span class="keyword">using namespace</span> <span class="identifier">std</span><span class="special">;</span>
    
    <span class="identifier">ifstream in</span><span class="special">(</span><span class="string">"input_file.txt"</span><span class="special">); </span><span class="comment">// we get our input from this file 我们从这个文件中输入<br><br>    </span><span class="keyword">typedef char </span><span class="identifier">char_t</span><span class="special">;</span>
    <span class="keyword">typedef </span><span class="identifier">multi_pass</span><span class="special">&lt;</span><span class="identifier">istreambuf_iterator</span><span class="special">&lt;</span><span class="identifier">char_t</span><span class="special">&gt; &gt; </span><span class="identifier">iterator_t</span><span class="special">;</span>

    <span class="keyword">typedef</span> <span class="identifier">skip_parser_iteration_policy</span><span class="special">&lt;</span><span class="identifier">space_parser</span><span class="special">&gt;</span> <span class="identifier">iter_policy_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scanner_policies</span><span class="special">&lt;</span>iter_policy_t<span class="special">&gt;</span> <span class="identifier">scanner_policies_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scanner</span><span class="special">&lt;</span>iterator_t, scanner_policies_t<span class="special">&gt;</span> <span class="identifier">scanner_t</span><span class="special">;</span>

    <span class="keyword">typedef</span> rule<span class="special">&lt;</span>scanner_t<span class="special">&gt;</span> <span class="identifier">rule_t</span><span class="special">;</span>

    <span class="identifier">iter_policy_t</span> <span class="identifier">iter_policy</span><span class="special">(</span><span class="identifier">space_p</span><span class="special">);</span>
    <span class="identifier">scanner_policies_t</span> <span class="identifier">policies</span><span class="special">(</span><span class="identifier">iter_policy</span><span class="special">);</span>
    iterator_t first(
        make_multi_pass(std::istreambuf_iterator&lt;char_t&gt;(in)));

    scanner_t <span class="identifier">scan</span><span class="special">(</span>
        first<span class="special">,</span> make_multi_pass(std::istreambuf_iterator<span class="special">&lt;</span><span class="identifier">char_t</span><span class="special">&gt;()),</span>
        <span class="identifier">policies</span><span class="special">)</span>;<br><span class="special"><br>    </span><span class="identifier">rule_t      n_list </span><span class="special">= </span><span class="identifier">real_p </span><span class="special">&gt;&gt; *(</span><span class="literal">',' </span><span class="special">&gt;&gt; </span><span class="identifier">real_p</span><span class="special">);<br>    </span><span class="identifier">match</span><span class="special">&lt;&gt;</span><span class="identifier">     m </span><span class="special">= </span><span class="identifier">n_list</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">);<br></span></code></pre>
<a name="flush_multi_pass"></a> 
<h2>flush_multi_pass</h2>
<p> There is a predefined pseudo-parser called flush_multi_pass. When this parser 
  is used with multi_pass, it will call multi_pass::clear_queue(). This will cause 
  any buffered data to be erased. This also will invalidate all other copies of 
  multi_pass and they should not be used. If they are, an boost::illegal_backtracking 
  exception will be thrown.<br>有一个预定义的伪分析器，名为 flush_multi_pass。当你将这个分析器用于 multi_pass 时，它将调用 multi_pass::clear_queue()。这将导致所有缓冲数据被删除。同时令 
  multi_pass 的所有其它拷贝失效并不能再使用。如果它们再被使用，将抛出一个 boost::illegal_backtracking 
  异常。</p>
<a name="multi_pass_policies"></a>
<h2>multi_pass Policies</h2>
<p>multi_pass is a templated policy driven class. The description of multi_pass 
  above is how it was originally implemented (before it used policies), and is 
  the default configuration now. But, multi_pass is capable of much more. Because 
  of the open-ended nature of policies, you can write your own policy to make 
  multi_pass behave in a way that we never before imagined.<br>multi_pass 是一个模板化的策略驱动类。以上对于 multi_pass 
  的说明是它原先是如何被实现的(在使用策略之前)，也是现在的缺省配置。但是，multi_pass 具有更多的能力。因为策略的 open-ended 特点，你可以编写你自己的策略来令 
  multi_pass 以我们从未想过的方式来工作。</p>
<p> The multi_pass class has five template parameters:<br>multi_pass 类有五个模板参数：</p>
<ul>
  <li>InputT - The type multi_pass uses to acquire it's input. This is typically 
    an input iterator, or functor.<br>InputT - multi_pass 用于获取输入的类型。典型是一个输入迭代器或仿函数。</li>
  <li>InputPolicy - A class that defines how multi_pass acquires it's input. The 
    InputPolicy is parameterized by InputT.<br>InputPolicy - 定义 multi_pass 如何获取其输入的类。InputPolicy 按 InputT 参数化。</li>
  <li>OwnershipPolicy - This policy determines how multi_pass deals with it's 
    shared components.<br>OwnershipPolicy - 这个策略决定 multi_pass 如何处理它的共享组件。</li>
  <li>CheckingPolicy - This policy determines how checking for invalid iterators 
    is done.<br>CheckingPolicy - 这个策略决定如何检查无效迭代器。</li>
  <li>StoragePolicy - The buffering scheme used by multi_pass is determined and 
    managed by the StoragePolicy.<br>StoragePolicy - multi_pass 所使用的缓冲机制由 StoragePolicy 确定及管理。</li>
</ul>
<a name="predefined_policies"></a>
<h2>Predefined policies 预定义策略</h2>
<p> All predefined multi_pass policies are in the namespace boost::spirit::multi_pass_policies.<br>所有预定义的 multi_pass 策略位于名字空间 boost::spirit::multi_pass_policies。</p>
<a name="predefined_inputpolicy_classes"></a>
<h3>Predefined InputPolicy classes 预定义的InputPolicy类</h3>
<a name="input_iterator"></a>
<h4>input_iterator</h4>
<p> This policy directs multi_pass to read from an input iterator of type InputT.<br>这个策略指示 multi_pass 从一个类型为 InputT 的输入迭代器读入。</p>
<a name="lex_input"></a>
<h4>lex_input</h4>
<p> This policy obtains it's input by calling yylex(), which would typically be 
  provided by a scanner generated by LEX. If you use this policy your code must 
  link against a LEX generated scanner.<br>这个策略通过调用 yylex() 获得其输入，该函数通常是由LEX所生成的扫描器提供的。如果你使用了该策略，则你的代码必须与某个LEX生成的扫描器相链接。</p>
<a name="functor_input"></a>
<h4>functor_input</h4>
<p> This input policy obtains it's data by calling a functor of type InputT. The 
  functor must meet certain requirements. It must have a typedef called result_type 
  which should be the type returned from operator(). Also, since an input policy 
  needs a way to determine when the end of input has been reached, the functor 
  must contain a static variable named eof which is comparable to a variable of 
  result_type.<br>这
种输入策略通过调用类型为 InputT 仿函数获得其数据。该仿函数必须满足某些要求。它必须有一个名为 result_type 的
typedef，是从
operator()&nbsp;返回的类型。此外，由于输入策略需要一种方法来确定输入何时到达结尾，所以该仿函数必须包含一个名为 eof
的静态变量，它应该可以与 result_type 变量相比较。</p>
<a name="predefined_ownershippolicy_classes"></a>
<h3>Predefined OwnershipPolicy classes 预定义的所有权策略类</h3>
<a name="ref_counted"></a>
<h4>ref_counted</h4>
<p> This class uses a reference counting scheme. multi_pass will delete it's shared 
  components when the count reaches zero.<br>这个类使用一个引用计数机制。multi_pass 将在该计数为零时删除其共享组件。</p>
<a name="first_owner"></a>
<h4>first_owner</h4>
<p> When this policy is used, the first multi_pass created will be the one that 
  deletes the shared data. Each copy will not take ownership of the shared data. 
  This works well for spirit, since no dynamic allocation of iterators is done. 
  All copies are made on the stack, so the original iterator has the longest lifespan.<br>使
用这个策略时，第一个创建的 multi_pass&nbsp;将是负责删除共享数据的
multi_pass。每个副本不会获取共享数据的所有权。这种方法在 spirit
行之有效，因为没有迭代器的动态分配要做。所有副本都是基于堆栈，所以原来的迭代器具有最长的寿命。</p>
<a name="predefined_checkingpolicy_classes"></a> 
<h3>Predefined CheckingPolicy classes 预定义的检查策略类</h3>
<a name="no_check"></a>
<h4>no_check</h4>
<p> This policy does no checking at all.<br>该策略不进行检查。</p>
<a name="buf_id_check"></a>
<h4>buf_id_check</h4>
<p> buf_id_check keeps around a buffer id, or a buffer age. Every time clear_queue() 
  is called on a multi_pass iterator, it is possible that all other iterators 
  become invalid. When clear_queue() is called, buf_id_check increments the buffer 
  id. When an iterator is dereferenced, this policy checks that the buffer id 
  of the iterator matches the shared buffer id. This policy is most effective 
  when used together with the std_deque StoragePolicy. It should not be used with 
  the fixed_size_queue StoragePolicy, because it will not detect iterator dereferences 
  that are out of range.<br>buf_id_check 保持一个缓冲区 id，或一个缓冲区寿命。每次对一个 multi_pass 迭代器调用 clear_queue()，有可能所有其它的迭代器都变为无效。在调用 clear_queue() 时，buf_id_check 递增该缓冲区 
  id。当一个迭代器被提领时，该策略检查该迭代器的缓冲区 id 
  是否与共享缓冲区 id 相匹配。在与 std_deque 存储策略一起使用时，该策略是最高效的。但它不能与 fixed_size_queue 存储策略共用，因为它不检查迭代器的提领是否超界。</p>
<a name="full_check"></a>
<h4>full_check</h4>
<p> This policy has not been implemented yet. When it is, it will keep track of 
  all iterators and make sure that they are all valid.<br>这个策略还未实现。当它实现时，它会跟踪所有迭代器，并确保他们都是有效的。</p>
<a name="predefined_storagepolicy_classes"></a>
<h3>Predefined StoragePolicy classes 预定义的存储策略类</h3>
<a name="std_deque"></a>
<h4>std_deque</h4>
<p> This policy keeps all buffered data in a std::deque. All data is stored as 
  long as there is more than one iterator. Once the iterator count goes down to 
  one, and the queue is no longer needed, it is cleared, freeing up memory. The 
  queue can also be forcibly cleared by calling multi_pass::clear_queue().<br>这个策略将所有缓冲数据保存在一个 std::deque 中。只要有一个以上的迭代器，所有数据都要保存。一旦迭代器计数下降为一，这个队列就不再需要了，它将被清除并释放内存。该队列也可以通过调用 multi_pass::clear_queue() 强行清除。</p>
<a name="fixed_size_queue_lt_n_gt_"></a>
<h4>fixed_size_queue&lt;N&gt;</h4>
<p> fixed_size_queue keeps a circular buffer that is size N+1 and stores N elements. 
  fixed_size_queue is a template with a std::size_t parameter that specified the 
  queue size. It is your responsibility to ensure that N is big enough for your 
  parser. Whenever the foremost iterator is incremented, the last character of 
  the buffer is automatically erased. Currently there is no way to tell if an 
  iterator is trailing too far behind and has become invalid. No dynamic allocation 
  is done by this policy during normal iterator operation, only on initial construction. 
  The memory usage of this StoragePolicy is set at N+1 bytes, unlike std_deque, 
  which is unbounded.<br>fixed_size_queue
保持一个大小这 N+1 的循环缓冲区，保存 N 个元素。fixed_size_queue 是一个模板，有一个 std::size_t
参数用于指定队列大小。你要负责确保 N
对于你的分析器足够大。当最前的迭代器被递增时，缓冲区的最后字符将被自动删除。当前没有办法得知一个迭代器是否落后得太多而变为无效。在普通的迭代器操
作期间，该策略没有动态分配，除了在初始化构造期间。这个存储策略的内存开销被设定为 N+1 字节，不象 std_deque 那样是无界的。</p>
<a name="combinations__how_to_specify_your_own_custom_multi_pass"></a>
<h2>Combinations: How to specify your own custom multi_pass 组合：如何指定你自己的multi_pass</h2>
<p> The beauty of policy based designs is that you can mix and match policies 
  to create your own custom class by selecting the policies you want. Here's an 
  example of how to specify a custom multi_pass that wraps an istream_iterator&lt;char&gt;, 
  and is slightly more efficient than the default because it uses the first_owner 
  OwnershipPolicy and the no_check CheckingPolicy:<br>基
于策略的设计的好处在于，你可以混合及匹配不同的策略，通过选择你想要的策略来创建你自己的定制策略。以下是一个关于如何指定一个定制
multi_pass 的例子，它封装了一个 istream_iterator&lt;char&gt;，而且比缺省的要高效一点，因为它使用了
first_owner 所有权策略和 no_check 检查策略：</p>
<pre>    <code><span class="keyword">typedef </span><span class="identifier">multi_pass</span><span class="special">&lt;<br>        </span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">input_iterator</span><span class="special">,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">first_owner</span><span class="special">,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">no_check</span><span class="special">,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">std_deque<br>    </span><span class="special">&gt; </span><span class="identifier">first_owner_multi_pass_t</span><span class="special">;<br></span></code></pre>
<p> The default template parameters for multi_pass are: input_iterator InputPolicy, 
  ref_counted OwnershipPolicy, buf_id_check CheckingPolicy and std_deque StoragePolicy. 
  So if you use multi_pass&lt;istream_iterator&lt;char&gt; &gt; you will get those 
  pre-defined behaviors while wrapping an istream_iterator&lt;char&gt;.<br>multi_pass
的缺省模板参数是：input_iterator 输入策略，ref_counted 所有权策略，buf_id_check 检查策略和
std_deque 存储策略。所以，如果你使用 multi_pass&lt;istream_iterator&lt;char&gt;
&gt;，那么你将得到一个具有以上预定义行为的封装 istream_iterator&lt;char&gt;。</p>
<p> There is one other pre-defined class called look_ahead. look_ahead has two 
  template parameters: InputT, the type of the input iterator to wrap, and a std::size_t 
  N, which specifies the size of the buffer to the fixed_size_queue policy. While 
  the default multi_pass configuration is designed for safey, look_ahead is designed 
  for speed. look_ahead is derived from a multi_pass with the following policies: 
  input_iterator InputPolicy, first_owner OwnershipPolicy, no_check CheckingPolicy, 
  and fixed_size_queue&lt;N&gt; StoragePolicy.<br>还
有一个名为 look_ahead 的预定义类。look_ahead 有两个模板参数：InputT 是要封装的输入迭代器的类型，以及一个
std::size_t N 用于指定 fixed_size_queue 策略所用的缓冲区的大小。缺省的 multi_pass
配置是为安全而设计的，而 look_ahead 则是为速度而设计的。look_ahead 派生自带有以下策略的
multi_pass：input_iterator 输入策略，first_owner 所有权策略，no_check 检查策略和
fixed_size_queue&lt;N&gt; 存储策略。</p>
<a name="how_to_write_a_functor_for_use_with_the_functor_input_inputpolicy"></a>
<h3>How to write a functor for use with the functor_input InputPolicy 如何编写一个与functor_input输入策略共用的仿函数</h3>
<p> If you want to use the functor_input InputPolicy, you can write your own functor 
  that will supply the input to multi_pass. The functor must satisfy two requirements. 
  It must have a typedef result_type which specifies the return type of operator(). 
  This is standard practice in the STL. Also, it must supply a static variable 
  called eof which is compared against to know whether the input has reached the 
  end. Here is an example:<br>如
果你想使用 functor_input 输入策略，你可以编写你自己的仿函数向 multi_pass
提供输入。该仿函数必须满足两个条件。它必须有一个 typedef result_type 用于指定 operator()
的返回类型。这是STL中的标准实践。另外，它必须提供一个名为 eof 的静态变量用于比较以获知输入是否已到结尾。以下是一个例子：</p>
<pre>    <code><span class="keyword">class </span><span class="identifier">my_functor<br>    </span><span class="special">{<br>    </span><span class="keyword">public</span><span class="special">:<br><br>        </span><span class="keyword">typedef char </span><span class="identifier">result_type</span><span class="special">;<br><br>        </span><span class="identifier">my_functor</span><span class="special">()<br>        : </span><span class="identifier">c</span><span class="special">(</span><span class="literal">'A'</span><span class="special">) {}<br><br>        </span><span class="keyword">char operator</span><span class="special">()() </span><span class="keyword">const<br>        </span><span class="special">{<br>            </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">c </span><span class="special">== </span><span class="literal">'M'</span><span class="special">)<br>                </span><span class="keyword">return </span><span class="identifier">eof</span><span class="special">;<br>            </span><span class="keyword">else<br>                return </span><span class="identifier">c</span><span class="special">++;<br>        }<br><br>        </span><span class="keyword">static </span><span class="identifier">result_type eof</span><span class="special">;<br><br>    </span><span class="keyword">private</span><span class="special">:<br><br>        </span><span class="keyword">char </span><span class="identifier">c</span><span class="special">;<br>    };<br><br>    </span><span class="identifier">my_functor</span><span class="special">::</span><span class="identifier">result_type my_functor</span><span class="special">::</span><span class="identifier">eof </span><span class="special">= </span><span class="literal">'\0'</span><span class="special">;<br><br>    </span><span class="keyword">typedef </span><span class="identifier">multi_pass</span><span class="special">&lt;<br>        </span><span class="identifier">my_functor</span><span class="special">,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">functor_input</span><span class="special">,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">first_owner</span><span class="special">,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">no_check</span><span class="special">,<br>        </span><span class="identifier">multi_pass_policies</span><span class="special">::</span><span class="identifier">std_deque<br>    </span><span class="special">&gt; </span><span class="identifier">functor_multi_pass_t</span><span class="special">;<br><br>    </span><span class="identifier">functor_multi_pass_t first </span><span class="special">= </span><span class="identifier">functor_multi_pass_t</span><span class="special">(</span><span class="identifier">my_functor</span><span class="special">());<br>    </span><span class="identifier">functor_multi_pass_t last</span><span class="special">;<br></span></code></pre>
<a name="how_to_write_policies_for_use_with_multi_pass"></a>
<h3>How to write policies for use with multi_pass 如何编写用于multi_pass的策略</h3>
<a name="inputpolicy"></a>
<h4>InputPolicy 输入策略</h4>
<p> An InputPolicy must have the following interface:<br>输入策略必须具有以下接口：</p>
<pre>    <code><span class="keyword">class </span><span class="identifier">my_input_policy </span><span class="comment">// your policy name 你的策略名<br>    </span><span class="special">{<br>    </span><span class="keyword">public</span><span class="special">:<br><br>    </span><span class="comment">//  class inner will be instantiated with the type given<br>    //  as the InputT parameter to multi_pass.<br>    //  类inner以给定为multi_pass的InputT参数的类型进行实例化<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">InputT</span><span class="special">&gt;<br>        </span><span class="keyword">class </span><span class="identifier">inner<br>        </span><span class="special">{<br>        </span><span class="keyword">public</span><span class="special">:<br><br>            </span><span class="comment">// these typedefs determine the iterator_traits for multi_pass<br>            //  以下typedef决定multi_pass的iterator_traits<br>            </span><span class="keyword">typedef </span><span class="identifier">x </span><span class="identifier">value_type</span><span class="special">;<br>            </span><span class="keyword">typedef </span><span class="identifier">x </span><span class="identifier">difference_type</span><span class="special">;<br>            </span><span class="keyword">typedef </span><span class="identifier">x </span><span class="identifier">pointer</span><span class="special">;<br>            </span><span class="keyword">typedef </span><span class="identifier">x </span><span class="identifier">reference</span><span class="special">;<br><br>        </span><span class="keyword">protected</span><span class="special">:<br><br>            </span><span class="identifier">inner</span><span class="special">();<br>            </span><span class="identifier">inner</span><span class="special">(</span><span class="identifier">InputT </span><span class="identifier">x</span><span class="special">);<br>            </span><span class="identifier">inner</span><span class="special">(</span><span class="identifier">inner </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>            </span><span class="comment">// delete or clean up any state 删除或清除所有状态<br>            </span><span class="keyword">void </span><span class="identifier">destroy</span><span class="special">();<br>            </span><span class="comment">// return true if *this and x have the same input 如果*this和x具有相同输入则返回true<br>            </span><span class="keyword">bool </span><span class="identifier">same_input</span><span class="special">(</span><span class="identifier">inner </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">) </span><span class="keyword">const</span><span class="special">;<br>            </span><span class="keyword">void </span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">inner</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br><br>        </span><span class="keyword">public</span><span class="special">:<br><br>            </span><span class="comment">// get an instance from the input 从输入取出一个实例<br>            </span><span class="identifier">result_type </span><span class="identifier">get_input</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>            </span><span class="comment">// advance the input 步进输入<br>            </span><span class="keyword">void </span><span class="identifier">advance_input</span><span class="special">();<br>            </span><span class="comment">// return true if the input is at the end 如果输入到尾则返回true<br>            </span><span class="keyword">bool </span><span class="identifier">input_at_eof</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="special">};<br>    </span><span class="special">};<br></span></code></pre>
<p> Because of the way that multi_pass shares a buffer and input among multiple 
  copies, class inner should keep a pointer to it's input. The copy constructor 
  should simply copy the pointer. destroy() should delete it. same_input should 
  compare the pointers. For more details see the various implementations of InputPolicy 
  classes.<br>由
于 multi_pass 共享一个缓冲区并输入多份拷贝的方式，类 inner 应持有指向其输入的指针。复制构造函数只需复制该指针。而
destroy() 则 delete 它。 same_input 应比较这些指针。更多的细节请见 InputPolicy 类的各个实现。</p>
<a name="ownershippolicy"></a>
<h4>OwnershipPolicy 所有权策略</h4>
<p> The OwnershipPolicy must have the following interface:<br>所有权策略必须具有以下接口：</p>
<pre>    <code><span class="keyword">class </span><span class="identifier">my_ownership_policy<br>    </span><span class="special">{<br>    </span><span class="keyword">protected</span><span class="special">:<br><br>        </span><span class="identifier">my_ownership_policy</span><span class="special">();<br>        </span><span class="identifier">my_ownership_policy</span><span class="special">(</span><span class="identifier">my_ownership_policy </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>        </span><span class="comment">// clone is called when a copy of the iterator is made 复制迭代器时调用clone<br>        </span><span class="keyword">void </span><span class="identifier">clone</span><span class="special">();<br>        </span><span class="comment">// called when a copy is deleted. Return true to indicate<br>        // resources should be released<br>        // 删除一个拷贝时调用。返回true表示资源应被释放<br>        </span><span class="keyword">bool </span><span class="identifier">release</span><span class="special">();<br>        </span><span class="keyword">void </span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">my_ownership_policy</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br><br>    </span><span class="keyword">public</span><span class="special">:<br>        </span><span class="comment">// returns true if there is only one iterator in existence.<br>        // std_dequeue StoragePolicy will free it's buffered data if this<br>        // returns true.<br>        // 如果只有一个迭代器存在则返回true。如果返回true则std_dequeue存储策略将释放期缓冲数据<br>        </span><span class="keyword">bool </span><span class="identifier">unique</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>    </span><span class="special">};<br></span></code></pre>
<a name="checkingpolicy"></a>
<h4>CheckingPolicy 检查策略</h4>
<p> The CheckingPolicy must have the following interface:<br>检查策略必须具有以下接口：</p>
<pre>    <code><span class="keyword">class </span><span class="identifier">my_check<br>    </span><span class="special">{<br>    </span><span class="keyword">protected</span><span class="special">:<br><br>        </span><span class="identifier">my_check</span><span class="special">();<br>        </span><span class="identifier">my_check</span><span class="special">(</span><span class="identifier">my_check </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>        </span><span class="keyword">void </span><span class="identifier">destroy</span><span class="special">();<br>        </span><span class="keyword">void </span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">my_check</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>        </span><span class="comment">// check should make sure that this iterator is valid 检查以确认该迭代器有效<br>        </span><span class="keyword">void </span><span class="identifier">check</span><span class="special">() </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="keyword">void </span><span class="identifier">clear_queue</span><span class="special">();<br>    </span><span class="special">};<br></span></code></pre>
<a name="storagepolicy"></a>
<h4>StoragePolicy 存储策略</h4>
<p> A StoragePolicy must have the following interface:<br>存储策略必须具有以下接口：</p>
<pre>    <code><span class="keyword">class </span><span class="identifier">my_storage_policy<br>    </span><span class="special">{<br>    </span><span class="keyword">public</span><span class="special">:<br><br>    </span><span class="comment">// class inner will be instantiated with the value_type from the InputPolicy<br>    // 类inner将以输入策略的value_type来实例化<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ValueT</span><span class="special">&gt;<br>        </span><span class="keyword">class </span><span class="identifier">inner<br>        </span><span class="special">{<br>        </span><span class="keyword">protected</span><span class="special">:<br><br>            </span><span class="identifier">inner</span><span class="special">();<br>            </span><span class="identifier">inner</span><span class="special">(</span><span class="identifier">inner </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>            </span><span class="comment">// will be called from the destructor of the last iterator. 从最后一个迭代器的析构函数调用。<br>            </span><span class="keyword">void </span><span class="identifier">destroy</span><span class="special">();<br>            </span><span class="keyword">void </span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">inner</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">);<br>            </span><span class="comment">// This is called when the iterator is dereferenced. It's a template<br>            // method so we can recover the type of the multi_pass iterator<br>            // and access it.<br>            // 在迭代器被提领时调用。它是一个模板方法，我们可以找回multi_pass迭代器的类型并访问它。<br>            </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">MultiPassT</span><span class="special">&gt;<br>            </span><span class="keyword">static </span><span class="identifier">ValueT </span><span class="identifier">dereference</span><span class="special">(</span><span class="identifier">MultiPassT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">mp</span><span class="special">);<br>            </span><span class="comment">// This is called when the iterator is incremented. It's a template<br>            // method so we can recover the type of the multi_pass iterator<br>            // and access it.<br>            // 在迭代器</span></code><code><span class="comment">被递增时调用。它是一个模板方法，我们可以找回multi_pass迭代器的类型并访问它。</span></code><code><span class="comment"> <br>            </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">MultiPassT</span><span class="special">&gt;<br>            </span><span class="keyword">static </span><span class="keyword">void </span><span class="identifier">increment</span><span class="special">(</span><span class="identifier">MultiPassT</span><span class="special">&amp; </span><span class="identifier">mp</span><span class="special">);<br>            </span><span class="keyword">void </span><span class="identifier">clear_queue</span><span class="special">();<br>            </span><span class="comment">// called to determine whether the iterator is an eof iterator 调用以确定迭代器是否eof<br>            </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">MultiPassT</span><span class="special">&gt;<br>            </span><span class="keyword">static </span><span class="keyword">bool </span><span class="identifier">is_eof</span><span class="special">(</span><span class="identifier">MultiPassT </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">mp</span><span class="special">);<br>            </span><span class="comment">// called by operator== 由operator==调用<br>            </span><span class="keyword">bool </span><span class="identifier">equal_to</span><span class="special">(</span><span class="identifier">inner </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">) </span><span class="keyword">const</span><span class="special">;<br>            </span><span class="comment">// called by operator&lt; 由operator&lt;调用<br>            </span><span class="keyword">bool </span><span class="identifier">less_than</span><span class="special">(</span><span class="identifier">inner </span><span class="keyword">const</span><span class="special">&amp; </span><span class="identifier">x</span><span class="special">) </span><span class="keyword">const</span><span class="special">;<br>        </span><span class="special">}; </span><span class="comment"> // class inner<br>    </span><span class="special">};<br></span></code></pre>
<p> A StoragePolicy is the trickiest policy to write. You should study and understand 
  the existing StoragePolicy classes before you try and write your own.<br>存储策略是最难编写的策略。你应该在尝试编写你自己的存储策略之前，认真学习和弄明白已有的存储策略类。</p>
<table border="0">
  <tbody><tr> 
    <td width="10"><br>
</td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="trees.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="file_iterator.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<br>
<hr size="1">
<p class="copyright">Copyright © 2001-2002 Daniel C. Nuffer<br>
  <br>
  <font size="2">Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt) </font> </p>
<p class="copyright">&nbsp;</p>
<br>
</body></html>
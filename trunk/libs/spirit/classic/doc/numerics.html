<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<title>Numerics</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="theme/style.css" type="text/css"></head>
<body>
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr>
    <td width="10">
    </td>
    <td width="85%">
      <font face="Verdana, Arial, Helvetica, sans-serif" size="6"><b>Numerics 数值</b></font>
    </td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0" height="48" width="112"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr>
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="operators.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="rule.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<p>Similar to <tt>chlit</tt>, <tt>strlit</tt> etc. numeric parsers are also primitives.
  Numeric parsers are placed on


 a section of their own

 to give this important building
  block better focus. The framework includes a couple of predefined objects for
  parsing signed and unsigned integers and real numbers. These parsers are fully
  parametric. Most of the important aspects of numeric parsing can be finely adjusted
  to suit. This includes the radix base, the minimum and maximum number of allowable
  digits, the exponent, the fraction etc. Policies control the real number parsers'
  behavior. There are some predefined policies covering the most common real number
  formats but the user can supply her own when needed.<br>与 <tt>chlit</tt>, <tt>strlit</tt>&nbsp;
等类似，数值分析器也是基元。把数值分析器单独放在一节是为了让你更好地关注这个重要的构件。框架包含了很多预定义的、成对的有符号/无符号整数、实数分
析器。这些分析器都是可参数化的。调整参数就可以很好的适应数值解析的大多数方面。这些参数包含了进制、可允许的数字位数的最大最小
值、幂、小数部分等。策略用于控制实数分析器的行为。已经预定义了涵盖常见的实数格式分析器，同时，当必要时，用户也可以使用自定义的策略。 </p>
<h2>uint_parser</h2>
<p>This class is the simplest among the members of the numerics package. The <tt>uint_parser</tt>
  can parse unsigned integers of arbitrary length and size. The <tt>uint_parser</tt>
  parser can be used to parse ordinary primitive C/C++ integers or even user defined
  scalars such as bigints (unlimited precision integers). Like most of the classes
  in Spirit, the <tt>uint_parser</tt> is a template class. Template parameters
  fine tune its behavior. The uint_parser is so flexible that the other numeric
  parsers are implemented using it as the backbone.<br>这个类是数值构件中最简单的一个成员。<tt>uint_parser</tt> 可分析任意长度和大小的无符号整数。<tt>uint_parser</tt> 不仅可用于分析普通的C/C++整数，还可以分析用户自定义的整数，如 bigints（没有精度限制的整数）。像Spirit里面大多数的类那样，<tt>uint_parser</tt> 是
一个模板类。模板参数可以很好的调整它的行为。<tt>uint_parser</tt> 是如此的灵活，因此其他的数值分析器都是以它为骨架构建的。</p>
<pre><code><font color="#000000"><span class="identifier">    </span><span class="keyword">template </span><span class="special">&lt;<br>        </span><span class="keyword">typename </span><span class="identifier">T </span><span class="special">= </span><span class="keyword">unsigned</span><span class="special">,<br>        </span><span class="keyword">int </span><span class="identifier">Radix </span><span class="special">= </span><span class="number">10</span><span class="special">,<br>        </span><span class="keyword">unsigned </span><span class="identifier">MinDigits </span><span class="special">= </span><span class="number">1</span><span class="special">,<br>        </span><span class="keyword">int </span><span class="identifier">MaxDigits </span><span class="special">= -</span><span class="number">1</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">uint_parser </span><span class="special">{ </span><span class="comment">/*...*/ </span><span class="special">};</span></font></code></pre>
<table align="center" border="0" width="90%">
  <tbody><tr>
    <td colspan="2" class="table_title">uint_parser template parameters 模板参数</td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>T</b></td>
    <td class="table_cells" width="79%">The numeric base type of the numeric parser.
      Defaults to <tt>unsigned<br></tt>数值分析器的基本数值类型。默认为 <tt>unsigned</tt></td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>Radix</b></td>
    <td class="table_cells" width="79%">The radix base. This can be either 2:
      binary, 8: octal, 10: decimal and 16: hexadecimal. Defaults to 10; decimal<br>数值进制。可以为：2：二进制、8：八进制、10：十进制以及16：十六进制。默认为10；十进制</td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>MinDigits</b></td>
    <td class="table_cells" width="79%">The minimum number of digits allowable<br>所允许的最少数位</td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>MaxDigits</b></td>
    <td class="table_cells" width="79%">The maximum number of digits allowable.
      If this is -1, then the maximum limit becomes unbounded<br>所允许的最多数位，如果为-1，则允许任意多数位</td>
  </tr>
</tbody></table>
<br>
<table align="center" border="0" width="90%">
  <tbody><tr>
    <td colspan="2" class="table_title">Predefined uint_parsers 预定义的unit_parser</td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>bin_p</b></td>
    <td class="table_cells" width="79%"><code><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">,
      </span><span class="number">2</span><span class="special">, </span><span class="number">1</span><span class="special">,
      -</span><span class="number">1</span><span class="special">&gt; </span><span class="keyword">const</span></code></td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>oct_p</b></td>
    <td class="table_cells" width="79%"><code><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">,
      </span><span class="number">8</span><span class="special">, </span><span class="number">1</span><span class="special">,
      -</span><span class="number">1</span><span class="special">&gt; </span><span class="keyword">const</span></code></td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>uint_p</b></td>
    <td class="table_cells" width="79%"><code><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">,
      </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">,
      -</span><span class="number">1</span><span class="special">&gt; </span><span class="keyword">const</span></code></td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>hex_p</b></td>
    <td class="table_cells" width="79%"><code><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">,
      </span><span class="number">16</span><span class="special">, </span><span class="number">1</span><span class="special">,
      -</span><span class="number">1</span><span class="special">&gt; </span><span class="keyword">const</span></code></td>
  </tr>
</tbody></table>
<p>The following example shows how the uint_parser can be used to parse thousand
  separated numbers. The example can correctly parse numbers such as 1,234,567,890.<br>下面的例子示范了如何使用uint_parser分析千位分隔的数值。该例子可正确地分析诸如1,234,567,890这样的数字。</p>
<pre><span class="keyword">    </span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">, </span><span class="number">3</span><span class="special">&gt; </span><span class="identifier">uint3_p</span><span class="special">;        </span><span class="comment">//  1..3 digits  1-3位数字<br>    </span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">3</span><span class="special">, </span><span class="number">3</span><span class="special">&gt; </span><span class="identifier">uint3_3_p</span><span class="special">;      </span><span class="comment">//  exactly 3 digits  正好3位数字<br>    </span><span class="identifier">ts_num_p </span><span class="special">= </span><span class="special">(</span><span class="identifier">uint3_p </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="literal">',' </span><span class="special">&gt;&gt; </span><span class="identifier">uint3_3_p</span><span class="special">));    </span><span class="comment">//  our thousand separated number parser 我们的千位分隔数值分析器</span></pre>
<p><tt>bin_p</tt>, <tt>oct_p</tt>, <tt>uint_p</tt> and <tt>hex_p</tt> are parser
  generator objects designed to be used within expressions. Here's an example
  of a rule that parses comma delimited list of numbers (We've seen this <a href="quick_start.html#list_of_numbers">before</a>):<br><tt>bin_p</tt>, <tt>oct_p</tt>, <tt>uint_p</tt> 和 <tt>hex_p</tt> 是设计成在表达式中使用的分析器生成器。以下是一个分析以逗号分隔的数值的规则例子(<a href="quick_start.html#list_of_numbers">之前</a> 我们已经见过这个例子)：</p>
<pre><code><span class="identifier">    </span><span class="identifier">list_of_numbers </span><span class="special">=</span> <span class="identifier">real_p </span><span class="special">&gt;&gt; *(</span><span class="literal">','</span> <span class="special">&gt;&gt; </span><span class="identifier">real_p</span><span class="special">)</span></code>;<br></pre>

<p>Later, we shall see how we can extract the actual numbers parsed by the numeric
  parsers. We shall deal with this when we get to the section on <a href="semantic_actions.html#specialized_actions">specialized
  actions</a>.<br>稍后，我们将会看到如何从数值分析器中获得它们分析出的数字。我们将在<a href="http://www.boost.org/libs/spirit/doc/semantic_actions.html#specialized_actions">特定动作</a>一节中接触这些。</p>
<h2>int_parser</h2>
<p>The <tt>int_parser</tt> can parse signed integers of arbitrary length and size.
  This is almost the same as the <tt>uint_parser</tt>. The only difference is
  the additional task of parsing the <tt><span class="quotes">'+'</span></tt>
  or <tt class="quotes">'-'</tt> sign preceding the number. The class interface
  is the same as that of the uint_parser.<br><tt>int_parser</tt> 可以分析任意长度和大小的有符号整数。这与 <tt>uint_parser</tt>&nbsp;几乎完全一样，唯一的不同是 <tt>int_parser</tt>&nbsp;多分析了数值前面的'+'、'-'号。这个类的接口与 <tt>uint_parser</tt> 一样。
</p>
<table align="center" border="0" width="90%">
  <tbody><tr>
    <td colspan="2" class="table_title">A predefined int_parser &nbsp;预定义的 int_parser</td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>int_p</b></td>
    <td class="table_cells" width="79%"><span class="identifier"><code>int_parser</code></span><code><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,
      </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">,
      -</span><span class="number">1</span><span class="special">&gt; </span><span class="keyword">const</span></code></td>
  </tr>
</tbody></table>
<h2>real_parser</h2>
<p>The <tt>real_parser</tt> can parse real numbers of arbitrary length and size
  limited by its parametric type <tt>T</tt>. The <tt>real_parser</tt> is a template
  class with 2 template parameters. Here's the <tt>real_parser</tt> template interface:<br><tt>real_parser</tt> 可以在它的模板参数 <tt>T</tt> 所限制的范围内的分析任意长度和大小的实数。<tt>real_parser</tt> 是一个有两个模板参数的模板类。以下是 <tt>real_parser</tt> 的接口：</p>
<pre><span class="keyword">    template</span><span class="special">&lt;<br>        </span><span class="keyword">typename </span><span class="identifier">T </span><span class="special">= </span><span class="keyword">double</span><span class="special">,<br>        </span><span class="keyword">typename </span><span class="identifier">RealPoliciesT </span><span class="special">= </span><span class="identifier">ureal_parser_policies</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt; </span><span class="special">&gt;<br></span><span class="keyword">    struct </span><span class="identifier">real_parser</span><span class="special">;</span></pre>
<p>The first template parameter is its numeric base type <tt>T</tt>. This defaults
  to <tt>double</tt>.<br>第一个模板参数是它的数值基类型 <tt>T</tt>。默认值为 <tt>double</tt>. </p>
<table align="center" border="0" width="80%">
  <tbody><tr>
    <td class="note_box"><img src="theme/bulb.gif" height="18" width="13"><b>
      Parsing special numeric types </b><strong>分析特定的数值类型</strong><br>
      <br>
      Notice that the numeric base type <tt>T</tt> can be specified by the user.
      This means that we can use the numeric parsers to parse user defined numeric
      types such as <tt>fixed_point</tt> (fixed point reals) and <tt>bigint</tt>
      (unlimited precision integers).<br>注意，数值类型 <tt>T</tt> 可以由用户定义。这意味着我们可以使用数值分析器分析用户定义的的数值类型，比如 <tt>fixed_point</tt>(定点实数)和 <tt>bigint</tt>(精度无限的整数)。</td>
  </tr>
</tbody></table>
<p>The second template parameter is a class that groups all the policies and defaults
  to <tt>ureal_parser_policies&lt;T&gt;</tt>. Policies control the real number
  parsers' behavior. The default policies provided are designed to parse C/C++
  style real numbers of the form <b>nnn.fff.Eeee</b> where <b>nnn</b> is the whole
  number part, <b>fff</b> is the fractional part, <b>E</b> is <tt class="quotes">'e'</tt>
  or <tt class="quotes">'E'</tt> and <b>eee</b> is the exponent optionally preceded
  by <tt class="quotes">'-'</tt> or <tt><span class="quotes">'+'</span></tt>.
  This corresponds to the following grammar, with the exception that plain integers
  without the decimal point are also accepted by default.<br>第二个模板参数是组织全部策略的策略类，默认值为 <tt>ureal_parser_policies&lt;T&gt;</tt>。策略控制着实数分析器的行为。所提供的默认策略被设计成识别C/C++风格的实数，格式为 <span style="font-weight: bold;">nnn.fff.Eeee</span>，<span style="font-weight: bold;">nnn</span>为整数部分，<span style="font-weight: bold;">fff</span>为小数部分，<span style="font-weight: bold;">E</span>为字母'E'或'e'<span style="font-weight: bold;">，eee</span>为指数部分，前面可以有'+'或'-'。这对应于以下语法，除了一点，缺省情况下，如果没有小数点，普通的整数也是被接受的。</p>
<pre><code><font color="#000000"><span class="keyword">    </span><span class="identifier">floatingliteral<br>        </span><span class="special">=   </span><span class="identifier">fractionalconstant </span><span class="special">&gt;&gt; </span><span class="special">!</span><span class="identifier">exponentpart<br>        </span><span class="special">|  </span><span class="special">+</span><span class="identifier">digit_p </span><span class="special">&gt;&gt; </span><span class="identifier">exponentpart<br>        </span><span class="special">;<br><br>    </span><span class="identifier">fractionalconstant<br>        </span><span class="special">=  </span><span class="special">*</span><span class="identifier">digit_p </span><span class="special">&gt;&gt; </span><span class="literal">'.' </span><span class="special">&gt;&gt; </span><span class="special">+</span><span class="identifier">digit_p<br>        </span><span class="special">|  </span><span class="special">+</span><span class="identifier">digit_p </span><span class="special">&gt;&gt; </span><span class="literal">'.'<br>        </span><span class="special">;<br><br>    </span><span class="identifier">exponentpart<br>        </span><span class="special">=   </span><span class="special">(</span><span class="literal">'e' </span><span class="special">| </span><span class="literal">'E'</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="special">!(</span><span class="literal">'+' </span><span class="special">| </span><span class="literal">'-'</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="special">+</span><span class="identifier">digit_p<br>        </span><span class="special">;</span></font></code></pre>
<p>The default policies are provided to take care of the most common case (there
  are many ways to represent, and hence parse, real numbers). In most cases, the
  default setting of the <tt>real_parser</tt> is sufficient and can be used straight
  out of the box. Actually, there are four <tt>real_parser</tt>s pre-defined for
  immediate use:<br>为了应付最常见的情况（实数有很多种写法，因此分析过程也是），我们提供了默认策略。再大多数情况下，<tt>real_parser</tt> 的默认设定完全够用，而且可以拿来就用。实际上，有四种预定义的 <tt>real_parser</tt> 可以直接使用：</p>
<table align="center" border="0" width="90%">
  <tbody><tr>
    <td colspan="2" class="table_title">Predefined real_parsers &nbsp;预定义的 real_parser</td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>ureal_p</b></td>
    <td class="table_cells" width="79%"><span class="identifier"><code>real_parser</code></span><code><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,
      </span><span class="identifier">ureal_parser_policies</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;
      &gt; </span><span class="keyword">const</span></code></td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>real_p</b></td>
    <td class="table_cells" width="79%"><span class="identifier"><code>real_parser</code></span><code><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,
      </span><span class="identifier">real_parser_policies</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;
      &gt; </span><span class="keyword">const</span></code></td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>strict_ureal_p</b></td>
    <td class="table_cells" width="79%"><span class="identifier"><code>real_parser</code></span><code><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,
      </span><span class="identifier">strict_ureal_parser_policies</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;
      &gt; </span><span class="keyword">const</span></code></td>
  </tr>
  <tr>
    <td class="table_cells" width="21%"><b>strict_real_p</b></td>
    <td class="table_cells" width="79%"><span class="identifier"><code>real_parser</code></span><code><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,
      </span><span class="identifier">strict_real_parser_policies</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;
      &gt; </span><span class="keyword">const</span></code></td>
  </tr>
</tbody></table>
<p>We've seen <tt>real_p</tt> before. <tt>ureal_p</tt> is its unsigned variant.<br>前面我们已经见过 <tt>real_p</tt>。<tt>ureal_p</tt> 是它的有符号变体。</p>
<h3><a name="strict_reals"></a>Strict Reals&nbsp;<span style="font-weight: bold;">严格实数</span> </h3>
<p>Integer numbers are considered a subset of real numbers, so <tt>real_p</tt>
  and <tt>ureal_p</tt> recognize integer numbers (without a dot) as real numbers.
  <tt>strict_real_p</tt> and <tt>strict_ureal_p</tt> are the equivalent parsers
  that <strong>require</strong> a dot to be present for a number to be considered
  a successful match.<br>整数被认为是实数的一个子集，所以 <tt>real_p</tt> 和 <tt>ureal_p</tt>&nbsp;将整数（没有小数点的数值）识别为实数。<tt>strict_real_p</tt> 和 <tt>strict_ureal_p</tt>&nbsp;与前面两个分析器相同，只是<span style="font-weight: bold;">需要</span>小数点在数值中出现才会产生成功匹配。</p>
<h2>Advanced: real_parser policies&nbsp;高级：real_parser的策略</h2>
<p>The parser policies break down real number parsing into 6 steps:<br>分析器的策略将实数的分析过程分为六步：</p>
<table align="center" border="0" width="90%">
  <tbody><tr>
    <td class="table_cells">1</td>
    <td class="table_cells"><b>parse_sign</b></td>
    <td class="table_cells">Parse the prefix sign<br>分析前缀的符号</td>
  </tr>
  <tr>
    <td class="table_cells">2</td>
    <td class="table_cells"><b>parse_n</b></td>
    <td class="table_cells">Parse the integer at the left of the decimal point<br>分析小数点左边的整数部分</td>
  </tr>
  <tr>
    <td class="table_cells">3</td>
    <td class="table_cells"><b>parse_dot</b></td>
    <td class="table_cells">Parse the decimal point<br>分析小数点</td>
  </tr>
  <tr>
    <td class="table_cells">4</td>
    <td class="table_cells"><b>parse_frac_n</b></td>
    <td class="table_cells">Parse the fraction after the decimal point<br>分析小数点之后的小数部分</td>
  </tr>
  <tr>
    <td class="table_cells">5</td>
    <td class="table_cells"><b>parse_exp</b></td>
    <td class="table_cells">Parse the exponent prefix (e.g. 'e')<br>分析指数前缀(比如字母'e')</td>
  </tr>
  <tr>
    <td class="table_cells">6</td>
    <td class="table_cells"><b>parse_exp_n</b></td>
    <td class="table_cells">Parse the actual exponent<br>分析实际的指数</td>
  </tr>
</tbody></table>
<p>And the interaction of these sub-parsing tasks is further controlled by these
  3 policies:<br>而且这些子分析步骤间的互动更进一步被下面这三个策略所控制：</p>
<table align="center" border="0" width="90%">
  <tbody><tr>
    <td class="table_cells">1</td>
    <td class="table_cells"><b>allow_leading_dot</b></td>
    <td class="table_cells">Allow a leading dot to be present (".1" becomes
      equivalent to "0.1")<br>允许数值以小数点打头（".1"变得与"0.1"等价）</td>
  </tr>
  <tr>
    <td class="table_cells">2</td>
    <td class="table_cells"><b>allow_trailing_dot</b></td>
    <td class="table_cells">Allow a trailing dot to be present ("1." becomes
    equivalent to "1.0")<br>允许数值以小数点结尾("1."变得与"1.0"等价)</td>
  </tr>
  <tr>
    <td class="table_cells">3</td>
    <td class="table_cells"><b>expect_dot</b></td>
    <td class="table_cells">Require a dot to be present (disallows "1" to
    be equivalent to "1.0")<br>要求数值中有小数点(不允许“1”与"1.0"等价)</td>
  </tr>
</tbody></table>
<p>[ <img src="theme/lens.gif" height="16" width="15"> From here on, required
  reading: <a href="scanner.html">The Scanner</a>, <a href="indepth_the_parser.html">In-depth
  The Parser</a> and <a href="indepth_the_scanner.html">In-depth The Scanner</a>
  ]</p><p>[<img style="width: 15px; height: 16px;" alt="" src="theme/lens.gif"> 要理解以下内容，需要阅读：<a href="scanner.html">扫描器</a>、<a href="indepth_the_parser.html">深入分析器</a> 和 <a href="indepth_the_scanner.html">深入扫描器</a>]</p>
<h2>sign_parser and sign_p</h2>
<p>Before we move on, a small utility parser is included here to ease the parsing
  of the <span class="quotes">'-'</span> or <span class="quotes">'+'</span> sign.
  While it is easy to write one:<br>在我们继续深入之前，先加入一个工具分析器，以使解析 <span class="quotes">'-'</span> 或 <span class="quotes">'+'</span> 符号变得容易些。虽然这玩意很容易写：<span class="quotes"></span></p>
<pre>    <span class="identifier">sign_p </span><span class="special">= </span><span class="special">(</span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'+'</span>) <span class="special">| </span><span class="literal">'-'</span><span class="special">)</span><span class="literal">;</span></pre>
<p>it is not possible to extract the actual sign (positive or negative) without
  resorting to semantic actions. The sign_p parser has a bool attribute returned
  to the caller through the match object which, after parsing, is set to <strong>true</strong>
  if the parsed sign is negative. This attribute detects if the negative sign
  has been parsed. Examples:<br>抛开语义动作而又正确的提取符号（正或负）是不可能的。sign_p分析器在匹配后，在返回给调用着的匹配对象中有一个bool属性，如果所解析的符号为负号，则该属性值为<strong>true</strong>。这个属性用于检测是否分析到符号。例：</p>
<pre><span class="special">    </span><span class="keyword">bool </span><span class="identifier">is_negative</span><span class="special">;<br>    </span><span class="identifier">r </span><span class="special">= </span><span class="identifier">sign_p</span><span class="special">[</span><span class="identifier">assign_a</span><span class="special">(</span><span class="identifier">is_negative</span><span class="special">)]</span><span class="special">;</span></pre>
<p><span class="special"></span>or simply...<br>或者简单些...</p>
<pre>    <span class="comment">// directly extract the result from the match result's value 从匹配结果的值中直接取出结果</span>
    <span class="keyword">bool </span><span class="identifier">is_negative </span><span class="special">= </span><span class="identifier">sign_p</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">).</span><span class="identifier">value</span><span class="special">();</span><span class="comment"> </span></pre>
<p>The sign_p parser expects attached semantic actions to have a signature (see
  <a href="semantic_actions.html#specialized_actions">Specialized Actions</a>
  for further detail) compatible with:<br>sign_p分析器要求连接的语义动作有与下面兼容的签名（查看<a href="semantic_actions.html#specialized_actions">特定动作</a>可获得更进一步的细节）： </p>
<p><b>Signature for functions: 函数签名：</b></p>
<pre><code><font color="#000000"><span class="identifier">    </span><span class="keyword">void </span><span class="identifier">func</span><span class="special">(</span><span class="keyword">bool</span><span class="identifier"> is_negative</span><span class="special">);</span></font></code></pre>
<p><b>Signature for functors: 仿函数签名：</b> </p>
<pre><code><font color="#000000"><span class="special">    </span><span class="keyword">struct </span><span class="identifier">ftor<br>    </span><span class="special">{<br>        </span><span class="keyword">void </span><span class="keyword">operator</span><span class="special">()(</span><span class="keyword">bool</span><span class="identifier"> is_negative</span><span class="special">) </span><span class="keyword">const</span><span class="special">;<br>    </span><span class="special">};</span></font></code></pre>
<h2><span class="identifier">ureal_parser_policies</span></h2>
<pre><span class="comment">    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">ureal_parser_policies<br>    </span><span class="special">{<br>        </span><span class="keyword">typedef </span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">, -</span><span class="number">1</span><span class="special">&gt;   </span><span class="identifier">uint_parser_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="identifier">int_parser</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">, -</span><span class="number">1</span><span class="special">&gt;    </span><span class="identifier">int_parser_t</span><span class="special">;<br><br>        </span><span class="keyword">static const bool</span> <span class="identifier">allow_leading_dot</span> <span class="special"> =</span> <span class="literal">true</span><span class="special">;</span><span class="special">
        </span><span class="keyword">static const bool</span> <span class="identifier">allow_trailing_dot </span><span class="special">=</span> <span class="literal">true</span><span class="special">;</span><span class="special"></span>
<span class="special">        </span><span class="keyword">static const bool</span> <span class="identifier">expect_dot</span> <span class="special">        =</span> <span class="literal">false</span><span class="special">;</span><span class="special"></span><span class="special"><br>
        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">match_result</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">, </span><span class="identifier">nil_t</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_sign</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">scan</span><span class="special">.</span><span class="identifier">no_match</span><span class="special">(); }<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">uint_parser_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_n</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">uint_parser_t</span><span class="special">().</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">); }<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">chlit</span><span class="special">&lt;&gt;, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_dot</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'.'</span><span class="special">).</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">); }<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">uint_parser_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_frac_n</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">uint_parser_t</span><span class="special">().</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">); }<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">chlit</span><span class="special">&lt;&gt;, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_exp</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">as_lower_d</span><span class="special">[</span><span class="literal">'e'</span><span class="special">].</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">); }<br><br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="keyword">int</span><span class="identifier">_parser_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_exp_n</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return int</span><span class="identifier">_parser_t</span><span class="special">().</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">); }<br>    };<br></span></pre>
<p><span class="special"></span><span class="identifier">The default ureal_parser_policies
  uses the lower level integer numeric parsers to do its job.<br>默认的ureal_parser_policies用更低一层的整数分析器来完成它的工作。</span></p>
<h2><span class="identifier">real_parser_policies</span></h2>
<pre>    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">real_parser_policies </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">ureal_parser_policies</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="special">{<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static </span><span class="keyword">typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">sign_parser</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        </span><span class="identifier">parse_sign</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        </span><span class="special">{ </span><span class="keyword">return </span><span class="identifier">sign_p</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">); </span><span class="special">}<br>    </span><span class="special">};</span></pre>
<p>Notice how the real_parser_policies replaced <b><tt>parse_sign</tt></b> of
  the <b>u</b>real_parser_policies from which it is subclassed. The default real_parser_policies
  simply uses a <tt>sign_p</tt> instead of <tt>scan.no_match()</tt> in the <tt>parse_sign
  </tt> step.<br>注意，real_parser_policies 是如何替换<span style="font-weight: bold;">u</span>real_parser_policies——它的基类的 <b><tt>parse_sign</tt></b> 的。默认的real_parser_policies只是在 <b><tt>parse_sign</tt></b> 这步简单的使用 <tt>sign_p</tt>&nbsp;替换 <tt>scan.no_match()</tt>。 </p>
<h2><span class="identifier">strict_ureal_parser_policies and strict_real_parser_policies</span></h2>
<pre>    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">strict_ureal_parser_policies </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">ureal_parser_policies</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="special">{</span>
<span class="special">        </span><span class="keyword">static const bool</span> <span class="identifier">expect_dot</span><span class="special"> =</span> <span class="literal">true</span><span class="special">;</span><span class="special"></span><span class="special"></span>
    <span class="special">};</span>

    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">strict_real_parser_policies </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">real_parser_policies</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="special">{</span>
<span class="special">        </span><span class="keyword">static const bool</span> <span class="identifier">expect_dot</span><span class="special"> =</span> <span class="literal">true</span><span class="special">;</span><span class="special"></span><span class="special"></span>
    <span class="special">};</span></pre>
<p>Again, these policies replaced just the policies they wanted different from
  their superclasses.<br>再次，这些策略类只替换了那些它们想与基类不同的策略。</p>
<p><i>Specialized</i> real parser policies can reuse some of the defaults while
  replacing a few. For example, the following is a real number parser policy that
  parses thousands separated numbers with at most two decimal places and no exponent.<br><span style="font-style: italic;">特化的</span>实数分析器策略可复用一些经过小的修改的默认策略。例如，下面是 一个分析千位分隔、最多两位小数、没有指数部分的实数。
</p>
<p><img src="theme/lens.gif" height="16" width="15">The full source code can be
  viewed <a href="../example/fundamental/thousand_separated.cpp">here</a>.<br><img src="theme/lens.gif" height="16" width="15">完整的代码在 <a href="../example/fundamental/thousand_separated.cpp">这里</a>。 </p>
<pre><span class="identifier">    </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">&gt;<br>    </span><span class="keyword">struct </span><span class="identifier">ts_real_parser_policies </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">ureal_parser_policies</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;<br>    {<br>        </span><span class="comment">//  These policies can be used to parse thousand separated<br>        //  numbers with at most 2 decimal digits after the decimal<br>        //  point. e.g. 123,456,789.01<br></span><span class="special">        </span><span class="comment">//  这些策略可用于分析小数点后最多两位数字的千位分隔数值。如 123,456,789.01<br></span><br><span class="comment">        </span><span class="keyword">typedef </span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">, </span><span class="number">2</span><span class="special">&gt;  </span><span class="identifier">uint2_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">, -</span><span class="number">1</span><span class="special">&gt;   </span><span class="identifier">uint_parser_t</span><span class="special">;<br>        </span><span class="keyword">typedef </span><span class="identifier">int_parser</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">, -</span><span class="number">1</span><span class="special">&gt;  </span><span class="identifier">int_parser_t</span><span class="special">;<br><br>        </span><span class="comment">//////////////////////////////////  2 decimal places Max 最多两位数字<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">uint2_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_frac_n</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">uint2_t</span><span class="special">().</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">); }<br><br></span><span class="special">        </span><span class="comment">//////////////////////////////////  No exponent 无指数<br></span>        <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">chlit</span><span class="special">&lt;&gt;, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_exp</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">scan</span><span class="special">.</span><span class="identifier">no_match</span><span class="special">(); }<br><br></span><span class="special">        </span><span class="comment">//////////////////////////////////  No exponent 无指数<br></span>        <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">int_parser_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        parse_exp_n</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        { </span><span class="keyword">return </span><span class="identifier">scan</span><span class="special">.</span><span class="identifier">no_match</span><span class="special">(); }<br><br>        </span><span class="comment">//////////////////////////////////  Thousands separated numbers 千位分隔数值<br>        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;<br>        </span><span class="keyword">static typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">uint_parser_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type<br>        <a name="scanner_save"></a>parse_n</span><span class="special">(</span><span class="identifier">ScannerT</span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">)<br>        {<br>            </span><span class="keyword">typedef typename </span><span class="identifier">parser_result</span><span class="special">&lt;</span><span class="identifier">uint_parser_t</span><span class="special">, </span><span class="identifier">ScannerT</span><span class="special">&gt;::</span><span class="identifier">type RT</span><span class="special">;<br>            </span><span class="keyword">static </span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">1</span><span class="special">, </span><span class="number">3</span><span class="special">&gt; </span><span class="identifier">uint3_p</span><span class="special">;<br>            </span><span class="keyword">static </span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">, </span><span class="number">10</span><span class="special">, </span><span class="number">3</span><span class="special">, </span><span class="number">3</span><span class="special">&gt; </span><span class="identifier">uint3_3_p</span><span class="special">;<br><br>            </span><span class="keyword">if </span><span class="special">(</span><span class="identifier">RT hit </span><span class="special">= </span><span class="identifier">uint3_p</span><span class="special">.</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">))<br>            {<br>                </span><span class="identifier">T n</span><span class="special">;<br>                </span><span class="keyword">typedef typename </span>ScannerT<span class="special">::</span>iterator_t iterator_t;<span class="special">
                </span>iterator_t save<span class="special"> = </span>scan.first<span class="special">;<br>                </span><span class="keyword">while </span><span class="special">(</span><span class="identifier">match</span><span class="special">&lt;&gt; </span><span class="identifier">next </span><span class="special">= (</span><span class="literal">',' </span><span class="special">&gt;&gt; </span><span class="identifier">uint3_3_p</span><span class="special">[</span><span class="identifier">assign_a</span><span class="special">(</span><span class="identifier">n</span><span class="special">)]).</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">scan</span><span class="special">))<br>                {<br>                    </span><span class="identifier">hit</span><span class="special">.</span><span class="identifier">value</span><span class="special">() *= </span><span class="number">1000</span><span class="special">;<br>                    </span><span class="identifier">hit</span><span class="special">.</span><span class="identifier">value</span><span class="special">() += </span><span class="identifier">n</span><span class="special">;<br>                    </span><span class="identifier">scan</span><span class="special">.</span><span class="identifier">concat_match</span><span class="special">(</span><span class="identifier">hit</span><span class="special">, </span><span class="identifier">next</span><span class="special">);<br>                    </span><span class="identifier">save </span><span class="special"><span class="special">= </span></span><span class="identifier">scan</span><span class="special">.</span><span class="identifier">first</span><span class="special"><span class="special">;</span>
                }
                </span>scan<span class="special">.</span>first<span class="special"> = </span>save<span class="special">;<br>                </span><span class="keyword">return </span><span class="identifier">hit</span><span class="special">;<br><br></span><span class="special">                // Note: On erroneous input such as "123,45", the result should<br>                // be a partial match "123". 'save' is used to makes sure that<br>                // the scanner position is placed at the last *valid* parse<br>                // position.<br></span><span class="special">                // 注：当输入错误时，如 "123,45"，结果会是部分匹配 "123"。'save' 用于确保<br>                // 扫描器位置位于最后的 *有效* 分析位置。<br>            }<br>            </span><span class="keyword">return </span><span class="identifier">scan</span><span class="special">.</span><span class="identifier">no_match</span><span class="special">();<br>        }<br>    };</span></pre>
<table border="0">
  <tbody><tr>
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="operators.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="rule.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<br>
<hr size="1">
<p class="copyright">Copyright © 1998-2002 Joel de Guzman<br>
  <br>
  <font size="2">Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt) </font> </p>
<p>&nbsp;</p>
</body></html>
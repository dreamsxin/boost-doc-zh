<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="ublas.css" type="text/css" />
<title>Range and slice</title>
</head>
<body>
<h1><img src="../../../../boost.png" align="middle" />
范围和切分存储(Range and Slice Storage)</h1>
<h2><a name="range" id="range"></a>Range&lt;SizeType,DistanceType&gt;</h2>
<h4>说明</h4>
<p>类<code>range</code> 指定索引的一个范围。这个范围是从一个起始值到一个终止值的索引的序列。这些索引以大小为1的步进来增加并且不包含最后一个终止值。因此 <code>range</code> 可以用来指定向量和矩阵的元素的一个范围。</p>
<h4>例子</h4>
<pre>
#include &lt;boost/numeric/ublas/storage.hpp&gt;

int main () {
    using namespace boost::numeric::ublas;
    range r (0, 3);
    for (unsigned i = 0; i &lt; r.size (); ++ i) {
        std::cout &lt;&lt; r (i) &lt;&lt; std::endl;
    }
}
</pre>
<h4>定义</h4>
<p>定义在头文件 storage.hpp 中。</p>
<h4>模型(Model of)</h4>
<p>可反转的容器( Reversible Container )。</p>
<h4>类型要求(Type requirements)</h4>
<p>没有，除了由可反转的容器( Reversible
Container )所施加的类型要求。</p>
<h4>公有基类(Public base classes)</h4>
<p>没有。</p>
<h4>成员</h4>
<table border="1" summary="members">
<tbody>
<tr>
<th>成员</th>
<th>说明</th>
</tr>
<tr>
<td><code>range (size_type start, size_type stop)</code></td>
<td>构造一个从<code>start</code> 到 <code>stop (不包含)的索引值的范围。</code>
.</td>
</tr>
<tr>
<td><code>size_type start () const</code></td>
<td>返回 <code>range</code> 的开始。</td>
</tr>
<tr>
<td><code>size_type size () const</code></td>
<td>返回 <code>range</code> 的大小。</td>
</tr>
<tr>
<td><code>const_reference operator [] (size_type i)
const</code></td>
<td>返回第<code>i</code>个元素<code>start + i</code>的常引用。</td>
</tr>
<tr>
<td><code>range compose (const range &amp;r) const</code></td>
<td>返回<code>start + r.start
()</code> 到 <code>start + r.start () + r.size ()</code>的组合范围。</td>
</tr>
<tr>
<td><code>bool operator == (const range &amp;r) const</code></td>
<td>测试两个范围的是否相等。</td>
</tr>
<tr>
<td><code>bool operator != (const range &amp;r) const</code></td>
<td>测试两个范围是否不相等。</td>
</tr>
<tr>
<td><code>const_iterator begin () const</code></td>
<td>返回指向<code>range</code>开始处的<code>const_iterator</code>。</td>
</tr>
<tr>
<td><code>const_iterator end () const</code></td>
<td>返回指向<code>range</code>终止处的<code>const_iterator</code>。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rbegin () const</code></td>
<td>返回指向反转的(reversed)<code>range</code>开始处的<code>const_reverse_iterator</code>。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rend () const</code></td>
<td>返回指向反转的(reversed)<code>range</code>终止处的<code>const_reverse_iterator</code></td>
</tr>
</tbody>
</table>
<h4>先决条件(Preconditions)</h4>
<ul>
<li><code>start () &lt;= stop ()</code></li>
</ul>

<h2><a name="slice" id="slice"></a>Slice&lt;SizeType,DistanceType&gt;</h2>
<h4>说明</h4>
<p>类<code>slice</code> 指定索引的一个 '切分(slice)'。 切分(Slices)与范围(ranges)更加一般化，允许在索引序列的元素之间以一个指定的步进值来增加和减少。因此 <code>slice</code> 可以用来指定向量和矩阵的元素的切分(slices)。</p>
<h4>例子</h4>
<pre>
#include &lt;boost/numeric/ublas/storage.hpp&gt;

int main () {
    using namespace boost::numeric::ublas;
    slice s (0, 1, 3);
    for (unsigned i = 0; i &lt; s.size (); ++ i) {
        std::cout &lt;&lt; s (i) &lt;&lt; std::endl;
    }
}
</pre>
<h4>定义</h4>
<p>定义在头文件 storage.hpp 中。 </p>
<h4>模型(Model of)</h4>
<p>可反转的容器( Reversible Container )</p>
<h4>类型要求(Type requirements)</h4>
<p>没有，除了由可反转的容器( Reversible Container )所施加的类型要求。</p>
<h4>公有基类(Public base classes)</h4>
<p>没有。</p>
<h4>成员</h4>
<table border="1" summary="members">
<tbody>
<tr>
<th>成员</th>
<th>说明</th>
</tr>
<tr>
<td><code>slice (size_type start, size_type stride, size_type
size)</code></td>
<td>构造一个包含<code>size</code>个元素的切分(slice) <code>start,start+stride,start+2*stride...</code>。</td>
</tr>
<tr>
<td><code>size_type start () const</code></td>
<td>返回 <code>slice</code>的开始位置。</td>
</tr>
<tr>
<td><code>size_type stride () const</code></td>
<td>返回<code>slice</code>的步进值(stride)。</td>
</tr>
<tr>
<td><code>size_type size () const</code></td>
<td>返回 <code>slice</code>的大小。</td>
</tr>
<tr>
<td><code>const_reference operator [] (size_type i)
const</code></td>
<td>返回第<code>i</code>个元素<code>start + i * stride</code>的常引用。</td>
</tr>
<tr>
<td><code>slice compose (const range &amp;r) const</code></td>
<td>返回从<code>start + stride * r.start
()</code> 到 <code>start + stride * (r.start () + r.size ())</code>
且步进值(stride)为 <code>stride</code>的组合切分(composite slice)。</td>
</tr>
<tr>
<td><code>slice compose (const slice &amp;s) const</code></td>
<td>返回从<code>start + stride * s.start
()</code> 到 <code>start + stride * s.stride () * (s.start () +
s.size ())</code>且步进值(stride)为<code>stride * s.stride ()</code>
的组合切分(composite slice)。</td>
</tr>
<tr>
<td><code>bool operator == (const slice &amp;s) const</code></td>
<td>测试两个切分(slices)是否相等。</td>
</tr>
<tr>
<td><code>bool operator != (const slice &amp;s) const</code></td>
<td>测试两个切分(slices)是否不相等。</td>
</tr>
<tr>
<td><code>const_iterator begin () const</code></td>
<td>返回指向<code>slice</code>开始处的<code>const_iterator</code>。</td>
</tr>
<tr>
<td><code>const_iterator end () const</code></td>
<td>返回指向<code>slice</code>终止处的<code>const_iterator</code>。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rbegin () const</code></td>
<td>返回指向反转的(reversed)<code>slice</code>开始处的<code>const_reverse_iterator</code>。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rend () const</code></td>
<td>返回指向反转的(reversed)<code>slice</code>终止处的<code>const_reverse_iterator</code>。</td>
</tr>
</tbody>
</table>
<h4>先决条件(Preconditions)</h4>
<ul>
<li>所有的步进值都是合法的。然而，当返回一个索引值或解引用(dereferenced)一个迭代器的时候，它的值必须能够在size_type类型中表示。</li>
</ul>
   <hr/>
   <p>
      Copyright (&copy;) 2000-2004 Michael Stevens, Mathias Koch,
      Joerg Walter, Gunter Winkler<br />
      Use, modification and distribution are subject to the
      Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt
      or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
         http://www.boost.org/LICENSE_1_0.txt
      </a>).
   </p>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="ublas.css" type="text/css" />
<title>Bounded Array;</title>
</head>
<body>
<h1><img src="../../../../boost.png" align="middle" />
有限数组存储(Bounded Array Storage)</h1>
<h2><a name="bounded_array" id="bounded_array"></a>有限数组(Bounded Array)</h2>
<h4>说明</h4>
<p>模板类<code>bounded_array&lt;T, N, ALLOC&gt;</code> 实现一个有限数组( bounded storage array )。有限数组( bounded array )类似于一个 C++ 数组类型，因为数组的最大大小被限制为 N 并在栈上分配而不是在堆上分配。类似的<code>bounded_array</code> 不需要二级存储( secondary storage )且 ALLOC 仅被用于指定<code>size_type</code> 和 <code>difference_type</code>。</p>
<p>当改变<code>bounded_array</code> 数组时永远都不会重新分配内存。因此改变数组<code>bounded_array</code>的大小永远都是高效的，但是改变的大小不能够超过 N 。 </p>
<h4>例子</h4>
<pre>
#include &lt;boost/numeric/ublas/storage.hpp&gt;

int main () {
    using namespace boost::numeric::ublas;
    bounded_array&lt;double, 3&gt; a (3);
    for (unsigned i = 0; i &lt; a.size (); ++ i) {
        a [i] = i;
        std::cout &lt;&lt; a [i] &lt;&lt; std::endl;
    }
}
</pre>
<h4>定义</h4>
<p>定义在头文件 storage.hpp 中。 </p>
<h4>模板参数</h4>
<table border="1" summary="parameters">
<tbody>
<tr>
<th>参数</th>
<th>说明</th>
<th>缺省值</th>
</tr>
<tr>
<td><code>T</code></td>
<td>存储在数组中的对象的类型。</td>
<td></td>
</tr>
<tr>
<td><code>N</code></td>
<td>分配的数组的大小。</td>
<td></td>
</tr>
<tr>
<td><code>ALLOC</code></td>
<td>一个STL分配器(Allocator)。</td>
<td>std::allocator</td>
</tr>
</tbody>
</table>
<h4>模型(Model of)</h4>
<p><a href="storage_concept.htm">存储(Storage)</a></p>
<h4>类型要求(Type requirements)</h4>
<p>没有，除了由存储(storage)所施加的类型要求。</p>
<h4>公有基类(Public base classes)</h4>
<p>没有。</p>
<h4>成员</h4>
<ul>
<li>这里的说明并没有描述类的成员的实际功能，这可以在对应的概念文档中找到，但是包含在概念模型内的成员函数的实现细节。</li>
<li>印刷(Typography)：
  <ul>
<li>不是所实现的概念的成员用<font color="blue">蓝色标记</font>。</li>
</ul>
</li>
</ul>
<table border="1" summary="members">
<tbody>
<tr>
<th>成员</th>
<th>定义位置</th>
<th>说明</th>
</tr>
<tr><td><code>value_type</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td></tr>
<tr><td><code>pointer</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>value_type*</code></td></tr>
<tr><td><code>const_pointer</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>const value_type*</code></td></tr>
<tr><td><code>reference</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>value_type&amp;</code></td></tr>
<tr><td><code>const_reference</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>const value_type&amp;</code></td></tr>
<tr><td><code>size_type</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>Alloc::size_type</code></td></tr>
<tr><td><code>difference_type</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>Alloc::difference_type</code></td></tr>
<tr><td><code>iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>pointer</code></td></tr>
<tr><td><code>const_iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>const_pointer</code></td></tr>
<tr><td><code>revere_iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>std::reverse_iterator&lt;iterator&gt;</code></td></tr>
<tr><td><code>const_revere_iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>std::reverse_iterator&lt;const_iterator&gt;</code></td></tr>
<tr>
<td><code>bounded_array ()</code></td>
<td><a href="storage_concept.htm">Storage</a></td>
<td>生成一个包含<strong>0</strong>个元素的 <code>unbounded_array</code> 。</td> 
</tr>
<tr>
<td><code>bounded_array (size_type size)</code></td>
<td><a href="storage_concept.htm">存储(Storage)</a></td>
<td>生成一个包含<code>size</code>个元素的未初始化的 <code>bounded_array</code> 。
所有的元素都是缺省构造。</td>
</tr>
<tr>
<td><code>bounded_array (size_type size, const T&amp; init)</code></td>
<td><a href="storage_concept.htm">存储(Storage)</a></td>
<td>生成一个包含<code>size</code>个元素的且被初始化的 <code>bounded_array</code> 。所有的元素都由 <code>init</code> 值来构造。</td>
</tr>
<tr>
<td><code>bounded_array (const bounded_array &amp;c)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>拷贝构造函数。</td>
</tr>
<tr>
<td><code>~bounded_array ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>析构 <code>bounded_array</code> 本身。</td>
</tr>
<tr>
<td><code>void resize (size_type size)</code></td>
<td><a href="storage_concept.htm">Storage</a>
<td>重新分配一个包含<code>size</code>个元素的 <code>bounded_array</code> 。</td>
</tr>
<tr>
<td><code>void resize (size_type size, const T&amp; t)</code></td>
<td><a href="storage_concept.htm">Storage</a>
<td>重新分配一个包含<code>size</code>个元素的 <code>bounded_array</code> 。</td>
</tr>
<tr>
<td><code>size_type size () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回 <code>bounded_array</code> 的大小。</td>
</tr>
<tr>
<td><code>const_reference operator [] (size_type i) const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回第<code>i</code>个元素的 <code>const</code> 引用。</td>
</tr>
<tr>
<td><code>reference operator [] (size_type i)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回第<code>i</code>个元素的引用。</td>
</tr>
<tr>
<td><code>bounded_array &amp;operator = (const bounded_array &amp;a)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>赋值运算符。</td>
</tr>
<tr>
<td><font color="blue"><code>bounded_array &amp;assign_temporary (bounded_array &amp;a)</code></font></td>
<td></td>
<td>赋值给一个临时变量。可能会改变数组 <code>a</code>。</td>
</tr>
<tr>
<td><code>void swap (bounded_array &amp;a)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>交换数组的内容。</td>
</tr>
<tr>
<td><code>const_iterator begin () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回一个指向<code>bounded_array</code>开始处的 <code>const_iterator</code> 。</td>
</tr>
<tr>
<td><code>const_iterator end () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回一个指向<code>bounded_array</code>终止处的 <code>const_iterator</code> 。</td> 
</tr>
<tr>
<td><code>iterator begin ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回一个指向<code>bounded_array</code>开始处的 <code>const_iterator</code> 。</td>
</tr>
<tr>
<td><code>iterator end ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回一个指向<code>bounded_array</code>终止处的 <code>const_iterator</code> 。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rbegin () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>bounded_array</code>开始处的 <code>const_reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rend () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>bounded_array</code>终止处的 <code>const_reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>reverse_iterator rbegin ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>bounded_array</code>开始处的 <code>reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>reverse_iterator rend ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>bounded_array</code>终止处的 <code>reverse_iterator</code> 。</td>
</tr>
</tbody>
</table>
   <hr />
   <p>
      Copyright (&copy;) 2000-2004 Michael Stevens, Mathias Koch,
      Joerg Walter, Gunter Winkler<br />
      Use, modification and distribution are subject to the
      Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt
      or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
         http://www.boost.org/LICENSE_1_0.txt
      </a>).
   </p>
</body>
</html>

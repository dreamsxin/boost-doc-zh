<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="ublas.css" type="text/css" />
<title>Unbounded array</title>
</head>
<body>
<h1><img src="../../../../boost.png" align="middle" />
无限的数组存储(Unbounded Array Storage)</h1>
<h2><a name="unbounded_array" id="unbounded_array"></a>无限的数组(Unbounded Array)</h2>
<h4>说明</h4>
<p>模板类<code>unbounded_array&lt;T, ALLOC&gt;</code> 使用一个分配器来实现一个无限的存储数组(unbounded storage array)。无限数组(unbounded array)类似于<code>std::vector</code> ，它可以自动增长数组的长度。然而<code>unbounded_array</code> 的目的在于优化性能。因此<code>unbounded_array</code> 并没有以使用一个类似于<code>std::vector</code> 的序列模型。
<p>当改变<code>unbounded_array</code> 大小的时候会重新分配内存，即使新的内存需求更小一些。因此，重新改变一个<code>unbounded_array</code>的大小是很低效的。</p>
<h4>例子</h4>
<pre>
#include &lt;boost/numeric/ublas/storage.hpp&gt;

int main () {
    using namespace boost::numeric::ublas;
    unbounded_array&lt;double&gt; a (3);
    for (unsigned i = 0; i &lt; a.size (); ++ i) {
        a [i] = i;
        std::cout &lt;&lt; a [i] &lt;&lt; std::endl;
    }
}
</pre>
<h4>定义</h4>
<p>定义在头文件 storage.hpp 中。 </p>
<h4>模板参数</h4>
<table border="1" summary="parameters">
<tbody>
<tr>
<th>参数</th>
<th>说明</th>
<th>缺省值</th>
</tr>
<tr>
<td><code>T</code></td>
<td>存储在数组中的对象的类型。</td>
<td></td>
</tr>
<tr>
<td><code>ALLOC</code></td>
<td>一个 STL 分配器(Allocator)</td>
<td>std::allocator</td>
</tr>
</tbody>
</table>
<h4>模型(Model of)</h4>
<p><a href="storage_concept.htm">存储(Storage)</a></p>
<h4>类型要求(Type requirements)</h4>
<p>没有，除了由存储所施加的类型要求。</p>
<h4>公有基类(Public base classes)</h4>
<p>没有。</p>
<h4>成员</h4>
<ul>
<li>这里的说明并没有描述成员实际所完成的功能，这可以在对应的概念文档中找到，但是包含在这种概念模型中的实现的细节。</li>
<li>印刷(Typography)：
  <ul>
<li>不是这个概念实现的成员以<font color="blue">蓝色标记</font>。</li>
</ul>
</li>
</ul>
<table border="1" summary="members">
<tbody>
<tr>
<th>成员</th>
<th>定义位置</th>
<th>说明</th>
</tr>
<tr><td><code>value_type</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td></tr>
<tr><td><code>pointer</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>value_type*</code></td></tr>
<tr><td><code>const_pointer</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>const value_type*</code></td></tr>
<tr><td><code>reference</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>value_type&amp;</code></td></tr>
<tr><td><code>const_reference</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>const value_type&amp;</code></td></tr>
<tr><td><code>size_type</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>Alloc::size_type</code></td></tr>
<tr><td><code>difference_type</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>Alloc::difference_type</code></td></tr>
<tr><td><code>iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>pointer</code></td></tr>
<tr><td><code>const_iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>const_pointer</code></td></tr>
<tr><td><code>revere_iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>std::reverse_iterator&lt;iterator&gt;</code></td></tr>
<tr><td><code>const_revere_iterator</code></td><td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td><td>定义为 <code>std::reverse_iterator&lt;const_iterator&gt;</code></td></tr>
<tr><td><font color="blue">allocator_type</font></td><td></td><td>定义为 ALLOC</td></tr>
<tr>
<td><code><em>explicit</em> unbounded_array (<em>ALLOC &amp;a = ALLOC()</em>)</code></td>
<td><a href="storage_concept.htm">Storage</a></td>
<td>使用一个指定的分配器来生成一个包含0个元素的<code>unbounded_array</code></td> 
</tr>
<tr>
<td><code><em>explicit</em> unbounded_array (size_type size<em>, ALLOC &amp;a = ALLOC()</em>)</code></td>
<td><a href="storage_concept.htm">Storage</a></td>
<td>使用一个指定的分配器来生成一个未初始化的包含<code>size</code>个元素的<code>unbounded_array</code>。
所有的元素使用缺省构造。</td>
</tr>
<tr>
<td><code>unbounded_array (size_type size, const T&amp; init<em>, ALLOC&amp; a = ALLOC()</em>)</code></td>
<td><a href="storage_concept.htm">Storage</a></td>
<td>使用一个指定的分配器来生成一个未初始化的包含<code>size</code>个元素的<code>unbounded_array</code>。
所有的元素使用<code>init</code>值构造。</td>
</tr>
<tr>
<td><code>unbounded_array (const unbounded_array &amp;a)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>拷贝构造函数。</td>
</tr>
<tr>
<td><code>~unbounded_array ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>析构<code>unbounded_array</code>本身。</td>
</tr>
<tr>
<td><code>void resize (size_type n)</code></td>
<td><a href="storage_concept.htm">Storage</a></td>
<td>重新分配一个包含<code>n</code>个元素的<code>unbounded_array</code>。元素没有初始化。</td>
</tr>
<tr>
<td><code>void resize(size_type n, const T&amp; t)</code></td>
<td><a href="storage_concept.htm">Storage</a></td>
<td>重新分配一个包含<code>n</code>个元素的<code>unbounded_array</code>。元素是<code>t</code>的拷贝。 
</tr>
<tr>
<td><code>size_type size () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回<code>unbounded_array</code>的大小。</td>
</tr>
<tr>
<td><code>const_reference operator [] (size_type i) const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回指向第<code>i</code>个元素的<code>const</code>引用。</td>
</tr>
<tr>
<td><code>reference operator [] (size_type i)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回指向第<code>i</code>个元素的引用。</td>
</tr>
<tr>
<td><code>unbounded_array &amp;operator = (const unbounded_array &amp;a)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>赋值运算符。</td>
</tr>
<tr>
<td><font color="blue"><code>unbounded_array &amp;assign_temporary (unbounded_array &amp;a)</code></font></td>
<td></td>
<td>赋值给一个临时变量。可能会改变数组 <code>a</code> 。</td>
</tr>
<tr>
<td><code>void swap (unbounded_array &amp;a)</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>交换数组的内容。</td>
</tr>
<tr>
<td><code>const_iterator begin () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回指向<code>unbounded_array</code>开始处的 <code>const_iterator</code> 。</td>
</tr>
<tr>
<td><code>const_iterator end () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回指向<code>unbounded_array</code>终止处的 <code>const_iterator</code> 。</td>
</tr>
<tr>
<td><code>iterator begin ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回指向<code>unbounded_array</code>开始处的 <code>iterator</code> 。</td>
</tr>
<tr>
<td><code>iterator end ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/Container.html">Container</a></td>
<td>返回指向<code>unbounded_array</code>终止处的 <code>iterator</code> 。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rbegin () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>unbounded_array</code>开始处的 <code>const_reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>const_reverse_iterator rend () const</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>unbounded_array</code>终止处的 <code>const_reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>reverse_iterator rbegin ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>unbounded_array</code>开始处的 <code>reverse_iterator</code> 。</td>
</tr>
<tr>
<td><code>reverse_iterator rend ()</code></td>
<td><a href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible Container</a></td>
<td>返回指向反转的(reversed)<code>unbounded_array</code>终止处的 <code>reverse_iterator</code> 。</td>
</tr>
</tbody>
</table>
<hr />
<p>Copyright (&copy;) 2000-2002 Joerg Walter, Mathias Koch<br />
   Use, modification and distribution are subject to the
   Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt
   or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
      http://www.boost.org/LICENSE_1_0.txt
   </a>).
</p>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Type Requirements and User-defined-types support</title>

<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="Chapter&nbsp;1.&nbsp;Boost.NumericConversion">
<link rel="up" href="../index.html" title="Chapter&nbsp;1.&nbsp;Boost.NumericConversion">
<link rel="prev" href="converter___function_object.html" title="converter&lt;&gt; function object">
<link rel="next" href="bounds___traits_class.html" title="bounds&lt;&gt; traits class">
</head>
<body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="converter___function_object.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="bounds___traits_class.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="boost_numericconversion.type_requirements_and_user_defined_types_support"></a><a class="link" href="type_requirements_and_user_defined_types_support.html" title="Type Requirements and User-defined-types support">Type
Requirements and User-defined-types support 类型要求和用户自定义类型支持</a>
</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.type_requirements">Type
Requirements 类型要求</a></span></dt>
<dt><span class="section"><a href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.udt_s_special_semantics">UDT's
special semantics 用户自定义类型的特殊语义</a></span></dt>
<dt><span class="section"><a href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.special_policies">Special
Policies 特殊策略</a></span></dt>
</dl>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_numericconversion.type_requirements_and_user_defined_types_support.type_requirements"></a><a class="link" href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.type_requirements" title="Type Requirements">Type Requirements 类型要求</a>
</h3>
</div>
</div>
</div>
<p> Both arithmetic (built-in) and user-defined numeric types
require proper specialization of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;&gt;</span></code>
(that is, with (in-class) integral constants).<br>
算术类型(内建的)和用户自定义的数字类型都要求对 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;&gt;</span></code>
(以(类中)的整型常量)进行正确的特化。 </p>
<p> The library uses <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">is_specialized</span></code>
to detect whether the type is builtin or user defined, and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">is_integer</span></code>, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">is_signed</span></code> to
detect whether the type is integer or floating point; and whether it is
signed/unsigned.<br>
本库用 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">is_specialized</span></code>
来检测某个类型是否内建的或用户定义的，用 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">is_integer</span></code>, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">is_signed</span></code>
来检测某个类型为整数或浮点数；以及是否有符号/无符号。 </p>
<p> The default <code class="computeroutput"><span class="identifier">Float2IntRounder</span></code>
policies uses unqualified calls to functions <code class="computeroutput"><span class="identifier">floor</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">ceil</span><span class="special">()</span></code>; but the
standard functions are introduced in scope by a using directive:<br>
缺省的 <code class="computeroutput"><span class="identifier">Float2IntRounder</span></code>
策略以非受限方式调用函数 <code class="computeroutput"><span class="identifier">floor</span><span class="special">()</span></code>
和 <code class="computeroutput"><span class="identifier">ceil</span><span class="special">()</span></code>；而标准函数是通过一个
using 指令引入到作用域中： </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">floor</span> <span class="special">;</span> <span class="keyword">return</span> <span class="identifier">floor</span><span class="special">(</span><span class="identifier">s</span><span class="special">);</span>
</pre>
<p> Therefore, for builtin arithmetic types, the std functions
will be used. User defined types should provide overloaded versions of
these functions in order to use the default rounder policies. If these
overloads are defined within a user namespace argument dependent lookup
(ADL) should find them, but if your compiler has a weak ADL you might
need to put these functions some place else or write your own rounder
policy.<br>
因此，对于内建的算术类型，将使用标准函数。为了使用缺省的舍入策略，用户自定义类型应该提供这些函数的重载版本。如果这些重载是在一个用户名字空间内定
义的，参数依赖查找(ADL)会找到它们，但是如果你的编译器的ADL较弱，那么你可能需要将这些函数放在其它地方，或者编写你自己的舍入策略。 </p>
<p> The default <code class="computeroutput"><span class="identifier">Trunc</span><span class="special">&lt;&gt;</span></code>
rounder policy needs to determine if the source value is positive or
not, and for this it evaluates the expression <code class="computeroutput"><span class="identifier">s</span>
<span class="special">&lt;</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">S</span><span class="special">&gt;(</span><span class="number">0</span><span class="special">)</span></code>.
Therefore, user defined types require a visible <code class="computeroutput"><span class="keyword">operator</span><span class="special">&lt;</span></code> in order
to use the <code class="computeroutput"><span class="identifier">Trunc</span><span class="special">&lt;&gt;</span></code>
policy (the default).<br>
缺省的 <code class="computeroutput"><span class="identifier">Trunc</span><span class="special">&lt;&gt;</span></code>
舍入策略需要判断源数值是否为正，为此它要对表达式 <code class="computeroutput"><span class="identifier">s</span> <span class="special">&lt;</span>
<span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">S</span><span class="special">&gt;(</span><span class="number">0</span><span class="special">)</span></code>
进行求值。因此，为了使用 <code class="computeroutput"><span class="identifier">Trunc</span><span class="special">&lt;&gt;</span></code>
策略(缺省情况)，用户自定义类型需要一个可见的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">&lt;</span></code>
。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_numericconversion.type_requirements_and_user_defined_types_support.udt_s_special_semantics"></a><a class="link" href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.udt_s_special_semantics" title="UDT's special semantics">UDT's special semantics
用户自定义类型的特殊语义</a>
</h3>
</div>
</div>
</div>
<a name="boost_numericconversion.type_requirements_and_user_defined_types_support.udt_s_special_semantics.conversion_traits"></a>
<h5><a name="id2645593"></a> <a class="link" href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.udt_s_special_semantics.conversion_traits">Conversion
Traits 转换 Traits</a> </h5>
<p> If a User Defined Type is involved in a conversion, it is <span class="emphasis"><em>assumed</em></span>
that the UDT has <a class="link" href="definitions.html#numeric_conversion_definitions_range">wider
range</a> than any built-in type, and consequently the values of
some <code class="computeroutput"><span class="identifier">converter_traits</span><span class="special">&lt;&gt;</span></code>
members are hardwired regardless of the reality. The following table
summarizes this:<br>
在转换中，如果涉及到用户自定义类型，将 <span class="emphasis"><em>假定</em></span>
UDT 具有比任意内建类型 <a class="link" href="definitions.html#numeric_conversion_definitions_range">更
广的范围</a>，因此不管事实如何，有些 <code class="computeroutput"><span class="identifier">converter_traits</span><span class="special">&lt;&gt;</span></code>
成员就是硬性规定的。总结如下表： </p>
<div class="itemizedlist">
<ul type="disc">
<li>
<code class="computeroutput"><span class="identifier">Target</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span> and <code class="computeroutput"><span class="identifier">Source</span><span class="special">=</span></code><span class="emphasis"><em>built-in</em></span><br><code class="computeroutput"><span class="identifier">Target</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span> 且 <code class="computeroutput"><span class="identifier">Source</span><span class="special">=</span></code><span class="emphasis"><em>built-in</em></span>
<div class="itemizedlist">
<ul type="circle">
<li><code class="computeroutput"><span class="identifier">subranged</span><span class="special">=</span><span class="keyword">false</span></code></li>
<li><code class="computeroutput"><span class="identifier">supertype</span><span class="special">=</span><span class="identifier">Target</span></code></li>
<li><code class="computeroutput"><span class="identifier">subtype</span><span class="special">=</span><span class="identifier">Source</span></code></li>
</ul>
</div>
</li>
<li>
<code class="computeroutput"><span class="identifier">Target</span><span class="special">=</span></code><span class="emphasis"><em>built-in</em></span>
and <code class="computeroutput"><span class="identifier">Source</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span><span class="emphasis"><em></em></span><br><code class="computeroutput"><span class="identifier">Target</span><span class="special">=</span></code><span class="emphasis"><em>built-in</em></span> 且 <code class="computeroutput"><span class="identifier">Source</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span><span class="emphasis"><em></em></span>
<div class="itemizedlist">
<ul type="circle">
<li><code class="computeroutput"><span class="identifier">subranged</span><span class="special">=</span><span class="keyword">true</span></code></li>
<li><code class="computeroutput"><span class="identifier">supertype</span><span class="special">=</span><span class="identifier">Source</span></code></li>
<li><code class="computeroutput"><span class="identifier">subtype</span><span class="special">=</span><span class="identifier">Target</span></code></li>
</ul>
</div>
</li>
<li>
<code class="computeroutput"><span class="identifier">Target</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span> and <code class="computeroutput"><span class="identifier">Source</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span><span class="emphasis"><em></em></span><br><code class="computeroutput"><span class="identifier">Target</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span> 且 <code class="computeroutput"><span class="identifier">Source</span><span class="special">=</span></code><span class="emphasis"><em>UDT</em></span>
<div class="itemizedlist">
<ul type="circle">
<li><code class="computeroutput"><span class="identifier">subranged</span><span class="special">=</span><span class="keyword">false</span></code></li>
<li><code class="computeroutput"><span class="identifier">supertype</span><span class="special">=</span><span class="identifier">Target</span></code></li>
<li><code class="computeroutput"><span class="identifier">subtype</span><span class="special">=</span><span class="identifier">Source</span></code></li>
</ul>
</div>
</li>
</ul>
</div>
<p> The <code class="computeroutput"><span class="identifier">Traits</span></code> member <code class="computeroutput"><span class="identifier">udt_mixture</span></code>
can be used to detect whether a UDT is involved and to infer the
validity of the other members as shown above.<br><code class="computeroutput"><span class="identifier">Traits</span></code> 成员 <code class="computeroutput"><span class="identifier">udt_mixture</span></code>
可用于检测是否涉及某个 UDT 并如上所示推断其它成员的有效性。 </p>
<a name="boost_numericconversion.type_requirements_and_user_defined_types_support.udt_s_special_semantics.range_checking"></a>
<h5><a name="id2645983"></a> <a class="link" href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.udt_s_special_semantics.range_checking">Range
Checking 范围检查</a></h5><p> Because User Defined Numeric Types might have peculiar ranges
(such as an unbounded range), this library does not attempt to supply a
meaningful range checking logic when UDTs are involved in a conversion.
Therefore, if either Target or Source are not built-in types, the
bundled range checking of the <code class="computeroutput"><span class="identifier">converter</span><span class="special">&lt;&gt;</span></code>
function object is automatically disabled. However, it is possible to
supply a user-defined range-checker. See <a class="link" href="type_requirements_and_user_defined_types_support.html#numeric_conversion_requirements_hooks">Special
Policies</a><br>因为用户自定义数字类型可能具有特殊的范围(如一个无界的范围)，因此本库在转换涉及某个UDT时不提供一个有意义的范围检查逻辑。因此，如果目标类型或源类型之一不是内建类型，则 <code class="computeroutput"><span class="identifier">converter</span><span class="special">&lt;&gt;</span></code>
函数对象所绑定的范围检查就会自动禁用。不过，你可以提供一个用户自定义的范围检查器。请见 <a class="link" href="type_requirements_and_user_defined_types_support.html#numeric_conversion_requirements_hooks">特殊策略</a>。<a class="link" href="type_requirements_and_user_defined_types_support.html#numeric_conversion_requirements_hooks"></a> </p>
</div>
<a name="numeric_conversion_requirements_hooks"></a>
<p> </p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_numericconversion.type_requirements_and_user_defined_types_support.special_policies"></a><a class="link" href="type_requirements_and_user_defined_types_support.html#boost_numericconversion.type_requirements_and_user_defined_types_support.special_policies" title="Special Policies">Special Policies 特殊策略</a>
</h3>
</div>
</div>
</div>
<p> There are two components of the <code class="computeroutput"><span class="identifier">converter</span><span class="special">&lt;&gt;</span></code>
class that might require special behavior if User Defined Numeric Types
are involved: the Range Checking and the Raw Conversion.<br>如果涉及到用户自定义类型，<code class="computeroutput"><span class="identifier">converter</span><span class="special">&lt;&gt;</span></code>
类中有两个组件可能需要特殊的行为：范围检查和原始转换。 </p>
<p> When both Target and Source are built-in types, the converter
class uses an internal range checking logic which is optimized and
customized for the combined properties of the types.<br>当目标类型和源类型都是内建类型时，转换器类使用一个内部的范围检查逻辑，该逻辑针对类型的组合特性进行了优化和定制。 </p>

<p> However, this internal logic is disabled when either type is
User Defined. In this case, the user can specify an <span class="emphasis"><em>external</em></span>
range checking policy which will be used in place of the internal code.
See <a class="link" href="numeric_converter_policy_classes.html#numeric_conversion_policy_user_range_checker">UserRangeChecker</a>
policy for details.<br>但是，当有其中一个类型是用户自定义类型时，该内部逻辑就会被禁用。这种情况下，用户可以指定一个 <span class="emphasis"><em>外部</em></span>
的范围检查策略，用于替换内部代码。具体请见 <a class="link" href="numeric_converter_policy_classes.html#numeric_conversion_policy_user_range_checker">UserRangeChecker</a> 策略。 </p>

<p> The converter class performs the actual conversion using a
Raw Converter policy. The default raw converter simply performs a <code class="computeroutput"><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">source</span><span class="special">)</span></code>.<br>转换器类使用一个原始转换器策略执行实际的转换。缺省的原始转换器只是执行一个 <code class="computeroutput"><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">source</span><span class="special">)</span></code>. </p>
<p> However, if the a UDT is involved, the <code class="computeroutput"><span class="keyword">static_cast</span></code>
might not work. In this case, the user can implement and pass a
different raw converter policy. See <a class="link" href="numeric_converter_policy_classes.html#numeric_conversion_policy_raw_converter">RawConverter</a>
policy for details<br>但是，如果涉及到 UDT，<code class="computeroutput"><span class="keyword">static_cast</span></code>
也许就不能奏效了。这种情况下，用户可以实现一个不同的原始转换器策略并传入它。具体请见 <a class="link" href="numeric_converter_policy_classes.html#numeric_conversion_policy_raw_converter">RawConverter</a> 策略。 </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%">
<tbody>
<tr>
<td align="left"></td>
<td align="right">
<div class="copyright-footer">Copyright © 2004 -2007
Fernando Luis Cacciola Carballal
<p> Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>
</div>
</td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="converter___function_object.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="bounds___traits_class.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
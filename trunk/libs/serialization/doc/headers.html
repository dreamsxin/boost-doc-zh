<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><!--
(C) Copyright 2002-4 Robert Ramey - http://www.rrsd.com . 
Use, modification and distribution is subject to the Boost Software
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
-->






  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">






  
  
  
  
  
  <link rel="stylesheet" type="text/css" href="../../../boost.css">






  
  
  
  
  
  <link rel="stylesheet" type="text/css" href="style.css">






  
  
  
  
  
  <title>Serialization - Code Structure</title></head>

<body link="#0000ff" vlink="#800080">






<table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">






  <tbody>





    <tr>





 
    <td valign="top" width="300"> 
      
      
      
      
      
      
      <h3><a href="../../../index.htm"><img alt="C++ Boost" src="../../../boost.png" border="0" height="86" width="277"></a></h3>






    </td>






    <td valign="top"> 
      
      
      
      
      
      
      <h1 align="center">Serialization序列化</h1>






      
      
      
      
      
      
      <h2 align="center">代码结构</h2>






    </td>






  </tr>






  
  
  
  
  
  </tbody>
</table>






<hr>

<dl class="page-index">






  <dt><a href="#userincludes">用户程序要包含的文件</a>
  </dt>





  
  
  
  
  
  <dl class="page-index">






    <dt><a href="#archiveimplementations">存档的实现</a>
    </dt>





    <dt><a href="#serializationdeclarations">序列化的声明</a>
    </dt>





    <dt><a href="#serializationimplementations">序列化的实现</a>
  </dt>





  
  
  
  
  
  </dl>






  <dt><a href="#libraryimplementation">实现本库的文件</a>
  </dt>





  
  
  
  
  
  <dl class="page-index">






    <dt><a href="#archivedevelopment">存档的开发</a>
    </dt>





    <dt><a href="#archiveinternals">存档的内部</a>
    </dt>





    <dt><a href="#codemodules">存档库代码模块</a>
    </dt>





    <dt><a href="#dataflowiterators">数据流迭代器</a>
  </dt>





  
  
  
  
  
  </dl>






</dl>





本库包含了大量文件。它们是按照上述目录中所列的用途来组织和分类的。 
<p>
<code style="white-space: normal;"></code>一个类或模板的名字空间与包含该文件的目录是对应的。例如，类
</p>





<pre><code>
boost::archive::text_oarchive
</code></pre>





的声明位于以下文件
<pre><code>
#include &lt;boost/archive/text_oarchive.hpp&gt;
</code></pre>







<a name="userincludes">
</a>
<h3><a name="userincludes">用户程序要包含的文件</a></h3>






<a name="userincludes">使用本库只要包含本节所列的头文件。不需要显式包含任何其它头文件。

</a><a name="archiveimplementations">
</a>
<h4><a name="archiveimplementations">存档的实现</a></h4>






<a name="archiveimplementations">以下头文件包含了用于保存和恢复数据的各种存档类型的声明。根据代码模块要求的工具包含以下存档。

</a>
<dl>







  <dt><a target="archive_exception" href="../../../boost/archive/archive_exception.hpp">
boost/archive/archive_exception.hpp
    </a>
  </dt>





  <dd>可能会由本库产生的异常。</dd>







  <dt><a target="binary_iarchive" href="../../../boost/archive/binary_iarchive.hpp">
boost/archive/binary_iarchive.hpp
    </a>
  </dt>





  <dd>用于导入的原生二进制输入存档。</dd>







  <dt><a target="binary_oarchive" href="../../../boost/archive/binary_oarchive.hpp">
boost/archive/binary_oarchive.hpp
    </a>
  </dt>





  <dd>用于保存的原生二进制输出存档。</dd>







  <dt><a target="text_iarchive" href="../../../boost/archive/text_iarchive.hpp">
boost/archive/text_iarchive.hpp
    </a>
  </dt>





  <dd>用于导入的文本输入存档。</dd>







  <dt><a target="text_oarchive" href="../../../boost/archive/text_oarchive.hpp">
boost/archive/text_oarchive.hpp
    </a>
  </dt>





  <dd>用于保存的文本输出存档。</dd>







  <dt><a target="text_wiarchive" href="../../../boost/archive/text_wiarchive.hpp">
boost/archive/text_wiarchive.hpp
    </a>
  </dt>





  <dd>用于导入的宽字符文本输入存档。</dd>







  <dt><a target="text_woarchive" href="../../../boost/archive/text_woarchive.hpp">
boost/archive/text_woarchive.hpp
    </a>
  </dt>





  <dd>用于保存的宽字符文本输出存档。</dd>







  <dt><a target="xml_iarchive" href="../../../boost/archive/xml_iarchive.hpp">
boost/archive/xml_iarchive.hpp
    </a>
  </dt>





  <dd>用于导入的 xml 输入存档。</dd>







  <dt><a target="text_oarchive" href="../../../boost/archive/xml_oarchive.hpp">
boost/archive/xml_oarchive.hpp
    </a>
  </dt>





  <dd>用于保存的 xml 输出存档。</dd>







  <dt><a target="text_wiarchive" href="../../../boost/archive/xml_wiarchive.hpp">
boost/archive/xml_wiarchive.hpp
    </a>
  </dt>





  <dd>用于导入的宽字符 xml 输入存档。</dd>







  <dt><a target="text_woarchive" href="../../../boost/archive/xml_woarchive.hpp">
boost/archive/xml_woarchive.hpp
    </a>
  </dt>





  <dd>用于保存的宽字符 xml 输出存档。</dd>







</dl>







<a name="serializationdeclarations">
</a>
<h4><a name="serializationdeclarations">序列化的声明</a></h4>






<a name="serializationdeclarations">为了指定一个类型的序列化，你要为序列化函数编写模板。对于最简单的情况，不需要为此包含任何头文件。在多数情况下，需要包含一个或多个下面的头文件，以实现或强化给定类的序列化实现。

</a>
<dl>







  <dt><a target="base_object" href="../../../boost/serialization/base_object.hpp">
boost/serialization/base_object.hpp
    </a>
  </dt>





  <dd>用于基类的序列化。</dd>







  <dt><a target="nvp" href="../../../boost/serialization/nvp.hpp">
boost/serialization/nvp.hpp
    </a>
  </dt>





  <dd>将一个名字与一个可序列化对象关联起来。这对于正确地处理 xml 存档是需要的，它要求包含对象的名字。</dd>







  <dt><a target="split_free" href="../../../boost/serialization/split_free.hpp">
boost/serialization/split_free.hpp
    </a>
  </dt>





  <dd>将非介入式序列化的实现分解为保存和导入函数。</dd>







  <dt><a target="split_member" href="../../../boost/serialization/split_member.hpp">
boost/serialization/split_member.hpp
    </a>
  </dt>





  <dd>将介入式序列化的实现分解为保存和导入函数。</dd>







  <dt><a target="export" href="../../../boost/serialization/export.hpp">
boost/serialization/export.hpp
    </a>
  </dt>





  <dd>通过关键字输出实现指向派生类的指针的序列化。</dd>







  <dt><a target="is_abstract" href="../../../boost/serialization/is_abstract.hpp">
boost/serialization/is_abstract.hpp
    </a>
  </dt>





  <dd>为实现抽象基类指针的序列化。该实现的泛型版本只可用于最新的编译器。这个版本只是一个简单的包装层，允许通过"手工"指定基类是否抽象的。</dd>







</dl>




以下头文件通常并不需要。它们用于覆盖某些特定类型的序列化处理在某些方面的缺省实现。

<dl>







  <dt><a target="version" href="../../../boost/serialization/version.hpp">
boost/serialization/version.hpp
    </a>
  </dt>





  <dd>覆盖赋给某个类的缺省版本号(0)。</dd>







  <dt><a target="level" href="../../../boost/serialization/level.hpp">
boost/serialization/level.hpp
    </a>
  </dt>





  <dd>覆盖某个类型的缺省实现级别 trait.</dd>







  <dt><a target="tracking" href="../../../boost/serialization/tracking.hpp">
boost/serialization/tracking.hpp
    </a>
  </dt>





  <dd>覆盖某个类型的缺省跟踪 trait.</dd>







  <dt><a target="type_info_implementation" href="../../../boost/serialization/type_info_implementation.hpp">
boost/serialization/type_info_implementation.hpp
    </a>
  </dt>





  <dd>缺省情况下，本库使用 RTTI 来在运行期进行类型识别。有某些情况下，如在没有实现 RTTI 的平台上，可以包含本头文件以覆盖缺省的运行期类型识别系统。</dd>







</dl>







<a name="serializationimplementations">
</a>
<h4><a name="serializationimplementations">序列化的实现</a></h4>






<a name="serializationimplementations">这组头文件包含了一些模板，它们实现了对标准库或 Boost 库的模板的序列化。任何程序要使用这些模板来执行对这些类型的对象的序列化，只需要包含相应的头文件即可。
</a>
<p>
<a name="serializationimplementations">为了便于使用，这些头文件被命名为：boost/serialization/xxx.hpp

其中 xxx 为包含要序列化的类型的头文件名。例如，声明
</a></p>





<pre><code>
<a name="serializationimplementations">#include &lt;boost/serialization/list.hpp&gt;<br></a></code></pre>







<a name="serializationimplementations">包含了实现对 STL
<code style="white-space: normal;">std::list</code> 类型的序列化的代码。而

</a>
<pre><code>
<a name="serializationimplementations">#include &lt;boost/serialization/shared_ptr.hpp&gt;<br></a></code></pre>







<a name="serializationimplementations">则包含了实现对 BOOST <code style="white-space: normal;">boost::shared_ptr</code> 类型的序列化的代码。注意，包含某个类型的序列化头文件就会自动地包含相应类型的头文件。到这篇文档为止，本库包含了所有 STL 库中的类模板以及 <code style="white-space: normal;">boost::optional</code>, 
<code style="white-space: normal;">boost::shared_ptr</code>, 和 
<code style="white-space: normal;">boost::scoped_ptr</code> 的序列化代码。随着时间的推移，这个名单还会继续扩充。

</a><a name="libraryimplementation">
</a>
<h3><a name="libraryimplementation">实现本库的文件</a></h3>







<a name="archivedevelopment">
</a>
<h4><a name="archivedevelopment">存档的开发</a></h4>






<a name="archivedevelopment">以下头文件包含了一些基本的类型声明，这些类型供本库的用户用于创建具体的存档类型。想要创建自己的存档类型的用户也许想了解这些头文件，看看本库所包含的存档是如何被构造的。

</a>
<dl>







  <dt><a target="basic_archive" href="../../../boost/archive/basic_archive.hpp">
boost/archive/basic_archive.hpp
    </a>
  </dt>






  <dd>该文件包含了在所有存档实现上都必须包含的特定类型的声明。序列化系统依靠这些特定的类型，如 <code style="white-space: normal;">class_id_type</code> 和其它类型，在存档中记录下重建原始数据结构所需的有关信息。它们和其它可序列化类型一样被处理。如，在简单的文本存档中，它们可以按简单基本类型来处理，而在 xml 存档中则需要特定的代码来处理。
  </dd>







  <dt><a target="basic_text_oprimitive" href="../../../boost/archive/basic_text_oprimitive.hpp">
boost/archive/basic_text_oprimitive.hpp
    </a>
  </dt>





  <dt><a target="basic_text_iprimitive" href="../../../boost/archive/basic_text_iprimitive.hpp">
boost/archive/basic_text_iprimitive.hpp
    </a>
  </dt>






  <dd>根据窄字符或宽字符文本流实现对基本类型的序列化。用于实现文本存档和 XML 存档。也可用于实现其它的文本存档，如用户友好的文本或 windows ini 文件。
  </dd>







  <dt><a target="basic_binary_oprimitive" href="../../../boost/archive/basic_binary_oprimitive.hpp">
boost/archive/basic_binary_oprimitive.hpp
    </a>
  </dt>





  <dt><a target="basic_binary_iprimitive" href="../../../boost/archive/basic_binary_iprimitive.hpp">
boost/archive/basic_binary_iprimitive.hpp
    </a>
  </dt>






  <dd>根据窄字符或宽字符二进制流实现对基本类型的序列化。 
  </dd>







  <dt><a target="basic_binary_oarchive" href="../../../boost/archive/basic_binary_oarchive.hpp">
boost/archive/basic_binary_oarchive.hpp
    </a>
  </dt>





  <dt><a target="basic_binary_iarchive" href="../../../boost/archive/basic_binary_iarchive.hpp">
boost/archive/basic_binary_iarchive.hpp
    </a>
  </dt>





  <dd>根据窄字符或宽字符二进制流实现对所有类型的序列化。这是从前面的基本类型二进制实现中分离出来的。这样有助于在以后创建其它类型的二进制存档。同时也保留了类似性和对称性，有助于理解本程序库。
  </dd>






  <dt><a target="basic_text_oarchive" href="../../../boost/archive/basic_text_oarchive.hpp">
boost/archive/basic_text_oarchive.hpp
    </a>
  </dt>





  <dt><a target="basic_text_iarchive" href="../../../boost/archive/basic_text_iarchive.hpp">
boost/archive/basic_text_iarchive.hpp
    </a>
  </dt>






  <dt><a target="basic_xml_oarchive" href="../../../boost/archive/basic_xml_oarchive.hpp">
boost/archive/basic_xml_oarchive.hpp
    </a>
  </dt>





  <dt><a target="basic_xml_iarchive" href="../../../boost/archive/basic_xml_iarchive.hpp">
boost/archive/basic_xml_iarchive.hpp
    </a>
  </dt>






  <dd>根据窄字符或宽字符文本流实现对所有类型的序列化。这些类指定了存档类型对于某个类型的特定行为。例如，<code style="white-space: normal;">basic_xml_oarchive.hpp</code> 中的代码确保了在编译期可以捕获到对象没有指定名字的错误。另一方面， <code style="white-space: normal;">basic_text_oarchive.hpp</code>
中的代码则会忽略附加在对象上的名字。
    
    
    
    
    
    <p>
    </p>





  </dd>





  <dt><a target="common_iarchive" href="../../../boost/archive/detail/common_iarchive.hpp">
boost/archive/detail/common_iarchive.hpp
    </a>
  </dt>





  <dt><a target="common_oarchive" href="../../../boost/archive/detail/common_oarchive.hpp">
boost/archive/detail/common_oarchive.hpp
    </a>
  </dt>





  <dd>所有存档实现均派生自这两个头文件。它们提供了本库内部实现细节的接口。
  </dd>







</dl>









<h4><a name="archiveinternals">存档的内部</a></h4>






目录 
<a target="basic_xml_iarchive" href="../../../boost/archive/detail">boost/archive/detail</a>
下的头文件为本库自身的实现部分。本库的用户无论是要实现一个类的序列化，还是要实现一个新的存档类型，都无须修改这个部分。<br><a name="archiveinternals">接口(见 </a><a target="detail" href="archives.html">存档概念</a>)与实现被分别提取至独立的类，令代码的重复性最小化。这些文件在目录
<a target="boost_archive_detail" href="../../../boost/archive/detail">boost/archive/detail</a> 中。它们被存档类的实现按需要包含，以前所列。不过这样有一个不好的副作用，会令到实现不够透明。不论是要实现一个类的序列化，或是实现一个新的存档类型。用户都不会发现需要修改这些文件。<p>以下讨论是基于
<a target="class_diagram" href="class_diagram.html">类图</a> 的。</p><dt><a target="interface_iarchive" href="../../../boost/archive/detail/interface_iarchive.hpp">
boost/archive/detail/interface_iarchive.hpp</a>
</dt><dt><a target="interface_iarchive" href="../../../boost/archive/detail/interface_iarchive.hpp">
boost/archive/detail/interface_iarchive.hpp</a>
</dt><dd>这里是为了 
<a href="archives.html">存档概念</a> 的声明和定义。
这个类将对存档接口的调用重定向至最底层的派生存档类中的一个名为 <code>save_override</code> 的函数。 
</dd>
<code>save_override</code> 在存档类层次中的每个类中都被声明和实现。

<pre><code>
template<class t="">
void save_override(T &amp; t, BOOST_PFTO int){
    // All for otherwise unhandled types are forwarded to the base class.
    // This emulates behavior for function overloading.
    this-&gt;base::save_override(t, 0);
}
void save_override(const some_type &amp; t, int){
    // any special handling for some type
    // this will usually entail forwarding some other operation
    // in the most derived class.
    this-&gt;This()-&gt;...
    // or in one of its parents basic_text_oprimitive
    this-&gt;This()-&gt;save(static_cast&lt;int&gt;(t));
}
... // other special type handling
</class></code></pre>注意，对
<a target="detail" href="implementation.html#functiontemplateordering">函数模板偏序</a>
的使用可以保证正确的 save 实现被选中。
<h4><a name="codemodules">存档库代码模块</a></h4>






<a name="codemodules">库的这个部分是代码的实现。所有这些代码位于
</a><a target="src" href="../../../libs/serialization/src">libs/serialization/src</a> 名字为 *.cpp. 目录
<a target="src" href="../../../boost/archive/impl">boost/archive/impl</a>
中的 *.ipp 文件为模板实现。这些模板只被实例化用于存档的实现，所以通常不被用户代码模块所包含。
<p>以预编译代码和模板头文件来实现程序库的差异大家都很清楚。本库同时使用了这两种方式。它用了模板头文件来生成序列化一个用户类型或基本类型的代码，用预编译代码来实现只依赖于存档类型的代码部分。构建本库时将生成并编译所有与存档实现相关的代码。

</p>





<ul>






  <li>用户类型和基本类型的序列化会以最快的速度运行。这一点与不使用模板的旧版本库有明显区别。
  </li>





  <li>库中不会改变的代码只需被编译一次，而不是每次随着用户程序重新编译。这样可以节省很多开发时间。
  </li>





  <li>只与实现相关的头文件只需要包含在库的代码模块中。这样可以防止用户程序依赖于 serialization 库的实现。
  </li>





  <li>在构建本库时，我得到一个结论，在某些情形下，静态的代码/数据实例化会发生问题，如果它们不是在一个代码模块中就不能得到满意的解决。不幸的是，我已经忘了让我得到该结论的详细情况。
  </li>





</ul>
一个例子就是，在本库中对 spirit 库的使用。这导致了较长的编译时间，也包含了很多其它文件。只在库中这样做总比在每一个使用 xml 序列化的程序中都这样做要方便得多。
<h4><a name="dataflowiterators">数据流迭代器</a></h4>






<a name="dataflowiterators">在开发本库期间，为了方便起见，我们创建了一组可组合的迭代器适配器，以处理存档文本。其中包括转义 xml 文本、非转义 xml 文本，以及实现与 base64 相互转换的应用。
</a>
<p>
<a name="dataflowiterators">对此有一个完整的讨论。它涉及到 
</a><a href="../../../libs/iterator/doc/index.html">boost iterator</a> 库、<a href="http://www.zib.de/weiser/vtl/index.html">View Template 库</a>, 等等。 
</p>





<p>这些迭代器的代码其实与本库无关。但由于它从未而且以后也不太可能会在此语境之外被讨论。所以，我把它放在 serialization 库的目录之下了：<a target="archiveiterators" href="../../../boost/archive/iterators">boost/archive/iterators</a>.
这些迭代器的相关讨论，请见 
<a href="dataflow.html">数据流迭代器</a>。
</p>





<hr>
<p><i>© Copyright <a href="http://www.rrsd.com">Robert Ramey</a> 2002-2004. 
Distributed under the Boost Software License, Version 1.0. (See
accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
</i></p>






</body></html>
[/license

Boost.Bimap

Copyright (c) 2006-2007 Matias Capeletto

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)

]

[/ QuickBook Document version 1.4 ]

[section:unordered_set_of_reference unordered_set_of Reference  unordered_set_of参考]

[section Header "boost/bimap/unordered_set_of.hpp" synopsis]

    namespace boost {
    namespace bimaps {


    template
    <
        class KeyType,
        class HashFunctor   = hash< KeyType >,
        class EqualKey      = std::equal_to< KeyType >
    >
    struct unordered_set_of;


    template
    <
        class HashFunctor   = hash< _relation >,
        class EqualKey      = std::equal_to< _relation >
    >
    struct unordered_set_of_relation;


    } // namespace bimap
    } // namespace boost


[endsect]

[section Header "boost/bimap/unordered_multiset_of.hpp" synopsis]

    namespace boost {
    namespace bimaps {


    template
    <
        class KeyType,
        class HashFunctor   = hash< KeyType >,
        class EqualKey      = std::equal_to< KeyType >
    >
    struct unordered_multiset_of;


    template
    <
        class HashFunctor   = hash< _relation >,
        class EqualKey      = std::equal_to< _relation >
    >
    struct unordered_multiset_of_relation;


    } // namespace bimap
    } // namespace boost


[endsect]

[section:collection_type_specifiers_unordered_set_of_and_unordered_multiset_of Collection type specifiers unordered_set_of and unordered_multiset_of 组合类型指示符unordered_set_of和unordered_multiset_of]

These collection types specifiers allow for set views without and
with allowance of duplicate elements, respectively. The syntax of
`set_of` and `multiset_of` coincide, thus we describe them
in a grouped manner.\n
这些组合类型指示符分别用于不允许和允许重复元素的集合视图。
`set_of` 和 `multiset_of` 的语法很相近，所以我们将它们一起说明。

[endsect]

[section unordered_\[multi\]set_of Views]

An unordered_\[multi\]set_of set view is a tr1::unordered\[multi\]set signature compatible
interface to the underlying heap of elements contained in a `bimap`.\n
unordered_\[multi\]set_of 集合视图是一个与 tr1::unordered\[multi\]set 签名兼容的接口，用于访问 `bimap` 中的元素堆。

The interface and semantics of `unordered_[multi]set_of` views are
modeled according to the proposal for unordered associative containers given
in the __CPP_STANDARD_LIBRARY_TECHNICAL_REPORT__, also known as TR1.
An `unordered_[multi]set_of` view is particularized according to a given
`Hash` function object which returns hash values for the keys and a
binary predicate `Pred` acting as an equivalence relation on values of Key.\n
`unordered_[multi]set_of` 视图的接口和语义遵循 __CPP_STANDARD_LIBRARY_TECHNICAL_REPORT__ (称为TR1)中的无序关联式容器建议。
`unordered_[multi]set_of` 视图是按照一个给定的 `Hash` 函数对象和一个二元谓词 `Pred` 来排列，
散列函数按照键值返回散列值，二元谓词则表示键值的等价关系。

There are two variants: unordered_set_of, which do not allow duplicate elements
(with respect to its associated comparison predicate) and unordered_multiset_of,
which accept those duplicates. The interface of these two variants is the same
to a great extent, so they are documented together with their differences
explicitly noted when they exist.\n
它有两个变体：unordered_set_of，它不允许重复的元素(对于它的关联比较谓词而言)，和 unordered_multiset_of，
它可以接受重复的元素。这两个变体的接口基本上一样，因此我们对它们一起说明，并对它们间的差异特别说明。

If you look the bimap by a side, you will use a map view and if you looked
it as a whole you will be using a set view.\n
如果你从某侧去看一个 bimap，你要使用某个映射视图，如果你要把它当作一个整体来看，你就要使用集合视图。

Except where noted, `unordered_[multi]set_of` views (both unique and non-unique) are models
of [^Unordered Associative Container].
Validity of iterators and references to elements is preserved in all cases.
Occasionally, the exception safety guarantees provided are actually stronger
than required by the extension draft. We only provide descriptions of those
types and operations that are either not present in the concepts modeled or
do not exactly conform to the requirements for unordered associative containers.\n
除了特别说明，`unordered_[multi]set_of` 视图(包括唯一和非唯一的)都符合 [^无序关联式容器]。
在所有情况下，迭代器和元素引用的有效性都得到保证。有些情况下，所提供的异常安全保证强于标准扩展草案的要求。
我们只对那些在概念模型中没有，或者与无序关联式容器的要求不完全吻合的类型和操作提供说明。


    namespace boost {
    namespace bimap {
    namespace views {

    template< ``['-implementation defined parameter list-]`` >
    class ``['-implementation defined view name-]``
    {
        public:

        // types

        typedef ``['-unspecified-]`` key_type;
        typedef ``['-unspecified-]`` value_type;
        typedef ``['-unspecified-]`` key_compare;
        typedef ``['-unspecified-]`` value_compare;
        typedef ``['-unspecified-]`` hasher;
        typedef ``['-unspecified-]`` key_equal;
        typedef ``['-unspecified-]`` allocator_type;
        typedef ``['-unspecified-]`` reference;
        typedef ``['-unspecified-]`` const_reference;
        typedef ``['-unspecified-]`` iterator;
        typedef ``['-unspecified-]`` const_iterator;
        typedef ``['-unspecified-]`` size_type;
        typedef ``['-unspecified-]`` difference_type;
        typedef ``['-unspecified-]`` pointer;
        typedef ``['-unspecified-]`` const_pointer;
        typedef ``['-unspecified-]`` local_iterator;
        typedef ``['-unspecified-]`` const_local_iterator;

        typedef ``['-unspecified-]`` info_type;

        // construct/destroy/copy:

        this_type & operator=(const this_type & x);

        allocator_type get_allocator() const;

        // size and capacity

        bool      empty() const;
        size_type size() const;
        size_type max_size() const;

        // iterators

        iterator       begin();
        const_iterator begin() const;
        iterator       end();
        const_iterator end() const;

        // modifiers

        std::pair< iterator, bool > ``[link reference_unordered_set_of_insert_value insert]``(const value_type & x);

        iterator ``[link reference_unordered_set_of_insert_iterator_value insert]``(iterator position, const value_type & x);

        template< class InputIterator >
        void ``[link reference_unordered_set_of_insert_iterator_iterator insert]``(InputIterator first, InputIterator last);

        iterator ``[link reference_unordered_set_of_erase_iterator erase]``(iterator position);

        template< class CompatibleKey >
        size_type ``[link reference_unordered_set_of_erase_key erase]``(const CompatibleKey & x);

        iterator ``[link reference_unordered_set_of_erase_iterator_iterator erase]``(iterator first, iterator last);

        bool ``[link reference_unordered_set_of_replace_iterator_value replace]``(iterator position, const value_type & x);

        // Only in map views
        // {

          template< class CompatibleKey >
          bool ``[link reference_unordered_set_of_replace_key_iterator_key replace_key]``(iterator position, const CompatibleKey & x);

          template< class CompatibleData >
          bool ``[link reference_unordered_set_of_replace_data_iterator_data replace_data]``(iterator position, const CompatibleData & x);

          template< class KeyModifier >
          bool ``[link reference_unordered_set_of_modify_key_iterator_modifier modify_key]``(iterator position, KeyModifier mod);

          template< class DataModifier >
          bool ``[link reference_unordered_set_of_modify_data_iterator_modifier modify_data]``(iterator position, DataModifier mod);

        // }


        void clear();

        // observers

        key_from_value key_extractor() const;
        hasher         hash_function() const;
        key_equal      key_eq() const;

        // lookup

        template< class CompatibleKey >
        iterator ``[link reference_unordered_set_of_find_key find]``(const CompatibleKey & x);

        template< class CompatibleKey >
        const_iterator ``[link reference_unordered_set_of_find_key find]``(const CompatibleKey & x) const;

        template< class CompatibleKey >
        size_type ``[link reference_unordered_set_of_count_key count]``(const CompatibleKey & x) const;

        template< class CompatibleKey >
        std::pair<iterator,iterator>
            ``[link reference_unordered_set_of_equal_range_key equal_range]``(const CompatibleKey & x);

        template< class CompatibleKey >
        std::pair<const_iterator,const_iterator>
            ``[link reference_unordered_set_of_equal_range_key equal_range]``(const CompatibleKey & x) const;

        // bucket interface

        size_type bucket_count() const;
        size_type max_bucket_count() const;
        size_type bucket_size(size_type n) const;
        size_type bucket(const key_type & k) const;

        local_iterator       begin(size_type n);
        const_local_iterator begin(size_type n) const;
        local_iterator       end(size_type n);
        const_local_iterator end(size_type n) const;

        // hash policy

        float load_factor() const;
        float max_load_factor() const;
        void  max_load_factor(float z);
        void  ``[link reference_unordered_set_of_rehash_size rehash]``(size_type n);

        // Only in maps views
        // {

        typedef ``['-unspecified-]`` data_type;

          // Only in for `unordered_set_of` collection type
          // {

          template<class CompatibleKey>
          const data_type & ``[link reference_unordered_set_of_at_key_const at]``(const CompatibleKey & k) const;

            // Only if the other collection type is mutable
            // {

            template<class CompatibleKey>
            data_type & ``[link reference_unordered_set_of_operator_bracket_key operator\[\]]``(const CompatibleKey & k);

            template<class CompatibleKey>
            data_type & ``[link reference_unordered_set_of_at_key at]``(const CompatibleKey & k);

            // }

            // Only if info_hook is used
            // {

            template< class CompatibleKey >
            info_type & ``[link reference_unordered_set_of_info_at_key info_at]``(const CompatibleKey & k);

            template< class CompatibleKey >
            const info_type & ``[link reference_unordered_set_of_info_at_key info_at]``(const CompatibleKey & k) const;

          // }

        // }

    };

    } // namespace views
    } // namespace bimap
    } // namespace boost



In the case of a `bimap< unordered_{multi}set_of<Left>, ... >`\n
对于 `bimap< unordered_{multi}set_of<Left>, ... >`

In the set view:\n
在集合视图中：

    typedef signature-compatible with relation<       Left, ... > key_type;
    typedef signature-compatible with relation< const Left, ... > value_type;

In the left map view:\n
在左映射视图中：

    typedef  Left  key_type;
    typedef  ...   data_type;

    typedef signature-compatible with std::pair< const Left, ... > value_type;

In the right map view:\n
在右映射视图中：

    typedef  ...  key_type;
    typedef  Left data_type;

    typedef signature-compatible with std::pair< ... ,const Left > value_type;



[#unordered_set_of_complexity_signature]

[section:complexity_signature Complexity signature 复杂度签名]

Here and in the descriptions of operations of `unordered_[multi]set_of` views,
we adopt the scheme outlined in the
[link complexity_signature_explanation complexity signature section].
The complexity signature of `unordered_[multi]set_of` view is:\n
在以下对 `unordered_[multi]set_of` 视图的操作说明中，我们采用在 [link complexity_signature_explanation 复杂度签名]
一节中给出的方式来描述。`unordered_[multi]set_of` 视图的复杂度签名为：

* copying: `c(n) = n * log(n)`,\n
  复制：`c(n) = n * log(n)`, 
* insertion: average case `i(n) = 1` (constant), worst case `i(n) = n`,\n
  插入：平均情况 `i(n) = 1` (常数)，最坏情况 `i(n) = n`，
* hinted insertion: average case `h(n) = 1` (constant), worst case `h(n) = n`,\n
  提示插入：平均情况 `h(n) = 1` (常数)，最坏情况 `h(n) = n`，
* deletion: average case `d(n) = 1` (constant), worst case `d(n) = n`,\n
  删除：平均情况 `d(n) = 1` (常数)，最坏情况 `d(n) = n`，
* replacement: \n
  替换：
    * if the new element key is equivalent to the original, `r(n) = 1` (constant),\n
      如果新元素的键值与原有相等，`r(n) = 1` (常数)， 
    * otherwise, average case `r(n) = 1` (constant), worst case `r(n) = n`,\n
      否则，平均情况 `r(n) = 1` (常数)，最坏情况 `r(n) = n`，
* modifying: average case `m(n) = 1` (constant), worst case `m(n) = n`.\n
  修改：平均情况 `m(n) = 1` (常数)，最坏情况 `m(n) = n`。

[endsect]


[section:instantiation_types Instantiation types 实例化类型]

`unordered_[multi]set_of` views are instantiated internally to `bimap`
specified by means of the collection type specifiers and the `bimap` itself.
Instantiations are dependent on the following types:\n
`unordered_[multi]set_of` 视图在一个 `bimap` 的内部根据组合类型指示符和 `bimap` 本身进行实例化。
实例化取决于以下类型：

* `Value` from `bimap`,\n
  来自 `bimap` 的 `Value`,
* `Allocator` from `bimap`,\n
  来自 `bimap` 的 `Allocator`, 
* `Hash` from the collection type specifier,\n
  来自组合类型指示符的 `Hash`，
* `Pred` from the collection type specifier.\n
  来自组合类型指示符的 `Pred`。

`Hash` is a __SGI_UNARY_FUNCTION__ taking a single argument of type
`key_type` and returning a value of type `std::size_t` in the range
`[0, std::numeric_limits<std::size_t>::max())`.
Pred is a __SGI_BINARY_PREDICATE__ inducing an equivalence relation on elements of
`key_type`. It is required that the `Hash` object return the same value for
keys equivalent under `Pred`.\n
`Hash` 是一个 __SGI_UNARY_FUNCTION__，它接受一个类型为 `key_type` 的参数，并返回一个类型为 `std::size_t`，
位于区间 `[0, std::numeric_limits<std::size_t>::max())` 的值。`Pred` 是一个 __SGI_BINARY_PREDICATE__，
它用于推断 `key_type` 元素的等价关系。要求对于 `Pred` 判断为等价的键，`Hash` 对象应返回相同值。

[endsect]

[section:nested_types Nested types 嵌套类型]

    iterator
    const_iterator
    local_iterator
    const_local_iterator

[:  These types are models of __SGI_FORWARD_ITERATOR__.
]


[endsect]

[section:constructors__copy_and_assignment Constructors, copy and assignment 构造函数、复制和赋值]

As explained in the concepts section,
views do not have public constructors or destructors. Assignment, on the other
hand, is provided.
Upon construction, `max_load_factor()` is 1.0.\n
如概念一节中所解释的，视图没有公有的构造函数和析构函数。而另一方面，赋值操作则是提供的。 
在构造时，`max_load_factor()` 为 1.0。

    this_type & operator=(const this_type & x);

* [*Effects: ] `a = b`;
where a and b are the `bimap` objects to which `*this`
and x belong, respectively.\n
  [*效果：]a = b; 其中 a 和 b 分别为 *this 和 x 所属的  bimap 对象。
* [*Returns: ] `*this.`\n
  [*返回：]`*this`. 


[endsect]

[section Modifiers]

[#reference_unordered_set_of_insert_value]

    std::pair<iterator,bool> insert(const value_type & x);

* [*Effects:] Inserts `x` into the `bimap` to which the view belongs if\n
  [*效果：]将 x 插入到集合视图所属的 bimap，如果 
    * the view is non-unique OR no other element with equivalent key exists,\n
      该集合视图为非唯一键的或者不存在相同键值的其它元素，
    * AND insertion is allowed by all other views of the `bimap`.\n
      并且，插入操作为该 `bimap` 的其它集合规格所允许。
* [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only if
insertion took place. On successful insertion, `p.first` points to the element
inserted; otherwise, `p.first` points to an element that caused the insertion to
be banned. Note that more than one element can be causing insertion not to be
allowed.\n
  [*返回：]返回值为一个值对 `p`。`p.second` 为 `true` 当且仅当插入成功。插入成功时，`p.first` 指向被插入的元素；
  否则，`p.first` 指向导致插入失败的元素。注意，可能会有一个以上的元素导致插入失败。
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(I(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(I(n)). 
* [*Exception safety:] Strong.\n
  [*异常安全性：]强。 

[#reference_unordered_set_of_insert_iterator_value]

    iterator insert(iterator position, const value_type & x);

* [*Requires: ] `position` is a valid iterator of the view.\n
  [*要求：]`position` 为视图的有效迭代器。
* [*Effects: ] `position` is used as a hint to improve the efficiency of the operation.
Inserts `x` into the `bimap` to which the view belongs if\n
  [*效果：]`position` 作为提示以提高操作的效率。将 `x` 插入到集合视图所属的 `bimap`，如果
    * the view is non-unique OR no other element with equivalent key exists,\n
      该集合视图为非唯一键的或者不存在相同键值的其它元素，
    * AND insertion is allowed by all other views of the `bimap`.\n
      并且，插入操作为该 `bimap` 的其它集合规格所允许。
* [*Returns:] On successful insertion, an iterator to the newly inserted element.
Otherwise, an iterator to an element that caused the insertion to be banned.
Note that more than one element can be causing insertion not to be allowed.\n
  [*返回：]插入成功时，返回指向新插入元素的迭代器。否则，返回指向导致插入失败的元素的迭代器。
  注意，可能会有一个以上的元素导致插入失败。
* [link unordered_set_of_complexity_signature [*Complexity:]] O(H(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(H(n)).
* [*Exception safety:] Strong.\n
  [*异常安全性：]强。 

[#reference_unordered_set_of_insert_iterator_iterator]

    template< class InputIterator>
    void insert(InputIterator first, InputIterator last);

* [*Requires: ] `InputIterator` is a model of __SGI_INPUT_ITERATOR__ over elements of type
`value_type`. `first` and `last` are not iterators into any views of the
`bimap` to which this view belongs. `last` is reachable from first.\n
  [*要求：]`InputIterator` 为 __SGI_INPUT_ITERATOR__，指向类型为 `value_type` 或可以转换为 `value_type` 的类型的元素。
  `first` 和 `last` 不是指向该索引所属 `bimap` 的任一视图的迭代器。`last` 可从 `first` 到达。
* [*Effects: ]
`iterator hint = end();`
`while(first != last) hint = insert(hint, *first++);`\n
  [*效果：]`iterator hint = end();`
`while(first != last) hint = insert(hint, *first++);`
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(m*H(n+m)), where m is the number of elements in `[first, last)`.\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(m*H(n+m))，其中 m 为 `[first, last)` 中的元素数量。
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。 

[#reference_unordered_set_of_erase_iterator]

    iterator erase(iterator position);

* [*Requires: ] `position` is a valid dereferenceable `iterator` of the view.\n
  [*要求：]`position` 为该集合视图的有效可提领 `iterator`。
* [*Effects:] Deletes the element pointed to by `position`.\n
  [*效果：]删除 `position` 所指的元素。
* [*Returns:] An `iterator` pointing to the element immediately following the one
that was deleted, or `end()` if no such element exists.\n
  [*返回：]指向紧跟在被删元素之后的元素的 `iterator`，如果不存在这样的元素，则返回 `end()`。 
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(D(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(D(n)).
* [*Exception safety:] nothrow.\n
  [*异常安全性：]无抛出。 


[#reference_unordered_set_of_erase_key]

    template< class CompatibleKey >
    size_type erase(const CompatibleKey & x);

* [*Effects:] Deletes the elements with key equivalent to `x`.\n
  [*效果：]删除所有与 `x` 等价的元素。
* [*Returns:] Number of elements deleted.\n
  [*返回：]被删元素的数量。
* [link unordered_set_of_complexity_signature
[*Complexity:]] Average case, O(1 + m*D(n)), worst case O(n + m*D(n)),
where m is the number of elements deleted.\n
  [link unordered_set_of_complexity_signature [*复杂度：]]平均情况，O(1 + m*D(n))，最坏情况 O(n + m*D(n))，其中 m 为被删元素数量。
* [*Exception safety:] Basic.\n
  [*异常安全性：]基本。 


[#reference_unordered_set_of_erase_iterator_iterator]

    iterator erase(iterator first, iterator last);

* [*Requires: ] `[first,last)` is a valid range of the view.\n
  [*要求：]`[first,last)` 为视图的有效区间。
* [*Effects:] Deletes the elements in `[first,last)`.\n
  [*效果：]删除 `[first,last)` 中所有元素。
* [*Returns: ] `last`.\n
  [*返回：]`last`.
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(m*D(n)), where m is the number of elements in `[first,last)`.\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(m*D(n))，其中 m 为 `[first,last)` 中的元素数量。
* [*Exception safety:] nothrow.\n
  [*异常安全性：]无抛出。 


[#reference_unordered_set_of_replace_iterator_value]

    bool replace(iterator position, const value_type & x);

* [*Requires: ] `position` is a valid dereferenceable `iterator` of the view.\n
  [*要求：]`position` 为该集合视图的有效可提领 `iterator`。
* [*Effects:] Assigns the value `x` to the element pointed to by `position` into
the `bimap` to which the view belongs if, for the value `x`\n
  [*效果：]将值 `x` 赋给 `position` 所指的元素，如果对于值 `x`
    * the view is non-unique OR no other element with equivalent key exists
(except possibly `*position`),\n
      该集合视图为非唯一键的或者不存在相同键值的其它元素(除 `*position` 以外)，
    * AND replacing is allowed by all other views of the `bimap`.\n
      并且，替换操作为该 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of position is preserved in all cases.\n
  [*后置条件：]在所有情形下，position 的有效性被保持。
* [*Returns: ] `true` if the replacement took place, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。 
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(R(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(R(n)).
* [*Exception safety:] Strong. If an exception is thrown by some user-provided
operation the `bimap` to which the view belongs remains in its original state.\n
  [*异常安全性：]强。如果用户提供的某个操作抛出异常，则集合视图所属的 `bimap` 将保持原有状态。 


[#reference_unordered_set_of_replace_key_iterator_key]

    template< class CompatibleKey >
    bool replace_key(iterator position, const CompatibleKey & x);

* [*Requires: ] `position` is a valid dereferenceable iterator of the set view.
`CompatibleKey` can be assigned to `key_type`.\n
  [*要求：]`position` 为该集合视图的有效可提领迭代器。`CompatibleKey` 可以被赋值给 `key_type`.
* [*Effects:] Assigns the value `x` to `e.first`, where `e` is the element pointed 
to by `position` into the `bimap` to which the set view belongs if,\n
  [*效果：]将值 `x` 赋给 `e.first`，其中 `e` 为 `position` 所指的元素，如果
    * the map view is non-unique OR no other element with equivalent key exists
(except possibly `*position`),\n
      该集合视图为非唯一键的或者不存在相同键值的其它元素(除 `*position` 以外)，
    * AND replacing is allowed by all other views of the `bimap`.\n
      并且，替换操作为该 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of position is preserved in all cases.\n
  [*后置条件：]在所有情形下，position 的有效性被保持。
* [*Returns: ] `true` if the replacement took place, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(R(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(R(n)).
* [*Exception safety:] Strong. If an exception is thrown by some user-provided
operation, the `bimap` to which the set view belongs remains in
its original state.\n
  [*异常安全性：]强。如果用户提供的某个操作抛出异常，则集合视图所属的 `bimap` 将保持原有状态。 


[#reference_unordered_set_of_replace_data_iterator_data]

    template< class CompatibleData >
    bool replace_data(iterator position, const CompatibleData & x);

* [*Requires: ] `position` is a valid dereferenceable iterator of the set view.
`CompatibleKey` can be assigned to `data_type`.\n
  [*要求：]`position` 为该集合视图的有效可提领迭代器。`CompatibleKey` 可以被赋值给 `data_type`. 
* [*Effects:] Assigns the value `x` to `e.second`, where `e` is the element pointed 
to by `position` into the `bimap` to which the set view belongs if,\n
  [*效果：]将值 `x` 赋给 `e.second`，其中 `e` 为 `position` 所指的元素，如果
    * the map view is non-unique OR no other element with equivalent key exists
(except possibly `*position`),\n
      该集合视图为非唯一键的或者不存在相同键值的其它元素(除 `*position` 以外)， 
    * AND replacing is allowed by all other views of the `bimap`.\n
      并且，替换操作为该 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of position is preserved in all cases.\n
  [*后置条件：]在所有情形下，position 的有效性被保持。
* [*Returns: ] `true` if the replacement took place, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(R(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(R(n)).
* [*Exception safety:] Strong. If an exception is thrown by some user-provided
operation, the `bimap` to which the set view belongs remains in
its original state.\n
  [*异常安全性：]强。如果用户提供的某个操作抛出异常，则集合视图所属的 bimap 将保持原有状态。 


[#reference_unordered_set_of_modify_key_iterator_modifier]

    template< class KeyModifier >
    bool modify_key(iterator position, KeyModifier mod);

* [*Requires: ] `KeyModifier` is a model of __SGI_UNARY_FUNCTION__ accepting arguments of
type: `key_type&`; `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]`KeyModifier` 是一个 __SGI_UNARY_FUNCTION__，它接受的参数类型为 `key_type&`; `position` 为该集合视图的有效可提领迭代器。
* [*Effects:] Calls `mod(e.first)` where e is the element pointed to by position and 
rearranges `*position` into all the views of the `bimap`.
If the rearrangement fails, the element is erased.
Rearrangement is successful if\n
  [*效果：]调用 `mod(e.first)`，其中 `e` 是 `position` 所指元素，对 `*position` 在 `bimap` 的所有视图中重排。
  如果重排失败，该元素将被删除。重排将成功，如果满足
    * the map view is non-unique OR no other element with equivalent key exists,\n
      该集合视图为非唯一键的或者不存在相同键值的其它元素，
    * AND rearrangement is allowed by all other views of the `bimap`.\n
      并且，重排操作为该 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of `position` is preserved if the operation succeeds.\n
  [*后置条件：]如果操作成功，则 `position` 的有效性被保持。
* [*Returns: ] `true` if the operation succeeded, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(M(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(M(n)).
* [*Exception safety:] Basic. If an exception is thrown by some user-provided
operation (except possibly mod), then the element pointed to by position is erased.\n
  [*异常安全性：]基本。如果用户提供的某个操作(除 mod 以外)抛出异常，则 position 所指元素被删除。
* [*Note:] Only provided for map views.  \n
  [*注：]仅对映射视图提供。


[#reference_unordered_set_of_modify_data_iterator_modifier]

    template< class DataModifier >
    bool modify_data(iterator position, DataModifier mod);

* [*Requires: ] `DataModifier` is a model of __SGI_UNARY_FUNCTION__ accepting arguments of
type: `data_type&`; `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]`DataModifier` 是一个 __SGI_UNARY_FUNCTION__，它接受的参数类型为 `data_type&`; `position` 为该集合视图的有效可提领迭代器。
* [*Effects:] Calls `mod(e.second)` where e is the element pointed to by position and 
rearranges `*position` into all the views of the `bimap`.
If the rearrangement fails, the element is erased.
Rearrangement is successful if\n
  [*效果：]调用 `mod(e.second)`，其中 `e` 是 `position` 所指元素，对 `*position` 在 `bimap` 的所有视图中重排。
  如果重排失败，该元素将被删除。重排将成功，如果满足
    * the oppositte map view is non-unique OR no other element with equivalent key in that
view exists,\n
      该集合视图为非唯一键的或者不存在相同键值的其它元素，
    * AND rearrangement is allowed by all other views of the `bimap`.\n
      并且，重排操作为该 `bimap` 的其它视图所允许。
* [*Postconditions:] Validity of `position` is preserved if the operation succeeds.\n
  [*后置条件：]如果操作成功，则 `position` 的有效性被保持。
* [*Returns: ] `true` if the operation succeeded, `false` otherwise.\n
  [*返回：]`true` 如果替换成功，否则返回 `false`。
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(M(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]O(M(n)).
* [*Exception safety:] Basic. If an exception is thrown by some user-provided
operation (except possibly mod), then the element pointed to by position is erased.\n
  [*异常安全性：]基本。如果用户提供的某个操作(除 mod 以外)抛出异常，则 position 所指元素被删除。 
* [*Note:] Only provided for map views.\n
  [*注：]仅对映射视图提供。

[/
[#reference_unordered_set_of_modify_iterator_modifier]

    template< class Modifier>
    bool modify(iterator position, Modifier mod);

* [*Requires: ] `Modifier` is a model of __SGI_BINARY_FUNCTION__ accepting arguments of
type: `first_type&` and `second_type&` for ['Map View] or `left_type&` and `right_type&`
for ['Set View]; `position` is a valid dereferenceable iterator of the view.\n
  [*要求：]
* [*Effects:] Calls `mod(e.first,e.second)` for ['Map View:] or calls `mod(e.left,e.right)`
for ['Set View] where `e` is the element pointed to by `position` and
rearranges `*position` into all the views of the `bimap`.
If the rearrangement fails, the element is erased.
Rearrangement is successful if\n
  [*效果：]
    * the view is non-unique OR no other element with equivalent key exists,
    * AND rearrangement is allowed by all other views of the `bimap`.
* [*Postconditions:] Validity of position is preserved if the operation succeeds.\n
  [*后置条件：]
* [*Returns: ] `true` if the operation succeeded, `false` otherwise.\n
  [*返回：]
* [link unordered_set_of_complexity_signature
[*Complexity:]] O(M(n)).\n
  [link unordered_set_of_complexity_signature [*复杂度：]]
* [*Exception safety:] Basic. If an exception is thrown by some user-provided
operation (except possibly `mod`), then the element pointed to by `position` is erased.\n
  [*异常安全性：]。 
/]

[endsect]

[section:lookup Lookup 查找]

`unordered_[multi]set_of` views provide the full lookup functionality required by unordered
associative containers, namely `find`, `count`, and `equal_range`. Additionally,
these member functions are templatized to allow for non-standard arguments,
so extending the types of search operations allowed. The kind of arguments
permissible when invoking the lookup member functions is defined by the
following concept.\n
`unordered_[multi]set_of` 视图提供了无序关联式容器所要求的所有查找功能，如 `find`, `count` 和 `equal_range`。
另外，这些成员函数是模板化的，允许使用非标准参数，所以也可以扩展查找操作的类型。
只要调用这些查找成员函数的参数种类按以下概念定义，就是可允许的。

[/
Consider a pair `(Hash, Pred)` where `Hash` is a hash functor over values of type
`Key` and `Pred` is a __SGI_BINARY_PREDICATE__ inducing an equivalence relation on `Key`,
with the additional constraint that equivalent keys have the same hash value.
A triplet of types `(CompatibleKey, CompatibleHash, CompatiblePred)` is said to
be a ['compatible extension] of `(Hash, Pred)` if

* `CompatibleHash` is a hash functor on values of type `CompatibleKey`,
* `CompatiblePred` is a __SGI_BINARY_PREDICATE__ over `(Key, CompatibleKey)`,
* `CompatiblePred` is a __SGI_BINARY_PREDICATE__ over `(CompatibleKey, Key)`,
* if `c_eq(ck,k1)` then `c_eq(k1,ck)`,
* if `c_eq(ck,k1)` and `eq(k1,k2)` then `c_eq(ck,k2)`,
* if `c_eq(ck,k1)` and `c_eq(ck,k2)` then `eq(k1,k2)`,
* if `c_eq(ck,k1)` then `c_hash(ck)==hash(k1)`,

for every `c_hash` of type `CompatibleHash`, `c_eq` of type `CompatiblePred`, hash of
type `Hash`, `eq` of type `Pred`, `ck` of type `CompatibleKey` and `k1`, `k2` of type `Key`.
]

A type `CompatibleKey` is said to be a ['compatible key] of `(Hash, Pred)`
if `(CompatibleKey, Hash, Pred)` is a compatible extension of `(Hash, Pred)`. This
implies that `Hash` and `Pred` accept arguments of type `CompatibleKey`, which usually
means they have several overloads of their corresponding `operator()` member
functions.\n
类型 `CompatibleKey` 被称为 `(Hash, Pred)` 的['兼容键]，如果 `(CompatibleKey, Hash, Pred)` 是 `(Hash, Pred)` 的一个兼容扩展。
这意味着 `Hash` 和 `Pred` 可以接受类型为 `CompatibleKey` 的参数，通常这表示会有几个 `operator()` 成员函数的重载。

[/
In the context of a compatible extension or a compatible key, the expression
"equivalent key" takes on its obvious interpretation.
]

[#reference_unordered_set_of_find_key]

    template< class CompatibleKey >
    iterator find(const CompatibleKey & x);

    template< class CompatibleKey >
    const_iterator find(const CompatibleKey & x) const;

* [*Effects:] Returns a pointer to an element whose key is equivalent to `x`,
or `end()` if such an element does not exist.\n
  [*效果：]返回一个指向其键值等价于 `x` 的元素的指针，如果不存在这样的元素，则返回 `end()`。 
* [*Complexity:] Average case O(1) (constant), worst case O(n).\n
  [*复杂度：]平均情况 O(1) (常数)，最坏情况 O(n)。 


[#reference_unordered_set_of_count_key]

    template< class CompatibleKey >
    size_type count(const CompatibleKey & x) const;

* [*Effects:] Returns the number of elements with key equivalent to `x`.\n
  [*效果：]返回键值等价于 `x` 的元素数量。
* [*Complexity:] Average case O(count(x)), worst case O(n).\n
  [*复杂度：]平均情况 O(count(x))，最坏情况 O(n)。 


[#reference_unordered_set_of_equal_range_key]

    template< class CompatibleKey >
    std::pair<iterator,iterator>
        equal_range(const CompatibleKey & x);

    template< class CompatibleKey >
    std::pair<const_iterator,const_iterator>
        equal_range(const CompatibleKey & x) const;

* [*Effects:] Returns a range containing all elements with keys equivalent
to `x` (and only those).\n
  [*效果：]返回一个包含键值等价于 `x` 的所有元素(且只有这些元素)的区间。
* [*Complexity:] Average case O(count(x)), worst case O(n).\n
  [*复杂度：]平均情况 O(count(x))，最坏情况 O(n)。 



[endsect]

[section at(), info_at() and operator\[\] - set_of only]


[#reference_unordered_set_of_at_key_const]

    template< class CompatibleKey >
    const data_type & at(const CompatibleKey & k) const;

* [*Requires: ] `CompatibleKey` is a compatible key of `key_compare`.\n
  [*要求：]`CompatibleKey` 是 `key_compare` 的一个兼容键。
* [*Effects:] Returns the `data_type` reference that is associated with `k`, or
throws `std::out_of_range` if such key does not exist.\n
  [*效果：]返回与 `k` 相关联的 `data_type` 引用，或者如果不存在这样的键值，则抛出 `std::out_of_range`。
* [*Complexity:] Average case O(1) (constant), worst case O(n).\n
  [*复杂度：]平均情况 O(1) (常数)，最坏情况 O(n)。
* [*Note:] Only provided when `unordered_set_of` is used.\n
  [*注：]仅当使用 `unordered_set_of` 时提供。

The symmetry of bimap imposes some constraints on `operator[]` and the 
non constant version of at() that are not found in `std::maps`.
Tey are only provided if the other collection type is mutable
(`list_of`, `vector_of` and `unconstrained_set_of`).\n
`bimap` 的对称性对 `operator[]` 有所约束，而且在 `std::maps` 中没有非常量版本的 `at()`。
这些函数仅在其它组合类型为可修改(`list_of`, `vector_of` 和 `unconstrained_set_of`)时提供。


[#reference_unordered_set_of_operator_bracket_key]

    template< class CompatibleKey >
    data_type & operator[](const CompatibleKey & k);

* [*Requires: ] `CompatibleKey` is a compatible key of `key_compare`.\n
  [*要求：]`CompatibleKey` 是 `key_compare` 的一个兼容键。
* [*Effects: ] `return insert(value_type(k,data_type()))->second;`\n
  [*效果：]`return insert(value_type(k,data_type()))->second;`
* [*Complexity:] If the insertion is performed O(I(n)), else: Average case
O(1) (constant), worst case O(n).\n
  [*复杂度：]如果执行了插入，则 O(I(n))，否则：插入平均情况 O(1) (常数)，最坏情况 O(n)。 
* [*Note:] Only provided when `unordered_set_of` is used and the other collection
type is mutable.\n
  [*注：]。仅当使用 `unordered_set_of` 且其它组合类型为可修改时提供。


[#reference_unordered_set_of_at_key]

    template< class CompatibleKey >
    data_type & at(const CompatibleKey & k);

* [*Requires: ] `CompatibleKey` is a compatible key of `key_compare`.\n
  [*要求：]`CompatibleKey` 是 `key_compare` 的一个兼容键。
* [*Effects: ] Returns the `data_type` reference that is associated with `k`, or
throws `std::out_of_range` if such key does not exist.\n
  [*效果：]返回与 `k` 相关联的 `data_type` 引用，或者如果不存在这样的键值，则抛出 `std::out_of_range`。
* [*Complexity:] Average case O(1) (constant), worst case O(n).\n
  [*复杂度：]平均情况 O(1) (常数)，最坏情况 O(n)。
* [*Note:] Only provided when `unordered_set_of` is used and the other collection
type is mutable.\n
  [*注：]仅当使用 `unordered_set_of` 且其它组合类型为可修改时提供。

[/

The symmetry of bimap imposes some constraints to the `operator[]` that are not
found in `std::maps`.
If other views are unique, `bimap::duplicate_value` is thrown whenever an assignment is
attempted to a value that is already a key in this views.
As for bimap::value_not_found, this exception is thrown while trying to access
a non-existent key: this behavior differs from that of std::map, which automatically
assigns a default value to non-existent keys referred to by `operator[]`.

    const data_type & operator[](const typename key_type & k) const;

* [*Effects:] Returns the `data_type` reference that is associated with `k`, or
throws `bimap::value_not_found` if such an element does not exist.\n
  [*效果：]
* [*Complexity:] O(log(n)).\n
  [*复杂度：]


    ``['-unspecified data_type proxy-]`` operator[](const typename key_type & k);

* [*Effects:] Returns a proxy to a `data_type` associated with `k` and the
bimap. The proxy behaves as a reference to the `data_type` object. If this
proxy is read and `k` was not in the bimap, the bimap::value_not_found is
thrown. If it is written then `bimap::duplicate_value` is thrown if the
assignment is not allowed by one of the other views of the `bimap`.\n
  [*效果：]
* [link unordered_set_of_complexity_signature
[*Complexity:]] If the assignment operator of the proxy is not used, then
the order is O(log(n)). If it is used, the order is O(I(n)) if `k` was not
in the bimap and O(R(n)) if it existed in the bimap.\n
  [link unordered_set_of_complexity_signature [*复杂度：]]

]

[#reference_unordered_set_of_info_at_key]

    template< class CompatibleKey >
    info_type & info_at(const CompatibleKey & k);

    template< class CompatibleKey >
    const info_type & info_at(const CompatibleKey & k) const;

* [*Requires: ] `CompatibleKey` is a compatible key of `key_compare`.\n
  [*要求：]`CompatibleKey` 是 `key_compare` 的一个兼容键。
* [*Effects:] Returns the `info_type` reference that is associated with `k`, or
throws `std::out_of_range` if such key does not exist.\n
  [*效果：]返回与 `k` 相关联的 `info_type` 引用，或者如果不存在这样的键值，则抛出 `std::out_of_range`。
* [*Complexity:] Average case O(1) (constant), worst case O(n).\n
  [*复杂度：]平均情况 O(1) (常数)，最坏情况 O(n)。 
* [*Note:] Only provided when `unordered_set_of` and `info_hook` are used\n
  [*注：]仅当使用 `unordered_set_of` 和 `info_hook` 时提供。


[endsect]

[section:hash_policy Hash policy 散列策略]


[#reference_unordered_set_of_rehash_size]

    void rehash(size_type n);

* [*Effects:] Increases if necessary the number of internal buckets so that
`size()/bucket_count()` does not exceed the maximum load factor, and
`bucket_count()>=n`.\n
  [*效果：]如果有必要，则增加内部桶的数量，使得 `size()/bucket_count()` 不超过最大负载因子，且 `bucket_count()>=n`。
* [*Postconditions:] Validity of iterators and references to the elements
contained is preserved.\n
  [*后置条件：]迭代器及元素引用的有效性被保持。
* [*Complexity:] Average case O(size()), worst case O(size(n)2).\n
  [*复杂度：]平均情况 O(size())，最坏情况 O(size(n)2)。 
* [*Exception safety:] Strong.\n
  [*异常安全性：]强。 


[endsect]

[section:serialization Serialization 序列化]

Views cannot be serialized on their own, but only as part of the
`bimap` into which they are embedded. In describing the
additional preconditions and guarantees associated to `unordered_[multi]set_of` views
with respect to serialization of their embedding containers, we use
the concepts defined in the `bimap` serialization section.\n
视图不能被它们自己序列化，只能作为它们所嵌的 bimap 的一部分。
在描述与所嵌容器的 `unordered_[multi]set_of` 视图相关的其它前提条件和保证时，
我们使用在 `bimap` 序列化一节中所定义的概念。

[blurb [*Operation:] saving of a `bimap` b to an output archive
(XML archive) ar.\n
[*操作：]保存一个 `bimap` b 到一个输出存档(XML 存档) ar 中。]

* [*Requires:] No additional requirements to those imposed by the container.\n
  [*要求：]除了对容器的要求以外，没有其它要求。


[blurb [*Operation:] loading of a `bimap` b' from an input
archive (XML archive) ar.\n
[*操作：]从一个输入存档(XML 存档) ar 中导入一个 `bimap` b' 。]

* [*Requires:] Additionally to the general requirements, `key_eq()` must
be serialization-compatible with `m.get<i>().key_eq()`, where i is the
position of the `unordered_[multi]set_of` view in the container.\n
  [*要求：]除了通常的要求以外，`key_eq()` 还必须序列化兼容于 `m.get<i>().key_eq()`，
  其中 `i` 为该 `unordered_[multi]set_of` 视图在容器中的位置。
* [*Postconditions:] On successful loading, the range `[begin(), end())`
contains restored copies of every element in
`[m.get<i>().begin(), m.get<i>().end())`, though not necessarily in
the same order.\n
  [*后置条件：]成功导入后，在 `[begin(), end())` 中的每个元素为 `[m.get<i>().begin(), m.get<i>().end())` 中各相应元素的恢复后拷贝，
  但是顺序不一定相同。


[blurb  [*Operation:] saving of an `iterator` or `const_iterator` `it` to an output
archive (XML archive) ar.\n
[*操作：]保存一个 `iterator` 或 `const_iterator` `it` 到一个输出存档(XML 存档) ar 中。]

* [*Requires: ] `it` is a valid `iterator` of the view. The associated
`bimap` has been previously saved.\n
  [*要求：]`it` 为视图的有效 `iterator`。相关联的 `bimap` 已经被保存。


[blurb [*Operation:] loading of an iterator or `const_iterator it`' from an
input archive (XML archive) ar.\n
[*操作：]从一个输入存档(XML 存档) ar 中导入一个 `iterator` 或 `const_iterator it`' 。]

* [*Postconditions:] On successful loading, if `it` was dereferenceable then
`*it`' is the restored copy of `*it`, otherwise `it`'` == end()`.\n
  [*后置条件：]成功导入后，如果 `it` 是可提领的，则 `*it`' 为 `*it` 的恢复后拷贝，否则 `it' == end()`. 
* [*Note:] It is allowed that `it` be a `const_iterator` and the restored
`it`' an `iterator`, or viceversa.\n
  [*注：]允许 `it` 是一个 `const_iterator`，而恢复后的 `it`' 为一个 `iterator`，反之亦然。


[blurb [*Operation:] saving of a local_iterator or const_local_iterator it
to an output archive (XML archive) ar.\n
[*操作：]保存一个 `local_iterator` 或 `const_local_iterator` `it` 到一个输出存档(XML 存档) ar 中。]

* [*Requires: ] `it` is a valid local iterator of the view. The associated
`bimap` has been previously saved.\n
  [*要求：]`it` 为视图的有效迭代器。相关联的 `bimap` 已经被保存。


[blurb [*Operation:] loading of a `local_iterator` or `const_local_iterator`
`it`' from an input archive (XML archive) ar.\n
[*操作：]从一个输入存档(XML 存档) ar 中导入一个 `local_iterator` 或 `const_local_iterator` `it`' 。]

* [*Postconditions:] On successful loading, if `it` was dereferenceable then
`*it`' is the restored copy of `*it`; if `it` was `m.get<i>().end(n)` for some n,
then `it`'` == m`'`.get<i>().end(n)` (where `b` is the original `bimap`,
`b`' its restored copy and `i` is the ordinal of the index.)\n
  [*后置条件：]成功导入后，如果 `it` 是可提领的，则 `*it`' 为 `*it` 的恢复后拷贝；
  如果 `it` 对于某些 n 是 `m.get<i>().end(n)`，则 `it`'` == m`'`.get<i>().end(n)` 
  (其中 `b` 是原始 `bimap`, `b`' 为其恢复后拷贝且 `i` 是索引序数)。 
* [*Note:] It is allowed that `it` be a `const_local_iterator` and the restored
`it`' a `local_iterator`, or viceversa.\n
  [*注：]允许 `it` 是一个 `const_local_iterator`，而恢复后的 `it`' 为一个 `local_iterator`，反之亦然。


[endsect]
[endsect]

[endsect]
[library Boost.TR1
    [quickbook 1.4]
    [copyright 2005 John Maddock]
    [purpose An implementation of the C++ Technical Report on Standard Library Extensions]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])]
    [authors [Maddock, John]]
    [category misc]
    [last-revision $Date: 2009-02-04 10:53:20 -0500 (Wed, 04 Feb 2009) $]
]

[section:intro Introduction 简介]
The TR1 library provides an implementation of the C++ Technical Report on Standard Library Extensions.
This library does not itself implement the TR1 components, rather it's a thin wrapper that will 
include your standard library's TR1 implementation (if it has one), otherwise it will include the Boost
Library equivalents, and import them into namespace `std::tr1`.\n
本 TR1 库提供了对关于标准库扩展的 C++ Technical Report 的一个实现。本库本身并没有实现 TR1 的组件，而只是一个简单的包装器，
它包含了你的标准库的 TR1 实现(如果有)，或者包含了 Boost 库中的等价物，并将它们导入到名字空间 `std::tr1` 中。

[endsect]

[section:usage Usage 用法]
There are two things you need to decide before using the Boost.TR1 library: 
whether to use your standard library's native TR1 implementation (if it has one),
and which include style to use.\n
在使用 Boost.TR1 库之前，有两件事情你必须要决定：是否使用你的标准库中的原生 TR1 实现(如果有的话)，以及使用哪一种头文件包含风格。

[section:native Whether to use Your Native TR1 Library 是否使用原生的TR1库]
If your standard library implements the TR1, and you want to make
use of it, rather than use the Boost equivalents, then you will need to
take some explicit action to enable it: this may be a pre-processor
define, a special compiler switch, or a different include path.
You will need to consult your compilers documentation to find out 
which of these
actions you need to take.\n
如果你的标准库实现了 TR1，而你也想使用它，而不是使用 Boost 的等价物，那么你就需要一些动作来使用它：
这些动作可能是一个预处理器的定义，可能是一个特定的编译器开关，或者是一个不同的包含路径。
你需要查看你的编译器文档，找到你需要做的相应动作。

Provided Boost is [link boost_tr1.config correctly configured], 
everything should
now "just work", and code written to use Boost.TR1 will include
your standard library's native headers rather than the Boost ones.\n
已提供的 Boost 是 [link boost_tr1.config 正确配置的]，所有东西都是"可以立即使用"的，为使用 
Boost.TR1 所编写的代码将包含你的标准库中的原生头文件而不是 Boost 的头文件。

[endsect]

[section:include_style Header Include Style 头文件包含风格]

There are two ways you can include the Boost.TR1 headers, 
for example if you are interested in shared_ptr then you can either use:\n
你有两种方法来包含 Boost.TR1 头文件，例如，如果你想用 shared_ptr，则你可以写：

   #include <boost/tr1/memory.hpp>
   
or:\n
或者：

   #include <memory>
   
The first option is the preferred method for other Boost libraries
to use.  The second option is standard-conforming, but requires that you
add `boost-install-path/boost/tr1/tr1` to your compiler's include search path.  
Note that you must not copy the headers in boost/tr1/tr1 into a directory
called "include", doing so will cause them to cease working.\n
在其它 Boost 库中使用时，第一种方式是首选的方法。
第二种方式则是符合标准的，不过要求你将 `boost-install-path/boost/tr1/tr1` 添加到你的编译器的头文件查找路径中。
注意，你不能将 boost/tr1/tr1 中的头文件复制到 "include" 目录下，那样做会使得它们无法工作。

[blurb [*Important Note 重要说明 #1]

The include path order is very important if you want this library to work 
correctly.  If you get compiler errors then suspect the include paths.  The
correct order is:\n
包含路径的顺序是很重要的，如果你想这个库工作正常。如果你的编译出现错误则应怀疑是否包含路径的原因。正确的顺序是：

1) boost-root/boost/tr1/tr1\n
2) boost-root\n
3) Any other standard library replacements (STLport for example).\n
   任何其它标准库的替代品(如 STLport)。\n
4) Your regular standard library.\n
   你的常规标准库。\n
]

[blurb [*Important Note 重要说明 #2: GNU C++ Users]

Normally this library should "just work" with the GNU C++ compiler.\n
通常这个库是 "可以用于" GNU C++ 编译器的。

However, if Boost is installed in `/usr/include` then you may get an error
message of the form:\n
不过，如果 Boost 被安装在 `/usr/include` 路径下，则你可能会得到以下错误信息：

``In file included from /usr/include/boost/tr1/tuple.hpp:5,
                 from boost-failure.cxx:1:
/usr/include/boost/tr1/detail/config.hpp:60:26: error: no include path in which to search for utility``

In this case try defining the macro `BOOST_TR1_DISABLE_INCLUDE_NEXT` when building,
and if that doesn't work, define the macro `BOOST_TR1_GCC_INCLUDE_PATH` to the 
name of the directory containing gcc's include files: this is likely to be 
something like "g++-v4" but unfortunately varies from distribution 
to distribution.\n
这时请尝试在构建时定义宏 `BOOST_TR1_DISABLE_INCLUDE_NEXT`，如果还不能使用，则将宏 `BOOST_TR1_GCC_INCLUDE_PATH` 
定义为 gcc 头文件所在的路径：这有点象 "g++-v4" 但是在各种发布间有所不同。
]

[blurb [*Important Note 重要说明 #3: Borland C++ Users]

Borland's compiler has a particularly broken form of `#include`, that
will actually look for a file named `array.h` if you `#include <array>`.
In order to make this library work with Borland's compiler you will need to
set up the include paths as follows:\n
Borland 的编译器具有特定的有问题的 `#include` 格式，如果你写 `#include <array>`，则它实际会查找名为 `array.h` 的文件。
为了让本库可以用于 Borland 的编译器，你需要将包含路径设置如下：

1) boost-root/boost/tr1/tr1/bcc32\n
2) boost-root/boost/tr1/tr1\n
3) boost-root\n
4) Any other standard library replacements (STLport for example).\n
   任何其它标准库的替代品(如 STLport)。\n
5) Your regular standard library.\n
   你的常规标准库。\n
]

[blurb [*Important Note 重要说明 #4: Sun C++ Users]

Sun's compiler has a particularly interesting form of `#include`, that
will actually look for a file named `array.SUNWCCh` if you `#include <array>`.
What's more it won't include a standard header file that it thinks it's
already seen.
In order to make this library work with Sun's compiler you can either
pass the undocumented compiler switch ['"-Qoption ccfe -nosunwcch"] to
the compiler, or else you will need to
set up the include paths as follows:\n
Sun 的编译器具有特别形式的 `#include`, 如果你写 `#include <array>`，则它实际会查找名为 `array.SUNWCCh` 的文件。
更重要的是它不会包含它认为已见到的标准头文件。为了让本库可以用于 Sun 的编译器，你要么对编译器使用未公开的编译开关 
['"-Qoption ccfe -nosunwcch"]，要么将包含路径设置如下：

1) boost-root/boost/tr1/tr1/sun\n
2) boost-root/boost/tr1/tr1\n
3) boost-root\n
4) Any other standard library replacements (STLport for example).\n
   任何其它标准库的替代品(如 STLport)。\n
5) Your regular standard library.\n
   你的常规标准库。\n
]

[endsect]

[section:writing_code Writing Code 编写代码]

Regardless of how the includes are setup, user code written to work 
with Boost.TR1 is exactly the same as code written to use a native 
tr1 implementation.  That is, references to classes and functions
need to explicitly use the `std::tr1` namespace or a `using std::tr1`
statement.  For example, \n
无论如何设置头文件包含路径，编写使用 Boost.TR1 的用户代码与编写使用原生 tr1 实现的代码是一样的。
即，对类和函数的引用必须显式使用 `std::tr1` 名字空间或 使用一个 `using std::tr1` 语句。例如：

   std::tr1::tuple<int, std::string> t = std::tr1::make_tuple(10, "hello");

or\n
或

  using std::tr1;
  tuple<int, std::string> t = make_tuple(10, "hello");


[endsect]


[endsect]

[section:config Configuration 配置]

Configuring Boost.TR1 is no different to configuring any other part of
Boost; in the majority of cases you shouldn't actually need to do anything at all.
However, because Boost.TR1 will inject Boost components into namespace std::tr1
it is more than usually sensitive to an incorrect configuration.\n
配置 Boost.TR1 和配置 Boost 的其它库没什么不同；多数情况下，你不需要做任何动作。
不过，由于 Boost.TR1 要将 Boost 组件注入到名字空间 std::tr1 中，所以它对于不正确的配置通常会更为敏感。

The intention is that 
[@../../libs/config/index.html Boost.Config] 
will automatically define the configuration
macros used by this library, so that if your standard library is set up to
support TR1 (note that few are at present) then this will be detected and Boost.TR1
will use your standard library versions of these components rather than the 
Boost ones.\n
我们的意图是，[@../../libs/config/index.html Boost.Config] 可以自动定义那些本库要使用的配置宏，因此如果你的标准库是支持 
TR1 的(注意当前只有很少标准库可以)，那么这会被检测出来且 Boost.TR1 会使用你的标准库中的组件而不是使用 Boost 的。

If you would prefer to use the Boost versions of the TR1 conponents rather than
your standard library, then either: include the Boost headers directly\n
如果你想使用 Boost 版本的 TR1 组件而不是标准库的，则要么直接包含 Boost 的头文件：

   #include <boost/regex.hpp>
   
   boost::regex e("myregex"); //etc
   
Or else don't enable TR1 in your standard library: since TR1 is not part of
the current standard, there should be some option to disable it in your
compiler or standard library.\n
要么在你的标准库中不要打开 TR1: 由于 TR1 不是当前标准的一部分，所以在你的编译器或标准库中应该有选项来关闭它。

The configuration macros used by each TR1 component are documented in each
library section (and all together in the 
[@../../libs/config/index.html Boost.Config] 
documentation), but defining BOOST_HAS_TR1 will turn on native TR1 support
for everything (if your standard library has it), which can act as a 
convenient shortcut.\n
每个 TR1 组件所使用的配置宏在各自的章节进行介绍(并且全部收录在 [@../../libs/config/index.html Boost.Config] 
的文档中)，而定义 BOOST_HAS_TR1 将打开所有原生 TR1 的支持(如果你的标准库中具备)，这可以作为方便使用的方式。

[blurb [*Note for gcc users 对于 gcc 用户的说明]\n\n
Boost.TR1 does not currently enable gcc's native TR1 implementation
as this is currently in an early stage of development.  However, you may
choose to do so by defining BOOST_HAS_GCC_TR1.\n
Boost.TR1 当前不能打开 gcc 的原生 TR1 实现，因为它尚处于开发的初期阶段。不过，你可以通过定义 BOOST_HAS_GCC_TR1 来使用它。]

[endsect]

[section:subject_list TR1 By Subject TR1 的分类]

[section:ref Reference Wrappers. 引用包装器]
   
   #include <boost/tr1/functional.hpp>

or\n
或

   #include <functional>
   
The Ref library is a small library that is useful for passing
references to function templates (algorithms) that would usually
take copies of their arguments. It defines the class template
`reference_wrapper<T>`,
and the two functions
`ref` and `cref` that return
instances of `reference_wrapper<T>`.
[@../../doc/html/ref.html Refer to Boost.Bind for more information.]\n
Ref 库是一个小库，用于将引用传递给通常要对参数进行复制的函数模板(算法)。它定义了类模板 `reference_wrapper<T>`, 以及返回 
`reference_wrapper<T>` 实例的两个函数 `ref` 和 `cref`. [@../../doc/html/ref.html 更多信息请参见 Boost.Bind.] 

   namespace std {
   namespace tr1 {

   template <class T> class reference_wrapper;

   template <class T> reference_wrapper<T> ref(T&);
   template <class T> reference_wrapper<const T> cref(const T&);
   template <class T> reference_wrapper<T> ref(reference_wrapper<T>);
   template <class T> reference_wrapper<const T> cref(reference_wrapper<T>);

   } // namespace tr1
   } // namespace std

[*Configuration: ] 
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_REFERENCE_WRAPPER if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_REFERENCE_WRAPPER，如果你的标准库实现了这部分 TR1.

[*Standard Conformity:]
The Boost version of this this component does not currently support
function call invocation (2.1.2.4), or derivation from std::unary_function 
or std::binary_function (2.1.2 paragraphs 3 and 4).\n
[*标准符合性：]
这一组件的 Boost 版本当前不支持函数调用(2.1.2.4)，或是从 std::unary_function 或 std::binary_function 派生(2.1.2 第 3 段和第 4 段)。 

The Boost version is not implicitly convertible to T& as the TR requires.\n
Boost 版本不能象 TR 要求的那样提供到 T& 的隐式转换。

[endsect]

[section:ptrs Smart Pointers. 智能指针]

   #include <boost/tr1/memory.hpp>

or\n
或

   #include <memory>

The `shared_ptr` class template stores a pointer to a dynamically allocated 
object, typically with a C++ new-expression. The object pointed to is 
guaranteed to be deleted when the last `shared_ptr` pointing to it is 
destroyed or reset. For more information refer to the 
[@../../libs/smart_ptr/shared_ptr.htm shared_ptr]
and [@../../libs/smart_ptr/weak_ptr.htm weak_ptr] documentation.\n
`shared_ptr` 类模板保存一个指向动态分配对象的指针，该对象通常是用 C++ 的new-表达式得到的。
当最后一个指向该对象的 `shared_ptr` 被销毁或重置时，将确保被指对象被删除。更多信息，请参考 
[@../../libs/smart_ptr/shared_ptr.htm shared_ptr] 和 [@../../libs/smart_ptr/weak_ptr.htm weak_ptr] 的文档。
   
   namespace std {
   namespace tr1 {

   class bad_weak_ptr;

   // [2.2.3] Class template shared_ptr
   template<class T> class shared_ptr;

   // [2.2.3.6] shared_ptr comparisons
   template<class T, class U> bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b);
   template<class T, class U> bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b);
   template<class T, class U> bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b);

   // [2.2.3.8] shared_ptr specialized algorithms
   template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b);

   // [2.2.3.9] shared_ptr casts
   template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r);
   template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r);
   template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r);

   // [2.2.3.7] shared_ptr I/O
   template<class E, class T, class Y>
   basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);

   // [2.2.3.10] shared_ptr get_deleter
   template<class D, class T> D * get_deleter(shared_ptr<T> const& p);

   // [2.2.4] Class template weak_ptr
   template<class T> class weak_ptr;

   // [2.2.4.6] weak_ptr comparison
   template<class T, class U> bool operator<(weak_ptr<T> const& a, weak_ptr<U> const& b);

   // [2.2.4.7] weak_ptr specialized algorithms
   template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b);

   // [2.2.5] Class enable_shared_from_this
   template<class T> class enable_shared_from_this;

   } // namespace tr1
   } // namespace std

[*Configuration:] 
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_SHARED_PTR if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_SHARED_PTR，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:] There are no known deviations from the standard when 
using the Boost version of this component.\n
[*标准符合性：]使用该组件的 Boost 版本时，没有已知的与标准不符的地方。

[endsect]

[section:result_of Class template result_of.]

   #include <boost/tr1/functional.hpp>
   
or\n
或

   #include <functional>

The class template
`result_of` helps determine the type of a
call expression. Given an lvalue `f` of
type `F` and lvalues `t1`,
`t2, ..., tN` of
types `T1, T2, ..., TN`, respectively, the type
`result_of<F(T1, T2, ..., TN)>::type` defines the result type
of the expression `f(t1, t2, ...,tN)`. The implementation permits
the type `F` to be a function pointer,
function reference, member function pointer, or class
type.  For more information 
[@../../libs/utility/utility.htm#result_of refer to the Boost.Utility documentation.]\n
类模板 `result_of` 帮助确定函数调用表达式的类型。给定类型 `F` 的一个左值 `f` 以及类型分别为  `T1, T2, ..., TN` 的左值 
`t1, t2, ..., tN`, 类型 `result_of<F(T1, T2, ..., TN)>::type` 定义了表达式 `f(t1, t2, ...,tN)` 的结果类型。
该实现允许类型 `F` 为函数指针、函数引用、成员函数指针或类类型。更多信息请 
[@../../libs/utility/utility.htm#result_of 参见 Boost.Utility 的文档]。

   namespace std {
   namespace tr1 {

   template <class T>
   struct result_of
   {
      typedef unspecified type;
   };

   } // namespace tr1
   } // namespace std

[*Configuration:] 
[@../../libs/config/index.html Boost.Config] should (automatically) define 
the macro BOOST_HAS_TR1_RESULT_OF if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_RESULT_OF，如果你的标准库实现了这部分 TR1. 
   
[*Standard Conformity:] No known problems.\n
[*标准符合性：]没有已知的问题。

[endsect]

[section:mem_fn Function template mem_fn.]

   #include <boost/tr1/functional.hpp>
   
or\n
或

   #include <functional>

`std::tr1::mem_fn` is a generalization of the standard functions `std::mem_fun`
and `std::mem_fun_ref`. It supports member function pointers with more 
than one argument, and the returned function object can take a pointer, a 
reference, or a smart pointer to an object instance as its first argument. `mem_fn`
also supports pointers to data members by treating them as functions taking no 
arguments and returning a (const) reference to the member.
For more information refer to the [@../../libs/bind/mem_fn.html
Boost.Mem_fn documentation].\n
`std::tr1::mem_fn` 是标准函数 `std::mem_fun` 和 `std::mem_fun_ref` 的泛化。
它支持多于一个参数的成员函数指针，且返回的函数对象可以以指向一个对象实例的指针、引用或智能指针作为第一个参数。
`mem_fn` 还支持数据成员指针，象不带参数的函数那样处理它们，返回该成员的一个(const)引用。更多信息请参见 
[@../../libs/bind/mem_fn.html Boost.Mem_fn 的文档]。 

   namespace std {
   namespace tr1 {

   template <class R, class T> unspecified mem_fn(R T::* pm);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define 
the macro BOOST_HAS_TR1_MEM_FN if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_MEM_FN，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
The Boost implementation does not produce functors that inherit from
`std::unary_function` or `std::binary_function`, nor does it function
correctly with pointers to volatile member functions (these should
be extremely rare in practice however).\n
[*标准符合性：]Boost 的实现不生成继承自 `std::unary_function` 或 `std::binary_function` 的仿函数，也不能正确处理指向 
volatile 成员函数的指针(在实际上极为罕见)。 

[endsect]

[section:bind Function Object Binders. 函数对象绑定器]

   #include <boost/tr1/functional.hpp>

or\n
或

   #include <functional>

`std::tr1::bind` is a generalization of the standard functions `std::bind1st`
and `std::bind2nd`. It supports arbitrary function objects, functions, 
function pointers, and member function pointers, and is able to bind any 
argument to a specific value or route input arguments into arbitrary positions. `bind`
does not place any requirements on the function object; in particular, it does 
not need the `result_type`, `first_argument_type` and `second_argument_type`
standard typedefs.
For more information refer to the [@../../libs/bind/bind.html 
Boost.Bind documentation].\n
`std::tr1::bind` 是标准函数 `std::bind1st` 和 `std::bind2nd` 的泛化。
它支持任意函数对象、函数、函数指针和成员函数指针，而且可以将任何参数绑定到一个特定值或将输入的参数换到任意位置。
`bind` 对函数对象没有任何要求；具体说，它不需要 `result_type`, `first_argument_type` 和 `second_argument_type` 等标准的 typedefs. 
更多信息请参见 [@../../libs/bind/bind.html Boost.Bind 的文档]。

   namespace std {
   namespace tr1 {

   // [3.6] Function object binders
   template<class T> struct is_bind_expression;
   template<class T> struct is_placeholder;
   template<class F, class T1, ..., class Tn > unspecified bind(F f, T1 t1, ..., Tn tn );
   template<class R, class F, class T1, ..., class Tn > unspecified bind(F f, T1 t1, ..., Tn tn );

   namespace placeholders {
      // M is the implementation-defined number of placeholders
      extern unspecified _1;
      extern unspecified _2;
      .
      .
      .
      extern unspecified _M;
   }

   } // namespace tr1
   } // namespace std

[*Configuration:] 
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_BIND if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_BIND，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
The traits classes `is_placeholder` and `is_bind_expression` are not supported
by the Boost implementation.\n
[*标准符合性：]在 Boost 实现中，不支持 traits 类 `is_placeholder` 和 `is_bind_expression`. 

The named return value syntax isn't supported if the object being bound is a 
function pointer, for example:\n
如果被绑定的对象是函数指针，则不支持命名返回值，例如：

   std::tr1::bind(&my_proc, arg1, arg2 /* etc */); // works OK.
   std::tr1::bind<double>(&my_proc, arg1, arg2 /* etc */); // causes compiler error.
   std::tr1::bind<double>(my_function_object, arg1, arg2 /* etc */); // works OK.

On the other hand, the Boost implementation does work with pointers to overloaded
functions, and optionally with function pointers with non-standard
calling conventions.\n
另一方面，Boost 实现可以使用指向重载函数的指针，以及可选地支持非标准调用法的函数指针。

[endsect]

[section:function Polymorphic function wrappers. 多态函数包装器]

   #include <boost/tr1/functional.hpp>

or\n
或

   #include <functional>

The polymorphic function wrappers are a family of class templates
that may be used as a generalized callback mechanism. 
A polymorphic function wrapper shares features with function pointers, in
that both define a call interface (for example a function taking two integer
arguments and returning a floating-point value) through which some
arbitrary code may be called. However a polymorphic function wrapper can call
any callable object with a compatible call signature, this could be a function 
pointer, or it could be a function object produced by std::tr1::bind, or some
other mechanism.  For more information see the [@../../doc/html/function.html
Boost.Function documentation].\n
多态函数包装器是一族类模板，它们可用于泛型的回调机制。
多态函数包装器共享了函数指针的特性，它们均定义了可被任意代码所调用的接口 (例如一个接受两个整型参数并返回一个浮点值的函数)。
但是，多态函数包装器可以用兼容的调用符号来调用任何可调用对象，可能是函数指针，或者是由 std::tr1::bind 或其它机制产生的函数对象。
更多信息请参见 [@../../doc/html/function.html Boost.Function 的文档]。

   
   namespace std {
   namespace tr1 {

   // [3.7] polymorphic function wrappers
   class bad_function_call;

   template<class Function> 
   class function;

   template<class Function>
   void swap(function<Function>&, function<Function>&);

   template<class Function1, class Function2>
   void operator==(const function<Function1>&, const function<Function2>&);
   template<class Function1, class Function2>
   void operator!=(const function<Function1>&, const function<Function2>&);
   template <class Function>
   bool operator==(const function<Function>&, unspecified-null-pointer-type );
   template <class Function>
   bool operator==(unspecified-null-pointer-type , const function<Function>&);
   template <class Function>
   bool operator!=(const function<Function>&, unspecified-null-pointer-type );
   template <class Function>
   bool operator!=(unspecified-null-pointer-type , const function<Function>&);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_FUNCTION if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_FUNCTION，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
The Boost version of `std::tr1::function` lacks the member function
`target_type()` and does not inherit from `std::unary_function`
or `std::binary_function` when applicable. The member function 
target() can only access pointer-to-member targets when they 
have been wrapped in mem_fn.\n
标准符合性：Boost 版本的 `std::tr1::function` 缺少成员函数 `target_type()`，并且在使用时不是继承自 `std::unary_function` 
或 `std::binary_function`. 当它们被包装在 mem_fn 中时，成员函数 target() 只能访问成员指针目标。

[endsect]

[section:type_traits Type Traits.]

   #include <boost/tr1/type_traits.hpp>

or\n
或

   #include <type_traits>

Type traits enable generic code to access the fundamental properties
of a type, to determine the relationship between two types, or to
transform one type into another related type.  For more information
refer to the [@../../libs/type_traits/index.html Boost.Type_traits documentation].\n
Type traits 使得泛型代码可以访问一个类型的基本属性，以决定两个类型之间的关系，或者将一个类型转换为另一个相关类型。更多信息请参见 
[@../../libs/type_traits/index.html Boost.Type_traits 的文档]。 
   
   namespace std {
   namespace tr1 {

   template <class T, T v> struct integral_constant;

   typedef integral_constant<bool, true> true_type;
   typedef integral_constant<bool, false> false_type;

   // [4.5.1] primary type categories:
   template <class T> struct is_void;
   template <class T> struct is_integral;
   template <class T> struct is_floating_point;
   template <class T> struct is_array;
   template <class T> struct is_pointer;
   template <class T> struct is_reference;
   template <class T> struct is_member_object_pointer;
   template <class T> struct is_member_function_pointer;
   template <class T> struct is_enum;
   template <class T> struct is_union;
   template <class T> struct is_class;
   template <class T> struct is_function;

   // [4.5.2] composite type categories:
   template <class T> struct is_arithmetic;
   template <class T> struct is_fundamental;
   template <class T> struct is_object;
   template <class T> struct is_scalar;
   template <class T> struct is_compound;
   template <class T> struct is_member_pointer;

   // [4.5.3] type properties:
   template <class T> struct is_const;
   template <class T> struct is_volatile;
   template <class T> struct is_pod;
   template <class T> struct is_empty;
   template <class T> struct is_polymorphic;
   template <class T> struct is_abstract;
   template <class T> struct has_trivial_constructor;
   template <class T> struct has_trivial_copy;
   template <class T> struct has_trivial_assign;
   template <class T> struct has_trivial_destructor;
   template <class T> struct has_nothrow_constructor;
   template <class T> struct has_nothrow_copy;
   template <class T> struct has_nothrow_assign;
   template <class T> struct has_virtual_destructor;
   template <class T> struct is_signed;
   template <class T> struct is_unsigned;
   template <class T> struct alignment_of;
   template <class T> struct rank;
   template <class T, unsigned I = 0> struct extent;

   // [4.6] type relations:
   template <class T, class U> struct is_same;
   template <class Base, class Derived> struct is_base_of;
   template <class From, class To> struct is_convertible;

   // [4.7.1] const-volatile modifications:
   template <class T> struct remove_const;
   template <class T> struct remove_volatile;
   template <class T> struct remove_cv;
   template <class T> struct add_const;
   template <class T> struct add_volatile;
   template <class T> struct add_cv;

   // [4.7.2] reference modifications:
   template <class T> struct remove_reference;
   template <class T> struct add_reference;

   // [4.7.3] array modifications:
   template <class T> struct remove_extent;
   template <class T> struct remove_all_extents;

   // [4.7.4] pointer modifications:
   template <class T> struct remove_pointer;
   template <class T> struct add_pointer;

   // [4.8] other transformations:
   template <std::size_t Len, std::size_t Align> struct aligned_storage;

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_TYPE_TRAITS if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_TYPE_TRAITS，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
No known problems.\n
[*标准符合性：]没有已知的问题。

[endsect]

[section:random Random Number Generators and Distributions. 随机数生成器和分发]

   #include <boost/tr1/random.hpp>
   
or\n
或

   #include <random>

The random number library is divided into three parts: 
[@../../libs/random/random-generators.html generators], which
are nullary functors producing uniform random number distributions.  
[@../../libs/random/random-distributions.html Distributions], which are unary 
functors that adapt a generator to some
specific kind of distribution.  And the class template 
[@../../libs/random/random-variate.html variate_generator]
which combines a generator with a distribution, to create a new generator.
For more information see the [@../../libs/random/index.html Boost.Random documentation].\n
随机数库分为三部分：[@../../libs/random/random-generators.html 生成器]，它是一些无参的函数对象，生成统一的随机数。
[@../../libs/random/random-distributions.html 分发器]，它也是一些无参的函数对象，将生成器适配为特定种类的分发器。
以及类模板 [@../../libs/random/random-variate.html variate_generator]，它将一个生成器和一个分配器进行组合，以创建一个新的生成器。
更多信息请参见 [@../../libs/random/index.html Boost.Random 的文档]。

   
   namespace std {
   namespace tr1 {

   // [5.1.3] Class template variate_generator
   template<class UniformRandomNumberGenerator, class Distribution>
   class variate_generator;

   // [5.1.4.1] Class template linear_congruential
   template<class IntType, IntType a, IntType c, IntType m>
   class linear_congruential;

   // [5.1.4.2] Class template mersenne_twister
   template<class UIntType, int w, int n, int m, int r,
   UIntType a, int u, int s, UIntType b, int t, UIntType c, int l>
   class mersenne_twister;

   // [5.1.4.3] Class template substract_with_carry
   template<class IntType, IntType m, int s, int r>
   class subtract_with_carry;

   // [5.1.4.4] Class template substract_with_carry_01
   template<class RealType, int w, int s, int r>
   class subtract_with_carry_01;

   // [5.1.4.5] Class template discard_block
   template<class UniformRandomNumberGenerator, int p, int r>
   class discard_block;

   // [5.1.4.6] Class template xor_combine
   template<class UniformRandomNumberGenerator1, int s1,
   class UniformRandomNumberGenerator2, int s2>
   class xor_combine;
   
   // [5.1.5] Predefined generators
   typedef linear_congruential<
               implementation-defined , 
               16807, 
               0, 
               2147483647> minstd_rand0;
               
   typedef linear_congruential<
               implementation-defined , 
               48271, 
               0, 
               2147483647> minstd_rand;
               
   typedef mersenne_twister<
               implementation-defined ,
               32, 624, 397, 31, 
               0x9908b0df, 11, 7, 
               0x9d2c5680, 15, 
               0xefc60000, 18> mt19937;
               
   typedef subtract_with_carry_01<
               float, 
               24, 
               10, 
               24> ranlux_base_01;
               
   typedef subtract_with_carry_01<
               double, 
               48, 
               10, 
               24> ranlux64_base_01;
               
   typedef discard_block<
               subtract_with_carry<
                     implementation-defined , 
                     (1<<24), 
                     10, 
                     24>, 
               223, 
               24> ranlux3;
               
   typedef discard_block<
               subtract_with_carry<
                     implementation-defined, 
                     (1<<24), 
                     10, 
                     24>, 
               389, 
               24> ranlux4;
               
   typedef discard_block<
               subtract_with_carry_01<
                     float, 
                     24, 
                     10, 
                     24>, 
               223, 
               24> ranlux3_01;
               
   typedef discard_block<
               subtract_with_carry_01<
                     float, 
                     24, 
                     10, 
                     24>, 
               389, 
               24> ranlux4_01;
   
   // [5.1.6] Class random_device
   class random_device;

   // [5.1.7.1] Class template uniform_int
   template<class IntType = int>
   class uniform_int;

   // [5.1.7.2] Class bernoulli_distribution
   class bernoulli_distribution;

   // [5.1.7.3] Class template geometric_distribution
   template<class IntType = int, class RealType = double>
   class geometric_distribution;

   // [5.1.7.4] Class template poisson_distribution
   template<class IntType = int, class RealType = double>
   class poisson_distribution;

   // [5.1.7.5] Class template binomial_distribution
   template<class IntType = int, class RealType = double>
   class binomial_distribution;

   // [5.1.7.6] Class template uniform_real
   template<class RealType = double>
   class uniform_real;

   // [5.1.7.7] Class template exponential_distribution
   template<class RealType = double>
   class exponential_distribution;

   // [5.1.7.8] Class template normal_distribution
   template<class RealType = double>
   class normal_distribution;

   // [5.1.7.9] Class template gamma_distribution
   template<class RealType = double>
   class gamma_distribution;

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_RANDOM if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_RANDOM，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
The Boost implementation has the following limitations:\n
[*标准符合性：]Boost 实现具有以下限制：

*The linear_congruential generator is fully supported for 
signed integer types only (unsigned types probably only work when 
the modulus is zero).\n
 linear_congruential 生成器只能完全支持有符号整数类型(无符号类型可能只能在模数为零时使用)。 
*The subtract_with_carry template does not support a modulus of zero.\n
 subtract_with_carry 模板不支持以零为模数。
*Not all of the standard generator types have Boost documentation yet, they are
none the less supported however.\n
 不是所有标准生成器都有 Boost 文档，不过它们仍被支持。
*Class template variate_generator does not have a template unary function call operator(), 
only the non-template nullary version.\n
 类模板 variate_generator 没有无参的模板函数调用操作符 operator()，只有非模板的无参版本。

Note also that most of the Random number generators have been re-implemented 
as thin wrappers around the Boost versions in order to
provide a standard conforming interface (the Boost versions all take an additional,
redundant, template parameter, and are initialized by iterators rather than functors).\n
还是注意，大多随机数生成器都重新实现了一个对 Boost 版本的小包装器，以提供符合标准的接口(Boost 版本的生成器均带有一个额外的、多余的模板参数，而且是通过迭代器而不是函数对象来初始化)。 

[endsect]

[section:tuple Tuples.]

   #include <boost/tr1/tuple.hpp>

or\n
或
   
   #include <tuple>

A tuple is a fixed size collection of elements. 
Pairs, triples, quadruples etc. are tuples. 
In a programming language, a tuple is a data object containing other objects as elements. 
These element objects may be of different types.
Tuples are convenient in many circumstances. 
For instance, tuples make it easy to define functions that return more than one value.
Some programming languages, such as ML, Python and Haskell, have built-in tuple constructs. 
Unfortunately C++ does not.
To compensate for this "deficiency", the TR1 Tuple Library implements a tuple construct using templates.
For more information see the [@../../libs/tuple/index.html Boost Tuple Library Documentation].\n
tuple 是一个固定大小的元素集合。Pairs, triples, quadruples 等等都是 tuples. 在编程语言中，tuple 是一个以其它对象作为元素的数据对象。
这些元素对象可以是不同的类型。Tuple 在许多环境下都很方便使用。例如，tuple 可以很容易地定义返回一个以上值的函数。
有些编程语言，如 ML, Python 和 Haskell, 带有内建的 tuple 结构。不幸的是 C++ 没有。
为了弥补这个"不足"，TR1 Tuple 库用模板实现了一个 tuple 结构。更多信息请参见 
[@../../libs/tuple/index.html Boost Tuple 库的文档]。

   namespace std {
   namespace tr1 {

   // [6.1.3] Class template tuple
   template <class T1 = unspecified ,
   class T2 = unspecified ,
   ...,
   class TM = unspecified > class tuple;

   // [6.1.3.2] Tuple creation functions
   const unspecified ignore;

   template<class T1, class T2, ..., class TN>
   tuple<V1, V2, ..., VN> make_tuple(const T1&, const T2& , ..., const TN&);

   // [6.1] Tuple types Containers
   template<class T1, class T2, ..., class TN>
   tuple<T1&, T2&, ..., TN&> tie(T1&, T2& , ..., TN&);

   // [6.1.3.3] Tuple helper classes
   template <class T> class tuple_size;
   template <int I, class T> class tuple_element;

   // [6.1.3.4] Element access
   template <int I, class T1, class T2, ..., class TN>
   RI get(tuple<T1, T2, ..., TN>&);
   template <int I, class T1, class T2, ..., class TN>
   PI get(const tuple<T1, T2, ..., TN>&);

   // [6.1.3.5] relational operators
   template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
   bool operator==(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);
   template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
   bool operator<(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);
   template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
   bool operator!=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);
   template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
   bool operator>(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);
   template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
   bool operator<=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);
   template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
   bool operator>=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_TUPLE if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_TUPLE，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
No known issues for conforming compilers.\n
[*标准符合性：]在符合标准的编译器上没有已知的问题。

[endsect]

[section:utility Tuple Interface to std::pair.  std::pair的tuple接口]

   #include <boost/tr1/utility.hpp>

or\n
或

   #include <utility>

The existing class template std::pair, can also be accessed using the 
[link boost_tr1.subject_list.tuple tuple interface].\n
已有的类模板 std::pair, 也可以通过 [link boost_tr1.subject_list.tuple tuple 接口] 来访问。
   
   namespace std {
   namespace tr1 {

   template <class T> class tuple_size; // forward declaration
   template <int I, class T> class tuple_element; // forward declaration
   template <class T1, class T2> struct tuple_size<std::pair<T1, T2> >;
   template <class T1, class T2> struct tuple_element<0, std::pair<T2, T2> >;
   template <class T1, class T2> struct tuple_element<1, std::pair<T2, T2> >;
   // see below for definition of "P".
   template<int I, class T1, class T2> P& get(std::pair<T1, T2>&);
   template<int I, class T1, class T2> const P& get(const std::pair<T1, T2>&);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_UTILITY if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_UTILITY，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
No known problems.\n
[*标准符合性：]没有已知的问题。

[endsect]

[section:array Fixed Size Array. 固定大小数组]

   #include <boost/tr1/array.hpp>
   
or\n
或

   #include <array>
   
Class template array is a fixed size array that is safer than and no
less efficient than a C style array.  Class array fulfils almost all of the
requirements of a reversible-container (see Section 23.1, 
[lib.container.requirements] of the C++ Standard).  For more information refer
to the [@../../libs/array/index.html Boost.Array documentation].\n
类模板 array 是一个固定大小的数组，比C风格的数组更为安全且没有降低效率。
类 array 几乎符合可逆容器(见C++标准的第 23.1节, [lib.container.requirements])的所有要求。
更多信息请参见 [@../../libs/array/index.html Boost.Array 的文档]。

   namespace std {
   namespace tr1 {

   // [6.2.2] Class template array
   template <class T, size_t N > struct array;

   // Array comparisons
   template <class T, size_t N> bool operator== (const array<T,N>& x, const array<T,N>& y);
   template <class T, size_t N> bool operator< (const array<T,N>& x, const array<T,N>& y);
   template <class T, size_t N> bool operator!= (const array<T,N>& x, const array<T,N>& y);
   template <class T, size_t N> bool operator> (const array<T,N>& x, const array<T,N>& y);
   template <class T, size_t N> bool operator>= (const array<T,N>& x, const array<T,N>& y);
   template <class T, size_t N> bool operator<= (const array<T,N>& x, const array<T,N>& y);

   // [6.2.2.2] Specialized algorithms
   template <class T, size_t N > void swap(array<T,N>& x, array<T,N>& y);

   // [6.2.2.5] Tuple interface to class template array
   template <class T> class tuple_size; // forward declaration
   template <int I, class T> class tuple_element; // forward declaration
   template <class T, size_t N> struct tuple_size<array<T, N> >;
   template <int I, class T, size_t N> struct tuple_element<I, array<T, N> >;
   template <int I, class T, size_t N> T& get( array<T, N>&);
   template <int I, class T, size_t N> const T& get(const array<T, N>&);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_ARRAY if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_ARRAY，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
No known issues as of Boost-1.34 onwards.\n
[*标准符合性：]没有 Boost-1.34 之前的已知问题。

[endsect]

[section:hash Hash Function Objects. 散列函数对象]

   #include <boost/tr1/functional.hpp>
   
or\n
或

   #include <functional>

Class template std::hash is a unary-functor that converts some type T 
into a hash-value,
specializations of std::hash are provided for integer, character, floating point, 
and pointer types, plus the two string types std::string and std::wstring.
See the [@../../libs/functional/hash/index.html Boost.Hash] 
documentation for more information.\n
类模板 std::hash 是一个单参函数对象，将某个类型 T 转换为一个散列值，对于整数、字符、浮点数、指针类型，以及两个字符串类型 std::string 
和 std::wstring 都已提供了 std::hash 的相应特化版本。更多信息请见 [@../../libs/functional/hash/index.html Boost.Hash] 的文档。
   
   namespace std {
   namespace tr1 {

   template <class T> 
   struct hash : public unary_function<T, size_t>
   {
      size_t operator()(T val)const;
   };

   // Hash function specializations
   template <> struct hash<bool>;
   template <> struct hash<char>;
   template <> struct hash<signed char>;
   template <> struct hash<unsigned char>;
   template <> struct hash<wchar_t>;
   template <> struct hash<short>;
   template <> struct hash<int>;
   template <> struct hash<long>;
   template <> struct hash<unsigned short>;
   template <> struct hash<unsigned int>;
   template <> struct hash<unsigned long>;
   template <> struct hash<float>;
   template <> struct hash<double>;
   template <> struct hash<long double>;
   template<class T> struct hash<T*>;
   template <> struct hash<std::string>;
   template <> struct hash<std::wstring>;

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_HASH if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_HASH，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
Boost.Hash adds specialisations of std::hash for a wider range of types
than those required by TR1: Boost.Hash acts as a testbed for issue 6.18
in the [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1756.pdf 
Library Extension Technical Report Issues List].\n
[*标准符合性：]Boost.Hash 增加了比 TR1 更广范围的 std::hash 特化版本：Boost.Hash 担当了 
[@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1756.pdf Library Extension Technical Report 问题列表] 中的问题 6.18 的测试床。

[endsect]

[section:regex Regular Expressions. 正则表达式]

   #include <boost/tr1/regex.hpp>
   
or\n
或

   #include <regex>
   
This library provides comprehensive support for regular expressions,
including either iterator or string based matching, searching, search-and-replace,
iteration, and tokenization.  Both POSIX and ECMAScript (JavaScript) regular
expressions are supported.  For more information see the [@../../libs/regex/index.html
Boost.Regex documentation]. \n
这个库提供了对正则表达式的全面支持，包括基于迭代器或字符串的匹配、查找、查找并替换、迭代，以及分词 (tokenization)。
支持 POSIX 和 ECMAScript (JavaScript)的正则表达式。更多信息请参见 [@../../libs/regex/index.html Boost.Regex 的文档]。
   
   namespace std {
   namespace tr1 {

   // [7.5] Regex constants
   namespace regex_constants {

   typedef bitmask_type syntax_option_type;
   typedef bitmask_type match_flag_type;
   typedef implementation-defined error_type;

   } // namespace regex_constants

   // [7.6] Class regex_error
   class regex_error;

   // [7.7] Class template regex_traits
   template <class charT> struct regex_traits;

   // [7.8] Class template basic_regex
   template <class charT, class traits = regex_traits<charT> > 
   class basic_regex;

   typedef basic_regex<char> regex;
   typedef basic_regex<wchar_t> wregex;

   // [7.8.6] basic_regex swap
   template <class charT, class traits>
   void swap(basic_regex<charT, traits>& e1,
            basic_regex<charT, traits>& e2);
             
   // [7.9] Class template sub_match
   template <class BidirectionalIterator>
   class sub_match;

   typedef sub_match<const char*> csub_match;
   typedef sub_match<const wchar_t*> wcsub_match;
   typedef sub_match<string::const_iterator> ssub_match;
   typedef sub_match<wstring::const_iterator> wssub_match;

   // [7.9.2] sub_match non-member operators

   /* Comparison operators omitted for clarity.... */

   template <class charT, class ST, class BiIter>
   basic_ostream<charT, ST>&
      operator<<(basic_ostream<charT, ST>& os, 
               const sub_match<BiIter>& m);

   // [7.10] Class template match_results
   template <class BidirectionalIterator,
            class Allocator = allocator<sub_match<BidirectionalIterator> > >
   class match_results;

   typedef match_results<const char*> cmatch;
   typedef match_results<const wchar_t*> wcmatch;
   typedef match_results<string::const_iterator> smatch;
   typedef match_results<wstring::const_iterator> wsmatch;

   // match_results comparisons
   template <class BidirectionalIterator, class Allocator>
   bool operator== (const match_results<BidirectionalIterator, Allocator>& m1,
                  const match_results<BidirectionalIterator, Allocator>& m2);
   template <class BidirectionalIterator, class Allocator>
   bool operator!= (const match_results<BidirectionalIterator, Allocator>& m1,
                  const match_results<BidirectionalIterator, Allocator>& m2);

   // [7.10.6] match_results swap
   template <class BidirectionalIterator, class Allocator>
   void swap(match_results<BidirectionalIterator, Allocator>& m1,
            match_results<BidirectionalIterator, Allocator>& m2);
             
   // [7.11.2] Function template regex_match
   template <class BidirectionalIterator, class Allocator, class charT, class traits>
   bool regex_match(BidirectionalIterator first, 
                  BidirectionalIterator last,
                  match_results<BidirectionalIterator, Allocator>& m,
                  const basic_regex<charT, traits>& e,
                  regex_constants::match_flag_type flags = regex_constants::match_default);

   template <class BidirectionalIterator, class charT, class traits>
   bool regex_match(BidirectionalIterator first, 
                  BidirectionalIterator last,
                  const basic_regex<charT, traits>& e,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
                    
   template <class charT, class Allocator, class traits>
   bool regex_match(const charT* str, 
                  match_results<const charT*, Allocator>& m,
                  const basic_regex<charT, traits>& e,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
                    
   template <class ST, class SA, class Allocator, class charT, class traits>
   bool regex_match(const basic_string<charT, ST, SA>& s,
                  match_results<typename basic_string<charT, ST, SA>::const_iterator,Allocator>& m,
                  const basic_regex<charT, traits>& e,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
                    
   template <class charT, class traits>
   bool regex_match(const charT* str,
                  const basic_regex<charT, traits>& e,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
                    
   template <class ST, class SA, class charT, class traits>
   bool regex_match(const basic_string<charT, ST, SA>& s,
                  const basic_regex<charT, traits>& e,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
                    
   // [7.11.3] Function template regex_search
   template <class BidirectionalIterator, class Allocator, class charT, class traits>
   bool regex_search(BidirectionalIterator first, 
                     BidirectionalIterator last,
                     match_results<BidirectionalIterator, Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
                     
   template <class BidirectionalIterator, class charT, class traits>
   bool regex_search(BidirectionalIterator first, 
                     BidirectionalIterator last,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
                     
   template <class charT, class Allocator, class traits>
   bool regex_search(const charT* str,
                     match_results<const charT*, Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
                     
   template <class charT, class traits>
   bool regex_search(const charT* str,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
                     
   template <class ST, class SA, class charT, class traits>
   bool regex_search(const basic_string<charT, ST, SA>& s,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
                     
   template <class ST, class SA, class Allocator, class charT, class traits>
   bool regex_search(const basic_string<charT, ST, SA>& s,
                     match_results<typename basic_string<charT, ST, SA>::const_iterator, Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
                     
   // [7.11.4] Function template regex_replace
   template <class OutputIterator, class BidirectionalIterator, class traits, class charT>
   OutputIterator regex_replace(OutputIterator out,
                              BidirectionalIterator first, 
                              BidirectionalIterator last,
                              const basic_regex<charT, traits>& e,
                              const basic_string<charT>& fmt,
                              regex_constants::match_flag_type flags = regex_constants::match_default);
                                
   template <class traits, class charT>
   basic_string<charT> regex_replace(const basic_string<charT>& s,
                                          const basic_regex<charT, traits>& e,
                                          const basic_string<charT>& fmt,
                                          regex_constants::match_flag_type flags = regex_constants::match_default);
                                           
   // [7.12.1] Class template regex_iterator
   template <class BidirectionalIterator, 
            class charT = typename iterator_traits<BidirectionalIterator>::value_type,
            class traits = regex_traits<charT> >
   class regex_iterator;

   typedef regex_iterator<const char*> cregex_iterator;
   typedef regex_iterator<const wchar_t*> wcregex_iterator;
   typedef regex_iterator<string::const_iterator> sregex_iterator;
   typedef regex_iterator<wstring::const_iterator> wsregex_iterator;

   // [7.12.2] Class template regex_token_iterator
   template <class BidirectionalIterator,
            class charT = typename iterator_traits<BidirectionalIterator>::value_type,
            class traits = regex_traits<charT> >
   class regex_token_iterator;

   typedef regex_token_iterator<const char*> cregex_token_iterator;
   typedef regex_token_iterator<const wchar_t*> wcregex_token_iterator;
   typedef regex_token_iterator<string::const_iterator> sregex_token_iterator;
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;

   } // namespace tr1
   } // namespace std

   
[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_REGEX if your
standard library implements this part of TR1.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_REGEX，如果你的标准库实现了这部分 TR1. 

[*Standard Conformity:]
No known problems.\n
[*标准符合性：]没有已知的问题。

[endsect]

[section:complex Complex Number Algorithm Overloads. 复数算法重载]

   #include <boost/tr1/complex.hpp>
   
or\n
或

   #include <complex>
   
The following function templates have additional overloads: 
`arg`, `norm`, `conj`, `polar`, `imag`, and `real`.\n
以下函数模板有新加的重载：`arg`, `norm`, `conj`, `polar`, `imag`, 和 `real`. 

The additional 
overloads are sufficient to ensure:\n
这些新增的重载函数足以确保：

*If the argument has type `long double`, then the overload behaves as if 
the argument had been cast to `std::complex<long double>`.\n
如果参数类型为 `long double`, 则重载函数的行为就象这些参数已转型为 `std::complex<long double>` 一样。
*Otherwise, if the argument has type `double` or is an integer type, 
then the overload behaves as if 
the argument had been cast to `std::complex<double>`.\n
否则，如果参数类型为 `double` 或某个整数类型，则重载函数的行为就象这些参数已转型为 `std::complex<double>` 一样。
*Otherwise, if the argument has type `float`, then the overload 
behaves as if 
the argument had been cast to `std::complex<float>`.\n
 否则，如果参数类型为 `float`, 则重载函数的行为就象这些参数已转型为 `std::complex<float>` 一样。

The function template `pow` has additional overloads sufficient to ensure, 
for a call with at least one argument of type `std::complex<T>`:\n
函数模板 `pow` 也有新增的重载可以确保，对于至少有一个参数类型为 `std::complex<T>` 的调用：

*If either argument has type `complex<long double>` or type 
`long double`, then the overload behaves as if both arguments were cast
to `std::complex<long double>`\n
 如果参数类型为 `complex<long double>` 或 `long double`, 则重载函数的行为就象两个参数均转型为 `std::complex<long double>` 一样。
*Otherwise, if either argument has type `complex<double>`, `double`, 
or an integer type, then the overload behaves as if both arguments were cast
to `std::complex<double>`\n
 否则，如果参数类型为 `complex<double>`, `double`, 或某个整数类型，则重载函数的行为就象两个参数均转型为 `std::complex<double>` 一样。
*Otherwise, if either argument has type `complex<float>` or `float`, 
then the overload behaves as if both arguments were cast
to `std::complex<float>`\n
 否则，如果参数类型为 `complex<float>` 或 `float`, 则重载函数的行为就象两个参数均转型为 `std::complex<float>` 一样。

In the following synopsis, `Real` is a floating point type,
`Arithmetic` is an integer or floating point type, and `
PROMOTE(X1 ... XN)` is the largest floating point type in the list
X1 to XN, after any non-floating point types in the list have been replaced by
the type `double`.\n
在以下摘要中，`Real` 为浮点类型，`Arithmetic` 为整数或浮点类型，`PROMOTE(X1 ... XN)` 则是 X1 到 XN 
的最大浮点类型，其中所有非浮点类型均替换为类型 `double`. 

   template <class Arithmetic>
   PROMOTE(Arithmetic) arg(const Arithmetic& t);

   template <class Arithmetic>
   PROMOTE(Arithmetic) norm(const Arithmetic& t);

   template <class Arithmetic>
   complex<PROMOTE(Arithmetic)> conj(const Arithmetic& t);

   template <class Arithmetic1, class Arithmetic2>
   complex<PROMOTE(Arithmetic1,Arithmetic2)> polar(const Arithmetic1& rho, const Arithmetic2& theta = 0);

   template <class Arithmetic>
   PROMOTE(Arithmetic) imag(const Arithmetic& );

   template <class Arithmetic>
   PROMOTE(Arithmetic) real(const Arithmetic& t);

   template<class Real1, class Real2>
   complex<PROMOTE(Real1, Real2)> 
      pow(const complex<Real1>& x, const complex<Real2>& y);
      
   template<class Real, class Arithmetic> 
   complex<PROMOTE(Real, Arithmetic)> 
      pow (const complex<Real>& x, const Arithmetic& y);

   template<class Arithmetic, class Real> 
   complex<PROMOTE(Real, Arithmetic)> 
      pow (const Arithmetic& x, const complex<Real>& y);
   
[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_COMPLEX_OVERLOADS if your
standard library implements the additional overloads for the existing
complex arithmetic functions.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_COMPLEX_OVERLOADS，
如果你的标准库实现了已有复数函数的额外重载。

[*Standard Conformity:]
No known problems.\n
[*标准符合性：]没有已知的问题。

[endsect]

[section:complex_trig Complex Number Additional Algorithms. 其它复数算法]

   #include <boost/tr1/complex.hpp>
   
or\n
或

   #include <complex>

The algorithms `acos`, `asin`, `atan`, 
`acosh`, `asinh`, `atanh` and `fabs`
are overloaded 
for arguments of type `std::complex<T>`.  
These algorithms are entirely
classical, and behave as specified in the C99 standard section 7.3.5.
See the [@../../libs/math/doc/complex/html/complex_number_tr1_algorithms/inverse_complex.html 
Boost.Math documentation for more information].\n
算法 `acos`, `asin`, `atan`, `acosh`, `asinh`, `atanh` 和 `fabs` 均针对参数类型 `std::complex<T>` 进行了重载。
这些算法完全是正统的，其行为符合C99标准第7.3.5节中的规定。更多信息请参见 
[@../../libs/math/doc/complex/html/complex_number_tr1_algorithms/inverse_complex.html Boost.Math 的文档]。
   
   namespace std {
   namespace tr1 {

   template<class T> complex<T> acos(complex<T>& x);
   template<class T> complex<T> asin(complex<T>& x);
   template<class T> complex<T> atan(complex<T>& x);
   template<class T> complex<T> acosh(complex<T>& x);
   template<class T> complex<T> asinh(complex<T>& x);
   template<class T> complex<T> atanh(complex<T>& x);
   template<class T> complex<T> fabs(complex<T>& x);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG
if your standard library implements the additional inverse trig functions.\n
[*配置：][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG，
如果你的标准库实现了这些额外的反三角函数。

[*Standard Conformity:]
No known problems.\n
[*标准符合性：]没有已知的问题。

[endsect]

[section:unordered_set Unordered Associative Set (Hash Table). 无序关联集合(散列表)]

   #include <boost/tr1/unordered_set.hpp>
   
or\n
或

   #include <unordered_set>

For accessing data based on key lookup, the C++ standard library 
offers std::set, std::map, std::multiset  and std::multimap. 
These are generally implemented using balanced binary trees so that 
lookup time has logarithmic complexity. That is generally okay, 
but in many cases a hash table can perform better, as accessing 
data has constant complexity, on average. The worst case complexity 
is linear, but that occurs rarely and with some care, can be avoided.\n
要基于键值查找来访问数据，C++ 标准库提供了 std::set, std::map, std::multiset 和 std::multimap。
它们通常是用平衡二分树实现的，所以查找时间具有对数复杂度。
这通常是OK的，但是在多数情况下，散列表可以表现得更好，因为平均来说它访问数据具有常量时间复杂度。
最坏情况下的复杂度是线性的，不过这极少发生，而且只要小心一点，是可以避免的。

With this in mind, the C++ Standard Library Technical Report 
introduced the unordered associative containers, which are 
implemented using hash tables, and they have now been added to 
the Working Draft of the C++ Standard.  \n
考虑到这一点，C++ 标准库技术报告引入了无序关联容器，用散列表来实现，而且现在已经将它们增加到C++标准的工作草案中了。

Refer to the 
[@../../libs/unordered/index.html Unordered Library docs] 
for more information.  \n
更多信息就参考 [@../../libs/unordered/index.html Unordered 库文档]。
   
   namespace std {
   namespace tr1 {

   template <class Value, 
            class Hash = hash<Value>, 
            class Pred = std::equal_to<Value>,
            class Alloc = std::allocator<Value> >
   class unordered_set;

   // [6.3.4.5] Class template unordered_multiset
   template <class Value,
            class Hash = hash<Value>,
            class Pred = std::equal_to<Value>,
            class Alloc = std::allocator<Value> >
   class unordered_multiset;

   template <class Value, class Hash, class Pred, class Alloc>
   void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
            unordered_set<Value, Hash, Pred, Alloc>& y);
             
   template <class Value, class Hash, class Pred, class Alloc>
   void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
            unordered_multiset<Value, Hash, Pred, Alloc>& y);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_UNORDERED_SET if your
standard library implements this part of TR1.\n
[*配置: ][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_UNORDERED_SET 如果你的标准库实现了这部分的 TR1. 

[*Standard Conformity:]
No known issues for conforming compilers.\n
[*标准符合性：]对于符合标准的编译器，没有已知的问题。 

[endsect]

[section:unordered_map Unordered Associative Map (Hash Table). 无序关联映射(散列表)]

   #include <boost/tr1/unordered_map.hpp>
   
or\n
或

   #include <unordered_map>
   
For accessing data based on key lookup, the C++ standard library 
offers std::set, std::map, std::multiset  and std::multimap. 
These are generally implemented using balanced binary trees so that 
lookup time has logarithmic complexity. That is generally okay, 
but in many cases a hash table can perform better, as accessing 
data has constant complexity, on average. The worst case complexity 
is linear, but that occurs rarely and with some care, can be avoided.\n
要基于键值查找来访问数据，C++ 标准库提供了 std::set, std::map, std::multiset 和 std::multimap。
它们通常是用平衡二分树实现的，所以查找时间具有对数复杂度。
这通常是OK的，但是在多数情况下，散列表可以表现得更好，因为平均来说它访问数据具有常量时间复杂度。
最坏情况下的复杂度是线性的，不过这极少发生，而且只要小心一点，是可以避免的。

With this in mind, the C++ Standard Library Technical Report 
introduced the unordered associative containers, which are 
implemented using hash tables, and they have now been added to 
the Working Draft of the C++ Standard.  \n
考虑到这一点，C++ 标准库技术报告引入了无序关联容器，用散列表来实现，而且现在已经将它们增加到C++标准的工作草案中了。

Refer to the 
[@../../libs/unordered/index.html Unordered Library docs] 
for more information.  \n
更多信息就参考 [@../../libs/unordered/index.html Unordered 库文档]。

   namespace std {
   namespace tr1 {

   // [6.3.4.4] Class template unordered_map
   template <class Key,
            class T,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
   class unordered_map;

   // [6.3.4.6] Class template unordered_multimap
   template <class Key,
            class T,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
   class unordered_multimap;

   template <class Key, class T, class Hash, class Pred, class Alloc>
   void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
            unordered_map<Key, T, Hash, Pred, Alloc>& y);
             
   template <class Key, class T, class Hash, class Pred, class Alloc>
   void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
            unordered_multimap<Key, T, Hash, Pred, Alloc>& y);

   } // namespace tr1
   } // namespace std

[*Configuration:]
[@../../libs/config/index.html Boost.Config] should (automatically) define
the macro BOOST_HAS_TR1_UNORDERED_MAP if your
standard library implements this part of TR1.\n
[*配置: ][@../../libs/config/index.html Boost.Config] 会(自动)定义宏 BOOST_HAS_TR1_UNORDERED_MAP 如果你的标准库实现了这部分的 TR1. 

[*Standard Conformity:]
No known issues for conforming compilers.\n
[*标准符合性：]对于符合标准的编译器，没有已知的问题。

[endsect]

[section:special Mathematical Special Functions. 数学特殊函数 ]

The TR adds 23 special functions (plus float and long double overloads)
to header <cmath>.\n
TR 在头文件 <cmatch> 中增加了23个特殊函数(加上 float 和 long double 的重载)。 

Refer to the 
[@../../libs/math/doc/sf_and_dist/html/math_toolkit/main_overview/tr1.html Math Library docs] 
for more information.  \n
更多信息请参考 [@../../libs/math/doc/sf_and_dist/html/math_toolkit/main_overview/tr1.html Math 库文档]。 

   
   namespace std {
   namespace tr1 {

   // [5.2.1.1] associated Laguerre polynomials:
   double assoc_laguerre(unsigned n, unsigned m, double x);
   float assoc_laguerref(unsigned n, unsigned m, float x);
   long double assoc_laguerrel(unsigned n, unsigned m, long double x);

   // [5.2.1.2] associated Legendre functions:
   double assoc_legendre(unsigned l, unsigned m, double x);
   float assoc_legendref(unsigned l, unsigned m, float x);
   long double assoc_legendrel(unsigned l, unsigned m, long double x);

   // [5.2.1.3] beta function:
   double beta(double x, double y);
   float betaf(float x, float y);
   long double betal(long double x, long double y);

   // [5.2.1.4] (complete) elliptic integral of the first kind:
   double comp_ellint_1(double k);
   float comp_ellint_1f(float k);
   long double comp_ellint_1l(long double k);

   // [5.2.1.5] (complete) elliptic integral of the second kind:
   double comp_ellint_2(double k);
   float comp_ellint_2f(float k);
   long double comp_ellint_2l(long double k);

   // [5.2.1.6] (complete) elliptic integral of the third kind:
   double comp_ellint_3(double k, double nu);
   float comp_ellint_3f(float k, float nu);
   long double comp_ellint_3l(long double k, long double nu);

   // [5.2.1.7] confluent hypergeometric functions:
   double conf_hyperg(double a, double c, double x);
   float conf_hypergf(float a, float c, float x);
   long double conf_hypergl(long double a, long double c, long double x);

   // [5.2.1.8] regular modified cylindrical Bessel functions:
   double cyl_bessel_i(double nu, double x);
   float cyl_bessel_if(float nu, float x);
   long double cyl_bessel_il(long double nu, long double x);

   // [5.2.1.9] cylindrical Bessel functions (of the first kind):
   double cyl_bessel_j(double nu, double x);
   float cyl_bessel_jf(float nu, float x);
   long double cyl_bessel_jl(long double nu, long double x);

   // [5.2.1.10] irregular modified cylindrical Bessel functions:
   double cyl_bessel_k(double nu, double x);
   float cyl_bessel_kf(float nu, float x);
   long double cyl_bessel_kl(long double nu, long double x);

   // [5.2.1.11] cylindrical Neumann functions;
   // cylindrical Bessel functions (of the second kind):
   double cyl_neumann(double nu, double x);
   float cyl_neumannf(float nu, float x);
   long double cyl_neumannl(long double nu, long double x);

   // [5.2.1.12] (incomplete) elliptic integral of the first kind:
   double ellint_1(double k, double phi);
   float ellint_1f(float k, float phi);
   long double ellint_1l(long double k, long double phi);

   // [5.2.1.13] (incomplete) elliptic integral of the second kind:
   double ellint_2(double k, double phi);
   float ellint_2f(float k, float phi);
   long double ellint_2l(long double k, long double phi);

   // [5.2.1.14] (incomplete) elliptic integral of the third kind:
   double ellint_3(double k, double nu, double phi);
   float ellint_3f(float k, float nu, float phi);
   long double ellint_3l(long double k, long double nu, long double phi);

   // [5.2.1.15] exponential integral:
   double expint(double x);
   float expintf(float x);
   long double expintl(long double x);

   // [5.2.1.16] Hermite polynomials:
   double hermite(unsigned n, double x);
   float hermitef(unsigned n, float x);
   long double hermitel(unsigned n, long double x);

   // [5.2.1.17] hypergeometric functions:
   double hyperg(double a, double b, double c, double x);
   float hypergf(float a, float b, float c, float x);
   long double hypergl(long double a, long double b, long double c, long double x);

   // [5.2.1.18] Laguerre polynomials:
   double laguerre(unsigned n, double x);
   float laguerref(unsigned n, float x);
   long double laguerrel(unsigned n, long double x);

   // [5.2.1.19] Legendre polynomials:
   double legendre(unsigned l, double x);
   float legendref(unsigned l, float x);
   long double legendrel(unsigned l, long double x);

   // [5.2.1.20] Riemann zeta function:
   double riemann_zeta(double);
   float riemann_zetaf(float);
   long double riemann_zetal(long double);

   // [5.2.1.21] spherical Bessel functions (of the first kind):
   double sph_bessel(unsigned n, double x);
   float sph_besself(unsigned n, float x);
   long double sph_bessell(unsigned n, long double x);

   // [5.2.1.22] spherical associated Legendre functions:
   double sph_legendre(unsigned l, unsigned m, double theta);
   float sph_legendref(unsigned l, unsigned m, float theta);
   long double sph_legendrel(unsigned l, unsigned m, long double theta);

   // [5.2.1.23] spherical Neumann functions;
   // spherical Bessel functions (of the second kind):
   double sph_neumann(unsigned n, double x);
   float sph_neumannf(unsigned n, float x);
   long double sph_neumannl(unsigned n, long double x);

   } // namespace tr1
   } // namespace std


[*Standard Conformity:]
The following functions are not supported in the Boost version of this component:\n
[*标准符合性：]以下函数在该组件的 Boost 版本中不支持： 

   // [5.2.1.7] confluent hypergeometric functions:
   double conf_hyperg(double a, double c, double x);
   float conf_hypergf(float a, float c, float x);
   long double conf_hypergl(long double a, long double c, long double x);

   // [5.2.1.17] hypergeometric functions:
   double hyperg(double a, double b, double c, double x);
   float hypergf(float a, float b, float c, float x);
   long double hypergl(long double a, long double b, long double c, long double x);

[endsect]

[section:c99_special C99 Mathematical Special Functions. C99 数学特殊函数]

The TR adds a number of special functions which were first introduced in the C99 standard
to header <cmath>.\n
TR 在头文件 <cmath> 中增加了许多在C99标准中首次引入的特殊函数。

Refer to the 
[@../../libs/math/doc/sf_and_dist/html/math_toolkit/main_overview/tr1.html Math Library docs] 
for more information.  \n
更多信息请参考 [@../../libs/math/doc/sf_and_dist/html/math_toolkit/main_overview/tr1.html Math 库文档]。 

   
   namespace std {
   namespace tr1 {
   
      // types
      typedef floating-type double_t;
      typedef floating-type float_t;

      // functions
      double acosh(double x);
      float acoshf(float x);
      long double acoshl(long double x);

      double asinh(double x);
      float asinhf(float x);
      long double asinhl(long double x);

      double atanh(double x);
      float atanhf(float x);
      long double atanhl(long double x);

      double cbrt(double x);
      float cbrtf(float x);
      long double cbrtl(long double x);

      double copysign(double x, double y);
      float copysignf(float x, float y);
      long double copysignl(long double x, long double y);

      double erf(double x);
      float erff(float x);
      long double erfl(long double x);

      double erfc(double x);
      float erfcf(float x);
      long double erfcl(long double x);

      double exp2(double x);
      float exp2f(float x);
      long double exp2l(long double x);

      double expm1(double x);
      float expm1f(float x);
      long double expm1l(long double x);

      double fdim(double x, double y);
      float fdimf(float x, float y);
      long double fdiml(long double x, long double y);

      double fma(double x, double y, double z);
      float fmaf(float x, float y, float z);
      long double fmal(long double x, long double y, long double z);

      double fmax(double x, double y);
      float fmaxf(float x, float y);
      long double fmaxl(long double x, long double y);

      double fmin(double x, double y);
      float fminf(float x, float y);
      long double fminl(long double x, long double y);

      double hypot(double x, double y);
      float hypotf(float x, float y);
      long double hypotl(long double x, long double y);

      int ilogb(double x);
      int ilogbf(float x);
      int ilogbl(long double x);

      double lgamma(double x);
      float lgammaf(float x);
      long double lgammal(long double x);

      long long llrint(double x);
      long long llrintf(float x);
      long long llrintl(long double x);

      long long llround(double x);
      long long llroundf(float x);
      long long llroundl(long double x);

      double log1p(double x);
      float log1pf(float x);
      long double log1pl(long double x);

      double log2(double x);
      float log2f(float x);
      long double log2l(long double x);

      double logb(double x);
      float logbf(float x);
      long double logbl(long double x);

      long lrint(double x);
      long lrintf(float x);
      long lrintl(long double x);

      long lround(double x);
      long lroundf(float x);
      long lroundl(long double x);

      double nan(const char *str);
      float nanf(const char *str);
      long double nanl(const char *str);

      double nearbyint(double x);
      float nearbyintf(float x);
      long double nearbyintl(long double x);

      double nextafter(double x, double y);
      float nextafterf(float x, float y);
      long double nextafterl(long double x, long double y);

      double nexttoward(double x, long double y);
      float nexttowardf(float x, long double y);
      long double nexttowardl(long double x, long double y);

      double remainder(double x, double y);
      float remainderf(float x, float y);
      long double remainderl(long double x, long double y);

      double remquo(double x, double y, int *pquo);
      float remquof(float x, float y, int *pquo);
      long double remquol(long double x, long double y, int *pquo);

      double rint(double x);
      float rintf(float x);
      long double rintl(long double x);

      double round(double x);
      float roundf(float x);
      long double roundl(long double x);

      double scalbln(double x, long ex);
      float scalblnf(float x, long ex);
      long double scalblnl(long double x, long ex);
      double scalbn(double x, int ex);
      float scalbnf(float x, int ex);
      long double scalbnl(long double x, int ex);

      double tgamma(double x);
      float tgammaf(float x);
      long double tgammal(long double x);

      double trunc(double x);
      float truncf(float x);
      long double truncl(long double x);

      // C99 macros defined as C++ templates
      template<class T> bool signbit(T x);
      template<class T> int fpclassify(T x);
      template<class T> bool isfinite(T x);
      template<class T> bool isinf(T x);
      template<class T> bool isnan(T x);
      template<class T> bool isnormal(T x);
      template<class T> bool isgreater(T x, T y);
      template<class T> bool isgreaterequal(T x, T y);
      template<class T> bool isless(T x, T y);
      template<class T> bool islessequal(T x, T y);
      template<class T> bool islessgreater(T x, T y);
      template<class T> bool isunordered(T x, T y);

   }} // namespaces

[*Standard Conformity:]
The following functions are not supported in the Boost version of this component:\n
[*标准符合性：]以下函数在该组件的 Boost 版本中不支持： 

      double exp2(double x);
      float exp2f(float x);
      long double exp2l(long double x);

      double fdim(double x, double y);
      float fdimf(float x, float y);
      long double fdiml(long double x, long double y);

      double fma(double x, double y, double z);
      float fmaf(float x, float y, float z);
      long double fmal(long double x, long double y, long double z);

      int ilogb(double x);
      int ilogbf(float x);
      int ilogbl(long double x);

      long long llrint(double x);
      long long llrintf(float x);
      long long llrintl(long double x);

      double log2(double x);
      float log2f(float x);
      long double log2l(long double x);

      double logb(double x);
      float logbf(float x);
      long double logbl(long double x);

      long lrint(double x);
      long lrintf(float x);
      long lrintl(long double x);

      double nan(const char *str);
      float nanf(const char *str);
      long double nanl(const char *str);

      double nearbyint(double x);
      float nearbyintf(float x);
      long double nearbyintl(long double x);

      double remainder(double x, double y);
      float remainderf(float x, float y);
      long double remainderl(long double x, long double y);

      double remquo(double x, double y, int *pquo);
      float remquof(float x, float y, int *pquo);
      long double remquol(long double x, long double y, int *pquo);

      double rint(double x);
      float rintf(float x);
      long double rintl(long double x);

      double scalbln(double x, long ex);
      float scalblnf(float x, long ex);
      long double scalblnl(long double x, long ex);
      double scalbn(double x, int ex);
      float scalbnf(float x, int ex);
      long double scalbnl(long double x, int ex);

      // C99 macros defined as C++ templates
      template<class T> bool isgreater(T x, T y);
      template<class T> bool isgreaterequal(T x, T y);
      template<class T> bool isless(T x, T y);
      template<class T> bool islessequal(T x, T y);
      template<class T> bool islessgreater(T x, T y);
      template<class T> bool isunordered(T x, T y);

[endsect]
[endsect]

[section:header_list TR1 By Header  TR1的头文件]

[section:array_header <array>]

See: [link boost_tr1.subject_list.array Fixed Size Array]\n
请见：[link boost_tr1.subject_list.array 固定大小数组] 

[endsect]

[section:cmath_header <cmath>]

See: [link boost_tr1.subject_list.special Special Functions]\n
请见：[link boost_tr1.subject_list.special 特定函数] 

See: [link boost_tr1.subject_list.c99_special C99 Special Functions]\n
请见：[link boost_tr1.subject_list.c99_special C99 特定函数] 

[endsect]

[section:complex_header <complex>]

See: [link boost_tr1.subject_list.complex Additional Overloads for Complex Number Algorithms]\n
请见：[link boost_tr1.subject_list.complex 复数算法的其它重载]

See: [link boost_tr1.subject_list.complex_trig Additional Complex Number Algorithms]\n
请见：[link boost_tr1.subject_list.complex_trig 其它复数算法] 

[endsect]

[section:functional <functional>]

See: [link boost_tr1.subject_list.ref Reference Wrapper].\n
请见：[link boost_tr1.subject_list.ref 引用包装器]

See: [link boost_tr1.subject_list.result_of Result_of].\n
请见：[link boost_tr1.subject_list.result_of Result_of].

See: [link boost_tr1.subject_list.mem_fn Member Function Wrappers].\n
请见：[link boost_tr1.subject_list.mem_fn 成员函数包装器]

See: [link boost_tr1.subject_list.bind Function Binders].\n
请见：[link boost_tr1.subject_list.bind 函数绑定器]

See: [link boost_tr1.subject_list.function Polymorphic Function Wrappers].\n
请见：[link boost_tr1.subject_list.function 多态函数包装器]

See: [link boost_tr1.subject_list.hash Hash Functions].\n
请见：[link boost_tr1.subject_list.hash 散列函数]

[endsect]

[section:memory <memory>]

See: [link boost_tr1.subject_list.ptrs Smart Pointers].\n
请见：[link boost_tr1.subject_list.ptrs 智能指针]

[endsect]

[section:random_header <random>]

See: [link boost_tr1.subject_list.random Random Numbers].\n
请见：[link boost_tr1.subject_list.random 随机数]

[endsect]

[section:regex_header <regex>]

See: [link boost_tr1.subject_list.regex Regular Expressions].\n
请见：[link boost_tr1.subject_list.regex 正则表达式] 

[endsect]

[section:tuple_header <tuple>]

See: [link boost_tr1.subject_list.tuple Tuple Types].\n
请见：[link boost_tr1.subject_list.tuple Tuple 类型]

[endsect]

[section:type_traits_header <type_traits>]

See: [link boost_tr1.subject_list.type_traits Type Traits].\n
请见：[link boost_tr1.subject_list.type_traits Type Traits].

[endsect]

[section:unordered_map_header <unordered_map>]

See: [link boost_tr1.subject_list.unordered_map Unordered Associative Map]\n
请见：[link boost_tr1.subject_list.unordered_map 无序关联 Map]

[endsect]

[section:unordered_set_header <unordered_set>]

See: [link boost_tr1.subject_list.unordered_set Unordered Associative Set].\n
请见：[link boost_tr1.subject_list.unordered_set 无序关联 Set]

[endsect]

[section:utility_header <utility>]

See: [link boost_tr1.subject_list.utility  Tuple Interface to std::pair].\n
请见：[link boost_tr1.subject_list.utility std::pair 的 tuple 接口]

[endsect]

[endsect]

[section:implementation Implementation 实现]

When Boost.TR1 is [link boost_tr1.config configured] to make use of your standard library's
native TR1 implementation, then it doesn't do very much: it just includes
the appropriate header.\n
如果 Boost.TR1 [link boost_tr1.config 被配置] 为使用你的标准库中的原生 TR1 实现，则它不需要做多少事情：它只是包含适当的头文件就行了。

When Boost.TR1 is using the Boost implementation of a particular
component, then it includes the appropriate Boost header(s) and imports
the necessary declarations in `namespace std::tr1` with using declarations.
Note that only those declarations that are part of the standard are imported:
the implementation is deliberately quite strict about not including any 
Boost-specific extensions in `namespace std::tr1`, in order to catch any
portability errors in user code.  If you really need to use Boost-specific
extensions then you should include the Boost headers directly and use the
declarations in `namespace boost::` instead.  Note that this style of implementation
is not completely standards-conforming, in particular it is not possible
to add user-defined template specializations of TR1 components
into `namespace std::tr1`.  There are also one or two Boost libraries that are not
yet fully standards conforming, any such non-conformities are documented in 
[link boost_tr1.subject_list the TR1 by subject section].  Hopefully, occurrences of non-standard 
behavior should be extremely rare in practice however.\n
如果 Boost.TR1 使用了某个组件的 Boost 实现，则它需要包含适当的 Boost 头文件并使用声明将所需的名字导入到 `namespace std::tr1` 中。
注意，只有作为标准部分的声明会被导入：本实现有意非常严格地没有将所有 Boost-特有的扩展引入到 `namespace std::tr1`，
这是为了能够捕获用户代码中的任何可移植性错误。
如果你真的需要使用 Boost-特有的扩展，则你应当直接包含 Boost 头文件，则改用 `namespace boost::` 中的声明。
注意，本实现的风格并不是完全符合标准的，它不能将用户自定义的 TR1 组件的模板特化增加到 `namespace std::tr1` 中。
还有一到两个 Boost 库尚未完全符合标准，任何与标准不符的地方都已在 [link boost_tr1.subject_list "TR1 的分类"一节 中] 说明。
不过幸好，这些不符合标准的行为在实际中极少会用到。

If you use the standard conforming header includes (in `boost/tr1/tr1`)
then these header names can sometimes conflict with existing standard library
headers (for example `shared_ptr` is added to the existing 
standard library header
`<memory>` rather than it's own header).  These headers 
forward on to your existing standard library header in one of two ways: for
gcc it uses `#include_next`, and for other compilers it uses the
macro `BOOST_TR1_STD_HEADER(header)` (defined in 
[@../../boost/tr1/detail/config.hpp boost/tr1/detail/config.hpp])
which evaluates to `#include <../include/header>`.  This
should work "straight out the box" for most compilers, but does mean that
these headers should [*never] be placed inside a 
directory called "include"
that is already in your compiler's search path.\n
如果你使用标准的头文件包含(在 `boost/tr1/tr1` 中)，则这些头文件名有时可能与现有的标准库头文件冲突(例如 `shared_ptr` 
已增加到现有的标准库头文件 `<memory>` 中而不是它自己的头文件)。这些头文件可以用以下两种方法之一前转到现有的标准库头文件：
对于 gcc，使用 `#include_next`, 而对于其它编译器则使用宏 `BOOST_TR1_STD_HEADER(header)` 
(在 [@../../boost/tr1/detail/config.hpp boost/tr1/detail/config.hpp] 中定义)，它将扩展为 `#include <../include/header>`. 
对于大多数编译器，这样就可以直接使用，但是这意味着这些头文件[*不能]被放在名为"include"且已在你的编译器搜索路径中的目录下。

[endsect]


[section:testing Testing 测试]

The test suite for Boost.TR1 is relatively lightweight; tests have been
added to the Boost.Config test suite for each new configuration macro, and
each TR1 component has a very short concept check test added.  The concept test
programs are designed only to verify that all the TR1 components 
that are
supposed to be in `namespace std::tr1` are indeed present and have standards
conforming interfaces.  There are a few test programs (those which end in the suffix 
"_tricky") which do not currently compile with the Boost.TR1 implementation, because the
relevant Boost libraries have not yet implemented the features tested; hopefully
these incompatibilities will be removed in future releases.\n
Boost.TR1 的测试组件是轻量级的；对每个新的配置宏的测试已被加入到 Boost.Config 的测试组件中，而每个 TR1 
组件只加入了一个非常短的概念检查测试。
概念测试程序被设计为只检验应该在 `namespace std::tr1` 中的所有 TR1 组件是否确实存在，以及具有符合标准的接口。
有少量测试程序(它们带有后缀"_tricky")当前尚未和 Boost.TR1 实现一起编译，因为有关的 Boost 库还没有实现要被测试的特性；
希望在以后的版本中这些不兼容性会被解决。 

The concept tests do not take account of compiler defects (quite deliberately
so); the intent is that the tests can be used to verify conformance with the
standard, both for Boost code, and for third party implementations.  Consequently
very many of these tests are known to fail with older compilers.  This should
not be taken as evidence that these compilers can not be used at all with Boost.TR1,
simply that there are features missing that make those compilers non-conforming.\n
概念测试并没有考虑编译器的缺陷(这是故意这么做的)；目的是这些测试可被用于检验 Boost 代码或第三方实现与标准的符合性。
所以这些测试中有很多都会在较老的编译器上失败。这不能作为这些编译器完全不能使用 Boost.TR1 的证明，只能说在这些编译器上缺少某些特性。

Full runtime tests for TR1 components are not in general part of this
test suite, however, it is hoped that the Boost.TR1 component authors will make 
their regular test suites compile with the standards conforming headers as well
as the Boost-specific ones. This will allow these tests to be used against the standard 
library's own TR1 implementation as well as the Boost one.\n
对 TR1 组件的完整运行期测试并不是本测试组件的一部分，不过可以期望 Boost.TR1 
组件的作者已经针对符合标准的头文件以及Boost-特有的头文件将他们的常规测试组件进行了编译。
这样，这些测试既可以用于标准库本身的 TR1 实现，也可以用于 Boost 的实现。

[endsect]






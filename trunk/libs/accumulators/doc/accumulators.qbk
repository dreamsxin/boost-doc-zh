
[library Boost.Accumulators
    [quickbook 1.3]
    [authors [Niebler, Eric]]
    [copyright 2005 2006 Eric Niebler]
    [category math]
    [id accumulators]
    [dirname accumulators]
    [purpose 
        Incremental accumulation framework and statistical accumulator library.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/  Images   ]

[def _note_                  [$images/note.png]]
[def _alert_                 [$images/caution.png]]
[def _detail_                [$images/note.png]]
[def _tip_                   [$images/tip.png]]

[/  Links   ]

[def _sample_type_           '''<replaceable>sample-type</replaceable>''']
[def _weight_type_           '''<replaceable>weight-type</replaceable>''']
[def _variate_type_          '''<replaceable>variate-type</replaceable>''']
[def _variate_tag_           '''<replaceable>variate-tag</replaceable>''']
[def _left_or_right_         '''<replaceable>left-or-right</replaceable>''']
[def _implementation_defined_ '''<replaceable>implementation-defined</replaceable>''']
[def _boost_                 [@http://www.boost.org Boost]]
[def _mpl_                   [@../../libs/mpl/index.html MPL]]
[def _mpl_lambda_expression_ [@../../libs/mpl/doc/refmanual/lambda-expression.html MPL Lambda Expression]]
[def _parameter_             [@../../libs/parameter/index.html Boost.Parameter]]
[def _accumulator_set_       [classref boost::accumulators::accumulator_set `accumulator_set<>`]]
[def _accumulator_base_      [classref boost::accumulators::accumulator_base `accumulator_base`]]
[def _depends_on_            [classref boost::accumulators::depends_on `depends_on<>`]]
[def _feature_of_            [classref boost::accumulators::feature_of `feature_of<>`]]
[def _as_feature_            [classref boost::accumulators::as_feature `as_feature<>`]]
[def _features_              [classref boost::accumulators::features `features<>`]]
[def _external_              [classref boost::accumulators::external `external<>`]]
[def _droppable_             [classref boost::accumulators::droppable `droppable<>`]]
[def _droppable_accumulator_ [classref boost::accumulators::droppable_accumulator `droppable_accumulator<>`]]
[def _extractor_             [classref boost::accumulators::tag::extractor `extractor<>`]]
[def _tail_                  [classref boost::accumulators::tag::tail `tail`]]
[def _tail_variate_          [classref boost::accumulators::tag::tail_variate `tail_variate<>`]]
[def _extract_result_        [funcref boost::accumulators::extract_result `extract_result()`]]
[def _ZKB_                   [@http://www.zkb.com Z'''&uuml;'''rcher Kantonalbank]]

[section:preface Preface 前言]

[:["It is better to be approximately right than exactly wrong."
\n"近似的正确要好于精确的错误"]
\n['-- Old adage 古谚语]]

[h2 Description 说明]

Boost.Accumulators is both a library for incremental statistical computation as
well as an extensible framework for incremental calculation in general. The library
deals primarily with the concept of an ['accumulator], which is a primitive
computational entity that accepts data one sample at a time and maintains some 
internal state. These accumulators may offload some of their computations on other
accumulators, on which they depend. Accumulators are grouped within an ['accumulator
set]. Boost.Accumulators resolves the inter-dependencies between accumulators in a
set and ensures that accumulators are processed in the proper order.
\n大致上，Boost.Accumulators 既是一个用于增量统计计算的库，也是一个用于增量计算的可扩展框架。
起初该库主要涉及 ['accumulator累加器] 概念，它是一个简单的计算实体，每次接受一个数据样本并维护一些内部状态。
这些累加器可能将其中一些计算卸给其它所依赖的累加器。多个累加器被组成一个 ['accumulator set累加器集]。
Boost.Accumulators 解决了一个累加器集中各累加器间的互相依赖，并确保各个累加器以正确的顺序进行处理。 

[endsect]

[section:user_s_guide User's Guide 用户指南]

This section describes how to use the Boost.Accumulators framework to create new
accumulators and how to use the existing statistical accumulators to perform incremental
statistical computation. For detailed information regarding specific components in
Boost.Accumulators, check the [link accumulators_framework_reference Reference] section.
\n本节描述了如何使用 Boost.Accumulators 框架来创建一个新的累加器，以及如何使用已有的统计累加器来执行增量统计计算。
关于 Boost.Accumulators 中的特定组件的详细信息，请查看 [link accumulators_framework_reference 参考] 一节。

[h2 Hello, World!]

Below is a complete example of how to use the Accumulators Framework and the 
Statistical Accumulators to perform an incremental statistical calculation. It
calculates the mean and 2nd moment of a sequence of doubles.
\n以下是一个关于如何使用累加器框架和统计累加器来执行增量统计计算的完整例子。
它计算一组 double 的平均值和二次矩。 

    #include <iostream>
    #include <boost/accumulators/accumulators.hpp>
    #include <boost/accumulators/statistics/stats.hpp>
    #include <boost/accumulators/statistics/mean.hpp>
    #include <boost/accumulators/statistics/moment.hpp>
    using namespace boost::accumulators;

    int main()
    {
        // Define an accumulator set for calculating the mean and the
        // 2nd moment ...
		// 为计算平均值和二次矩定义一个累加器集 ...
        accumulator_set<double, stats<tag::mean, tag::moment<2> > > acc;

        // push in some data ...  压入一些数据 ...
        acc(1.2);
        acc(2.3);
        acc(3.4);
        acc(4.5);

        // Display the results ...  显示结果 ...
        std::cout << "Mean:   " << mean(acc) << std::endl;
        std::cout << "Moment: " << moment<2>(acc) << std::endl;

        return 0;
    }

This program displays the following:
\n该程序输出如下： 

[pre
Mean:   2.85
Moment: 9.635
]

[section The Accumulators Framework 累加器框架]

The Accumulators Framework is framework for performing incremental calculations. Usage
of the framework follows the following pattern:
\n累加器框架是用于执行增量计算的框架。该框架的使用遵循以下模式：

* Users build a computational object, called an ['_accumulator_set_], by selecting
  the computations in which they are interested, or authoring their own computational
  primitives which fit within the framework.
  \n用户通过选择他们感兴趣的计算方法来构建一个计算对象，称为 ['_accumulator_set_]，
  或者创造他们自己的符合该框架的计算方法。
* Users push data into the _accumulator_set_ object one sample at a time.
  \n用户将数据压入 _accumulator_set_ 对象，每次一个数据样本。
* The _accumulator_set_ computes the requested quantities in the most efficient method
  possible, resolving dependencies between requested calculations, possibly cacheing
  intermediate results.
  \n _accumulator_set_ 以尽可能高效的方法来计算被请求的数量，解决各种计算方法间的依赖性，
  可能会对中间结果进行缓存。

The Accumulators Framework defines the utilities needed for defining primitive
computational elements, called ['accumulators]. It also provides the _accumulator_set_
type, described above.
\n累加器框架定义了一些工具，它们是定义基本计算元素所需要的，被称为 ['accumulators累加器]。
它还提供了前述的 _accumulator_set_ 类型。 

[h2 Terminology 术语]

The following terms are used in the rest of the documentation.
\n以下术语将在本文档中使用。

[variablelist
    [[Sample 样本]              [[#sample_type] A datum that is pushed into an _accumulator_set_.
                                 The type of the sample is the ['sample type].
								 \n被压入 _accumulator_set_ 的数据。样本的类型为 ['sample type样本类型]。]]
    [[Weight 权重]              [[#weight_type] An optional scalar value passed along with the
                                 sample specifying the weight of the sample. Conceptually, each
                                 sample is multiplied with its weight. The type of the weight is
                                 the ['weight type].
								 \n与样本一起传递的一个可选的比例值，用于指定该样本的权重。
								 概念上，每个样本要与其权重相乘。权重的类型为 ['weight type权重类型]。]]
    [[Feature 特征]             [An abstract primitive computational entity. When defining an
                                 _accumulator_set_, users specify the features in which they are
                                 interested, and the _accumulator_set_ figures out which
                                 ['accumulators] would best provide those features. Features may
                                 depend on other features. If they do, the accumulator set figures
                                 out which accumulators to add to satisfy the dependencies.
								 \n一个抽象的基本计算实体。在定义一个 _accumulator_set_ 时，
								 用户指定他们感兴趣的特征，然后 _accumulator_set_ 确定哪些['累加器]最适合提供这些特征。
								 一个特征可以依赖于其它特征。如果它们有依赖关系，累加器集负责决定加入哪些累加器以满足依赖关系。]]
    [[Accumulator 累加器]       [A concrete primitive computational entity. An accumulator is a
                                 concrete implementation of a feature. It satisfies exactly one
                                 abstract feature. Several different accumulators may provide the
                                 same feature, but may represent different implementation strategies.
								 \n一个具体的计算实体。累加器是特征的具体实现。它精确满足某个抽象特征。
								 多个不同的累加器可以提供相同的特征，但可能代表不同的实现策略。]]
    [[Accumulator Set 累加器集] [A collection of accumulators. An accumulator set is specified with
                                 a sample type and a list of features. The accumulator set uses this
                                 information to generate an ordered set of accumulators depending on
                                 the feature dependency graph. An accumulator set accepts samples one
                                 datum at a time, propogating them to each accumulator in order. At any
                                 point, results can be extracted from the accumulator set.
								 \n一组累加器。累加器集被指定了一个样本类型和一组特征。
								 累加器集使用这些信息并根据特征依赖关系图来生成累加器的一个有序集合。
								 累加器集每次接受一个数据样本，并将它们按顺序传播给每个累加器。
								 任何时间点都可以从累加器集获取相应结果。]]
    [[Extractor 提取器]         [A function or function object that can be used to extract a result
                                 from an _accumulator_set_.
								 \n一个函数或函数对象，可用于从一个 _accumulator_set_ 取出结果。]]
]

[h2 Overview 概览]

Here is a list of the important types and functions in the Accumulator Framework and
a brief description of each.
\n以下是在累加器框架中最重要的类型和函数，以及它们各自的说明。 

[table Accumulators Toolbox 累加器工具盒
    [[Tool 工具]         [Description 说明]]
    [[_accumulator_set_] [This is the most important type in the Accumulators Framework.
                          It is a collection of accumulators. A datum pushed into an 
                          _accumulator_set_ is forwarded to each accumulator, in an order
                          determined by the dependency relationships between the
                          accumulators. Computational results can be extracted from an
                          accumulator at any time.
						  \n这是累加器框架中最重要的类型。它是一组累加器。一个数据被压入一个
						  _accumulator_set_ 后将被按照由各累加器间的依赖关系所决定的顺序前转至每个累加器。
						  计算的结果可以在任何时候从累加器上取出。]]
    [[_depends_on_     ] [Used to specify which other features a feature depends on.
	                      \n用于指定一个特征所依赖的其它特征。]]
    [[_feature_of_     ] [Trait used to tell the Accumulators Framework that, for the purpose
                          of feature-based dependency resolution, one feature should be
                          treated the same as another.
						  \n一个 Trait，用于告诉累加器框架一个特征与其它某个特征具有相同的处理结果，
						  其目的是为了基于特征的依赖性决议。]]
    [[_as_feature_     ] [Used to create an alias for a feature. For example, if there are
                          two features, fast_X and accurate_X, they can be mapped to
                          X(fast) and X(accurate) with _as_feature_. This is just syntactic
                          sugar.
						  \n用于创建一个特征的别名。例如，如果有两个特征 fast_X 和 accurate_X，
						  它们可以通过 _as_feature_ 被映射到 X(fast) 和 X(accurate)。这只是一个语法糖。]]
    [[_features_       ] [An _mpl_ sequence. We can use _features_ as the second template
                          parameter when declaring an _accumulator_set_.
						  \n一个 _mpl_ 序列。我们可以在声明 _accumulator_set_ 时将 _features_ 
						  用作第二个模板参数。]]
    [[_external_       ] [Used when declaring an _accumulator_set_. If the weight type is
                          specified with _external_, then the weight accumulators are
                          assumed to reside in a separate accumulator set which will be passed
                          in with a named parameter.
						  \n在声明 _accumulator_set_ 时使用。如果权重类型是通过 _external_
						  指定的，则权重累加器被假定位于一个独立的累加器集，它将以一个命名参数的方式传递。]]
    [[_extractor_      ] [A class template useful for creating an extractor function object.
                          It is parameterized on a feature, and it has member functions for
                          extracting from an _accumulator_set_ the result corresponding to
                          that feature.
						  \n一个类模板，用于创建一个提取器函数对象。它按特征进行参数化，
						  它有一些成员函数，从 accumulator_set_ 获取与特征相对应的结果。]]
]

[section Using [^accumulator_set<>] 使用[^accumulator_set<>]]

Our tour of the _accumulator_set_ class template begins with the forward declaration:
\n我们的 _accumulator_set_ 类模板之旅从这个前向声明开始：

    template< typename Sample, typename Features, typename Weight = void >
    struct accumulator_set;

The template parameters have the following meaning:
\n模板参数具有以下意义：

[variablelist
    [[`Sample`]     [The type of the data that will be accumulated.
	                 \n将被累计的数据的类型。]]
    [[`Features`]   [An _mpl_ sequence of features to be calculated.
	                 \n要计算的多个特征的 _mpl_ 序列。]]
    [[`Weight`]     [The type of the (optional) weight paramter.
	                 \n(可选的)权重参数的类型。]]
]

For example, the following line declares an _accumulator_set_ that will accept
a sequence of doubles one at a time and calculate the min and mean:
\n例如，以下一行代码声明了一个 _accumulator_set_，它将一次一个地接受一组 double，
并计算最小值和平均值：

    accumulator_set< double, features< tag::min, tag::mean > > acc;

Notice that we use the _features_ template to specify a list of features to be calculated.
_features_ is an MPL sequence of features.
\n注意，我们使用了 _features_ 模板来指定一个要计算的特征列表。_features_
是多个特征组成的一个 MPL 序列。

[note _features_ is a synonym of `mpl::vector<>`. In fact, we could use `mpl::vector<>`
 or any MPL sequence if we prefer, and the meaning would be the same.
 \n _features_ 是 `mpl::vector<>` 一个同义字。事实上，如果愿意，我们可以使用
 `mpl::vector<>` 或任何 MPL 序列，意思是一样的。]

Once we have defined an _accumulator_set_, we can then push data into it,
and it will calculate the quantities you requested, as shown below.
\n一旦我们定义了一个 _accumulator_set_，我们就可以将数据压进去给它，
它就会对你所需要的数量进行计算，如下所示：

    // push some data into the accumulator_set ... 
	// 压入一些数据到 accumulator_set ... 
    acc(1.2);
    acc(2.3);
    acc(3.4);

Since _accumulator_set_ defines its accumulate function to be the function call operator,
we might be tempted to use an _accumulator_set_ as a UnaryFunction to a standard
algorithm such as `std::for_each`. That's fine as long as we keep in mind that the standard
algorithms take UnaryFunction objects by value, which involves making a copy of the
_accumulator_set_ object. Consider the following:
\n因为 _accumulator_set_ 将它的累加器函数定义为函数调用操作符，所以我们可以将一个
_accumulator_set_ 作为一个 UnaryFunction 用于标准算法，如 `std::for_each`。
只要我们牢记标准算法是以传值方式接受 UnaryFunction 对象的就可以了，即会复制一份
_accumulator_set_ 对象。考虑以下代码：

    // The data for which we wish to calculate statistical properties:
    // 我们想要计算统计特征的数据：
    std::vector< double > data( /* stuff */ );

    // The accumulator set which will calculate the properties for us: 
    // 为我们计算统计特征的累加器集：	
    accumulator_set< double, features< tag::min, tag::mean > > acc;

    // Use std::for_each to accumulate the statistical properties:
    // 使用 std::for_each 来累计相关统计特征：
    acc = std::for_each( data.begin(), data.end(), acc );

Notice how we must assign the return value of `std::for_each` back to the _accumulator_set_.
This works, but some accumulators are not cheap to copy. For
example, the _tail_ and _tail_variate_ accumulators must store a `std::vector<>`, so copying
these accumulators involves a dynamic allocation. We might be better off in this
case passing the accumulator by reference, with the help of `boost::bind()` and
`boost::ref()`. See below:
\n请留意，我们必须将 `std::for_each` 的返回值赋回给 _accumulator_set_。
这样是可以的，但是有些累加器在复制时代价并不低。例如，累加器 _tail_ 和 _tail_variate_
累加器必须保存一个 `std::vector<>`，所以复制这些累加器将包含一次动态内存分配。在这种情况下，
以引用方式传递累加器也许更好，这时可以使用 `boost::bind()` 和 `boost::ref()`。如下：

    // The data for which we wish to calculate statistical properties:
    // 我们想要计算统计特征的数据：
    std::vector< double > data( /* stuff */ );

    // The accumulator set which will calculate the properties for us:
    // 为我们计算统计特征的累加器集：
    accumulator_set< double, features< tag::tail<left> > > acc( 
        tag::tail<left>::cache_size = 4 );

    // Use std::for_each to accumulate the statistical properties:
    // 使用 std::for_each 来累计相关统计特征：
    std::for_each( data.begin(), data.end(), bind<void>( ref(acc), _1 ) );

Notice now that we don't care about the return value of `std::for_each()` anymore because
`std::for_each()` is modifying `acc` directly.
\n现在请留意，我们不再关心 `std::for_each()` 的返回值了，因为 `std::for_each()` 
可以直接修改 `acc` 了。

[note To use `boost::bind()` and `boost::ref()`, you must `#include` [^<boost/bind.hpp>]
and [^<boost/ref.hpp>]
\n要使用 `boost::bind()` 和 `boost::ref()`，你必须 `#include` [^<boost/bind.hpp>] 和 
[^<boost/ref.hpp>]]

[endsect]

[section Extracting Results 取出结果]

Once we have declared an _accumulator_set_ and pushed data into it, we need to be able
to extract results from it. For each feature we can add to an _accumulator_set_, there
is a corresponding extractor for fetching its result. Usually, the extractor has the
same name as the feature, but in a different namespace. For example, if we accumulate
the `tag::min` and `tag::max` features, we can extract the results with the `min` and `max`
extractors, as follows:
\n一旦我们声明了一个 _accumulator_set_ 并且向它压入数据，我们就必须可以从它获取结果。
对于每一个我们可以加入到 _accumulator_set_ 中的特征，都有一个对应的提取器来获取结果。
通常，该提取器具有与特征相同的名字，但是是在另一个名字空间中。例如，如果我们要累计
`tag::min` 和 `tag::max` 特征，则可以用 `min` 和 `max` 提取器获取结果，如下： 

    // Calculate the minimum and maximum for a sequence of integers.
    // 计算一组整数的最小值和最大值
    accumulator_set< int, features< tag::min, tag::max > > acc;
    acc( 2 );
    acc( -1 );
    acc( 1 );

    // This displays "(-1, 2)"  将显示 "(-1, 2)"
    std::cout << '(' << min( acc ) << ", " << max( acc ) << ")\n";

The extractors are all declared in the `boost::accumulators::extract` namespace, but they
are brought into the `boost::accumulators` namespace with a `using` declaration.
\n提取器全都在名字空间 `boost::accumulators::extract` 中声明，不过可以通过一个 `using`
声明将它们注入 `boost::accumulators` 名字空间。

[tip On the Windows platform, `min` and `max` are preprocessor macros defined in [^WinDef.h].
 To use the `min` and `max` extractors, you should either compile with `NOMINMAX` defined, or
 you should invoke the extractors like: `(min)( acc )` and `(max)( acc )`. The parentheses
 keep the macro from being invoked.
 \n在 Windows 平台上，`min` 和 `max` 是在 [^WinDef.h] 中定义的预处理器。
 要使用 `min` 和 `max` 提取器，你应该要么在编译时定义 `NOMINMAX`，要么象这样来调用提取器：
 `(min)( acc )` 和 `(max)( acc )`。其中的括号将阻止宏调用。]

Another way to extract a result from an _accumulator_set_ is with the
`extract_result()` function. This can be more convenient if there isn't an extractor
object handy for a certain feature. The line above which displays results could 
equally be written as:
\n另一种从 _accumulator_set_ 中取出结果的方法是，使用 `extract_result()` 函数。
如果某个特征不存在方便的提取器对象，这样会更方便一些。上述例子中显示结果的那行代码也可以写为： 

    // This displays "(-1, 2)"  将显示 "(-1, 2)"
    std::cout << '('  << extract_result< tag::min >( acc )
              << ", " << extract_result< tag::max >( acc ) << ")\n";

Finally, we can define our own extractor using the _extractor_ class template. For
instance, another way to avoid the `min` / `max` macro business would be to define 
extractors with names that don't conflict with the macros, like this:
\n最后，我们用 _extractor_ 类模板定义我们自己的提取器。例如，避免 `min` / `max`
宏的麻烦的另一种方法是，定义另一个名字不冲突的提取器，如下：

    extractor< tag::min > min_;
    extractor< tag::min > max_;

    // This displays "(-1, 2)"  将显示 "(-1, 2)"
    std::cout << '(' << min_( acc ) << ", " << max_( acc ) << ")\n";

[endsect]

[section Passing Optional Parameters 传递可选参数]

Some accumulators need initialization parameters. In addition, perhaps some auxiliary
information needs to be passed into the _accumulator_set_ along with each sample.
Boost.Accumulators handles these cases with named parameters from the _parameter_
library.
\n有些累加器需要初始化参数。另外，可能还有些辅助信息要和每个样本一起传给 _accumulator_set_。
Boost.Accumulators 通过来自于 _parameter_ 库的命名参数来处理这些情况。

For example, consider the _tail_ and _tail_variate_ features. _tail_ keeps
an ordered list of the largest [^['N]] samples, where [^['N]] can be specified at
construction time. Also, the _tail_variate_ feature, which depends on _tail_, keeps
track of some data that is covariate with the [^['N]] samples tracked by _tail_. The
code below shows how this all works, and is described in more detail below.
\n以 _tail_ 和 _tail_variate_ 特征为例。_tail_ 保存了最大 [^['N]] 个样本的一个有序列表，
其中 [^['N]] 可以在构造时指定。同样，_tail_variate_ 特征依赖于 _tail_，它跟踪某些跟随
_tail_ 所保存的 [^['N]] 个样本而变化的数据。以下代码示范了它们如何工作，后面有更多细节的说明。

    // Define a feature for tracking covariate data
    // 定义一个特征以跟踪变化的数据
    typedef tag::tail_variate< int, tag::covariate1, left > my_tail_variate_tag;

    // This will calculate the left tail and my_tail_variate_tag for N == 2
    // using the tag::tail<left>::cache_size named parameter
    // 以下使用 tag::tail<left>::cache_size 命名参数针对 N == 2 计算左 tail 和 my_tail_variate_tag
    accumulator_set< double, features< my_tail_variate_tag > > acc( 
        tag::tail<left>::cache_size = 2 );

    // push in some samples and some covariates by using 
    // the covariate1 named parameter
    // 使用 covariate1 命名参数压入一些数据和一些关联值
    acc( 1.2, covariate1 =  12 );
    acc( 2.3, covariate1 = -23 );
    acc( 3.4, covariate1 =  34 );
    acc( 4.5, covariate1 = -45 );

    // Define an extractor for the my_tail_variate_tag feature
    // 为 my_tail_variate_tag 特征定义一个提取器
    extractor< my_tail_variate_tag > my_tail_variate;
    
    // Write the tail statistic to std::cout. This will print "4.5, 3.4, "
    // 打印 tail 统计值到 std::cout。将打印 "4.5, 3.4, "
    std::ostream_iterator< double > dout( std::cout, ", " );
    std::copy( tail( acc ).begin(), tail( acc ).end(), dout );
    
    // Write the tail_variate statistic to std::cout. This will print "-45, 34, "
    // 打印 tail_variate 统计值到 std::cout。将打印 "-45, 34, "
    std::ostream_iterator< int > iout( std::cout, ", " );
    std::copy( my_tail_variate( acc ).begin(), my_tail_variate( acc ).end(), iout );

There are several things to note about the code above. First, notice that we didn't have
to request that the _tail_ feature be calculated. That is implicit because the _tail_variate_
feature depends on the _tail_ feature. Next, notice how the `acc` object
is initialized: `acc( tag::tail<left>::cache_size = 2 )`. Here, `cache_size` is a named parameter.
It is used to tell the _tail_ and _tail_variate_ accumulators how many samples and
covariates to store. Conceptually, every construction parameter is made available to
every accumulator in an accumulator set. 
\n以上代码中有几个要注意的事情。首先，注意我们不必要求 _tail_ 特征被计算。这是隐含的，
因为 _tail_variate_ 特征依赖于 _tail_ 特征。其次，留意如何初始化 `acc` 对象：
`acc( tag::tail<left>::cache_size = 2 )`。这里的 `cache_size` 是一个命名参数。
它用于通知 _tail_ 和 _tail_variate_ 累加器要保存多少个样本和关联值。
概念上，每个构造参数都可以用于累加器集中的每个累加器。

We also use a named parameter to pass covariate data into the accumulator set along with
the samples. As with the constructor parameters, all parameters to the accumulate function
are made available to all the accumulators in the set. In this case, only the accumulator
for the `my_tail_variate` feature would be interested in the value of the `covariate1` named
parameter.
\n我们还使用了一个命名参数来将关联数据和样本一起传递给累加器集。和构造函数参数一样，
给累加器函数的所有参数都可以用于累加器集中的所有累加器。在这种情况下，只有 `my_tail_variate`
特征的累加器会关心 `covariate1` 命名参数的值。

We can make one final observation about the example above. Since _tail_ and _tail_variate_
are multi-valued features, the result we extract for them is represented as an iterator
range. That is why we can say `tail( acc ).begin()` and `tail( acc ).end()`.
\n对于上述例子，我们可以得到最后一个结果。由于 _tail_ 和 _tail_variate_ 都是多值特征，
所以我们从它们所获取的结果要表示为一个整数区间。这就是为什么我们使用 `tail( acc ).begin()`
和 `tail( acc ).end()` 的原因。

Even the extractors can accept named parameters. In a bit, we'll see a situation where that
is useful.
\n甚至提取器也可以接受命名参数。稍后我们将看到这样的情况。

[endsect]

[section Weighted Samples 加权样本]

Some accumulators, statistical accumulators in particular, deal with data that are
['weighted]. Each sample pushed into the accumulator has an associated weight, by which
the sample is conceptually multiplied. The Statistical Accumulators Library provides an 
assortment of these weighted statistical accumulators. And many unweighted statistical
accumulators have weighted variants. For instance, the weighted variant of the `sum`
accumulator is called `weighted_sum`, and is calculated by accumulating all the
samples multiplied by their weights.
\n有些累加器，尤其是统计累加器，要处理['加权]的数据。压入累加器的每个样本都具有一个相应的权重，
样本应与权重相乘。统计累加器库提供了一类这样的加权统计累加器。许多非加权统计累加器都具有加权的变体。
例如，`sum` 累加器的加权变体名为 `weighted_sum`，它通过累加所有样本与权重的乘积进行计算。

To declare an _accumulator_set_ that accepts weighted samples, you must specify the
type of the weight parameter as the 3rd template parameter, as follows:
\n要声明一个接受加权样本的 _accumulator_set_，你必须用第三个模板参数指定权重参数的类型，如下：

    // 3rd template parameter 'int' means this is a weighted
    // accumulator set where the weights have type 'int'
    // 第三个模板参数 'int' 表示这是一个加权累加器集，权重的类型为 'int'
    accumulator_set< int, features< tag::sum >, int > acc;

When you specify a weight, all the accumulators in the set are replaced with
their weighted equivalents. For example, the above _accumulator_set_ declaration
is equivalent to the following:
\n当你指定了一个权重，累加器集中的所有累加器都会被替换为各自的加权变体。
例如，以上的 _accumulator_set_ 声明相当于：

    // Since we specified a weight, tag::sum becomes tag::weighted_sum
    // 由于我们指定了权重，tag::sum 变为了 tag::weighted_sum
    accumulator_set< int, features< tag::weighted_sum >, int > acc;

When passing samples to the accumulator set, you must also specify the 
weight of each sample. You can do that with the `weight` named parameter,
as follows:
\n在传递样本给累加器集时，你必须指定每个样本的权重。你可以通过 `weight` 命名参数来传递，如下：

    acc(1, weight = 2); //   1 * 2
    acc(2, weight = 4); //   2 * 4
    acc(3, weight = 6); // + 3 * 6
                        // -------
                        // =    28

You can then extract the result with the `sum()` extractor, as follows:
\n然后你就可以用 `sum()` 提取器来取出结果，如下：

    // This prints "28"  打印 "28"
    std::cout << sum(acc) << std::endl;

[note When working with weighted statistical accumulators from the Statistical
Accumulators Library, be sure to include the appropriate header. For instance, 
`weighted_sum` is defined in `<boost/accumulators/statistics/weighted_sum.hpp>`.
\n使用来自统计累加器库的加权统计累加器时，请确认已包含合适的头文件。例如，
`weighted_sum` 的定义位于 `<boost/accumulators/statistics/weighted_sum.hpp>` 中。]

[endsect]

[section Numeric Operators Sub-Library 数学操作符子库]

This section describes the function objects in the `boost::numeric` namespace, which
is a sub-library that provides function objects and meta-functions corresponding
to the infix operators in C++.
\n这一节描述位于 `boost::numeric` 名字空间的函数对象，它是一个子库，
提供了与C++中缀操作符相对应的函数对象和元函数。

In the `boost::numeric::operators` namespace are additional operator overloads for
some useful operations not provided by the standard library, such as multiplication 
of a `std::complex<>` with a scalar.
\n在 `boost::numeric::operators` 名字空间中，是一些在标准库中没有提供的但很有用的操作符的重载，
如 `std::complex<>` 与标量的乘法。

In the `boost::numeric::functional` namespace are function object equivalents of 
the infix operators. These function object types are heterogeneous, and so are more 
general than the standard ones found in the [^<functional>] header. They use the
Boost.Typeof library to deduce the return types of the infix expressions they
evaluate. In addition, they look within the `boost::numeric::operators` namespace
to consider any additional overloads that might be defined there.
\n在 `boost::numeric::functional` 名字空间中，是与中缀操作符相等价的函数对象。
这些函数对象的类型是异类的，所以比在 [^<functional>] 头文件中的标准函数对象更为通用。
它们使用 Boost.Typeof 库来推断所要求值的中缀表达式的返回类型。另外，它们在 
`boost::numeric::operators` 名字空间内部查找可能定义的重载。

In the `boost::numeric` namespace are global polymorphic function objects 
corresponding to the function object types defined in the `boost::numeric::functional`
namespace. For example, `boost::numeric::plus(a, b)` is equivalent to
`boost::numeric::functional::plus<A, B>()(a, b)`, and both are equivalent to
`using namespace boost::numeric::operators; a + b;`.
\n在 `boost::numeric` 名字空间中，是与定义在 `boost::numeric::functional`
名字空间中的函数对象类型相对应的全局多态函数对象。例如，`boost::numeric::plus(a, b)`
等价于 `boost::numeric::functional::plus<A, B>()(a, b)`，它们都等价于
`using namespace boost::numeric::operators; a + b;`。 

The Numeric Operators Sub-Library also gives several ways to sub-class and
a way to sub-class and specialize operations. One way uses tag dispatching on
the types of the operands. The other way is based on the compile-time
properties of the operands.
\n数字操作符子库还给出几种子类化的方法，和一种子类化与特化操作的方法。
一种方法是用 tag 来基于操作数的类型进行分派。另一种方法则基于操作数的编译期属性。

[endsect]

[section Extending the Accumulators Framework 对累加器框架进行扩展]

This section describes how to extend the Accumulators Framework by defining new accumulators,
features and extractors. Also covered are how to control the dependency resolution of
features within an accumulator set.
\n这一节描述如何通过定义新的累加器、特征和提取器来扩展这个累加器框架。
还有如何控制在累加器集中各个特征的依赖关系决议。

[section Defining a New Accumulator 定义新的累加器]

All new accumulators must satisfy the [link
accumulators.user_s_guide.the_accumulators_framework.concepts.accumulator_concept Accumulator
Concept]. Below is a sample class that satisfies the accumulator concept, which simply sums
the values of all samples passed into it.
\n所有新的累加器都必须满足 [link accumulators.user_s_guide.the_accumulators_framework.concepts.accumulator_concept 累加器概念]。
以下是一个满足累加器概念的简单类，它对所有传入的样本进行求和。

    #include <boost/accumulators/framework/accumulator_base.hpp>
    #include <boost/accumulators/framework/parameters/sample.hpp>
    
    namespace boost {                           // Putting your accumulators in the
    namespace accumulators {                    // impl namespace has some advantages. See below.
    namespace impl {                            // 将你的累加器置于 impl 名字空间有一些好处。具体见后。
    
    template<typename Sample>
    struct sum_accumulator                      // All accumulators should inherit from accumulator_base.
      : accumulator_base                        // 所有累加器都应继承自 accumulator_base。
    {
        typedef Sample result_type;             // The type returned by result() below. 后述 result() 的返回类型。
        
        template<typename Args>                 // The constructor takes an argument pack. 构造函数接受一个参数包。
        sum_accumulator(Args const & args)
          : sum(args[sample | Sample()])        // Maybe there is an initial value in the argument pack.
        {                                       // ('sample' is defined in sample.hpp, included above.)
        }                                       // 参数包中可能有初始值('sample'定义于sample.hpp，前面已包含)。
        
        template<typename Args>                 // The accumulate function is the function
        void operator ()(Args const & args)     // call operator, and it also accepts an argument pack.
        {                                       // 累加函数是函数调用操作符，它也接受一个参数包。
            this->sum += args[sample];
        }
        
        result_type result(dont_care) const     // The result function will also be passed an argument pack,
        {                                       // but we don't use it here, so we use "dont_care" as the argument type.
            return this->sum;                   // result 函数也被传入一个参数包，但我们不使用它，所以用"dont_care"作为参数类型。
        }
    private:
        Sample sum;
    };
    
    }}}

Much of the above should be pretty self-explanitory, except for the use of argument packs
which may be confusing if you have never used the _parameter_ library before. An argument
pack is a cluster of values, each of which can be accessed with a key. So `args[sample]`
extracts from the pack the value associated with the `sample` key. And the cryptic
`args[sample | Sample()]` evaluates to the value associated with the `sample` key if it
exists, or a default-constructed `Sample` if it doesn't.
\n上面多数代码都可以很好地自解释，除了对参数包的使用可能会让你糊涂，如果你以前从来没有用过 
_parameter_ 库的话。一个参数包是一簇值，其中每一个都可以通过键值来访问。所以可以使用 
`args[sample]` 从包中取出与 `sample` 键相关联的值。而诡异的 `args[sample | Sample()]` 
将会在 `sample` 键存在时求出其关联值，或者在该键不存在时给出一个缺省构造的 `Sample`。

The example above demonstrates the most common attributes of an accumulator. There are
other optional member functions that have special meaning. In particular:
\n以上例子示范了一个累加器最常用的属性。还有其它一些可选的成员函数具有特殊的意义。特别是：

[variablelist Optional Accumulator Member Functions 可选的累加器成员函数
[[[^on_drop(Args)]]         [Defines an action to be taken when this accumulator is
                             dropped. See the section on
                             [link accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.droppable_accumulators
                              Droppable Accumulators].
                              \n定义一个动作，在该累加器被删除时执行。请见 [link accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.droppable_accumulators 可删除累加器]。]]
]

[h3 Accessing Other Accumulators in the Set 访问集合中的其它累加器]

Some accumulators depend on other accumulators within the same accumulator set. In those
cases, it is necessary to be able to access those other accumulators. To make this possible,
the _accumulator_set_ passes a reference to itself when invoking the member functions of
its contained accumulators. It can be accessed by using the special `accumulator` key with
the argument pack. Consider how we might implement `mean_accumulator`:
\n有些累加器要依赖于同一个累加器集中的其它累加器。这时，它需要可以访问那些其它累加器。
为此，_accumulator_set_ 在执行所含累加器的成员函数时会传入一个它自身的引用。
它可以通过对参数包使用特定的 `accumulator` 键来访问。看一下我们可能会如何实现 `mean_accumulator`：

    // Mean == (Sum / Count) 平均值 == (总和 / 数量)
    template<typename Sample>
    struct mean_accumulator : accumulator_base
    {
        typedef Sample result_type;
        mean_accumulator(dont_care) {}

        template<typename Args>
        result_type result(Args const &args) const
        {
            return sum(args[accumulator]) / count(args[accumulator]);
        }
    };

`mean` depends on the `sum` and `count` accumulators. (We'll see in the next section how
to specify these dependencies.) The result of the mean accumulator is merely the result of 
the sum accumulator divided by the result of the count accumulator. Consider how we write
that: `sum(args[accumulator]) / count(args[accumulator])`. The expression `args[accumulator]`
evaluates to a reference to the _accumulator_set_ that contains this `mean_accumulator`. It
also contains the `sum` and `count` accumulators, and we can access their results with the
extractors defined for those features: `sum` and `count`.
\n `mean` 依赖于 `sum` 和 `count` 累加器。(在下一节我们将看到如何指定这些依赖关系)。
mean 累加器的结果不过是 sum 累加器的结果除以 count 累加器的结果。看看我们是如何写的：
`sum(args[accumulator]) / count(args[accumulator])`。表达式 `args[accumulator]` 
被求值为包含这个 `mean_accumulator` 的 _accumulator_set_ 的引用。它同时还包含了 `sum` 
和 `count` 累加器，所以我们可以通过为特征 `sum` 和 `count` 所定义的提取器来访问它们的结果。

[note Accumulators that inherit from _accumulator_base_ get an empty `operator ()`, so
 accumulators like `mean_accumulator` above need not define one.
 \n继承自 _accumulator_base_ 的累加器得到一个空的 `operator ()`, 因此象上述 
 `mean_accumulator` 这样的累加器无需再定义一个。]

All the member functions that accept an argument pack have access to the enclosing 
_accumulator_set_ via the `accumulator` key, including the constructor. The
accumulators within the set are constructed in an order determined by their interdependencies.
As a result, it is safe for an accumulator to access one on which it depends during construction.
\n所有接受参数包的成员函数都可以通过 `accumulator` 键访问它所在的 _accumulator_set_，
包含构造函数。累加器集中的累加器是按照一个由它们的依赖关系所决定的顺序来构造的。
因此，累加器在构造期间访问一个它所依赖的累加器是安全的。

[h3 Infix Notation and the Numeric Operators Sub-Library 中缀表示法和数学操作符子库]

Although not necessary, it can be a good idea to put your accumulator implementations in 
the `boost::accumulators::impl` namespace. This namespace pulls in any operators defined
in the `boost::numeric::operators` namespace with a using directive. The Numeric Operators 
Sub-Library defines some additional overloads that will make your accumulators work with 
all sorts of data types.
\n虽然不是必须，但是将你的累加器实现置于 `boost::accumulators::impl` 名字空间下是一个好主意。
这个名字空间通过 using 指示符注入了在 `boost::numeric::operators` 名字空间中定义的所有操作符。
数学操作符子库定义了一些额外的重载，这样可以让你的累加器与所有数据类型共同工作。

Consider `mean_accumulator` defined above. It divides the sum of the samples by the count.
The type of the count is `std::size_t`. What if the sample type doesn't define division by
`std::size_t`? That's the case for `std::complex<>`. You might think that if the sample type
is `std::complex<>`, the code would not work, but in fact it does. That's because
Numeric Operators Sub-Library defines an overloaded `operator/` for `std::complex<>` 
and `std::size_t`. This operator is defined in the `boost::numeric::operators` namespace and
will be found within the `boost::accumulators::impl` namespace. That's why it's a good idea
to put your accumulators there.
\n看一下前面定义的 `mean_accumulator`。它要将样本的总和除以数量。数量的类型是 `std::size_t`。
如果样本类型没有定义与 `std::size_t` 的除法，那会怎样？对于 `std::complex<>` 就是如此。
你可能想，如果样本类型是 `std::complex<>`，这段代码将不能工作，但事实上它可以。
这是因为数学操作符子库为 `std::complex<>` 和 `std::size_t` 定义了一个重载的 `operator/`。
这个操作符定义于 `boost::numeric::operators` 名字空间中，可以在 `boost::accumulators::impl`
名字空间内查找到。这就是为什么说将你的累加器放在那里是一个好主意的原因。

[h3 Droppable Accumulators 可删除累加器]

The term "droppable" refers to an accumulator that can be removed from the _accumulator_set_.
You can request that an accumulator be made droppable by using the _droppable_ class template.
\n术语 "可删除" 是指一个累加器可以从 _accumulator_set_ 中删掉。
你可以用 _droppable_ 类模板来指定一个累加器是可删除的。

    // calculate sum and count, make sum droppable:
    // 计算 sum 和 count，把 sum 定义为可删除：
    accumulator_set< double, features< tag::count, droppable<tag::sum> > > acc;

    // add some data 加入一些数据
    acc(3.0);
    acc(2.0);

    // drop the sum (sum is 5 here) 删除 sum (现在的总和为5)
    acc.drop<tag::sum>();
    
    // add more data 再加入一些数据
    acc(1.0);
    
    // This will display "3" and "5"
    // 将显示 "3" 和 "5"
    std::cout << count(acc) << ' ' << sum(acc);    

Any accumulators that get added to an accumulator set in order to satisfy
dependencies on droppable accumulators are themselves droppable. Consider
the following accumulator:
\n为了满足某些可删除累加器的依赖关系而自动加入到累加器集中的累加器，其本身也是可删除的。
考虑以下累加器：

    // Sum is not droppable. Mean is droppable. Count, brought in to 
    // satisfy mean's dependencies, is implicitly droppable, too.
    // Sum 不是可删除的。Mean 是可删除的。为了满足 mean 的依赖关系而带入的 Count 也是可删除的。
    accumulator_set< double, features< tag::sum, droppable<tag::mean> > > acc;

`mean` depends on `sum` and `count`. Since `mean` is droppable, so too is `count`.
However, we have explictitly requested that `sum` be not droppable, so it isn't. Had
we left `tag::sum` out of the above declaration, the `sum` accumulator would have
been implicitly droppable.
\n`mean` 依赖于 `sum` 和 `count`。由于 `mean` 是可删除的，所以 `count` 也是。但是，
我们显式指定了 `sum` 是不可删除的，所以它不是。如果我们在上述声明中去掉 `tag::sum`，
则 `sum` 累加器也将是可删除的。

A droppable accumulator is reference counted, and is only really dropped after all the
accumulators that depend on it have been dropped. This can lead to some surprising
behavior in some situations. 
\n可删除累加器是引用计数的，它只在所有依赖于它的累加器都被删除后才真正删除。
在某些情况下可能会导致一些令人惊讶的行为。 
    
    // calculate sum and mean, make mean droppable. 
    // 计算 sum 和 mean，其中 mean 是可删除的。
    accumulator_set< double, features< tag::sum, droppable<tag::mean> > > acc;
    
    // add some data 加入一些数据
    acc(1.0);
    acc(2.0);
    
    // drop the mean. mean's reference count
    // drops to 0, so it's really dropped. So
    // too, count's reference count drops to 0
    // and is really dropped.
    // 删除 mean。mean 的引用计数降至0，因此它被删除。
    // 同样，count 的引用计数也降至0，所以也被删除。
    acc.drop<tag::mean>();
    
    // add more data. Sum continues to accumulate!
    // 再加入一些数据。Sum 继续进行累加！
    acc(3.0);
    
    // This will display "6 2 3"
    // 以下将打印 "6 2 3"
    std::cout << sum(acc) << ' '
              << count(acc) << ' '    
              << mean(acc);

Note that at the point at which `mean` is dropped, `sum` is 3, `count` is 2, and
therefore `mean` is 1.5. But since `sum` continues to accumulate even after `mean`
has been dropped, the value of `mean` continues to change. If you want to remember
the value of `mean` at the point it is dropped, you should save its value into
a local variable.
\n留意 `mean` 被删除的时间点，此时 `sum` 为 3，`count` 为 2，因此 `mean` 为 1.5。
但是由于 `sum` 在 `mean` 被删除之后继续累加，所以 `mean` 的值会继续变化。
如果你想在 `mean` 被删除的时候记住它的值，你应该将它的值保存在一个局部变量中。

The following rules more precisely specify how droppable and non-droppable
accumulators behave within an accumulator set.
\n以下规则更好地说明了在一个累加器集内部的可删除累加器和不可删除累加器的行为。

* There are two types of accumulators: droppable and non-droppable.
  The default is non-droppable.
  \n有两类累加器：可删除的和不可删除的。缺省是不可删除的。
* For any feature `X`, both `X` and `droppable<X>` satisfy the `X` dependency.
  \n对于任意特征 `X`，`X` 和 `droppable<X>` 都满足 `X` 的依赖关系。
* If feature `X` depends on `Y` and `Z`, then `droppable<X>` depends on
  `droppable<Y>` and `droppable<Z>`.
  \n如果特征 `X` 依赖于 `Y` 和 `Z`，则 `droppable<X>` 依赖于 `droppable<Y>` 
  和 `droppable<Z>`。
* All accumulators have `add_ref()` and `drop()` member functions.
  \n所有累加器都有 `add_ref()` 和 `drop()` 成员函数。
* For non-droppable accumulators, `drop()` is a no-op, and `add_ref()`
  invokes `add_ref()` on all accumulators corresponding to the features
  upon which the current accumulator depends.
  \n对于不可删除的累加器，`drop()` 是空操作，而 `add_ref()` 
  则对当前累加器所依赖的所有特征的累加器执行 `add_ref()`。
* Droppable accumulators have a reference count and define `add_ref()`
  and `drop()` to manipulate the reference count.
  \n可删除的累加器有一个引用计数，并定义了 `add_ref()` 和 `drop()` 来维护该引用计数。
* For droppable accumulators, `add_ref()` increments the accumulator's
  reference count, and also `add_ref()`'s the accumulators corresponding
  to the features upon which the current accumulator depends.
  \n对于可删除累加器，`add_ref()` 递增该累加器的引用计数，
  并对当前累加器所依赖的所有特征的累加器执行 `add_ref()`。
* For droppable accumulators, `drop()` decrements the accumulator's
  reference count, and also `drop()`'s the accumulators corresponding to
  the features upon which the current accumulator depends.
  \n对于可删除累加器，`drop()` 递减该累加器的引用计数，
  并对当前累加器所依赖的所有特征的累加器执行 `drop()`。
* The accumulator_set constructor walks the list of *user-specified*
  features and `add_ref()`'s the accumulator that corresponds to each of
  them. (Note: that means that an accumulator that is not user-specified
  but in the set merely to satisfy a dependency will be dropped as soon
  as all its dependencies have been dropped. Ones that have been user
  specified are not dropped until their dependencies have been
  dropped *and* the user has explicitly dropped the accumulator.)
  \n accumulator_set的构造函数遍历*用户指定*特征的列表，并对其中每一个
  所对应的累加器执行 `add_ref()`。(注：这意味着如果一个累加器不是用户指定的，
  只是为了满足依赖关系而存在的，则当所有依赖它的累加器被删除时，它就会立即被删除。
  而对于用户指定的累加器，则直到依赖它的所有累加器被删除且用户显式删除该累加器时，
  才被删除。)
* Droppable accumulators check their reference count in their
  accumulate member function. If the reference count is 0, the function
  is a no-op.
  \n可删除累加器在它们的累加成员函数中检查其引用计数。如果引用计数为0，
  则函数为空操作。
* Users are not allowed to drop a feature that is not user-specified and
  marked as droppable.
  \n用户不允许删除不是用户指定的和未被标记为可删除的特征。

And as an optimization:
\n作为一种优化，有：

* If the user specifies the non-droppable feature `X`, which depends on `Y`
  and `Z`, then the accumulators for `Y` and `Z` can be safely made
  non-droppable, as well as any accumulators on which they depend.
  \n如果用户指定了一个不可删除特征 `X`，它依赖于 `Y` 和 `Z`，则 `Y` 和 `Z`
  的累加器可以安全地设为不可删除，它们所依赖的任何累加器也是如此。

[endsect]

[section Defining a New Feature 定义新的特征]

Once we have implemented an accumulator, we must define a feature for it so
that users can specify the feature when declaring an _accumulator_set_. We
typically put the features into a nested namespace, so that later we can
define an extractor of the same name. All features must satisfy the
[link accumulators.user_s_guide.the_accumulators_framework.concepts.feature_concept
Feature Concept]. Using _depends_on_ makes satisfying the concept simple.
Below is an example of a feature definition.
\n一旦我们完成了一个累加器，我们就必须为它定义一个特征，这样用户才可以在声明
_accumulator_set_ 时指定这个特征。我们应该将这个特征置于一个嵌套的名字空间中，
这样稍后我们就可以定义一个同名的提取器。所有特征都必须满足 
[link accumulators.user_s_guide.the_accumulators_framework.concepts.feature_concept 特征概念]。
使用 _depends_on_ 就可以很简单地满足该概念。以下是一个特征定义的例子。

    namespace boost { namespace accumulators { namespace tag {
    
    struct mean                         // Features should inherit from depends_on<> to specify dependencies
      : depends_on< count, sum >        // 特征应继承自 depends_on<> 以指定依赖关系
    {
        // Define a nested typedef called 'impl' that specifies which
        // accumulator implements this feature. 
        // 定义一个名为 'impl' 的嵌套 typedef，指定哪一个累加器实现了这个特征。
        typedef accumulators::impl::mean_accumulator< mpl::_1 > impl;
    };
    
    }}}

The only two things we must do to define the `mean` feature is to specify the
dependencies with _depends_on_ and define the nested `impl` typedef. Even features
that have no dependencies should inherit from _depends_on_. The nested `impl` type
must be an _mpl_lambda_expression_. The result of 
`mpl::apply< impl, _sample_type_, _weight_type_ >::type` must be
be the type of the accumulator that implements this feature. The use of _mpl_
placeholders like `mpl::_1` make it especially easy to make a template such
as `mean_accumulator<>` an _mpl_lambda_expression_. Here, `mpl::_1` will be
replaced with the sample type. Had we used `mpl::_2`, it would have been replaced
with the weight type.
\n在定义 `mean` 特征时，我们必须要做的两件事是，用 _depends_on_ 指定依赖关系和定义嵌套的
`impl` typedef。即使是没有依赖关系的特征，也要继承自 _depends_on_。
嵌套的 `impl` 类型必须是一个 _mpl_lambda_expression_。
`mpl::apply< impl, sample-type, weight-type >::type` 的结果必须是实现这一特征的累加器。
使用象 `mpl::_1` 这样的 _mpl_ 占位符可以很容易地将象 `mean_accumulator<>` 这样的模板变为
_mpl_lambda_expression_。在这里，`mpl::_1` 将被样本类型所替换。如果我们使用了 `mpl::_2`，
它将会被权重类型所替换。

What about accumulator types that are not templates? If you have a `foo_accumulator`
which is a plain struct and not a template, you could turn it into an
_mpl_lambda_expression_ using `mpl::always<>`, like this:
\n那么对于非模板的累加器类型又该如何？如果你有一个 `foo_accumulator`，它是一个简单结构而非模板，
你可以用 `mpl::always<>` 将它转为 _mpl_lambda_expression_，象这样：

    // An MPL lambda expression that always evaluates to
    // foo_accumulator:
    // 一个 MPL Lambda 表达式，它总是被求值为 foo_accumulator：
    typedef mpl::always< foo_accumulator > impl;

If you are ever unsure, or if you are not comfortable with MPL lambda expressions,
you could always define `impl` explicitly:
\n如果你不太确定，或者如果你不适应 MPL lambda 表达式，你总可以显式地定义 `impl` 吧：

    // Same as 'typedef mpl::always< foo_accumulator > impl;'
    // 与 'typedef mpl::always< foo_accumulator > impl;' 一样
    struct impl
    {
        template< typename Sample, typename Weight >
        struct apply
        {
            typedef foo_accumulator type;
        };
    };

Here, `impl` is a binary [@../../libs/mpl/doc/refmanual/metafunction-class.html
MPL Metafunction Class], which is a kind of _mpl_lambda_expression_. The nested
`apply<>` template is part of the metafunction class protocol and tells MPL how
to to build the accumulator type given the sample and weight types.
\n在这里，`impl` 是一个二元 [@../../libs/mpl/doc/refmanual/metafunction-class.html
MPL 元函数类]，它是 _mpl_lambda_expression_ 中的一种。嵌套的 `apply<>`
模板是元函数类协议的一部分，它告诉 MPL 如何根据给定的样本类型和权重类型来构建累加器类型。

All features must also provide a nested `is_weight_accumulator` typedef. It must
be either `mpl::true_` or `mpl::false_`. _depends_on_ provides a default of 
`mpl::false_` for all features that inherit from it, but that can be overridden
(or hidden, technically speaking) in the derived type. When the feature represents
an accumulation of information about the weights instead of the samples, we
can mark this feature as such with `typedef mpl::true_ is_weight_accumulator;`.
The weight accumulators are made external if the weight type is specified using
the _external_ template.
\n所有特征都必须提供一个嵌套的 `is_weight_accumulator typedef`。它必须是 `mpl::true_`
或 `mpl::false_`。_depends_on_ 为所有派生自它的特征提供了一个缺省值 `mpl::false_`，
不过它是可以在派生类中被覆写的(或隐藏，技术上说)。当一个特征表示的是关于权重信息而不是样本信息的累加时，
我们可以用 `typedef mpl::true_ is_weight_accumulator;` 来标记这一特征。
如果权重类型是用 _external_ 模板指定的，则加权累加器是在外部制造的。

[endsect]

[section Defining a New Extractor 定义新的提取器]

Now that we have an accumulator and a feature, the only thing lacking is a way
to get results from the accumulator set. The Accumulators Framework provides the
_extractor_ class template to make it simple to define an extractor for your
feature. Here's an extractor for the `mean` feature we defined above:
\n现在我们有了一个累加器和一个特征，唯一还缺少的就是从累加器集中取出结果的方法了。
累加器框架提供了 _extractor_ 类模板，它可以很简单地为你的特征定义一个提取器。
以下是我们在前面定义的 `mean` 特征的一个提取器：

    namespace boost {
    namespace accumulators {                // By convention, we put extractors in the 'extract' namespace
    namespace extract {                     // 为方便起见，我们将提取器放在 'extract' 名字空间中
    
    extractor< tag::mean > const mean = {}; // Simply define our extractor with our feature tag, like this.
                                            // 只要用我们的特征 tag 来定义我们的提取器就可以了，象这样。
    }
    using extract::mean;                    // Pull the extractor into the enclosing namespace.
                                            // 将提取器注入外层名字空间。
    }}                                            

Once defined, the `mean` extractor can be used to extract the result of the
`tag::mean` feature from an _accumulator_set_.
\n一旦定义好了，`mean` 提取器就可以用来从一个 _accumulator_set_ 中取出 `tag::mean` 特征的值。

Parameterized features complicate this simple picture. Consider the `moment`
feature, for calculating the [^['N]]-th moment, where [^['N]] is specified as
a template parameter:
\n参数化的特征会复杂一些。考虑 `moment` 特征，它用于计算[^['N]]次矩，其中 [^['N]] 
是作为模板参数给定的：

    // An accumulator set for calculating the N-th moment, for N == 2 ...
    // 一个用于计算N次矩的累加器集，其中 N == 2 ...
    accumulator_set< double, features< tag::moment<2> > > acc;
    
    // ... add some data ... 加入一些数据
    
    // Display the 2nd moment ... 打印二次矩 ...
    std::cout << "2nd moment is " << moment<2>(acc) << std::endl;

In the expression `moment<2>(acc)`, what is `moment`? It cannot be an object --
the syntax of C++ will not allow it. Clearly, if we want to provide this syntax,
we must make `moment` a function template. Here's what the definition of the 
`moment` extractor looks like:
\n在表达式 `moment<2>(acc)` 中，`moment` 是什么？它不可能是一个对象 -- C++的语法不允许。
显然，如果我们想提供这一语法，那么 `moment` 必须是一个函数模板。
`moment` 提取器的定义可以象下面这样：

    namespace boost {
    namespace accumulators {                // By convention, we put extractors in the 'extract' namespace
    namespace extract {                     // 为方便起见，我们将提取器放在 'extract' 名字空间中
    
    template<int N, typename AccumulatorSet>
    typename mpl::apply<AccumulatorSet, tag::moment<N> >::type::result_type
    moment(AccumulatorSet const &acc)
    {
        return extract_result<tag::moment<N> >(acc);
    }
    
    }
    using extract::moment;                  // Pull the extractor into the enclosing namespace.
                                            // 将提取器注入外层名字空间。
    }}                                            

The return type deserves some explanation. Every _accumulator_set_ type
is actually a unary [@../../libs/mpl/doc/refmanual/metafunction-class.html
MPL Metafunction Class]. When you `mpl::apply<>` an _accumulator_set_ and
a feature, the result is the type of the accumulator within the set that
implements that feature. And every accumulator provides a nested `result_type`
typedef that tells what its return type is. The extractor simply delegates
its work to the _extract_result_ function.
\n关于返回类型应该作一些解释。每一个 _accumulator_set_ 类型其实都是一个一元 
[@../../libs/mpl/doc/refmanual/metafunction-class.html MPL 元函数类]。
当你 `mpl::apply<>` 一个 _accumulator_set_ 和一个特征时，
返回结果是该集合内部实现该特征的累加器类型。并且每个累加器都提供一个嵌套的
`result_type` typedef，用于告知返回类型是什么。提取器只要将它的工作委托给
_extract_result_ 函数就可以了。

[endsect]

[section Controlling Dependencies 控制依赖关系]

The feature-based dependency resolution of the Accumulators Framework is
designed to allow multiple different implementation strategies for each
feature. For instance, two different accumulators may calculate the same
quantity with different rounding modes, or using different algorithms with
different size/speed tradeoffs. Other accumulators that depend on that
quantity shouldn't care how it's calculated. The Accumulators Framework
handles this by allowing several different accumulators satisfy the same
feature.
\n累加器框架的基于特征依赖关系的决议方式，是为了允许每个特征按多种不同策略来实现而设计的。
例如，可能有两个不同的累加器，它们以不同的舍入方式来计算同一个量，
或者是使用具有不同空间/时间代价的算法实现。其它依赖于这个量的累加器不应关心它是如何计算的。
累加器框架通过允许多个不同累加器满足同一个特征来处理这一问题。

[*Aliasing feature dependencies with [^feature_of<>]
 \n用 [^feature_of<>] 为特征依赖关系取别名]

Imagine that you would like to implement the hypothetical ['fubar] statistic,
and that you know two ways to calculate fubar on a bunch of samples: an
accurate but slow calculation and an approximate but fast calculation. You
might opt to make the accurate calculation the default, so you implement
two accumulators and call them `impl::fubar_impl` and `impl::fast_fubar_impl`.
You would also define the `tag::fubar` and `tag::fast_fubar` features as described
[link accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature above].
Now, you would like to inform the Accumulators Framework that these two features
are the same from the point of view of dependency resolution. You can do that
with _feature_of_, as follows:
\n想象一下你要实现假设的 ['fubar] 统计，你知道两种方法来计算一组样本的 fubar：
一种方法精确但计算速度慢，另一种方法近似但计算速度快。你可能选择将精确的算法作为缺省方法，
于是你实现了两个累加器，名为 `impl::fubar_impl` 和 `impl::fast_fubar_impl`。你也如 
[link accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature
上文] 所述定义了 `tag::fubar` 和 `tag::fast_fubar` 特征。现在，你想通知累加器框架，
这两个特征从依赖关系决议的角度而言是相同的。你可以用 _feature_of_ 来声明，如下：

    namespace boost { namespace accumulators
    {
        // For the purposes of feature-based dependency resolution,
        // fast_fubar provides the same feature as fubar
        // 对于基于特征的依赖关系决议来说，fast_fubar 提供了和 fubar 相同的特征
        template<>
        struct feature_of<tag::fast_fubar>
          : feature_of<tag::fubar>
        {
        };
    }}

The above code instructs the Accumulators Framework that, if another accumulator
in the set depends on the `tag::fubar` feature, the `tag::fast_fubar` feature
is an acceptable substitute.
\n以上代码指示累加器框架，如果累加器集中的某个累加器依赖于 `tag::fubar` 特征，
则 `tag::fast_fubar` 特征也是一个可接受的替代品。

[*Registering feature variants with [^as_feature<>]
 \n用 [^as_feature<>] 注册特征变体]

You may hve noticed that some feature variants in the Accumulators Framework can be
specified with a nicer syntax. For instance, instead of `tag::mean` and `tag::immediate_mean`
you can specify them with `tag::mean(lazy)` and `tag::mean(immediate)` respectively.
These are merely aliases, but the syntax makes the relationship between the two clearer.
You can create these feature aliases with the _as_feature_ trait. Given the fubar example
above, you might decide to alias `tag::fubar(accurate)` with `tag::fubar` and
`tag::fubar(fast)` with `tag::fast_fubar`. You would do that as follows:
\n你也许已经留意到，在累加器框架中有些特征变体可以用一种较漂亮的语法来指定。例如，要替代
`tag::mean` 和 `tag::immediate_mean`，你可以分别用 `tag::mean(lazy)` 和 `tag::mean(immediate)`
来指定。它们不过是别名而已，不过这种语法使得两者的关系更为清晰。你可以用 _as_feature_ trait 
来创建这些特征的别名。以前面的 fubar 为例，你可能决定以 `tag::fubar(accurate)` 作为 `tag::fubar`
的别名，以 `tag::fubar(fast)` 作为 `tag::fast_fubar` 的别名。你可以象下面这样做：

    namespace boost { namespace accumulators
    {
        struct fast {};     // OK to leave these tags empty 标记类型为空就可以了
        struct accurate {};
        
        template<>
        struct as_feature<tag::fubar(accurate)>
        {
            typedef tag::fubar type;
        };
        
        template<>
        struct as_feature<tag::fubar(fast)>
        {
            typedef tag::fast_fubar type;
        };
    }}

Once you have done this, users of your fubar accumulator can request the `tag::fubar(fast)` 
and `tag::fubar(accurate)` features when defining their `accumulator_set`s and get the correct
accumulator.
\n这样做了之后，你的 fubar 累加器的用户就可以在定义 `accumulator_set` 时使用 `tag::fubar(fast)`
和 `tag::fubar(accurate)` 特征并获得正确的累加器了。

[endsect]

[section:operators_ex Specializing Numeric Operators 特化数学操作符]

This section describes how to adapt third-party numeric types to work with the Accumulator
Framework.
\n这一节描述如何让第三方的数学类型适用于累加器框架。

Rather than relying on the built-in operators, the Accumulators Framework relies on functions
and operator overloads defined in the
[link accumulators.user_s_guide.the_accumulators_framework.numeric_operators_sub_library 
Numeric Operators Sub-Library] for many of its numeric operations. This is so that it
is possible to assign non-standard meanings to arithmetic operations. For instance, when
calculating an average by dividing two integers, the standard integer division behavior
would be mathematically incorrect for most statistical quantities. So rather than use `x / y`,
the Accumulators Framework uses `numeric::average(x, y)`, which does floating-point division
even if both `x` and `y` are integers.
\n对于多数的数学操作，累加器框架不是依赖于内建的操作符的，而是依赖于在 
[link accumulators.user_s_guide.the_accumulators_framework.numeric_operators_sub_library 
数学操作符子库] 中定义的函数和操作符重载。这样就可以为算术操作赋予非标准的特殊意义。
例如，在通过将两个整数相除以计算平均值时，标准的整数除法行为对于多数统计量来说在数学上是不正确的。
所以累加器框架不使用 `x / y`，而是使用 `numeric::average(x, y)`，即使 `x` 和 `y` 都是整数，
它也会进行浮点除法。

Another example where the Numeric Operators Sub-Library is useful is when a type does not
define the operator overloads required to use it for some statistical calculations. For instance, 
`std::vector<>` does not overload any arithmetic operators, yet it may be useful to use
`std::vector<>` as a sample or variate type. The Numeric Operators Sub-Library
defines the necessary operator overloads in the `boost::numeric::operators` namespace,
which is brought into scope by the Accumulators Framework with a using directive. 
\n说明数学操作符子库有用的另一个例子是，在一个类型没有定义某些统计运算所需的操作符重载的时候。
例如，`std::vector<>` 没有重载任何算术操作符，但是有可能需要将 `std::vector<>`
用作样本类型或变值类型。数学操作符子库在 `boost::numeric::operators`
名字空间中定义了所需要的操作符重载，它们被累加器框架用一个 using 指示符带入到了作用域中。

[*Numeric Function Objects and Tag Dispatching
 \n数学函数对象和 Tag 分派]

How are the numeric function object defined by the Numeric Operators Sub-Library made
to work with types such as `std::vector<>`? The free functions in the `boost::numeric` namespace
are implemented in terms of the function objects in the `boost::numeric::functional` namespace,
so to make `boost::numeric::average()` do something sensible with a `std::vector<>`, for instance,
we'll need to partially specialize the `boost::numeric::functional::average<>` function object.
\n数学操作符子库定义的数学函数对象是如何可用于 `std::vector<>` 这样的类型的呢？
在 `boost::numeric` 名字空间中的普通函数是根据 `boost::numeric::functional` 名字空间中的函数对象来实现的，
因此例如要让 `boost::numeric::average()` 能够对一个 `std::vector<>` 做些有意义的事情，
我们就需要偏特化 `boost::numeric::functional::average<>` 函数对象。

The functional objects make use of a technique known as 
[@http://www.boost.org/community/generic_programming.html#tag_dispatching ['tag dispatching]] to
select the proper implementation for the given operands. It works as follows:
\n函数对象使用一种被称为 [@http://www.boost.org/community/generic_programming.html#tag_dispatching ['tag 分派 ]]
的技术来为给定的操作数选择正确的实现。它的工作方式如下：

    namespace boost { namespace numeric { namespace functional
    {
        // Metafunction for looking up the tag associated with
        // a given numeric type T.
        // 用于查找与给定数学类型 T 相关联的 tag 的元函数
        template<typename T>
        struct tag
        {
            // by default, all types have void as a tag type
            // 缺省情况下，所有类型以 void 作为 tag 类型
            typedef void type;
        };
    
        // Forward declaration looks up the tag types of each operand
        // 前向声明，查找每个操作数的 tag 类型
        template<
            typename Left
          , typename Right
          , typename LeftTag = typename tag<Left>::type
          , typename RightTag = typename tag<Right>::type
        >
        struct average;
    }}}
    
If you have some user-defined type `MyDouble` for which you would like to customimze the behavior
of `numeric::average()`, you would specialize `numeric::functional::average<>` by
first defining a tag type, as shown below:
\n如果你有一个用户自定义的类型 `MyDouble`，你想针对它定制 `numeric::average()` 的行为，
你应该通过定义一个 tag 类型来特化 `numeric::functional::average<>`，如下所示：

    namespace boost { namespace numeric { namespace functional
    {
        // Tag type for MyDouble
        // MyDouble 的 Tag 类型
        struct MyDoubleTag {};
        
        // Specialize tag<> for MyDouble.
        // This only needs to be done once.
        // 为 MyDouble 特化 tag<>。这只需要做一次。
        template<>
        struct tag<MyDouble>
        {
            typedef MyDoubleTag type;
        };

        // Specify how to divide a MyDouble by an integral count
        // 指定如何将一个 MyDouble 除以一个整数数量
        template<typename Left, typename Right>
        struct average<Left, Right, MyDoubleTag, void>
        {
            // Define the type of the result
            // 定义运算结果的类型
            typedef ... result_type;
            
            result_type operator()(Left & left, Right & right) const
            {
                return ...;
            }
        };
    }}}
    
Once you have done this, `numeric::average()` will use your specialization 
of `numeric::functional::average<>` when the first argument is a `MyDouble`
object. All of the function objects in the Numeric Operators Sub-Library can
be customized in a similar fashion.
\n你做了这些以后，当第一个参数是 `MyDouble` 对象时，`numeric::average()` 将使用你特化的
`numeric::functional::average<>`。数学操作符子库中的所有函数对象都可以按类似方式进行特化。

[endsect]

[endsect]

[section Concepts 概念]

[h2 Accumulator Concept 累加器概念]

In the following table, `Acc` is the type of an accumulator, `acc` and `acc2` are objects of type
`Acc`, and `args` is the name of an argument pack from the _parameter_ library.
\n下表中，`Acc` 是一个累加器类型，`acc` 和 `acc2` 为类型 `Acc` 的对象，`args` 是来自于
_parameter_ 库的参数包的名字。

[table Accumulator Requirements 累加器的要求
    [[[*Expression\n表达式]]         [[*Return type\n返回类型]]       [[*Assertion / Note / Pre- / Post-condition
                                                                        \n断言/说明/前置条件/后置条件]]]
    [[`Acc::result_type`]            [['implementation
                                       defined\n实现定义]]            [The type returned by `Acc::result()`.
                                                                      \n由 Acc::result() 返回的类型。]]
    [[`Acc acc(args)`]               [none\n无]                       [Construct from an argument pack.
                                                                      \n从一个参数包进行构造。]]
    [[`Acc acc(acc2)`]               [none\n无]                       [Post: `acc.result(args)` is equivalent
                                                                      to `acc2.result(args)`
                                                                      \n后置条件：`acc.result(args)` 等价于 `acc2.result(args)`]]
    [[`acc(args)`]                   [['unspecified\n未指定]]         []]
    [[`acc.on_drop(args)`]           [['unspecified\n未指定]]         []]
    [[`acc.result(args)`]            [`Acc::result_type`]            []]
]

[h2 Feature Concept 特征概念]

In the following table, `F` is the type of a feature and `S` is some scalar type.
\n下表中，`F` 是一个特征类型，`S` 是某个标量类型。

[table Featue Requirements 特征的要求
    [[[*Expression\n表达式]]         [[*Return type\n返回类型]]       [[*Assertion / Note / Pre- / Post-condition
                                                                        \n断言/说明/前置条件/后置条件]]]
    [[`F::dependencies`]             [['unspecified\n未指定]]         [An MPL sequence of other features on
                                                                       which which `F` depends.
                                                                       \n由 `F` 所依赖的其它特征所组成的 MPL 序列。]]
    [[`F::is_weight_accumulator`]    [`mpl::true_` or
                                      `mpl::false_`]                  [`mpl::true_` if the accumulator for
                                                                        this feature should be made external
                                                                        when the weight type for the accumulator
                                                                        set is `external<S>`, `mpl::false_`
                                                                        otherwise.
                                                                        \n`mpl::true_` 如果该特征的累加器在累加器集的权重类型为
                                                                        `external<S>` 时将在外部制造，否则为 `mpl::false_`。]]
    [[`F::impl`]                     [['unspecified\n未指定]]         [An _mpl_lambda_expression_ that
                                                                        returns the type of the accumulator that
                                                                        implements this feature when passed a
                                                                        sample type and a weight type.
                                                                        \n一个 _mpl_lambda_expression_，在传入一个样本
                                                                        类型和一个权重类型时返回实现该特征的累加器类型。]]
]

[endsect]

[endsect]

[section The Statistical Accumulators Library 统计累加器库]

The Statistical Accumulators Library defines accumulators for incremental statistial
computations. It is built on top of [link accumulators.user_s_guide.the_accumulators_framework
The Accumulator Framework].
\n统计累加器库定义了增量统计计算所用的累加器。它构建于 
[link accumulators.user_s_guide.the_accumulators_framework 累加器框架] 之上。

[section:count count]

The `count` feature is a simple counter that tracks the
number of samples pushed into the accumulator set.
\n`count` 特征是一个简单的计数器，跟踪压入累加器集的样本数量。

[variablelist
    [[Result Type 返回类型] [``
                    std::size_t
                    ``]]
    [[Depends On 依赖于] [['none 无]]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _COUNT_HPP_ [headerref boost/accumulators/statistics/count.hpp]]

    #include <_COUNT_HPP_>

[*Example]

    accumulator_set<int, features<tag::count> > acc;
    acc(0);
    acc(0);
    acc(0);
    assert(3 == count(acc));

[*See also]

* [classref boost::accumulators::impl::count_impl `count_impl`]

[endsect]

[section:covariance covariance]

The `covariance` feature is an iterative Monte Carlo estimator for the covariance.
It is specified as `tag::covariance<_variate_type_, _variate_tag_>`.
\n`covariance` 特征是用于协方差的一个迭代蒙特卡洛估算法。
它用 `tag::covariance<variate-type, variate-tag>` 指定。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::outer_product<
                        numeric::functional::average<_sample_type_, std::size_t>::result_type
                      , numeric::functional::average<_variate_type_, std::size_t>::result_type
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`count` \n `mean` \n `mean_of_variates<_variate_type_, _variate_tag_>`]]
    [[Variants 变体] [`abstract_covariance`]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [[~variate-tag]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _COVARIANCE_HPP_ [headerref boost/accumulators/statistics/covariance.hpp]]

    #include <_COVARIANCE_HPP_>

[*Example]

    accumulator_set<double, stats<tag::covariance<double, tag::covariate1> > > acc;
    acc(1., covariate1 = 2.);
    acc(1., covariate1 = 4.);
    acc(2., covariate1 = 3.);
    acc(6., covariate1 = 1.);
    assert(covariance(acc) == -1.75);

[*See also]

* [classref boost::accumulators::impl::covariance_impl [^covariance_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.mean [^mean]]

[endsect]

[section:density density]

The `tag::density` feature returns a histogram of the sample distribution. For more
implementation details, see [classref boost::accumulators::impl::density_impl [^density_impl]].
\n`tag::density` 特征返回样本分布的直方图。更多的实现细节，请见 
[classref boost::accumulators::impl::density_impl [^density_impl]]. 

[variablelist
    [[Result Type 返回类型] [``
                    iterator_range<
                        std::vector<
                            std::pair<
                                numeric::functional::average<_sample_type_, std::size_t>::result_type
                              , numeric::functional::average<_sample_type_, std::size_t>::result_type
                            >
                        >::iterator
                    >
                    ``]]
    [[Depends On 依赖于] [`count` \n `min` \n `max`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`density::cache_size` \n `density::num_bins`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(N), when N is `density::num_bins` \n O(N), 其中 N 为 `density::num_bins`]] 
]

[*Header]
[def _DENSITY_HPP_ [headerref boost/accumulators/statistics/density.hpp]]

    #include <_DENSITY_HPP_>

[*Note]

Results from the `density` accumulator can only be extracted after the number of
samples meets or exceeds the cache size.
\n`density` 累加器的结果只能在样本数量达到或超过缓冲区大小以后，才可以提取。

[/ TODO add example ]

[*See also]

* [classref boost::accumulators::impl::density_impl [^density_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.min [^min]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.max [^max]]

[endsect]

[section:error_of_mean error_of<mean>]

The `error_of<mean>` feature calculates the error of the mean feature. It is equal to
`sqrt(variance / (count - 1))`.
\n`error_of<mean>` 特征计算平均值特征的误差。它等于 `sqrt(variance / (count - 1))`. 

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`count` \n `variance`]]
    [[Variants 变体] [`error_of<immediate_mean>`]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _ERROR_OF_HPP_      [headerref boost/accumulators/statistics/error_of.hpp]]
[def _ERROR_OF_MEAN_HPP_ [headerref boost/accumulators/statistics/error_of_mean.hpp]]

    #include <_ERROR_OF_HPP_>
    #include <_ERROR_OF_MEAN_HPP_>

[*Example]

    accumulator_set<double, stats<tag::error_of<tag::mean> > > acc;
    acc(1.1);
    acc(1.2);
    acc(1.3);
    assert(0.057735 == error_of<tag::mean>(acc));

[*See also]

* [classref boost::accumulators::impl::error_of_mean_impl [^error_of_mean_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.variance [^variance]]

[endsect]

[section:extended_p_square extended_p_square]

Multiple quantile estimation with the extended [^P^2] algorithm. For further 
details, see [classref boost::accumulators::impl::extended_p_square_impl [^extended_p_square_impl]].
\n扩展 [^P^2] 算法的多重分位数预估。更多细节，请见 
[classref boost::accumulators::impl::extended_p_square_impl [^extended_p_square_impl]].

[variablelist
    [[Result Type 返回类型] [``
                    boost::iterator_range<
                        _implementation_defined_
                    >
                    ``]]
    [[Depends On 依赖于] [`count`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::extended_p_square::probabilities`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _EXTENDED_P_SQUARE_HPP_ [headerref boost/accumulators/statistics/extended_p_square.hpp]]

    #include <_EXTENDED_P_SQUARE_HPP_>

[*Example]

    boost::array<double> probs = {0.001,0.01,0.1,0.25,0.5,0.75,0.9,0.99,0.999};
    accumulator_set<double, stats<tag::extended_p_square> >
        acc(tag::extended_p_square::probabilities = probs);

    boost::lagged_fibonacci607 rng; // a random number generator
    for (int i=0; i<10000; ++i)
        acc(rng());

    BOOST_CHECK_CLOSE(extended_p_square(acc)[0], probs[0], 25);
    BOOST_CHECK_CLOSE(extended_p_square(acc)[1], probs[1], 10);
    BOOST_CHECK_CLOSE(extended_p_square(acc)[2], probs[2], 5);
    
    for (std::size_t i=3; i < probs.size(); ++i)
    {
        BOOST_CHECK_CLOSE(extended_p_square(acc)[i], probs[i], 2);
    }

[*See also]

* [classref boost::accumulators::impl::extended_p_square_impl [^extended_p_square_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]

[endsect]

[section:extended_p_square_quantile extended_p_square_quantile ['and variants]]

Quantile estimation using the extended [^P^2] algorithm for weighted and unweighted samples.
By default, the calculation is linear and unweighted, but quadratic and weighted variants 
are also provided. For further implementation details, see 
[classref boost::accumulators::impl::extended_p_square_quantile_impl [^extended_p_square_quantile_impl]].
\n分位数预估对加权和非加权样本使用了扩展的 [^P^2] 算法。缺省情况下，计算是线性的和非加权的，
不过也提供二次的和加权的的变体。更多实现细节，请见
[classref boost::accumulators::impl::extended_p_square_quantile_impl [^extended_p_square_quantile_impl]].

All the variants share the `tag::quantile` feature and can be extracted using the `quantile()`
extractor.
\n所有变体共享 `tag::quantile` 特征，都可以用 `quantile()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [weighted variants depend on `weighted_extended_p_square` \n
                   加权的变体依赖于 `weighted_extended_p_square` \n
                   unweighted variants depend on `extended_p_square` \n
                   非加权变体依赖于 `extended_p_square`]]
    [[Variants 变体] [`extended_p_square_quantile_quadratic` \n 
                 `weighted_extended_p_square_quantile` \n 
                 `weighted_extended_p_square_quantile_quadratic`]]
    [[Initialization Parameters 初始化参数] [`tag::extended_p_square::probabilities`]]
    [[Accumulator Parameters 累加器参数] [`weight` for the weighted variants \n `weight` 对于加权的变体]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(N) where N is the count of probabilities. \n O(N) 其中 N 为可能性的数量。]] 
]

[*Header]
[def _EXTENDED_P_SQUARE_QUANTILE_HPP_ [headerref boost/accumulators/statistics/extended_p_square_quantile.hpp]]

    #include <_EXTENDED_P_SQUARE_QUANTILE_HPP_>

[*Example]

    typedef accumulator_set<double, stats<tag::extended_p_square_quantile> >
        accumulator_t;
    typedef accumulator_set<double, stats<tag::weighted_extended_p_square_quantile>, double >
        accumulator_t_weighted;
    typedef accumulator_set<double, stats<tag::extended_p_square_quantile(quadratic)> >
        accumulator_t_quadratic;
    typedef accumulator_set<double, stats<tag::weighted_extended_p_square_quantile(quadratic)>, double >
        accumulator_t_weighted_quadratic;

    // tolerance 容许的误差
    double epsilon = 1;

    // a random number generator 随机数生成器
    boost::lagged_fibonacci607 rng;

    boost::array<double> probs = { 0.990, 0.991, 0.992, 0.993, 0.994, 
                                   0.995, 0.996, 0.997, 0.998, 0.999 };
    accumulator_t acc(extended_p_square_probabilities = probs);
    accumulator_t_weighted acc_weighted(extended_p_square_probabilities = probs);
    accumulator_t_quadratic acc2(extended_p_square_probabilities = probs);
    accumulator_t_weighted_quadratic acc_weighted2(extended_p_square_probabilities = probs);
    
    for (int i=0; i<10000; ++i)
    {
        double sample = rng();
        acc(sample);
        acc2(sample);
        acc_weighted(sample, weight = 1.);
        acc_weighted2(sample, weight = 1.);
    }
    
    for (std::size_t i = 0; i < probs.size() - 1; ++i)
    {
        BOOST_CHECK_CLOSE(
            quantile(acc, quantile_probability = 0.99025 + i*0.001)
          , 0.99025 + i*0.001
          , epsilon
        );
        BOOST_CHECK_CLOSE(
            quantile(acc2, quantile_probability = 0.99025 + i*0.001)
          , 0.99025 + i*0.001
          , epsilon
        );
        BOOST_CHECK_CLOSE(
            quantile(acc_weighted, quantile_probability = 0.99025 + i*0.001)
          , 0.99025 + i*0.001
          , epsilon
        );
        BOOST_CHECK_CLOSE(
            quantile(acc_weighted2, quantile_probability = 0.99025 + i*0.001)
          , 0.99025 + i*0.001
          , epsilon
        );
    }

[*See also]

* [classref boost::accumulators::impl::extended_p_square_quantile_impl [^extended_p_square_quantile_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.extended_p_square [^extended_p_square]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_extended_p_square [^weighted_extended_p_square]]

[endsect]

[section:kurtosis kurtosis]

The kurtosis of a sample distribution is defined as the ratio of the 4th central moment and the
square of the 2nd central moment (the variance) of the samples, minus 3. The term [^-3] is added
in order to ensure that the normal distribution has zero kurtosis. For more implementation 
details, see [classref boost::accumulators::impl::kurtosis_impl [^kurtosis_impl]]
\n样本分布的峰度被定义为样本(变异)的4次中心矩与2次中心矩平方之比减3。
这个 [^-3] 是为了确保天上正态分布的峰度为0。更多的实现细节，请见
[classref boost::accumulators::impl::kurtosis_impl [^kurtosis_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, _sample_type_>::result_type
                    ``]]
    [[Depends On 依赖于] [`mean` \n `moment<2>` \n `moment<3>` \n `moment<4>`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _KURTOSIS_HPP_ [headerref boost/accumulators/statistics/kurtosis.hpp]]

    #include <_KURTOSIS_HPP_>

[*Example]

    accumulator_set<int, stats<tag::kurtosis > > acc;
        
    acc(2);
    acc(7);
    acc(4);
    acc(9);
    acc(3);
    
    BOOST_CHECK_EQUAL( mean(acc), 5 );
    BOOST_CHECK_EQUAL( moment<2>(acc), 159./5. );
    BOOST_CHECK_EQUAL( moment<3>(acc), 1171./5. );
    BOOST_CHECK_EQUAL( moment<4>(acc), 1863 );
    BOOST_CHECK_CLOSE( kurtosis(acc), -1.39965397924, 1e-6 );

[*See also]

* [classref boost::accumulators::impl::kurtosis_impl [^kurtosis_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.mean [^mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.moment [^moment]]

[endsect]

[section:max max]

Calculates the maximum value of all the samples.
\n计算所有样本中的最大值。

[variablelist
    [[Result Type 返回类型] [``
                    _sample_type_
                    ``]]
    [[Depends On 依赖于] [['none 无]]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _MAX_HPP_ [headerref boost/accumulators/statistics/max.hpp]]

    #include <_MAX_HPP_>

[*Example]

    accumulator_set<int, stats<tag::max> > acc;

    acc(1);
    BOOST_CHECK_EQUAL(1, (max)(acc));

    acc(0);
    BOOST_CHECK_EQUAL(1, (max)(acc));

    acc(2);
    BOOST_CHECK_EQUAL(2, (max)(acc));

[*See also]

* [classref boost::accumulators::impl::max_impl [^max_impl]]

[endsect]

[section:mean mean ['and variants]]

Calculates the mean of samples, weights or variates. The calculation is either
lazy (in the result extractor), or immediate (in the accumulator). The lazy implementation
is the default. For more implementation details, see 
[classref boost::accumulators::impl::mean_impl [^mean_impl]] or.
[classref boost::accumulators::impl::immediate_mean_impl [^immediate_mean_impl]]
\n计算样本、权重或变值的平均值。计算方法可以是延迟的(在结果提取器中计算)或立即的(在累加器中计算)。
缺省实现是延迟方式。更多实现细节，请见 [classref boost::accumulators::impl::mean_impl [^mean_impl]] 或
[classref boost::accumulators::impl::immediate_mean_impl [^immediate_mean_impl]].

[variablelist
    [[Result Type 返回类型] [For samples, `numeric::functional::average<_sample_type_, std::size_t>::result_type` \n
                    对于样本, `numeric::functional::average<_sample_type_, std::size_t>::result_type` \n
                    For weights, `numeric::functional::average<_weight_type_, std::size_t>::result_type` \n
                    对于权重, `numeric::functional::average<_weight_type_, std::size_t>::result_type` \n
                    For variates, `numeric::functional::average<_variate_type_, std::size_t>::result_type` \n
                    对于变值, `numeric::functional::average<_variate_type_, std::size_t>::result_type`]]
    [[Depends On 依赖于] [`count` \n
                   The lazy mean of samples depends on `sum` \n
                   延迟方式的样本平均值依赖于 `sum` \n
                   The lazy mean of weights depends on `sum_of_weights` \n
                   延迟方式的权重平均值依赖于 `sum_of_weights` \n
                   The lazy mean of variates depends on `sum_of_variates<>` \n
                   延迟方式的变值平均值依赖于 `sum_of_variates<>`]]
    [[Variants 变体] [`mean_of_weights` \n
                 `mean_of_variates<_variate_type_, _variate_tag_>` \n
                 `immediate_mean` \n
                 `immediate_mean_of_weights` \n
                 `immediate_mean_of_variates<_variate_type_, _variate_tag_>`]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _MEAN_HPP_ [headerref boost/accumulators/statistics/mean.hpp]]

    #include <_MEAN_HPP_>

[*Example]

    accumulator_set<
        int
      , stats<
            tag::mean
          , tag::mean_of_weights
          , tag::mean_of_variates<int, tag::covariate1>
        >
      , int 
    > acc;

    acc(1, weight = 2, covariate1 = 3);
    BOOST_CHECK_CLOSE(1., mean(acc), 1e-5);
    BOOST_CHECK_EQUAL(1u, count(acc));
    BOOST_CHECK_EQUAL(2, sum(acc));
    BOOST_CHECK_CLOSE(2., mean_of_weights(acc), 1e-5);
    BOOST_CHECK_CLOSE(3., (mean_of_variates<int, tag::covariate1>(acc)), 1e-5);

    acc(0, weight = 4, covariate1 = 4);
    BOOST_CHECK_CLOSE(0.33333333333333333, mean(acc), 1e-5);
    BOOST_CHECK_EQUAL(2u, count(acc));
    BOOST_CHECK_EQUAL(2, sum(acc));
    BOOST_CHECK_CLOSE(3., mean_of_weights(acc), 1e-5);
    BOOST_CHECK_CLOSE(3.5, (mean_of_variates<int, tag::covariate1>(acc)), 1e-5);

    acc(2, weight = 9, covariate1 = 8);
    BOOST_CHECK_CLOSE(1.33333333333333333, mean(acc), 1e-5);
    BOOST_CHECK_EQUAL(3u, count(acc));
    BOOST_CHECK_EQUAL(20, sum(acc));
    BOOST_CHECK_CLOSE(5., mean_of_weights(acc), 1e-5);
    BOOST_CHECK_CLOSE(5., (mean_of_variates<int, tag::covariate1>(acc)), 1e-5);

    accumulator_set<
        int
      , stats<
            tag::mean(immediate)
          , tag::mean_of_weights(immediate)
          , tag::mean_of_variates<int, tag::covariate1>(immediate)
        >
      , int
    > acc2;

    acc2(1, weight = 2, covariate1 = 3);
    BOOST_CHECK_CLOSE(1., mean(acc2), 1e-5);
    BOOST_CHECK_EQUAL(1u, count(acc2));
    BOOST_CHECK_CLOSE(2., mean_of_weights(acc2), 1e-5);
    BOOST_CHECK_CLOSE(3., (mean_of_variates<int, tag::covariate1>(acc2)), 1e-5);
        
    acc2(0, weight = 4, covariate1 = 4);
    BOOST_CHECK_CLOSE(0.33333333333333333, mean(acc2), 1e-5);
    BOOST_CHECK_EQUAL(2u, count(acc2));
    BOOST_CHECK_CLOSE(3., mean_of_weights(acc2), 1e-5);
    BOOST_CHECK_CLOSE(3.5, (mean_of_variates<int, tag::covariate1>(acc2)), 1e-5);
    
    acc2(2, weight = 9, covariate1 = 8);
    BOOST_CHECK_CLOSE(1.33333333333333333, mean(acc2), 1e-5);
    BOOST_CHECK_EQUAL(3u, count(acc2));
    BOOST_CHECK_CLOSE(5., mean_of_weights(acc2), 1e-5);
    BOOST_CHECK_CLOSE(5., (mean_of_variates<int, tag::covariate1>(acc2)), 1e-5);

[*See also]

* [classref boost::accumulators::impl::mean_impl [^mean_impl]]
* [classref boost::accumulators::impl::immediate_mean_impl [^immediate_mean_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]

[endsect]

[section:median median ['and variants]]

Median estimation based on the [^P^2] quantile estimator, the density estimator, or
the [^P^2] cumulative distribution estimator. For more implementation details, see
[classref boost::accumulators::impl::median_impl [^median_impl]], 
[classref boost::accumulators::impl::with_density_median_impl [^with_density_median_impl]], 
and [classref boost::accumulators::impl::with_p_square_cumulative_distribution_median_impl [^with_p_square_cumulative_distribution_median_impl]].
\n基于 [^P^2] 分位数估算、密度估算或 [^P^2] 累积分布估算的中值估算。更多实现细节，请见
[classref boost::accumulators::impl::median_impl [^median_impl]], 
[classref boost::accumulators::impl::with_density_median_impl [^with_density_median_impl]], 
和 [classref boost::accumulators::impl::with_p_square_cumulative_distribution_median_impl [^with_p_square_cumulative_distribution_median_impl]].

The three median accumulators all satisfy the `tag::median` feature, and can all be
extracted with the `median()` extractor.
\n这三个中值估算累加器均满足 `tag::median` 特征，都可以用 `median()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`median` depends on `p_square_quantile_for_median` \n
                   `median` 依赖于 `p_square_quantile_for_median` \n
                   `with_density_median` depends on `count` and `density` \n
                   `with_density_median` 依赖于 `count` and `density` \n
                   `with_p_square_cumulative_distribution_median` depends on `p_square_cumulative_distribution` \n
                   `with_p_square_cumulative_distribution_median` 依赖于 `p_square_cumulative_distribution`]]
    [[Variants 变体] [`with_density_median` \n
                 `with_p_square_cumulative_distribution_median`]]
    [[Initialization Parameters 初始化参数] [`with_density_median` requires `tag::density::cache_size` and `tag::density::num_bins` \n
                                  `with_density_median` 要求 `tag::density::cache_size` 和 `tag::density::num_bins` \n
                                  `with_p_square_cumulative_distribution_median` requires `tag::p_square_cumulative_distribution::num_cells` \n
                                  `with_p_square_cumulative_distribution_median` 要求 `tag::p_square_cumulative_distribution::num_cells`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [TODO 待办]] 
]

[*Header]
[def _MEDIAN_HPP_ [headerref boost/accumulators/statistics/median.hpp]]

    #include <_MEDIAN_HPP_>

[*Example]

    // two random number generators 两个随机数生成器
    double mu = 1.;
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma(mu,1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> >
        normal(rng, mean_sigma);
    
    accumulator_set<double, stats<tag::median(with_p_square_quantile) > > acc;
    accumulator_set<double, stats<tag::median(with_density) > > 
        acc_dens( density_cache_size = 10000, density_num_bins = 1000 );
    accumulator_set<double, stats<tag::median(with_p_square_cumulative_distribution) > > 
        acc_cdist( p_square_cumulative_distribution_num_cells = 100 );
        
    for (std::size_t i=0; i<100000; ++i)
    {
        double sample = normal();
        acc(sample);
        acc_dens(sample);
        acc_cdist(sample);
    }
    
    BOOST_CHECK_CLOSE(1., median(acc), 1.);
    BOOST_CHECK_CLOSE(1., median(acc_dens), 1.);
    BOOST_CHECK_CLOSE(1., median(acc_cdist), 3.);

[*See also]

* [classref boost::accumulators::impl::median_impl [^median_impl]]
* [classref boost::accumulators::impl::with_density_median_impl [^with_density_median_impl]]
* [classref boost::accumulators::impl::with_p_square_cumulative_distribution_median_impl [^with_p_square_cumulative_distribution_median_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.p_square_quantile [^p_square_quantile]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.p_square_cumulative_distribution [^p_square_cumulative_distribution]]

[endsect]

[section:min min]

Calculates the minimum value of all the samples.
\n计算所有样本中的最小值。

[variablelist
    [[Result Type 返回类型] [``
                    _sample_type_
                    ``]]
    [[Depends On 依赖于] [['none 无]]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _MIN_HPP_ [headerref boost/accumulators/statistics/min.hpp]]

    #include <_MIN_HPP_>

[*Example]

    accumulator_set<int, stats<tag::min> > acc;

    acc(1);
    BOOST_CHECK_EQUAL(1, (min)(acc));

    acc(0);
    BOOST_CHECK_EQUAL(0, (min)(acc));

    acc(2);
    BOOST_CHECK_EQUAL(0, (min)(acc));

[*See also]

* [classref boost::accumulators::impl::min_impl [^min_impl]]

[endsect]

[section:moment moment]

Calculates the N-th moment of the samples, which is defined as the sum of the N-th power of the
samples over the count of samples.
\n计算样本的N次矩，其定义为样本的N次方之和除以样本数量。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`count`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _MOMENT_HPP_ [headerref boost/accumulators/statistics/moment.hpp]]

    #include <_MOMENT_HPP_>

[*Example]

    accumulator_set<int, stats<tag::moment<2> > > acc1;

    acc1(2); //    4
    acc1(4); //   16
    acc1(5); // + 25
             // = 45 / 3 = 15

    BOOST_CHECK_CLOSE(15., moment<2>(acc1), 1e-5);

    accumulator_set<int, stats<tag::moment<5> > > acc2;

    acc2(2); //     32
    acc2(3); //    243
    acc2(4); //   1024
    acc2(5); // + 3125
             // = 4424 / 4 = 1106

    BOOST_CHECK_CLOSE(1106., moment<5>(acc2), 1e-5);

[*See also]

* [classref boost::accumulators::impl::moment_impl [^moment_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]

[endsect]

[section:p_square_cumulative_distribution p_square_cumulative_distribution]

Histogram calculation of the cumulative distribution with the [^P^2] algorithm.
For more implementation details, see 
[classref boost::accumulators::impl::p_square_cumulative_distribution_impl [^p_square_cumulative_distribution_impl]]
\n用 [^P^2] 算法进行累积分布的直方图计算。更多实现细节，请见
[classref boost::accumulators::impl::p_square_cumulative_distribution_impl [^p_square_cumulative_distribution_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    iterator_range<
                        std::vector<
                            std::pair<
                                numeric::functional::average<_sample_type_, std::size_t>::result_type
                              , numeric::functional::average<_sample_type_, std::size_t>::result_type
                            >
                        >::iterator
                    >
                    ``]]
    [[Depends On 依赖于] [`count`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::p_square_cumulative_distribution::num_cells`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(N) where N is `num_cells` \n O(N) 其中 N 为 `num_cells`]] 
]

[*Header]
[def _P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_ [headerref boost/accumulators/statistics/p_square_cumulative_distribution.hpp]]

    #include <_P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_>

[*Example]

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 3;

    typedef accumulator_set<double, stats<tag::p_square_cumulative_distribution> > accumulator_t;
        
    accumulator_t acc(tag::p_square_cumulative_distribution::num_cells = 100);
    
    // two random number generators 两个随机数生成器
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma(0,1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal(rng, mean_sigma);
    
    for (std::size_t i=0; i<100000; ++i)
    {
        acc(normal());
    }
    
    typedef iterator_range<std::vector<std::pair<double, double> >::iterator > histogram_type;
    histogram_type histogram = p_square_cumulative_distribution(acc);
    
    for (std::size_t i = 0; i < histogram.size(); ++i)
    {   
        // problem with small results: epsilon is relative (in percent), not absolute!
        // 结果较小的问题：epsilon 是相对的(百分比)，不是绝对的！
        if ( histogram[i].second > 0.001 )    
            BOOST_CHECK_CLOSE( 0.5 * (1.0 + erf( histogram[i].first / sqrt(2.0) )), histogram[i].second, epsilon );
    }        

[*See also]

* [classref boost::accumulators::impl::p_square_cumulative_distribution_impl [^p_square_cumulative_distribution_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]

[endsect]

[section:p_square_quantile p_square_quantile ['and variants]]

Single quantile estimation with the [^P^2] algorithm. For more implementation details, see
[classref boost::accumulators::impl::p_square_quantile_impl [^p_square_quantile_impl]]
\n以 P^2 算法进行单分位数估算。更多实现细节，请见
[classref boost::accumulators::impl::p_square_quantile_impl [^p_square_quantile_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`count`]]
    [[Variants 变体] [`p_square_quantile_for_median`]]
    [[Initialization Parameters 初始化参数] [`quantile_probability`, which defaults to `0.5`.
                                  (Note: for `p_square_quantile_for_median`, the `quantile_probability`
                                  parameter is ignored and is always `0.5`.) \n
                                  `quantile_probability`, 缺省为 `0.5`.
                                  (注：对于 `p_square_quantile_for_median`, 参数 `quantile_probability`
                                  被忽略且设为 `0.5`.)]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _P_SQUARE_QUANTILE_HPP_ [headerref boost/accumulators/statistics/p_square_quantile.hpp]]

    #include <_P_SQUARE_QUANTILE_HPP_>

[*Example]

    typedef accumulator_set<double, stats<tag::p_square_quantile> > accumulator_t;

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1;
    
    // a random number generator 随机数生成器
    boost::lagged_fibonacci607 rng;
    
    accumulator_t acc0(quantile_probability = 0.001);
    accumulator_t acc1(quantile_probability = 0.01 );
    accumulator_t acc2(quantile_probability = 0.1  );
    accumulator_t acc3(quantile_probability = 0.25 );
    accumulator_t acc4(quantile_probability = 0.5  );
    accumulator_t acc5(quantile_probability = 0.75 );
    accumulator_t acc6(quantile_probability = 0.9  );
    accumulator_t acc7(quantile_probability = 0.99 );
    accumulator_t acc8(quantile_probability = 0.999);
    
    for (int i=0; i<100000; ++i)
    {
        double sample = rng();
        acc0(sample);
        acc1(sample);
        acc2(sample);
        acc3(sample);
        acc4(sample);
        acc5(sample);
        acc6(sample);
        acc7(sample);
        acc8(sample);
    }
    
    BOOST_CHECK_CLOSE( p_square_quantile(acc0), 0.001, 15*epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc1), 0.01 , 5*epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc2), 0.1  , epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc3), 0.25 , epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc4), 0.5  , epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc5), 0.75 , epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc6), 0.9  , epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc7), 0.99 , epsilon );
    BOOST_CHECK_CLOSE( p_square_quantile(acc8), 0.999, epsilon );    

[*See also]

* [classref boost::accumulators::impl::p_square_quantile_impl [^p_square_quantile_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]

[endsect]

[section:peaks_over_threshold peaks_over_threshold ['and variants]]

Peaks Over Threshold method for quantile and tail mean estimation. For implementation
details, see [classref boost::accumulators::impl::peaks_over_threshold_impl [^peaks_over_threshold_impl]]
and [classref boost::accumulators::impl::peaks_over_threshold_prob_impl [^peaks_over_threshold_prob_impl]].
\n用于分位数和尾均值估算的高限峰值法(POT)。更多实现细节，请见
[classref boost::accumulators::impl::peaks_over_threshold_impl [^peaks_over_threshold_impl]]
和 [classref boost::accumulators::impl::peaks_over_threshold_prob_impl [^peaks_over_threshold_prob_impl]].

Both `tag::peaks_over_threshold` and `tag::peaks_over_threshold_prob<>` satisfy the `tag::abstract_peaks_over_threshold`
feature, and can be extracted with the `peaks_over_threshold()` extractor. The result is a 3-tuple representing
the fit parameters `u_bar`, `beta_bar` and `xi_hat`.
\n`tag::peaks_over_threshold` 和 `tag::peaks_over_threshold_prob<>` 都满足 `tag::abstract_peaks_over_threshold` 特征，
都可以用 `peaks_over_threshold()` 提取器进行提取。结果为一个3元组，分别表示合适参数 `u_bar`, `beta_bar` 和 `xi_hat`。

[variablelist
    [[Result Type 返回类型] [``
                    boost::tuple<
                        numeric::functional::average<_sample_type_, std::size_t>::result_type // u_bar
                      , numeric::functional::average<_sample_type_, std::size_t>::result_type // beta_bar
                      , numeric::functional::average<_sample_type_, std::size_t>::result_type // xi_hat
                    >
                    ``]]
    [[Depends On 依赖于] [`count` \n
                   In addtion, `tag::peaks_over_threshold_prob<>` depends on `tail<_left_or_right_>` \n
                   另外，`tag::peaks_over_threshold_prob<>` 依赖于 `tail<_left_or_right_>`]]
    [[Variants 变体] [`peaks_over_threshold_prob<_left_or_right_>`]]
    [[Initialization Parameters 初始化参数] [ `tag::peaks_over_threshold::threshold_value` \n
                                   `tag::peaks_over_threshold_prob::threshold_probability` \n
                                   `tag::tail<_left_or_right_>::cache_size` ]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [TODO 待办]] 
]

[*Header]
[def _PEAKS_OVER_THRESHOLD_HPP_ [headerref boost/accumulators/statistics/peaks_over_threshold.hpp]]

    #include <_PEAKS_OVER_THRESHOLD_HPP_>

[*Example]

See example for [link accumulators.user_s_guide.the_statistical_accumulators_library.pot_quantile [^pot_quantile]].
\n参见 [link accumulators.user_s_guide.the_statistical_accumulators_library.pot_quantile [^pot_quantile]] 的例子。

[*See also]

* [classref boost::accumulators::impl::peaks_over_threshold_impl [^peaks_over_threshold_impl]]
* [classref boost::accumulators::impl::peaks_over_threshold_prob_impl [^peaks_over_threshold_prob_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.pot_quantile [^pot_quantile]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.pot_tail_mean [^pot_tail_mean]]

[endsect]

[section:pot_quantile pot_quantile ['and variants]]

Quantile estimation based on Peaks over Threshold method (for both left and right tails). For 
implementation details, see [classref boost::accumulators::impl::pot_quantile_impl [^pot_quantile_impl]].
\n基于高限峰值法(POT)的分位数估算(用于左右两端)。更多实现细节，请见
[classref boost::accumulators::impl::pot_quantile_impl [^pot_quantile_impl]].

Both `tag::pot_quantile<_left_or_right_>` and `tag::pot_quantile_prob<_left_or_right_>` satisfy the
`tag::quantile` feature and can be extracted using the `quantile()` extractor.
\n`tag::pot_quantile<left-or-right>` 和 `tag::pot_quantile_prob<left-or-right>` 均满足 `tag::quantile` 特征，
都可以用 `quantile()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`pot_quantile<_left_or_right_>` depends on `peaks_over_threshold<_left_or_right_>` \n
                   `pot_quantile<_left_or_right_>` 依赖于 `peaks_over_threshold<_left_or_right_>` \n
                   `pot_quantile_prob<_left_or_right_>` depends on `peaks_over_threshold_prob<_left_or_right_>` \n
                   `pot_quantile_prob<_left_or_right_>` 依赖于 `peaks_over_threshold_prob<_left_or_right_>` ]]
    [[Variants 变体] [`pot_quantile_prob<_left_or_right_>`]]
    [[Initialization Parameters 初始化参数] [ `tag::peaks_over_threshold::threshold_value` \n
                                   `tag::peaks_over_threshold_prob::threshold_probability` \n
                                   `tag::tail<_left_or_right_>::cache_size` ]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [TODO 待办]] 
]

[*Header]
[def _POT_QUANTILE_HPP_ [headerref boost/accumulators/statistics/pot_quantile.hpp]]

    #include <_POT_QUANTILE_HPP_>

[*Example]

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1.;

    double alpha = 0.999;
    double threshold_probability = 0.99;
    double threshold = 3.;
    
    // two random number generators 两个随机数生成器
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma(0,1);
    boost::exponential_distribution<> lambda(1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal(rng, mean_sigma);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::exponential_distribution<> > exponential(rng, lambda);
    
    accumulator_set<double, stats<tag::pot_quantile<right>(with_threshold_value)> > acc1(
        tag::peaks_over_threshold::threshold_value = threshold
    );
    accumulator_set<double, stats<tag::pot_quantile<right>(with_threshold_probability)> > acc2(
        tag::tail<right>::cache_size = 2000
      , tag::peaks_over_threshold_prob::threshold_probability = threshold_probability
    );
    
    threshold_probability = 0.995;
    threshold = 5.;
    
    accumulator_set<double, stats<tag::pot_quantile<right>(with_threshold_value)> > acc3(
        tag::peaks_over_threshold::threshold_value = threshold
    );
    accumulator_set<double, stats<tag::pot_quantile<right>(with_threshold_probability)> > acc4(
        tag::tail<right>::cache_size = 2000
      , tag::peaks_over_threshold_prob::threshold_probability = threshold_probability
    );
    
    for (std::size_t i = 0; i < 100000; ++i)
    {
        double sample = normal();
        acc1(sample);
        acc2(sample);
    }
    
    for (std::size_t i = 0; i < 100000; ++i)
    {
        double sample = exponential();
        acc3(sample);
        acc4(sample);
    }
    
    BOOST_CHECK_CLOSE( quantile(acc1, quantile_probability = alpha), 3.090232, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc2, quantile_probability = alpha), 3.090232, epsilon );  
    
    BOOST_CHECK_CLOSE( quantile(acc3, quantile_probability = alpha), 6.908, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc4, quantile_probability = alpha), 6.908, epsilon );  

[*See also]

* [classref boost::accumulators::impl::pot_quantile_impl [^pot_quantile_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.peaks_over_threshold [^peaks_over_threshold]]

[endsect]

[section:pot_tail_mean pot_tail_mean]

Estimation of the (coherent) tail mean based on the peaks over threshold method (for both left and right tails).
For inplementation details, see [classref boost::accumulators::impl::pot_tail_mean_impl [^pot_tail_mean_impl]].
\n基于POT的(连续)尾均值估算(用于左右两端)。更多实现细节，请见
[classref boost::accumulators::impl::pot_tail_mean_impl [^pot_tail_mean_impl]].

Both `tag::pot_tail_mean<_left_or_right_>` and `tag::pot_tail_mean_prob<_left_or_right_>` satisfy the
`tag::tail_mean` feature and can be extracted using the `tail_mean()` extractor.
\n`tag::pot_tail_mean<left-or-right>` 和 `tag::pot_tail_mean_prob<left-or-right>` 均满足 
`tag::tail_mean` 特征，都可以用 `tail_mean()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`pot_tail_mean<_left_or_right_>` depends on `peaks_over_threshold<_left_or_right_>`
                         and `pot_quantile<_left_or_right_>` \n
                   `pot_tail_mean<_left_or_right_>` 依赖于 `peaks_over_threshold<_left_or_right_>`
                         和 `pot_quantile<_left_or_right_>` \n
                   `pot_tail_mean_prob<_left_or_right_>` depends on `peaks_over_threshold_prob<_left_or_right_>`
                         and `pot_quantile_prob<_left_or_right_>` \n
                   `pot_tail_mean_prob<_left_or_right_>` 依赖于 `peaks_over_threshold_prob<_left_or_right_>`
                         和 `pot_quantile_prob<_left_or_right_>` ]]
    [[Variants 变体] [`pot_tail_mean_prob<_left_or_right_>`]]
    [[Initialization Parameters 初始化参数] [ `tag::peaks_over_threshold::threshold_value` \n
                                   `tag::peaks_over_threshold_prob::threshold_probability` \n
                                   `tag::tail<_left_or_right_>::cache_size` ]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [TODO 待办]] 
]

[*Header]
[def _POT_TAIL_MEAN_HPP_ [headerref boost/accumulators/statistics/pot_tail_mean.hpp]]

    #include <_POT_TAIL_MEAN_HPP_>

[*Example]

    // TODO

[*See also]

* [classref boost::accumulators::impl::pot_tail_mean_impl [^pot_tail_mean_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.peaks_over_threshold [^peaks_over_threshold]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.pot_quantile [^pot_quantile]]

[endsect]

[section:rolling_count rolling_count]

The rolling count is the current number of elements in the rolling window. 
\n滚动数量(rolling count)是指滚动窗口中当前的元素数量。

[variablelist
    [[Result Type 返回类型] [``std::size_t``]]
    [[Depends On 依赖于] [`rolling_window_plus1`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::rolling_window::window_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _ROLLING_COUNT_HPP_ [headerref boost/accumulators/statistics/rolling_count.hpp]]

    #include <_ROLLING_COUNT_HPP_>

[*Example]

    accumulator_set<int, stats<tag::rolling_count> > acc(tag::rolling_window::window_size = 3);

    BOOST_CHECK_EQUAL(0u, rolling_count(acc));

    acc(1);
    BOOST_CHECK_EQUAL(1u, rolling_count(acc));

    acc(1);
    BOOST_CHECK_EQUAL(2u, rolling_count(acc));

    acc(1);
    BOOST_CHECK_EQUAL(3u, rolling_count(acc));

    acc(1);
    BOOST_CHECK_EQUAL(3u, rolling_count(acc));

    acc(1);
    BOOST_CHECK_EQUAL(3u, rolling_count(acc));

[*See also]

* [classref boost::accumulators::impl::rolling_count_impl [^rolling_count_impl]]

[endsect]

[section:rolling_sum rolling_sum]

The rolling sum is the sum of the last /N/ samples. 
\n滚动和(rolling sum)是指最后 /N/ 个样本的总和。

[variablelist
    [[Result Type 返回类型] [``_sample_type_``]]
    [[Depends On 依赖于] [`rolling_window_plus1`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::rolling_window::window_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _ROLLING_SUM_HPP_ [headerref boost/accumulators/statistics/rolling_sum.hpp]]

    #include <_ROLLING_SUM_HPP_>

[*Example]

    accumulator_set<int, stats<tag::rolling_sum> > acc(tag::rolling_window::window_size = 3);

    BOOST_CHECK_EQUAL(0, rolling_sum(acc));

    acc(1);
    BOOST_CHECK_EQUAL(1, rolling_sum(acc));

    acc(2);
    BOOST_CHECK_EQUAL(3, rolling_sum(acc));

    acc(3);
    BOOST_CHECK_EQUAL(6, rolling_sum(acc));

    acc(4);
    BOOST_CHECK_EQUAL(9, rolling_sum(acc));

    acc(5);
    BOOST_CHECK_EQUAL(12, rolling_sum(acc));

[*See also]

* [classref boost::accumulators::impl::rolling_sum_impl [^rolling_sum_impl]]

[endsect]

[section:rolling_mean rolling_mean]

The rolling mean is the mean over the last /N/ samples. It is computed by dividing
the rolling sum by the rolling count.
\n滚动均值(rolling mean)是指最后 /N/ 个样本的平均值。通过将滚动和除以滚动数量计算得到。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`rolling_sum` \n `rolling_count`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::rolling_window::window_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _ROLLING_MEAN_HPP_ [headerref boost/accumulators/statistics/rolling_mean.hpp]]

    #include <_ROLLING_MEAN_HPP_>

[*Example]

    accumulator_set<int, stats<tag::rolling_mean> > acc(tag::rolling_window::window_size = 5);
    
    acc(1);
    acc(2);
    acc(3);

    BOOST_CHECK_CLOSE( rolling_mean(acc), 2.0, 1e-6 );

    acc(4);
    acc(5);
    acc(6);
    acc(7);

    BOOST_CHECK_CLOSE( rolling_mean(acc), 5.0, 1e-6 );

[*See also]

* [classref boost::accumulators::impl::rolling_mean_impl [^rolling_mean_impl]]

[endsect]

[section:skewness skewness]

The skewness of a sample distribution is defined as the ratio of the 3rd central moment and the [^3/2]-th power 
of the 2nd central moment (the variance) of the sampless 3. For implementation details, see
[classref boost::accumulators::impl::skewness_impl [^skewness_impl]].
\n样本分布的偏度被定义为样本(变异)的3次中心矩与2次中心矩的[^3/2]次方之比。更多实现细节，请见
[classref boost::accumulators::impl::skewness_impl [^skewness_impl]].

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, _sample_type_>::result_type
                    ``]]
    [[Depends On 依赖于] [`mean` \n `moment<2>` \n `moment<3>`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _SKEWNESS_HPP_ [headerref boost/accumulators/statistics/skewness.hpp]]

    #include <_SKEWNESS_HPP_>

[*Example]

    accumulator_set<int, stats<tag::skewness > > acc2;
    
    acc2(2);
    acc2(7);
    acc2(4);
    acc2(9);
    acc2(3);
    
    BOOST_CHECK_EQUAL( mean(acc2), 5 );
    BOOST_CHECK_EQUAL( moment<2>(acc2), 159./5. );
    BOOST_CHECK_EQUAL( moment<3>(acc2), 1171./5. );
    BOOST_CHECK_CLOSE( skewness(acc2), 0.406040288214, 1e-6 );

[*See also]

* [classref boost::accumulators::impl::skewness_impl [^skewness_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.mean [^mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.moment [^moment]]

[endsect]

[section:sum sum ['and variants]]

For summing the samples, weights or variates. 
\n用于对样本、权重或变值进行求和。

[variablelist
    [[Result Type 返回类型] [`_sample_type_` for summing samples \n
                    `_sample_type_` 对于样本求和 \n
                    `_weight_type_` for summing weights \n
                    `_weight_type_` 对于权重求和 \n
                    `_variate_type_` for summing variates \n
                    `_variate_type_` 对于变值求和]]
    [[Depends On 依赖于] [['none 无]]]
    [[Variants 变体] [`tag::sum` \n
                 `tag::sum_of_weights` \n
                 `tag::sum_of_variates<_variate_type_, _variate_tag_>`]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [`weight` for summing weights \n
                               `weight` 对于权重求和 \n
                               `_variate_tag_` for summing variates \n
                               `_variate_tag_` 对于变值求和]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _SUM_HPP_ [headerref boost/accumulators/statistics/sum.hpp]]

    #include <_SUM_HPP_>

[*Example]

    accumulator_set<
        int
      , stats<
            tag::sum
          , tag::sum_of_weights
          , tag::sum_of_variates<int, tag::covariate1>
        >
      , int
    > acc;

    acc(1, weight = 2, covariate1 = 3);
    BOOST_CHECK_EQUAL(2, sum(acc));  // weighted sample = 1 * 2 加权样本 = 1 * 2
    BOOST_CHECK_EQUAL(2, sum_of_weights(acc));
    BOOST_CHECK_EQUAL(3, sum_of_variates(acc));

    acc(2, weight = 4, covariate1 = 6);
    BOOST_CHECK_EQUAL(10, sum(acc)); // weighted sample = 2 * 4 加权样本 = 2 * 4
    BOOST_CHECK_EQUAL(6, sum_of_weights(acc));
    BOOST_CHECK_EQUAL(9, sum_of_variates(acc));

    acc(3, weight = 6, covariate1 = 9);
    BOOST_CHECK_EQUAL(28, sum(acc)); // weighted sample = 3 * 6 加权样本 = 3 * 6
    BOOST_CHECK_EQUAL(12, sum_of_weights(acc));
    BOOST_CHECK_EQUAL(18, sum_of_variates(acc));

[*See also]

* [classref boost::accumulators::impl::sum_impl [^sum_impl]]

[endsect]

[section:tail tail]

Tracks the largest or smallest [^N] values. `tag::tail<right>` tracks the largest [^N],
and `tag::tail<left>` tracks the smallest. The parameter [^N] is specified with the
`tag::tail<_left_or_right_>::cache_size` initialization parameter. For implementation details, see
[classref boost::accumulators::impl::tail_impl [^tail_impl]].
\n跟踪最大或最小的 [^N] 个值。`tag::tail<right>` 跟踪最大的 [^N] 个，而 `tag::tail<left>` 则跟踪最小的。
参数 [^N] 以初始化参数 `tag::tail<left-or-right>::cache_size` 指定。更多实现细节，请见
[classref boost::accumulators::impl::tail_impl [^tail_impl]].

Both `tag::tail<left>` and `tag::tail<right>` satisfy the `tag::abstract_tail` feature and 
can be extracted with the `tail()` extractor.
\n`tag::tail<left>` 和 `tag::tail<right>` 均满足 `tag::abstract_tail` 特征，
都可以用 `tail()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [``
                    boost::iterator_range<
                        boost::reverse_iterator<
                            boost::permutation_iterator<
                                std::vector<_sample_type_>::const_iterator  // samples
                              , std::vector<std::size_t>::iterator          // indices
                            >
                        >
                    >
                    ``]]
    [[Depends On 依赖于] [['none 无]]]
    [[Variants 变体] [`abstract_tail`]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _TAIL_HPP_ [headerref boost/accumulators/statistics/tail.hpp]]

    #include <_TAIL_HPP_>

[*Example]

See the Example for [link accumulators.user_s_guide.the_statistical_accumulators_library.tail_variate [^tail_variate]].
\n参见 [link accumulators.user_s_guide.the_statistical_accumulators_library.tail_variate [^tail_variate]] 的例子。

[*See also]

* [classref boost::accumulators::impl::tail_impl [^tail_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail_variate [^tail_variate]]

[endsect]

[section:coherent_tail_mean coherent_tail_mean]

Estimation of the coherent tail mean based on order statistics (for both left and right tails).
The left coherent tail mean feature is `tag::coherent_tail_mean<left>`, and the right choherent
tail mean feature is `tag::coherent_tail_mean<right>`. They both share the `tag::tail_mean` feature
and can be extracted with the `tail_mean()` extractor. For more implementation details, see
[classref boost::accumulators::impl::coherent_tail_mean_impl [^coherent_tail_mean_impl]]
\n基于次序统计估算连续尾均值(用于左右两端)。左端连续尾均值特征为 `tag::coherent_tail_mean<left>`，
而右端连续尾均值特征为 `tag::coherent_tail_mean<right>`。两者共享 `tag::tail_mean` 特征，都可以用 
`tail_mean()` 提取器进行提取。更多实现细节，
[classref boost::accumulators::impl::coherent_tail_mean_impl [^coherent_tail_mean_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`count` \n `quantile` \n `non_coherent_tail_mean<_left_or_right_>`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _TAIL_MEAN_HPP_ [headerref boost/accumulators/statistics/tail_mean.hpp]]

    #include <_TAIL_MEAN_HPP_>

[*Example]

See the example for 
[link accumulators.user_s_guide.the_statistical_accumulators_library.non_coherent_tail_mean [^non_coherent_tail_mean]].
\n参见 [link accumulators.user_s_guide.the_statistical_accumulators_library.non_coherent_tail_mean [^non_coherent_tail_mean]] 的例子。

[*See also]

* [classref boost::accumulators::impl::coherent_tail_mean_impl [^coherent_tail_mean_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.extended_p_square_quantile [^extended_p_square_quantile]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.pot_quantile [^pot_quantile]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail_quantile [^tail_quantile]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.non_coherent_tail_mean [^non_coherent_tail_mean]]

[endsect]

[section:non_coherent_tail_mean non_coherent_tail_mean]

Estimation of the (non-coherent) tail mean based on order statistics (for both left and right tails).
The left non-coherent tail mean feature is `tag::non_coherent_tail_mean<left>`, and the right non-choherent
tail mean feature is `tag::non_coherent_tail_mean<right>`. They both share the `tag::abstract_non_coherent_tail_mean`
feature and can be extracted with the `non_coherent_tail_mean()` extractor. For more implementation details, see
[classref boost::accumulators::impl::non_coherent_tail_mean_impl [^non_coherent_tail_mean_impl]]
\n基于次序统计估算(松散)尾均值(用于左右两端)。左端松散尾均值的特征为 `tag::non_coherent_tail_mean<left>`，
而右端松散尾均值的特征为 `tag::non_coherent_tail_mean<right>`。它们共享 `tag::abstract_non_coherent_tail_mean` 特征，
都可以用 `non_coherent_tail_mean()` 提取器进行提取。更多实现细节，请见 
[classref boost::accumulators::impl::non_coherent_tail_mean_impl [^non_coherent_tail_mean_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`count` \n `tail<_left_or_right_>`]]
    [[Variants 变体] [`abstract_non_coherent_tail_mean`]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _TAIL_MEAN_HPP_ [headerref boost/accumulators/statistics/tail_mean.hpp]]

    #include <_TAIL_MEAN_HPP_>

[*Example]

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1;
    
    std::size_t n = 100000; // number of MC steps  MC步数
    std::size_t c =  10000; // cache size  缓存大小
    
    typedef accumulator_set<double, stats<tag::non_coherent_tail_mean<right>, tag::tail_quantile<right> > > accumulator_t_right1;
    typedef accumulator_set<double, stats<tag::non_coherent_tail_mean<left>, tag::tail_quantile<left> > > accumulator_t_left1;
    typedef accumulator_set<double, stats<tag::coherent_tail_mean<right>, tag::tail_quantile<right> > > accumulator_t_right2;
    typedef accumulator_set<double, stats<tag::coherent_tail_mean<left>, tag::tail_quantile<left> > > accumulator_t_left2;
    
    accumulator_t_right1 acc0( right_tail_cache_size = c );
    accumulator_t_left1 acc1( left_tail_cache_size = c );
    accumulator_t_right2 acc2( right_tail_cache_size = c );
    accumulator_t_left2 acc3( left_tail_cache_size = c );
    
    // a random number generator 随机数生成器
    boost::lagged_fibonacci607 rng;
    
    for (std::size_t i = 0; i < n; ++i)
    {
        double sample = rng();
        acc0(sample);
        acc1(sample);
        acc2(sample);
        acc3(sample);
    }
    
    // check uniform distribution 检查均衡分布
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc0, quantile_probability = 0.95), 0.975, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc0, quantile_probability = 0.975), 0.9875, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc0, quantile_probability = 0.99), 0.995, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc0, quantile_probability = 0.999), 0.9995, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc1, quantile_probability = 0.05), 0.025, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc1, quantile_probability = 0.025), 0.0125, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc1, quantile_probability = 0.01), 0.005, 5 );
    BOOST_CHECK_CLOSE( non_coherent_tail_mean(acc1, quantile_probability = 0.001), 0.0005, 10 );
    BOOST_CHECK_CLOSE( tail_mean(acc2, quantile_probability = 0.95), 0.975, epsilon );
    BOOST_CHECK_CLOSE( tail_mean(acc2, quantile_probability = 0.975), 0.9875, epsilon );
    BOOST_CHECK_CLOSE( tail_mean(acc2, quantile_probability = 0.99), 0.995, epsilon );
    BOOST_CHECK_CLOSE( tail_mean(acc2, quantile_probability = 0.999), 0.9995, epsilon );
    BOOST_CHECK_CLOSE( tail_mean(acc3, quantile_probability = 0.05), 0.025, epsilon );
    BOOST_CHECK_CLOSE( tail_mean(acc3, quantile_probability = 0.025), 0.0125, epsilon );
    BOOST_CHECK_CLOSE( tail_mean(acc3, quantile_probability = 0.01), 0.005, 5 );
    BOOST_CHECK_CLOSE( tail_mean(acc3, quantile_probability = 0.001), 0.0005, 10 );

[*See also]

* [classref boost::accumulators::impl::non_coherent_tail_mean_impl [^non_coherent_tail_mean_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]

[endsect]

[section:tail_quantile tail_quantile]

Tail quantile estimation based on order statistics (for both left and right tails).
The left tail quantile feature is `tag::tail_quantile<left>`, and the right
tail quantile feature is `tag::tail_quantile<right>`. They both share the `tag::quantile`
feature and can be extracted with the `quantile()` extractor. For more implementation details, see
[classref boost::accumulators::impl::tail_quantile_impl [^tail_quantile_impl]]
\n基于次序统计的尾部分位数估算(用于左右两端)。左端尾部分位数的特征为 `tag::tail_quantile<left>`，
右端尾部分位数的特征为 `tag::tail_quantile<right>`。它们共享 `tag::quantile` 特征，
都可以用 `quantile()` 提取器进行提取。更多实现细节，请见
[classref boost::accumulators::impl::tail_quantile_impl [^tail_quantile_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    _sample_type_
                    ``]]
    [[Depends On 依赖于] [`count` \n `tail<_left_or_right_>`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _TAIL_QUANTILE_HPP_ [headerref boost/accumulators/statistics/tail_quantile.hpp]]

    #include <_TAIL_QUANTILE_HPP_>

[*Example]

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1;
    
    std::size_t n = 100000; // number of MC steps  MC步数
    std::size_t c =  10000; // cache size  缓存大小
        
    typedef accumulator_set<double, stats<tag::tail_quantile<right> > > accumulator_t_right;
    typedef accumulator_set<double, stats<tag::tail_quantile<left> > > accumulator_t_left;
    
    accumulator_t_right acc0( tag::tail<right>::cache_size = c );
    accumulator_t_right acc1( tag::tail<right>::cache_size = c );
    accumulator_t_left  acc2( tag::tail<left>::cache_size = c );
    accumulator_t_left  acc3( tag::tail<left>::cache_size = c );
    
    // two random number generators 两个随机数生成器
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma(0,1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal(rng, mean_sigma);
                    
    for (std::size_t i = 0; i < n; ++i)
    {
        double sample1 = rng();
        double sample2 = normal();
        acc0(sample1);
        acc1(sample2);
        acc2(sample1);
        acc3(sample2);
    }
    
    // check uniform distribution 检查均衡分布
    BOOST_CHECK_CLOSE( quantile(acc0, quantile_probability = 0.95 ), 0.95,  epsilon );
    BOOST_CHECK_CLOSE( quantile(acc0, quantile_probability = 0.975), 0.975, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc0, quantile_probability = 0.99 ), 0.99,  epsilon );
    BOOST_CHECK_CLOSE( quantile(acc0, quantile_probability = 0.999), 0.999, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc2, quantile_probability  = 0.05 ), 0.05,  2 );
    BOOST_CHECK_CLOSE( quantile(acc2, quantile_probability  = 0.025), 0.025, 2 );
    BOOST_CHECK_CLOSE( quantile(acc2, quantile_probability  = 0.01 ), 0.01,  3 );
    BOOST_CHECK_CLOSE( quantile(acc2, quantile_probability  = 0.001), 0.001, 20 );
    
    // check standard normal distribution 检查标准正态分布
    BOOST_CHECK_CLOSE( quantile(acc1, quantile_probability = 0.975),  1.959963, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc1, quantile_probability = 0.999),  3.090232, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc3, quantile_probability  = 0.025), -1.959963, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc3, quantile_probability  = 0.001), -3.090232, epsilon );

[*See also]

* [classref boost::accumulators::impl::tail_quantile_impl [^tail_quantile_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]

[endsect]

[section:tail_variate tail_variate]

Tracks the covariates of largest or smallest [^N] samples. 
`tag::tail_variate<_variate_type_, _variate_tag_, right>` tracks the covariate associated with 
_variate_tag_ for the largest [^N], and `tag::tail_variate<_variate_type_, _variate_tag_, left>`
for the smallest. The parameter [^N] is specified with the `tag::tail<_left_or_right_>::cache_size` 
initialization parameter. For implementation details, see
[classref boost::accumulators::impl::tail_variate_impl [^tail_variate_impl]].
\n跟踪最大或最小的 [^N] 个样本的协变量。`tag::tail_variate<_variate_type_, _variate_tag_, right>` 
跟踪最大 [^N] 个样本的与 _variate_tag_ 相关联的协变量，而 `tag::tail_variate<_variate_type_, _variate_tag_, left>`
则用于最小样本。参数 [^N] 由 `tag::tail<_left_or_right_>::cache_size` 初始化参数指定。更多实现细节，请见
[classref boost::accumulators::impl::tail_variate_impl [^tail_variate_impl]].

Both `tag::tail_variate<_variate_type_, _variate_tag_, right>` and 
`tag::tail_variate<_variate_type_, _variate_tag_, left>` satisfy the `tag::abstract_tail_variate` feature
and can be extracted with the `tail_variate()` extractor.
\n`tag::tail_variate<_variate_type_, _variate_tag_, right>` 和 `tag::tail_variate<_variate_type_, _variate_tag_, left>`
均满足 `tag::abstract_tail_variate` 特征，都可以用 `tail_variate()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [``
                    boost::iterator_range<
                        boost::reverse_iterator<
                            boost::permutation_iterator<
                                std::vector<_variate_type_>::const_iterator // variates
                              , std::vector<std::size_t>::iterator          // indices
                            >
                        >
                    >
                    ``]]
    [[Depends On 依赖于] [`tail<_left_or_right_>`]]
    [[Variants 变体] [`abstract_tail_variate`]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _TAIL_VARIATE_HPP_ [headerref boost/accumulators/statistics/tail_variate.hpp]]

    #include <_TAIL_VARIATE_HPP_>

[*Example]

    accumulator_set<int, stats<tag::tail_variate<int, tag::covariate1, right> > > acc(
        tag::tail<right>::cache_size = 4
    );
    
    acc(8, covariate1 = 3);
    CHECK_RANGE_EQUAL(tail(acc), {8});
    CHECK_RANGE_EQUAL(tail_variate(acc), {3});
    
    acc(16, covariate1 = 1);
    CHECK_RANGE_EQUAL(tail(acc), {16, 8});
    CHECK_RANGE_EQUAL(tail_variate(acc), {1, 3});

    acc(12, covariate1 = 4);
    CHECK_RANGE_EQUAL(tail(acc), {16, 12, 8});
    CHECK_RANGE_EQUAL(tail_variate(acc), {1, 4, 3});

    acc(24, covariate1 = 5);
    CHECK_RANGE_EQUAL(tail(acc), {24, 16, 12, 8});
    CHECK_RANGE_EQUAL(tail_variate(acc), {5, 1, 4, 3});

    acc(1, covariate1 = 9);
    CHECK_RANGE_EQUAL(tail(acc), {24, 16, 12, 8});
    CHECK_RANGE_EQUAL(tail_variate(acc), {5, 1, 4, 3});

    acc(9, covariate1 = 7);
    CHECK_RANGE_EQUAL(tail(acc), {24,  16, 12, 9});
    CHECK_RANGE_EQUAL(tail_variate(acc), {5, 1, 4, 7});

[*See also]

* [classref boost::accumulators::impl::tail_variate_impl [^tail_variate_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]

[endsect]

[section:tail_variate_means tail_variate_means ['and variants]]

Estimation of the absolute and relative tail variate means (for both left and right tails).
The absolute tail variate means has the feature 
`tag::absolute_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`
and the relative tail variate mean has the feature
`tag::relative_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`. All
absolute tail variate mean features share the `tag::abstract_absolute_tail_variate_means`
feature and can be extracted with the `tail_variate_means()` extractor. All the
relative tail variate mean features share the `tag::abstract_relative_tail_variate_means`
feature and can be extracted with the `relative_tail_variate_means()` extractor.
\n估算绝对和相对的尾部变值平均值(用于左右两端)。绝对尾部变值平均值具有特征 
`tag::absolute_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`，
而相对尾部变值平均值具有特征 `tag::relative_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`。
所有绝对尾部变值平均值共享 `tag::abstract_absolute_tail_variate_means` 特征并可以用 `tail_variate_means()`
提取器进行提取。所有相对尾部变值平均值共享 `tag::abstract_relative_tail_variate_means` 特征并可以用 
`relative_tail_variate_means()` 提取器进行提取。

For more implementation details, see
[classref boost::accumulators::impl::tail_variate_means_impl [^tail_variate_means_impl]]
\n更多实现细节，请见[classref boost::accumulators::impl::tail_variate_means_impl [^tail_variate_means_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    boost::iterator_range<
                        std::vector<
                            numeric::functional::average<_sample_type_, std::size_t>::result_type
                        >::iterator
                    >
                    ``]]
    [[Depends On 依赖于] [`non_coherent_tail_mean<_left_or_right_>` \n 
                   `tail_variate<_variate_type_, _variate_tag_, _left_or_right_>`]]
    [[Variants 变体] [`tag::absolute_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>` \n
                 `tag::relative_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _TAIL_VARIATE_MEANS_HPP_ [headerref boost/accumulators/statistics/tail_variate_means.hpp]]

    #include <_TAIL_VARIATE_MEANS_HPP_>

[*Example]

    std::size_t c = 5; // cache size 缓存大小
    
    typedef double variate_type;
    typedef std::vector<variate_type> variate_set_type;
    
    typedef accumulator_set<double, stats<
        tag::tail_variate_means<right, variate_set_type, tag::covariate1>(relative)>, tag::tail<right> >
    accumulator_t1;
    
    typedef accumulator_set<double, stats<
        tag::tail_variate_means<right, variate_set_type, tag::covariate1>(absolute)>, tag::tail<right> >
    accumulator_t2;
    
    typedef accumulator_set<double, stats<
        tag::tail_variate_means<left, variate_set_type, tag::covariate1>(relative)>, tag::tail<left> >
    accumulator_t3;
    
    typedef accumulator_set<double, stats<
        tag::tail_variate_means<left, variate_set_type, tag::covariate1>(absolute)>, tag::tail<left> >
    accumulator_t4;
    
    accumulator_t1 acc1( right_tail_cache_size = c );
    accumulator_t2 acc2( right_tail_cache_size = c );
    accumulator_t3 acc3( left_tail_cache_size = c );
    accumulator_t4 acc4( left_tail_cache_size = c );
    
    variate_set_type cov1, cov2, cov3, cov4, cov5;
    double c1[] = { 10., 20., 30., 40. }; // 100
    double c2[] = { 26.,  4., 17.,  3. }; // 50
    double c3[] = { 46., 64., 40., 50. }; // 200
    double c4[] = {  1.,  3., 70.,  6. }; // 80
    double c5[] = {  2.,  2.,  2., 14. }; // 20
    cov1.assign(c1, c1 + sizeof(c1)/sizeof(variate_type));
    cov2.assign(c2, c2 + sizeof(c2)/sizeof(variate_type));
    cov3.assign(c3, c3 + sizeof(c3)/sizeof(variate_type));
    cov4.assign(c4, c4 + sizeof(c4)/sizeof(variate_type));
    cov5.assign(c5, c5 + sizeof(c5)/sizeof(variate_type));            
    
    acc1(100., covariate1 = cov1);
    acc1( 50., covariate1 = cov2);
    acc1(200., covariate1 = cov3);
    acc1( 80., covariate1 = cov4);
    acc1( 20., covariate1 = cov5);
    
    acc2(100., covariate1 = cov1);
    acc2( 50., covariate1 = cov2);
    acc2(200., covariate1 = cov3);
    acc2( 80., covariate1 = cov4);
    acc2( 20., covariate1 = cov5);
    
    acc3(100., covariate1 = cov1);
    acc3( 50., covariate1 = cov2);
    acc3(200., covariate1 = cov3);
    acc3( 80., covariate1 = cov4);
    acc3( 20., covariate1 = cov5);
    
    acc4(100., covariate1 = cov1);
    acc4( 50., covariate1 = cov2);
    acc4(200., covariate1 = cov3);
    acc4( 80., covariate1 = cov4);
    acc4( 20., covariate1 = cov5);
   
    // check relative risk contributions 检查相对风险分布
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.7).begin()     ), 14./75. ); // (10 + 46) / 300 = 14/75
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.7).begin() + 1),  7./25. ); // (20 + 64) / 300 =  7/25
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.7).begin() + 2),  7./30. ); // (30 + 40) / 300 =  7/30
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.7).begin() + 3),  3./10. ); // (40 + 50) / 300 =  3/10
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.3).begin()    ), 14./35. ); // (26 +  2) /  70 = 14/35
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.3).begin() + 1),  3./35. ); // ( 4 +  2) /  70 =  3/35
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.3).begin() + 2), 19./70. ); // (17 +  2) /  70 = 19/70
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.3).begin() + 3), 17./70. ); // ( 3 + 14) /  70 = 17/70
    
    // check absolute risk contributions 检查绝对风险分布
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.7).begin()    ), 28 ); // (10 + 46) / 2 = 28
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.7).begin() + 1), 42 ); // (20 + 64) / 2 = 42
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.7).begin() + 2), 35 ); // (30 + 40) / 2 = 35
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.7).begin() + 3), 45 ); // (40 + 50) / 2 = 45
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.3).begin()    ), 14 ); // (26 +  2) / 2 = 14
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.3).begin() + 1),  3 ); // ( 4 +  2) / 2 =  3
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.3).begin() + 2),9.5 ); // (17 +  2) / 2 =  9.5
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.3).begin() + 3),8.5 ); // ( 3 + 14) / 2 =  8.5
    
    // check relative risk contributions 检查相对风险分布
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.9).begin()    ), 23./100. ); // 46/200 = 23/100
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.9).begin() + 1),  8./25.  ); // 64/200 =  8/25
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.9).begin() + 2),  1./5.   ); // 40/200 =  1/5
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc1, quantile_probability = 0.9).begin() + 3),  1./4.   ); // 50/200 =  1/4
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.1).begin()    ),  1./10.  ); //  2/ 20 =  1/10
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.1).begin() + 1),  1./10.  ); //  2/ 20 =  1/10
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.1).begin() + 2),  1./10.  ); //  2/ 20 =  1/10
    BOOST_CHECK_EQUAL( *(relative_tail_variate_means(acc3, quantile_probability = 0.1).begin() + 3),  7./10.  ); // 14/ 20 =  7/10
    
    // check absolute risk contributions 检查绝对风险分布
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.9).begin()    ), 46 ); // 46
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.9).begin() + 1), 64 ); // 64
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.9).begin() + 2), 40 ); // 40
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc2, quantile_probability = 0.9).begin() + 3), 50 ); // 50
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.1).begin()    ),  2 ); //  2
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.1).begin() + 1),  2 ); //  2
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.1).begin() + 2),  2 ); //  2
    BOOST_CHECK_EQUAL( *(tail_variate_means(acc4, quantile_probability = 0.1).begin() + 3), 14 ); // 14

[*See also]

* [classref boost::accumulators::impl::tail_variate_means_impl [^tail_variate_means_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.non_coherent_tail_mean [^non_coherent_tail_mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail_variate [^tail_variate]]

[endsect]

[section:variance variance ['and variants]]

Lazy or iterative calculation of the variance. The lazy calculation is associated with the `tag::lazy_variance`
feature, and the iterative calculation with the `tag::variance` feature. Both can be extracted
using the `tag::variance()` extractor. For more implementation details, see
[classref boost::accumulators::impl::lazy_variance_impl [^lazy_variance_impl]] and
[classref boost::accumulators::impl::variance_impl [^variance_impl]]
\n对变值的延迟或迭代计算。延迟计算方式以 `tag::lazy_variance` 特征相关联，而迭代计算方式以
`tag::variance` 特征相关联。两者均可用 `tag::variance()` 提取器进行提取。更多实现细节，请见
[classref boost::accumulators::impl::lazy_variance_impl [^lazy_variance_impl]] 和
[classref boost::accumulators::impl::variance_impl [^variance_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`tag::lazy_variance` depends on `tag::moment<2>` and `tag::mean` \n
                   `tag::lazy_variance` 依赖于 `tag::moment<2>` 和 `tag::mean` \n
                   `tag::variance` depends on `tag::count` and `tag::immediate_mean` \n
                   `tag::variance` 依赖于 `tag::count` 和 `tag::immediate_mean`]]
    [[Variants 变体] [`tag::lazy_variance` (a.k.a. `tag::variance(lazy))` \n
                 `tag::variance` (a.k.a. `tag::variance(immediate)`)]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _VARIANCE_HPP_ [headerref boost/accumulators/statistics/variance.hpp]]

    #include <_VARIANCE_HPP_>

[*Example]

    // lazy variance 延迟方式
    accumulator_set<int, stats<tag::variance(lazy)> > acc1;

    acc1(1);
    acc1(2);
    acc1(3);
    acc1(4);
    acc1(5);

    BOOST_CHECK_EQUAL(5u, count(acc1));
    BOOST_CHECK_CLOSE(3., mean(acc1), 1e-5);
    BOOST_CHECK_CLOSE(11., moment<2>(acc1), 1e-5);
    BOOST_CHECK_CLOSE(2., variance(acc1), 1e-5);

    // immediate variance 立即方式
    accumulator_set<int, stats<tag::variance> > acc2;

    acc2(1);
    acc2(2);
    acc2(3);
    acc2(4);
    acc2(5);

    BOOST_CHECK_EQUAL(5u, count(acc2));
    BOOST_CHECK_CLOSE(3., mean(acc2), 1e-5);
    BOOST_CHECK_CLOSE(2., variance(acc2), 1e-5);

[*See also]

* [classref boost::accumulators::impl::lazy_variance_impl [^lazy_variance_impl]]
* [classref boost::accumulators::impl::variance_impl [^variance_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.mean [^mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.moment [^moment]]

[endsect]

[section:weighted_covariance weighted_covariance]

An iterative Monte Carlo estimator for the weighted covariance. The feature is specified as
`tag::weighted_covariance<_variate_type_, _variate_tag_>` and is extracted with the `weighted_variate()`
extractor. For more implementation details, see 
[classref boost::accumulators::impl::weighted_covariance_impl [^weighted_covariance_impl]]
\n用于加权协方差的迭代蒙特卡洛估算法。该特征以 `tag::weighted_covariance<_variate_type_, _variate_tag_>` 指定，
并用 `weighted_variate()` 提取器进行提取。更多实现细节，请见
[classref boost::accumulators::impl::weighted_covariance_impl [^weighted_covariance_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::outer_product<
                        numeric::functional::multiplies<
                            _weight_type_
                          , numeric::functional::average<_sample_type_, std::size_t>::result_type
                        >::result_type
                      , numeric::functional::multiplies<
                            _weight_type_
                          , numeric::functional::average<_variate_type_, std::size_t>::result_type
                        >::result_type
                    >
                    ``]]
    [[Depends On 依赖于] [`count` \n 
                   `sum_of_weights` \n 
                   `weighted_mean` \n 
                   `weighted_mean_of_variates<_variate_type_, _variate_tag_>`]]
    [[Variants 变体] [`abstract_weighted_covariance`]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [`weight` \n
                               `_variate_tag_`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_COVARIANCE_HPP_ [headerref boost/accumulators/statistics/weighted_covariance.hpp]]

    #include <_WEIGHTED_COVARIANCE_HPP_>

[*Example]

    accumulator_set<double, stats<tag::weighted_covariance<double, tag::covariate1> >, double > acc;

    acc(1., weight = 1.1, covariate1 = 2.);
    acc(1., weight = 2.2, covariate1 = 4.);
    acc(2., weight = 3.3, covariate1 = 3.);
    acc(6., weight = 4.4, covariate1 = 1.);        

    double epsilon = 1e-6;
    BOOST_CHECK_CLOSE(weighted_covariance(acc), -2.39, epsilon);

[*See also]

* [classref boost::accumulators::impl::weighted_covariance_impl [^weighted_covariance_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_mean [^weighted_mean]]

[endsect]

[section:weighted_density weighted_density]

The `tag::weighted_density` feature returns a histogram of the weighted sample distribution. For more
implementation details, see [classref boost::accumulators::impl::weighted_density_impl [^weighted_density_impl]].
\n`tag::weighted_density` 特征返回加权样本分布的直方图。更多实现细节，请见
[classref boost::accumulators::impl::weighted_density_impl [^weighted_density_impl]].

[variablelist
    [[Result Type 返回类型] [``
                    iterator_range<
                        std::vector<
                            std::pair<
                                numeric::functional::average<_weight_type_, std::size_t>::result_type
                              , numeric::functional::average<_weight_type_, std::size_t>::result_type
                            >
                        >::iterator
                    >
                    ``]]
    [[Depends On 依赖于] [`count` \n `sum_of_weights` \n `min` \n `max`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::weighted_density::cache_size` \n `tag::weighted_density::num_bins`]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(N), when N is `weighted_density::num_bins` \n O(N), 其中 N 为 `weighted_density::num_bins`]] 
]

[*Header]
[def _WEIGHTED_DENSITY_HPP_ [headerref boost/accumulators/statistics/weighted_density.hpp]]

    #include <_WEIGHTED_DENSITY_HPP_>

[/ TODO add example ]

[*See also]

* [classref boost::accumulators::impl::weighted_density_impl [^weighted_density_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.min [^min]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.max [^max]]

[endsect]

[section:weighted_extended_p_square weighted_extended_p_square]

Multiple quantile estimation with the extended [^P^2] algorithm for weighted samples. For further 
details, see [classref boost::accumulators::impl::weighted_extended_p_square_impl [^weighted_extended_p_square_impl]].
\n用于加权样本的多重分位数估算，使用扩展的 [^P^2] 算法。更多细节请见
[classref boost::accumulators::impl::weighted_extended_p_square_impl [^weighted_extended_p_square_impl]].

[variablelist
    [[Result Type 返回类型] [``
                    boost::iterator_range<
                        _implementation_defined_
                    >
                    ``]]
    [[Depends On 依赖于] [`count` \n `sum_of_weights`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::weighted_extended_p_square::probabilities`]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_EXTENDED_P_SQUARE_HPP_ [headerref boost/accumulators/statistics/weighted_extended_p_square.hpp]]

    #include <_WEIGHTED_EXTENDED_P_SQUARE_HPP_>

[*Example]

    typedef accumulator_set<double, stats<tag::weighted_extended_p_square>, double> accumulator_t;

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1;
    
    // some random number generators 一些随机数生成器
    double mu1 = -1.0;
    double mu2 =  1.0;
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma1(mu1, 1);
    boost::normal_distribution<> mean_sigma2(mu2, 1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal1(rng, mean_sigma1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal2(rng, mean_sigma2);
    
    std::vector<double> probs_uniform, probs_normal1, probs_normal2, probs_normal_exact1, probs_normal_exact2;
    
    double p1[] = {/*0.001,*/ 0.01, 0.1, 0.5, 0.9, 0.99, 0.999};
    probs_uniform.assign(p1, p1 + sizeof(p1) / sizeof(double));
    
    double p2[] = {0.001, 0.025};
    double p3[] = {0.975, 0.999};
    probs_normal1.assign(p2, p2 + sizeof(p2) / sizeof(double));
    probs_normal2.assign(p3, p3 + sizeof(p3) / sizeof(double));
    
    double p4[] = {-3.090232, -1.959963};
    double p5[] = {1.959963, 3.090232};
    probs_normal_exact1.assign(p4, p4 + sizeof(p4) / sizeof(double));
    probs_normal_exact2.assign(p5, p5 + sizeof(p5) / sizeof(double));
    
    accumulator_t acc_uniform(tag::weighted_extended_p_square::probabilities = probs_uniform);
    accumulator_t acc_normal1(tag::weighted_extended_p_square::probabilities = probs_normal1);
    accumulator_t acc_normal2(tag::weighted_extended_p_square::probabilities = probs_normal2);
    
    for (std::size_t i = 0; i < 100000; ++i)
    {
        acc_uniform(rng(), weight = 1.);
        
        double sample1 = normal1();
        double sample2 = normal2();
        acc_normal1(sample1, weight = std::exp(-mu1 * (sample1 - 0.5 * mu1)));
        acc_normal2(sample2, weight = std::exp(-mu2 * (sample2 - 0.5 * mu2)));
    }
    
    // check for uniform distribution 检验均衡分布 
    for (std::size_t i = 0; i < probs_uniform.size(); ++i)
    {
        BOOST_CHECK_CLOSE(weighted_extended_p_square(acc_uniform)[i], probs_uniform[i], epsilon);
    }
    
    // check for standard normal distribution 检验标准正态分布
    for (std::size_t i = 0; i < probs_normal1.size(); ++i)
    {
        BOOST_CHECK_CLOSE(weighted_extended_p_square(acc_normal1)[i], probs_normal_exact1[i], epsilon);
        BOOST_CHECK_CLOSE(weighted_extended_p_square(acc_normal2)[i], probs_normal_exact2[i], epsilon);
    }

[*See also]

* [classref boost::accumulators::impl::weighted_extended_p_square_impl [^weighted_extended_p_square_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]

[endsect]

[section:weighted_kurtosis weighted_kurtosis]

The kurtosis of a sample distribution is defined as the ratio of the 4th central moment and the
square of the 2nd central moment (the variance) of the samples, minus 3. The term [^-3] is added
in order to ensure that the normal distribution has zero kurtosis. For more implementation 
details, see [classref boost::accumulators::impl::weighted_kurtosis_impl [^weighted_kurtosis_impl]]
\n样本分布的峰度被定义为样本(变异)的4次中心矩与2次中心矩平方之比减3。
其中的 [^-3] 是为了确保正态分布的峰度为零。更多实现细节，请见 
[classref boost::accumulators::impl::weighted_kurtosis_impl [^weighted_kurtosis_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<
                        numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                      , numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`weighted_mean` \n `weighted_moment<2>` \n `weighted_moment<3>` \n `weighted_moment<4>`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_KURTOSIS_HPP_ [headerref boost/accumulators/statistics/weighted_kurtosis.hpp]]

    #include <_WEIGHTED_KURTOSIS_HPP_>

[*Example]

    accumulator_set<int, stats<tag::weighted_kurtosis>, int > acc2;
    
    acc2(2, weight = 4);
    acc2(7, weight = 1);
    acc2(4, weight = 3);
    acc2(9, weight = 1);
    acc2(3, weight = 2);
    
    BOOST_CHECK_EQUAL( weighted_mean(acc2), 42./11. );
    BOOST_CHECK_EQUAL( weighted_moment<2>(acc2), 212./11. );
    BOOST_CHECK_EQUAL( weighted_moment<3>(acc2), 1350./11. );
    BOOST_CHECK_EQUAL( weighted_moment<4>(acc2), 9956./11. );
    BOOST_CHECK_CLOSE( weighted_kurtosis(acc2), 0.58137026432, 1e-6 );

[*See also]

* [classref boost::accumulators::impl::weighted_kurtosis_impl [^weighted_kurtosis_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_mean [^weighted_mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_moment [^weighted_moment]]

[endsect]

[section:weighted_mean weighted_mean ['and variants]]

Calculates the weighted mean of samples or variates. The calculation is either
lazy (in the result extractor), or immediate (in the accumulator). The lazy implementation
is the default. For more implementation details, see 
[classref boost::accumulators::impl::weighted_mean_impl [^weighted_mean_impl]] or.
[classref boost::accumulators::impl::immediate_weighted_mean_impl [^immediate_weighted_mean_impl]]
\n计算样本或变值的加权平均值。计算方式可以是延迟的(在结果提取器中计算)，或立即的(在累加器中计算)。
缺省方式是延迟的。更多实现细节，请见
[classref boost::accumulators::impl::weighted_mean_impl [^weighted_mean_impl]] 或
[classref boost::accumulators::impl::immediate_weighted_mean_impl [^immediate_weighted_mean_impl]].

[variablelist
    [[Result Type 返回类型] [For samples, `numeric::functional::average<numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type, _weight_type_>::result_type` \n
                    For variates, `numeric::functional::average<numeric::functional::multiplies<_variate_type_, _weight_type_>::result_type, _weight_type_>::result_type`]]
    [[Depends On 依赖于] [`sum_of_weights` \n
                   The lazy mean of samples depends on `weighted_sum` \n
                   样本均值的延迟方式依赖于 `weighted_sum` \n
                   The lazy mean of variates depends on `weighted_sum_of_variates<>` \n
                   变值均值的延迟方式依赖于 `weighted_sum_of_variates<>`]]
    [[Variants 变体] [`weighted_mean_of_variates<_variate_type_, _variate_tag_>` \n
                 `immediate_weighted_mean` \n
                 `immediate_weighted_mean_of_variates<_variate_type_, _variate_tag_>`]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_MEAN_HPP_ [headerref boost/accumulators/statistics/weighted_mean.hpp]]

    #include <_WEIGHTED_MEAN_HPP_>

[*Example]

    accumulator_set<
        int
      , stats<
            tag::weighted_mean
          , tag::weighted_mean_of_variates<int, tag::covariate1>
        >
      , int
    > acc;

    acc(10, weight = 2, covariate1 = 7);          //  20
    BOOST_CHECK_EQUAL(2, sum_of_weights(acc));    //
                                                  //
    acc(6, weight = 3, covariate1 = 8);           //  18
    BOOST_CHECK_EQUAL(5, sum_of_weights(acc));    //
                                                  //
    acc(4, weight = 4, covariate1 = 9);           //  16
    BOOST_CHECK_EQUAL(9, sum_of_weights(acc));    //
                                                  //
    acc(6, weight = 5, covariate1 = 6);           //+ 30
    BOOST_CHECK_EQUAL(14, sum_of_weights(acc));   //
                                                  //= 84  / 14 = 6

    BOOST_CHECK_EQUAL(6., weighted_mean(acc));
    BOOST_CHECK_EQUAL(52./7., (weighted_mean_of_variates<int, tag::covariate1>(acc)));

    accumulator_set<
        int
      , stats<
            tag::weighted_mean(immediate)
          , tag::weighted_mean_of_variates<int, tag::covariate1>(immediate)
        >
      , int
    > acc2;

    acc2(10, weight = 2, covariate1 = 7);         //  20
    BOOST_CHECK_EQUAL(2, sum_of_weights(acc2));   //
                                                  //
    acc2(6, weight = 3, covariate1 = 8);          //  18
    BOOST_CHECK_EQUAL(5, sum_of_weights(acc2));   //
                                                  //
    acc2(4, weight = 4, covariate1 = 9);          //  16
    BOOST_CHECK_EQUAL(9, sum_of_weights(acc2));   //
                                                  //
    acc2(6, weight = 5, covariate1 = 6);          //+ 30
    BOOST_CHECK_EQUAL(14, sum_of_weights(acc2));  //
                                                  //= 84  / 14 = 6

    BOOST_CHECK_EQUAL(6., weighted_mean(acc2));
    BOOST_CHECK_EQUAL(52./7., (weighted_mean_of_variates<int, tag::covariate1>(acc2)));

[*See also]

* [classref boost::accumulators::impl::weighted_mean_impl [^weighted_mean_impl]]
* [classref boost::accumulators::impl::immediate_weighted_mean_impl [^immediate_weighted_mean_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_sum [^weighted_sum]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]

[endsect]

[section:weighted_median weighted_median ['and variants]]

Median estimation for weighted samples based on the [^P^2] quantile estimator, the density estimator, or
the [^P^2] cumulative distribution estimator. For more implementation details, see
[classref boost::accumulators::impl::weighted_median_impl [^weighted_median_impl]], 
[classref boost::accumulators::impl::with_weighted_density_median_impl [^with_weighted_density_median_impl]], 
and [classref boost::accumulators::impl::with_weighted_p_square_cumulative_distribution_median_impl [^with_weighted_p_square_cumulative_distribution_median_impl]].
\n基于 [^P^2] 分位数估算法、密度估算法或 [^P^2] 累积分布估算法的加权样本中值估算。更多实现细节，请见
[classref boost::accumulators::impl::weighted_median_impl [^weighted_median_impl]], 
[classref boost::accumulators::impl::with_weighted_density_median_impl [^with_weighted_density_median_impl]], 
和 [classref boost::accumulators::impl::with_weighted_p_square_cumulative_distribution_median_impl [^with_weighted_p_square_cumulative_distribution_median_impl]].

The three median accumulators all satisfy the `tag::weighted_median` feature, and can all be
extracted with the `weighted_median()` extractor.
\n以上三种中值累加器均满足 `tag::weighted_median` 特征，都可以用 `weighted_median()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<_sample_type_, std::size_t>::result_type
                    ``]]
    [[Depends On 依赖于] [`weighted_median` depends on `weighted_p_square_quantile_for_median` \n
                   `weighted_median` 依赖于 `weighted_p_square_quantile_for_median` \n
                   `with_weighted_density_median` depends on `count` and `weighted_density` \n
                   `with_weighted_density_median` 依赖于 `count` 和 `weighted_density` \n
                   `with_weighted_p_square_cumulative_distribution_median` depends on `weighted_p_square_cumulative_distribution` \n
                   `with_weighted_p_square_cumulative_distribution_median` 依赖于 `weighted_p_square_cumulative_distribution`]]
    [[Variants 变体] [`with_weighted_density_median` (a.k.a. `weighted_median(with_weighted_density)`) \n
                 `with_weighted_p_square_cumulative_distribution_median` (a.k.a. `weighted_median(with_weighted_p_square_cumulative_distribution)`)]]
    [[Initialization Parameters 初始化参数] [`with_weighted_density_median` requires `tag::weighted_density::cache_size` and `tag::weighted_density::num_bins` \n
                                  `with_weighted_density_median` 要求 `tag::weighted_density::cache_size` 和 `tag::weighted_density::num_bins` \n
                                  `with_weighted_p_square_cumulative_distribution_median` requires `tag::weighted_p_square_cumulative_distribution::num_cells` \n
                                  `with_weighted_p_square_cumulative_distribution_median` 要求 `tag::weighted_p_square_cumulative_distribution::num_cells`]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [TODO 待办]] 
]

[*Header]
[def _WEIGHTED_MEDIAN_HPP_ [headerref boost/accumulators/statistics/weighted_median.hpp]]

    #include <_WEIGHTED_MEDIAN_HPP_>

[*Example]

    // Median estimation of normal distribution N(1,1) using samples from a narrow normal distribution N(1,0.01)
    // The weights equal to the likelihood ratio of the corresponding samples
    // 正态分布 N(1,1) 的中值估算使用了来自窄正态分布 N(1,0.01) 的样本。权重等于相应样本的概率
    
    // two random number generators 两个随机数生成器
    double mu = 1.;
    double sigma_narrow = 0.01;
    double sigma = 1.;
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma_narrow(mu,sigma_narrow);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal_narrow(rng, mean_sigma_narrow);
    
    accumulator_set<double, stats<tag::weighted_median(with_weighted_p_square_quantile) >, double > acc;
    accumulator_set<double, stats<tag::weighted_median(with_weighted_density) >, double > 
        acc_dens( tag::weighted_density::cache_size = 10000, tag::weighted_density::num_bins = 1000 );
    accumulator_set<double, stats<tag::weighted_median(with_weighted_p_square_cumulative_distribution) >, double > 
        acc_cdist( tag::weighted_p_square_cumulative_distribution::num_cells = 100 );
        
    for (std::size_t i=0; i<100000; ++i)
    {
        double sample = normal_narrow();
        acc(sample, weight = std::exp(0.5 * (sample - mu) * (sample - mu) * ( 1./sigma_narrow/sigma_narrow - 1./sigma/sigma )));
        acc_dens(sample, weight = std::exp(0.5 * (sample - mu) * (sample - mu) * ( 1./sigma_narrow/sigma_narrow - 1./sigma/sigma )));
        acc_cdist(sample, weight = std::exp(0.5 * (sample - mu) * (sample - mu) * ( 1./sigma_narrow/sigma_narrow - 1./sigma/sigma )));
    }
    
    BOOST_CHECK_CLOSE(1., weighted_median(acc), 1e-1);
    BOOST_CHECK_CLOSE(1., weighted_median(acc_dens), 1e-1);
    BOOST_CHECK_CLOSE(1., weighted_median(acc_cdist), 1e-1);

[*See also]

* [classref boost::accumulators::impl::weighted_median_impl [^weighted_median_impl]]
* [classref boost::accumulators::impl::with_weighted_density_median_impl [^with_weighted_density_median_impl]]
* [classref boost::accumulators::impl::with_weighted_p_square_cumulative_distribution_median_impl [^with_weighted_p_square_cumulative_distribution_median_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_p_square_quantile [^weighted_p_square_quantile]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_p_square_cumulative_distribution [^weighted_p_square_cumulative_distribution]]

[endsect]

[section:weighted_moment weighted_moment]

Calculates the N-th moment of the weighted samples, which is defined as the sum of the weighted N-th
power of the samples over the sum of the weights.
\n计算加权样本的N次矩，其定义为样本N次方的加权和除以样本数量。

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<
                        numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                      , weight_type
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`count` \n `sum_of_weights`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_MOMENT_HPP_ [headerref boost/accumulators/statistics/weighted_moment.hpp]]

    #include <_WEIGHTED_MOMENT_HPP_>

[*Example]

    accumulator_set<double, stats<tag::weighted_moment<2> >, double> acc2;
    accumulator_set<double, stats<tag::weighted_moment<7> >, double> acc7;
    
    acc2(2.1, weight = 0.7);
    acc2(2.7, weight = 1.4);
    acc2(1.8, weight = 0.9);
    
    acc7(2.1, weight = 0.7);
    acc7(2.7, weight = 1.4);
    acc7(1.8, weight = 0.9);
    
    BOOST_CHECK_CLOSE(5.403, weighted_moment<2>(acc2), 1e-5);
    BOOST_CHECK_CLOSE(548.54182, weighted_moment<7>(acc7), 1e-5);

[*See also]

* [classref boost::accumulators::impl::weighted_moment_impl [^weighted_moment_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]

[endsect]

[section:weighted_p_square_cumulative_distribution weighted_p_square_cumulative_distribution]

Histogram calculation of the cumulative distribution with the [^P^2] algorithm for weighted samples.
For more implementation details, see 
[classref boost::accumulators::impl::weighted_p_square_cumulative_distribution_impl [^weighted_p_square_cumulative_distribution_impl]]
\n用 [^P^2] 算法对加权样本进行累积分布的直方图计算。更多实现细节，请见
[classref boost::accumulators::impl::weighted_p_square_cumulative_distribution_impl [^weighted_p_square_cumulative_distribution_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    iterator_range<
                        std::vector<
                            std::pair<
                                numeric::functional::average<weighted_sample, std::size_t>::result_type
                              , numeric::functional::average<weighted_sample, std::size_t>::result_type
                            >
                        >::iterator
                    >
                    ``
                    where `weighted_sample` is `numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type`]]
    [[Depends On 依赖于] [`count` \n `sum_or_weights`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::weighted_p_square_cumulative_distribution::num_cells`]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(N) where N is `num_cells` \n O(N) 其中 N 为 `num_cells`]] 
]

[*Header]
[def _WEIGHTED_P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_ [headerref boost/accumulators/statistics/weighted_p_square_cumulative_distribution.hpp]]

    #include <_WEIGHTED_P_SQUARE_CUMULATIVE_DISTRIBUTION_HPP_>

[*Example]

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 4;

    typedef accumulator_set<double, stats<tag::weighted_p_square_cumulative_distribution>, double > accumulator_t;
        
    accumulator_t acc_upper(tag::weighted_p_square_cumulative_distribution::num_cells = 100);
    accumulator_t acc_lower(tag::weighted_p_square_cumulative_distribution::num_cells = 100);
    
    // two random number generators 两个随机数生成器
    double mu_upper = 1.0;
    double mu_lower = -1.0;
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma_upper(mu_upper,1);
    boost::normal_distribution<> mean_sigma_lower(mu_lower,1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal_upper(rng, mean_sigma_upper);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal_lower(rng, mean_sigma_lower);
    
    for (std::size_t i=0; i<100000; ++i)
    {
        double sample = normal_upper();
        acc_upper(sample, weight = std::exp(-mu_upper * (sample - 0.5 * mu_upper)));
    }
    
    for (std::size_t i=0; i<100000; ++i)
    {
        double sample = normal_lower();
        acc_lower(sample, weight = std::exp(-mu_lower * (sample - 0.5 * mu_lower)));
    }
    
    typedef iterator_range<std::vector<std::pair<double, double> >::iterator > histogram_type;
    histogram_type histogram_upper = weighted_p_square_cumulative_distribution(acc_upper);
    histogram_type histogram_lower = weighted_p_square_cumulative_distribution(acc_lower);
    
    // Note that applaying importance sampling results in a region of the distribution 
    // to be estimated more accurately and another region to be estimated less accurately
    // than without importance sampling, i.e., with unweighted samples
    // 注意，将带有重要性的样本结果应用于一个分布区域，以便更精确地估算，另一个不太精确估算的区域则为不带重要性的样本，即非加权样本
    
    for (std::size_t i = 0; i < histogram_upper.size(); ++i)
    {
        // problem with small results: epsilon is relative (in percent), not absolute!
        // 结果较小的问题：epsilon 是相对的(百分比)，不是绝对的！ 
        
        // check upper region of distribution 检查分布的上区域
        if ( histogram_upper[i].second > 0.1 )    
            BOOST_CHECK_CLOSE( 0.5 * (1.0 + erf( histogram_upper[i].first / sqrt(2.0) )), histogram_upper[i].second, epsilon );
        // check lower region of distribution 检查分布的下区域
        if ( histogram_lower[i].second < -0.1 )    
            BOOST_CHECK_CLOSE( 0.5 * (1.0 + erf( histogram_lower[i].first / sqrt(2.0) )), histogram_lower[i].second, epsilon );
    }

[*See also]

* [classref boost::accumulators::impl::weighted_p_square_cumulative_distribution_impl [^weighted_p_square_cumulative_distribution_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]

[endsect]

[section:weighted_p_square_quantile weighted_p_square_quantile ['and variants]]

Single quantile estimation with the [^P^2] algorithm. For more implementation details, see
[classref boost::accumulators::impl::weighted_p_square_quantile_impl [^weighted_p_square_quantile_impl]]
\n以 [^P^2] 算法进行单分位数估算。更多实现细节，请见
[classref boost::accumulators::impl::weighted_p_square_quantile_impl [^weighted_p_square_quantile_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<
                        numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                      , std::size_t
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`count` \n `sum_of_weights`]]
    [[Variants 变体] [`weighted_p_square_quantile_for_median`]]
    [[Initialization Parameters 初始化参数] [`quantile_probability`, which defaults to `0.5`.
                                  (Note: for `weighted_p_square_quantile_for_median`, the `quantile_probability`
                                  parameter is ignored and is always `0.5`.) \n
                                  `quantile_probability`, 缺省为 `0.5`.
                                  (注：对于 `weighted_p_square_quantile_for_median`, 参数 `quantile_probability`
                                  被忽略且设为 `0.5`.)]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_P_SQUARE_QUANTILE_HPP_ [headerref boost/accumulators/statistics/weighted_p_square_quantile.hpp]]

    #include <_WEIGHTED_P_SQUARE_QUANTILE_HPP_>

[*Example]

    typedef accumulator_set<double, stats<tag::weighted_p_square_quantile>, double> accumulator_t;

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1;
    
    // some random number generators 一些随机数生成器
    double mu4 = -1.0;
    double mu5 = -1.0;
    double mu6 = 1.0;
    double mu7 = 1.0;
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma4(mu4, 1);
    boost::normal_distribution<> mean_sigma5(mu5, 1);
    boost::normal_distribution<> mean_sigma6(mu6, 1);
    boost::normal_distribution<> mean_sigma7(mu7, 1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal4(rng, mean_sigma4);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal5(rng, mean_sigma5);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal6(rng, mean_sigma6);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal7(rng, mean_sigma7);
        
    accumulator_t acc0(quantile_probability = 0.001);
    accumulator_t acc1(quantile_probability = 0.025);
    accumulator_t acc2(quantile_probability = 0.975);
    accumulator_t acc3(quantile_probability = 0.999);

    accumulator_t acc4(quantile_probability = 0.001);
    accumulator_t acc5(quantile_probability = 0.025);
    accumulator_t acc6(quantile_probability = 0.975);
    accumulator_t acc7(quantile_probability = 0.999);

        
    for (std::size_t i=0; i<100000; ++i)
    {
        double sample = rng();
        acc0(sample, weight = 1.);
        acc1(sample, weight = 1.);
        acc2(sample, weight = 1.);
        acc3(sample, weight = 1.);
        
        double sample4 = normal4();
        double sample5 = normal5();
        double sample6 = normal6();
        double sample7 = normal7();
        acc4(sample4, weight = std::exp(-mu4 * (sample4 - 0.5 * mu4)));
        acc5(sample5, weight = std::exp(-mu5 * (sample5 - 0.5 * mu5)));
        acc6(sample6, weight = std::exp(-mu6 * (sample6 - 0.5 * mu6)));
        acc7(sample7, weight = std::exp(-mu7 * (sample7 - 0.5 * mu7)));
    }
    
    // check for uniform distribution with weight = 1 以权重 = 1 检验均衡分布
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc0), 0.001, 15 );
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc1), 0.025, 5 );
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc2), 0.975, epsilon );
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc3), 0.999, epsilon );
    
    // check for shifted standard normal distribution ("importance sampling")
    // 检验平移的标准正态分布("重要性样本")
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc4), -3.090232, epsilon );
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc5), -1.959963, epsilon );
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc6),  1.959963, epsilon );
    BOOST_CHECK_CLOSE( weighted_p_square_quantile(acc7),  3.090232, epsilon );

[*See also]

* [classref boost::accumulators::impl::weighted_p_square_quantile_impl [^weighted_p_square_quantile_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]

[endsect]

[section:weighted_peaks_over_threshold weighted_peaks_over_threshold ['and variants]]

Weighted peaks over threshold method for weighted quantile and weighted tail mean estimation.
For more implementation details,
see [classref boost::accumulators::impl::weighted_peaks_over_threshold_impl [^weighted_peaks_over_threshold_impl]]
and [classref boost::accumulators::impl::weighted_peaks_over_threshold_prob_impl [^weighted_peaks_over_threshold_prob_impl]].
\n用于加权分位数和加权尾均值估算的加权高限峰值法(WPOT)。更多实现细节，请见
[classref boost::accumulators::impl::weighted_peaks_over_threshold_impl [^weighted_peaks_over_threshold_impl]]
和 [classref boost::accumulators::impl::weighted_peaks_over_threshold_prob_impl [^weighted_peaks_over_threshold_prob_impl]].

Both `tag::weighted_peaks_over_threshold<_left_or_right_>` and
`tag::weighted_peaks_over_threshold_prob<_left_or_right_>` satisfy the
`tag::weighted_peaks_over_threshold<_left_or_right_>` feature and can be extracted using the
`weighted_peaks_over_threshold()` extractor.
\n`tag::weighted_peaks_over_threshold<_left_or_right_>` 和 
`tag::weighted_peaks_over_threshold_prob<_left_or_right_>` 均满足 
`tag::weighted_peaks_over_threshold<_left_or_right_>` 特征，
都可以用 `weighted_peaks_over_threshold()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [`tuple<float_type, float_type, float_type>` where `float_type` is
                    ``
                    numeric::functional::average<
                        numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                      , std::size_t
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`weighted_peaks_over_threshold<_left_or_right_>` depends on `sum_of_weights` \n
                   `weighted_peaks_over_threshold<_left_or_right_>` 依赖于 `sum_of_weights` \n
                   `weighted_peaks_over_threshold_prob<_left_or_right_>` depends on `sum_of_weights` and `tail_weights<_left_or_right_>` \n
                   `weighted_peaks_over_threshold_prob<_left_or_right_>` 依赖于 `sum_of_weights` 和 `tail_weights<_left_or_right_>`]]
    [[Variants 变体] [`weighted_peaks_over_threshold_prob`]]
    [[Initialization Parameters 初始化参数] [ `tag::peaks_over_threshold::threshold_value` \n
                                   `tag::peaks_over_threshold_prob::threshold_probability` \n
                                   `tag::tail<_left_or_right_>::cache_size` ]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [TODO 待办]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]]
]

[*Header]
[def _WEIGHTED_PEAKS_OVER_THRESHOLD_HPP_ [headerref boost/accumulators/statistics/weighted_peaks_over_threshold.hpp]]

    #include <_WEIGHTED_PEAKS_OVER_THRESHOLD_HPP_>

[/ TODO Add example]

[*See also]

* [classref boost::accumulators::impl::weighted_peaks_over_threshold_impl [^weighted_peaks_over_threshold_impl]]
* [classref boost::accumulators::impl::weighted_peaks_over_threshold_prob_impl [^weighted_peaks_over_threshold_prob_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]

[endsect]

[section:weighted_skewness weighted_skewness]

The skewness of a sample distribution is defined as the ratio of the 3rd central moment and the [^3/2]-th power 
of the 2nd central moment (the variance) of the sampless 3. The skewness estimator for weighted samples 
is formally identical to the estimator for unweighted samples, except that the weighted counterparts of
all measures it depends on are to be taken.
\n样本分布的偏度被定义为样本(变异)的3次中心矩与2次中心矩的[^3/2]次方之比。
加权样本的偏度估算法形式上与非加权样本的相同，除了对所依赖的所有测量都使用加权的方式。

For implementation details, see
[classref boost::accumulators::impl::weighted_skewness_impl [^weighted_skewness_impl]].
\n更多实现细节，请见
[classref boost::accumulators::impl::weighted_skewness_impl [^weighted_skewness_impl]].

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<
                        numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                      , numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`weighted_mean` \n `weighted_moment<2>` \n `weighted_moment<3>`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_SKEWNESS_HPP_ [headerref boost/accumulators/statistics/weighted_skewness.hpp]]

    #include <_WEIGHTED_SKEWNESS_HPP_>

[*Example]

    accumulator_set<int, stats<tag::weighted_skewness>, int > acc2;
    
    acc2(2, weight = 4);
    acc2(7, weight = 1);
    acc2(4, weight = 3);
    acc2(9, weight = 1);
    acc2(3, weight = 2);
    
    BOOST_CHECK_EQUAL( weighted_mean(acc2), 42./11. );
    BOOST_CHECK_EQUAL( weighted_moment<2>(acc2), 212./11. );
    BOOST_CHECK_EQUAL( weighted_moment<3>(acc2), 1350./11. );
    BOOST_CHECK_CLOSE( weighted_skewness(acc2), 1.30708406282, 1e-6 );

[*See also]

* [classref boost::accumulators::impl::weighted_skewness_impl [^weighted_skewness_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_mean [^weighted_mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_moment [^weighted_moment]]

[endsect]

[section:weighted_sum weighted_sum ['and variants]]

For summing the weighted samples or variates. All of the `tag::weighted_sum_of_variates<>` features 
can be extracted with the `weighted_sum_of_variates()` extractor.
\n对加权样本或变值进行求和。所有 `tag::weighted_sum_of_variates<>` 特征都可以用 
`weighted_sum_of_variates()` 提取器进行提取。

[variablelist
    [[Result Type 返回类型] [`numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type` for summing weighted samples \n
                    `numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type` 对于加权样本求和 \n
                    `numeric::functional::multiplies<_variate_type_, _weight_type_>::result_type` for summing weighted variates \n
                    `numeric::functional::multiplies<_variate_type_, _weight_type_>::result_type` 对于加权变值求和]]
    [[Depends On 依赖于] [['none 无]]]
    [[Variants 变体] [`tag::weighted_sum` \n
                 `tag::weighted_sum_of_variates<_variate_type_, _variate_tag_>`]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [`weight` \n
                               `_variate_tag_` for summing variates \n
                               `_variate_tag_` 对于变值求和]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_SUM_HPP_ [headerref boost/accumulators/statistics/weighted_sum.hpp]]

    #include <_WEIGHTED_SUM_HPP_>

[*Example]

    accumulator_set<int, stats<tag::weighted_sum, tag::weighted_sum_of_variates<int, tag::covariate1> >, int> acc;

    acc(1, weight = 2, covariate1 = 3);
    BOOST_CHECK_EQUAL(2, weighted_sum(acc));
    BOOST_CHECK_EQUAL(6, weighted_sum_of_variates(acc));

    acc(2, weight = 3, covariate1 = 6);
    BOOST_CHECK_EQUAL(8, weighted_sum(acc));
    BOOST_CHECK_EQUAL(24, weighted_sum_of_variates(acc));

    acc(4, weight = 6, covariate1 = 9);
    BOOST_CHECK_EQUAL(32, weighted_sum(acc));
    BOOST_CHECK_EQUAL(78, weighted_sum_of_variates(acc));

[*See also]

* [classref boost::accumulators::impl::weighted_sum_impl [^weighted_sum_impl]]

[endsect]

[section:non_coherent_weighted_tail_mean non_coherent_weighted_tail_mean]

Estimation of the (non-coherent) weighted tail mean based on order statistics (for both left and right tails).
The left non-coherent weighted tail mean feature is `tag::non_coherent_weighted_tail_mean<left>`, and the right
non-choherent weighted tail mean feature is `tag::non_coherent_weighted_tail_mean<right>`. They both share the
`tag::abstract_non_coherent_tail_mean` feature with the unweighted non-coherent tail mean accumulators and can
be extracted with either the `non_coherent_tail_mean()` or the `non_coherent_weighted_tail_mean()` extractors.
For more implementation details, see
[classref boost::accumulators::impl::non_coherent_weighted_tail_mean_impl [^non_coherent_weighted_tail_mean_impl]].
\n基于次序统计估算(松散)加权尾均值(用于左右两端)。左端松散加权尾均值的特征为 `tag::non_coherent_weighted_tail_mean<left>`，
而右端松散加权尾均值的特征为 `tag::non_coherent_weighted_tail_mean<right>`。
它们和非加权的松散尾均值累加器一起共享 `tag::abstract_non_coherent_tail_mean` 特征，
都可以用 `non_coherent_tail_mean()` 或 `non_coherent_weighted_tail_mean()` 提取器进行提取。更多实现细节，请见
[classref boost::accumulators::impl::non_coherent_weighted_tail_mean_impl [^non_coherent_weighted_tail_mean_impl]].

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<
                        numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                      , std::size_t
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`sum_of_weights` \n `tail_weights<_left_or_right_>`]]
    [[Variants 变体] [`abstract_non_coherent_tail_mean`]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]]
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]]
]

[*Header]
[def _WEIGHTED_TAIL_MEAN_HPP_ [headerref boost/accumulators/statistics/weighted_tail_mean.hpp]]

    #include <_WEIGHTED_TAIL_MEAN_HPP_>

[*Example]

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1;

    std::size_t n = 100000; // number of MC steps  MC步数
    std::size_t c = 25000; // cache size  缓存大小

    accumulator_set<double, stats<tag::non_coherent_weighted_tail_mean<right> >, double >
        acc0( right_tail_cache_size = c );
    accumulator_set<double, stats<tag::non_coherent_weighted_tail_mean<left> >, double >
        acc1( left_tail_cache_size = c );

    // random number generators 随机数生成器
    boost::lagged_fibonacci607 rng;

    for (std::size_t i = 0; i < n; ++i)
    {
        double smpl = std::sqrt(rng());
        acc0(smpl, weight = 1./smpl);
    }

    for (std::size_t i = 0; i < n; ++i)
    {
        double smpl = rng();
        acc1(smpl*smpl, weight = smpl);
    }

    // check uniform distribution 检查均衡分布
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc0, quantile_probability = 0.95), 0.975, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc0, quantile_probability = 0.975), 0.9875, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc0, quantile_probability = 0.99), 0.995, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc0, quantile_probability = 0.999), 0.9995, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc1, quantile_probability = 0.05), 0.025, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc1, quantile_probability = 0.025), 0.0125, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc1, quantile_probability = 0.01), 0.005, epsilon );
    BOOST_CHECK_CLOSE( non_coherent_weighted_tail_mean(acc1, quantile_probability = 0.001), 0.0005, 5*epsilon );

[*See also]

* [classref boost::accumulators::impl::non_coherent_weighted_tail_mean_impl [^non_coherent_weighted_tail_mean_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]

[endsect]

[section:weighted_tail_quantile weighted_tail_quantile]

Tail quantile estimation based on order statistics of weighted samples (for both left
and right tails). The left weighted tail quantile feature is `tag::weighted_tail_quantile<left>`,
and the right weighted tail quantile feature is `tag::weighted_tail_quantile<right>`. They both
share the `tag::quantile` feature with the unweighted tail quantile accumulators and can be
extracted with either the `quantile()` or the `weighted_tail_quantile()` extractors. For more
implementation details, see
[classref boost::accumulators::impl::weighted_tail_quantile_impl [^weighted_tail_quantile_impl]]
\n基于次序统计的加权样本尾部分位数估算(用于左右两端)。左端加权尾部分位数的特征为 `tag::weighted_tail_quantile<left>`，
右端加权尾部分位数的特征为 `tag::weighted_tail_quantile<right>`。它们和非加权尾部分位数累加器一起共享
`tag::quantile` 特征，都可以用 `quantile()` 或 `weighted_tail_quantile()` 提取器进行提取。更多实现细节，请见
[classref boost::accumulators::impl::weighted_tail_quantile_impl [^weighted_tail_quantile_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    _sample_type_
                    ``]]
    [[Depends On 依赖于] [`sum_of_weights` \n `tail_weights<_left_or_right_>`]]
    [[Variants 变体] [['none 无]]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _WEIGHTED_TAIL_QUANTILE_HPP_ [headerref boost/accumulators/statistics/weighted_tail_quantile.hpp]]

    #include <_WEIGHTED_TAIL_QUANTILE_HPP_>

[*Example]

    // tolerance in % 以百分比表示的允许误差
    double epsilon = 1;

    std::size_t n = 100000; // number of MC steps  MC步数
    std::size_t c =  20000; // cache size 缓存大小

    double mu1 = 1.0;
    double mu2 = -1.0;
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma1(mu1,1);
    boost::normal_distribution<> mean_sigma2(mu2,1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal1(rng, mean_sigma1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal2(rng, mean_sigma2);

    accumulator_set<double, stats<tag::weighted_tail_quantile<right> >, double>
        acc1(right_tail_cache_size = c);

    accumulator_set<double, stats<tag::weighted_tail_quantile<left> >, double>
        acc2(left_tail_cache_size = c);

    for (std::size_t i = 0; i < n; ++i)
    {
        double sample1 = normal1();
        double sample2 = normal2();
        acc1(sample1, weight = std::exp(-mu1 * (sample1 - 0.5 * mu1)));
        acc2(sample2, weight = std::exp(-mu2 * (sample2 - 0.5 * mu2)));
    }

    // check standard normal distribution 检查标准正态分布
    BOOST_CHECK_CLOSE( quantile(acc1, quantile_probability = 0.975),  1.959963, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc1, quantile_probability = 0.999),  3.090232, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc2, quantile_probability  = 0.025), -1.959963, epsilon );
    BOOST_CHECK_CLOSE( quantile(acc2, quantile_probability  = 0.001), -3.090232, epsilon );

[*See also]

* [classref boost::accumulators::impl::weighted_tail_quantile_impl [^weighted_tail_quantile_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.sum [^sum]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]

[endsect]

[section:weighted_tail_variate_means weighted_tail_variate_means ['and variants]]

Estimation of the absolute and relative weighted tail variate means (for both left and right tails)
The absolute weighted tail variate means has the feature 
`tag::absolute_weighted_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`
and the relative weighted tail variate mean has the feature
`tag::relative_weighted_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`. All
absolute weighted tail variate mean features share the `tag::abstract_absolute_tail_variate_means`
feature with their unweighted variants and can be extracted with the `tail_variate_means()` and
`weighted_tail_variate_means()` extractors. All the relative weighted tail variate mean features 
share the `tag::abstract_relative_tail_variate_means` feature with their unweighted variants
and can be extracted with either the `relative_tail_variate_means()` or 
`relative_weighted_tail_variate_means()` extractors.
\n估算绝对和相对的加权尾部变值平均值(用于左右两端)。绝对加权尾部变值平均值具有特征
`tag::absolute_weighted_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`，
而相对加权尾部变值平均值具有特征 `tag::relative_weighted_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`。
所有绝对加权尾部变值平均值与非加权的相应特征一些共享 `tag::abstract_absolute_tail_variate_means` 特征，
并可以用 `tail_variate_means()` 和 `weighted_tail_variate_means()` 提取器进行提取。
所有相对加权尾部变值平均值与非加权的相应特征一起共享 `tag::abstract_relative_tail_variate_means` 特征，
并可以用 `relative_tail_variate_means()` 或 `relative_weighted_tail_variate_means()` 提取器进行提取。

For more implementation details, see
[classref boost::accumulators::impl::weighted_tail_variate_means_impl [^weighted_tail_variate_means_impl]]
\n更多实现细节，请见
[classref boost::accumulators::impl::weighted_tail_variate_means_impl [^weighted_tail_variate_means_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    boost::iterator_range<
                        numeric::functional::average<
                            numeric::functional::multiplies<_variate_type_, _weight_type_>::result_type
                          , _weight_type_
                        >::result_type::iterator
                    >
                    ``]]
    [[Depends On 依赖于] [`non_coherent_weighted_tail_mean<_left_or_right_>` \n 
                   `tail_variate<_variate_type_, _variate_tag_, _left_or_right_>` \n
                   `tail_weights<_left_or_right_>`]]
    [[Variants 变体] [`tag::absolute_weighted_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>` \n
                 `tag::relative_weighted_tail_variate_means<_left_or_right_, _variate_type_, _variate_tag_>`]]
    [[Initialization Parameters 初始化参数] [`tag::tail<_left_or_right_>::cache_size`]]
    [[Accumulator Parameters 累加器参数] [['none 无]]]
    [[Extractor Parameters 提取器参数] [`quantile_probability`]]
    [[Accumulator Complexity 累加器复杂度] [O(log N), where N is the cache size \n O(log N), 其中 N 为缓存大小]] 
    [[Extractor Complexity 提取器复杂度] [O(N log N), where N is the cache size \n O(N log N), 其中 N 为缓存大小]] 
]

[*Header]
[def _WEIGHTED_TAIL_VARIATE_MEANS_HPP_ [headerref boost/accumulators/statistics/weighted_tail_variate_means.hpp]]

    #include <_WEIGHTED_TAIL_VARIATE_MEANS_HPP_>

[*Example]

    std::size_t c = 5; // cache size 缓存大小

    typedef double variate_type;
    typedef std::vector<variate_type> variate_set_type;

    accumulator_set<double, stats<tag::weighted_tail_variate_means<right, variate_set_type, tag::covariate1>(relative)>, double >
        acc1( right_tail_cache_size = c );
    accumulator_set<double, stats<tag::weighted_tail_variate_means<right, variate_set_type, tag::covariate1>(absolute)>, double >
        acc2( right_tail_cache_size = c );
    accumulator_set<double, stats<tag::weighted_tail_variate_means<left, variate_set_type, tag::covariate1>(relative)>, double >
        acc3( left_tail_cache_size = c );
    accumulator_set<double, stats<tag::weighted_tail_variate_means<left, variate_set_type, tag::covariate1>(absolute)>, double >
        acc4( left_tail_cache_size = c );

    variate_set_type cov1, cov2, cov3, cov4, cov5;
    double c1[] = { 10., 20., 30., 40. }; // 100
    double c2[] = { 26.,  4., 17.,  3. }; // 50
    double c3[] = { 46., 64., 40., 50. }; // 200
    double c4[] = {  1.,  3., 70.,  6. }; // 80
    double c5[] = {  2.,  2.,  2., 14. }; // 20
    cov1.assign(c1, c1 + sizeof(c1)/sizeof(variate_type));
    cov2.assign(c2, c2 + sizeof(c2)/sizeof(variate_type));
    cov3.assign(c3, c3 + sizeof(c3)/sizeof(variate_type));
    cov4.assign(c4, c4 + sizeof(c4)/sizeof(variate_type));
    cov5.assign(c5, c5 + sizeof(c5)/sizeof(variate_type));

    acc1(100., weight = 0.8, covariate1 = cov1);
    acc1( 50., weight = 0.9, covariate1 = cov2);
    acc1(200., weight = 1.0, covariate1 = cov3);
    acc1( 80., weight = 1.1, covariate1 = cov4);
    acc1( 20., weight = 1.2, covariate1 = cov5);

    acc2(100., weight = 0.8, covariate1 = cov1);
    acc2( 50., weight = 0.9, covariate1 = cov2);
    acc2(200., weight = 1.0, covariate1 = cov3);
    acc2( 80., weight = 1.1, covariate1 = cov4);
    acc2( 20., weight = 1.2, covariate1 = cov5);

    acc3(100., weight = 0.8, covariate1 = cov1);
    acc3( 50., weight = 0.9, covariate1 = cov2);
    acc3(200., weight = 1.0, covariate1 = cov3);
    acc3( 80., weight = 1.1, covariate1 = cov4);
    acc3( 20., weight = 1.2, covariate1 = cov5);

    acc4(100., weight = 0.8, covariate1 = cov1);
    acc4( 50., weight = 0.9, covariate1 = cov2);
    acc4(200., weight = 1.0, covariate1 = cov3);
    acc4( 80., weight = 1.1, covariate1 = cov4);
    acc4( 20., weight = 1.2, covariate1 = cov5);

    // check relative risk contributions 检查相对风险分布
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.7).begin()    ), (0.8*10 + 1.0*46)/(0.8*100 + 1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.7).begin() + 1), (0.8*20 + 1.0*64)/(0.8*100 + 1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.7).begin() + 2), (0.8*30 + 1.0*40)/(0.8*100 + 1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.7).begin() + 3), (0.8*40 + 1.0*50)/(0.8*100 + 1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.3).begin()    ), (0.9*26 + 1.2*2)/(0.9*50 + 1.2*20) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.3).begin() + 1), (0.9*4 + 1.2*2)/(0.9*50 + 1.2*20) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.3).begin() + 2), (0.9*17 + 1.2*2)/(0.9*50 + 1.2*20) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.3).begin() + 3), (0.9*3 + 1.2*14)/(0.9*50 + 1.2*20) );

    // check absolute risk contributions 检查绝对风险分布
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.7).begin()    ), (0.8*10 + 1.0*46)/1.8 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.7).begin() + 1), (0.8*20 + 1.0*64)/1.8 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.7).begin() + 2), (0.8*30 + 1.0*40)/1.8 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.7).begin() + 3), (0.8*40 + 1.0*50)/1.8 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.3).begin()    ), (0.9*26 + 1.2*2)/2.1 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.3).begin() + 1), (0.9*4 + 1.2*2)/2.1 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.3).begin() + 2), (0.9*17 + 1.2*2)/2.1 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.3).begin() + 3), (0.9*3 + 1.2*14)/2.1 );

    // check relative risk contributions 检查相对风险分布
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.9).begin()    ), 1.0*46/(1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.9).begin() + 1), 1.0*64/(1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.9).begin() + 2), 1.0*40/(1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc1, quantile_probability = 0.9).begin() + 3), 1.0*50/(1.0*200) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.1).begin()    ), 1.2*2/(1.2*20) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.1).begin() + 1), 1.2*2/(1.2*20) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.1).begin() + 2), 1.2*2/(1.2*20) );
    BOOST_CHECK_EQUAL( *(relative_weighted_tail_variate_means(acc3, quantile_probability = 0.1).begin() + 3), 1.2*14/(1.2*20) );

    // check absolute risk contributions 检查绝对风险分布
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.9).begin()    ), 1.0*46/1.0 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.9).begin() + 1), 1.0*64/1.0 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.9).begin() + 2), 1.0*40/1.0 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc2, quantile_probability = 0.9).begin() + 3), 1.0*50/1.0 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.1).begin()    ), 1.2*2/1.2 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.1).begin() + 1), 1.2*2/1.2 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.1).begin() + 2), 1.2*2/1.2 );
    BOOST_CHECK_EQUAL( *(weighted_tail_variate_means(acc4, quantile_probability = 0.1).begin() + 3), 1.2*14/1.2 );

[*See also]

* [classref boost::accumulators::impl::weighted_tail_variate_means_impl [^weighted_tail_variate_means_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.non_coherent_weighted_tail_mean [^non_coherent_weighted_tail_mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail_variate [^tail_variate]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.tail [^tail]]

[endsect]

[section:weighted_variance weighted_variance ['and variants]]

Lazy or iterative calculation of the weighted variance. The lazy calculation is associated with the `tag::lazy_weighted_variance`
feature, and the iterative calculation with the `tag::weighted_variance` feature. Both can be extracted
using the `tag::weighted_variance()` extractor. For more implementation details, see
[classref boost::accumulators::impl::lazy_weighted_variance_impl [^lazy_weighted_variance_impl]] and
[classref boost::accumulators::impl::weighted_variance_impl [^weighted_variance_impl]]
\n对加权方差的延迟或迭代计算。延迟计算方式以 `tag::lazy_weighted_variance` 特征相关联，
而迭代计算方式以 `tag::weighted_variance` 特征相关联。两者均可用 `tag::weighted_variance()` 提取器进行提取。
更多实现细节，请见
[classref boost::accumulators::impl::lazy_weighted_variance_impl [^lazy_weighted_variance_impl]] 和
[classref boost::accumulators::impl::weighted_variance_impl [^weighted_variance_impl]]

[variablelist
    [[Result Type 返回类型] [``
                    numeric::functional::average<
                        numeric::functional::multiplies<_sample_type_, _weight_type_>::result_type
                      , std::size_t
                    >::result_type
                    ``]]
    [[Depends On 依赖于] [`tag::lazy_weighted_variance` depends on `tag::weighted_moment<2>` and `tag::weighted_mean` \n
                   `tag::lazy_weighted_variance` 依赖于 `tag::weighted_moment<2>` 和 `tag::weighted_mean` \n
                   `tag::weighted_variance` depends on `tag::count` and `tag::immediate_weighted_mean` \n
                   `tag::weighted_variance` 依赖于 `tag::count` 和 `tag::immediate_weighted_mean`]]
    [[Variants 变体] [`tag::lazy_weighted_variance` (a.k.a. `tag::weighted_variance(lazy))` \n
                 `tag::weighted_variance` (a.k.a. `tag::weighted_variance(immediate)`)]]
    [[Initialization Parameters 初始化参数] [['none 无]]]
    [[Accumulator Parameters 累加器参数] [`weight`]]
    [[Extractor Parameters 提取器参数] [['none 无]]]
    [[Accumulator Complexity 累加器复杂度] [O(1)]] 
    [[Extractor Complexity 提取器复杂度] [O(1)]] 
]

[*Header]
[def _WEIGHTED_VARIANCE_HPP_ [headerref boost/accumulators/statistics/weighted_variance.hpp]]

    #include <_WEIGHTED_VARIANCE_HPP_>

[*Example]

    // lazy weighted_variance 延迟方式
    accumulator_set<int, stats<tag::weighted_variance(lazy)>, int> acc1;

    acc1(1, weight = 2);    //  2
    acc1(2, weight = 3);    //  6
    acc1(3, weight = 1);    //  3
    acc1(4, weight = 4);    // 16
    acc1(5, weight = 1);    //  5

    // weighted_mean = (2+6+3+16+5) / (2+3+1+4+1) = 32 / 11 = 2.9090909090909090909090909090909

    BOOST_CHECK_EQUAL(5u, count(acc1));
    BOOST_CHECK_CLOSE(2.9090909, weighted_mean(acc1), 1e-5);
    BOOST_CHECK_CLOSE(10.1818182, weighted_moment<2>(acc1), 1e-5);
    BOOST_CHECK_CLOSE(1.7190083, weighted_variance(acc1), 1e-5);

    // immediate weighted_variance 立即方式
    accumulator_set<int, stats<tag::weighted_variance>, int> acc2;

    acc2(1, weight = 2);
    acc2(2, weight = 3);
    acc2(3, weight = 1);
    acc2(4, weight = 4);
    acc2(5, weight = 1);

    BOOST_CHECK_EQUAL(5u, count(acc2));
    BOOST_CHECK_CLOSE(2.9090909, weighted_mean(acc2), 1e-5);
    BOOST_CHECK_CLOSE(1.7190083, weighted_variance(acc2), 1e-5);
    
    // check lazy and immediate variance with random numbers 用随机数检验延迟和立即方式
    
    // two random number generators 两个随机数生成器
    boost::lagged_fibonacci607 rng;
    boost::normal_distribution<> mean_sigma(0,1);
    boost::variate_generator<boost::lagged_fibonacci607&, boost::normal_distribution<> > normal(rng, mean_sigma);
    
    accumulator_set<double, stats<tag::weighted_variance>, double > acc_lazy;    
    accumulator_set<double, stats<tag::weighted_variance(immediate)>, double > acc_immediate;
    
    for (std::size_t i=0; i<10000; ++i)
    {
        double value = normal();
        acc_lazy(value, weight = rng());
        acc_immediate(value, weight = rng());
    }
    
    BOOST_CHECK_CLOSE(1., weighted_variance(acc_lazy), 1.);
    BOOST_CHECK_CLOSE(1., weighted_variance(acc_immediate), 1.);

[*See also]

* [classref boost::accumulators::impl::lazy_weighted_variance_impl [^lazy_weighted_variance_impl]]
* [classref boost::accumulators::impl::weighted_variance_impl [^weighted_variance_impl]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.count [^count]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_mean [^weighted_mean]]
* [link accumulators.user_s_guide.the_statistical_accumulators_library.weighted_moment [^weighted_moment]]

[endsect]

[endsect]

[endsect]

[section:acknowledgements Acknowledgements 鸣谢]

Boost.Accumulators represents the efforts of many individuals. I would like to thank 
Daniel Egloff of _ZKB_ for helping to conceive the library and realize its 
implementation. I would also like to thank David Abrahams and Matthias Troyer for 
their key contributions to the design of the library. Many thanks are due to Michael 
Gauckler and Olivier Gygi, who, along with Daniel Egloff, implemented many of the 
statistical accumulators.
\nBoost.Accumulators 代表了许多人的努力。我要感谢 _ZKB_ 的 Daniel Egloff 孕育了这个库并实现了它。
我还要感谢 David Abrahams 和 Matthias Troyer 对于本库设计的重要贡献。还要感谢 Michael Gauckler
和 Olivier Gygi，他们和 Daniel Egloff 一起实现了多个统计累加器。

Finally, I would like to thank _ZKB_ for sponsoring the work on Boost.Accumulators 
and graciously donating it to the community. 
\n最后，我要感谢_ZKB_ 赞助了 Boost.Accumulators 的工作并慷慨地将它捐献给社区。

[endsect]

[section:Reference Reference 参考手册]

[xinclude accdoc.xml]

[xinclude statsdoc.xml]

[xinclude opdoc.xml]

[endsect]

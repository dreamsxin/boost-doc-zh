<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin
  
  - Distributed under the Boost Software License, Version 1.0.
  - (See accompanying file LICENSE_1_0.txt or copy at
  - http://www.boost.org/LICENSE_1_0.txt)
  
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://opensource.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://opensource.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>GIL  : Class 列表</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=utf-8"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="opensource.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="globals.html">File Members</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.4.4 -->
<h1>Generic Image Library Class List</h1>下面是一些classes, structs, unions 和 interfaces ,并附有简单的描述:<table>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0380.html">alpha_t</a></td><td class="indexvalue">Alpha </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0018.html">any_image</a></td><td class="indexvalue">
                        运行时指派的图像. 注意不满足 <a class="el" href="g_i_l_0301.html">ImageConcept</a> 的要求</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0020.html">any_image_view</a></td><td class="indexvalue">运行时指派的图像视图, 满足 <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>, <a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>, 不满足 <a class="el" href="g_i_l_0303.html">ImageViewConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0257.html">Assignable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0382.html">binary_operation_obj</a></td><td class="indexvalue">图像间的泛型二元操作<p>
  把这个类型作为一个方便的超类,在定义图像操作的时候使用. 当图像视图兼容的时候, 很多的操作有不同的行为. 这个类型可以为子类的兼容性调用apply_compatible(V1,V2) 或者 apply_incompatible(V1,V2). 你必须为你的子类型定义 apply_compatible(V1,V2),但是apply_incompatible(V1,V2)不是必须的,默认的是抛出异常std::bad_cast.</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0384.html">bit_aligned_image1_type</a></td><td class="indexvalue">
                        指定通道的位长和布局,返回单通道位对齐图像的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0386.html">bit_aligned_image2_type</a></td><td class="indexvalue">指定通道的位长和布局,返回双通道位对齐图像的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0388.html">bit_aligned_image3_type</a></td><td class="indexvalue">指定通道的位长和布局,返回三通道位对齐图像的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0390.html">bit_aligned_image4_type</a></td><td class="indexvalue">指定通道的位长和布局,返回四通道位对齐图像的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0392.html">bit_aligned_image5_type</a></td><td class="indexvalue">指定通道的位长和布局,返回五单通道位对齐图像的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0394.html">bit_aligned_image_type</a></td><td class="indexvalue">返回像素是非字节对齐的packed图像的类型.例如, "rgb222" 图像是位对齐的,占有6个位 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0396.html">bit_aligned_pixel_iterator</a></td><td class="indexvalue">非字节对象像素迭代器, 是 <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>, <a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> 的模型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0398.html">bit_aligned_pixel_reference</a></td><td class="indexvalue">非字节对齐位域定义的异质像素引用类型. 是 <a class="el" href="g_i_l_0269.html">ColorBaseConcept</a>, <a class="el" href="g_i_l_0341.html">PixelConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0399.html">black_t</a></td><td class="indexvalue">Black </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0400.html">blue_t</a></td><td class="indexvalue">Blue </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0401.html">byte_to_memunit</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0403.html">channel_converter</a></td><td class="indexvalue"> 通道类型转换的一元仿函数对象 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0407.html">channel_converter_unsigned&lt; bits32, bits32f &gt;</a></td><td class="indexvalue">32 位 &lt;-&gt; 浮点类型通道转换 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0411.html">channel_converter_unsigned&lt; bits32f, bits32 &gt;</a></td><td class="indexvalue">32 位 &lt;-&gt; 浮点类型通道转换 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0409.html">channel_converter_unsigned&lt; bits32f, DstChannelV &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0405.html">channel_converter_unsigned&lt; T, T &gt;</a></td><td class="indexvalue">通道到自身的转换-identity操作 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0471.html">channel_converter_unsigned_impl</a></td><td class="indexvalue">默认的实现, 提供了性能优化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0413.html">channel_mapping_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">得到planar像素引用的颜色空间, <a class="el" href="g_i_l_0339.html">PixelBasedConcep</a> 需要这个功能</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0415.html">channel_multiplier</a></td><td class="indexvalue">通道值相乘的仿函数. result = a * b / max_value </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0417.html">channel_multiplier_unsigned</a></td><td class="indexvalue">默认的实现, 提供了性能优化  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0419.html">channel_multiplier_unsigned&lt; bits16 &gt;</a></td><td class="indexvalue"> channel_multiply 针对16位无符号通道的特化版本 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0421.html">channel_multiplier_unsigned&lt; bits32f &gt;</a></td><td class="indexvalue"> channel_multiply 针对浮点范围为 0..1 的特化版本 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0423.html">channel_multiplier_unsigned&lt; bits8 &gt;</a></td><td class="indexvalue">channel_multiply 针对8位无符号通道的特化版本 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0424.html">channel_traits</a></td><td class="indexvalue">通道特性,包含下列成员: </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0426.html">channel_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">返回planar像素引用类型的颜色空间.  <a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a> 需要这个功能</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0259.html">ChannelConcept</a></td><td class="indexvalue">通道是颜色的构建块. 颜色定义为颜色基元的混合物,而通道就是每个颜色基元所占的比率 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0261.html">ChannelConvertibleConcept</a></td><td class="indexvalue">如果针对两个通道类型的算法 <code>channel_convert</code> 存在, 那么通道之间是可转换的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0263.html">ChannelMappingConcept</a></td><td class="indexvalue">通道映射概念</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0427.html">channels_are_compatible</a></td><td class="indexvalue">两个通道是否兼容的 Predicate 元函数 <p>
如果通道的值类型(不考虑const和引用)是相同的,那么它们就是兼容的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0267.html">ChannelsCompatibleConcept</a></td><td class="indexvalue">如果通道的值类型(不考虑const和引用)是相同的,那么它们就是兼容的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0265.html">ChannelValueConcept</a></td><td class="indexvalue">支持默认构造函数的通道类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0022.html">color_convert_deref_fn</a></td><td class="indexvalue">仿函数对象, 指定源像素,颜色空间和通道深度, 返回转换后的像素类型, 是 <a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0428.html">color_converted_view_type</a></td><td class="indexvalue">得到通过像素解引用进行颜色变换的图像视图类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0432.html">color_converted_view_type&lt; any_image_view&lt; ViewTypes &gt;, DstP &gt;</a></td><td class="indexvalue">通过默认的颜色变换,得到运行时指派的图像视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0430.html">color_converted_view_type&lt; any_image_view&lt; ViewTypes &gt;, DstP, CC &gt;</a></td><td class="indexvalue">通过用户自定义的颜色变换,得到运行时指派的图像视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0434.html">color_element_const_reference_type</a></td><td class="indexvalue">通过颜色名称, get_color(color_base, Color()), 得到const颜色元素类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0436.html">color_element_reference_type</a></td><td class="indexvalue">通过颜色名称, get_color(color_base, Color()), 得到颜色元素类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0438.html">color_element_type</a></td><td class="indexvalue">通过关联的颜色标签, 得到const颜色元素类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0440.html">color_space_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">得到planar像素引用的颜色空间, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> 需要这个功能</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0269.html">ColorBaseConcept</a></td><td class="indexvalue">颜色基是颜色元素的集合(例如通道,通道引用和通道指针) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0273.html">ColorBasesCompatibleConcept</a></td><td class="indexvalue">如果两个颜色基具有相同的颜色空间,并且颜色元素是语义成对兼容的, 那么就认为它们是兼容的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0271.html">ColorBaseValueConcept</a></td><td class="indexvalue">具有默认构造函数的颜色基, 是 <a class="el" href="g_i_l_0371.html">Regular</a> 的强化</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0275.html">ColorSpaceConcept</a></td><td class="indexvalue">颜色空间概念</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0277.html">ColorSpacesCompatibleConcept</a></td><td class="indexvalue">如果颜色空间是相同的,那么它们就是兼容的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0441.html">contains_color</a></td><td class="indexvalue">确定颜色基是否含有一个指定颜色的 predicate 元函数</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0473.html">copier_n</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0475.html">copier_n&lt; I, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="indexvalue">通过像素迭代器分割的目标区间 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0479.html">copier_n&lt; iterator_from_2d&lt; IL &gt;, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="indexvalue">源区间和目标区间通过像素迭代器分割 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0477.html">copier_n&lt; iterator_from_2d&lt; IL &gt;, O &gt;</a></td><td class="indexvalue">通过像素迭代器分割的源区间 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0279.html">CopyConstructible</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0442.html">cyan_t</a></td><td class="indexvalue">Cyan </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0481.html">dec</a></td><td class="indexvalue">操作符 -- 包裹在仿函数中 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0444.html">default_channel_converter</a></td><td class="indexvalue">和<a class="el" href="g_i_l_0403.html">channel_converter</a> 一样, 除了目标通道以引用参数的方式使用, 这样可以使得模板参数在方法级,而不是在类级,这个对异质像素很重要 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0446.html">default_color_converter</a></td><td class="indexvalue">一个像素的颜色变换为另一个</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0447.html">default_color_converter_impl</a></td><td class="indexvalue">颜色变换仿函数. 对 src/dst 颜色空间进行特化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0451.html">default_color_converter_impl&lt; C, C &gt;</a></td><td class="indexvalue">当颜色空间相同,颜色变换执行深度转换 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0449.html">default_color_converter_impl&lt; C1, rgba_t &gt;</a></td><td class="indexvalue">把像素类型转换为 RGBA. 注意: 只是支持同质像素 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0453.html">default_color_converter_impl&lt; cmyk_t, gray_t &gt;</a></td><td class="indexvalue">CMYK to Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0455.html">default_color_converter_impl&lt; cmyk_t, rgb_t &gt;</a></td><td class="indexvalue">CMYK to RGB (不是最快的代码) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0457.html">default_color_converter_impl&lt; gray_t, cmyk_t &gt;</a></td><td class="indexvalue">Gray to CMYK </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0459.html">default_color_converter_impl&lt; gray_t, rgb_t &gt;</a></td><td class="indexvalue">Gray to RGB </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0461.html">default_color_converter_impl&lt; rgb_t, cmyk_t &gt;</a></td><td class="indexvalue">RGB to CMYK (不是最快的代码) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0463.html">default_color_converter_impl&lt; rgb_t, gray_t &gt;</a></td><td class="indexvalue">RGB to Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0465.html">default_color_converter_impl&lt; rgba_t, C2 &gt;</a></td><td class="indexvalue">RGBA 转换为任意的像素类型. 注意: 只是支持同质像素 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0467.html">default_color_converter_impl&lt; rgba_t, rgba_t &gt;</a></td><td class="indexvalue">不幸的是 RGBA 到 RGBA 的转换必须显式提供,否则会产生编译错误 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0281.html">DefaultConstructible</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0469.html">deref_base</a></td><td class="indexvalue">像素解引用适配的辅助基类 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0024.html">deref_compose</a></td><td class="indexvalue">两个仿函数的合成,和std::unary_compose 类似, 但是需要更多的 typedefs .是 <a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a>  的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0026.html">dereference_iterator_adaptor</a></td><td class="indexvalue">迭代器适配器,在对象解引用的时候进行定制的过滤, 是  <a class="el" href="g_i_l_0305.html">IteratorAdaptorConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0028.html">derived_image_type</a></td><td class="indexvalue">通过更改源图像的属性,构造同质的图像类型.<p>
使用 use_default 保持源图像的属性不变 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0030.html">derived_iterator_type</a></td><td class="indexvalue">通过更改像素迭代器的属性,构造新的像素迭代器.<p>
使用 use_default 保持像素迭代器的属性不变</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0032.html">derived_pixel_reference_type</a></td><td class="indexvalue">通过更改像素引用的属性,构造新的像素引用类型.<p>
使用 use_default 保持像素引用的属性不变 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0034.html">derived_view_type</a></td><td class="indexvalue">通过更改图像视图的属性,构造新的图像视图类型.<p>
使用 use_default 保持图像视图的属性不变 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0517.html">devicen_color_t</a></td><td class="indexvalue">未命名颜色 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0519.html">devicen_layout_t</a></td><td class="indexvalue">1到5个通道的未命名  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0520.html">devicen_t&lt; 1 &gt;</a></td><td class="indexvalue">1个通道的未命名颜色  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0521.html">devicen_t&lt; 2 &gt;</a></td><td class="indexvalue">2个通道的未命名颜色   </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0522.html">devicen_t&lt; 3 &gt;</a></td><td class="indexvalue">3个通道的未命名颜色   </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0523.html">devicen_t&lt; 4 &gt;</a></td><td class="indexvalue">4个通道的未命名颜色   </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0524.html">devicen_t&lt; 5 &gt;</a></td><td class="indexvalue">5个通道的未命名颜色   </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0525.html">dynamic_xy_step_transposed_type</a></td><td class="indexvalue">得到在X Y两个方向具有动态步长的对调图像视图的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0526.html">dynamic_xy_step_type</a></td><td class="indexvalue">得到在X Y两个方向具有动态步长的图像视图的类型  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0527.html">element_const_reference_type</a></td><td class="indexvalue">得到同质颜色基函数at_c返回的const要素类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0528.html">element_reference_type</a></td><td class="indexvalue">得到同质颜色基函数at_c返回的要素类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0529.html">element_type</a></td><td class="indexvalue">得到同质颜色基的要素类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0487.html">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc &gt;, I2 &gt;</a></td><td class="indexvalue">通过图像迭代器分割的源区间 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0485.html">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc1 &gt;, boost::gil::iterator_from_2d&lt; Loc2 &gt; &gt;</a></td><td class="indexvalue">通过图像迭代器分割的源区间和目标区间 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0489.html">equal_n_fn&lt; const pixel&lt; T, Cs &gt; *, const pixel&lt; T, Cs &gt; * &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0483.html">equal_n_fn&lt; I1, boost::gil::iterator_from_2d&lt; Loc &gt; &gt;</a></td><td class="indexvalue">通过图像迭代器分割的目标区间</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0491.html">equal_n_fn&lt; planar_pixel_iterator&lt; IC, Cs &gt;, planar_pixel_iterator&lt; IC, Cs &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0283.html">EqualityComparable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0530.html">gray_color_t</a></td><td class="indexvalue">Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0531.html">green_t</a></td><td class="indexvalue">Green </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a></td><td class="indexvalue">通过指定的迭代器,定位器和图像视图定义新的迭代器,定位器和图像视图类型,新的类型和源类型除了支持在X方向的动态步长以外,其余的都是相同的</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a></td><td class="indexvalue">通过指定的迭代器,定位器和图像视图定义新的迭代器,定位器和图像视图类型,新的类型和源类型除了支持在Y方向的动态步长以外,其余的都是相同的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a></td><td class="indexvalue">通过指定的定位器和图像视图定义新的定位器和图像视图类型,新的类型和源类型除了支持在X,Y可交换以外,其余的都是相同的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0493.html">homogeneous_color_base&lt; Element, Layout, 1 &gt;</a></td><td class="indexvalue">含有1种颜色要素同质颜色基, 是<a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0495.html">homogeneous_color_base&lt; Element, Layout, 2 &gt;</a></td><td class="indexvalue">>含有2种颜色要素同质颜色基, 是 <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0497.html">homogeneous_color_base&lt; Element, Layout, 3 &gt;</a></td><td class="indexvalue">>含有1种颜色要素同质颜色基, 是 <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0499.html">homogeneous_color_base&lt; Element, Layout, 4 &gt;</a></td><td class="indexvalue">>含有1种颜色要素同质颜色基, 是 <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0501.html">homogeneous_color_base&lt; Element, Layout, 5 &gt;</a></td><td class="indexvalue">>含有1种颜色要素同质颜色基, 是 <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a></td><td class="indexvalue">>含只有1种颜色要素同质颜色基</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a></td><td class="indexvalue">只有1种颜色要素同质颜色基, 支持默认构造. 是 <a class="el" href="g_i_l_0371.html">Regular</a> 的强化</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a></td><td class="indexvalue">同质,基于像素,GIL构造的概念 </td></tr>
  <tr><td class="i,ndexkey"><a class="el" href="g_i_l_0297.html">HomogeneousPixelConcept</a></td><td class="indexvalue">同质像素概念 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0299.html">HomogeneousPixelValueConcept</a></td><td class="indexvalue">同质像素概念,是 <a class="el" href="g_i_l_0371.html">Regular</a> 类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0503.html">identity</a></td><td class="indexvalue"> 采用于 SGI STL的Identity概念 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0038.html">image</a></td><td class="indexvalue">图像视图的容器接口, 是 <a class="el" href="g_i_l_0301.html">ImageConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0532.html">image_is_basic</a></td><td class="indexvalue">基本图像必须使用基本图像视图,并且使用标准的分配器 :基于char 的 std::allocator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0534.html">image_type</a></td><td class="indexvalue">指定通道的类型,布局和结构(是否是planar),得到同质图像的类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0040.html">image_view</a></td><td class="indexvalue">轻量级的对象,把内存映射为像素的2维数组, 是 <a class="el" href="g_i_l_0303.html">ImageViewConcept</a>,<a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>,<a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>,<a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>,<a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0301.html">ImageConcept</a></td><td class="indexvalue">2维图像,是 <a class="el" href="g_i_l_0351.html">PixelValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0303.html">ImageViewConcept</a></td><td class="indexvalue">GIL的2维图像视图,其像素是不可变的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0505.html">inc</a></td><td class="indexvalue">操作符++ 封装为仿函数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0535.html">is_iterator_adaptor</a></td><td class="indexvalue">判定指定的迭代器是平凡迭代器还是迭代器适配器的 <a class="el" href="g_i_l_0309.html">元函数 </a>  . 适配器的示例是step迭代器和解引用适配器 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0536.html">is_pixel&lt; bit_aligned_pixel_reference&lt; C, L, M &gt; &gt;</a></td><td class="indexvalue">判定标示对象<a class="el" href="g_i_l_0398.html">bit_aligned_pixel_reference</a>是否满足<a class="el" href="g_i_l_0341.html">PixelConcept</a>的<a class="el" href="g_i_l_0309.html">元函数</a> .  <a class="el" href="g_i_l_0341.html">PixelConcept</a> 需要这个功能</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0537.html">is_pixel&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue"> 判定标示对象 <a class="el" href="g_i_l_0605.html">planar_pixel_reference</a> 是否满足 <a class="el" href="g_i_l_0341.html">PixelConcept</a> 的 <a class="el" href="g_i_l_0309.html">元函数</a>. <a class="el" href="g_i_l_0341.html">PixelConcept</a> 需要这个功能</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0538.html">is_planar&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">判定 <a class="el" href="g_i_l_0605.html">planar_pixel_reference</a> 是否表示一个planar 构造. <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> 需要这个功能</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0540.html">iterator_add_deref</a></td><td class="indexvalue">通过对迭代器解引用的时候调用适配器,产生新的迭代器类型(并且也创建这样的一个实例)</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0542.html">iterator_add_deref&lt; dereference_iterator_adaptor&lt; Iterator, PREV_DEREF &gt;, Deref &gt;</a></td><td class="indexvalue">对于解引用迭代器适配器,新旧仿函数对象进行复合</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0042.html">iterator_from_2d</a></td><td class="indexvalue">对图像的像素提供一维随机访问迭代器, 是 <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0543.html">iterator_is_basic</a></td><td class="indexvalue">判定指定的像素迭代器是否是基本的, 基本的迭代器必须使用<a class="el" href="g_i_l_0593.html">gil::pixel</a> (如果是 interleaved), 或者<a class="el" href="g_i_l_0603.html">gil::planar_pixel_iterator</a> (如果是 planar) , 或者是 <a class="el" href="g_i_l_0046.html">gil::memory_based_step_iterator</a> (如果是 step). 它们必须使用标准的const规则 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0544.html">iterator_is_mutable</a></td><td class="indexvalue"> 判定是否可以修改指定迭代器值的<a class="el" href="g_i_l_0309.html">元函数</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0545.html">iterator_is_step</a></td><td class="indexvalue">判定指定得到迭代器的step是否可以动态设定 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0546.html">iterator_type</a></td><td class="indexvalue">指定通道的类型,布局,结构(是否是planar),步长(是否是step)和可变性, 得到同质迭代器的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0547.html">iterator_type_from_pixel</a></td><td class="indexvalue">指定像素的类型, 结构(是否是planar),步长(是否是step)和可变性,得到迭代器的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0305.html">IteratorAdaptorConcept</a></td><td class="indexvalue">迭代器适配器是一个前向迭代器,以另一个迭代器为基础 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0549.html">jpeg_read_support</a></td><td class="indexvalue">判定指定的图像视图类型是否可读 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0551.html">jpeg_write_support</a></td><td class="indexvalue">判定指定的图像视图类型是否可写 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0507.html">kth_channel_deref_fn</a></td><td class="indexvalue">仿函数对象,得到指定像素第K个通道(作为模板参数)的灰度级引用. 是<a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a>的模型.<p>
如果输入是一个像素值或者const引用,那么仿函数是不可变的, 否则是可变的(返回非const引用) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0553.html">kth_channel_view_type</a></td><td class="indexvalue">指定源图像视图和通道, 得到新的图像视图类型.<p>
如果源视图的通道是存储相邻的(planar 非step视图或者单通道视图), 那么得到的视图类型是单通道,非step视图. 如果通道是非存储相邻的(interleaved或者step视图), 那么得到的视图类型是单通道,step视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0555.html">kth_semantic_element_const_reference_type</a></td><td class="indexvalue">得到函数 semantic_at_c&lt;K&gt;(color_base); 的const返回值类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0557.html">kth_semantic_element_reference_type</a></td><td class="indexvalue">得到函数 semantic_at_c&lt;K&gt;(color_base); 的返回值类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0559.html">kth_semantic_element_type</a></td><td class="indexvalue"> 得到颜色基第K个元素的类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0561.html">layout</a></td><td class="indexvalue">表示内存中的颜色空间和通道次序 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0562.html">locator_is_basic</a></td><td class="indexvalue">判定指定的定位器是否是基本的, 基本的定位器是基于内存的,并且具有 basic x_iterator 和 y_iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0563.html">locator_is_mutable</a></td><td class="indexvalue">判定指定的定位器是否是可变的 (例如, 它的像素值是可变的) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0564.html">locator_is_step_in_x</a></td><td class="indexvalue">判定指定的定位器是否有水平动态的定位步长 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0565.html">locator_is_step_in_y</a></td><td class="indexvalue">判定指定的定位器是否有垂直动态的定位步长 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0567.html">locator_type</a></td><td class="indexvalue">指定通道类型,布局,结构(是否是planar),步长(是否有水平step),得到同质定位器的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0568.html">magenta_t</a></td><td class="indexvalue">Magenta </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0044.html">memory_based_2d_locator</a></td><td class="indexvalue">基于内存的像素定位器,是 <a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a>,<a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>,<a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>,<a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a> 的模型<p>
这个类以step迭代器为参数, step迭代器提供垂直漫游的功能, 而其基本迭代器提供水平漫游的功能 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0046.html">memory_based_step_iterator</a></td><td class="indexvalue">动态的基于存储单位(字节或位)的动态step迭代器, 是 <a class="el" href="g_i_l_0375.html">StepIteratorConcept</a>, <a class="el" href="g_i_l_0305.html">IteratorAdaptorConcept</a>, <a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a></td><td class="indexvalue">基于存储单位(字节或位)的随机访问迭代器的概念 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0570.html">memunit_step_fn</a></td><td class="indexvalue">仿函数对象, 得到两个迭代器之间的距离, 按照指定的步长(以字节或者位为单位)累加迭代器  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0309.html">Metafunction</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0311.html">MutableChannelConcept</a></td><td class="indexvalue">数值可变的通道类型  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0313.html">MutableColorBaseConcept</a></td><td class="indexvalue">元素可变的颜色基类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0315.html">MutableHomogeneousColorBaseConcept</a></td><td class="indexvalue">元素可变的同质颜色基类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0317.html">MutableHomogeneousPixelConcept</a></td><td class="indexvalue">通道可变的同质像素类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0319.html">MutableImageViewConcept</a></td><td class="indexvalue">基于可变像素的2维图像视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0321.html">MutableIteratorAdaptorConcept</a></td><td class="indexvalue">可变的迭代器适配器 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0323.html">MutablePixelConcept</a></td><td class="indexvalue">通道值可变的像素概念 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0325.html">MutablePixelIteratorConcept</a></td><td class="indexvalue">像素值可变的像素迭代器</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0327.html">MutablePixelLocatorConcept</a></td><td class="indexvalue">基于可变像素的GIL2维定位器</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0329.html">MutableRandomAccess2DImageViewConcept</a></td><td class="indexvalue">可变的2维图像视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0331.html">MutableRandomAccess2DLocatorConcept</a></td><td class="indexvalue">可变像素的2维定位器 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0333.html">MutableRandomAccessNDImageViewConcept</a></td><td class="indexvalue">可变的N维图像视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0335.html">MutableRandomAccessNDLocatorConcept</a></td><td class="indexvalue">可变像素的N维定位器  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0337.html">MutableStepIteratorConcept</a></td><td class="indexvalue">可变的Step迭代器 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0509.html">nth_channel_deref_fn</a></td><td class="indexvalue">仿函数对象, 得到指定像素的第N个通道的灰度级引用类型, 是 <a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a> 的模型.<p>
如果输入的是数像素值或者像素const引用, 那么得到的是不可变类型;否则是可变类型(非const,第n个通道的像素引用类型)</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0572.html">nth_channel_view_type</a></td><td class="indexvalue">指定源图像视图和通道, 得到单通道图像视图类型<p>
如果源视图的通道是存储相邻的(planar 非step视图或者单通道视图), 那么得到的视图类型是单通道,非step视图. 如果通道是非存储相邻的(interleaved或者step视图), 那么得到的视图类型是单通道,step视图  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0574.html">nth_channel_view_type&lt; any_image_view&lt; ViewTypes &gt; &gt;</a></td><td class="indexvalue">指定运行时指派的源图像视图和通道, 得到单通道图像视图类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0575.html">num_channels</a></td><td class="indexvalue">得到基于像素的GIL构造的通道个数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0048.html">packed_channel_reference&lt; BitField, FirstBit, NumBits, false &gt;</a></td><td class="indexvalue">在编译期指定位偏移,构造通道引用的常量子类型,是  <a class="el" href="g_i_l_0259.html">ChannelConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0050.html">packed_channel_reference&lt; BitField, FirstBit, NumBits, true &gt;</a></td><td class="indexvalue">在编译期指定位偏移,构造通道引用的可变子类型,是  <a class="el" href="g_i_l_0259.html">ChannelConcept</a> 的模型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0052.html">packed_channel_value</a></td><td class="indexvalue">通道子类型的值, 是<a class="el" href="g_i_l_0265.html">ChannelValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0054.html">packed_dynamic_channel_reference&lt; BitField, NumBits, false &gt;</a></td><td class="indexvalue">在运行期指定位偏移,构造通道引用的常量子类型,是 <a class="el" href="g_i_l_0259.html">ChannelConcept</a> 的模型, 和 packed_channel_reference 一样, 除了位偏移是在运行期指派 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0056.html">packed_dynamic_channel_reference&lt; BitField, NumBits, true &gt;</a></td><td class="indexvalue">在运行期指定位偏移,构造通道引用的可变子类型,是<a class="el" href="g_i_l_0259.html">ChannelConcept</a>的模型, 和 packed_channel_reference 一样, 除了位偏移是在运行期指派</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0577.html">packed_image1_type</a></td><td class="indexvalue">指定位域类型,通道的位大小和布局, 得到单通道图像类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0579.html">packed_image2_type</a></td><td class="indexvalue">指定位域类型,通道的位大小和布局, 得到2通道图像类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0581.html">packed_image3_type</a></td><td class="indexvalue">指定位域类型,通道的位大小和布局, 得到3通道图像类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0583.html">packed_image4_type</a></td><td class="indexvalue">指定位域类型,通道的位大小和布局, 得到4通道图像类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0585.html">packed_image5_type</a></td><td class="indexvalue">指定位域类型,通道的位大小和布局, 得到5通道图像类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0587.html">packed_image_type</a></td><td class="indexvalue">得到interleaved packed 图像类型: 图像的通道可以不是字节对齐的,但是整个像素是字节对齐的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0589.html">packed_pixel</a></td><td class="indexvalue">异质像素值类型, 其通道引用是从位域和索引构造的, 是<a class="el" href="g_i_l_0271.html">ColorBaseValueConcept</a>, <a class="el" href="g_i_l_0351.html">PixelValueConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> 的模型, 这个模型的一般适用于packed 像素 (例如 565 RGB) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0591.html">packed_pixel_type</a></td><td class="indexvalue">指定位域类型,通道的位大小和布局, 得到packed像素类型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0593.html">pixel</a></td><td class="indexvalue">表示像素值(通道的容器),是 <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a>, <a class="el" href="g_i_l_0351.html">PixelValueConcept</a>, <a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0058.html">pixel_2d_locator_base</a></td><td class="indexvalue"> <a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a>概念模型的基类<p>
像素定位器类似于像素迭代器,只是允许对图像视图的2维遍历. 它有2维的 difference_type,并支持随机访问 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0594.html">pixel_is_reference</a></td><td class="indexvalue">判定指向的像素模型是否是像素引用(相对于像素值) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0595.html">pixel_reference_is_basic</a></td><td class="indexvalue">判定像素引用是否是基本的引用类型,基本的引用类型必须使用 <a class="el" href="g_i_l_0593.html">gil::pixel</a>&amp; (如果是 interleaved), 或者是<a class="el" href="g_i_l_0605.html">gil::planar_pixel_reference</a> (如果是 planar). 它们必须使用标准的const规则</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0596.html">pixel_reference_is_mutable</a></td><td class="indexvalue">判定指定的像素引用是否是可变的(例如通道值是可变的) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0597.html">pixel_reference_is_proxy</a></td><td class="indexvalue">判定指定的像素引用是否是代理类或者本地的 C++ 引用 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0598.html">pixel_reference_type</a></td><td class="indexvalue">指定通道类型,布局,结构(是否是planar)和可变性,得到同质像素引用类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0600.html">pixel_value_type</a></td><td class="indexvalue">指定通道类型和布局,得到同质像素类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0339.html">PixelBasedConcept</a></td><td class="indexvalue">基于像素的GIL构造的概念, 例如像素, 迭代器,定位器,视图和基于像素的图像 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0341.html">PixelConcept</a></td><td class="indexvalue">像素概念,其颜色基的元素类型那个是颜色通道 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0343.html">PixelConvertibleConcept</a></td><td class="indexvalue">像素可转换概念  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a></td><td class="indexvalue">对像素迭代器解引用的一元仿函数对象</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a></td><td class="indexvalue">满足<a class="el" href="g_i_l_0341.html">PixelConcept</a>,STL风格的随机访问迭代器 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a></td><td class="indexvalue">基于GIL不可变像素类型的2维定位器</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0601.html">pixels_are_compatible</a></td><td class="indexvalue">像素间是否兼容 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0353.html">PixelsCompatibleConcept</a></td><td class="indexvalue">像素兼容的概念, 像素兼容也即是它们的颜色空间和通道类型是兼容的. 兼容的像素之间可以赋值和相互拷贝  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0351.html">PixelValueConcept</a></td><td class="indexvalue">满足 <a class="el" href="g_i_l_0371.html">Regular</a> 的像素类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0603.html">planar_pixel_iterator</a></td><td class="indexvalue">planar像素迭代器类型, 是  <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a>, <a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0605.html">planar_pixel_reference</a></td><td class="indexvalue">planar像素引用代理, 是 <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a>, <a class="el" href="g_i_l_0297.html">HomogeneousPixelConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0511.html">plus_asymmetric</a></td><td class="indexvalue">加法函数对象,其参数可以是different_type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0607.html">png_read_support</a></td><td class="indexvalue">判定指定的图像视图类型是否可读  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0609.html">png_write_support</a></td><td class="indexvalue">判定指定的图像视图类型是否可写 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0060.html">point2</a></td><td class="indexvalue">具有相同维度类型的2维点<p>
是 <a class="el" href="g_i_l_0355.html">Point2DConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0355.html">Point2DConcept</a></td><td class="indexvalue">2维点的概念 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0357.html">PointNDConcept</a></td><td class="indexvalue">N维点概念 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0611.html">position_iterator</a></td><td class="indexvalue">记录X Y位置的迭代器,并且通过调用仿函数进行解引用, 是 <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a> 的模型. 用来创建虚拟图像视图, 是 <a class="el" href="g_i_l_0375.html">StepIteratorConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0359.html">RandomAccess2DImageConcept</a></td><td class="indexvalue">二维容器概念</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0361.html">RandomAccess2DImageViewConcept</a></td><td class="indexvalue">不可变二维图像视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0363.html">RandomAccess2DLocatorConcept</a></td><td class="indexvalue">不可变二维定位器</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0365.html">RandomAccessNDImageConcept</a></td><td class="indexvalue">N维容器 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0367.html">RandomAccessNDImageViewConcept</a></td><td class="indexvalue">不可变N维图像视图 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0369.html">RandomAccessNDLocatorConcept</a></td><td class="indexvalue">不可变N维定位器 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0612.html">red_t</a></td><td class="indexvalue">Red </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0371.html">Regular</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0513.html">rgb_to_luminance_fn</a></td><td class="indexvalue">Red * .3 + green * .59 + blue * .11 + .5 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0373.html">SameType</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0614.html">scoped_channel_value</a></td><td class="indexvalue">改变源的通道适配器, 是<a class="el" href="g_i_l_0265.html">ChannelValueConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0615.html">size</a></td><td class="indexvalue">得到颜色基的元素个数, 以MPL整数类型返回  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0515.html">std_fill_t</a></td><td class="indexvalue">模仿 <a class="el" href="g_i_l_0209.html#ga4">std::fill</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0036.html">step_iterator_adaptor</a></td><td class="indexvalue">迭代器适配器,支持步长的改变 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0375.html">StepIteratorConcept</a></td><td class="indexvalue">Step 迭代器概念 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0377.html">Swappable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0617.html">tiff_read_support</a></td><td class="indexvalue">判定指定的图像视图类型是否可读 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0619.html">tiff_write_support</a></td><td class="indexvalue">判定指定的图像视图类型是否可写 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0621.html">type_from_x_iterator</a></td><td class="indexvalue">指定通过行访问像素的像素迭代器, 得到内建的类型 step_iterator, xy_locator 和 <a class="el" href="g_i_l_0040.html">image_view</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0516.html">type_to_index</a></td><td class="indexvalue">得到指定类型第一次出现的位置 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0062.html">variant</a></td><td class="indexvalue">在指定类型集中通过运行时指派的变体类型<p>
一般的是指不同类型集的概念. 这个类型集可以是不同参数的模板类,也可以是完全无关的类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0622.html">view_is_basic</a></td><td class="indexvalue">基本图像视图是基于基本定位器的 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0623.html">view_is_mutable</a></td><td class="indexvalue">判定指定的图像视图是否是可变的  (例如它的像素是否看更改 ) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0624.html">view_is_step_in_x</a></td><td class="indexvalue">判定指定的图像视图在水平方向上的步长是否可动态的设定 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0625.html">view_is_step_in_y</a></td><td class="indexvalue">判定指定的图像视图在垂直方向上的步长是否可动态的设定 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0627.html">view_type</a></td><td class="indexvalue">指定通道类型,布局,结构(是否是planar)和步长(是否支持水平步长),得到同质的图像视图类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0629.html">view_type_from_pixel</a></td><td class="indexvalue">指定像素, 结构(是否是planar)和步长(是否支持水平步长),得到图像视图类型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0630.html">views_are_compatible</a></td><td class="indexvalue">图像视图间是否兼容 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0379.html">ViewsCompatibleConcept</a></td><td class="indexvalue">如果具有相同的颜色空间和兼容的通道类型,那么图像视图就是兼容的. const特性和布局与兼容性无关  </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0064.html">virtual_2d_locator</a></td><td class="indexvalue">二维虚拟图像适配器. 通过指定的仿函数对坐标解引用, 是 <a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>, <a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>, <a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a> 的模型</td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0631.html">yellow_t</a></td><td class="indexvalue">Yellow </td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Nov 8 21:53:19 2007 for Generic Image Library   by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>

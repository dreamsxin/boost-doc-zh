<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<!----><title>GIL : 设计指南</title>

<meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<link type="text/css" rel="stylesheet" href="adobe_source.css" />
<link rel="alternate" title="opensource.adobe.com RSS" href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" type="application/rss+xml" />
</head>
<body>
<table style="margin: 0pt; padding: 0pt; width: 100%;" border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%">
<div class="qindex"><a class="qindex" href="index.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical List</a> | <a class="qindex" href="annotated.html">Class List</a>
| <a class="qindex" href="dirs.html">Directories</a>
| <a class="qindex" href="files.html">File List</a>
| <a class="qindex" href="../index.html">GIL Home
Page</a> </div>
<!-- End Header -->
<!-- Generated by Doxygen 1.5.6 -->
<h1><a class="anchor" name="GILDesignGuide">GIL
设计指南</a></h1>
<dl compact="compact">
<dt><b>作者:</b></dt>
<dd>Lubomir Bourdev (<a href="mailto:lbourdev@adobe.com">lbourdev@adobe.com</a>)
和 Hailin Jin (<a href="mailto:hljin@adobe.com">hljin@adobe.com</a>)
<br />
Adobe 系统公司 </dd>
</dl>
<dl compact="compact">
<dt><b>版本:</b></dt>
<dd>2.1 </dd>
</dl>
<dl compact="compact">
<dt><b>日期:</b></dt>
<dd>September 15, 2007</dd>
</dl>
<p>
GIL是一个从算法角度抽象图像接口的C++函数库,本文档描述了GIL的设计理念. 本文档的内容远远超过了如何简单的使用GIL所需要的知识.
在GIL的主页上,你可以找到一个使用GIL的快速起点&nbsp;<a href="http://stlab.adobe.com/gil">http://stlab.adobe.com/gil</a></p>
<p>(译者注:本文中image view和view经常混用,其实它们都是image
view的含义.为了方便,我们统一使用图像视图)</p>
<p></p>
<ul>
<li><a class="el" href="gildesignguide.html#OverviewSectionDG">1. 概述</a></li>
<li><a class="el" href="gildesignguide.html#ConceptsSectionDG">2. 关于Concept</a></li>
<li><a class="el" href="gildesignguide.html#PointSectionDG">3. 点</a></li>
<li><a class="el" href="gildesignguide.html#ChannelSectionDG">4. 通道</a></li>
<li><a class="el" href="gildesignguide.html#ColorSpaceSectionDG">5. 颜色空间和布局</a></li>
<li><a class="el" href="gildesignguide.html#ColorBaseSectionDG">6. 颜色基</a></li>
<li><a class="el" href="gildesignguide.html#PixelSectionDG">7. 像素</a></li>
<li><a class="el" href="gildesignguide.html#PixelIteratorSectionDG">8. 像素迭代器</a>
<ul>
<li><a class="el" href="gildesignguide.html#FundamentalIteratorDG">基本迭代器</a></li>
<li><a class="el" href="gildesignguide.html#IteratorAdaptorDG">迭代适配器</a></li>
<li><a class="el" href="gildesignguide.html#PixelDereferenceAdaptorAG">像素解引用适配器</a></li>
<li><a class="el" href="gildesignguide.html#StepIteratorDG">Step 迭代器</a></li>
<li><a class="el" href="gildesignguide.html#LocatorDG">像素定位器</a></li>
<li><a class="el" href="gildesignguide.html#IteratorFrom2DDG">2维图像迭代器</a></li>
</ul>
</li>
<li><a class="el" href="gildesignguide.html#ImageViewSectionDG">9. 图像视图</a>
<ul>
<li><a class="el" href="gildesignguide.html#ImageViewFrowRawDG">从裸像素创建图像视图</a></li>
<li><a class="el" href="gildesignguide.html#ImageViewFrowImageViewDG">从其他图像视图创建
图像视图</a></li>
</ul>
</li>
<li><a class="el" href="gildesignguide.html#ImageSectionDG">10. 图像</a></li>
<li><a class="el" href="gildesignguide.html#VariantSecDG">11. 运行时指派的图像和图像视图</a></li>
<li><a class="el" href="gildesignguide.html#MetafunctionsDG">12.
丰富的元函数和Typedefs</a></li>
<li><a class="el" href="gildesignguide.html#IO_DG">13. I/O 扩展</a></li>
<li><a class="el" href="gildesignguide.html#SampleImgCodeDG">14. 示例代码</a>
<ul>
<li><a class="el" href="gildesignguide.html#PixelLevelExampleDG">像素级别示例代码</a></li>
<li><a class="el" href="gildesignguide.html#SafeAreaExampleDG">从安全缓冲区创建的视图拷贝</a></li>
<li><a class="el" href="gildesignguide.html#HistogramExampleDG">柱状图</a></li>
<li><a class="el" href="gildesignguide.html#ImageViewsExampleDG">使用视图</a></li>
</ul>
</li>
<li><a class="el" href="gildesignguide.html#ExtendingGIL_DG">15. 扩展GIL</a>
<ul>
<li><a class="el" href="gildesignguide.html#NewColorSpacesDG">定义新的颜色空间</a></li>
<li><a class="el" href="gildesignguide.html#NewColorConversionDG">重载颜色变换</a></li>
<li><a class="el" href="gildesignguide.html#NewChannelsDG">定义新的颜色通道类型</a></li>
<li><a class="el" href="gildesignguide.html#NewImagesDG">定义新的图像视图</a></li>
</ul>
</li>
<li><a class="el" href="gildesignguide.html#TechnicalitiesDG">16. 专门技术</a></li>
<li><a class="el" href="gildesignguide.html#ConclusionDG">17. 结论</a></li>
</ul>
<p>
<br />
</p>
<hr />
<h2><a class="anchor" name="OverviewSectionDG">1.
概述</a></h2>
在任何图像处理,视觉和视频处理的工程中,图像都是很基本的概念. 但是图像在表现上的千差万别使其算法代码很难做到既通用又高效.
在本节中,我们将描述一些我们面对的挑战.
<p>在下面的讨论中,图像将被视为像素的一个2维数组. 像素是一个颜色通道的集合, 代表图像中指定点的颜色.
每个通道代表颜色组件的一个值. 存在两种通用的图像内存结构. Interleaved图像, 像素是分组连续, 通道是间隔存储的,
而planar图像, 不同的通道存在不同的颜色面上. 下面是一个4x3 RGB 类型的图像,第一行的第二个像素被标记为红色, 是
interleaved 型的:</p>
<p></p>
<div align="center"><img src="interleaved.jpg" alt="interleaved.jpg" />
</div>
而这个是planar型的:
<p></p>
<div align="center"><img src="planar.jpg" alt="planar.jpg" />
</div>
<p>
要注意可能的行对齐导致行末的空白填充. </p>
<p>GIL提供的图像模型可以应对如下的变化:</p>
<ul>
<li>结构性(planar 和 interleaved)</li>
<li>颜色空间和alpha表示 (RGB, RGBA, CMYK, 等等.)</li>
<li>颜色通道深度 (8位, 16位, 等等.)</li>
<li>通道的次序(RGB 和 BGR, 等等.)</li>
<li>行对齐策略 (没有对齐,字对齐, 等等.)</li>
</ul>
<p>
GIL还支持用户定义的图像模型,以及参数在运行时指定的图像类型. GIL从算法的角度抽象了图像的表现, 这样代码只需书写一次,
就可以使之工作在各种图像类型上, 而其产生的可执行代码速度,可以和针对特定图像类型的手写代码相媲美.</p>
<p>本文档遵循自顶向上的设计原则. 每节定义的概念建立在上一节定义的概念之上. 推荐你按照节的次序阅读本文档.</p>
<p></p>
<hr />
<h2><a class="anchor" name="ConceptsSectionDG">2.
关于Concept</a></h2>
所有的GIL构造都是GIL概念的模型. 概念是为了泛型算法正确的应用,一个类型(或者一组相关类型)必须满足的一组条件.
这些条件包括语法形式和算法运算. 例如,GIL类型 <code>pixel</code> 是 GIL 概念
PixelConcept的模型. 用户可以使用自己的类型替换<code>pixel</code>. 只要它能够满足<code>PixelConcept</code>的
要求, 所有其他的GIL 类型和算法都可以使用. 这里有更多概念的信息 <a href="http://www.generic-programming.org/languages/conceptcpp/">http://www.generic-programming.org/languages/conceptcpp/</a>
<p>我们将使用语法的形式定义概念,这是C++0x 标准定义的一个关于概念的扩展: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2081.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2081.pdf</a></p>
<p>这里有更多的GIL使用的概念定义,绝大部分都在这里: <a href="http://www.generic-programming.org/languages/conceptcpp/concept_web.php">http://www.generic-programming.org/languages/conceptcpp/concept_web.php</a></p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">auto</span> concept DefaultConstructible&lt;typename T&gt; {<br /> T::T(); <br />};<br /><br /><span class="keyword">auto</span> concept CopyConstructible&lt;typename T&gt; {<br /> T::T(T);<br /> T::~T();<br />};<br /><br /><span class="keyword">auto</span> concept Assignable&lt;typename T, typename U = T&gt; {<br /> <span class="keyword">typename</span> result_type;<br /> result_type operator=(T&amp;, U); <br />};<br /><br /><span class="keyword">auto</span> concept EqualityComparable&lt;typename T, typename U = T&gt; {<br /> <span class="keywordtype">bool</span> operator==(T x, T y); <br /> <span class="keywordtype">bool</span> operator!=(T x, T y) { <span class="keywordflow">return</span> !(x==y); }<br />};<br /><br />concept SameType&lt;typename T, typename U&gt; { <span class="comment">/* unspecified */</span> };<br /><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; concept_map SameType&lt;T, T&gt; { <span class="comment">/* unspecified */</span> };<br /><br /><span class="keyword">auto</span> concept Swappable&lt;typename T&gt; {<br /> <span class="keywordtype">void</span> swap(T&amp; t, T&amp; u);<br />};<br /></pre>
</div>
<p>这里是附加的GIL需要的基本概念:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">auto</span> concept Regular&lt;typename T&gt; : DefaultConstructible&lt;T&gt;, CopyConstructible&lt;T&gt;, EqualityComparable&lt;T&gt;, Assignable&lt;T&gt;, Swappable&lt;T&gt; {};<br /><br /><span class="keyword">auto</span> concept Metafunction&lt;typename T&gt; {<br /> <span class="keyword">typename</span> type;<br />};<br /></pre>
</div>
<h2><a class="anchor" name="PointSectionDG">3.
点</a></h2>
一个点定义了图像中像素的位置, 它也可以用来描述图像的维度. 从最通用的角度看, 点是N-维的,满足下列概念的要求:
<p></p>
<div class="fragment">
<pre class="fragment">concept PointNDConcept&lt;typename T&gt; : Regular&lt;T&gt; { <br /> <span class="comment">// 每个轴的坐标定义</span><br /> <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> K&gt; <span class="keyword">struct </span>axis; where Metafunction&lt;axis&gt;;<br /> <br /> <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dimensions;<br /> <br /> <span class="comment"> // 访问/修改 每个轴的数值.</span><br /> <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> K&gt; <span class="keyword">const</span> <span class="keyword">typename</span> axis&lt;K&gt;::type&amp; T::axis_value() <span class="keyword">const</span>;<br /> <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> K&gt; <span class="keyword">typename</span> axis&lt;K&gt;::type&amp; T::axis_value();<br />};<br /></pre>
</div>
<p>GIL 使用2维点, 它是概念 <code>PointNDConcept</code>
的一个强化,要求每维的数据类型必须是相同的:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept Point2DConcept&lt;typename T&gt; : PointNDConcept&lt;T&gt; { <br /> where num_dimensions == 2;<br /> where SameType&lt;axis&lt;0&gt;::type, axis&lt;1&gt;::type&gt;;<br /><br /> <span class="keyword">typename</span> value_type = axis&lt;0&gt;::type;<br /><br /> <span class="keyword">const</span> value_type&amp; operator[](<span class="keyword">const</span> T&amp;, <span class="keywordtype">size_t</span> i);<br /> value_type&amp; operator[]( T&amp;, <span class="keywordtype">size_t</span> i);<br /><br /> value_type x,y;<br />};<br /></pre>
</div>
<p><b>相关概念:</b></p>
<p></p>
<ul>
<li>PointNDConcept&lt;T&gt;</li>
<li>Point2DConcept&lt;T&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>GIL 提供了 <code>Point2DConcept</code>的一个模型<code>point2&lt;T&gt;</code>,
其中<code>T</code> 是坐标的类型. .</p>
<p></p>
<hr />
<h2><a class="anchor" name="ChannelSectionDG">4.
通道</a></h2>
通道指示颜色组件的强度(例如, RGB像素中的红色通道). 典型的通道操作包括获取,比较和设置通道的值.
通道有最大和最小值.GIL的通道是以下概念的模型:
<p></p>
<div class="fragment">
<pre class="fragment">concept ChannelConcept&lt;typename T&gt; : EqualityComparable&lt;T&gt; {<br /> <span class="keyword">typename</span> value_type = T; <span class="comment">// 使用 channel_traits&lt;T&gt;::value_type 访问</span><br />where ChannelValueConcept&lt;value_type&gt;;<br /><span class="keyword">typename</span> reference = T&amp;; <span class="comment">// 使用 channel_traits&lt;T&gt;::reference 访问</span><br /><span class="keyword">typename</span> pointer = T*; <span class="comment">// 使用 channel_traits&lt;T&gt;::pointer 访问</span><br /><span class="keyword">typename</span> const_reference = <span class="keyword">const</span> T&amp;; <span class="comment">// 使用 channel_traits&lt;T&gt;::const_reference 访问</span><br /><span class="keyword">typename</span> const_pointer = <span class="keyword">const</span> T*; <span class="comment">// 使用 channel_traits&lt;T&gt;::const_pointer 访问</span><br /><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_mutable; <span class="comment">// 使用 channel_traits&lt;T&gt;::is_mutable 访问</span><br /><span class="keyword">static</span> T min_value(); <span class="comment">// 使用 channel_traits&lt;T&gt;::min_value 访问</span><br /><span class="keyword">static</span> T max_value(); <span class="comment">// 使用 channel_traits&lt;T&gt;::min_value 访问</span><br />};<br />concept MutableChannelConcept&lt;ChannelConcept T&gt; : Swappable&lt;T&gt;, Assignable&lt;T&gt; {};<br />concept ChannelValueConcept&lt;ChannelConcept T&gt; : Regular&lt;T&gt; {}; </pre>
</div>
<p>GIL允许使用内建的整型和浮点型作为通道类型. 因此其相关型别和范围信息可以使用<code>channel_traits</code>
定义, 获得默认的实现:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<br /><span class="keyword">struct </span>channel_traits {<br /> <span class="keyword">typedef</span> T value_type;<br /> <span class="keyword">typedef</span> T&amp; reference;<br /> <span class="keyword">typedef</span> T* pointer;<br /> <span class="keyword">typedef</span> T&amp; <span class="keyword">const</span> const_reference;<br /> <span class="keyword">typedef</span> T* <span class="keyword">const</span> const_pointer;<br /> <br /> <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> std::numeric_limits&lt;T&gt;::min(); }<br /> <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> std::numeric_limits&lt;T&gt;::max(); }<br />};<br /></pre>
</div>
<p>如果通道具有相同的值类型,那么它们就是兼容的:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept ChannelsCompatibleConcept&lt;ChannelConcept T1, ChannelConcept T2&gt; {<br /> where SameType&lt;T1::value_type, T2::value_type&gt;;<br />};<br /></pre>
</div>
<p>一个通道类型可以转换为其他的通道类型:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;ChannelConcept Src, ChannelValueConcept Dst&gt;<br />concept ChannelConvertibleConcept {<br /> Dst <a class="code" href="../../../../../boost_doc_40/libs/gil/doc/html/g_i_l_0099.html#gf04e6ac30a35a1f68a8bb84730e34786" title="Converting from one channel type to another.">channel_convert</a>(Src);<br />};<br /></pre>
</div>
<p>注意到 <code>ChannelConcept</code> 和 <code>MutableChannelConcept</code>并
没有默认构造函数. 支持默认构造函数的类型(也就构成所谓的正规型别)是概念<code>ChannelValueConcept</code>的
模型. 为了理解这个差别, 考虑一个16位RGB像素类型,是"565" 位模式. 通道模式和位区间一致. 为了支持这样的通道类型,
我们需要创建代理引用类. 这样的代理引用类是概念<code>ChannelConcept</code>的模型,
但是和本地的C++ 引用一样, 它没有默认构造函数.</p>
<p>注意到算法可能需要对通道类型施加更多的要求,例如需要支持算术运算.</p>
<p><b>相关概念:</b></p>
<p></p>
<ul>
<li>ChannelConcept&lt;T&gt;</li>
<li>ChannelValueConcept&lt;T&gt;</li>
<li>MutableChannelConcept&lt;T&gt;</li>
<li>ChannelsCompatibleConcept&lt;T1,T2&gt;</li>
<li>ChannelConvertibleConcept&lt;SrcChannel,DstChannel&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>所有内建的整型和浮点型都是有效的通道类型, GIL提供了一些整型通道类型的标准定义:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">typedef</span> boost::uint8_t bits8;<br /><span class="keyword">typedef</span> boost::uint16_t bits16;<br /><span class="keyword">typedef</span> boost::uint32_t bits32;<br /><span class="keyword">typedef</span> boost::int8_t bits8s;<br /><span class="keyword">typedef</span> boost::int16_t bits16s;<br /><span class="keyword">typedef</span> boost::int32_t bits32s;<br /></pre>
</div>
<p>基于内建型别的通道类型的最大值和最小值, 和这些内建型别的物理值范围一致,也即通过<code>std::numeric_limits</code>指
定的最大值和最小值. 有时候物理值范围是不适合的. GIL提供了<code>scoped_channel_value</code>,
是通道适配器的一个模型, 允许定制值的范围. 我们可以用它来定义 [0..1]范围内浮点通道类型:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">struct </span>float_zero { <span class="keyword">static</span> <span class="keywordtype">float</span> apply() { <span class="keywordflow">return</span> 0.0f; } };<br /><span class="keyword">struct </span>float_one { <span class="keyword">static</span> <span class="keywordtype">float</span> apply() { <span class="keywordflow">return</span> 1.0f; } };<br /><span class="keyword">typedef</span> scoped_channel_value&lt;float,float_zero,float_one&gt; bits32f;<br /></pre>
</div>
<p>GIL 还提供了和位域范围一致的模型定义:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 通道的值范围通过NumBits 定义, 是ChannelValueConcept的模型</span><br /><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NumBits&gt; <span class="keyword">class </span>packed_channel_value;<br /><br /><span class="comment">// 通道的值范围通过NumBits 定义的引用, 是ChannelConcept的模型</span><br /><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> FirstBit, <br /> <span class="keywordtype">int</span> NumBits, <span class="comment">// 定义包含通道值的序列位 </span><br /><span class="keywordtype">bool</span> Mutable&gt; <span class="comment">// 如果引用可修改则为true </span><br /><span class="keyword">class </span>packed_channel_reference;<br /><br /><span class="comment">// 通道的值范围通过NumBits 定义的引用,FirstBit 是运行时参数. 它是ChannelConcept的模型</span><br /><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NumBits, <span class="comment">// 定义包含通道值的序列位 </span><br /><span class="keywordtype">bool</span> Mutable&gt; <span class="comment">// 如果引用可修改则为true </span><br /><span class="keyword">class </span>packed_dynamic_channel_reference;<br /></pre>
</div>
<p>注意到这两种引用代理的模型是不同的, 区别在于通道值范围的偏移是通过模板参数定义的还是通过运行时参数定义的.
第一种模型更快,更紧凑;第二种则更灵活. 例如第二种允许我们通过通道的位域构造迭代器.</p>
<p><b>算法:</b></p>
<p>下面是如何构造三类16位"565" 模式的像素类型, 然后设置其最大值的算法:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">typedef</span> packed_channel_reference&lt;0,5,true&gt; channel16_0_5_reference_t;<br /><span class="keyword">typedef</span> packed_channel_reference&lt;5,6,true&gt; channel16_5_6_reference_t;<br /><span class="keyword">typedef</span> packed_channel_reference&lt;11,5,true&gt; channel16_11_5_reference_t;<br /><br />boost::uint16_t data=0;<br />channel16_0_5_reference_t channel1(&amp;data);<br />channel16_5_6_reference_t channel2(&amp;data);<br />channel16_11_5_reference_t channel3(&amp;data);<br /><br />channel1=channel_traits&lt;channel16_0_5_reference_t&gt;::max_value();<br />channel2=channel_traits&lt;channel16_5_6_reference_t&gt;::max_value();<br />channel3=channel_traits&lt;channel16_11_5_reference_t&gt;::max_value();<br />assert(data==65535);<br /></pre>
</div>
<p>赋值,相等比较和拷贝构造只是在兼容的类型之间有效:</p>
<p></p>
<div class="fragment">
<pre class="fragment">packed_channel_value&lt;5&gt; channel_6bit = channel1;<br />channel_6bit = channel3;<br /><br /><span class="comment">//channel_6bit = channel2; // 编译错误: 在不兼容通道类型之间赋值.</span>
</pre>
</div>
<p>GIL所有的通道模型都是可以成对转换的:</p>
<p></p>
<div class="fragment">
<pre class="fragment">channel1 = channel_traits&lt;channel16_0_5_reference_t&gt;::max_value();<br />assert(channel1 == 31);<br /><br />bits16 chan16 = channel_convert&lt;bits16&gt;(channel1);<br />assert(chan16 == 65535);<br /></pre>
</div>
<p>通道转换是一个松散的操作, GIL的通道转换是一个在源通道范围到目标通道范围的线性变换.
这样的变换能够准确的在最大值和最小值之间进行映射(例如,从uint8_t到uint16_t的转换,GIL并没有进行位移操作,因为那样不能在最值之
间正确转换,而是乘以257).</p>
<p>GIL所有的通道类型都可以从整型到浮点型进行转换,所以它们支持算数运算,下面是GIL提供的通道级别的算法:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 从源通道值转换为目标通道值,在范围之内进行线性映射</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DstChannel, <span class="keyword">typename</span> SrcChannel&gt;<br /><span class="keyword">typename</span> channel_traits&lt;DstChannel&gt;::value_type <a class="code" href="../../../../../boost_doc_40/libs/gil/doc/html/g_i_l_0099.html#gf04e6ac30a35a1f68a8bb84730e34786" title="Converting from one channel type to another.">channel_convert</a>(SrcChannel src);<br /><br /><span class="comment">// 返回最大值 - x + min_value</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel&gt;<br /><span class="keyword">typename</span> channel_traits&lt;Channel&gt;::value_type <a class="code" href="../../../../../boost_doc_40/libs/gil/doc/html/g_i_l_0101.html#ge2e0267865f89610ef26148874a04bb5" title="Default implementation. Provide overloads for performance.">channel_invert</a>(Channel x);<br /><br /><span class="comment">// 返回 a * b / max_value</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel&gt;<br /><span class="keyword">typename</span> channel_traits&lt;Channel&gt;::value_type <a class="code" href="../../../../../boost_doc_40/libs/gil/doc/html/g_i_l_0103.html#gf73b2a47a7877767534df0eee46dda17" title="A function multiplying two channels. result = a * b / max_value.">channel_multiply</a>(Channel a, Channel b);<br /></pre>
</div>
<p></p>
<hr />
<h2><a class="anchor" name="ColorSpaceSectionDG">5.
颜色空间和布局</a></h2>
颜色空间描述了组成像素的颜色通道的解释和集合, 它是一个MPL随机访问的容器, 包含了这个空间内所有要素类型.
两个颜色空间是相等的(例如,在相同的次序下是相同的颜色集),那么就认为它们是兼容的.
<p><b>关联概念:</b></p>
<p></p>
<ul>
<li>ColorSpaceConcept&lt;ColorSpace&gt;</li>
<li>ColorSpacesCompatibleConcept&lt;ColorSpace1,ColorSpace2&gt;</li>
<li>ChannelMappingConcept&lt;Mapping&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>当前的GIL支持如下的颜色空间: <code>gray_t</code>, <code>rgb_t</code>,
<code>rgba_t</code>, 和 <code>cmyk_t</code>.
GIL还支持未命名的2到5个通道的颜色空间, <code>devicen_t&lt;2&gt;</code>,
<code>devicen_t&lt;3&gt;</code>, <code>devicen_t&lt;4&gt;</code>,
<code>devicen_t&lt;5&gt;</code>.
除了这些标准的空间布局,GIL还支持 <code>bgr_layout_t</code>, <code>bgra_layout_t</code>,
<code>abgr_layout_t</code> 和 <code>argb_layout_t</code>.</p>
<p>作为一个例子,下面的代码说明了GIL如何定义RGBA 颜色空间:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">struct </span>red_t{};<br /><span class="keyword">struct </span>green_t{};<br /><span class="keyword">struct </span>blue_t{};<br /><span class="keyword">struct </span>alpha_t{};<br /><span class="keyword">typedef</span> mpl::vector4&lt;red_t,green_t,blue_t,alpha_t&gt; rgba_t;<br /></pre>
</div>
<p>颜色空间内颜色通道的次序表明了它们的语义次序. 例如<code>red_t</code>
就是 <code>rgba_t</code>的第一个语义通道.虽然颜色空间的通道有一个唯一的语义次序,
但是它们的物理存储次序可以不同. 颜色通道的次序通过 <code>ChannelMappingConcept</code>
指定, 它是一个MPL整型随机访问容器. 颜色空间和位置映射经常一起使用, 因此GIL把它们组合在一起:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorSpace, <br /> <span class="keyword">typename</span> ChannelMapping = mpl::range_c&lt;int,0,mpl::size&lt;ColorSpace&gt;::value&gt; &gt;<br /><span class="keyword">struct </span>layout {<br /> <span class="keyword">typedef</span> ColorSpace color_space_t;<br /> <span class="keyword">typedef</span> ChannelMapping channel_mapping_t;<br />};<br /></pre>
</div>
<p>下面的代码说明了如何创建 RGBA 的颜色空间:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">typedef</span> layout&lt;rgba_t&gt; rgba_layout_t; <span class="comment">// 默认的次序是 0,1,2,3...</span><br /><span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,2,1,0,3&gt; &gt; bgra_layout_t;<br /><span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,1,2,3,0&gt; &gt; argb_layout_t;<br /><span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,3,2,1,0&gt; &gt; abgr_layout_t;<br /></pre>
</div>
<p></p>
<hr />
<h2><a class="anchor" name="ColorBaseSectionDG">6.
颜色基</a></h2>
颜色基是颜色元素的容器. 颜色基最通常的使用场景是作为像素的实现, 这样颜色基的元素就是颜色通道的值.
但是颜色基的概念还可以使用在其他的场景中. 例如, plannar 像素的颜色通道不是连续存储的, 它的引用是通过代理类实现的,
其元素类型是通道引用. planar像素迭代器也是使用颜色基实现的, 其元素类型是通道迭代器.
<p>颜色基必须满足下列概念的要求:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept ColorBaseConcept&lt;typename T&gt; : CopyConstructible&lt;T&gt;, EqualityComparable&lt;T&gt; {<br /> <span class="comment">// GIL 布局 (颜色空间和元素排列)</span><br /><span class="keyword">typename</span> layout_t;<br /> <br /> <span class="comment">// K-个元素的类型</span><br /><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_type;<br /> where Metafunction&lt;kth_element_type&gt;;<br /> <br /> <span class="comment">// at_c的结果类型</span><br /><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_const_reference_type;<br /> where Metafunction&lt;kth_element_const_reference_type&gt;; <br /> <br /> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; kth_element_const_reference_type&lt;T,K&gt;::type at_c(T);<br /> <br /> <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } <br /> T::T(T2);<br /> <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } <br /> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T2&amp;);<br /> <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } <br /> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T2&amp;);<br /><br />};<br /><br />concept MutableColorBaseConcept&lt;ColorBaseConcept T&gt; : Assignable&lt;T&gt;, Swappable&lt;T&gt; {<br /> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_reference_type;<br /> where Metafunction&lt;kth_element_reference_type&gt;;<br /><br /> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; kth_element_reference_type&lt;T,K&gt;::type at_c(T);<br /> <br /> <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } <br /> T&amp; operator=(T&amp;, <span class="keyword">const</span> T2&amp;);<br />};<br /><br />concept ColorBaseValueConcept&lt;typename T&gt; : MutableColorBaseConcept&lt;T&gt;, Regular&lt;T&gt; {<br />};<br /><br />concept HomogeneousColorBaseConcept&lt;ColorBaseConcept CB&gt; {<br /> <span class="comment">// 对于所有的在区间[0 ... size&lt;C1&gt;::value-1)中的K:</span><br /><span class="comment">// 满足 SameType&lt;kth_element_type&lt;K&gt;::type, kth_element_type&lt;K+1&gt;::type&gt;; </span><br />kth_element_const_reference_type&lt;0&gt;::type dynamic_at_c(<span class="keyword">const</span> CB&amp;, std::size_t n) <span class="keyword">const</span>;<br />};<br /><br />concept MutableHomogeneousColorBaseConcept&lt;MutableColorBaseConcept CB&gt; : HomogeneousColorBaseConcept&lt;CB&gt; {<br /> kth_element_reference_type&lt;0&gt;::type dynamic_at_c(<span class="keyword">const</span> CB&amp;, std::size_t n);<br />};<br /><br />concept HomogeneousColorBaseValueConcept&lt;typename T&gt; : MutableHomogeneousColorBaseConcept&lt;T&gt;, Regular&lt;T&gt; {<br />};<br /><br />concept ColorBasesCompatibleConcept&lt;ColorBaseConcept C1, ColorBaseConcept C2&gt; {<br /> where SameType&lt;C1::layout_t::color_space_t, C2::layout_t::color_space_t&gt;;<br /> <span class="comment">// 同样, 对于在区间[0 ... size&lt;C1&gt;::value)的所有K:</span><br /><span class="comment">// 是可转换的 Convertible&lt;kth_semantic_element_type&lt;C1,K&gt;::type, kth_semantic_element_type&lt;C2,K&gt;::type&gt;;</span><br /><span class="comment">// 也是可转换的 Convertible&lt;kth_semantic_element_type&lt;C2,K&gt;::type, kth_semantic_element_type&lt;C1,K&gt;::type&gt;;</span><br />};<br /></pre>
</div>
<p>颜色基必须具有相关的颜色布局类型(包括颜色空间和颜色通道的次序). 有两种方法对颜色基的要素进行索引访问:
一种是通过对存储位置上的物理索引值,一种是通过要素在颜色空间上的语义索引值. 例如, RGB 颜色空间的的次序是{red_t,
green_t, blue_t}. 而对于 BGR 的颜色布局, 其物理排序的第一个索引值绿色, 而第一个语义要素是红色. 概念 <code>ColorBaseConcept</code>
的模型必须提供函数 <code>at_c&lt;K&gt;(ColorBase)</code>
,允许按照物理次序访问要素. GIL 还提供了函数 <code>semantic_at_c&lt;K&gt;(ColorBase)</code>
(以后再描述) 对 ColorBaseConcept 的模型进行操作,返回相关的语义要素.</p>
<p>如果两种颜色基的颜色空间是相等的, 并且其要素类型是可以转换的,那么它们就是兼容的.</p>
<p><b>Models:</b></p>
<p>GIL 提供了同质颜色基概念(它们的要素类型都是相同的)的模型.</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">namespace </span>detail {<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> Layout, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>homogeneous_color_base;<br />}<br /></pre>
</div>
<p>GIL像素, planar像素引用和planer像素迭代器都是使用颜色基概念实现的. <code>ColorBaseConcept</code>
的另外一个模型是<code>packed_pixel</code> - 它的像素通道是位域, 参见 <a class="el" href="gildesignguide.html#PixelSectionDG">7.
像素</a> .</p>
<p><b>算法:</b></p>
<p>GIL 为颜色基提供了以下的函数和元函数:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 以 mpl::int_形式返回颜色基元素个数的元函数</span><br /><span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase&gt; <span class="keyword">struct </span>size;<br /><br /><span class="comment">// 函数 semantic_at_c&lt;K&gt;(color_base)的返回类型</span><br /><span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_semantic_element_reference_type;<br /><span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_semantic_element_const_reference_type;<br /><br /><span class="comment">// 得到元素第 K 个语义索引的引用.</span><br /><span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <br /><span class="keyword">typename</span> kth_semantic_element_reference_type&lt;ColorBase,K&gt;::type <a class="code" title="A mutable accessor to the K-th semantic element of a color base." href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de">semantic_at_c</a>(ColorBase&amp; p) <br /><span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <br /><span class="keyword">typename</span> kth_semantic_element_const_reference_type&lt;ColorBase,K&gt;::type <a class="code" title="A mutable accessor to the K-th semantic element of a color base." href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de">semantic_at_c</a>(<span class="keyword">const</span> ColorBase&amp; p) <br /><br /><span class="comment">// 得到get_color&lt;Color&gt;(color_base)返回值的类型</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Color, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>color_reference_t;<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Color, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>color_const_reference_t;<br /><br /><span class="comment">// 返回指定颜色的元素索引</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; <br /><span class="keyword">typename</span> color_reference_t&lt;Color,ColorBase&gt;::type <a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(ColorBase&amp; cb, Color=Color());<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; <br /><span class="keyword">typename</span> color_const_reference_t&lt;Color,ColorBase&gt;::type <a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(<span class="keyword">const</span> ColorBase&amp; cb, Color=Color());<br /><br /><span class="comment">// 颜色基的元素类型,只为同质的颜色基定义</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_type;<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_reference_type;<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_const_reference_type;<br /></pre>
</div>
<p>GIL 还提供了操作颜色基的下列函数,注意它们都是语义成对排列:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 对应于标准库的 std::equal, std::copy, std::fill, std::generate</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2&gt; <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> CB1&amp; p1, <span class="keyword">const</span> CB2&amp; p2);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Src,<span class="keyword">typename</span> Dst&gt; <span class="keywordtype">void</span> static_copy(<span class="keyword">const</span> Src&amp; src, Dst&amp; dst);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB, <span class="keyword">typename</span> Op&gt; <span class="keywordtype">void</span> static_generate(CB&amp; dst,Op op);<br /><br /><span class="comment">// 对应于标准库的 std::transform</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB , <span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform( CB&amp;,Dst&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB , <span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB&amp;,Dst&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform( CB1&amp;, CB2&amp;,Dst&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB1&amp;, CB2&amp;,Dst&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform( CB1&amp;,<span class="keyword">const</span> CB2&amp;,Dst&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,Dst&amp;,Op); <br /><br /><span class="comment">// 对应于标准库的 std::for_each</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1, <span class="keyword">typename</span> Op&gt; Op static_for_each( CB1&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1, <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2, <span class="keyword">typename</span> Op&gt; Op static_for_each( CB1&amp;, CB2&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2, <span class="keyword">typename</span> Op&gt; Op static_for_each( CB1&amp;,<span class="keyword">const</span> CB2&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2, <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;, CB2&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2, <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each( CB1&amp;, CB2&amp;, CB3&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each( CB1&amp;, CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each( CB1&amp;,<span class="keyword">const</span> CB2&amp;, CB3&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each( CB1&amp;,<span class="keyword">const</span> CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;, CB2&amp;, CB3&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;, CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;, CB3&amp;,Op); <br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); <br /><br /><span class="comment">// 下列函数只是适用于同质的颜色基:</span><br /><span class="comment">// 对应于标准库的 std::fill</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB, <span class="keyword">typename</span> Element&gt; <span class="keywordtype">void</span> static_fill(HCB&amp; p, <span class="keyword">const</span> Element&amp; v);<br /><br /><span class="comment">// 对应于标准库的 std::min_element 和 std::max_element</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_const_reference_type&lt;HCB&gt;::type static_min(<span class="keyword">const</span> HCB&amp;);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_reference_type&lt;HCB&gt;::type static_min( HCB&amp;);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_const_reference_type&lt;HCB&gt;::type static_max(<span class="keyword">const</span> HCB&amp;);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_reference_type&lt;HCB&gt;::type static_max( HCB&amp;);<br /></pre>
</div>
<p>这些算法是仿照STL定义的, 但是它们不是以迭代器区间为参数,而是以颜色基和要素为参数.
另外这些算法通过编译器递归实现的(因此以"static_"为前缀). 最后,这些算法访问要素是以语义索引而不是物理索引. 例如, 下面是<code>static_equal:</code>
的一个实现 </p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">namespace </span>detail {<br /><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>element_recursion {<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;<br /> <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) { <br /> <span class="keywordflow">return</span> element_recursion&lt;K-1&gt;::static_equal(p1,p2) &amp;&amp;<br /> <a class="code" title="A mutable accessor to the K-th semantic element of a color base." href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de">semantic_at_c</a>&lt;K-1&gt;(p1)==semantic_at_c&lt;N-1&gt;(p2); <br /> }<br />};<br /><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>element_recursion&lt;0&gt; {<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;<br /> <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp;, <span class="keyword">const</span> P2&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }<br />};<br />}<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;<br /><span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) {<br /> gil_function_requires&lt;ColorSpacesCompatibleConcept&lt;P1::layout_t::color_space_t,P2::layout_t::color_space_t&gt; &gt;(); <br /> <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_equal(p1,p2); <br />} <br /></pre>
</div>
<p>在两个像素上调用操作符 <code>operator==</code>
的时候会使用这个算法. 使用语义索引会正确的比较RGB和BGR像素. 注意到如果算法有两个或者以上的颜色基参数,那么它们必须属于相同的颜色空间.</p>
<p></p>
<hr />
<h2><a class="anchor" name="PixelSectionDG">7.
像素</a></h2>
一个像素就是在图像指定点的颜色通道集合. 从概念上说,因为像素的元素类型是<code>ChannelConcept</code>的
模型,所以像素必然是颜色基的强化类型. 像素的所有属性都继承自颜色基: 如果所有的通道类型一致,那么像素就是同质的;否则是异质的.
像素的通道值可以通过语义值和物理值索引,或者通过颜色索引. 所有颜色基的算法都适用于像素.
如果像素的颜色空间相同,并且颜色通道语义上兼容,那么两个像素类型也被认为是兼容的. 注意到常量性, 内存组织以及引用/值等特点是被有意忽略的.
例如,一个8位planar的RGB引用和一个常量interleaved的BGR像素值在型别上是兼容的.
绝大多数的成对像素见操作(copy构造,赋值,相等性等等)只在兼容的类型之间有效.
<p>像素
(还有其他基于像素的GIL构造,例如迭代器,定位器,视图和图像)必须提供相关的元函数访问其颜色空间,通道映射,通道个数以及通道(同质的通道)类型
:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept PixelBasedConcept&lt;typename T&gt; {<br /> <span class="keyword">typename</span> color_space_type&lt;T&gt;; <br /> where Metafunction&lt;color_space_type&lt;T&gt; &gt;;<br /> where ColorSpaceConcept&lt;color_space_type&lt;T&gt;::type&gt;;<br /> <span class="keyword">typename</span> channel_mapping_type&lt;T&gt;; <br /> where Metafunction&lt;channel_mapping_type&lt;T&gt; &gt;; <br /> where ChannelMappingConcept&lt;channel_mapping_type&lt;T&gt;::type&gt;;<br /> <span class="keyword">typename</span> is_planar&lt;T&gt;;<br /> where Metafunction&lt;is_planar&lt;T&gt; &gt;;<br /> where SameType&lt;is_planar&lt;T&gt;::type, <span class="keywordtype">bool</span>&gt;;<br />};<br /><br />concept HomogeneousPixelBasedConcept&lt;PixelBasedConcept T&gt; {<br /> <span class="keyword">typename</span> channel_type&lt;T&gt;; <br /> where Metafunction&lt;channel_type&lt;T&gt; &gt;;<br /> where ChannelConcept&lt;channel_type&lt;T&gt;::type&gt;;<br />};<br /></pre>
</div>
<p>像素是下列概念的模型:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept PixelConcept&lt;typename P&gt; : ColorBaseConcept&lt;P&gt;, PixelBasedConcept&lt;P&gt; { <br /> where is_pixel&lt;P&gt;::type::value==<span class="keyword">true</span>;<br /> <span class="comment">// 对于每个 K [0..size&lt;P&gt;::value-1]:</span><br /><span class="comment">// 满足ChannelConcept&lt;kth_element_type&lt;K&gt; &gt;;</span><br /><span class="keyword">typename</span> value_type; where PixelValueConcept&lt;value_type&gt;;<br /> <span class="keyword">typename</span> reference; where PixelConcept&lt;reference&gt;;<br /> <span class="keyword">typename</span> const_reference; where PixelConcept&lt;const_reference&gt;;<br /> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> P::is_mutable;<br /><br /> <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } <br /> P::P(P2);<br /> <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } <br /> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> P&amp;, <span class="keyword">const</span> P2&amp;);<br /> <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } <br /> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> P&amp;, <span class="keyword">const</span> P2&amp;);<br />}; <br /><br />concept MutablePixelConcept&lt;typename P&gt; : PixelConcept&lt;P&gt;, MutableColorBaseConcept&lt;P&gt; {<br /> where is_mutable==<span class="keyword">true</span>;<br />};<br /><br />concept HomogeneousPixelConcept&lt;PixelConcept P&gt; : HomogeneousColorBaseConcept&lt;P&gt;, HomogeneousPixelBasedConcept&lt;P&gt; { <br /> P::template element_const_reference_type&lt;P&gt;::type operator[](P p, std::size_t i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dynamic_at_c(P,i); }<br />};<br /><br />concept MutableHomogeneousPixelConcept&lt;MutablePixelConcept P&gt; : MutableHomogeneousColorBaseConcept&lt;P&gt; { <br /> P::template element_reference_type&lt;P&gt;::type operator[](P p, std::size_t i) { <span class="keywordflow">return</span> dynamic_at_c(p,i); }<br />};<br /><br />concept PixelValueConcept&lt;typename P&gt; : PixelConcept&lt;P&gt;, Regular&lt;P&gt; {<br /> where SameType&lt;value_type,P&gt;;<br />}; <br /><br />concept PixelsCompatibleConcept&lt;PixelConcept P1, PixelConcept P2&gt; : ColorBasesCompatibleConcept&lt;P1,P2&gt; {<br /> <span class="comment">// 对于每个 K [0..size&lt;P1&gt;::value):</span><br /><span class="comment">// 满足 ChannelsCompatibleConcept&lt;kth_semantic_element_type&lt;P1,K&gt;::type, kth_semantic_element_type&lt;P2,K&gt;::type&gt;;</span><br />};<br /></pre>
</div>
<p>如果一个像素可以使用另外一个像素的颜色空间来近似表示,那么两个像素之间就是可转换的.
转换是显式的,非对称的并且属于有损操作(这是由于颜色空间和颜色通道的近似模拟造成的). 转换是下面概念的模型:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;PixelConcept SrcPixel, MutablePixelConcept DstPixel&gt;<br />concept PixelConvertibleConcept {<br /> <span class="keywordtype">void</span> <a class="code" title="helper function for converting one pixel to another using GIL default color-converters..." href="g_i_l_0178.html#gaa258d34eafbf9d9e34a2a2ad6131af2">color_convert</a>(<span class="keyword">const</span> SrcPixel&amp;, DstPixel&amp;);<br />};<br /></pre>
</div>
<p>概念 <code>PixelConcept</code> 和 <code>PixelValueConcept</code>
之间的区别和通道和颜色基的是一样的-像素引用代理是二者的模型, 而只有像素值是后者的模型.</p>
<p><b>相关概念:</b></p>
<p></p>
<ul>
<li>PixelBasedConcept&lt;P&gt;</li>
<li>PixelConcept&lt;Pixel&gt;</li>
<li>MutablePixelConcept&lt;Pixel&gt;</li>
<li>PixelValueConcept&lt;Pixel&gt;</li>
<li>HomogeneousPixelConcept&lt;Pixel&gt;</li>
<li>MutableHomogeneousPixelConcept&lt;Pixel&gt;</li>
<li>HomogeneousPixelValueConcept&lt;Pixel&gt;</li>
<li>PixelsCompatibleConcept&lt;Pixel1,Pixel2&gt;</li>
<li>PixelConvertibleConcept&lt;SrcPixel,DstPixel&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>最常用的像素是同质像素, 其值连续存储在一起. 为了这个目的, GIL提供了结构 <code>pixel</code>,
以通道值和布局为参数:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 是 HomogeneousPixelValueConcept的模型</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout&gt; <span class="keyword">struct </span>pixel;<br /><br /><span class="comment">// GIL提供的 typedefs </span><br /><span class="keyword">typedef</span> pixel&lt;bits8, rgb_layout_t&gt; rgb8_pixel_t;<br /><span class="keyword">typedef</span> pixel&lt;bits8, bgr_layout_t&gt; bgr8_pixel_t;<br /><br />bgr8_pixel_t bgr8(255,0,0); <span class="comment">// 可以直接通过通道值初始化</span><br />rgb8_pixel_t rgb8(bgr8); <span class="comment">// 兼容像素之间可以相互拷贝构造</span><br />rgb8 = bgr8; <span class="comment">// 兼容像素之间可以相互赋值和进行相等性比较</span><br />assert(rgb8 == bgr8); <span class="comment">// 按照语义通道赋值和比较</span><br /><span class="comment">// 两个像素之间的物理通道值是不同的</span><br />assert(at_c&lt;0&gt;(rgb8) != at_c&lt;0&gt;(bgr8));<br />assert(dynamic_at_c(bgr8,0) != dynamic_at_c(rgb8,0));<br />assert(rgb8[0] != bgr8[0]); <span class="comment">// 同上 ( 只是为像素定义了operator[])</span>
</pre>
</div>
<p>planar 像素的通道值分布存储. 它们共享同样的值类型 (<code>pixel</code>)
, 它们的引用类型是一个代理类, 包含指向每个通道的引用. 下面是结构 <code>planar_pixel_reference:</code>的
实现 </p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 是 HomogeneousPixel的模型</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelReference, <span class="keyword">typename</span> ColorSpace&gt; <span class="keyword">struct </span>planar_pixel_reference;<br /><br /><span class="comment">// 定义可变和只读引用. (GIL已经提供了这些 typedefs )</span><br /><span class="keyword">typedef</span> planar_pixel_reference&lt; bits8&amp;,rgb_t&gt; rgb8_planar_ref_t;<br /><span class="keyword">typedef</span> planar_pixel_reference&lt;const bits8&amp;,rgb_t&gt; rgb8c_planar_ref_t;<br /></pre>
</div>
<p>注意到, 和结构 <code>pixel</code> 不一样, planar
像素引用是以颜色空间,而不是以像素布局为参数的. 它们总是具有一致的通道次序. 它们内部的元素次序没有必要,因为它们是指向通道的引用.</p>
<p>有时候像素的通道不是字节对齐的. 例如'5-5-6' 模式的RGB像素是16位的,其 red, green 和
blue 通道分别占据[0..4],[5..9] 和 [10..15].GIL 提供了这种紧凑的像素格式的定义:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 定义 rgb565 像素类型</span><br /><span class="keyword">typedef</span> packed_pixel_type&lt;uint16_t, mpl::vector3_c&lt;unsigned,5,6,5&gt;, rgb_layout_t&gt;::type rgb565_pixel_t;<br /><br />function_requires&lt;PixelValueConcept&lt;rgb565_pixel_t&gt; &gt;();<br />BOOST_STATIC_ASSERT((<span class="keyword">sizeof</span>(rgb565_pixel_t)==2));<br /><br /><span class="comment">// 定义bgr556 像素类型</span><br /><span class="keyword">typedef</span> packed_pixel_type&lt;uint16_t, mpl::vector3_c&lt;unsigned,5,6,5&gt;, bgr_layout_t&gt;::type bgr556_pixel_t;<br /><br />function_requires&lt;PixelValueConcept&lt;bgr556_pixel_t&gt; &gt;();<br /><br /><span class="comment">// rgb565 和 bgr556是兼容的.</span><br />function_requires&lt;PixelsCompatibleConcept&lt;rgb565_pixel_t,bgr556_pixel_t&gt; &gt;();<br /></pre>
</div>
<p>有时候,像素自身不是字节对齐的. 例如, 考虑格式为RGB '2-3-2' 模式的像素, 其位长为7. GIL
使用'位对齐'的模式引用这种类型的像素,像素迭代器和图像. 位对齐的像素(还有图像)要比紧凑的格式复杂很多. 因为紧凑格式的像素是字节对齐的,
我们以C++引用类型的方式使用一个紧凑格式的像素, 并以C式指针作为x_iterator遍历一行紧凑格式的像素.
对于位对齐格式,我们需要一个特殊类型的引用代理类(bit_aligned_pixel_reference)和一个特殊类型的迭代器类
(bit_aligned_pixel_iterator). 位对齐格式的像素值类型是packed_pixel.
下面说明如何使用位对齐的像素和像素迭代器:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 可变的 BGR232 像素引用类型 </span><br /><span class="keyword">typedef</span> <span class="keyword">const</span> bit_aligned_pixel_reference&lt;unsigned char, mpl::vector3_c&lt;unsigned,2,3,2&gt;, bgr_layout_t, <span class="keyword">true</span>&gt; bgr232_ref_t;<br /><br /><span class="comment">// 可变的 BGR232 像素迭代器</span><br /><span class="keyword">typedef</span> bit_aligned_pixel_iterator&lt;bgr232_ref_t&gt; bgr232_ptr_t;<br /><br /><span class="comment">// BGR232 像素值类型. 它是一个1个字节 packed_pixel . (最后一位没有使用)</span><br /><span class="keyword">typedef</span> std::iterator_traits&lt;bgr232_ptr_t&gt;::value_type bgr232_pixel_t; <br />BOOST_STATIC_ASSERT((<span class="keyword">sizeof</span>(bgr232_pixel_t)==1));<br /><br />bgr232_pixel_t red(0,0,3); <span class="comment">// = 0RRGGGBB, = 01100000 = 0x60</span><br /><span class="comment">// 7字节的缓冲区恰好容纳8个 BGR232 类型的像素 .</span><br /><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pix_buffer[7]; <br /><a class="code" title="std::fill(I,I,V) with I being a iterator_from_2d" href="g_i_l_0214.html#g718772a47188f4e2ecfce2f28fa3dc4f">std::fill</a>(pix_buffer,pix_buffer+7,0);<br /><br /><span class="comment">// 使用红色填充8个像素</span><br />bgr232_ptr_t pix_it(&amp;pix_buffer[0],0); <span class="comment">// 从第一个像素的0位开始</span><br /><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8; ++i) {<br /> *pix_it++ = red;<br />}<br /><span class="comment">// 结果是: 0x60 0x30 0x11 0x0C 0x06 0x83 0xC1</span>
</pre>
</div>
<p><b>算法:</b></p>
<p>既然像素是 <code>ColorBaseConcept</code> 和 <code>PixelBasedConcept</code>
的模型,所有适用于这两个概念的算法也都适用于像素:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 如何访问第一个语义通道(红色)</span><br />assert(semantic_at_c&lt;0&gt;(rgb8) == semantic_at_c&lt;0&gt;(bgr8));<br /><span class="comment">// 如何通过名字访问红色通道</span><br />assert(get_color&lt;red_t&gt;(rgb8) == get_color&lt;red_t&gt;(bgr8));<br /><span class="comment">// 另外一种实现方式(有些编译器不喜欢第一种方式)</span><br />assert(<a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(rgb8,red_t()) == <a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(bgr8,red_t()));<br /><br /><span class="comment">// 如何使用元函数 PixelBasedConcept </span><br />BOOST_MPL_ASSERT(num_channels&lt;rgb8_pixel_t&gt;::value == 3);<br />BOOST_MPL_ASSERT((is_same&lt;channel_type&lt;rgb8_pixel_t&gt;::type, bits8&gt;));<br />BOOST_MPL_ASSERT((is_same&lt;color_space_type&lt;bgr8_pixel_t&gt;::type, rgb_t&gt; ));<br />BOOST_MPL_ASSERT((is_same&lt;channel_mapping_type&lt;bgr8_pixel_t&gt;::type, mpl::vector3_c&lt;int,2,1,0&gt; &gt; ));<br /><span class="comment">// 像素只是包含3个通道,别的就没了 </span><br />BOOST_MPL_ASSERT(<span class="keyword">sizeof</span>(rgb8_pixel_t)==3);<br /><br />rgb8_planar_ref_t ref(bgr8); <span class="comment">// 兼容可变的像素类型之间是可以copy构造的 </span><br />get_color&lt;red_t&gt;(ref) = 10; <span class="comment">// 可变的引用是可以赋值的</span><br />assert(get_color&lt;red_t&gt;(bgr8)==10); <span class="comment">// 通过引用改变了绑定的值 </span><br /><span class="comment">// 创建一个0冗余的 packed 像素和一个完全正规的 unpacked 像素.</span><br />rgb565_pixel_t r565;<br />rgb8_pixel_t rgb_full(255,255,255);<br /><span class="comment">// 把unpacked像素的所有通道转换为packed形式, 并且断言packed像素的数值</span><br /><a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(r565,red_t()) = channel_convert&lt;rgb565_channel0_t&gt;(<a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(rgb_full,red_t()));<br /><a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(r565,green_t()) = channel_convert&lt;rgb565_channel1_t&gt;(<a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(rgb_full,green_t()));<br /><a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(r565,blue_t()) = channel_convert&lt;rgb565_channel2_t&gt;(<a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(rgb_full,blue_t()));<br />assert(r565 == rgb565_pixel_t((uint16_t)65535)); <br /></pre>
</div>
<p>GIL 还提供了 <code>color_convert</code> 算法,
用于不同颜色空间和通道类型之间的像素转换:</p>
<p></p>
<div class="fragment">
<pre class="fragment">rgb8_pixel_t red_in_rgb8(255,0,0);<br />cmyk16_pixel_t red_in_cmyk16;<br /><a class="code" title="helper function for converting one pixel to another using GIL default color-converters..." href="g_i_l_0178.html#gaa258d34eafbf9d9e34a2a2ad6131af2">color_convert</a>(red_in_rgb8,red_in_cmyk16);<br /></pre>
</div>
<p></p>
<hr />
<h2><a class="anchor" name="PixelIteratorSectionDG">8. 像素迭代器 </a></h2>
<h2><a class="anchor" name="FundamentalIteratorDG">
基本迭代器 </a></h2>
像素迭代器是随机访问迭代器, 它的 <code>value_type</code> 是<code>PixelValueConcept</code>的
模型. 像素迭代器提供了元函数访问其可变性(例如, 是否允许修改像素的值), 得到只读像素的类型, 以及它们是普通迭代器还是迭代器适配器:
<p></p>
<div class="fragment">
<pre class="fragment">concept PixelIteratorConcept&lt;RandomAccessTraversalIteratorConcept Iterator&gt; : PixelBasedConcept&lt;Iterator&gt; {<br /> where PixelValueConcept&lt;value_type&gt;;<br /> <span class="keyword">typename</span> const_iterator_type&lt;It&gt;::type; <br /> where PixelIteratorConcept&lt;const_iterator_type&lt;It&gt;::type&gt;;<br /> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> iterator_is_mutable&lt;It&gt;::type::value; <br /> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_iterator_adaptor&lt;It&gt;::type::value; <span class="comment">// 是否是适配器</span><br />};<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;<br />concept MutablePixelIteratorConcept : PixelIteratorConcept&lt;Iterator&gt;, MutableRandomAccessIteratorConcept&lt;Iterator&gt; {};<br /></pre>
</div>
<p><b>相关概念 :</b></p>
<p></p>
<ul>
<li>PixelIteratorConcept&lt;Iterator&gt;</li>
<li>MutablePixelIteratorConcept&lt;Iterator&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>GIL通过内建的像素指针 <code>pixel&lt;ChannelValue,Layout&gt;*</code>表
示interleaved 同质像素迭代器的模型; 同样, 通过<code>packed_pixel&lt;PixelData,ChannelRefVec,Layout&gt;*</code>
表示interleaved packed 像素的模型.</p>
<p>GIL通过类<code>planar_pixel_iterator</code>实现
planar 同质像素,其通道迭代器和颜色空间都是模板参数. 下面是使用unsigned
char定义可变的和只读的planar类型的RGB迭代器:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelPtr, <span class="keyword">typename</span> ColorSpace&gt; <span class="keyword">struct </span>planar_pixel_iterator;<br /><br /><span class="comment">// GIL 提供的 typedefs</span><br /><span class="keyword">typedef</span> planar_pixel_iterator&lt;const bits8*, rgb_t&gt; rgb8c_planar_ptr_t;<br /><span class="keyword">typedef</span> planar_pixel_iterator&lt; bits8*, rgb_t&gt; rgb8_planar_ptr_t;<br /></pre>
</div>
<p>因为<code>planar_pixel_iterator</code> 是 <code>HomogeneousColorBaseConcept</code>的
模型 (是 <code>homogeneous_color_base</code>的子类型) ,
所以基于颜色基的算法都适用于它.它的颜色基元素类型是通道迭代器. 例如, GIL实现planar迭代器的方式大体如下:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<br /><span class="keyword">struct </span>inc : <span class="keyword">public</span> std::unary_function&lt;T,T&gt; {<br /> T operator()(T x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ++x; }<br />};<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelPtr, <span class="keyword">typename</span> ColorSpace&gt;<br />planar_pixel_iterator&lt;ChannelPtr,ColorSpace&gt;&amp; <br />planar_pixel_iterator&lt;ChannelPtr,ColorSpace&gt;::operator++() {<br /> static_transform(*<span class="keyword">this</span>,*<span class="keyword">this</span>,inc&lt;ChannelPtr&gt;());<br /> <span class="keywordflow">return</span> *<span class="keyword">this</span>;<br />}<br /></pre>
</div>
<p>因为函数<code>static_transform</code>是编译期递归,所以<code>rgb8_planar_ptr_t</code>
的累加操作就是3次指针累加. GIL还通过类型 bit_aligned_pixel_iterator 支持位对齐像素迭代.
在内部它维护着当前的字节和位偏移 .</p>
<h2><a class="anchor" name="IteratorAdaptorDG">像
素适配器</a></h2>
迭代器适配器就是像素的包裹器. 像素适配器的<code>is_iterator_adaptor</code>
必定为真, 它也必须提供成员函数访问其基础迭代器, 类型以及绑定到其他迭代器的元函数:
<p></p>
<div class="fragment">
<pre class="fragment">concept IteratorAdaptorConcept&lt;RandomAccessTraversalIteratorConcept Iterator&gt; {<br /> where SameType&lt;is_iterator_adaptor&lt;Iterator&gt;::type, mpl::true_&gt;;<br /><br /> <span class="keyword">typename</span> iterator_adaptor_get_base&lt;Iterator&gt;;<br /> where Metafunction&lt;iterator_adaptor_get_base&lt;Iterator&gt; &gt;;<br /> where boost_concepts::ForwardTraversalConcept&lt;iterator_adaptor_get_base&lt;Iterator&gt;::type&gt;;<br /> <br /> <span class="keyword">typename</span> another_iterator; <br /> <span class="keyword">typename</span> iterator_adaptor_rebind&lt;Iterator,another_iterator&gt;::type;<br /> where boost_concepts::ForwardTraversalConcept&lt;another_iterator&gt;;<br /> where IteratorAdaptorConcept&lt;iterator_adaptor_rebind&lt;Iterator,another_iterator&gt;::type&gt;;<br /><br /> <span class="keyword">const</span> iterator_adaptor_get_base&lt;Iterator&gt;::type&amp; Iterator::base() <span class="keyword">const</span>;<br />};<br /><br /><span class="keyword">template</span> &lt;boost_concepts::Mutable_ForwardIteratorConcept Iterator&gt;<br />concept MutableIteratorAdaptorConcept : IteratorAdaptorConcept&lt;Iterator&gt; {};<br /></pre>
</div>
<p><b>相关概念 :</b></p>
<p></p>
<ul>
<li>IteratorAdaptorConcept&lt;Iterator&gt;</li>
<li>MutableIteratorAdaptorConcept&lt;Iterator&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>GIL 提供了几个 IteratorAdaptorConcept的模型:</p>
<ul>
<li><code>memory_based_step_iterator&lt;Iterator&gt;</code>:
改变基础迭代器步长的迭代器 (参见 <a class="el" href="gildesignguide.html#StepIteratorDG">Step Iterator</a>)</li>
<li><code>dereference_iterator_adaptor&lt;Iterator</code>,Fn&gt;:
通过一元函数<code>Fn</code> 解引用的适配器. 可以用来做临时的颜色转换,
也可用作表面上具有不同的颜色空间和通道深度的浅层图像"视图". 更多的信息参见 <a class="el" href="gildesignguide.html#ImageViewFrowImageViewDG">Creating
Image Views from Other Image Views</a> . 一元函数 <code>Fn</code>
必须是 <code>PixelDereferenceAdaptorConcept</code>的模型 (见下).</li>
</ul>
<h2><a class="anchor" name="PixelDereferenceAdaptorAG">
像素解引用适配器 </a></h2>
像素解引用适配器是一个一元函数,可以对一个像素迭代器解引用. 它的参数类型是任意的(经常是<code>PixelConcept</code>),
但是其结果类型必须是<code>PixelConcept</code>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;boost::UnaryFunctionConcept D&gt;<br />concept PixelDereferenceAdaptorConcept : DefaultConstructibleConcept&lt;D&gt;, CopyConstructibleConcept&lt;D&gt;, AssignableConcept&lt;D&gt; {<br /> <span class="keyword">typename</span> const_t; where PixelDereferenceAdaptorConcept&lt;const_t&gt;;<br /> <span class="keyword">typename</span> value_type; where PixelValueConcept&lt;value_type&gt;;<br /> <span class="keyword">typename</span> reference; where PixelConcept&lt;remove_reference&lt;reference&gt;::type&gt;; <span class="comment">// may be mutable</span><br /><span class="keyword">typename</span> const_reference; <span class="comment">// 必定不是可变的</span><br /><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> D::is_mutable;<br /><br /> where Convertible&lt;value_type, result_type&gt;;<br />};<br /></pre>
</div>
<p><b>模型:</b></p>
<p>GIL 提供了几个 <code>PixelDereferenceAdaptorConcept</code>模
型 </p>
<ul>
<li><code>color_convert_deref_fn:</code>
执行颜色变换</li>
<li><code>detail::nth_channel_deref_fn:</code>
返回指定像素第n个通道对应的灰度像素</li>
<li><code>deref_compose:</code> 对概念<code>PixelDereferenceAdaptorConcept</code>的
两个模型进行合成. 和<code>std::unary_compose</code>相似,只是还需要增加概念 <code>PixelDereferenceAdaptorConcept</code>所
需要的几个类型定义 </li>
</ul>
<p>
GIL 通过解引用适配器实现图像视图的颜色变换, 或者得到像素第n个通道的灰度值. 通过任意的函数变换,
解引用适配器实可以用来实现虚拟图像视图, 例如 Mandelbrot 集. <code>dereference_iterator_adaptor&lt;Iterator,Fn&gt;</code>
是一个像素迭代器包裹器,通过函数<code>Fn</code> 进行像素的解引用.</p>
<h2><a class="anchor" name="StepIteratorDG">Step
迭代器</a></h2>
有时候我们希望以单位步长而不是像素指定的步长遍历像素迭代器,下面的示例说明这个概念很有用:
<ul>
<li>RGB interleaved图像的红色通道的单通道视图</li>
<li>从左到右翻转的视图 (step = -fundamental_step)</li>
<li>每N个像素的子视图(step = N*fundamental_step)</li>
<li>垂直方向遍历的视图 (step = 每行的字节数)</li>
<li>上面的任意组合 (步长是相乘的)</li>
</ul>
<p>
Step 迭代器是前向迭代器, 允许修改相邻迭代器之间的步长 :</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept StepIteratorConcept&lt;boost_concepts::ForwardTraversalConcept Iterator&gt; {<br /> <span class="keyword">template</span> &lt;Integral D&gt; <span class="keywordtype">void</span> Iterator::set_step(D step);<br />};<br /><br />concept MutableStepIteratorConcept&lt;boost_concepts::Mutable_ForwardIteratorConcept Iterator&gt; : StepIteratorConcept&lt;Iterator&gt; {};<br /></pre>
</div>
<p>当前的GIL 提供的 step 迭代器的 <code>value_type</code>
是 <code>PixelValueConcept</code>的模型. 另外,
步长是基于内存单位的(字节或者位). 这是必要的,例如, 当对一系列的像素进行迭代的时候, 一行像素的大小不能被一个像素的大小整除;
还比如像素不是字对齐的 .</p>
<p>为了能够以字或字节向前迭代, 基础迭代器必须是 MemoryBasedIteratorConcept 的模型.
基于内存的迭代器有一个内在的存储单位, 位或者字节. 它必须提供下列功能: 每个存储单位的位数(1或8), 当前的步长,
两个迭代器之间基于存储单位的距离, 指定基于存储单位距离的引用. 它还必须提供函数使得迭代器前进一定距离. 函数<code>memunit_advanced</code>
和 <code>memunit_advanced_ref</code>
都有默认的实现,但是其他的迭代器可以提供更加有效的版本:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept MemoryBasedIteratorConcept&lt;boost_concepts::RandomAccessTraversalConcept Iterator&gt; {<br /> <span class="keyword">typename</span> byte_to_memunit&lt;Iterator&gt;; where metafunction&lt;byte_to_memunit&lt;Iterator&gt; &gt;;<br /> std::ptrdiff_t memunit_step(<span class="keyword">const</span> Iterator&amp;);<br /> std::ptrdiff_t memunit_distance(<span class="keyword">const</span> Iterator&amp; , <span class="keyword">const</span> Iterator&amp;);<br /> <span class="keywordtype">void</span> memunit_advance(Iterator&amp;, std::ptrdiff_t diff);<br /> Iterator memunit_advanced(<span class="keyword">const</span> Iterator&amp; p, std::ptrdiff_t diff) { Iterator tmp; memunit_advance(tmp,diff); <span class="keywordflow">return</span> tmp; }<br /> Iterator::reference memunit_advanced_ref(<span class="keyword">const</span> Iterator&amp; p, std::ptrdiff_t diff) { <span class="keywordflow">return</span> *memunit_advanced(p,diff); }<br />};<br /></pre>
</div>
<p>通过另外的迭代器构造一个step迭代器是很有用的. 更一般的是指定一个类型,
我们能够构造一个对应的动态指派水平步长的类型:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept HasDynamicXStepTypeConcept&lt;typename T&gt; {<br /> <span class="keyword">typename</span> dynamic_x_step_type&lt;T&gt;;<br /> where Metafunction&lt;dynamic_x_step_type&lt;T&gt; &gt;;<br />};<br /></pre>
</div>
<p>所有GIL提供的像素迭代器,定位器和图像视图的模型都是支持 <code>HasDynamicXStepTypeConcept</code>.</p>
<p><b>相关概念:</b></p>
<p></p>
<ul>
<li>StepIteratorConcept&lt;Iterator&gt;</li>
<li>MutableStepIteratorConcept&lt;Iterator&gt;</li>
<li>MemoryBasedIteratorConcept&lt;Iterator&gt;</li>
<li>HasDynamicXStepTypeConcept&lt;T&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>所有GIL当前提供的基于内存的迭代器都是 <code>MemoryBasedIteratorConcept</code>
的模型. GIL 提供的类型 <code>memory_based_step_iterator</code> 是概念
<code>PixelIteratorConcept</code>, <code>StepIteratorConcept</code>,
和 <code>MemoryBasedIteratorConcept</code>的模型. 它以基础迭代器(必须是<code>PixelIteratorConcept</code>
和 <code>MemoryBasedIteratorConcept</code>的模型)为模板参数,
并且允许动态改变步长. GIL的实现包含一个基础迭代器和一个 <code>ptrdiff_t</code>,用于表明基
于存储单位(字节或位)的步长数. 这个变量也可以用作负数. GIL提供了这样一个函数: 使用基础迭代器和步长创建一个step迭代器:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// 是 MemoryBasedIteratorConcept和 HasDynamicXStepTypeConcept的模型</span><br /><span class="keyword">typename</span> dynamic_x_step_type&lt;I&gt;::type make_step_iterator(<span class="keyword">const</span> I&amp; it, std::ptrdiff_t step);<br /></pre>
</div>
<p>GIL 还提供了 <code>position_iterator</code>,
基于虚拟像素数组的迭代器. 它是一个step 迭代器, 跟踪一个像素的位置,并且通过仿函数对像素解引用. 它是概念 <code>PixelIteratorConcept</code>
和 <code>StepIteratorConcept</code> 的模型,但是不是<code>MemoryBasedIteratorConcept</code>的
模型.</p>
<h2><a class="anchor" name="LocatorDG">像
素定位器</a></h2>
定位器允许在2维或者多维空间中进行漫游. 定位器本质上是N维的, 但是因为它们不完全满足迭代器的要求,我们需要另起炉灶. 例如,
它们不能进行累加和递减操作,因为它们知道在那一个维度上进行这样的操作. N维迭代器满足以下的概念:
<p></p>
<div class="fragment">
<pre class="fragment">concept RandomAccessNDLocatorConcept&lt;Regular Loc&gt; { <br /> <span class="keyword">typename</span> value_type; <span class="comment">// 定位器漫游的值类型 </span><br /><span class="keyword">typename</span> reference; <span class="comment">// 引用类型</span><br /><span class="keyword">typename</span> difference_type; where PointNDConcept&lt;difference_type&gt;; <span class="comment">// operator-的类型.</span><br /><span class="keyword">typename</span> const_t; <span class="comment">// Loc的常量类型</span><br /><span class="keyword">typename</span> cached_location_t; <span class="comment">// 存储相关位置的类型 (为了快速的重复访问)</span><br /><span class="keyword">typename</span> point_t = difference_type;<br /> <br /> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dimensions; <span class="comment">// 定位器的维度</span><br />where num_dimensions = point_t::num_dimensions;<br /><span class="comment">// 每个维度的 difference_type 和 迭代器类型. 迭代器可以只是在 </span><br /><span class="comment">// difference_type上不一样. 它们的 value_type 和 Loc::value_type必须一致</span><br /><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; <span class="keyword">struct </span>axis {<br /> <span class="keyword">typename</span> coord_t = point_t::axis&lt;D&gt;::coord_t;<br /> <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;; <span class="comment">// D维坐标轴的迭代器.</span><br />where iterator::value_type == value_type;<br />};<br /><span class="comment">// 定义和定位器类似的类型,只是在解引用上不同</span><br /><span class="keyword">template</span> &lt;PixelDereferenceAdaptorConcept Deref&gt; <span class="keyword">struct </span>add_deref {<br /> <span class="keyword">typename</span> type; where RandomAccessNDLocatorConcept&lt;type&gt;;<br /> <span class="keyword">static</span> type make(<span class="keyword">const</span> Loc&amp; loc, <span class="keyword">const</span> Deref&amp; deref);<br /> };<br /> <br /> Loc&amp; operator+=(Loc&amp;, <span class="keyword">const</span> difference_type&amp;);<br /> Loc&amp; operator-=(Loc&amp;, <span class="keyword">const</span> difference_type&amp;);<br /> Loc operator+(<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);<br /> Loc operator-(<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);<br /> <br /> reference operator*(<span class="keyword">const</span> Loc&amp;);<br /> reference operator[](<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);<br /> <br /> <span class="comment">// 存储相关的位置以便快速的重复访问 </span><br />cached_location_t Loc::cache_location(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;<br /> reference operator[](<span class="keyword">const</span> Loc&amp;,<span class="keyword">const</span> cached_location_t&amp;);<br /> <br /> <span class="comment">// 在当前位置或者指定的偏移处访问迭代器</span><br /> <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; axis&lt;D&gt;::iterator&amp; Loc::axis_iterator();<br /> <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; axis&lt;D&gt;::iterator <span class="keyword">const</span>&amp; Loc::axis_iterator() <span class="keyword">const</span>;<br /> <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; axis&lt;D&gt;::iterator Loc::axis_iterator(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;<br />};<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Loc&gt;<br />concept MutableRandomAccessNDLocatorConcept : RandomAccessNDLocatorConcept&lt;Loc&gt; { <br /> where Mutable&lt;reference&gt;;<br />};<br /></pre>
</div>
<p>2维定位器还有附加的要求:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept RandomAccess2DLocatorConcept&lt;RandomAccessNDLocatorConcept Loc&gt; {<br /> where num_dimensions==2;<br /> where Point2DConcept&lt;point_t&gt;;<br /> <br /> <span class="keyword">typename</span> x_iterator = axis&lt;0&gt;::iterator;<br /> <span class="keyword">typename</span> y_iterator = axis&lt;1&gt;::iterator;<br /> <span class="keyword">typename</span> x_coord_t = axis&lt;0&gt;::coord_t;<br /> <span class="keyword">typename</span> y_coord_t = axis&lt;1&gt;::coord_t;<br /> <br /> <span class="comment">// 只适用于在Y方向有动态步长的定位器</span><br /><span class="comment">//Loc::Loc(const Loc&amp; loc, y_coord_t);</span><br /><span class="comment">// 只适用于在X Y方向都有动态步长的定位器</span><br /><span class="comment">//Loc::Loc(const Loc&amp; loc, x_coord_t, y_coord_t, bool transposed=false);</span><br />x_iterator&amp; Loc::x();<br />x_iterator <span class="keyword">const</span>&amp; Loc::x() <span class="keyword">const</span>; <br /> y_iterator&amp; Loc::y();<br /> y_iterator <span class="keyword">const</span>&amp; Loc::y() <span class="keyword">const</span>; <br /> <br /> x_iterator Loc::x_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;<br /> y_iterator Loc::y_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;<br /> Loc Loc::xy_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;<br /> <br /> <span class="comment">// 不同类型所有方法的x/y 版本</span><br />x_iterator Loc::x_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;<br /> y_iterator Loc::y_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;<br /> Loc Loc::xy_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;<br /> reference operator()(<span class="keyword">const</span> Loc&amp;, x_coord_t, y_coord_t);<br /> cached_location_t Loc::cache_location(x_coord_t, y_coord_t) <span class="keyword">const</span>;<br /><br /> <span class="keywordtype">bool</span> Loc::is_1d_traversable(x_coord_t width) <span class="keyword">const</span>;<br /> y_coord_t Loc::y_distance_to(<span class="keyword">const</span> Loc&amp; loc2, x_coord_t x_diff) <span class="keyword">const</span>;<br />};<br /><br />concept MutableRandomAccess2DLocatorConcept&lt;RandomAccess2DLocatorConcept Loc&gt; : MutableRandomAccessNDLocatorConcept&lt;Loc&gt; {};<br /></pre>
</div>
<p>2维定位器不仅可以在水平方向,也可以在垂直方向有一个动态的定位步, 这样就产生了和Y对应的 <code>HasDynamicXStepTypeConcept:</code>
</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept HasDynamicYStepTypeConcept&lt;typename T&gt; {<br /> <span class="keyword">typename</span> dynamic_y_step_type&lt;T&gt;;<br /> where Metafunction&lt;dynamic_y_step_type&lt;T&gt; &gt;;<br />};<br /></pre>
</div>
<p>GIL提供的所有定位器和图像视图都是 <code>HasDynamicYStepTypeConcept</code>的
模型.</p>
<p>有时候对以指定的定位器和图像视图,需要对换X和Y方向的含义(例如,GIL提供了对换图像视图的函数).
这样的定位器和视图必须是可对换的:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept HasTransposedTypeConcept&lt;typename T&gt; {<br /> <span class="keyword">typename</span> transposed_type&lt;T&gt;;<br /> where Metafunction&lt;transposed_type&lt;T&gt; &gt;;<br />};<br /></pre>
</div>
<p>GIL提供的所有的定位器和视图都是<code>HasTransposedTypeConcept</code>的
模型.</p>
<p>GIL的定位器操纵的类型都是 <code>PixelConcept</code>
的模型, 并且它们的x/y维的类型是一致的. 它们是下列概念的模型:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept PixelLocatorConcept&lt;RandomAccess2DLocatorConcept Loc&gt; {<br /> where PixelValueConcept&lt;value_type&gt;;<br /> where PixelIteratorConcept&lt;x_iterator&gt;;<br /> where PixelIteratorConcept&lt;y_iterator&gt;;<br /> where x_coord_t == y_coord_t;<br /><br /> <span class="keyword">typename</span> coord_t = x_coord_t;<br />};<br /><br />concept MutablePixelLocatorConcept&lt;PixelLocatorConcept Loc&gt; : MutableRandomAccess2DLocatorConcept&lt;Loc&gt; {};<br /></pre>
</div>
<p><b>相关概念:</b></p>
<p></p>
<ul>
<li>HasDynamicYStepTypeConcept&lt;T&gt;</li>
<li>HasTransposedTypeConcept&lt;T&gt;</li>
<li>RandomAccessNDLocatorConcept&lt;Locator&gt;</li>
<li>MutableRandomAccessNDLocatorConcept&lt;Locator&gt;</li>
<li>RandomAccess2DLocatorConcept&lt;Locator&gt;</li>
<li>MutableRandomAccess2DLocatorConcept&lt;Locator&gt;</li>
<li>PixelLocatorConcept&lt;Locator&gt;</li>
<li>MutablePixelLocatorConcept&lt;Locator&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>GIL 提供了 <code>PixelLocatorConcept</code>
的两个模型:基于内存的定位器<code>memory_based_2d_locator</code> 和虚拟定位器 <code>virtual_2d_locator</code>.</p>
<p><code>memory_based_2d_locator</code>
是一个基于像素在内存中的用于 planar 或者 interleaved 图像的定位器. 它以 <code>StepIteratorConcept</code>为
模板参数.(当使用 概念<code>MutableStepIteratorConcept</code>的时候,
即生成概念 <code>MutablePixelLocatorConcept</code>).</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StepIterator&gt; <span class="comment">// 是StepIteratorConcept, MemoryBasedIteratorConcept的模型</span><br /><span class="keyword">class </span>memory_based_2d_locator;<br /></pre>
</div>
<p><code>StepIterator</code>
的步长必须是基于存储单位(字节或者位)的每行数(这样就可以向前累加).类型 <code>memory_based_2d_locator</code>
是 <code>StepIterator</code> 的包裹器,
并使用它进行垂直游历,而使用其基础迭代器进行水平游历. </p>
<p>由于定位器使用了基本内容和step迭代器分开的模式, 所以我们可以创建像素的存储结构更加复杂的定位器. 第一,
我们可以对水平方向的迭代器进行选择, 例如遍历同一行的像素. 使用这种分开的模式给了我们四种选择的可能:</p>
<ul>
<li><code>pixel&lt;T,C&gt;*</code>
(适用于 interleaved 图像)</li>
<li><code>planar_pixel_iterator&lt;T*,C&gt;</code>
(适用于 planar 图像)</li>
<li><code>memory_based_step_iterator&lt;pixel&lt;T,C&gt;*&gt;</code>
(适用于非标准步长的 interleaved 图像)</li>
<li><code>
memory_based_step_iterator&lt;planar_pixel_iterator&lt;T*,C&gt;
&gt; </code> (适用于非标准步长的 planar 图像)</li>
</ul>
<p>
当然,用户也可以提供它们自己定制的 x-iterator. 下面描述的一个例子是一个迭代器适配器,当解引用的时候可以进行颜色转换.</p>
<p>指定一个水平迭代器<code>XIterator</code>,
我们可以得到一个在垂直方向移动的迭代器 <em>y-iterator</em>, 移动的步长是<code>memory_based_step_iterator&lt;XIterator&gt;</code>
指定的基于存储单位(字节或者位)的每行数. 当然, 人们也可以自由的定制 y-iterator.</p>
<p>这样我们就可以实例化 <code>memory_based_2d_locator&lt;memory_based_step_iterator&lt;XIterator&gt;</code>
&gt; 得到一个2维像素定位器,如下图所示: </p>
<div align="center"><img src="step_iterator.gif" alt="step_iterator.gif" />
</div>
<p>
<code>virtual_2d_locator</code> 是一个通过仿函数对像素进行解引用的定位器.
仿函数返回指定X,Y位置像素值. 虚拟定位器可以用来实现用户指定的任意仿函数定义的虚拟图像视图.
参见GIL教程Mandelbrot集构造的虚拟图像.</p>
<p>虚拟定位器和基于内存实体定位器都继承自 <code>pixel_2d_locator_base</code>,
这个基类提供了概念 <code>PixelLocatorConcept</code>需要的绝大部分接口.
如果用户需要定制其他的<code>PixelLocatorConcept</code>,那么它们会发现这个基类非常的有
用:</p>
<p></p>
<div class="fragment">
<pre class="fragment">loc=img.xy_at(10,10); <span class="comment">// 从像素 (x=10,y=10)开始</span><br />above=loc.cache_location(0,-1); <span class="comment">// 记住上下邻居的相关位置 </span><br />below=loc.cache_location(0, 1);<br />++loc.x(); <span class="comment">// 移动到 (11,10)</span><br />loc.y()+=15; <span class="comment">// 移动到 (11,25)</span><br />loc-=point2&lt;std::ptrdiff_t&gt;(1,1);<span class="comment">// 移动到 (10,24)</span><br />*loc=(loc(0,-1)+loc(0,1))/2; <span class="comment">// 设置(10,24) 处的像素为 (10,23)处和 (10,25)处的均值 (只适用于灰度级像素)</span><br />*loc=(loc[above]+loc[below])/2; <span class="comment">// 同上,只是由于使用了缓存邻居的位置,所以更快 </span>
</pre>
</div>
<p>标准的GIL定位器都是快速的轻量级的对象.
例如简单的interleaved图像的定位器,只是包含一个指向像素起始位置的裸指针和一个行数据大小的整数, 总共8个字节. <code>
++loc.x() </code> 总共只是进行了一次裸指针的累加操作(或者是对于planar图像的N次累加操作).
因为要进行加法和乘法运算,所以2维的偏移操作相对较慢. 例如过滤器就需要访问每个像素的相同邻居,在这种情况下我们可以使用 <code>cache_location</code>缓
存相对位置. 在上面的实例中, 简单interleaved图像使用的代码<code> loc[above]</code>,
就是就是进行数组索引操作.</p>
<h2><a class="anchor" name="IteratorFrom2DDG">2
维图像迭代器</a></h2>
有的时候我们需要以位置独立的方式进行同样的像素遍历操作, 在这种情况下把像素视为一维的数组会非常的有用. GIL的类<code>iterator_from_2d</code>是
一个随机访问迭代器, 它以一种自然的,存储友好的方式从左到右,从上到下遍历像素.
它以定位器,图像的宽度和当前的X位置为参数,这样才有足够的信息决定何时回转,概要如下:
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Locator&gt; <span class="comment">// 是 PixelLocatorConcept的模型</span><br /><span class="keyword">class </span>iterator_from_2d {<br /><span class="keyword">public</span>:<br /> iterator_from_2d(<span class="keyword">const</span> Locator&amp; loc, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> width);<br /> <br /> iterator_from_2d&amp; operator++(); <span class="comment">// if (++_x&lt;_width) ++_p.x(); else _p+=point_t(-_width,1);</span><br />...<br />private:<br /><span class="keywordtype">int</span> _x, _width;<br /> Locator _p;<br />};<br /></pre>
</div>
<p>Iterating through the pixels in an image using <code>iterator_from_2d</code>
is slower than going through all rows and using the x-iterator at each
row. This is because two comparisons are done per iteration step - one
for the end condition of the loop using the iterators, and one inside <code>iterator_from_2d::operator++</code>
to determine whether we are at the end of a row. For fast operations,
such as pixel copy, this second check adds about 15% performance delay
(measured for interleaved images on Intel platform). GIL overrides some
STL algorithms, such as <code>std::copy</code> and <code>std::fill</code>,
when invoked with <code>iterator_from_2d-s</code>, to go
through each row using their base x-iterators, and, if the image has no
padding (i.e. <code>iterator_from_2d::is_1d_traversable()</code>
returns true) to simply iterate using the x-iterators directly.</p>
<p>通过<code>iterator_from_2d</code>
对图像像素进行迭代,速度要慢于通过每行迭代,并且在每行中使用x-iterator迭代。这是因为每个迭代步骤要进行两次比较,一次是对结束条件的判
断,另一次是在 <code>iterator_from_2d::operator++</code>
内部检查是否到达行尾. 对于有些快速的操作,例如像素的copy, 第二个检查会增加15%的性能损失(这是在Intel平台上的测量结果).
GIL 重载了一些STL算法, 例如&nbsp; <code>std::copy</code> 和 <code>std::fill</code><code></code><code></code>,
当这些算法以x-iterators为基础, 调用<code>iterator_from_2d-s</code>进行遍历的
时候,如果图像没有填充(例如 <code>iterator_from_2d::is_1d_traversable()</code>返
回true),那么就会直接使用x-iterators简化遍历操作.</p>
<p></p>
<hr />
<h2><a class="anchor" name="ImageViewSectionDG">9.
图像视图</a></h2>
图像视图是STL区间概念的泛化,具有多个维度. 和区间(多个迭代器)相似, 图像视图是浅层的, 它并不拥有数据,也不会影响数据本身的常量特性.
例如, 一个常量的图像视图并不能改变大小,但是允许修改像素.
对于像素不可变的操作,使用数据本身是具有常量特性的图像数据(也称为non-mutable图像视图). N-维的图像视图满足下面的概念要求:
<p></p>
<div class="fragment">
<pre class="fragment">concept RandomAccessNDImageViewConcept&lt;Regular View&gt; {<br /> <span class="keyword">typename</span> value_type; <span class="comment">// 对于基于像素的视图,就是像素的类型</span><br /><span class="keyword">typename</span> reference; <span class="comment">// 引用类型</span><br /><span class="keyword">typename</span> difference_type; <span class="comment">// operator-(iterator,iterator) (1-维!)的类型</span><br /><span class="keyword">typename</span> const_t; where RandomAccessNDImageViewConcept&lt;View&gt;; <span class="comment">// same as View, but over immutable values</span><br /><span class="keyword">typename</span> point_t; where PointNDConcept&lt;point_t&gt;; <span class="comment">// N-维点</span><br /><span class="keyword">typename</span> locator; where RandomAccessNDLocatorConcept&lt;locator&gt;; <span class="comment">// N-维定位器.</span><br /><span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;; <span class="comment">// 1-维迭代器</span><br /><span class="keyword">typename</span> reverse_iterator; where RandomAccessTraversalConcept&lt;reverse_iterator&gt;; <br /> <span class="keyword">typename</span> size_type; <span class="comment">// size()的类型</span><br /><span class="comment">// 对应于RandomAccessNDLocatorConcept::axis</span><br /><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; <span class="keyword">struct </span>axis {<br /> <span class="keyword">typename</span> coord_t = point_t::axis&lt;D&gt;::coord_t;<br /> <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;; <span class="comment">// 第D个坐标轴的迭代器.</span><br />where SameType&lt;coord_t, iterator::difference_type&gt;;<br />where SameType&lt;iterator::value_type,value_type&gt;;<br />};<br /><span class="comment">// 除了在解引用上调用Deref(译者注:不是直接解引用),定义和视图一致的视图类型</span><br /><span class="keyword">template</span> &lt;PixelDereferenceAdaptorConcept Deref&gt; <span class="keyword">struct </span>add_deref {<br /> <span class="keyword">typename</span> type; where RandomAccessNDImageViewConcept&lt;type&gt;;<br /> <span class="keyword">static</span> type make(<span class="keyword">const</span> View&amp; v, <span class="keyword">const</span> Deref&amp; deref);<br /> };<br /><br /> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dimensions = point_t::num_dimensions;<br /> <br /> <span class="comment">// 从定位器和左上角以及维度创建视图</span><br />View::View(<span class="keyword">const</span> locator&amp;, <span class="keyword">const</span> point_type&amp;);<br /> <br /> size_type View::size() <span class="keyword">const</span>; <span class="comment">// 元素的总个数 </span><br />reference operator[](View, <span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>; <span class="comment">// 1-维引用</span><br />iterator View::begin() <span class="keyword">const</span>;<br /> iterator View::end() <span class="keyword">const</span>;<br /> reverse_iterator View::rbegin() <span class="keyword">const</span>;<br /> reverse_iterator View::rend() <span class="keyword">const</span>;<br /> iterator View::at(<span class="keyword">const</span> point_t&amp;);<br /> point_t View::dimensions() <span class="keyword">const</span>; <span class="comment">// 每个维度的元素数</span><br /><span class="keywordtype">bool</span> View::is_1d_traversable() <span class="keyword">const</span>; <span class="comment">// 是否支持一维遍历?</span><br /><span class="comment">// 得到指定的维度和指定点的迭代器</span><br /> <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; View::axis&lt;D&gt;::iterator View::axis_iterator(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;<br /><br /> reference operator()(View,<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;<br />};<br /><br />concept MutableRandomAccessNDImageViewConcept&lt;RandomAccessNDImageViewConcept View&gt; {<br /> where Mutable&lt;reference&gt;;<br />};<br /></pre>
</div>
<p>2维的图像视图还有额外的要求:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept RandomAccess2DImageViewConcept&lt;RandomAccessNDImageViewConcept View&gt; {<br /> where num_dimensions==2;<br /><br /> <span class="keyword">typename</span> x_iterator = axis&lt;0&gt;::iterator;<br /> <span class="keyword">typename</span> y_iterator = axis&lt;1&gt;::iterator;<br /> <span class="keyword">typename</span> x_coord_t = axis&lt;0&gt;::coord_t;<br /> <span class="keyword">typename</span> y_coord_t = axis&lt;1&gt;::coord_t;<br /> <span class="keyword">typename</span> xy_locator = locator;<br /> <br /> x_coord_t View::width() <span class="keyword">const</span>;<br /> y_coord_t View::height() <span class="keyword">const</span>;<br /> <br /> <span class="comment">// X-方向遍历</span><br />x_iterator View::x_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;<br /> x_iterator View::row_begin(y_coord_t) <span class="keyword">const</span>;<br /> x_iterator View::row_end (y_coord_t) <span class="keyword">const</span>;<br /><br /> <span class="comment">// Y-方向遍历</span><br />y_iterator View::y_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;<br /> y_iterator View::col_begin(x_coord_t) <span class="keyword">const</span>;<br /> y_iterator View::col_end (x_coord_t) <span class="keyword">const</span>;<br /> <br /> <span class="comment">// 2维遍历</span><br />xy_locator View::xy_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;<br /><br /> <span class="comment">// 以point_t为参数的所有方法的(x,y)版本实现 </span><br />View::View(x_coord_t,y_coord_t,<span class="keyword">const</span> locator&amp;);<br /> iterator View::at(x_coord_t,y_coord_t) <span class="keyword">const</span>;<br /> reference operator()(View,x_coord_t,y_coord_t) <span class="keyword">const</span>;<br /> xy_locator View::xy_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;<br /> x_iterator View::x_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;<br /> y_iterator View::y_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;<br />};<br /><br />concept MutableRandomAccess2DImageViewConcept&lt;RandomAccess2DImageViewConcept View&gt;<br /> : MutableRandomAccessNDImageViewConcept&lt;View&gt; {};<br /></pre>
</div>
<p>典型的GIL图像视图满足 <code>PixelValueConcept</code>
, 并且有额外的要求:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept ImageViewConcept&lt;RandomAccess2DImageViewConcept View&gt; {<br /> where PixelValueConcept&lt;value_type&gt;;<br /> where PixelIteratorConcept&lt;x_iterator&gt;; <br /> where PixelIteratorConcept&lt;y_iterator&gt;;<br /> where x_coord_t == y_coord_t;<br /> <br /> <span class="keyword">typename</span> coord_t = x_coord_t;<br /><br /> std::size_t View::num_channels() <span class="keyword">const</span>;<br />};<br /><br /><br />concept MutableImageViewConcept&lt;ImageViewConcept View&gt; : MutableRandomAccess2DImageViewConcept&lt;View&gt; {};<br /></pre>
</div>
<p>如果两个图像视图维度相同,并且像素类型是兼容的,那么它们就被认为是兼容的: </p>
<div class="fragment">
<pre class="fragment">concept ViewsCompatibleConcept&lt;ImageViewConcept V1, ImageViewConcept V2&gt; {<br /> where PixelsCompatibleConcept&lt;V1::value_type, V2::value_type&gt;;<br /> where V1::num_dimensions == V2::num_dimensions;<br />};<br /></pre>
</div>
<p>兼容的视图必须具有相同的维度(例如, 相同的高度和宽度).很多以多个视图为参数的算法要求它们是兼容的 .</p>
<p><b>相关的概念:</b></p>
<p></p>
<ul>
<li>RandomAccessNDImageViewConcept&lt;View&gt;</li>
<li>MutableRandomAccessNDImageViewConcept&lt;View&gt;</li>
<li>RandomAccess2DImageViewConcept&lt;View&gt;</li>
<li>MutableRandomAccess2DImageViewConcept&lt;View&gt;</li>
<li>ImageViewConcept&lt;View&gt;</li>
<li>MutableImageViewConcept&lt;View&gt;</li>
<li>ViewsCompatibleConcept&lt;View1,View2&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>GIL 提供的<code>ImageViewConcept</code> 的模型是 <code>image_view</code>,
它以<code>PixelLocatorConcept</code>为模板参数. (如果以<code>MutablePixelLocatorConcept</code>为
模板参数, 那么就是 <code>MutableImageViewConcept</code>). 如下:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Locator&gt; <span class="comment">// 是概念 PixelLocatorConcept的模型 (也可以是 MutablePixelLocatorConcept)</span><br /><span class="keyword">class </span>image_view {<br /><span class="keyword">public</span>:<br /> <span class="keyword">typedef</span> Locator xy_locator;<br /> <span class="keyword">typedef</span> iterator_from_2d&lt;Locator&gt; iterator;<br /> ...<br />private:<br /> xy_locator _pixels; <span class="comment">// 在图像左上角的2维像素定位器</span><br />point_t _dimensions; <span class="comment">// 高度和宽度</span><br />};<br /></pre>
</div>
<p>图像视图是轻量级的对象, 一个常规的 interleaved 视图典型是是16个字节的大小 :
两个表示长度和宽度的整数(包含在维度点中),一个表示相邻行的字节大小的整数(包含在定位器中),以及一个表示图像像素数据块首地址的指针.</p>
<p><b>算法:</b></p>
<h3><a class="anchor" name="ImageViewFrowRawDG">从
裸像素数据创建视图 </a></h3>
从任何支持的颜色空间,位深度,通道次序以及planar,interleaved结构的裸数据都可以构造标准的视图. Interleaved
视图使用 <code>interleaved_view</code>构造,
需要提供图像的维度,每行的字节数和指向第一个像素的指针:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt; <span class="comment">// 像素迭代器的指针 (例如 rgb8_ptr_t 或者 rgb8c_ptr_t)</span><br />image_view&lt;...&gt; <a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(ptrdiff_t width, ptrdiff_t height, Iterator pixels, ptrdiff_t rowsize)<br /></pre>
</div>
<p>Planar 视图使用每个颜色空间定义, 下面是一个RGB的形式:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IC&gt; <span class="comment">// Models channel iterator (like bits8* or const bits8*)</span><br />image_view&lt;...&gt; <a class="code" title="from raw RGB planar data" href="g_i_l_0140.html#g294f43780e7b88f43b91fdd6346cb51b">planar_rgb_view</a>(ptrdiff_t width, ptrdiff_t height,<br /> IC r, IC g, IC b, ptrdiff_t rowsize);<br /></pre>
</div>
<p>注意到提供的像素/通道迭代器可以是常量(不变)迭代器,在这种情况下构造的视图也是常量(不变)视图 .</p>
<h3><a class="anchor" name="ImageViewFrowImageViewDG">从其他的视图创建图像视图</a></h3>
改变图像视图数据使用的某些方式,可以构造一个新的图像视图. 新的视图的类型是从源视图的类型衍生出来的,
GIL提供了以下的元函数来得到衍生的类型:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 一些视图类型</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <br /><span class="keyword">struct </span>dynamic_xy_step_type : <span class="keyword">public</span> dynamic_y_step_type&lt;typename dynamic_x_step_type&lt;View&gt;::type&gt; {};<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <br /><span class="keyword">struct </span>dynamic_xy_step_transposed_type : <span class="keyword">public</span> dynamic_xy_step_type&lt;typename transposed_type&lt;View&gt;::type&gt; {};<br /><br /><span class="comment">// 对颜色和位深进行转换</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="comment">// ImageViewConcept的模型</span><br /><span class="keyword">typename</span> DstP, <span class="comment">// PixelConcept的模型</span><br /><span class="keyword">typename</span> ColorConverter=gil::default_color_converter&gt; <br /><span class="keyword">struct </span>color_converted_view_type {<br /> <span class="keyword">typedef</span> ... type; <span class="comment">// 经过适配的图像视图</span><br />};<br /><span class="comment">// N个通道的单通道视图</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView&gt;<br /><span class="keyword">struct </span>nth_channel_view_type {<br /> <span class="keyword">typedef</span> ... type;<br />};<br /></pre>
</div>
<p>GIL 提供了如下的视图转换:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 上下,左右和双向翻转的视图</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type flipped_up_down_view(<span class="keyword">const</span> View&amp; src);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_x_step_type&lt;View&gt;::type flipped_left_right_view(<span class="keyword">const</span> View&amp; src);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type transposed_view(<span class="keyword">const</span> View&amp; src);<br /><br /><span class="comment">// 旋转</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type rotated180_view(<span class="keyword">const</span> View&amp; src);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type rotated90cw_view(<span class="keyword">const</span> View&amp; src);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type rotated90ccw_view(<span class="keyword">const</span> View&amp; src);<br /><br /><span class="comment">// 矩形范围内部的子视图</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; View subimage_view(<span class="keyword">const</span> View&amp; src, <br /> <span class="keyword">const</span> View::point_t&amp; top_left, <span class="keyword">const</span> View::point_t&amp; dimensions);<br /><br /><span class="comment">// 在XY两个方向间隔的视图</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type subsampled_view(<span class="keyword">const</span> View&amp; src, <br /> <span class="keyword">const</span> View::point_t&amp; step);<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> P&gt; <br />color_converted_view_type&lt;View,P&gt;::type <a class="code" title="view of a different color space with a user defined color-converter" href="g_i_l_0161.html#gb5114cdb6c2a34f6706952f80baf2dfa">color_converted_view</a>(<span class="keyword">const</span> View&amp; src);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> P, <span class="keyword">typename</span> CCV&gt; <span class="comment">// 定制的颜色变换</span><br />color_converted_view_type&lt;View,P,CCV&gt;::type <a class="code" title="view of a different color space with a user defined color-converter" href="g_i_l_0161.html#gb5114cdb6c2a34f6706952f80baf2dfa">color_converted_view</a>(<span class="keyword">const</span> View&amp; src);<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <br />nth_channel_view_type&lt;View&gt;::view_t nth_channel_view(<span class="keyword">const</span> View&amp; <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>, <span class="keywordtype">int</span> n);<br /></pre>
</div>
<p> 绝大多数视图创建的算法都是直白的,下面是一个视图翻转实现的例子. 上下翻转<code>创建的</code>视
图的第一个像素是源视图最底最左的像素,并且在y方向的步长是相反的.</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt;<br /><span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type flipped_up_down_view(<span class="keyword">const</span> View&amp; src) { <br /> gil_function_requires&lt;ImageViewConcept&lt;View&gt; &gt;();<br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type RView;<br /> <span class="keywordflow">return</span> RView(src.dimensions(),<span class="keyword">typename</span> RView::xy_locator(src.xy_at(0,src.height()-1),-1));<br />}<br /></pre>
</div>
<p> 调用函数 <code>gil_function_requires</code>
会确保 (在编译期)模板参数是&nbsp; <code>ImageViewConcept</code>的模型.
使用这个函数会比较容易跟踪编译错误,并且不会增加代码体积和运行时的开销. 我们使用了函数库 <code>boost::concept_check</code>
, 并且包裹为 <code>gil_function_requires</code>, 还设置了一个开关选项 <code>BOOST_GIL_USE_CONCEPT_CHECK</code>
,默认是关闭的, 这主要是因为一旦开启这个选项会显著的增加编译时间. 在本文档中, 为了简洁,我们会跳过这个函数检查.</p>
<p> 图像视图之间可以自由组合(参见 <a class="el" href="gildesignguide.html#MetafunctionsDG">12. 使用元函数和Typedefs</a>
中的类型定义 <code>rgb16_image_t</code> 和 <code>gray16_step_view_t</code>):</p>
<p></p>
<div class="fragment">
<pre class="fragment">rgb16_image_t img(100,100); <span class="comment">// 一个 RGB interleaved 的图像</span><br /><span class="comment">// img的绿色通道(通道索引号1)生成的灰度级视图</span><br />gray16_step_view_t green=nth_channel_view(<a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(img),1);<br /><br /><span class="comment">// 50x50 大小的视图,上下翻转并且在XY方向都是每隔一行取数据</span><br />gray16_step_view_t ud_fud=flipped_up_down_view(subsampled_view(green,2,2));<br /></pre>
</div>
<p> 如前所述,图像视图的构造是快速的,常量时间的,是对图像数据的一个浅层映像. 上面的代码不会执行像素数据的拷贝,
数据是图像创建的时候分配的.</p>
<h3><a class="anchor" name="ImageViewAlgorithmsDG">图
像视图的STL形式的算法</a></h3>
通过方法 begin() 和 end() ,图像视图提供了对像素的1维迭代器, 这使得可以应用STL算法. 但是,对X
Y两个方向应用嵌套的循环,在很多情况下会更加高效. 本节中的算法都是模仿STL算法的,
它们封装了嵌套的循环,并以视图作为输入参数(而不是一个区间).
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 对应于 std::copy and std::uninitialized_copy</span><br /><span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;, ViewsCompatibleConcept&lt;V1,V2&gt;</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;<br /><span class="keywordtype">void</span> <a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;<br /><span class="keywordtype">void</span> <a class="code" title="std::uninitialized_copy for image views. Does not support planar heterogeneous views..." href="g_i_l_0155.html#ge33d703beb3b085809b3b3ca64cc8906">uninitialized_copy_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);<br /><br /><span class="comment">// <code>对应于</code> std::fill and std::uninitialized_fill</span><br /><span class="comment">// 满足 MutableImageViewConcept&lt;V&gt;, PixelConcept&lt;Value&gt;, PixelsCompatibleConcept&lt;Value,V::value_type&gt;</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> Value&gt;<br /><span class="keywordtype">void</span> <a class="code" title="std::fill for image views" href="g_i_l_0149.html#g3b28c66102763fd1d42f69e4eefa631f">fill_pixels</a>(<span class="keyword">const</span> V&amp; dst, <span class="keyword">const</span> Value&amp; val);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> Value&gt;<br /><span class="keywordtype">void</span> <a class="code" title="std::uninitialized_fill for image views. Does not support planar heterogeneous views..." href="g_i_l_0156.html#g4f5edbc3fe6b776c6aa1939902333cf3">uninitialized_fill_pixels</a>(<span class="keyword">const</span> V&amp; dst, <span class="keyword">const</span> Value&amp; val);<br /><br /><span class="comment">// 对应于 std::for_each</span><br /><span class="comment">// 满足 ImageViewConcept&lt;V&gt;, boost::UnaryFunctionConcept&lt;F&gt;</span><br /><span class="comment">// 满足 PixelsCompatibleConcept&lt;V::reference, F::argument_type&gt;</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;<br />F for_each_pixel(<span class="keyword">const</span> V&amp; <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>, F fun);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;<br />F for_each_pixel_position(<span class="keyword">const</span> V&amp; <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>, F fun);<br /><br /><span class="comment">// 对应于 std::generate</span><br /><span class="comment">// 满足 MutableImageViewConcept&lt;V&gt;, boost::UnaryFunctionConcept&lt;F&gt;</span><br /><span class="comment">// 满足 PixelsCompatibleConcept&lt;V::reference, F::argument_type&gt;</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;<br /><span class="keywordtype">void</span> <a class="code" title="std::generate for image views" href="g_i_l_0152.html#gdce3525a9aa4794ba807cfb8c0100d2f">generate_pixels</a>(<span class="keyword">const</span> V&amp; dst, F fun);<br /><br /><span class="comment">// 对应于 std::transform with one source</span><br /><span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;</span><br /><span class="comment">// 满足 boost::UnaryFunctionConcept&lt;F&gt;</span><br /><span class="comment">// 满足 PixelsCompatibleConcept&lt;V1::const_reference, F::argument_type&gt;</span><br /><span class="comment">// 满足 PixelsCompatibleConcept&lt;F::result_type, V2::reference&gt;</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> F&gt;<br />F <a class="code" title="std::transform for image views" href="g_i_l_0154.html#g27eed3931b4835e3757642ed41db0984">transform_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, F fun);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> F&gt;<br />F <a class="code" title="Like transform_pixels but passes to the function object pixel locators instead of..." href="g_i_l_0153.html#gc74f3114086b954dfd1735a918f68389">transform_pixel_positions</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, F fun);<br /><br /><span class="comment">// 对应于 std::transform with two sources</span><br /><span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, ImageViewConcept&lt;V2&gt;, MutableImageViewConcept&lt;V3&gt;</span><br /><span class="comment">// 满足 boost::BinaryFunctionConcept&lt;F&gt;</span><br /><span class="comment">// 满足 PixelsCompatibleConcept&lt;V1::const_reference, F::first_argument_type&gt;</span><br /><span class="comment">// 满足 PixelsCompatibleConcept&lt;V2::const_reference, F::second_argument_type&gt;</span><br /><span class="comment">// 满足 PixelsCompatibleConcept&lt;F::result_type, V3::reference&gt;</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> V3, <span class="keyword">typename</span> F&gt;<br />F <a class="code" title="std::transform for image views" href="g_i_l_0154.html#g27eed3931b4835e3757642ed41db0984">transform_pixels</a>(<span class="keyword">const</span> V1&amp; src1, <span class="keyword">const</span> V2&amp; src2, <span class="keyword">const</span> V3&amp; dst, F fun);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> V3, <span class="keyword">typename</span> F&gt;<br />F <a class="code" title="Like transform_pixels but passes to the function object pixel locators instead of..." href="g_i_l_0153.html#gc74f3114086b954dfd1735a918f68389">transform_pixel_positions</a>(<span class="keyword">const</span> V1&amp; src1, <span class="keyword">const</span> V2&amp; src2, <span class="keyword">const</span> V3&amp; dst, F fun);<br /><br /><span class="comment">// 使用用户定义的或者默认的颜色转换器(<code>在必要的时候才进行颜色转换</code>),从一个视图构造一个新视图</span><br /><span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;</span><br /><span class="comment">// V1::value_type must be convertible to V2::value_type.</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;<br /><span class="keywordtype">void</span> copy_and_convert_pixels(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> ColorConverter&gt;<br /><span class="keywordtype">void</span> copy_and_convert_pixels(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, ColorConverter ccv);<br /><br /><span class="comment">// 对应于 std::equal</span><br /><span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, ImageViewConcept&lt;V2&gt;, ViewsCompatibleConcept&lt;V1,V2&gt;</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;<br /><span class="keywordtype">bool</span> <a class="code" title="std::equal for image views" href="g_i_l_0148.html#g86a5d26dbacd64b2bc4f53b4b2971a73">equal_pixels</a>(<span class="keyword">const</span> V1&amp; view1, <span class="keyword">const</span> V2&amp; view2);<br /></pre>
</div>
<p> 使用多个视图参数的算法要求它们具有相同的维度. <code>for_each_pixel_position</code>
和 <code>transform_pixel_positions</code>
给仿函数传递的是像素定位器,而不是像素引用,这适用于那些需要访问像素邻居的算法,这在教程里面有过描述.</p>
<p> 绝大部分的算法都会检查图像视图是否是1维可遍历的, 所谓的一维可遍历视图, 指的是图像行数据之间没有填充.
换句话说, 如果视图的x_iterator累加到了一行的末尾就会直接的转入下一行, 那么这个视图就是1维可遍历的. 如果视图是一维可遍历的,
那么算法就会使用一个单一的循环, 运行就会更加的有效; 否则算法就会在Y方向循环内部嵌套X循环.</p>
<p> 一般这些算法会把工作转交给对应的STL算法, 例如 <code>copy_pixels</code>
会调用 <code><span class="el">std::copy</span></code>
扫描每行,或者当视图是一维可遍历的, 扫描所有的像素.</p>
<p> 另外, 有时候会对STL算法提供重载. 例如,针对planar迭代器调用 <code><span class="el">std::copy</span></code>
会转换为对每个颜色面调用 <code><span class="el">std::copy</span></code>
, 而对可以逐位拷贝的像素调用 <code><span class="el">std::copy</span></code>
会转换为对无符号字节调用 <code><span class="el">std::copy</span></code>
,而这种情形下,STL会转换为对 <code>memmove</code>的调用.</p>
<p> 这样的结果是, <code>copy_pixels</code>
会对一维可遍历的interleaved视图执行 <code>memmove</code>
,或者对一维可遍历的planar视图执行每个颜色面的一次拷贝,或者对非一维可遍历的interleaved视图执行每行数据的一次拷贝,等等.</p>
<p>GIL 还提供了一些图像处理算法的beta-版本,
例如数字扩展中的重采样和卷积运算等,这可以在&nbsp;<a href="http://stlab.adobe.com/gil/download.html.">http://stlab.adobe.com/gil/download.html</a>
得
到. 这是在开发早期定义的算法,并没有针对速度进行优化. </p>
<p></p>
<hr />
<h2><a class="anchor" name="ImageSectionDG">10.
</a>图像</h2>
图像是像素的容器,是视图像素的拥有者. 它会在构造函数中分配空间并在析构函数中释放. 它的赋值运算和拷贝构造都是深层次的.
除了在拥有权很重要的情况下,图像很少直接使用.
绝大多数的STL算法都是操纵区间,而不是容器,同样的GIL算法也大多应用在图像视图(上一节的内容).
<p>从最通用的角度来看,图像是N维的,并且满足以下的概念:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept RandomAccessNDImageConcept&lt;typename Img&gt; : Regular&lt;Img&gt; {<br /> <span class="keyword">typename</span> view_t; where MutableRandomAccessNDImageViewConcept&lt;view_t&gt;;<br /> <span class="keyword">typename</span> const_view_t = view_t::const_t;<br /> <span class="keyword">typename</span> point_t = view_t::point_t;<br /> <span class="keyword">typename</span> value_type = view_t::value_type;<br /> <span class="keyword">typename</span> allocator_type;<br /><br /> Img::Img(point_t dims, std::size_t alignment=0);<br /> Img::Img(point_t dims, value_type fill_value, std::size_t alignment);<br /> <br /> <span class="keywordtype">void</span> Img::recreate(point_t new_dims, std::size_t alignment=0);<br /> <span class="keywordtype">void</span> Img::recreate(point_t new_dims, value_type fill_value, std::size_t alignment);<br /><br /> <span class="keyword">const</span> point_t&amp; Img::dimensions() <span class="keyword">const</span>;<br /> <span class="keyword">const</span> const_view_t&amp; <a class="code" title="Returns the constant-pixel view of an image." href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996">const_view</a>(<span class="keyword">const</span> Img&amp;);<br /> <span class="keyword">const</span> view_t&amp; <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(Img&amp;);<br />};<br /></pre>
</div>
<p>2维的图像还有更多的要求:</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept RandomAccess2DImageConcept&lt;RandomAccessNDImageConcept Img&gt; {<br /> <span class="keyword">typename</span> x_coord_t = const_view_t::x_coord_t;<br /> <span class="keyword">typename</span> y_coord_t = const_view_t::y_coord_t;<br /> <br /> Img::Img(x_coord_t width, y_coord_t height, std::size_t alignment=0);<br /> Img::Img(x_coord_t width, y_coord_t height, value_type fill_value, std::size_t alignment);<br /><br /> x_coord_t Img::width() <span class="keyword">const</span>;<br /> y_coord_t Img::height() <span class="keyword">const</span>;<br /> <br /> <span class="keywordtype">void</span> Img::recreate(x_coord_t width, y_coord_t height, std::size_t alignment=1);<br /> <span class="keywordtype">void</span> Img::recreate(x_coord_t width, y_coord_t height, value_type fill_value, std::size_t alignment);<br />};<br /></pre>
</div>
<p>GIL的图像视图满足 <code>ImageViewConcept</code>,
并且可以操纵像素.</p>
<p></p>
<div class="fragment">
<pre class="fragment">concept ImageConcept&lt;RandomAccess2DImageConcept Img&gt; {<br /> where MutableImageViewConcept&lt;view_t&gt;;<br /> <span class="keyword">typename</span> coord_t = view_t::coord_t;<br />};<br /></pre>
</div>
<p>与定位器和图像视图不同,图像没有'mutable'概念, 因为immutable的图像不是很有用途.</p>
<p><b>相关概念:</b></p>
<p></p>
<ul>
<li>RandomAccessNDImageConcept&lt;Image&gt;</li>
<li>RandomAccess2DImageConcept&lt;Image&gt;</li>
<li>ImageConcept&lt;Image&gt;</li>
</ul>
<p>
<b>模型:</b></p>
<p>GIL 提供了类 <code>image</code>, 它以 value type
(像素) 为模板参数,并且满足 <code>ImageConcept</code>.</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, \\ PixelValueConcept的模型<br /> <span class="keywordtype">bool</span> IsPlanar, \\ planar 或者 interleaved 的图像<br /> <span class="keyword">typename</span> A=std::allocator&lt;unsigned char&gt; &gt; <br /><span class="keyword">class </span>image;<br /></pre>
</div>
<p>图像构造器有一个对齐参数, 这允许构造字对齐或者字节对齐的图像. 对齐的单位是字节, 默认的对齐参数是0,
这意味着每行的数据没有填充. 使用这样一维可遍历的图像, 很多的算法要更快, 因为这样就会使用 <code>image_view::x_iterator</code>
进行像素遍历,而不是使用更加复杂的<code>image_view::iterator</code>.
注意当对齐为0的时候, packed的图像是以位对齐的,例如packed图像在行尾没有对齐的位.</p>
<hr />
<h2><a class="anchor" name="VariantSecDG">11.
运行时指派的图像和图像视图</a></h2>
图像的颜色空间, 通道次序和interleaved/planar结构都是模板参数, 这是编译器绑定的. 很多情况下,
这些参数只有在运行时才能得到. 考虑一个实例,一个模块根据指定的路径打开一个图像文件, 进行旋转,然后按照原来的颜色空间和通道深度存储回去.
如何使用我们的泛型图像实现这个功能?图像加载代码返回什么类型?
<p>GIL的扩展 dynamic_image,
允许在运行时指派参数构造图像,图像视图或者任何其他的GIL构造,这里是一个实例: </p>
<div class="fragment">
<pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" title="Includes all of the GIL dynamic image extension files, for convenience." href="g_i_l_0083.html">boost/gil/extension/dynamic_image/dynamic_image_all.hpp</a>&gt;</span><span class="preprocessor"></span><br /><span class="keyword">using</span> <span class="keyword">namespace </span>boost;<br /><br /><span class="preprocessor">#define ASSERT_SAME(A,B) BOOST_STATIC_ASSERT((is_same&lt; A,B &gt;::value))</span>
<span class="preprocessor"></span><br /><span class="comment">// 定义允许的图像类型集合</span><br /><span class="keyword">typedef</span> mpl::vector&lt;rgb8_image_t, cmyk16_planar_image_t&gt; my_images_t;<br /><br /><span class="comment">// 创建 any_image class (或者 any_image_view) 类</span><br /><span class="keyword">typedef</span> any_image&lt;my_images_t&gt; my_any_image_t;<br /><br /><span class="comment">// 视图的相关型别也是可用的(和image_t里面的是一样的)</span><br /><span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8_view_t, cmyk16_planar_view_t &gt; &gt; AV;<br />ASSERT_SAME(my_any_image_t::view_t, AV);<br /><br /><span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8c_view_t, cmyk16c_planar_view_t&gt; &gt; CAV;<br />ASSERT_SAME(my_any_image_t::const_view_t, CAV);<br />ASSERT_SAME(my_any_image_t::const_view_t, my_any_image_t::view_t::const_t);<br /><br /><span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8_step_view_t, cmyk16_planar_step_view_t&gt; &gt; SAV;<br />ASSERT_SAME(<span class="keyword">typename</span> dynamic_x_step_type&lt;my_any_image_t::view_t&gt;::type, SAV);<br /><br /><span class="comment">// 在运行时对图像赋值 it a concrete image at run time:</span><br />my_any_image_t myImg = my_any_image_t(rgb8_image_t(100,100));<br /><span class="comment">// 在运行时改变图像, 前一个图像被析构</span><br />myImg = cmyk16_planar_image_t(200,100);<br /><span class="comment">// 构造一个不在类型允许范围内的图像,会抛出一个异常Assigning to an image not in the allowed set throws an exception</span><br />myImg = gray8_image_t(); <span class="comment">// 抛出 std::bad_cast</span>
</pre>
</div>
<p><code>any_image</code> 和 <code>any_image_view</code>
是 GIL <code>variant</code> 的子类,
它会通过一个非模板化的底层结构和唯一的类型标识进行实例化. 这个底层结构是一个字节块, 这个字节块足够容纳特定类型的最大内容.</p>
<p>GIL 的 variant 和 <code>boost::variant</code>
在本质上很类似 (我们因此也借用了那个名字),只是在有些地方还和当前的 <a class="el" href="namespaceboost.html">boost</a>&nbsp;实现有所不同.
也许最大的不同就是GIL的variant总是通过单一的参数构造,这个参数就是枚举了允许类型的MPL随机访问序列(Random Access
Sequence). 单一的接口使得GIL的variant在泛型编码中更容易使用.其概要如下:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Types&gt; <span class="comment">// MPL 随机访问容器</span><br /><span class="keyword">class </span>variant {<br /> ... _bits;<br /> std::size_t _index;<br /><span class="keyword">public</span>:<br /> <span class="keyword">typedef</span> Types types_t;<br /><br /> variant();<br /> variant(<span class="keyword">const</span> variant&amp; v);<br /> <span class="keyword">virtual</span> ~variant();<br /> <br /> variant&amp; operator=(<span class="keyword">const</span> variant&amp; v);<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TS&gt; <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> variant&lt;TS&gt;&amp; x, <span class="keyword">const</span> variant&lt;TS&gt;&amp; y);<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TS&gt; <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> variant&lt;TS&gt;&amp; x, <span class="keyword">const</span> variant&lt;TS&gt;&amp; y);<br /><br /> <span class="comment">// 从类型 T构造/赋值. 如果T不在允许的类型范围内则抛出异常 std::bad_cast</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> variant(<span class="keyword">const</span> T&amp; obj);<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; variant&amp; operator=(<span class="keyword">const</span> T&amp; obj);<br /><br /> <span class="comment">// 通过和T的当前内容交换构造/赋值,仅当它们是可交换的</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> variant(T&amp; obj, <span class="keywordtype">bool</span> do_swap);<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> move_in(T&amp; obj);<br /><br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> <span class="keywordtype">bool</span> has_type();<br /><br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; _dynamic_cast() <span class="keyword">const</span>;<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; _dynamic_cast();<br /> <br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> current_type_is() <span class="keyword">const</span>;<br />};<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UOP, <span class="keyword">typename</span> Types&gt; <br /> UOP::result_type <a class="code" title="Invokes a generic mutable operation (represented as a unary function object) on a..." href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505">apply_operation</a>(variant&lt;Types&gt;&amp; v, UOP op);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UOP, <span class="keyword">typename</span> Types&gt; <br /> UOP::result_type <a class="code" title="Invokes a generic mutable operation (represented as a unary function object) on a..." href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types&gt;&amp; v, UOP op);<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; <br /> BOP::result_type <a class="code" title="Invokes a generic mutable operation (represented as a unary function object) on a..." href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505">apply_operation</a>( variant&lt;Types1&gt;&amp; v1, variant&lt;Types2&gt;&amp; v2, UOP op);<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; <br /> BOP::result_type <a class="code" title="Invokes a generic mutable operation (represented as a unary function object) on a..." href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types1&gt;&amp; v1, variant&lt;Types2&gt;&amp; v2, UOP op);<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; <br /> BOP::result_type <a class="code" title="Invokes a generic mutable operation (represented as a unary function object) on a..." href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types1&gt;&amp; v1, <span class="keyword">const</span> variant&lt;Types2&gt;&amp; v2, UOP op);<br /></pre>
</div>
<p> GIL的 <code>any_image_view</code> 和 <code>any_image</code>
是 <code>variant</code> 的子类:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ImageViewTypes&gt;<br /><span class="keyword">class </span>any_image_view : <span class="keyword">public</span> variant&lt;ImageViewTypes&gt; {<br /><span class="keyword">public</span>:<br /> <span class="keyword">typedef</span> ... const_t; <span class="comment">// 对应的immutable类型</span><br /><span class="keyword">typedef</span> std::ptrdiff_t x_coord_t;<br /> <span class="keyword">typedef</span> std::ptrdiff_t y_coord_t;<br /> <span class="keyword">typedef</span> point2&lt;std::ptrdiff_t&gt; point_t;<br /><br /> any_image_view();<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image_view(<span class="keyword">const</span> T&amp; obj);<br /> any_image_view(<span class="keyword">const</span> any_image_view&amp; v);<br /><br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; any_image_view&amp; operator=(<span class="keyword">const</span> T&amp; obj);<br /> any_image_view&amp; operator=(<span class="keyword">const</span> any_image_view&amp; v);<br /><br /> <span class="comment">// 当前实例化视图的参数</span><br />std::size_t num_channels() <span class="keyword">const</span>;<br /> point_t dimensions() <span class="keyword">const</span>;<br /> x_coord_t width() <span class="keyword">const</span>;<br /> y_coord_t height() <span class="keyword">const</span>;<br />};<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ImageTypes&gt;<br /><span class="keyword">class </span>any_image : <span class="keyword">public</span> variant&lt;ImageTypes&gt; {<br /> <span class="keyword">typedef</span> variant&lt;ImageTypes&gt; parent_t;<br /><span class="keyword">public</span>:<br /> <span class="keyword">typedef</span> ... const_view_t;<br /> <span class="keyword">typedef</span> ... view_t;<br /> <span class="keyword">typedef</span> std::ptrdiff_t x_coord_t;<br /> <span class="keyword">typedef</span> std::ptrdiff_t y_coord_t;<br /> <span class="keyword">typedef</span> point2&lt;std::ptrdiff_t&gt; point_t;<br /><br /> any_image();<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image(<span class="keyword">const</span> T&amp; obj);<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image(T&amp; obj, <span class="keywordtype">bool</span> do_swap);<br /> any_image(<span class="keyword">const</span> any_image&amp; v);<br /><br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; any_image&amp; operator=(<span class="keyword">const</span> T&amp; obj);<br /> any_image&amp; operator=(<span class="keyword">const</span> any_image&amp; v);<br /><br /> <span class="keywordtype">void</span> recreate(<span class="keyword">const</span> point_t&amp; dims, <span class="keywordtype">unsigned</span> alignment=1);<br /> <span class="keywordtype">void</span> recreate(x_coord_t width, y_coord_t height, <span class="keywordtype">unsigned</span> alignment=1);<br /><br /> std::size_t num_channels() <span class="keyword">const</span>;<br /> point_t dimensions() <span class="keyword">const</span>;<br /> x_coord_t width() <span class="keyword">const</span>;<br /> y_coord_t height() <span class="keyword">const</span>;<br />};<br /></pre>
</div>
<p>对 variants 调用 <code>apply_operation</code>
会执行仿函数指定的操作.variant通过switch语句,在许可类型范围内选择合适的的类型实例化.
因为一般的图像视图算法都至少和像素数目成线性比例, 所以和模板化类型的图像视图相比,
variant类型的图像视图执行单个的switch语句不会造成多少性能开销.</p>
<p>Variants 的行为模式和底层类型是一致的.
它们的拷贝构造会执行底层类型拷贝构造,相等性操作符会检查底层类型的一致性,并在此基础上执行底层类型的 operator==, 等等.
variant的默认构造函数会执行第一个类型(译者注:variant是多个类型的变体)的默认构造.这也意味着 <code>any_image_view</code>
具有浅层的默认构造函数, 拷贝构造函数,赋值运算和相等性检查,而 <code>any_image</code>
则会执行深层的操作.</p>
<p>有一点很重要, 虽然 <code>any_image_view</code> 和 <code>any_image</code>
非常类似于静态的 <code>image_view</code> 和 <code>image</code>,
但是它们并不满足概念 <code>ImageViewConcept</code> 和 <code>ImageConcept</code>的
所有要求. 特别的是,它们没有像素的访问概念, 在GIL中不存在 "any_pixel" 或者 "any_pixel_iterator".
这样的对象可以通过 <code>variant</code> 机制实现, 但是这样做会导致算法的低效,
因为不得不针对每个像素执行类型解析. 图像级别的算法应该通过 <code>apply_operation</code>实
现. 也就是说, 很多通用的操作在静态类型和动态类型之间是共享的. 另外,所有的图像视图变换, 很多的STL形式的算法都针对 <code>any_image_view</code>提
供了重载版本, 就像 <code>copy_pixels</code>一样: </p>
<p></p>
<div class="fragment">
<pre class="fragment">rgb8_view_t v1(...); <span class="comment">// 图像视图实体</span><br />bgr8_view_t v2(...); <span class="comment">// 和v1兼容的图像视图并且具有相同的大小</span><br />any_image_view&lt;Types&gt; av(...); <span class="comment">// 运行时指派的图像视图</span><br /><span class="comment">// 从 v1 拷贝像素到 v2. </span><br /><span class="comment">// 如果像素不兼容,则产生编译错误 </span><br /><a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(v1,v2);<br /><br /><span class="comment">// 源或者目标(或同时二者)可以是运行时实例化的</span><br /><span class="comment">// 如果它们不兼容,则抛出std::bad_cast</span><br /><a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(v1, av);<br /><a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(av, v2);<br /><a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(av, av);<br /></pre>
</div>
<p>基于动态构造的算法重载,我们可以创建适合于编译期和运行期的图像或视图算法. 例如下面的代码,使用GIL
IO扩展,对图像进行上下翻转并且存储到磁盘上:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="preprocessor">#include &lt;boost\gil\extension\io\jpeg_dynamic_io.hpp&gt;</span><br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image&gt; <span class="comment">// </span><span class="comment">可以是 rgb8_image_t 或者 any_image&lt;...&gt;</span><span class="comment"></span><br /><span class="keywordtype">void</span> save_180rot(<span class="keyword">const</span> std::string&amp; file_name) {<br /> Image img;<br /> <a class="code" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name..." href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398">jpeg_read_image</a>(file_name, img);<br /> <a class="code" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg..." href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde">jpeg_write_view</a>(file_name, rotated180_view(<a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(img)));<br />}<br /></pre>
</div>
<p>因为所有的函数都以运行时的构造重载, 所以可以对编译期或运行期的图像实例化. 例如,下面是 <code>rotated180_view</code>
的实现:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 使用模板化视图实现</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <br /><span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type rotated180_view(<span class="keyword">const</span> View&amp; src) { ... }<br /><br /><span class="keyword">namespace </span>detail {<br /> <span class="comment">// 通过仿函数封装函数</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result&gt; <span class="keyword">struct </span>rotated180_view_fn {<br /> <span class="keyword">typedef</span> Result result_type;<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; result_type operator()(<span class="keyword">const</span> View&amp; src)<span class="keyword"> const </span>{ <br /> <span class="keywordflow">return</span> result_type(rotated180_view(src)); <br /> }<br /> };<br />}<br /><br /><span class="comment">// 使用 variant 重载. 以运行时的图像为参数,并且返回运行时的图像.</span><br /><span class="comment">// 返回的图像具有动态的步长 </span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ViewTypes&gt; <span class="keyword">inline</span> <span class="comment">// Models MPL Random Access Container of models of ImageViewConcept</span><br /><span class="keyword">typename</span> dynamic_xy_step_type&lt;any_image_view&lt;ViewTypes&gt; &gt;::type rotated180_view(<span class="keyword">const</span> any_image_view&lt;ViewTypes&gt;&amp; src) { <br /> <span class="keywordflow">return</span> <a class="code" title="Invokes a generic mutable operation (represented as a unary function object) on a..." href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505">apply_operation</a>(src,detail::rotated180_view_fn&lt;<span class="keyword">typename</span> dynamic_xy_step_type&lt;any_image_view&lt;ViewTypes&gt; &gt;::type&gt;()); <br />}<br /></pre>
</div>
<p>Variants
应该谨慎使用(尤其对于使用几个variant为参数的算法),因为对于variant的每个类型,算法都要进行实例化,这可能会带来编译时间和执行文件
大小的膨胀. 除了这些限制, <code>variant</code>是一种强大的技术,它综合利用了编译期解析的速度和
运行期解析的灵活性. 它允许我们把不同参数的图像作为集合以一种同一的方式使用,并且可以存储在同一个容器当中.</p>
<p></p>
<hr />
<h2><a class="anchor" name="MetafunctionsDG">12.
丰富的元函数和 Typedefs</a></h2>
灵活性是有代价的. GIL的类型可能非常的长,难以阅读. 为了解决这个问题, GIL提供了typedefs,指向标准的图像,
像素迭代器,像素定位器,像素引用和像素值.它们的命名遵循下面的模式:
<p><em>ColorSpace</em> + <em>BitDepth</em>
+ ["s|f"] + ["c"] + ["_planar"] + ["_step"] + <em>ClassType</em>
+ "_t" </p>
<p>在这里, <em>ColorSpace</em> 也指示要素的次序, 例如 <code>rgb</code>,
<code>bgr</code>, <code>cmyk</code>, <code>rgba</code>.
<em>BitDepth</em> 可以是<code>8</code>,<code>16</code>,<code>32</code>,
默认的位是无符号整数. 在后面添加 <code>s</code> 指示有符号整数,添加 <code>f</code>
指示浮点数, 添加<code>c</code> 只是相关的像素引用是不可变的. <code>_planar</code>
指示像素的组织方式 planar (相对于 interleaved). <code>_step</code>
指示是动态步长, <em>ClassType</em> 表明是 <code>_image</code>
(图像, 使用标准的分配器), 或者<code>_view</code> (图像视图), 或者<code>_loc</code>
(像素定位器), 或者<code>_ptr</code> (像素迭代器), 或者<code>_ref</code>
(像素引用), <code>_pixel</code> (像素值). 下面是实例:</p>
<p></p>
<div class="fragment">
<pre class="fragment">bgr8_image_t i; <span class="comment">// 8位无符号整数(无符号字节) interleaved BGR 图像</span><br />cmyk16_pixel_t; x; <span class="comment">// 16位无符号整数(无符号short) CMYK 像素值;</span><br />cmyk16sc_planar_ref_t p(x); <span class="comment">// 16位有符号整数(有符号short)planar CMYK的常量引用.</span><br />rgb32f_planar_step_ptr_t ii; <span class="comment">// 基于32位浮点数planar RGB 像素的step 迭代器.</span>
</pre>
</div>
<p>通过指定的通道类型,布局,结构(是planar还是interleaved),迭代步长(是静态步长还是动态步长)和可
变性, GIL 使用元函数获得标准同质的基于内存的构造:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsMutable=true&gt;<br /><span class="keyword">struct </span>pixel_reference_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel, <span class="keyword">typename</span> Layout&gt; <br /><span class="keyword">struct </span>pixel_value_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt;<br /><span class="keyword">struct </span>iterator_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsXStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt;<br /><span class="keyword">struct </span>locator_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsXStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt;<br /><span class="keyword">struct </span>view_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;<br /><span class="keyword">struct </span>image_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keyword">typename</span> ChannelBitSizeVector, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;<br /><span class="keyword">struct </span>packed_image_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelBitSizeVector, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;<br /><span class="keyword">struct </span>bit_aligned_image_type { <span class="keyword">typedef</span> ... type; };<br /></pre>
</div>
<p>还有一些辅助的元函数用来构造packed图像,以及最多5个通道的位对齐图像:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>packed_image1_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>packed_image2_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>packed_image3_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>packed_image4_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <span class="keywordtype">unsigned</span> Size5, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>packed_image5_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>bit_aligned_image1_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2,<br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>bit_aligned_image2_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>bit_aligned_image3_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>bit_aligned_image4_type { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <span class="keywordtype">unsigned</span> Size5, <br /> <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;<br /><span class="keyword">struct </span>bit_aligned_image5_type { <span class="keyword">typedef</span> ... type; };<br /></pre>
</div>
<p>这里的 <code>ChannelValue</code> 是 <code>ChannelValueConcept</code>的
模型. 我们并不需要 <code>IsYStep</code>,因为GIL基于内存的定位器和视图允许动态的指定垂直步
长.迭代器和视图可以从像素类型构造:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt; <br /><span class="keyword">struct </span>iterator_type_from_pixel { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStepX=false, <span class="keywordtype">bool</span> IsMutable=true&gt; <br /><span class="keyword">struct </span>view_type_from_pixel { <span class="keyword">typedef</span> ... type; };<br /></pre>
</div>
<p>同质的像素类型会产生同质的迭代器和视图. 也可以从水平迭代器构造相关类型:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> XIterator&gt; <br /><span class="keyword">struct </span>type_from_x_iterator {<br /> <span class="keyword">typedef</span> ... step_iterator_t;<br /> <span class="keyword">typedef</span> ... xy_locator_t;<br /> <span class="keyword">typedef</span> ... view_t;<br />};<br /></pre>
</div>
<p>还有一些元函数,通过改变指定类型的一个或多个属性创建新的类型:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PixelReference, <br /> <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsMutable&gt;<br /><span class="keyword">struct </span>derived_pixel_reference_type {<br /> <span class="keyword">typedef</span> ... type; <span class="comment">// PixelConcept的模型</span><br />};<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <br /> <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsStep, <span class="keyword">typename</span> IsMutable&gt;<br /><span class="keyword">struct </span>derived_iterator_type {<br /> <span class="keyword">typedef</span> ... type; <span class="comment">// PixelIteratorConcept的模型</span><br />};<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <br /> <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsXStep, <span class="keyword">typename</span> IsMutable&gt;<br /><span class="keyword">struct </span>derived_view_type {<br /> <span class="keyword">typedef</span> ... type; <span class="comment">// ImageViewConcept的模型</span><br />};<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image, <br /> <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar&gt;<br /><span class="keyword">struct </span>derived_image_type {<br /> <span class="keyword">typedef</span> ... type; <span class="comment">// ImageConcept的模型</span><br />};<br /></pre>
</div>
<p>你可以替换一些属性,并使用<code>boost::use_default</code>
保持余下的不变. 上面的<code>IsPlanar</code>, <code>IsStep</code>
和 <code>IsMutable</code> 都是 MPL 的布尔常量. 例如,
下面的代码展示了如何通过改变视图的灰度级和planar,构建新的视图:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">typename</span> derived_view_type&lt;View, boost::use_default, gray_t, mpl::true_&gt;::type VT;<br /></pre>
</div>
<p>通过PixelBasedConcept,
HomogeneousPixelBasedConcept和基于这些概念的元函数,
你可以得到任何基于像素的GIL构造(像素,迭代器,定位器和视图)的相关类型:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>color_space_type { <span class="keyword">typedef</span> ... type; };<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>channel_mapping_type { <span class="keyword">typedef</span> ... type; };<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>is_planar { <span class="keyword">typedef</span> ... type; };<br /><br /><span class="comment">// 通过同质类型定义</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>channel_type { <span class="keyword">typedef</span> ... type; };<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>num_channels { <span class="keyword">typedef</span> ... type; };<br /></pre>
</div>
<p>有一些元函数返回整型型别,可以这样使用:</p>
<p></p>
<div class="fragment">
<pre class="fragment">BOOST_STATIC_ASSERT(is_planar&lt;rgb8_planar_view_t&gt;::value == <span class="keyword">true</span>);<br /></pre>
</div>
<p>GIL 还提供了下列形式的分析型元函数:
[pixel_reference/iterator/locator/view/image] + <code>"_is_"</code>
+ [basic/mutable/step]. 例如:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordflow">if</span> (view_is_mutable&lt;View&gt;::value) {<br /> ...<br />}<br /></pre>
</div>
<p>所谓 <em>基本的</em> GIL 构造是基于内存的构造,
并且使用内建的GIL类型, 解引用的时候也不使用仿函数. 例如, 一个简单的planar 或者 interleaved的图像, step 或者
非step 的RGB 图像是基本的构造, 而基于颜色变换的视图和虚拟视图则不是.</p>
<p></p>
<hr />
<h2><a class="anchor" name="IO_DG">13.
I/O 扩展</a></h2>
GIL的 I/O 扩展提供了提供了低层次的图像i/o设施, 支持几种图像格式的加载和存储, 每一种格式都需要连接相关的库:
<p></p>
<ul>
<li><b>JPEG</b>: 为了使用JPEG 文件, 需要包含文件 <code><a class="el" title="Support for reading and writing JPEG files Requires libjpeg." href="jpeg__io_8hpp.html">gil/extension/io/jpeg_io.hpp</a></code>.
但是如果使用运行期指派的图像, 你需要包含文件<code><a class="el" title="Support for reading and writing JPEG files Requires libjpeg." href="g_i_l_0232.html">gil/extension/io/jpeg_dynamic_io.hpp</a></code><code></code>.
你需要编译并连接库libjpeg.lib (在网站 <a href="http://www.ijg.org">http://www.ijg.org</a>可
以得到). 你需要在包含路径中添加<code>jpeglib.h</code>.</li>
</ul>
<p>
</p>
<ul>
<li><b>TIFF</b>: 为了使用 TIFF 文件,
需要包含文件&nbsp;<code><a class="el" title="Support for reading and writing TIFF files Requires libtiff!" href="tiff__io_8hpp.html">gil/extension/io/tiff_io.hpp</a></code>.
但是如果使用运行期指派的图像, 你需要包含文件&nbsp;<code><a class="el" title="Support for reading and writing TIFF files Requires libtiff!" href="g_i_l_0639.html">gil/extension/io/tiff_dynamic_io.hpp</a></code>.
你需要编译并连接库libtiff.lib (在网站 <a href="http://www.libtiff.org">http://www.libtiff.org</a>).
你需要在包含路径中添加<code>tiffio.h</code>.</li>
</ul>
<p>
</p>
<ul>
<li><b>PNG</b>: 为了使用 PNG 文件, 需要包含文件 <code><a class="el" title="Support for reading and writing PNG files Requires libpng and zlib!" href="png__io_8hpp.html">gil/extension/io/png_io.hpp</a></code>.
但是如果使用运行期指派的图像, 你需要包含文件&nbsp;<code><a class="el" title="Support for reading and writing PNG files Requires libpng and zlib!" href="g_i_l_0251.html">gil/extension/io/png_dynamic_io.hpp</a></code>.
你需要编译并连接库libpng.lib (在网站 <a href="http://www.libpng.org">http://www.libpng.org</a>).
你需要在包含路径中添加<code>png.h</code>.</li>
</ul>
<p>
你并不需要安装所有这些函数库,仅安装你需要的即可.这里是一些针对JPEG I/O的API (使用<code>"tiff"</code>
或者 <code>"png"</code> 替换<code>"jpeg"</code>
即可使用其他的函数库):</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 得到指定路径的JPEG文件的宽度和长度.</span><br /><span class="comment">// 如果指定路径的JPEG文件不合法,则抛出std::ios_base::failure</span><br />point2&lt;std::ptrdiff_t&gt; <a class="code" title="Returns the width and height of the JPEG file at the specified location. Throws std::ios_base::failu..." href="g_i_l_0169.html#g10d06211a2d4ba61145b50cf04f3ad85">jpeg_read_dimensions</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*);<br /><br /><span class="comment">// 按照指定的JPEG文件的维度创建图像,并且加载像素.</span><br /><span class="comment">// 如果JPEG库或者I/O扩展不支持图像的颜色空间和通道深度,会激发编译错误.</span><br /><span class="comment">// 如果指定路径的JPEG文件不合法,或者和图像指定的颜色空间和通道深度不兼容,则抛出std::ios_base::failure. </span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img&gt; <span class="keywordtype">void</span> <a class="code" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name..." href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398">jpeg_read_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;);<br /><br /><span class="comment">// 按照指定的JPEG文件的维度创建图像,并且加载像素,</span><br /><span class="comment">// 如有必要则执行颜色变换和通道变换.</span><br /><span class="comment">// 如果JPEG库或者I/O扩展不支持图像的颜色空间和通道深度,会激发编译错误.</span><br /><span class="comment">// 如果指定路径的JPEG文件不合法,或者发生读文件错误,则抛出std::ios_base::failure.</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img&gt; <span class="keywordtype">void</span> <a class="code" title="Allocates a new image whose dimensions are determined by the given jpeg image file..." href="g_i_l_0169.html#gbe915826a254db40e74e783255b502e4">jpeg_read_and_convert_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img, <span class="keyword">typename</span> CCV&gt; <span class="keywordtype">void</span> <a class="code" title="Allocates a new image whose dimensions are determined by the given jpeg image file..." href="g_i_l_0169.html#gbe915826a254db40e74e783255b502e4">jpeg_read_and_convert_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;, CCV color_converter);<br /><br /><span class="comment">// 按照指定的jpeg文件名称,把图像加载到指定的视图中.</span><br /><span class="comment">// 如果JPEG库或者I/O扩展不支持图像的颜色空间和通道深度,会激发编译错误.</span><br /><span class="comment">// 如果指定路径的JPEG文件不合法,或者和视图指定的颜色空间和通道深度不兼容,或者维度不匹配, 则抛出std::ios_base::failure.</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keywordtype">void</span> <a class="code" title="Loads the image specified by the given jpeg image file name into the given view...." href="g_i_l_0169.html#g4e8ae7c617147cf99f7a2aa37e44f28c">jpeg_read_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);<br /><br /><span class="comment">// 按照指定的jpeg文件名称,把图像加载到指定的视图中,并执行必要的颜色变换(或者通道变换).</span><br /><span class="comment">// 如果JPEG库或者I/O扩展不支持图像的颜色空间和通道深度,会激发编译错误.</span><br /><span class="comment">// 如果指定路径的JPEG文件不合法,或者维度不匹配, 则抛出std::ios_base::failure.</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keywordtype">void</span> <a class="code" title="Loads and color-converts the image specified by the given jpeg image file name into..." href="g_i_l_0169.html#ged18c0f8084bedab8804d2cd1b0b284d">jpeg_read_and_convert_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);<br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> CCV&gt; <span class="keywordtype">void</span> <a class="code" title="Loads and color-converts the image specified by the given jpeg image file name into..." href="g_i_l_0169.html#ged18c0f8084bedab8804d2cd1b0b284d">jpeg_read_and_convert_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;, CCV color_converter);<br /><br /><span class="comment">// 按照指定的名称,把视图存储到jpeg文件中.</span><br /><span class="comment">// 如果JPEG库或者I/O扩展不支持图像的颜色空间和通道深度,会激发编译错误.</span><br /><span class="comment">// 如果存储文件失败,则抛出std::ios_base::failure .</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keywordtype">void</span> <a class="code" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg..." href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde">jpeg_write_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);<br /><br /><span class="comment">// 判断jpeg读取是支持指定的视图类型 </span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">struct </span>jpeg_read_support {<br /> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = ...;<br />};<br /><br /><span class="comment">// 判断jpeg写入是支持指定的视图类型 </span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">struct </span>jpeg_write_support {<br /> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = ...;<br />};<br /></pre>
</div>
<p>如果使用动态图像扩展, 确保包含文件 <code>"jpeg_dynamic_io.hpp"</code>
,而是不是 <code>"jpeg_io.hpp"</code>. 除了上面的方法,对于动态图像还支持下面的重载:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 打开指定的JPEG文件, 选择图像类型中第一个和图像文件类型在颜色空间和通道类型兼容的类型</span><br /><span class="comment">// 按照图像文件的维度创建这种类型的图像.</span><br /><span class="comment">// 如果给定的类型和磁盘文件的类型不兼容,则抛出异常 std::ios_base::failure .</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Images&gt; <span class="keywordtype">void</span> <a class="code" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name..." href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398">jpeg_read_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, any_image&lt;Images&gt;&amp;);<br /><br /><span class="comment">// 按照指定的jpeg文件名, 把当前实例化的视图存储起来.</span><br /><span class="comment">// 如果I/O扩展不支持当前实例化的视图类型,或者创建文件失败,则抛出异常std::ios_base::failure </span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Views&gt; <span class="keywordtype">void</span> <a class="code" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg..." href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde">jpeg_write_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, any_image_view&lt;Views&gt;&amp;);<br /></pre>
</div>
<p>上面所有的方法都对参数 <code>std::string</code> 和 <code>const
char*</code>实现了重载的版本</p>
<p></p>
<hr />
<h2><a class="anchor" name="SampleImgCodeDG">14.
示例代码</a></h2>
<h3><a class="anchor" name="PixelLevelExampleDG">
像素级别的示例代码</a></h3>
下面是一些针对像素,指针和引用类型的操作:
<p></p>
<div class="fragment">
<pre class="fragment">rgb8_pixel_t p1(255,0,0); <span class="comment">// 创建红色的 RGB 像素</span><br />bgr8_pixel_t p2 = p1; <span class="comment">// RGB 和 BGR 是兼容的,通道值也会被恰当的映射. </span><br />assert(p1==p2); <span class="comment">// p2 也是红色的.</span><br />assert(p2[0]!=p1[0]); <span class="comment">// operator[] 得到是通道值的物理次序 (也就是内存次序)</span><br />assert(semantic_at_c&lt;0&gt;(p1)==semantic_at_c&lt;0&gt;(p2)); <span class="comment">// 这是如何比较两个红色通道的方法</span><br /><a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(p1,green_t()) = <a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(p2,blue_t()); <span class="comment">// 通道值也可以通过名称访问</span><br /><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* r;<br /><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* g;<br /><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* b;<br />rgb8c_planar_ptr_t ptr(r,g,b); <span class="comment">// 从每个颜色面的常量指针构造const planar指针</span><br />rgb8c_planar_ref_t ref=*ptr; <span class="comment">// 就像内建的引用类型一样, 对planar指针解引用返回一个planar引用类型</span><br />p2=ref; p2=p1; p2=ptr[7]; p2=rgb8_pixel_t(1,2,3); <span class="comment">// planar/interleaved 的引用和值类型和 RGB/BGR 类型的颜色之间可以自由的混合使用</span><br /><span class="comment">//rgb8_planar_ref_t ref2; // 编译错误: 引用没有默认构造</span><br /><span class="comment">//ref2=*ptr; // 编译错误: 常量指针的解引用不能赋给非常量引用</span><br /><span class="comment">//ptr[3]=p1; // 编译错误: 不能改变常量指针的第4个像素</span><br /><span class="comment">//p1 = pixel&lt;float, rgb_layout_t&gt;();// 编译错误: 不兼容的通道深度</span><br /><span class="comment">//p1 = pixel&lt;bits8, rgb_layout_t&gt;();// 编译错误: 不兼容的颜色空间(虽然那通道数目相同)</span><br /><span class="comment">//p1 = pixel&lt;bits8,rgba_layout_t&gt;();// 编译错误: 不兼容的颜色空间(即使它含有 red, green 和 blue 通道)</span>
</pre>
</div>
<p>下面是泛型代码如何使用像素:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayPixel, <span class="keyword">typename</span> RGBPixel&gt;<br /><span class="keywordtype">void</span> gray_to_rgb(<span class="keyword">const</span> GrayPixel&amp; src, RGBPixel&amp; dst) {<br /> gil_function_requires&lt;PixelConcept&lt;GrayPixel&gt; &gt;(); <br /> gil_function_requires&lt;MutableHomogeneousPixelConcept&lt;RGBPixel&gt; &gt;();<br /><br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;GrayPixel&gt;::type gray_cs_t;<br /> BOOST_STATIC_ASSERT((boost::is_same&lt;gray_cs_t,gray_t&gt;::value));<br /><br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;RGBPixel&gt;::type rgb_cs_t;<br /> BOOST_STATIC_ASSERT((boost::is_same&lt;rgb_cs_t,rgb_t&gt;::value));<br /><br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;GrayPixel&gt;::type gray_channel_t;<br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;RGBPixel&gt;::type rgb_channel_t;<br /><br /> gray_channel_t gray = <a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(src,gray_color_t());<br /> static_fill(dst, channel_convert&lt;rgb_channel_t&gt;(gray));<br />}<br /><br /><span class="comment">// 使用模式的示例:</span><br /><span class="comment">// 把灰度值转换为BGR像素值,这个像素位于16位interleaved图像的(5,5)处:</span><br />bgr16_view_t b16(...);<br />gray_to_rgb(gray8_pixel_t(33), b16(5,5));<br /><span class="comment">// 把8位灰度级图像的第一个像素存储到32位planar RGB 图像的第五个像素处:</span><br />rgb32f_planar_view_t rpv32;<br />gray8_view_t gv8(...);<br />gray_to_rgb(*gv8.begin(), rpv32[5]);<br /></pre>
</div>
<p>正如示例表明的,源和目标的类型都可以是引用或值, planar 或 interleaved,只要他们符合 <code>PixelConcept</code>
和 <code>MutablePixelConcept</code> 的要求.</p>
<h3><a class="anchor" name="SafeAreaExampleDG">使
用安全缓冲区创建图像拷贝 </a></h3>
假定我们要使用多核对图像进行卷积处理,最大的扩充是2K+1 x 2K+1 像素, 这样我们就需要在图像的边界创建K个像素的填充,
下面是它的实现:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="comment">// ImageViewConcept的模型 (源视图)</span><br /><span class="keyword">typename</span> DstImage&gt; <span class="comment">// ImageConcept的模型(返回的图像)</span><br /><span class="keywordtype">void</span> create_with_margin(<span class="keyword">const</span> SrcView&amp; src, <span class="keywordtype">int</span> k, DstImage&amp; result) {<br /> gil_function_requires&lt;ImageViewConcept&lt;SrcView&gt; &gt;();<br /> gil_function_requires&lt;ImageConcept&lt;DstImage&gt; &gt;();<br /> gil_function_requires&lt;ViewsCompatibleConcept&lt;SrcView, typename DstImage::view_t&gt; &gt;();<br /> <br /> result=DstImage(src.width()+2*k, src.height()+2*k);<br /> <span class="keyword">typename</span> DstImage::view_t centerImg=subimage_view(<a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(result), k,k,src.width(),src.height());<br /> <a class="code" title="Copy when both src and dst are interleaved and of the same type can be just memmove..." href="g_i_l_0214.html#gc2faa90ab27d7fb0253d19839c75d341">std::copy</a>(src.begin(), src.end(), centerImg.begin());<br />}<br /></pre>
</div>
<p>我们创建一个更大维度的图像, 然后我们使用 <code>subimage_view</code>
创建一个浅层子视图,左上角位于源视图的(k,k)处,大小和 <code>src</code>一致,最后我们使用 <code>src</code>
拷贝到视图的中央. 如果边界填充需要初始化, 我们可以使用<code>fill_pixels</code>实现.
下面我们使用算法<code>copy_pixels</code>的简化实现:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstImage&gt;<br /><span class="keywordtype">void</span> create_with_margin(<span class="keyword">const</span> SrcView&amp; src, <span class="keywordtype">int</span> k, DstImage&amp; result) {<br /> result.recreate(src.width()+2*k, src.height()+2*k);<br /> <a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(src, subimage_view(<a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(result), k,k,src.width(),src.height()));<br />}<br /></pre>
</div>
<p>(注意到 <code>image::recreate</code>要比<code>operator=</code>高
效很多, 因为后者要执行一个不必要的拷贝构造). 上面的代码不仅适用于不同颜色空间,不同像素深度,不同结构(planar 或者
interleaved)的图像;而且它也是优化的.GIL重写了 <code><span class="el">std::copy</span></code>,
当参数是两个在行末没有填充的相同interleaved的图像的时候,它只是简单的调用 <code>memmove</code>.
对于 planar 图像,对每个通道执行 <code>memmove</code>.
如果两个图像没有填充(我们的情况就是如此),对每行我们尽量调用 <code>memmove</code> .
当其中的一个图像没有填充, 它会使用轻量级的水平迭代器(更加复杂的1维图像迭代器会对每行进行检查). 综合考虑静态和运行时的参数,
它会选择最快的方法.</p>
<h3><a class="anchor" name="HistogramExampleDG">柱
状图</a></h3>
柱状图通过计算每个像素值出现的次数得到. 下面的算法以灰度级图像(一维的)为参数,因为只有灰度级的像素值可以转换为整数:
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayView, <span class="keyword">typename</span> R&gt;<br /><span class="keywordtype">void</span> grayimage_histogram(<span class="keyword">const</span> GrayView&amp; img, R&amp; hist) {<br /> <span class="keywordflow">for</span> (<span class="keyword">typename</span> GrayView::iterator it=img.begin(); it!=img.end(); ++it)<br /> ++hist[*it];<br />}<br /></pre>
</div>
<p>使用 <code>boost::lambda</code> 和 GIL的 <code>for_each_pixel</code>
可以使得我们的算法更紧凑:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayView, <span class="keyword">typename</span> R&gt;<br /><span class="keywordtype">void</span> grayimage_histogram(<span class="keyword">const</span> GrayView&amp; v, R&amp; hist) {<br /> for_each_pixel(v, ++var(hist)[_1]);<br />}<br /></pre>
</div>
<p><code>var</code> 和 <code>_1</code>
都是 <code>boost::lambda</code> 的对象, 并且<code>for_each_pixel</code>
会调用 <code>std::for_each</code> . 为了计算亮度的柱状图,
我们可以使用图像的灰度级视图调用上面的方法:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> R&gt;<br /><span class="keywordtype">void</span> luminosity_histogram(<span class="keyword">const</span> View&amp; v, R&amp; hist) {<br /> grayimage_histogram(color_converted_view&lt;gray8_pixel_t&gt;(v),hist);<br />}<br /></pre>
</div>
<p>可以像下面这样调用这个方法:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hist[256];<br /><a class="code" title="std::fill(I,I,V) with I being a iterator_from_2d" href="g_i_l_0214.html#g718772a47188f4e2ecfce2f28fa3dc4f">std::fill</a>(hist,hist+256,0);<br />luminosity_histogram(my_view,hist);<br /></pre>
</div>
<p>如果我们想查看图像左上角100x100的区域第二个通道的柱状图:</p>
<p></p>
<div class="fragment">
<pre class="fragment">grayimage_histogram(nth_channel_view(subimage_view(img,0,0,100,100),1),hist);<br /></pre>
</div>
<p>在这个过程中, 没有像素的拷贝和额外的内存分配,都是直接操纵源视图的像素, 源视图支持任何的颜色空间和通道深度,
在结构上也可以是planar 或 interleaved的.</p>
<h3><a class="anchor" name="ImageViewsExampleDG">使
用图像视图</a></h3>
下面的代码说明了使用图像视图的威力:
<p></p>
<div class="fragment">
<pre class="fragment"><a class="code" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name..." href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398">jpeg_read_image</a>(<span class="stringliteral">"monkey.jpg"</span>, img);<br />step1=<a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(img);<br />step2=subimage_view(step1, 200,300, 150,150);<br />step3=color_converted_view&lt;rgb8_view_t,gray8_pixel_t&gt;(step2);<br />step4=rotated180_view(step3);<br />step5=subsampled_view(step4, 2,1);<br /><a class="code" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg..." href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde">jpeg_write_view</a>(<span class="stringliteral">"monkey_transform.jpg"</span>, step5);<br /></pre>
</div>
<p>这些图像的结果是: </p>
<div align="center"><img src="monkey_steps.jpg" alt="monkey_steps.jpg" />
</div>
<p>
注意到这里没有像素的拷贝,所有的工作都施加在 <code>jpeg_write_view</code>上面.
如果我们针对<code>step5</code>调用<code>luminosity_histogram</code>,
结果也是正确的.</p>
<p></p>
<hr />
<h2><a class="anchor" name="ExtendingGIL_DG">15.
扩展GIL</a></h2>
你可以定义自己的像素迭代器,定位器,图像视图,图像,通道类型,颜色空间和算法. 虚拟的图像可以位于磁盘上, jpeg文件中,
internet中的某个地方,或者是完全合成的图像,例如 Mandelbrot 集合, 只要他们满足相关的概念要求,
它们就可以使用已有的GIL算法.绝大多数这样的扩展并不需要改变已有的代码, 这些扩展也可以在其他的模块当中.
<h3><a class="anchor" name="NewColorSpacesDG">定
义新的颜色空间</a></h3>
每个颜色空间位于一个单独的文件当中. 为了添加一个新的颜色空间, 只需要拷贝文件 (参见 <a class="el" title="Support for RGB color space and variants." href="rgb_8hpp.html">rgb.hpp</a>) , 并修改相关的部分即可.
如果你需要颜色变换的支持,你需要定义新的颜色空间和已有的颜色空间之间的变换函数(参见 color_convert.h). 为了方便,
你需要位新的颜色的空间定义像素,指针,引用和视图的typedef (参见 typedefs.h).
<h3><a class="anchor" name="NewChannelsDG">定
义新的通道类型</a></h3>
绝大多数的情况下你不需要定义新的通道类型, 你仅是使用它们而已:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">typedef</span> pixel&lt;double,rgb_layout_t&gt; rgb64_pixel_t; <span class="comment">// 64 位 RGB 像素 </span><br /><span class="keyword">typedef</span> rgb64_pixel* rgb64_pixel_ptr_t;<span class="comment">// 指向64位 interleaved 的数据</span><br /><span class="keyword">typedef</span> image_type&lt;double,rgb_layout_t&gt;::type rgb64_image_t; <span class="comment">// 64W位interleaved 图像</span>
</pre>
</div>
<p>如果你想定义自己的通道类型, 你需要为它提供类型<code>channel_traits</code>
的特化版本 (参见 <a class="el" title="Channel utilities." href="channel_8hpp.html">channel.hpp</a>).
如果你需要在新的通道类型和已有的通道类型之间进行转换, 你需要定义函数<code>channel_convert</code>的
重载版本.</p>
<h3><a class="anchor" name="NewColorConversionDG">重
载颜色变换</a></h3>
假如你需要定义自己的颜色变换, 例如,你需要使用颜色配置文件实现更高质量的颜色变换. 一般情况下, 你只是会在某些特殊的情况下重定义颜色变换,
而其他的情况则使用GIL的默认实现. 下面是一个颜色变换重载的示例, 在灰度图的时候使用自定义颜色变换, 而其他情况保持不变:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 使用 GIL 的默认的实现 </span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcColorSpace, <span class="keyword">typename</span> DstColorSpace&gt;<br /><span class="keyword">struct </span>my_color_converter_impl<br /> : <span class="keyword">public</span> default_color_converter_impl&lt;SrcColorSpace,DstColorSpace&gt; {};<br /><br /><span class="comment">// 你只要定义自己需要的特化实现</span><br /><span class="comment">// (在这里,如果目标是灰度级的图像,就进行翻转)</span><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcColorSpace&gt;<br /><span class="keyword">struct </span>my_color_converter_impl&lt;SrcColorSpace,gray_t&gt; {<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcP, <span class="keyword">typename</span> DstP&gt; <span class="comment">// Model PixelConcept</span><br /> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> SrcP&amp; src, DstP&amp; dst)<span class="keyword"> const </span>{<br /> default_color_converter_impl&lt;SrcColorSpace,gray_t&gt;()(src,dst);<br /> <a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(dst,gray_color_t())=<a class="code" title="Default implementation. Provide overloads for performance." href="g_i_l_0101.html#ge2e0267865f89610ef26148874a04bb5">channel_invert</a>(<a class="code" title="Mutable accessor to the element associated with a given color name." href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">get_color</a>(dst,gray_color_t()));<br /> }<br />};<br /><br /><span class="comment">// 创建一个颜色变换对象,用在自定义的实现当中</span><br /><span class="keyword">struct </span>my_color_converter {<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcP, <span class="keyword">typename</span> DstP&gt; <span class="comment">// PixelConcept的模型</span><br /><span class="keywordtype">void</span> operator()(<span class="keyword">const</span> SrcP&amp; src,DstP&amp; dst)<span class="keyword"> const </span>{ <br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;SrcP&gt;::type SrcColorSpace;<br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;DstP&gt;::type DstColorSpace;<br /> my_color_converter_impl&lt;SrcColorSpace,DstColorSpace&gt;()(src,dst);<br /> }<br />};<br /></pre>
</div>
<p>GIL的颜色变换函数使用颜色变换器对象作为可选的参数, 在这里你可以选择自己的颜色变换器对象:</p>
<p></p>
<div class="fragment">
<pre class="fragment">color_converted_view&lt;gray8_pixel_t&gt;(img_view,my_color_converter());<br /></pre>
</div>
<h3><a class="anchor" name="NewImagesDG">定
义新的图像视图</a></h3>
通过定义像素序列获取的机制, 或者通过解引用进行像素变换, 你就可以定义自己的像素迭代器,定位器和视图. 例如, 让我们查看这个函数<code>color_converted_view</code>
(一个图像工厂方法, 通过一个指定的图像视图,返回一个新的同样的视图, 只是在像素访问上进行了颜色变换)的实现. 首先我们要定义一个<code>PixelDereferenceAdaptorConcept</code>的
模型; 是一个在对像素迭代器进行解引用的时候调用的仿函数. 调用<code>color_convert</code>
转换为目标像素类型:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcConstRefP, <span class="comment">// 源像素的常量引用 </span><br /><span class="keyword"> typename</span> DstP&gt; <span class="comment"> // 目标像素值(PixelValueConcept的模型)</span><br /><span class="keyword">class </span>color_convert_deref_fn {<br /><span class="keyword">public</span>:<br /> <span class="keyword">typedef</span> color_convert_deref_fn const_t;<br /> <span class="keyword">typedef</span> DstP value_type;<br /> <span class="keyword">typedef</span> value_type reference; <span class="comment">// read-only dereferencing</span><br /> <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;<br /> <span class="keyword">typedef</span> SrcConstRefP argument_type;<br /> <span class="keyword">typedef</span> reference result_type;<br /> BOOST_STATIC_CONSTANT(<span class="keywordtype">bool</span>, is_mutable=<span class="keyword">false</span>);<br /><br /> result_type operator()(argument_type srcP)<span class="keyword"> const </span>{<br /> result_type dstP;<br /> <a class="code" title="helper function for converting one pixel to another using GIL default color-converters..." href="g_i_l_0178.html#gaa258d34eafbf9d9e34a2a2ad6131af2">color_convert</a>(srcP,dstP);<br /> <span class="keywordflow">return</span> dstP;<br /> }<br />};<br /></pre>
</div>
<p>通过调用图像视图的成员函数<code>add_deref</code>,在像素解引用的时候
执行仿函数(类型是<code>deref_t</code>),我们可以构造新的图像视图. 在这里,
仿函数执行的就是颜色变换:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstP&gt;<br /><span class="keyword">struct </span>color_converted_view_type {<br /><span class="keyword">private</span>:<br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> SrcView::const_t::reference src_pix_ref; <span class="comment">// SrcView像素的常量引用</span><br /><span class="keyword">typedef</span> color_convert_deref_fn&lt;src_pix_ref, DstP&gt; deref_t; <span class="comment">// 执行颜色变换的解引用适配器</span><br /><span class="keyword">typedef</span> <span class="keyword">typename</span> SrcView::template add_deref&lt;deref_t&gt; add_ref_t;<br /><span class="keyword">public</span>:<br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> add_ref_t::type type; <span class="comment">// 颜色变换后的视图类型</span><br /><span class="keyword">static</span> type make(<span class="keyword">const</span> SrcView&amp; sv) { <span class="keywordflow">return</span> add_ref_t::make(sv, deref_t()); }<br />};<br /></pre>
</div>
<p>最后我们的函数 <code>color_converted_view</code>
就可以简单从源视图构造一个经过颜色变换的视图:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DstP, <span class="keyword">typename</span> View&gt; <span class="keyword">inline</span><br /><span class="keyword">typename</span> color_converted_view_type&lt;View,DstP&gt;::type color_convert_view(<span class="keyword">const</span> View&amp; src) {<br /> <span class="keywordflow">return</span> color_converted_view_type&lt;View,DstP&gt;::make(src);<br />}<br /></pre>
</div>
<p>(实际的颜色变换有一点复杂,因为虽然允许用户指定颜色变换的仿函数,但是这个参数是可选的). 参见GIL教程,
那里有一个通过定义Mandelbrot集创建虚拟图像视图的示例.</p>
<p></p>
<hr />
<h2><a class="anchor" name="TechnicalitiesDG">16.
专门技术</a></h2>
<h3><a class="anchor" name="CreatingReferenceProxyDG">
创建引用代理</a></h3>
有时候需要创建一个代理类, 用来表示一个指定对象的引用. 这方面的例子是GIL的planar型别的像素引用(<code>planar_pixel_reference</code>)
和 GIL的通道引用子类型.书写这样的一个代理类需要一些技巧. 其问题之一就是, 迭代器解引用的返回值是一个引用代理,这是一个临时对象:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">struct </span>rgb_planar_pixel_iterator {<br /> <span class="keyword">typedef</span> my_reference_proxy&lt;T&gt; reference;<br /> reference operator*()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> reference(red,green,blue); }<br />};<br /></pre>
</div>
<p>当一个函数以可变像素为参数,而传入这样一个迭代器解引用生成的临时对象的时候,问题就出现了:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel&gt; <span class="comment">// MutablePixelConcept的模型</span><br /><span class="keywordtype">void</span> invert_pixel(Pixel&amp; p);<br /><br />rgb_planar_pixel_iterator myIt;<br />invert_pixel(*myIt); <span class="comment">// 编译错误!</span>
</pre>
</div>
<p>C++ 并不允许对临时对象进行非常量引用,解决的方法是:</p>
<ul>
<li>对所有的引用代理对象使用const修饰符:</li>
</ul>
<p>
</p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<br /><span class="keyword">struct </span>my_reference_proxy {<br /> <span class="keyword">const</span> my_reference_proxy&amp; operator=(<span class="keyword">const</span> my_reference_proxy&amp; p) <span class="keyword">const</span>;<br /> <span class="keyword">const</span> my_reference_proxy* operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; }<br /> ...<br />};<br /></pre>
</div>
<p></p>
<ul>
<li>使用不同的型别指示不可变的和常量的引用(或者基于模板参数的常量性)</li>
</ul>
<p>
</p>
<ul>
<li>使用常量修饰符定义迭代器的引用类型:</li>
</ul>
<p>
</p>
<div class="fragment">
<pre class="fragment"><span class="keyword">struct </span>iterator_traits&lt;rgb_planar_pixel_iterator&gt; {<br /> <span class="keyword">typedef</span> <span class="keyword">const</span> my_reference_proxy&lt;T&gt; reference;<br />};<br /></pre>
</div>
<p>第二个重要的问题是需要为<code>swap</code>提供针对你的引用类的重载版本,
默认的 <code>std::swap</code> 不会正确的执行, 你必须使用一个真正的值类型作为临时对象.
一个更加复杂的问题是在有些STL的实现中, 函数<code>swap</code> 不能正确合法的调用,
唯一的措施就是在<code>std</code>命名空间中重载这个方法: </p>
<div class="fragment">
<pre class="fragment"><span class="keyword">namespace </span>std {<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<br /> <span class="keywordtype">void</span> swap(my_reference_proxy&lt;T&gt;&amp; x, my_reference_proxy&lt;T&gt;&amp; y) {<br /> my_value&lt;T&gt; tmp=x;<br /> x=y;<br /> y=tmp;<br /> }<br />}<br /></pre>
</div>
<p>最后一点要记住, 代理引用的构造函数和拷贝构造都是浅拷贝的,而赋值运算符是深拷贝的.</p>
<p>对于上面的解决方案的建议者,Dave Abrahams, Sean Parent 和 Alex ,我们表示感谢.</p>
<p></p>
<hr />
<h2><a class="anchor" name="ConclusionDG">17.
结论</a></h2>
要记住GIL有以下5个设计目标:
<p></p>
<ul>
<li><b> 泛型.</b> 从图像算法的角度抽象图像的表现,
这使得代码只需要书写一次就适用于所有的图像类型. </li>
<li><b> 效率.</b> 速度是库设计的基础.
库提供的泛型算法在很多情况下,其速度可以和针对某种特定图像格式的手写代码相媲美. </li>
<li><b> 灵活性.</b> 编译期参数解析的速度很快,
但是代码的灵活性受到严重的限制, GIL允许参数在运行时解析, 这只是带来很小的性能损失. </li>
<li><b> 可扩展性.</b>
实际上GIL的每个构造都是可扩展的,只要符合GIL概念的要求, 就可以构造新的通道类型, 颜色空间,布局,迭代器,定位器,图像视图和图像. </li>
<li><b> 兼容性.</b> GIL设计为STL的一个补充.
像素处理可以使用STL的算法, 并且也特别的做了针对性的优化. GIL可以和已有图像库导入的裸像素数据一起工作.</li>
</ul>
<p></p><div id="footer" title="footer: links to copyright and other legal information"><a href="licenses.html" class="el">Copyright © 2005 Adobe Systems Incorporated</a><ul id="list1">
<li id="terms">
<a href="http://www.adobe.com/misc/copyright.html" title="Terms of Use">Terms of Use</a></li>
<li>
<a href="http://www.adobe.com/misc/privacy.html" title="Privacy Policy">Privacy Policy</a></li>
<li>
<a href="http://access.adobe.com">Accessibility</a></li>
<li>
<a href="http://www.adobe.com/aboutadobe/antipiracy/main.html" title="Avoid software piracy">Avoid software piracy</a></li>
<li id="tms">
<a href="http://www.adobe.com/misc/agreement.html" title="Permissions and trademarks">Permissions and trademarks</a></li>
<li>
<a href="http://www.adobe.com/products/eulas/main.html" title="Product License Agreements">Product License Agreements</a></li>
</ul>
</div> 
<hr size="1" /><address style="text-align: right;"><small>Generated on Sat May 2 13:50:16 2009 for Generic Image Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.5.6 </small></address>
</td>
</tr>
</tbody>
</table>
</body></html>
<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  --
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://opensource.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://opensource.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>GIL  : 设计指南</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=utf8"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="opensource.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<!-- End Header -->
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="GILDesignGuide">GIL设计指南</a></h1><dl compact><dt><b>作者:</b></dt><dd>Lubomir Bourdev (<a href="mailto:lbourdev@adobe.com">lbourdev@adobe.com</a>) and Hailin Jin (<a href="mailto:hljin@adobe.com">hljin@adobe.com</a>) <br>
 Adobe 系统公司 </dd></dl>
<dl compact><dt><b>版本:</b></dt><dd>2.1 </dd></dl>
<dl compact><dt><b>日期:</b></dt><dd>September 15, 2007</dd></dl>
<p>
GIL是一个从算法角度抽象图像接口的C++函数库,本文档描述了GIL的设计理念. 本文档的内容远远超过了如何简单使用GIL所需要的知识. 在GIL的主页上,你可以找到一个快速的起点 <a href="http://opensource.adobe.com/gil">http://opensource.adobe.com/gil</a><p>
<ul>
<li><a class="el" href="gildesignguide.html#OverviewSectionDG">1. 概述</a></li><li><a class="el" href="gildesignguide.html#ConceptsSectionDG">2. 关于概念</a></li><li><a class="el" href="gildesignguide.html#PointSectionDG">3. 点</a></li><li><a class="el" href="gildesignguide.html#ChannelSectionDG">4. 通道</a></li><li><a class="el" href="gildesignguide.html#ColorSpaceSectionDG">5. 颜色空间和布局</a></li><li><a class="el" href="gildesignguide.html#ColorBaseSectionDG">6. 颜色基</a></li><li><a class="el" href="gildesignguide.html#PixelSectionDG">7. 像素</a></li><li><a class="el" href="gildesignguide.html#PixelIteratorSectionDG">8. 像素迭代器</a><ul>
<li><a class="el" href="gildesignguide.html#FundamentalIteratorDG">基本迭代器</a></li><li><a class="el" href="gildesignguide.html#IteratorAdaptorDG">迭代适配器</a></li><li><a class="el" href="gildesignguide.html#PixelDereferenceAdaptorAG">像素解引用适配器</a></li><li><a class="el" href="gildesignguide.html#StepIteratorDG">Step Iterator</a></li><li><a class="el" href="gildesignguide.html#LocatorDG">像素定位器</a></li><li><a class="el" href="gildesignguide.html#IteratorFrom2DDG">2维图像迭代器</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#ImageViewSectionDG">9. 图像视图</a><ul>
<li><a class="el" href="gildesignguide.html#ImageViewFrowRawDG">从裸像素创建视图</a></li><li><a class="el" href="gildesignguide.html#ImageViewFrowImageViewDG">从其他的图像视图创建视图</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#ImageSectionDG">10. Image</a></li><li><a class="el" href="gildesignguide.html#VariantSecDG">11. 运行时指派的图像和图像视图</a></li><li><a class="el" href="gildesignguide.html#MetafunctionsDG">12. 丰富的元函数和Typedefs</a></li><li><a class="el" href="gildesignguide.html#IO_DG">13. I/O 扩展</a></li><li><a class="el" href="gildesignguide.html#SampleImgCodeDG">14. 示例代码</a><ul>
<li><a class="el" href="gildesignguide.html#PixelLevelExampleDG">像素级别示例代码</a></li><li><a class="el" href="gildesignguide.html#SafeAreaExampleDG">从安全缓冲区创建的视图拷贝</a></li><li><a class="el" href="gildesignguide.html#HistogramExampleDG">柱状图</a></li><li><a class="el" href="gildesignguide.html#ImageViewsExampleDG">使用视图</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#ExtendingGIL_DG">15. 扩展GIL</a><ul>
<li><a class="el" href="gildesignguide.html#NewColorSpacesDG">定义新的颜色空间</a></li><li><a class="el" href="gildesignguide.html#NewColorConversionDG">重载颜色变换</a></li><li><a class="el" href="gildesignguide.html#NewChannelsDG">定义新的颜色通道类型</a></li><li><a class="el" href="gildesignguide.html#NewImagesDG">定义新的图像视图</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#TechnicalitiesDG">16. 专门技术</a></li><li><a class="el" href="gildesignguide.html#ConclusionDG">17. 结论</a></li></ul>
<p>
<br>
 <hr>
 <h2><a class="anchor" name="OverviewSectionDG">
1. 概述</a></h2>
在任何图像处理的工程项目中,例如视觉和视频处理,图像都是很基本的概念. 但是图像在表现上的千差万别使其算法代码很难既通用又高效. 在本节中,我们将描述一些我们面对的挑战.<p>在下面的讨论中,图像将被视为像素的一个2维数组. 像素是一个颜色通道的集合, 代表图像中给定点的颜色. 每个通道代表颜色组件的一个值. 存在两种通用的图像内存结构. Interleaved图像, 其像素分组连续, 通道是间隔存储的, 而planar图像, 不同的通道在不同的颜色面上. 下面是一个4x3 RGB 类型的图像,第一行的第二个像素被标记为红色, 是 interleaved 类型的:<p>
<div align="center">
<img src="interleaved.jpg" alt="interleaved.jpg">
</div>
 而这个是planar类型的:<p>
<div align="center">
<img src="planar.jpg" alt="planar.jpg">
</div>
<p>
要注意可能的行对齐导致的每行末的空白填充. <p>
GIL提供的图像模型可以应对如下的变化:<ul>
<li>结构性(planar 和 interleaved)</li><li>颜色空间和alpha表示 (RGB, RGBA, CMYK, 等等.)</li><li>颜色通道深度 (8-位, 16-位, 等等.)</li><li>通道的次序(RGB 和 BGR, 等等.)</li><li>行对齐策略 (没有对齐,字对齐, 等等.)</li></ul>
<p>
GIL还支持用户定义的图像模型,以及参数在运行时指定的图像类型. GIL从算法的角度抽象了图像的表现, 这样我们只需书写一次代码, 就可以使之工作在以上不同的图像变体上, 而其生成可执行代码的速度,可以和针对特定图像类型的手写代码相媲美.<p>
本文档遵循自低向上的设计原则. 每节定义的概念建立在上节定义的概念之上. 推荐你按照节的次序阅读本文档.<p>
<hr>
 <h2><a class="anchor" name="ConceptsSectionDG">
2. 关于概念</a></h2>
所有的GIL构造都是GIL概念的模型. 概念是为了泛型算法正确应用,一个类型(或者一组相关类型)必须满足的一组条件. 这些条件包括语法形式和算法运算. 例如,GIL的类型 <code>pixel</code> 是 GIL概念 PixelConcept的模型. 用户可以使用自己的类型替换<code>pixel</code> 类型, 只要它能够满足Pixe <code>PixelConcept</code>lConcept的要求, 所有其他的GIL 类型和算法都可以使用. 这里有更多概念的信息 <a href="http://www.generic-programming.org/languages/conceptcpp/">http://www.generic-programming.org/languages/conceptcpp/</a><p>
In我们将使用语法形式定义概念,这是C++0x 标准定义的一个关于概念的扩展: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2081.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2081.pdf</a><p>
这里有更多的GIL使用的概念的定义,绝大部分都在这里: <a href="http://www.generic-programming.org/languages/conceptcpp/concept_web.php">http://www.generic-programming.org/languages/conceptcpp/concept_web.php</a><p>
<div class="fragment"><pre class="fragment"><span class="keyword">auto</span> concept DefaultConstructible&lt;typename T&gt; {
    T::T();    
};

<span class="keyword">auto</span> concept CopyConstructible&lt;typename T&gt; {
    T::T(T);
    T::~T();
};

<span class="keyword">auto</span> concept Assignable&lt;typename T, typename U = T&gt; {
    <span class="keyword">typename</span> result_type;
    result_type operator=(T&amp;, U);    
};

<span class="keyword">auto</span> concept EqualityComparable&lt;typename T, typename U = T&gt; {
    <span class="keywordtype">bool</span> operator==(T x, T y);    
    <span class="keywordtype">bool</span> operator!=(T x, T y) { <span class="keywordflow">return</span> !(x==y); }
};

concept SameType&lt;typename T, typename U&gt; {  unspecified  };
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; concept_map SameType&lt;T, T&gt; {  unspecified  };

<span class="keyword">auto</span> concept Swappable&lt;typename T&gt; {
    <span class="keywordtype">void</span> swap(T&amp; t, T&amp; u);
};
</pre></div><p>
这里是附加的GIL需要的基本概念:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">auto</span> concept Regular&lt;typename T&gt; : DefaultConstructible&lt;T&gt;, CopyConstructible&lt;T&gt;, EqualityComparable&lt;T&gt;, Assignable&lt;T&gt;, Swappable&lt;T&gt; {};

<span class="keyword">auto</span> concept Metafunction&lt;typename T&gt; {
    <span class="keyword">typename</span> type;
};
</pre></div><h2><a class="anchor" name="PointSectionDG">
3. Point</a></h2>
一个点定义了图像中像素的位置, 它也可以用来描述图像的维度. 从最通用的角度来说, 点是N-维的,满足下列概念的模型:<p>
<div class="fragment"><pre class="fragment">concept PointNDConcept&lt;typename T&gt; : Regular&lt;T&gt; {    
    <span class="comment">// 每个轴的坐标定义</span>
    <span class="keyword">template</span> &lt;size_t K&gt; <span class="keyword">struct </span>axis; where Metafunction&lt;axis&gt;;
            
    <span class="keyword">const</span> size_t num_dimensions;
    
    <span class="comment">// 访问/修改 每个轴的数值.</span>
    <span class="keyword">template</span> &lt;size_t K&gt; <span class="keyword">const</span> <span class="keyword">typename</span> axis&lt;K&gt;::type&amp; T::axis_value() <span class="keyword">const</span>;
    <span class="keyword">template</span> &lt;size_t K&gt;       <span class="keyword">typename</span> axis&lt;K&gt;::type&amp; T::axis_value();
};
</pre></div><p>
GIL 使用2维点, 它是概念 <code>PointNDConcept</code> 的一个强化,要求每维数据类型必须是相同的:<p>
<div class="fragment"><pre class="fragment">concept Point2DConcept&lt;typename T&gt; : PointNDConcept&lt;T&gt; {    
    where num_dimensions == 2;
    where SameType&lt;axis&lt;0&gt;::type, axis&lt;1&gt;::type&gt;;

    <span class="keyword">typename</span> value_type = axis&lt;0&gt;::type;

    <span class="keyword">const</span> value_type&amp; operator[](<span class="keyword">const</span> T&amp;, size_t i);
          value_type&amp; operator[](      T&amp;, size_t i);

    value_type x,y;
};
</pre></div><p>
<b>相关概念:</b><p>
<ul>
<li>PointNDConcept&lt;T&gt;</li><li>Point2DConcept&lt;T&gt;</li></ul>
<p>
<b>模型:</b><p>
GIL 提供了 <code>Point2DConcept</code>的一个模型<code>point2&lt;T&gt;</code>,其中<code>T</code> 是一个坐标类型. .<p>
<hr>
 <h2><a class="anchor" name="ChannelSectionDG">
4. 通道</a></h2>
通道指示了颜色组件的强度(例如, RGB像素的红色通道). 典型的通道操作包括获取,比较和设置通道的值. 通道有最大和最小值.GIL的通道是下面概念的模型:<p>
<div class="fragment"><pre class="fragment">concept ChannelConcept&lt;typename T&gt; : EqualityComparable&lt;T&gt; {
    <span class="keyword">typename</span> value_type      = T;        <span class="comment">// 使用 channel_traits&lt;T&gt;::value_type 访问</span>
       where ChannelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> reference       = T&amp;;       <span class="comment">// 使用 channel_traits&lt;T&gt;::reference 访问</span>
    <span class="keyword">typename</span> pointer         = T*;       <span class="comment">// 使用 channel_traits&lt;T&gt;::pointer 访问</span>
    <span class="keyword">typename</span> const_reference = <span class="keyword">const</span> T&amp;; <span class="comment">// 使用 channel_traits&lt;T&gt;::const_reference 访问</span>
    <span class="keyword">typename</span> const_pointer   = <span class="keyword">const</span> T*; <span class="comment">// 使用 channel_traits&lt;T&gt;::const_pointer 访问</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_mutable;        <span class="comment">// 使用 channel_traits&lt;T&gt;::is_mutable 访问</span>

    <span class="keyword">static</span> T min_value();                <span class="comment">// 使用 channel_traits&lt;T&gt;::min_value 访问</span>
    <span class="keyword">static</span> T max_value();                <span class="comment">// 使用 channel_traits&lt;T&gt;::min_value 访问</span>
};

concept MutableChannelConcept&lt;ChannelConcept T&gt; : Swappable&lt;T&gt;, Assignable&lt;T&gt; {};

concept ChannelValueConcept&lt;ChannelConcept T&gt; : Regular&lt;T&gt; {}; 
</pre></div><p>
GIL运行使用内建的整型和浮点型作为通道的类型. 因此其相关型别和范围信息可以使用<code>channel_traits</code> 定义, 获得默认的实现:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct </span>channel_traits {
    <span class="keyword">typedef</span> T         value_type;
    <span class="keyword">typedef</span> T&amp;        reference;
    <span class="keyword">typedef</span> T*        pointer;
    <span class="keyword">typedef</span> T&amp; <span class="keyword">const</span>  const_reference;
    <span class="keyword">typedef</span> T* <span class="keyword">const</span>  const_pointer;
    
    <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> std::numeric_limits&lt;T&gt;::min(); }
    <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> std::numeric_limits&lt;T&gt;::max(); }
};
</pre></div><p>
如果通道具有相同的值类型,那么它们就是兼容的<p>
<div class="fragment"><pre class="fragment">concept ChannelsCompatibleConcept&lt;ChannelConcept T1, ChannelConcept T2&gt; {
    where SameType&lt;T1::value_type, T2::value_type&gt;;
};
</pre></div><p>
一个通道类型可以转换其他的通道类型:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;ChannelConcept Src, ChannelValueConcept Dst&gt;
concept ChannelConvertibleConcept {
    Dst <a class="code" href="http://opensource.adobe.com/gil/html/group___channel_convert_algorithm.html#ga0">channel_convert</a>(Src);
};
</pre></div><p>
注意到 <code>ChannelConcept</code> 和 <code>MutableChannelConcept</code>并不需要默认构造函数. 支持默认构造函数的类型(也就构成所谓的正规型别)是概念code>ChannelValueConcept</code>的模型. 为了理解这个差别, 考虑一个16位RGB像素类型,是"565" 位模式. 通道模式和位区间一致. 为了支持这样的通道类型, 我们需要创建代理引用类来支持它. 这样的代理引用类是概念<code>ChannelConcept</code的模型, 但是和本地的C++ 引用一样, 它没有默认构造函数.<p>
注意到算法可能需要对通道类型施加更多的要求,例如需要支持算术运算.<p>
<b>相关概念:</b><p>
<ul>
<li>ChannelConcept&lt;T&gt;</li><li>ChannelValueConcept&lt;T&gt;</li><li>MutableChannelConcept&lt;T&gt;</li><li>ChannelsCompatibleConcept&lt;T1,T2&gt;</li><li>ChannelConvertibleConcept&lt;SrcChannel,DstChannel&gt;</li></ul>
<p>
<b>模型:</b><p>
所有内建的整型和浮点型都是有效的通道类型, GIL提供了一些整型通道的类型标准定义:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> boost::uint8_t  bits8;
<span class="keyword">typedef</span> boost::uint16_t bits16;
<span class="keyword">typedef</span> boost::uint32_t bits32;
<span class="keyword">typedef</span> boost::int8_t   bits8s;
<span class="keyword">typedef</span> boost::int16_t  bits16s;
<span class="keyword">typedef</span> boost::int32_t  bits32s;
</pre></div><p>
基于内建型别通道类型的最大值和最小值, 和这些内建型别的物理值范围一致,也即通过<code>std::numeric_limits</code>指定的最大值和最小值. 有时候物理值范围是不适合的. GIL提供了<code>scoped_channel_value</code>, 是通道适配器的一个模型, 允许定制值的范围. 我们可以用它来定义 [0..1]范围内浮点通道类型:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>float_zero { <span class="keyword">static</span> <span class="keywordtype">float</span> apply() { <span class="keywordflow">return</span> 0.0f; } };
<span class="keyword">struct </span>float_one  { <span class="keyword">static</span> <span class="keywordtype">float</span> apply() { <span class="keywordflow">return</span> 1.0f; } };
<span class="keyword">typedef</span> scoped_channel_value&lt;float,float_zero,float_one&gt; bits32f;
</pre></div><p>
GIL 还同了和位域范围一致的模型定义:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 通道的值范围通过NumBits 定义, 是ChannelValueConcept的模型</span>
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NumBits&gt; <span class="keyword">class </span>packed_channel_value;

<span class="comment">// 通道的值范围通过NumBits 定义的引用, 是ChannelConcept的模型</span>
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> FirstBit, 
          <span class="keywordtype">int</span> NumBits,       <span class="comment">// 定义包含通道值的序列位 </span>
          <span class="keywordtype">bool</span> Mutable&gt;      <span class="comment">// 如果引用可修改则为true  </span>
<span class="keyword">class </span>packed_channel_reference;

<span class="comment">// 通道的值范围通过NumBits 定义的引用,FirstBit 是运行时参数. 它是ChannelConcept的模型</span>
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NumBits,       <span class="comment">// 定义包含通道值的序列位 </span>
          <span class="keywordtype">bool</span> Mutable&gt;      <span class="comment">// 如果引用可修改则为true </span>
<span class="keyword">class </span>packed_dynamic_channel_reference;
</pre></div><p>
注意到这两种引用代理的模型是不易昂的, 它们的区别在于通道值范围的偏移是通过模板参数定义的还是通过运行时参数定义的. 第一种模型更快,更紧凑;第二种则更灵活. 例如第二种允许我们通过通道的位域构造迭代器.<p>
<b>算法:</b><p>
下面是如何构造三类16位"565" 模式的像素类型, 然后设置其最大值的算法:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> packed_channel_reference&lt;0,5,true&gt; channel16_0_5_reference_t;
<span class="keyword">typedef</span> packed_channel_reference&lt;5,6,true&gt; channel16_5_6_reference_t;
<span class="keyword">typedef</span> packed_channel_reference&lt;11,5,true&gt; channel16_11_5_reference_t;

boost::uint16_t data=0;
channel16_0_5_reference_t   channel1(&amp;data);
channel16_5_6_reference_t   channel2(&amp;data);
channel16_11_5_reference_t  channel3(&amp;data);

channel1=channel_traits&lt;channel16_0_5_reference_t&gt;::max_value();
channel2=channel_traits&lt;channel16_5_6_reference_t&gt;::max_value();
channel3=channel_traits&lt;channel16_11_5_reference_t&gt;::max_value();
assert(data==65535);
</pre></div><p>
赋值,相等比较和拷贝构造只是在兼容的类型之间有效:<p>
<div class="fragment"><pre class="fragment">packed_channel_value&lt;5&gt; channel_6bit = channel1;
channel_6bit = channel3;

<span class="comment">//channel_6bit = channel2; // 编译错误: 在不兼容通道类型之间赋值.</span>
</pre></div><p>
GIL所有的通道模型都是可以成对转换的:<p>
<div class="fragment"><pre class="fragment">channel1 = channel_traits&lt;channel16_0_5_reference_t&gt;::max_value();
assert(channel1 == 31);

bits16 chan16 = channel_convert&lt;bits16&gt;(channel1);
assert(chan16 == 65535);
</pre></div><p>
通道转换是一个松散的操作, GIL的通道转换是一个在源通道范围到目标通道范围的线性变换. 这样的变换能够准确的在最大值和最小值之间进行映射(例如,从uint8_t到uint16_t的转换,GIL并没有进行位移操作,因为那样不能在最值之间正确转换,而是乘以257).<p>
GIL所有的通道类型都可以从整型到浮点型进行转换,所以它们只有算数运算,下面是GIL提供的通道级别的算法:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 从源通道值转换为目标通道值,在范围之内进行线性映射</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> DstChannel, <span class="keyword">typename</span> SrcChannel&gt;
<span class="keyword">typename</span> channel_traits&lt;DstChannel&gt;::value_type <a class="code" href="http://opensource.adobe.com/gil/html/group___channel_convert_algorithm.html#ga0">channel_convert</a>(SrcChannel src);

<span class="comment">// 返回最大值 - x + min_value</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel&gt;
<span class="keyword">typename</span> channel_traits&lt;Channel&gt;::value_type <a class="code" href="http://opensource.adobe.com/gil/html/group___channel_invert_algorithm.html#ga0">channel_invert</a>(Channel x);

<span class="comment">// 返回 a * b / max_value</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel&gt;
<span class="keyword">typename</span> channel_traits&lt;Channel&gt;::value_type <a class="code" href="http://opensource.adobe.com/gil/html/group___channel_multiply_algorithm.html#ga0">channel_multiply</a>(Channel a, Channel b);
</pre></div><p>
<hr>
 <h2><a class="anchor" name="ColorSpaceSectionDG">
5. 颜色空间和布局</a></h2>
一个颜色空间表示组成像素颜色通道的解释和集合. 颜色空间是这个空间内所有要素类型的一个MPL随机访问的容器.两个颜色空间相等(例如,在相同的次序下是相同的颜色集)的,那么就认为它们是兼容的.<p>
<b>关联概念:</b><p>
<ul>
<li>ColorSpaceConcept&lt;ColorSpace&gt;</li><li>ColorSpacesCompatibleConcept&lt;ColorSpace1,ColorSpace2&gt;</li><li>ChannelMappingConcept&lt;Mapping&gt;</li></ul>
<p>
<b>模型:</b><p>
GIL 当前支持如下的颜色空间: <code>gray_t</code>, <code>rgb_t</code>, <code>rgba_t</code>, 和 <code>cmyk_t</code>. GIL还支持未命名的2到5个通道的颜色空间, <code>devicen_t&lt;2&gt;</code>, <code>devicen_t&lt;3&gt;</code>, <code>devicen_t&lt;4&gt;</code>, <code>devicen_t&lt;5&gt;</code>. 除了这些标准的布局,GIL还支持 <code>bgr_layout_t</code>, <code>bgra_layout_t</code>, <code>abgr_layout_t</code> 和 <code>argb_layout_t</code>.<p>
作为一个例子,下面的代码说明了GIL如何定义RGBA 颜色空间:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>red_t{};
<span class="keyword">struct </span>green_t{};
<span class="keyword">struct </span>blue_t{};
<span class="keyword">struct </span>alpha_t{};
<span class="keyword">typedef</span> mpl::vector4&lt;red_t,green_t,blue_t,alpha_t&gt; rgba_t;
</pre></div><p>
颜色空间内颜色通道的次序指定了它们的语义次序. 例如<code>red_t</code> 就是 <code>rgba_t</code>的第一个语义通道.虽然颜色空间内通道的语义次序是唯一的, 但是它们的物理存储次序可以不同. 通道的次序通过 <code>ChannelMappingConcept</code> 指定, 它是一个MPL的整型随机访问容器. 颜色空间和位置映射经常仪器使用, 因此GIL把它们组合在一起使用:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorSpace, 
          <span class="keyword">typename</span> ChannelMapping = mpl::range_c&lt;int,0,mpl::size&lt;ColorSpace&gt;::value&gt; &gt;
<span class="keyword">struct </span>layout {
    <span class="keyword">typedef</span> ColorSpace      color_space_t;
    <span class="keyword">typedef</span> ChannelMapping  channel_mapping_t;
};
</pre></div><p>
下面的代码说明了如何创建 RGBA 的颜色空间:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> layout&lt;rgba_t&gt; rgba_layout_t; <span class="comment">// 默认的次序是 0,1,2,3...</span>
<span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,2,1,0,3&gt; &gt; bgra_layout_t;
<span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,1,2,3,0&gt; &gt; argb_layout_t;
<span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,3,2,1,0&gt; &gt; abgr_layout_t;
</pre></div><p>
<hr>
 <h2><a class="anchor" name="ColorBaseSectionDG">
6. 颜色基</a></h2>
颜色基是颜色元素的容器. 颜色基最通常的使用场景是作为像素的实现, 这样颜色基的元素就是颜色通道的值. 但是颜色基的概念还可以使用在其他的场景中. 例如, plannar 像素的颜色通道不是连续存储的, 它的引用是通过代理类实现的, 这个代理的颜色基元素类型是通道引用. planar像素迭代器也是使用颜色基实现的, 而其元素类型是通道迭代器.<p>
Color base models must satisfy the following concepts:<p>
<div class="fragment"><pre class="fragment">concept ColorBaseConcept&lt;typename T&gt; : CopyConstructible&lt;T&gt;, EqualityComparable&lt;T&gt; {
    <span class="comment">// GIL 布局 (颜色空间和元素排列)</span>
    <span class="keyword">typename</span> layout_t;
        
    <span class="comment">//  K-个元素的类型</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_type;
        where Metafunction&lt;kth_element_type&gt;;
    
    <span class="comment">// at_c的结果类型</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_const_reference_type;
        where Metafunction&lt;kth_element_const_reference_type&gt;;        
    
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; kth_element_const_reference_type&lt;T,K&gt;::type at_c(T);
    
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        T::T(T2);
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T2&amp;);
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T2&amp;);

};

concept MutableColorBaseConcept&lt;ColorBaseConcept T&gt; : Assignable&lt;T&gt;, Swappable&lt;T&gt; {
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_reference_type;
        where Metafunction&lt;kth_element_reference_type&gt;;

    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; kth_element_reference_type&lt;T,K&gt;::type at_c(T);
    
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        T&amp; operator=(T&amp;, <span class="keyword">const</span> T2&amp;);
};

concept ColorBaseValueConcept&lt;typename T&gt; : MutableColorBaseConcept&lt;T&gt;, Regular&lt;T&gt; {
};

concept HomogeneousColorBaseConcept&lt;ColorBaseConcept CB&gt; {
    <span class="comment">// 对于所有的在区间[0 ... size&lt;C1&gt;::value-1)中的K:</span>
    <span class="comment">//     满足是相同类型 SameType&lt;kth_element_type&lt;K&gt;::type, kth_element_type&lt;K+1&gt;::type&gt;;    </span>
    kth_element_const_reference_type&lt;0&gt;::type dynamic_at_c(<span class="keyword">const</span> CB&amp;, std::size_t n) <span class="keyword">const</span>;
};

concept MutableHomogeneousColorBaseConcept&lt;MutableColorBaseConcept CB&gt; : HomogeneousColorBaseConcept&lt;CB&gt; {
    kth_element_reference_type&lt;0&gt;::type dynamic_at_c(<span class="keyword">const</span> CB&amp;, std::size_t n);
};

concept HomogeneousColorBaseValueConcept&lt;typename T&gt; : MutableHomogeneousColorBaseConcept&lt;T&gt;, Regular&lt;T&gt; {
};

concept ColorBasesCompatibleConcept&lt;ColorBaseConcept C1, ColorBaseConcept C2&gt; {
    where SameType&lt;C1::layout_t::color_space_t, C2::layout_t::color_space_t&gt;;
    <span class="comment">// 同样, 对于在区间[0 ... size&lt;C1&gt;::value)的所有K:</span>
    <span class="comment">//     是可转换的 Convertible&lt;kth_semantic_element_type&lt;C1,K&gt;::type, kth_semantic_element_type&lt;C2,K&gt;::type&gt;;</span>
    <span class="comment">//     也是可转换的 Convertible&lt;kth_semantic_element_type&lt;C2,K&gt;::type, kth_semantic_element_type&lt;C1,K&gt;::type&gt;;</span>
};
</pre></div><p>
颜色基必须具有相关的颜色布局类型(包括颜色空间和颜色通道的次序). 有两种方法对颜色基的要素进行索引访问: 一种是通过对存储位置上的物理索引值,一种是通过要素在颜色空间上的语义索引值. 例如, RGB 颜色空间的的次序是{red_t, green_t, blue_t}. 而对于 BGR 的颜色布局, 其物理排序的第一个索引值绿色, 而第一个语义要素是红色. 概念 <code>ColorBaseConcept</code> 的模型必须提供函数 <code>at_c&lt;K&gt;(ColorBase)</code> ,允许按照物理次序访问要素. GIL 还提供了函数 <code>semantic_at_c&lt;K&gt;(ColorBase)</code> (以后再描述) 对概念 ColorBaseConcept 的模型进行操作,返回相关的语义要素.<p>
如果两种颜色基的颜色空间是相等的, 并且其要素类型是可以转换的,那么它们就是兼容的.<p>
<b>Models:</b><p>
GIL 提供了同质颜色基概念(它们的要素类型都是相同的)的模型.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>detail {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> Layout, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>homogeneous_color_base;
}
</pre></div><p>
作为GIL像素的实现, planar像素引用和planer像素迭代器使用它们. 概念<code>ColorBaseConcept</code> 的两外一个模型是<code>packed_pixel</code> - 它的像素通道是位域, 参见 <a class="el" href="gildesignguide.html#PixelSectionDG">7. Pixel</a> .<p>
<b>算法:</b><p>
GIL 为颜色基提供了以下的函数和元函数:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 以 mpl::int_形式返回颜色基元素个数的元函数</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase&gt; <span class="keyword">struct </span>size;

<span class="comment">// 函数 semantic_at_c&lt;K&gt;(color_base)的返回类型</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_semantic_element_reference_type;
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_semantic_element_const_reference_type;

<span class="comment">// 得到元素第 K 个语义索引的引用.</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; 
<span class="keyword">typename</span> kth_semantic_element_reference_type&lt;ColorBase,K&gt;::type       <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_semantic_at_c.html#ga0">semantic_at_c</a>(ColorBase&amp; p) 
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; 
<span class="keyword">typename</span> kth_semantic_element_const_reference_type&lt;ColorBase,K&gt;::type <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_semantic_at_c.html#ga0">semantic_at_c</a>(<span class="keyword">const</span> ColorBase&amp; p) 

<span class="comment">// 得到函数 get_color&lt;Color&gt;(color_base)返回值的类型</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Color, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>color_reference_t;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Color, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>color_const_reference_t;

<span class="comment">// 返回给定颜色的元素索引</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; 
<span class="keyword">typename</span> color_reference_t&lt;Color,ColorBase&gt;::type <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(ColorBase&amp; cb, Color=Color());
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; 
<span class="keyword">typename</span> color_const_reference_t&lt;Color,ColorBase&gt;::type <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(<span class="keyword">const</span> ColorBase&amp; cb, Color=Color());

<span class="comment">// 颜色基的元素类型,只为同质的颜色基定义</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_type;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_reference_type;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_const_reference_type;
</pre></div><p>
GIL 还提供了操作颜色基的下列函数,注意它们都是语义成对排列:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 对应于标准库的 std::equal, std::copy, std::fill, std::generate</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2&gt;   <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> CB1&amp; p1, <span class="keyword">const</span> CB2&amp; p2);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Src,<span class="keyword">typename</span> Dst&gt;   <span class="keywordtype">void</span> static_copy(<span class="keyword">const</span> Src&amp; src, Dst&amp; dst);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB, <span class="keyword">typename</span> Op&gt;    <span class="keywordtype">void</span> static_generate(CB&amp; dst,Op op);

<span class="comment">// 对应于标准库的 std::transform</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB ,             <span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(      CB&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB ,             <span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(      CB1&amp;,      CB2&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,Dst&amp;,Op); 

<span class="comment">// 对应于标准库的 std::for_each</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,                          <span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,                          <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,      CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,      CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,      CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 

<span class="comment">// 下列函数只是适用于同质的颜色基:</span>
<span class="comment">// 对应于标准库的 std::fill</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB, <span class="keyword">typename</span> Element&gt; <span class="keywordtype">void</span> static_fill(HCB&amp; p, <span class="keyword">const</span> Element&amp; v);

<span class="comment">// 对应于标准库的 std::min_element 和 std::max_element</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_const_reference_type&lt;HCB&gt;::type static_min(<span class="keyword">const</span> HCB&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_reference_type&lt;HCB&gt;::type       static_min(      HCB&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_const_reference_type&lt;HCB&gt;::type static_max(<span class="keyword">const</span> HCB&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_reference_type&lt;HCB&gt;::type       static_max(      HCB&amp;);
</pre></div><p>
这些算法是仿照STL定义的, 但是它们不是以迭代器区间位参数,而是以颜色基和要素位参数. 另外这些算法通过编译器递归实现的(因此以"static_"位前缀). 最后,这些算法访问要素是以语义索引而不是物理存储索引. 例如, 下面是<code>static_equal:</code> 的一个实现 <p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>detail {
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>element_recursion {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
    <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) { 
        <span class="keywordflow">return</span> element_recursion&lt;K-1&gt;::static_equal(p1,p2) &amp;&amp;
               <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_semantic_at_c.html#ga0">semantic_at_c</a>&lt;K-1&gt;(p1)==<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_semantic_at_c.html#ga0">semantic_at_c</a>&lt;N-1&gt;(p2); 
    }
};
<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>element_recursion&lt;0&gt; {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
    <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp;, <span class="keyword">const</span> P2&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
};
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
<span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) {
    gil_function_requires&lt;ColorSpacesCompatibleConcept&lt;P1::layout_t::color_space_t,P2::layout_t::color_space_t&gt; &gt;(); 
    <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_equal(p1,p2); 
}    
</pre></div><p>
在两个像素上调用操作符 <code>operator==</code> 的时候会启动这个算法. 使用语义索引会正确的比较RGB和BGR像素. 注意到如果算法有两个或者以上的颜色基参数,那么它们必须属于相同的颜色空间.<p>
<hr>
 <h2><a class="anchor" name="PixelSectionDG">
7. 像素</a></h2>
一个像素就是在图像给定点的颜色通道集合. 从概念上说,因为像素的元素类型是<code>ChannelConcept</code>的模型,所以像素是必颜色基更严格的类型. 像素的所有属性都继承自颜色基: 如果所有的通道类型一致,那么像素就是同质的;否则是异质的. 像素的通道值可以通过语义值和物理值索引,或者通过颜色索引. 所有颜色基的算法都适用于像素. 如果像素的颜色空间相同,并且颜色通道语义上兼容,那么两个像素类型也被认为是兼容的. 注意到常量性, 内存组织以及引用/值等特点是被有意忽略的. 例如,一个8位planar的RGB引用和一个常量interleaved的BGR像素值在型别上是兼容的. 绝大多数的成对像素操作(copy构造,赋值,相等性等等)只在兼容的像素类型之间有效.<p>
像素 (还有其他基于像素的GIL构造,例如迭代器,定位器,视图和图像)必须提供相关的元函数访问其颜色空间,通道映射,通道个数以及通道(同质的通道)类型 :<p>
<div class="fragment"><pre class="fragment">concept PixelBasedConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> color_space_type&lt;T&gt;;     
        where Metafunction&lt;color_space_type&lt;T&gt; &gt;;
        where ColorSpaceConcept&lt;color_space_type&lt;T&gt;::type&gt;;
    <span class="keyword">typename</span> channel_mapping_type&lt;T&gt;; 
        where Metafunction&lt;channel_mapping_type&lt;T&gt; &gt;;  
        where ChannelMappingConcept&lt;channel_mapping_type&lt;T&gt;::type&gt;;
    <span class="keyword">typename</span> is_planar&lt;T&gt;;
        where Metafunction&lt;is_planar&lt;T&gt; &gt;;
        where SameType&lt;is_planar&lt;T&gt;::type, <span class="keywordtype">bool</span>&gt;;
};

concept HomogeneousPixelBasedConcept&lt;PixelBasedConcept T&gt; {
    <span class="keyword">typename</span> channel_type&lt;T&gt;;         
        where Metafunction&lt;channel_type&lt;T&gt; &gt;;
        where ChannelConcept&lt;channel_type&lt;T&gt;::type&gt;;
};
</pre></div><p>
像素是下列概念的模型:<p>
<div class="fragment"><pre class="fragment">concept PixelConcept&lt;typename P&gt; : ColorBaseConcept&lt;P&gt;, PixelBasedConcept&lt;P&gt; {    
    where is_pixel&lt;P&gt;::type::value==<span class="keyword">true</span>;
    <span class="comment">// 对于每个 K [0..size&lt;P&gt;::value-1]:</span>
    <span class="comment">//      满足概念 ChannelConcept&lt;kth_element_type&lt;K&gt; &gt;;</span>
        
    <span class="keyword">typename</span> value_type;       where PixelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> reference;        where PixelConcept&lt;reference&gt;;
    <span class="keyword">typename</span> const_reference;  where PixelConcept&lt;const_reference&gt;;
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> P::is_mutable;

    <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } 
        P::P(P2);
    <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } 
        <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> P&amp;, <span class="keyword">const</span> P2&amp;);
    <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } 
        <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> P&amp;, <span class="keyword">const</span> P2&amp;);
}; 

concept MutablePixelConcept&lt;typename P&gt; : PixelConcept&lt;P&gt;, MutableColorBaseConcept&lt;P&gt; {
    where is_mutable==<span class="keyword">true</span>;
};

concept HomogeneousPixelConcept&lt;PixelConcept P&gt; : HomogeneousColorBaseConcept&lt;P&gt;, HomogeneousPixelBasedConcept&lt;P&gt; { 
    P::template element_const_reference_type&lt;P&gt;::type operator[](P p, std::size_t i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dynamic_at_c(P,i); }
};

concept MutableHomogeneousPixelConcept&lt;MutablePixelConcept P&gt; : MutableHomogeneousColorBaseConcept&lt;P&gt; { 
    P::template element_reference_type&lt;P&gt;::type operator[](P p, std::size_t i) { <span class="keywordflow">return</span> dynamic_at_c(p,i); }
};

concept PixelValueConcept&lt;typename P&gt; : PixelConcept&lt;P&gt;, Regular&lt;P&gt; {
    where SameType&lt;value_type,P&gt;;
};    

concept PixelsCompatibleConcept&lt;PixelConcept P1, PixelConcept P2&gt; : ColorBasesCompatibleConcept&lt;P1,P2&gt; {
    <span class="comment">// 对于每个 K [0..size&lt;P1&gt;::value):</span>
    <span class="comment">//    满足概念 ChannelsCompatibleConcept&lt;kth_semantic_element_type&lt;P1,K&gt;::type, kth_semantic_element_type&lt;P2,K&gt;::type&gt;;</span>
};
</pre></div><p>
如果一个像素可以使用另外一个像素的颜色空间来近似表示,那么就记忆认为两个像素之间是可以转换的. 转换是显式的,非对称的并且属于有损操作(这是由于颜色空间和颜色通道的近似模拟造成的). 转换需要下列概念的模型:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;PixelConcept SrcPixel, MutablePixelConcept DstPixel&gt;
concept PixelConvertibleConcept {
    <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___pixel_algorithm.html#ga0">color_convert</a>(<span class="keyword">const</span> SrcPixel&amp;, DstPixel&amp;);
};
</pre></div><p>
概念 <code>PixelConcept</code> 和 <code>PixelValueConcept</code> 之间的区别和通道和颜色基的是一样的-像素引用代理是二者的模型, 而只有像素值是后者的模型.<p>
<b>相关概念:</b><p>
<ul>
<li>PixelBasedConcept&lt;P&gt;</li><li>PixelConcept&lt;Pixel&gt;</li><li>MutablePixelConcept&lt;Pixel&gt;</li><li>PixelValueConcept&lt;Pixel&gt;</li><li>HomogeneousPixelConcept&lt;Pixel&gt;</li><li>MutableHomogeneousPixelConcept&lt;Pixel&gt;</li><li>HomogeneousPixelValueConcept&lt;Pixel&gt;</li><li>PixelsCompatibleConcept&lt;Pixel1,Pixel2&gt;</li><li>PixelConvertibleConcept&lt;SrcPixel,DstPixel&gt;</li></ul>
<p>
<b>模型:</b><p>
最常用的像素是同质像素, 其值连续存储在一起. 为了这个目的, GIL提供了结构 <code>pixel</code>, 以通道值和布局为参数:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 是 HomogeneousPixelValueConcept的模型</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout&gt; <span class="keyword">struct </span>pixel;

<span class="comment">// GIL提供的 typedefs </span>
<span class="keyword">typedef</span> pixel&lt;bits8, rgb_layout_t&gt; rgb8_pixel_t;
<span class="keyword">typedef</span> pixel&lt;bits8, bgr_layout_t&gt; bgr8_pixel_t;

bgr8_pixel_t bgr8(255,0,0);     <span class="comment">// 喜爱能告诉可以直接通过通道值初始化</span>
rgb8_pixel_t rgb8(bgr8);        <span class="comment">// 兼容像素之间可以相互copy构造</span>

rgb8 = bgr8;            <span class="comment">// 兼容像素之间可以相互赋值和比较相等</span>
assert(rgb8 == bgr8);   <span class="comment">// 按照语义通道赋值和比较</span>

<span class="comment">// 两个像素之间的物理通道值是不同的</span>
assert(at_c&lt;0&gt;(rgb8) != at_c&lt;0&gt;(bgr8));
assert(dynamic_at_c(bgr8,0) != dynamic_at_c(rgb8,0));
assert(rgb8[0] != bgr8[0]); <span class="comment">// 同上 (  只是为像素定义了operator[])</span>
</pre></div><p>
planar 像素的通道值分布存储. 它们共享同样的值类型 (<code>pixel</code>) , 它们的引用类型是一个代理类, 包含指向每个通道的引用. 下面是结构 <code>planar_pixel_reference:</code>的实现 <p>
<div class="fragment"><pre class="fragment"><span class="comment">// 是 HomogeneousPixel的模型</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelReference, <span class="keyword">typename</span> ColorSpace&gt; <span class="keyword">struct </span>planar_pixel_reference;

<span class="comment">// 定义可变和只读引用. (GIL已经提供了这些 typedefs )</span>
<span class="keyword">typedef</span> planar_pixel_reference&lt;      bits8&amp;,rgb_t&gt; rgb8_planar_ref_t;
<span class="keyword">typedef</span> planar_pixel_reference&lt;const bits8&amp;,rgb_t&gt; rgb8c_planar_ref_t;
</pre></div><p>
注意到, 和结构 <code>pixel</code> 不一样, planar 像素引用是以颜色空间,而不是以像素布局位么把那参数的. 它们总是具有一致的通道次序. 它们内部的元素次序没有必要,因为它们是指向通道的引用.<p>
有时候像素的通道不是字节对齐的. 例如'5-5-6' 模式的RGB像素是16位的,其 red, green 和 blue 通道分别占据[0..4],[5..9] 和 [10..15].GIL 提供了这种紧凑的像素格式的定义:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 定义 rgb565 像素类型</span>
<span class="keyword">typedef</span> packed_pixel_type&lt;uint16_t, mpl::vector3_c&lt;unsigned,5,6,5&gt;, rgb_layout_t&gt;::type rgb565_pixel_t;

function_requires&lt;PixelValueConcept&lt;rgb565_pixel_t&gt; &gt;();
BOOST_STATIC_ASSERT((<span class="keyword">sizeof</span>(rgb565_pixel_t)==2));

<span class="comment">// 定义bgr556 像素类型</span>
<span class="keyword">typedef</span> packed_pixel_type&lt;uint16_t, mpl::vector3_c&lt;unsigned,5,6,5&gt;, bgr_layout_t&gt;::type bgr556_pixel_t;

function_requires&lt;PixelValueConcept&lt;bgr556_pixel_t&gt; &gt;();

<span class="comment">// rgb565 和 bgr556是兼容的.</span>
function_requires&lt;PixelsCompatibleConcept&lt;rgb565_pixel_t,bgr556_pixel_t&gt; &gt;();
</pre></div><p>
有时候,像素自身不是字节对齐的. 例如, 考虑格式为RGB '2-3-2' 模式的像素, 其位长为7. GIL 使用'位对齐'的模式引用这种类型的像素,像素迭代器和图像. 位对齐的像素(还有图像)要比紧凑的格式复杂很多. 因为紧凑格式的像素是字节对齐的, 我们以C++引用类型的方式使用一个紧凑格式的像素, 并以C式指针作为x_iterator遍历一行紧凑格式的像素. 对于位对齐格式,我们需要一个特殊类型的引用代理类(bit_aligned_pixel_reference)和一个特殊类型的迭代器类(bit_aligned_pixel_iterator). 位对齐格式的像素值类型是packed_pixel. 下面说明如何使用位对齐的像素和像素迭代器:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 可变的 BGR232 像素引用类型 </span>
<span class="keyword">typedef</span> <span class="keyword">const</span> bit_aligned_pixel_reference&lt;mpl::vector3_c&lt;unsigned,2,3,2&gt;, bgr_layout_t, <span class="keyword">true</span>&gt;  bgr232_ref_t;

<span class="comment">// 可变的 BGR232 像素迭代器</span>
<span class="keyword">typedef</span> bit_aligned_pixel_iterator&lt;bgr232_ref_t&gt; bgr232_ptr_t;

<span class="comment">// BGR232 像素值类型. 它是一个1个字节 packed_pixel . (最后一位没有使用)</span>
<span class="keyword">typedef</span> std::iterator_traits&lt;bgr232_ptr_t&gt;::value_type bgr232_pixel_t; 
BOOST_STATIC_ASSERT((<span class="keyword">sizeof</span>(bgr232_pixel_t)==1));

bgr232_pixel_t red(0,0,3); <span class="comment">// = 0RRGGGBB, = 01100000 = 0x60</span>

<span class="comment">// 7字节的缓冲区恰好容纳8个 BGR232 类型的像素 .</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pix_buffer[7];    
<a class="code" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga4">std::fill</a>(pix_buffer,pix_buffer+7,0);

<span class="comment">// 使用红色填充8个像素</span>
bgr232_ptr_t pix_it(&amp;pix_buffer[0],0);  <span class="comment">// 从第一个像素的0位开始</span>
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8; ++i) {
    *pix_it++ = red;
}
<span class="comment">// 结果是: 0x60 0x30 0x11 0x0C 0x06 0x83 0xC1</span>
</pre></div><p>
<b>算法:</b><p>
既然像素是概念 <code>ColorBaseConcept</code> 和 <code>PixelBasedConcept</code> 的模型,所有适用于这两个概念的算法也都适用于像素:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 如何访问第一个语义通道(红色)</span>
assert(semantic_at_c&lt;0&gt;(rgb8) == semantic_at_c&lt;0&gt;(bgr8));

<span class="comment">// 如何通过名字访问红色通道</span>
assert(get_color&lt;red_t&gt;(rgb8) == get_color&lt;red_t&gt;(bgr8));

<span class="comment">// 另外一种实现方式(有些编译器不喜欢第一种方式)</span>
assert(<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(rgb8,red_t()) == <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(bgr8,red_t()));

<span class="comment">// 如何使用元函数 PixelBasedConcept </span>
BOOST_MPL_ASSERT(num_channels&lt;rgb8_pixel_t&gt;::value == 3);
BOOST_MPL_ASSERT((is_same&lt;channel_type&lt;rgb8_pixel_t&gt;::type, bits8&gt;));
BOOST_MPL_ASSERT((is_same&lt;color_space_type&lt;bgr8_pixel_t&gt;::type, rgb_t&gt; ));
BOOST_MPL_ASSERT((is_same&lt;channel_mapping_type&lt;bgr8_pixel_t&gt;::type, mpl::vector3_c&lt;int,2,1,0&gt; &gt; ));

<span class="comment">// 像素只是包含3个通道,别的就没了 </span>
BOOST_MPL_ASSERT(<span class="keyword">sizeof</span>(rgb8_pixel_t)==3);

rgb8_planar_ref_t ref(bgr8);    <span class="comment">// 兼容可变的像素类型之间是可以copy构造的 </span>

get_color&lt;red_t&gt;(ref) = 10;     <span class="comment">// 可变的引用是可以赋值的</span>
assert(get_color&lt;red_t&gt;(bgr8)==10);  <span class="comment">// 通过引用改变了绑定的值 </span>

<span class="comment">// 创建一个0冗余的 packed 像素和一个完全正规的 unpacked 像素.</span>
rgb565_pixel_t r565;
rgb8_pixel_t rgb_full(255,255,255);

<span class="comment">// 把unpacked像素的所有通道转换为packed形式, 并且断言packed像素的数值</span>
<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(r565,red_t())   = channel_convert&lt;rgb565_channel0_t&gt;(<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(rgb_full,red_t()));
<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(r565,green_t()) = channel_convert&lt;rgb565_channel1_t&gt;(<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(rgb_full,green_t()));
<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(r565,blue_t())  = channel_convert&lt;rgb565_channel2_t&gt;(<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(rgb_full,blue_t()));
assert(r565 == rgb565_pixel_t((uint16_t)65535));    
</pre></div><p>
GIL 还提供了  <code>color_convert</code> 算法, 用于不同颜色空间和通道类型之间的像素转换:<p>
<div class="fragment"><pre class="fragment">rgb8_pixel_t red_in_rgb8(255,0,0);
cmyk16_pixel_t red_in_cmyk16;
<a class="code" href="http://opensource.adobe.com/gil/html/group___pixel_algorithm.html#ga0">color_convert</a>(red_in_rgb8,red_in_cmyk16);
</pre></div><p>
<hr>
 <h2><a class="anchor" name="PixelIteratorSectionDG">
8. 像素迭代器 </a></h2>
<h2><a class="anchor" name="FundamentalIteratorDG">
基本迭代器 </a></h2>
像素迭代器是随机访问迭代器, 它的  <code>value_type</code> 是概念 <code>PixelValueConcept</code>的模型. 像素迭代器提供了元函数访问其可变性(例如, 是否允许修改像素的值), 得到只读像素的类型, 以及它们是普通迭代器还是迭代器适配器:<p>
<div class="fragment"><pre class="fragment">concept PixelIteratorConcept&lt;RandomAccessTraversalIteratorConcept Iterator&gt; : PixelBasedConcept&lt;Iterator&gt; {
    where PixelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> const_iterator_type&lt;It&gt;::type;         
        where PixelIteratorConcept&lt;const_iterator_type&lt;It&gt;::type&gt;;
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span>  iterator_is_mutable&lt;It&gt;::type::value;          
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span>  is_iterator_adaptor&lt;It&gt;::type::value;   <span class="comment">// 是否是适配器</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
concept MutablePixelIteratorConcept : PixelIteratorConcept&lt;Iterator&gt;, MutableRandomAccessIteratorConcept&lt;Iterator&gt; {};
</pre></div><p>
<b>相关概念 :</b><p>
<ul>
<li>PixelIteratorConcept&lt;Iterator&gt;</li><li>MutablePixelIteratorConcept&lt;Iterator&gt;</li></ul>
<p>
<b>模型:</b><p>
GIL通过内建的像素指针 <code>pixel&lt;ChannelValue,Layout&gt;*</code>表示interleaved 同质像素迭代器的模型; 同样, 通过<code>packed_pixel&lt;PixelData,ChannelRefVec,Layout&gt;*</code> 表示interleaved packed 像素的模型.<p>
对于 planar 同质像素,GIL通过模板化参数通道迭代器和颜色空间的类<code>planar_pixel_iterator</code>实现. 下面是使用unsigned char定义mutable和只读planar类型的RGB迭代器:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelPtr, <span class="keyword">typename</span> ColorSpace&gt; <span class="keyword">struct </span>planar_pixel_iterator;

<span class="comment">// GIL 提供的 typedefs</span>
<span class="keyword">typedef</span> planar_pixel_iterator&lt;const bits8*, rgb_t&gt; rgb8c_planar_ptr_t;
<span class="keyword">typedef</span> planar_pixel_iterator&lt;      bits8*, rgb_t&gt; rgb8_planar_ptr_t;
</pre></div><p>
因为<code>planar_pixel_iterator</code> 是概念 <code>HomogeneousColorBaseConcept</code>的模型 (是 <code>homogeneous_color_base</code>的子类型) , 所以基于颜色基的算法搜适用于它.它的颜色基元素类型是通道迭代器. 例如, GIL实现planar迭代器的大体方式是:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct </span>inc : <span class="keyword">public</span> std::unary_function&lt;T,T&gt; {
    T operator()(T x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ++x; }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelPtr, <span class="keyword">typename</span> ColorSpace&gt;
planar_pixel_iterator&lt;ChannelPtr,ColorSpace&gt;&amp; 
planar_pixel_iterator&lt;ChannelPtr,ColorSpace&gt;::operator++() {
    static_transform(*<span class="keyword">this</span>,*<span class="keyword">this</span>,inc&lt;ChannelPtr&gt;());
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div><p>
因为函数<code>static_transform</code>是编译期递归,所以操作<code>rgb8_planar_ptr_t</code> 的累加就是3次指针累加. GIL还通过类型 bit_aligned_pixel_iterator 支持位对齐像素迭代. 在内部它维护当前的字节和位偏移 .<h2><a class="anchor" name="IteratorAdaptorDG">
像素适配器</a></h2>
迭代器适配器就是对另外一个像素的包裹器. 像素适配器的<code>is_iterator_adaptor</code> 必定为真, 也必须提供函数访问其基础迭代器, 类型以及绑定到其他迭代器的元函数:<p>
<div class="fragment"><pre class="fragment">concept IteratorAdaptorConcept&lt;RandomAccessTraversalIteratorConcept Iterator&gt; {
    where SameType&lt;is_iterator_adaptor&lt;Iterator&gt;::type, mpl::true_&gt;;

    <span class="keyword">typename</span> iterator_adaptor_get_base&lt;Iterator&gt;;
        where Metafunction&lt;iterator_adaptor_get_base&lt;Iterator&gt; &gt;;
        where boost_concepts::ForwardTraversalConcept&lt;iterator_adaptor_get_base&lt;Iterator&gt;::type&gt;;
    
    <span class="keyword">typename</span> another_iterator; 
    <span class="keyword">typename</span> iterator_adaptor_rebind&lt;Iterator,another_iterator&gt;::type;
        where boost_concepts::ForwardTraversalConcept&lt;another_iterator&gt;;
        where IteratorAdaptorConcept&lt;iterator_adaptor_rebind&lt;Iterator,another_iterator&gt;::type&gt;;

    <span class="keyword">const</span> iterator_adaptor_get_base&lt;Iterator&gt;::type&amp; Iterator::base() <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;boost_concepts::Mutable_ForwardIteratorConcept Iterator&gt;
concept MutableIteratorAdaptorConcept : IteratorAdaptorConcept&lt;Iterator&gt; {};
</pre></div><p>
<b>相关概念 :</b><p>
<ul>
<li>IteratorAdaptorConcept&lt;Iterator&gt;</li><li>MutableIteratorAdaptorConcept&lt;Iterator&gt;</li></ul>
<p>
<b>模型:</b><p>
GIL 提供了几个 IteratorAdaptorConcept的模型:<ul>
<li><code>memory_based_step_iterator&lt;Iterator&gt;</code>: 改变基础迭代器步长的迭代器 (参见 <a class="el" href="gildesignguide.html#StepIteratorDG">Step Iterator</a>)</li><li><code>dereference_iterator_adaptor&lt;Iterator</code>,Fn&gt;: 通过一元函数<code>Fn</code> 解引用的适配器. 可以用来做临时的颜色转换, 也可用作假装具有不同的颜色空间和通道深度的浅层的图像"视图". 更多的信息参见 <a class="el" href="gildesignguide.html#ImageViewFrowImageViewDG">Creating Image Views from Other Image Views</a> . 一元函数 <code>Fn</code> 必须是概念 <code>PixelDereferenceAdaptorConcept</code>的模型 (见下).</li></ul>
<h2><a class="anchor" name="PixelDereferenceAdaptorAG">
像素解引用适配器 </a></h2>
像素解引用适配器是一个一元函数,可以对一个像素迭代器解引用. 它的参数类型是任意的(经常是<code>PixelConcept</code>),但是其结果类型必须是<code>PixelConcept</code> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;boost::UnaryFunctionConcept D&gt;
concept PixelDereferenceAdaptorConcept : DefaultConstructibleConcept&lt;D&gt;, CopyConstructibleConcept&lt;D&gt;, AssignableConcept&lt;D&gt;  {
    <span class="keyword">typename</span> const_t;         where PixelDereferenceAdaptorConcept&lt;const_t&gt;;
    <span class="keyword">typename</span> value_type;      where PixelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> reference;       where PixelConcept&lt;remove_reference&lt;reference&gt;::type&gt;;  <span class="comment">// may be mutable</span>
    <span class="keyword">typename</span> const_reference;   <span class="comment">// must not be mutable</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> D::is_mutable;

    where Convertible&lt;value_type, result_type&gt;;
};
</pre></div><p>
<b>模型:</b><p>
GIL 提供了几个 <code>PixelDereferenceAdaptorConcept</code>模型 <ul>
<li><code>color_convert_deref_fn:</code> 执行颜色变换</li><li><code>detail::nth_channel_deref_fn:</code> 返回指定像素第n个通道对应的灰度级像素</li><li><code>deref_compose:</code> 对概念<code>PixelDereferenceAdaptorConcept</code>的两个模型进行合成. 和<code>std::unary_compose</code>相似,只是还需要增加概念 <code>PixelDereferenceAdaptorConcept</code>所需要的几个typedef </li></ul>
<p>
GIL 通过解引用适配器实现图像视图的颜色变换, 或者得到像素第n个通道的灰度值. 通过任意的函数变换, 解引用适配器实可以用来实现虚拟图像视图, 例如 Mandelbrot 集合. <code>dereference_iterator_adaptor&lt;Iterator,Fn&gt;</code> 是一个像素迭代器包裹器,通过函数<code>Fn</code> 进行像素的解引用.<h2><a class="anchor" name="StepIteratorDG">
Step 迭代器</a></h2>
有时候我们希望以单位步长而不是像素给定的步长遍历像素迭代器,下面的示例就很有用:<ul>
<li>RGB间隔图像红色通道的单通道视图</li><li>从左到右翻转的视图 (step = -fundamental_step)</li><li>每N个像素的子视图(step = N*fundamental_step)</li><li>垂直方向遍历的视图 (step = 每行的字节数)</li><li>上面的任意组合 (steps 是相乘的)</li></ul>
<p>
Step 迭代器是前向迭代器, 允许修改相邻迭代器之间的步长 :<p>
<div class="fragment"><pre class="fragment">concept StepIteratorConcept&lt;boost_concepts::ForwardTraversalConcept Iterator&gt; {
    <span class="keyword">template</span> &lt;Integral D&gt; <span class="keywordtype">void</span> Iterator::set_step(D step);
};

concept MutableStepIteratorConcept&lt;boost_concepts::Mutable_ForwardIteratorConcept Iterator&gt; : StepIteratorConcept&lt;Iterator&gt; {};
</pre></div><p>
GIL 当前提供的 step 迭代器的 <code>value_type</code> 是 <code>PixelValueConcept</code>的模型. 另外, 步长是基于内存单位的(字节或者位). 这是必要的,例如, 当对一系列的像素进行迭代的时候, 一行像素的大小不能被一个像素的大小整除; 还比如像素不是字对齐的 .<p>
为了能够以字或字节向前迭代, 基础迭代器必须是 MemoryBasedIteratorConcept 的模型. 基于内存的迭代器有一个内在的存储单位, 位或者字节. 它必须提供下列功能: 每个存储单位的位数(1或8), 当前的步长, 两个迭代器之间基于存储单位的距离, 给定基于存储单位距离的引用. 它还必须提供函数使得迭代器前进一定距离. 函数<code>memunit_advanced</code> 和 <code>memunit_advanced_ref</code> 都有默认的实现,但是其他的迭代器可以提供更加有效的版本:<p>
<div class="fragment"><pre class="fragment">concept MemoryBasedIteratorConcept&lt;boost_concepts::RandomAccessTraversalConcept Iterator&gt; {
    <span class="keyword">typename</span> byte_to_memunit&lt;Iterator&gt;; where metafunction&lt;byte_to_memunit&lt;Iterator&gt; &gt;;
    std::ptrdiff_t      memunit_step(<span class="keyword">const</span> Iterator&amp;);
    std::ptrdiff_t      memunit_distance(<span class="keyword">const</span> Iterator&amp; , <span class="keyword">const</span> Iterator&amp;);
    <span class="keywordtype">void</span>                memunit_advance(Iterator&amp;, std::ptrdiff_t diff);
    Iterator            memunit_advanced(<span class="keyword">const</span> Iterator&amp; p, std::ptrdiff_t diff) { Iterator tmp; memunit_advance(tmp,diff); <span class="keywordflow">return</span> tmp; }
    Iterator::reference memunit_advanced_ref(<span class="keyword">const</span> Iterator&amp; p, std::ptrdiff_t diff) { <span class="keywordflow">return</span> *memunit_advanced(p,diff); }
};
</pre></div><p>
通过另外的迭代器构造一个step迭代器是很有用的. 更一般的是给定一个类型, 我们能够构造一个对应的动态指派水平步长的类型:<p>
<div class="fragment"><pre class="fragment">concept HasDynamicXStepTypeConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> dynamic_x_step_type&lt;T&gt;;
        where Metafunction&lt;dynamic_x_step_type&lt;T&gt; &gt;;
};
</pre></div><p>
所有GIL提供的像素迭代器,定位器和图像视图的模型都是支持 <code>HasDynamicXStepTypeConcept</code>.<p>
<b>相关概念:</b><p>
<ul>
<li>StepIteratorConcept&lt;Iterator&gt;</li><li>MutableStepIteratorConcept&lt;Iterator&gt;</li><li>MemoryBasedIteratorConcept&lt;Iterator&gt;</li><li>HasDynamicXStepTypeConcept&lt;T&gt;</li></ul>
<p>
<b>模型:</b><p>
所有GIL当前提供的基于内存的迭代器都是 <code>MemoryBasedIteratorConcept</code> 的模型. GIL 提供的类型 <code>memory_based_step_iterator</code> 是概念 <code>PixelIteratorConcept</code>, <code>StepIteratorConcept</code>, 和 <code>MemoryBasedIteratorConcept</code>的模型. 它以基础迭代器(必须是<code>PixelIteratorConcept</code> 和 <code>MemoryBasedIteratorConcept</code>的模型)为模板参数, 并且允许动态改变步长. GIL的实现包含一个基础迭代器和一个 <code>ptrdiff_t</code>,用于表明基于存储单位(字节或位)的步长数. 这个变量也可以用作负数. GIL提供了这样一个函数: 使用基础迭代器和步长创建一个step迭代器:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;  <span class="comment">// 是 MemoryBasedIteratorConcept和 HasDynamicXStepTypeConcept的模型</span>
<span class="keyword">typename</span> dynamic_x_step_type&lt;I&gt;::type make_step_iterator(<span class="keyword">const</span> I&amp; it, std::ptrdiff_t step);
</pre></div><p>
GIL 还提供了 <code>position_iterator</code>, 基于虚拟像素数组的迭代器. 它是一个step 迭代器, 跟踪一个像素的位置,并且通过仿函数对像素解引用. 它是概念 <code>PixelIteratorConcept</code> 和 <code>StepIteratorConcept</code> 的模型,但是不是<code>MemoryBasedIteratorConcept</code>的模型.<h2><a class="anchor" name="LocatorDG">
像素定位器</a></h2>
定位器允许在2维或者多维空间中进行漫游. 定位器本质上是N维的, 但是因为它们不完全满足迭代器的要求,我们需要另起炉灶. 例如, 它们不能进行累加和递减操作,因为它们知道在那一个维度上进行这样的操作. N维迭代器满足以下的概念:<p>
<div class="fragment"><pre class="fragment">concept RandomAccessNDLocatorConcept&lt;Regular Loc&gt; {    
    <span class="keyword">typename</span> value_type;        <span class="comment">// 定位器漫游的值类型 </span>
    <span class="keyword">typename</span> reference;         <span class="comment">// 引用类型</span>
    <span class="keyword">typename</span> difference_type; where PointNDConcept&lt;difference_type&gt;; <span class="comment">// operator-的类型.</span>
    <span class="keyword">typename</span> const_t;           <span class="comment">// Loc的常量类型</span>
    <span class="keyword">typename</span> cached_location_t; <span class="comment">// 存储相关位置的类型 (为了快速的重复访问)</span>
    <span class="keyword">typename</span> point_t  = difference_type;
    
    <span class="keyword">static</span> <span class="keyword">const</span> size_t num_dimensions; <span class="comment">// 定位器的维度</span>
    where num_dimensions = point_t::num_dimensions;
    
    <span class="comment">// 每个维度的 difference_type 和 迭代器类型. 迭代器可以只是在 </span>
    <span class="comment">// difference_type上不一样. 它们的 value_type 和 Loc::value_type必须一致</span>
    <span class="keyword">template</span> &lt;size_t D&gt; <span class="keyword">struct </span>axis {
        <span class="keyword">typename</span> coord_t = point_t::axis&lt;D&gt;::coord_t;
        <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;; <span class="comment">// D维坐标轴的迭代器.</span>
        where iterator::value_type == value_type;
    };

    <span class="comment">// 定义和定位器类似的类型,只是在解引用上不同</span>
    <span class="keyword">template</span> &lt;PixelDereferenceAdaptorConcept Deref&gt; <span class="keyword">struct </span>add_deref {
        <span class="keyword">typename</span> type;        where RandomAccessNDLocatorConcept&lt;type&gt;;
        <span class="keyword">static</span> type make(<span class="keyword">const</span> Loc&amp; loc, <span class="keyword">const</span> Deref&amp; deref);
    };
    
    Loc&amp; operator+=(Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    Loc&amp; operator-=(Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    Loc operator+(<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    Loc operator-(<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    
    reference operator*(<span class="keyword">const</span> Loc&amp;);
    reference operator[](<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
 
    <span class="comment">// 存储相关的位置以便快速的重复访问  </span>
    cached_location_t Loc::cache_location(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    reference operator[](<span class="keyword">const</span> Loc&amp;,<span class="keyword">const</span> cached_location_t&amp;);
    
    <span class="comment">// 在当前位置或者给定的偏移处访问迭代器</span>
    <span class="keyword">template</span> &lt;size_t D&gt; axis&lt;D&gt;::iterator&amp;       Loc::axis_iterator();
    <span class="keyword">template</span> &lt;size_t D&gt; axis&lt;D&gt;::iterator <span class="keyword">const</span>&amp; Loc::axis_iterator() <span class="keyword">const</span>;
    <span class="keyword">template</span> &lt;size_t D&gt; axis&lt;D&gt;::iterator        Loc::axis_iterator(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Loc&gt;
concept MutableRandomAccessNDLocatorConcept : RandomAccessNDLocatorConcept&lt;Loc&gt; {    
    where Mutable&lt;reference&gt;;
};
</pre></div><p>
2维定位器还有附加的要求:<p>
<div class="fragment"><pre class="fragment">concept RandomAccess2DLocatorConcept&lt;RandomAccessNDLocatorConcept Loc&gt; {
    where num_dimensions==2;
    where Point2DConcept&lt;point_t&gt;;
    
    <span class="keyword">typename</span> x_iterator = axis&lt;0&gt;::iterator;
    <span class="keyword">typename</span> y_iterator = axis&lt;1&gt;::iterator;
    <span class="keyword">typename</span> x_coord_t  = axis&lt;0&gt;::coord_t;
    <span class="keyword">typename</span> y_coord_t  = axis&lt;1&gt;::coord_t;
    
    <span class="comment">// 只适用于在Y方向有动态步长的定位器</span>
    <span class="comment">//Loc::Loc(const Loc&amp; loc, y_coord_t);</span>

    <span class="comment">// 只适用于在X Y方向都有动态步长的定位器</span>
    <span class="comment">//Loc::Loc(const Loc&amp; loc, x_coord_t, y_coord_t, bool transposed=false);</span>

    x_iterator&amp;       Loc::x();
    x_iterator <span class="keyword">const</span>&amp; Loc::x() <span class="keyword">const</span>;    
    y_iterator&amp;       Loc::y();
    y_iterator <span class="keyword">const</span>&amp; Loc::y() <span class="keyword">const</span>;    
    
    x_iterator Loc::x_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    y_iterator Loc::y_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    Loc Loc::xy_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    
    <span class="comment">// 不同类型所有方法的x/y 版本</span>
    x_iterator        Loc::x_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;
    y_iterator        Loc::y_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;
    Loc               Loc::xy_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;
    reference         operator()(<span class="keyword">const</span> Loc&amp;, x_coord_t, y_coord_t);
    cached_location_t Loc::cache_location(x_coord_t, y_coord_t) <span class="keyword">const</span>;

    <span class="keywordtype">bool</span>      Loc::is_1d_traversable(x_coord_t width) <span class="keyword">const</span>;
    y_coord_t Loc::y_distance_to(<span class="keyword">const</span> Loc&amp; loc2, x_coord_t x_diff) <span class="keyword">const</span>;
};

concept MutableRandomAccess2DLocatorConcept&lt;RandomAccess2DLocatorConcept Loc&gt; : MutableRandomAccessNDLocatorConcept&lt;Loc&gt; {};
</pre></div><p>
2维定位器不仅可以在水平方向,也可以在垂直方向有一个动态的定位步, 这样就产生了和Y对应的 <code>HasDynamicXStepTypeConcept:</code> <p>
<div class="fragment"><pre class="fragment">concept HasDynamicYStepTypeConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> dynamic_y_step_type&lt;T&gt;;
        where Metafunction&lt;dynamic_y_step_type&lt;T&gt; &gt;;
};
</pre></div><p>
GIL提供的所有定位器和图像视图都是 <code>HasDynamicYStepTypeConcept</code>的模型.<p>
对以给定的定位器和图像视图,需要对换X和Y方向的含义(例如,GIL提供了调换图像视图的函数). 这样的定位器和视图必须是可调换的:<p>
<div class="fragment"><pre class="fragment">concept HasTransposedTypeConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> transposed_type&lt;T&gt;;
        where Metafunction&lt;transposed_type&lt;T&gt; &gt;;
};
</pre></div><p>
GIL提供的所有的定位器和视图都是<code>HasTransposedTypeConcept</code>的模型.<p>
GIL使用的定位器操纵的类型都是 <code>PixelConcept</code> 的模型, 并且它们的x/y维的类型是一致的. 它们是下列概念的模型:<p>
<div class="fragment"><pre class="fragment">concept PixelLocatorConcept&lt;RandomAccess2DLocatorConcept Loc&gt; {
    where PixelValueConcept&lt;value_type&gt;;
    where PixelIteratorConcept&lt;x_iterator&gt;;
    where PixelIteratorConcept&lt;y_iterator&gt;;
    where x_coord_t == y_coord_t;

    <span class="keyword">typename</span> coord_t = x_coord_t;
};

concept MutablePixelLocatorConcept&lt;PixelLocatorConcept Loc&gt; : MutableRandomAccess2DLocatorConcept&lt;Loc&gt; {};
</pre></div><p>
<b>相关概念:</b><p>
<ul>
<li>HasDynamicYStepTypeConcept&lt;T&gt;</li><li>HasTransposedTypeConcept&lt;T&gt;</li><li>RandomAccessNDLocatorConcept&lt;Locator&gt;</li><li>MutableRandomAccessNDLocatorConcept&lt;Locator&gt;</li><li>RandomAccess2DLocatorConcept&lt;Locator&gt;</li><li>MutableRandomAccess2DLocatorConcept&lt;Locator&gt;</li><li>PixelLocatorConcept&lt;Locator&gt;</li><li>MutablePixelLocatorConcept&lt;Locator&gt;</li></ul>
<p>
<b>模型:</b><p>
GIL 提供了概念 <code>PixelLocatorConcept</code> 的两个模型 - 基于内存的定位器<code>memory_based_2d_locator</code> 和一个虚拟定位器 <code>virtual_2d_locator</code>.<p>
<code>memory_based_2d_locator</code> 是一个基于像素在内存中的用于 planar 或者 interleaved 图像的定位器. 它以 <code>StepIteratorConcept</code>为模板参数.(当使用 概念<code>MutableStepIteratorConcept</code>的时候, 即生成概念 <code>MutablePixelLocatorConcept</code>).<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StepIterator&gt;  <span class="comment">// 是概念 StepIteratorConcept, MemoryBasedIteratorConcept的模型</span>
<span class="keyword">class </span>memory_based_2d_locator;
</pre></div><p>
<code>StepIterator</code> 的步长必须是基于存储单位(字节或者位)的每行数(这样就可以向前累加).类型 <code>memory_based_2d_locator</code> 是 <code>StepIterator</code> 的包裹器, 并使用它进行垂直游历,而使用其基础迭代器进行水平游历. <p>
定位器的概念使用基本内容和step迭代器分开的模式, 这样允许我们创建像素存储结构更加复杂的定位器. 第一, 我们可以对水平方向的迭代器进行选择, 例如遍历同一行的像素. 使用这种分开的模式给了我们四种选择的可能:<ul>
<li><code>pixel&lt;T,C&gt;*</code> (适用于 interleaved 图像)</li><li><code>planar_pixel_iterator&lt;T*,C&gt;</code> (适用于 planar 图像)</li><li><code>memory_based_step_iterator&lt;pixel&lt;T,C&gt;*&gt;</code> (适用于非标准步长的 interleaved 图像)</li><li><code> memory_based_step_iterator&lt;planar_pixel_iterator&lt;T*,C&gt; &gt; </code> (适用于非标准步长的 planar 图像)</li></ul>
<p>
当然,用户也可以提供它们自己定制的 x-iterator. 下面描述的一个例子是一个迭代器适配器,当解引用的时候可以进行颜色转换.<p>
给定一个水平迭代器<code>XIterator</code>, 我们可以得到一个在垂直方向移动的迭代器 <em>y-iterator</em>, 移动的步长是<code>memory_based_step_iterator&lt;XIterator&gt;</code> 指定的基于存储单位(字节或者位)的每行数. 当然, 人们也可以自由的定制 y-iterator.<p>
这样我们就可以实例化 <code>memory_based_2d_locator&lt;memory_based_step_iterator&lt;XIterator&gt;</code> &gt; 得到一个2维像素定位器,如下图所示: <div align="center">
<img src="step_iterator.gif" alt="step_iterator.gif">
</div>
<p>
<code>virtual_2d_locator</code> 是一个通过仿函数对像素进行解引用的定位器. 仿函数返回给定X,Y位置像素值. 虚拟定位器可以用来实现用户给定的任意仿函数定义的虚拟图像视图. 参见GIL教程Mandelbrot集构造的虚拟图像.<p>
虚拟定位器和基于内存实体定位器都继承自 <code>pixel_2d_locator_base</code>, 这个基类提供了概念 <code>PixelLocatorConcept</code>需要的绝大部分接口. 如果用户需要定制其他的<code>PixelLocatorConcept</code>,那么它们会发现这个基类非常的有用:<p>
<div class="fragment"><pre class="fragment">loc=img.xy_at(10,10);            <span class="comment">// 从像素 (x=10,y=10)开始</span>
above=loc.cache_location(0,-1);  <span class="comment">// 记住上下邻居的相关位置 </span>
below=loc.cache_location(0, 1);
++loc.x();                       <span class="comment">// 移动到 (11,10)</span>
loc.y()+=15;                     <span class="comment">// 移动到 (11,25)</span>
loc-=point2&lt;std::ptrdiff_t&gt;(1,1);<span class="comment">// 移动到 (10,24)</span>
*loc=(loc(0,-1)+loc(0,1))/2;     <span class="comment">// 设置(10,24) 处的像素为  (10,23)处和 (10,25)处的均值 (只适用于灰度级像素)</span>
*loc=(loc[above]+loc[below])/2;  <span class="comment">// 同上,只是由于使用了缓存邻居的位置,所以更快 </span>
</pre></div><p>
标准的GIL定位器都是快速的轻量级的对象. 例如简单的interleaved图像的定位器,只是包含一个指向像素起始位置的裸指针和一个行数据大小的整数, 总共8个字节. <code> ++loc.x() </code> 总共只是进行了一次裸指针的累加操作(或者是对于planar图像的N次累加操作). 因为要进行加法和乘法运算,所以2维的偏移操作相对较慢. 例如过滤器就需要访问每个像素的相同邻居,在这种情况下我们可以使用 <code>cache_location</code>缓存相对位置. 在上面的实例中, 简单interleaved图像使用的代码<code> loc[above]</code>,就是就是进行数组索引操作.<h2><a class="anchor" name="IteratorFrom2DDG">
2维图像迭代器</a></h2>
有的时候我们需要以位置独立的方式进行同样的像素遍历操作, 在这种情况下把像素视为一维的数组会非常的有用. GIL的类<code>iterator_from_2d</code>是一个随机访问迭代器, 它以一种自然的,存储友好的方式从左到右,从上到下遍历像素. 它以定位器,图像的宽度和当前的X位置为参数,这样才有足够的信息决定何时回转,概要如下:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Locator&gt;  <span class="comment">// 是 PixelLocatorConcept的模型</span>
<span class="keyword">class </span>iterator_from_2d {
<span class="keyword">public</span>:
    iterator_from_2d(<span class="keyword">const</span> Locator&amp; loc, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> width);
    
    iterator_from_2d&amp; operator++(); <span class="comment">// if (++_x&lt;_width) ++_p.x(); else _p+=point_t(-_width,1);</span>

    ...
private:
    <span class="keywordtype">int</span> _x, _width;
    Locator _p;
};
</pre></div><p>
通过<code>iterator_from_2d</code> 对图像像素进行迭代,要比通过每行迭代,并且在每行中使用x-iterator迭代的速度要慢. 这是因为每个迭代步骤要进行两次比较,一次是对结束条件的判断,另一次是在 <code>iterator_from_2d::operator++</code> 内部检查是否到达行尾. 对于有些快速的操作,例如像素的copy, 第二个检查会增加15%的性能损失(这是在Intel平台上的测量结果). GIL 重载了一些STL算法, 例如 <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga2">std::copy</a></code> 和 <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga4">std::fill</a></code>, 当这些算法以x-iterators为基础, 调用<code>iterator_from_2d-s</code>进行遍历的时候,如果图像没有填充(例如 <code>iterator_from_2d::is_1d_traversable()</code>返回true),那么就会直接使用x-iterators简化遍历操作.<p>
<hr>
 <h2><a class="anchor" name="ImageViewSectionDG">
9. 图像视图</a></h2>
图像视图是STL区间概念的泛化,具有多个维度. 和区间(多个迭代器)相似, 图像视图是浅层的, 它并不拥有数据,也不会影响数据本身的常量特性. 例如, 一个常量的图像视图并不能改变大小,但是允许修改像素. 对于像素不可变的操作,使用数据本身是具有常量特性的图像数据(也称为non-mutable图像视图). N-维的图像视图满足下面的概念要求:<p>
<div class="fragment"><pre class="fragment">concept RandomAccessNDImageViewConcept&lt;Regular View&gt; {
    <span class="keyword">typename</span> value_type;      <span class="comment">// 对于基于像素的视图,就是像素的类型</span>
    <span class="keyword">typename</span> reference;       <span class="comment">// 引用类型</span>
    <span class="keyword">typename</span> difference_type; <span class="comment">// operator-(iterator,iterator) (1-维!)的类型</span>
    <span class="keyword">typename</span> const_t;  where RandomAccessNDImageViewConcept&lt;View&gt;; <span class="comment">// same as View, but over immutable values</span>
    <span class="keyword">typename</span> point_t;  where PointNDConcept&lt;point_t&gt;; <span class="comment">// N-维点</span>
    <span class="keyword">typename</span> locator;  where RandomAccessNDLocatorConcept&lt;locator&gt;; <span class="comment">// N-维定位器.</span>
    <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;; <span class="comment">// 1-维迭代器</span>
    <span class="keyword">typename</span> reverse_iterator; where RandomAccessTraversalConcept&lt;reverse_iterator&gt;; 
    <span class="keyword">typename</span> size_type;       <span class="comment">// size()的类型</span>

    <span class="comment">// 对应于RandomAccessNDLocatorConcept::axis</span>
    <span class="keyword">template</span> &lt;size_t D&gt; <span class="keyword">struct </span>axis {
        <span class="keyword">typename</span> coord_t = point_t::axis&lt;D&gt;::coord_t;
        <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;;   <span class="comment">// 第D个坐标轴的迭代器.</span>
        where SameType&lt;coord_t, iterator::difference_type&gt;;
        where SameType&lt;iterator::value_type,value_type&gt;;
    };

    <span class="comment">// 除了在解引用上调用Deref(译者注:不是直接解引用),定义和视图一致的视图类型</span>
    <span class="keyword">template</span> &lt;PixelDereferenceAdaptorConcept Deref&gt; <span class="keyword">struct </span>add_deref {
        <span class="keyword">typename</span> type;        where RandomAccessNDImageViewConcept&lt;type&gt;;
        <span class="keyword">static</span> type make(<span class="keyword">const</span> View&amp; v, <span class="keyword">const</span> Deref&amp; deref);
    };

    <span class="keyword">static</span> <span class="keyword">const</span> size_t num_dimensions = point_t::num_dimensions;
    
    <span class="comment">// 从定位器和左上角以及维度创建视图</span>
    View::View(<span class="keyword">const</span> locator&amp;, <span class="keyword">const</span> point_type&amp;);
    
    size_type        View::size()       <span class="keyword">const</span>; <span class="comment">// 元素的总个数 </span>
    reference        operator[](View, <span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>; <span class="comment">// 1-维引用</span>
    iterator         View::begin()      <span class="keyword">const</span>;
    iterator         View::end()        <span class="keyword">const</span>;
    reverse_iterator View::rbegin()     <span class="keyword">const</span>;
    reverse_iterator View::rend()       <span class="keyword">const</span>;
    iterator         View::at(<span class="keyword">const</span> point_t&amp;);
    point_t          View::dimensions() <span class="keyword">const</span>; <span class="comment">// 每个维度的元素数</span>
    <span class="keywordtype">bool</span>             View::is_1d_traversable() <span class="keyword">const</span>;   <span class="comment">// 是否支持一维遍历?</span>

    <span class="comment">// 得到给定的维度和给定点的迭代器</span>
    <span class="keyword">template</span> &lt;size_t D&gt; View::axis&lt;D&gt;::iterator View::axis_iterator(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;

    reference operator()(View,<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;
};

concept MutableRandomAccessNDImageViewConcept&lt;RandomAccessNDImageViewConcept View&gt; {
    where Mutable&lt;reference&gt;;
};
</pre></div><p>
2维的图像视图还有额外的要求:<p>
<div class="fragment"><pre class="fragment">concept RandomAccess2DImageViewConcept&lt;RandomAccessNDImageViewConcept View&gt; {
    where num_dimensions==2;

    <span class="keyword">typename</span> x_iterator = axis&lt;0&gt;::iterator;
    <span class="keyword">typename</span> y_iterator = axis&lt;1&gt;::iterator;
    <span class="keyword">typename</span> x_coord_t  = axis&lt;0&gt;::coord_t;
    <span class="keyword">typename</span> y_coord_t  = axis&lt;1&gt;::coord_t;
    <span class="keyword">typename</span> xy_locator = locator;
    
    x_coord_t View::width()  <span class="keyword">const</span>;
    y_coord_t View::height() <span class="keyword">const</span>;
    
    <span class="comment">// X-方向遍历</span>
    x_iterator View::x_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;
    x_iterator View::row_begin(y_coord_t) <span class="keyword">const</span>;
    x_iterator View::row_end  (y_coord_t) <span class="keyword">const</span>;

    <span class="comment">// Y-方向遍历</span>
    y_iterator View::y_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;
    y_iterator View::col_begin(x_coord_t) <span class="keyword">const</span>;
    y_iterator View::col_end  (x_coord_t) <span class="keyword">const</span>;
       
    <span class="comment">// 2维遍历</span>
    xy_locator View::xy_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;

    <span class="comment">//  以point_t为参数的所有方法的(x,y)版本实现    </span>
    View::View(x_coord_t,y_coord_t,<span class="keyword">const</span> locator&amp;);
    iterator View::at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
    reference operator()(View,x_coord_t,y_coord_t) <span class="keyword">const</span>;
    xy_locator View::xy_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
    x_iterator View::x_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
    y_iterator View::y_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
};

concept MutableRandomAccess2DImageViewConcept&lt;RandomAccess2DImageViewConcept View&gt;
  : MutableRandomAccessNDImageViewConcept&lt;View&gt; {};
</pre></div><p>
GIL典型使用的图像视图满足以下的概念 <code>PixelValueConcept</code> 并且有额外的要求:<p>
<div class="fragment"><pre class="fragment">concept ImageViewConcept&lt;RandomAccess2DImageViewConcept View&gt; {
    where PixelValueConcept&lt;value_type&gt;;
    where PixelIteratorConcept&lt;x_iterator&gt;;        
    where PixelIteratorConcept&lt;y_iterator&gt;;
    where x_coord_t == y_coord_t;
    
    <span class="keyword">typename</span> coord_t = x_coord_t;

    std::size_t View::num_channels() <span class="keyword">const</span>;
};


concept MutableImageViewConcept&lt;ImageViewConcept View&gt; : MutableRandomAccess2DImageViewConcept&lt;View&gt; {};
</pre></div><p>
如果两个图像视图维度相同,并且像素类型是兼容的,那么它们就被认为是兼容的: <div class="fragment"><pre class="fragment">concept ViewsCompatibleConcept&lt;ImageViewConcept V1, ImageViewConcept V2&gt; {
    where PixelsCompatibleConcept&lt;V1::value_type, V2::value_type&gt;;
    where V1::num_dimensions == V2::num_dimensions;
};
</pre></div><p>
兼容的视图必须具有相同的维度(例如, 相同的高度和宽度).很多以多个视图为参数的算法要求它们是兼容的 .<p>
<b>相关的概念:</b><p>
<ul>
<li>RandomAccessNDImageViewConcept&lt;View&gt;</li><li>MutableRandomAccessNDImageViewConcept&lt;View&gt;</li><li>RandomAccess2DImageViewConcept&lt;View&gt;</li><li>MutableRandomAccess2DImageViewConcept&lt;View&gt;</li><li>ImageViewConcept&lt;View&gt;</li><li>MutableImageViewConcept&lt;View&gt;</li><li>ViewsCompatibleConcept&lt;View1,View2&gt;</li></ul>
<p>
<b>模型:</b><p>
GIL 提供的概念<code>ImageViewConcept</code> 的模型称为 <code>image_view</code>, 它以<code>PixelLocatorConcept</code>为模板参数. (如果以<code>MutablePixelLocatorConcept</code>为模板参数, 那么就是 <code>MutableImageViewConcept</code>). 如下:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Locator&gt;  <span class="comment">// 是概念 PixelLocatorConcept的模型 (也可以是 MutablePixelLocatorConcept)</span>
<span class="keyword">class </span>image_view {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> Locator xy_locator;
    <span class="keyword">typedef</span> iterator_from_2d&lt;Locator&gt; iterator;
    ...
private:
    xy_locator _pixels;     <span class="comment">// 在图像左上角的2维像素定位器</span>
    point_t    _dimensions; <span class="comment">// 高度和宽度</span>
};
</pre></div><p>
图像视图是轻量级的对象, 一个常规的 interleaved 视图典型是是16个字节的大小 - 两个表示长度和宽度的整数(包含在维度点中),一个表示相邻行的字节大小的整数(包含在定位器中),以及一个表示图像像素数据块首地址的指针.<p>
<b>算法:</b><h3><a class="anchor" name="ImageViewFrowRawDG">
从裸像素数据创建视图 </a></h3>
从任何支持的颜色空间,位深度,通道次序以及planar,interleaved结构的裸数据都可以构造标准的视图. Interleaved 视图使用 <code>interleaved_view</code>构造, 需要提供图像的维度,每行的字节数和指向第一个像素的指针:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt; <span class="comment">// 像素迭代器的指针 (例如 rgb8_ptr_t 或者 rgb8c_ptr_t)</span>
image_view&lt;...&gt; <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_constructors.html#ga5">interleaved_view</a>(ptrdiff_t width, ptrdiff_t height, Iterator pixels, ptrdiff_t rowsize)
</pre></div><p>
Planar 视图使用每个颜色空间定义, 下面是一个RGB的形式:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IC&gt;  <span class="comment">// Models channel iterator (like bits8* or const bits8*)</span>
image_view&lt;...&gt; <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_constructors.html#ga9">planar_rgb_view</a>(ptrdiff_t width, ptrdiff_t height,
                                 IC r, IC g, IC b, ptrdiff_t rowsize);
</pre></div><p>
注意到提供的像素/通道迭代器可以是常量(不变)迭代器,在这种情况下构造的视图也是常量(不变)视图 .<h3><a class="anchor" name="ImageViewFrowImageViewDG">
从其他的视图创建图像视图</a></h3>
改变一个视图数据使用的一些方式,可以构造一个新的图像视图. 新的视图的类型可以是从源视图的类型衍生出来的, GIL提供了以下的元函数来得到衍生的类型:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 一些视图类型</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
<span class="keyword">struct </span>dynamic_xy_step_type : <span class="keyword">public</span> dynamic_y_step_type&lt;typename dynamic_x_step_type&lt;View&gt;::type&gt; {};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
<span class="keyword">struct </span>dynamic_xy_step_transposed_type : <span class="keyword">public</span> dynamic_xy_step_type&lt;typename transposed_type&lt;View&gt;::type&gt; {};

<span class="comment">// 对颜色和位深进行转换</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="comment">// ImageViewConcept的模型</span>
          <span class="keyword">typename</span> DstP,    <span class="comment">// PixelConcept的模型</span>
          <span class="keyword">typename</span> ColorConverter=gil::default_color_converter&gt;    
<span class="keyword">struct </span>color_converted_view_type {
    <span class="keyword">typedef</span> ... type;     <span class="comment">// 经过适配的图像视图</span>};

<span class="comment">// N个通道的单通道视图</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView&gt;
<span class="keyword">struct </span>nth_channel_view_type {
    <span class="keyword">typedef</span> ... type;
};
</pre></div><p>
GIL 提供了如下的视图转换:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 上下,左右和双向翻转的视图</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type             flipped_up_down_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_x_step_type&lt;View&gt;::type             flipped_left_right_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type transposed_view(<span class="keyword">const</span> View&amp; src);

<span class="comment">// 旋转</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type            rotated180_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type rotated90cw_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type rotated90ccw_view(<span class="keyword">const</span> View&amp; src);

<span class="comment">// 矩形范围内部的子视图</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; View                                                 subimage_view(<span class="keyword">const</span> View&amp; src, 
             <span class="keyword">const</span> View::point_t&amp; top_left, <span class="keyword">const</span> View::point_t&amp; dimensions);

<span class="comment">// 在XY两个方向跳跃的视图</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type            subsampled_view(<span class="keyword">const</span> View&amp; src, 
             <span class="keyword">const</span> View::point_t&amp; step);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> P&gt; 
color_converted_view_type&lt;View,P&gt;::type                                       <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_transformations_color_convert.html#ga0">color_converted_view</a>(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> P, <span class="keyword">typename</span> CCV&gt; <span class="comment">// 定制的颜色变换</span>
color_converted_view_type&lt;View,P,CCV&gt;::type                                   <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_transformations_color_convert.html#ga0">color_converted_view</a>(<span class="keyword">const</span> View&amp; src);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
nth_channel_view_type&lt;View&gt;::view_t                                           nth_channel_view(<span class="keyword">const</span> View&amp; <a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>, <span class="keywordtype">int</span> n);
</pre></div><p>
                    绝大多数视图创建的算法都是直白的,下面是一个视图翻转实现的例子. 上下翻转<code>创建的</code>视图的第一个像素是源视图最底最左的像素,并且在y方向的步长相反的.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt;
<span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type flipped_up_down_view(<span class="keyword">const</span> View&amp; src) { 
    gil_function_requires&lt;ImageViewConcept&lt;View&gt; &gt;();
    <span class="keyword">typedef</span> <span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type RView;
    <span class="keywordflow">return</span> RView(src.dimensions(),<span class="keyword">typename</span> RView::xy_locator(src.xy_at(0,src.height()-1),-1));
}
</pre></div><p>
                    调用函数 <code>gil_function_requires</code> 会确保 (在编译期)模板参数是&nbsp; <code>ImageViewConcept</code>的模型. 
                    使用这个函数会比较容易跟踪编译错误,并且不会增加代码体积和运行时的开销. 我们使用了函数库 <code>boost::concept_check</code> , 
                    并且包裹为 <code>gil_function_requires</code>, 
                    还设置了一个开关选项 <code>BOOST_GIL_USE_CONCEPT_CHECK</code> 
                    ,默认是关闭的, 这主要是因为一旦开启这个选项会显著的增加编译时间. 在本文档中, 为了简洁,我们会跳过这个函数检查.<p>
                图像视图之间可以自由组合(参见 <a class="el" href="gildesignguide.html#MetafunctionsDG">12. 使用元函数和Typedefs</a> 中的类型定义 <code>rgb16_image_t</code> 和 <code>gray16_step_view_t</code>):<p>
<div class="fragment"><pre class="fragment">rgb16_image_t img(100,100);    <span class="comment">// 一个 RGB interleaved 的图像</span>

<span class="comment">// img的绿色通道(通道索引号1)生成的灰度级视图</span>
gray16_step_view_t green=nth_channel_view(<a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>(img),1);

<span class="comment">// 50x50 大小的视图,上下翻转并且在XY方向都是每隔一行取数据</span>
gray16_step_view_t ud_fud=flipped_up_down_view(subsampled_view(green,2,2));
</pre></div><p>
                    如前所述,图像视图的构造是快速的,常量时间的,是对图像数据的一个浅层映像. 上面的代码不会执行像素数据的拷贝, 数据是图像创建的时候分配的.<h3><a class="anchor" name="ImageViewAlgorithmsDG">
图像视图的STL形式的算法</a></h3>
通过方法 begin() 和 end() ,图像视图提供了对像素的1维迭代器, 这使得可以应用STL的算法. 但是,对X Y两个方向应用嵌套的循环,在很多情况下会更加高效. 在本节中的算法都是模仿STL的算法的, 它们封装了嵌套的循环,并以视图作为输入参数(而不是一个区间).<p>
<div class="fragment"><pre class="fragment"><span class="comment">// 对应于 std::copy and std::uninitialized_copy</span>
<span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;, ViewsCompatibleConcept&lt;V1,V2&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_copy_pixels.html#ga0">copy_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_uninitialized_copy_pixels.html#ga0">uninitialized_copy_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);

<span class="comment">// <code>对应于</code> std::fill and std::uninitialized_fill</span>
<span class="comment">// 满足 MutableImageViewConcept&lt;V&gt;, PixelConcept&lt;Value&gt;, PixelsCompatibleConcept&lt;Value,V::value_type&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> Value&gt;
<span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_fill_pixels.html#ga0">fill_pixels</a>(<span class="keyword">const</span> V&amp; dst, <span class="keyword">const</span> Value&amp; val);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> Value&gt;
<span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_uninitialized_fill_pixels.html#ga0">uninitialized_fill_pixels</a>(<span class="keyword">const</span> V&amp; dst, <span class="keyword">const</span> Value&amp; val);

<span class="comment">// 对应于 std::for_each</span>
<span class="comment">// 满足 ImageViewConcept&lt;V&gt;, boost::UnaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// 满足 PixelsCompatibleConcept&lt;V::reference, F::argument_type&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;
F for_each_pixel(<span class="keyword">const</span> V&amp; <a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>, F fun);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;
F for_each_pixel_position(<span class="keyword">const</span> V&amp; <a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>, F fun);

<span class="comment">// 对应于 std::generate</span>
<span class="comment">// 满足 MutableImageViewConcept&lt;V&gt;, boost::UnaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// 满足 PixelsCompatibleConcept&lt;V::reference, F::argument_type&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;
<span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_generate_pixels.html#ga0">generate_pixels</a>(<span class="keyword">const</span> V&amp; dst, F fun);

<span class="comment">// 对应于 std::transform with one source</span>
<span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;</span>
<span class="comment">// 满足 boost::UnaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// 满足 PixelsCompatibleConcept&lt;V1::const_reference, F::argument_type&gt;</span>
<span class="comment">// 满足 PixelsCompatibleConcept&lt;F::result_type, V2::reference&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> F&gt;
F <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_transform_pixels.html#ga0">transform_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, F fun);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> F&gt;
F <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_transform_pixel_positions.html#ga0">transform_pixel_positions</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, F fun);

<span class="comment">// 对应于 std::transform with two sources</span>
<span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, ImageViewConcept&lt;V2&gt;, MutableImageViewConcept&lt;V3&gt;</span>
<span class="comment">// 满足 boost::BinaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// 满足 PixelsCompatibleConcept&lt;V1::const_reference, F::first_argument_type&gt;</span>
<span class="comment">// 满足 PixelsCompatibleConcept&lt;V2::const_reference, F::second_argument_type&gt;</span>
<span class="comment">// 满足 PixelsCompatibleConcept&lt;F::result_type, V3::reference&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> V3, <span class="keyword">typename</span> F&gt;
F <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_transform_pixels.html#ga0">transform_pixels</a>(<span class="keyword">const</span> V1&amp; src1, <span class="keyword">const</span> V2&amp; src2, <span class="keyword">const</span> V3&amp; dst, F fun);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> V3, <span class="keyword">typename</span> F&gt;
F <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_transform_pixel_positions.html#ga0">transform_pixel_positions</a>(<span class="keyword">const</span> V1&amp; src1, <span class="keyword">const</span> V2&amp; src2, <span class="keyword">const</span> V3&amp; dst, F fun);

<span class="comment">// 使用用户定义的或者默认的颜色转换器(<code>在必要的时候才进行颜色转换</code>),从一个视图构造一个新视图</span>
<span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;</span>
<span class="comment">// V1::value_type must be convertible to V2::value_type.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">void</span> copy_and_convert_pixels(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> ColorConverter&gt;
<span class="keywordtype">void</span> copy_and_convert_pixels(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, ColorConverter ccv);

<span class="comment">// 对应于 std::equal</span>
<span class="comment">// 满足 ImageViewConcept&lt;V1&gt;, ImageViewConcept&lt;V2&gt;, ViewsCompatibleConcept&lt;V1,V2&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">bool</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_equal_pixels.html#ga0">equal_pixels</a>(<span class="keyword">const</span> V1&amp; view1, <span class="keyword">const</span> V2&amp; view2);
</pre></div><p>
                    使用多个视图参数的算法要求它们具有相同的维度. <code>for_each_pixel_position</code> 
        和 <code>transform_pixel_positions</code> 
        给仿函数传递的是像素定位器,而不是像素引用,这适用于那些需要访问像素邻居的算法,这在教程里面有过描述.<p>
                    绝大部分的算法都会检查图像视图是否是1维可遍历的, 所谓的一维可遍历视图, 指的是图像行数据之间没有填充. 换句话说, 
                    如果视图的x_iterator累加到了一行的末尾就会直接的转入下一行, 那么这个视图就是1维可遍历的. 如果视图是一维可遍历的, 
                    那么算法就会使用一个单一的循环, 运行就会更加的有效; 否则算法就会在Y方向循环内部嵌套X循环.<p>
                    一般的这些算法会把工作转交给对应的STL算法, 例如 <code>copy_pixels</code> 会调用 <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga2">std::copy</a></code> 
        扫描每行,或者当视图是一维可遍历的, 扫描所有的像素.<p>
                    另外, 有时候会对STL算法提供重载. 例如,针对planar迭代器调用 <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga2">std::copy</a></code> 
        会转换为对每个颜色面调用 <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga2">std::copy</a></code> 
        , 而对可以逐位拷贝的像素调用 <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga2">std::copy</a></code> 
        会转换为对无符号字节调用 <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga2">std::copy</a></code> ,而这种情形下,STL会转换位对 <code>memmove</code>的调用.<p>
                这样的结果是, <code>copy_pixels</code> 会对一维可遍历的interleaved视图执行 <code>memmove</code> 
        ,或者对一维可遍历的planar视图执行每个颜色面的一次拷贝,或者对非一维可遍历的interleaved视图执行每行数据的一次拷贝,等等.<p>
GIL 还提供了一些图像处理算法的beta-版本, 例如数字扩展中的重采样和卷积运算等,这可以在 <a href="http://opensource.adobe.com/gil/download.html">http://opensource.adobe.com/gil/download.html</a>得到. 这是在开发早期定义的算法,并没有针对速度进行优化. <p>
<hr>
 <h2><a class="anchor" name="ImageSectionDG">
     10. </a>图像</h2>
图像是像素的容器,是视图像素的拥有者. 它会在构造函数中分配空间并在析构函数中释放. 它的赋值运算和拷贝构造都是深层次的. 除了在拥有权很重要的情况下,图像很少直接使用. 绝大多数的STL算法都是操纵区间,而不是容器,同样的GIL算法也大多应用在图像视图(上一节的内容).<p>
从最通用的角度来看,图像是N维的,并且满足以下的概念:<p>
<div class="fragment"><pre class="fragment">concept RandomAccessNDImageConcept&lt;typename Img&gt; : Regular&lt;Img&gt; {
    <span class="keyword">typename</span> view_t; where MutableRandomAccessNDImageViewConcept&lt;view_t&gt;;
    <span class="keyword">typename</span> const_view_t = view_t::const_t;
    <span class="keyword">typename</span> point_t      = view_t::point_t;
    <span class="keyword">typename</span> value_type   = view_t::value_type;
    <span class="keyword">typename</span> allocator_type;

    Img::Img(point_t dims, std::size_t alignment=0);
    Img::Img(point_t dims, value_type fill_value, std::size_t alignment);
    
    <span class="keywordtype">void</span> Img::recreate(point_t new_dims, std::size_t alignment=0);
    <span class="keywordtype">void</span> Img::recreate(point_t new_dims, value_type fill_value, std::size_t alignment);

    <span class="keyword">const</span> point_t&amp;        Img::dimensions() <span class="keyword">const</span>;
    <span class="keyword">const</span> const_view_t&amp;   <a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga3">const_view</a>(<span class="keyword">const</span> Img&amp;);
    <span class="keyword">const</span> view_t&amp;         <a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>(Img&amp;);
};
</pre></div><p>
2维的图像还有更多的要求:<p>
<div class="fragment"><pre class="fragment">concept RandomAccess2DImageConcept&lt;RandomAccessNDImageConcept Img&gt; {
    <span class="keyword">typename</span> x_coord_t = const_view_t::x_coord_t;
    <span class="keyword">typename</span> y_coord_t = const_view_t::y_coord_t;
    
    Img::Img(x_coord_t width, y_coord_t height, std::size_t alignment=0);
    Img::Img(x_coord_t width, y_coord_t height, value_type fill_value, std::size_t alignment);

    x_coord_t Img::width() <span class="keyword">const</span>;
    y_coord_t Img::height() <span class="keyword">const</span>;
    
    <span class="keywordtype">void</span> Img::recreate(x_coord_t width, y_coord_t height, std::size_t alignment=0);
    <span class="keywordtype">void</span> Img::recreate(x_coord_t width, y_coord_t height, value_type fill_value, std::size_t alignment);
};
</pre></div><p>
GIL的图像视图满足概念 <code>ImageViewConcept</code>, 并且可以操纵像素.<p>
<div class="fragment"><pre class="fragment">concept ImageConcept&lt;RandomAccess2DImageConcept Img&gt; {
    where MutableImageViewConcept&lt;view_t&gt;;
    <span class="keyword">typename</span> coord_t  = view_t::coord_t;
};
</pre></div><p>
和定位器和图像视图不同,图像没有'mutable'概念, 因为immutable的图像不是很有用途.<p>
<b>相关概念:</b><p>
<ul>
<li>RandomAccessNDImageConcept&lt;Image&gt;</li><li>RandomAccess2DImageConcept&lt;Image&gt;</li><li>ImageConcept&lt;Image&gt;</li></ul>
<p>
<b>模型:</b><p>
GIL 提供了类 <code>image</code>, 它以 value type (像素) 位模板参数,并且满足 <code>ImageConcept</code>.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, \\ Models PixelValueConcept
          <span class="keywordtype">bool</span> IsPlanar,  \\ planar or interleaved image
          <span class="keyword">typename</span> A=std::allocator&lt;unsigned char&gt; &gt;    
<span class="keyword">class </span>image;
</pre></div><p>

图像构造器有一个对齐参数, 这允许构造字对齐或者字节对齐的图像. 对齐的单位是字节, 默认的对齐参数是0, 这意味着每行的数据没有填充. 使用这样一维可遍历的图像, 很多的算法要更快, 因为这样就会使用 <code>image_view::x_iterator</code> 进行像素遍历,而不是使用更加复杂的<code>image_view::iterator</code>. 注意当对齐为0的时候, packed的图像是以位对齐的,例如packed图像在行尾可能没有对齐的位.<hr>
 <h2><a class="anchor" name="VariantSecDG">
11. 运行时指派的图像和图像视图</a></h2>
图像的颜色空间, 通道次序和interleaved/planar结构都是模板参数, 这是编译器绑定的. 很多情况下, 这些参数只有在运行时才能得到. 考虑一个实例,一个模块根据给定的路径打开一个图像文件, 进行旋转,然后按照原来的颜色空间和通道深度存储回去. 如何使用我们的泛型图像实现这个功能?图像加载代码返回什么类型?<p>
GIL的扩展 dynamic_image, 允许在运行时指派参数构造图像,图像视图或者任何其他的GIL构造,这里是一个实例: <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="http://opensource.adobe.com/gil/html/dynamic__image__all_8hpp.html">boost/gil/extension/dynamic_image/dynamic_image_all.hpp</a>&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace </span>boost;

<span class="preprocessor">#define ASSERT_SAME(A,B) BOOST_STATIC_ASSERT((is_same&lt; A,B &gt;::value))</span>
<span class="preprocessor"></span>
<span class="comment">// 定义允许的图像类型集合</span>
<span class="keyword">typedef</span> mpl::vector&lt;rgb8_image_t, cmyk16_planar_image_t&gt; my_images_t;

<span class="comment">// 创建e any_image class (或者 any_image_view) 类</span>
<span class="keyword">typedef</span> any_image&lt;my_images_t&gt; my_any_image_t;

<span class="comment">// 视图的相关型别也是可用的(和image_t里面的是一样的)</span>
<span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8_view_t,  cmyk16_planar_view_t &gt; &gt; AV;
ASSERT_SAME(my_any_image_t::view_t, AV);

<span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8c_view_t, cmyk16c_planar_view_t&gt; &gt; CAV;
ASSERT_SAME(my_any_image_t::const_view_t, CAV);
ASSERT_SAME(my_any_image_t::const_view_t, my_any_image_t::view_t::const_t);

<span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8_step_view_t, cmyk16_planar_step_view_t&gt; &gt; SAV;
ASSERT_SAME(<span class="keyword">typename</span> dynamic_x_step_type&lt;my_any_image_t::view_t&gt;::type, SAV);

<span class="comment">// 在运行时对图像赋值 it a concrete image at run time:</span>
my_any_image_t myImg = my_any_image_t(rgb8_image_t(100,100));

<span class="comment">// 在运行时改变图像, 前一个图像被析构</span>
myImg = cmyk16_planar_image_t(200,100);

<span class="comment">// 构造一个不在类型允许范围内的图像,会抛出一个异常Assigning to an image not in the allowed set throws an exception</span>
myImg = gray8_image_t();        <span class="comment">// 抛出 std::bad_cast</span>
</pre></div><p>
<code>any_image</code> 和 <code>any_image_view</code> 是 GIL <code>variant</code> 的子类, 它会通过一个非模板化的底层结构和唯一的类型标识进行实例化. 这个底层结构是一个字节块, 这个字节块足够容纳特定类型的最大内容.<p>
GIL 的 variant 和 <code>boost::variant</code> 在本质上很类似 (我们因此也借用了那个名字),只是在有些地方还和boost的实现有所不同. 也许最大的不同就是GIL的variant总是通过单一的参数构造,这个参数就是枚举了允许类型的MPL随机访问序列(Random Access Sequence). 单一的接口使得GIL的variant在泛型编码中更容易使用.其概要如下:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Types&gt;    <span class="comment">// models MPL Random Access Container</span>
<span class="keyword">class </span>variant {
    ...           _bits;
    std::size_t   _index;
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> Types types_t;

    variant();
    variant(<span class="keyword">const</span> variant&amp; v);
    <span class="keyword">virtual</span> ~variant();
    
    variant&amp; operator=(<span class="keyword">const</span> variant&amp; v);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TS&gt; <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> variant&lt;TS&gt;&amp; x, <span class="keyword">const</span> variant&lt;TS&gt;&amp; y);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TS&gt; <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> variant&lt;TS&gt;&amp; x, <span class="keyword">const</span> variant&lt;TS&gt;&amp; y);

    <span class="comment">// 从类型 T构造/赋值. 如果T不在允许的类型范围内则抛出异常 std::bad_cast</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> variant(<span class="keyword">const</span> T&amp; obj);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; variant&amp; operator=(<span class="keyword">const</span> T&amp; obj);

    <span class="comment">// 通过和T的当前内容交换构造/赋值,仅当它们是可交换的</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> variant(T&amp; obj, <span class="keywordtype">bool</span> do_swap);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> move_in(T&amp; obj);

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> <span class="keywordtype">bool</span> has_type();

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; _dynamic_cast() <span class="keyword">const</span>;
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;       T&amp; _dynamic_cast();
    
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> current_type_is() <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> UOP, <span class="keyword">typename</span> Types&gt; 
   UOP::result_type <a class="code" href="http://opensource.adobe.com/gil/html/group___variant.html#ga0">apply_operation</a>(variant&lt;Types&gt;&amp; v, UOP op);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> UOP, <span class="keyword">typename</span> Types&gt; 
   UOP::result_type <a class="code" href="http://opensource.adobe.com/gil/html/group___variant.html#ga0">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types&gt;&amp; v, UOP op);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; 
   BOP::result_type <a class="code" href="http://opensource.adobe.com/gil/html/group___variant.html#ga0">apply_operation</a>(      variant&lt;Types1&gt;&amp; v1,       variant&lt;Types2&gt;&amp; v2, UOP op);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; 
   BOP::result_type <a class="code" href="http://opensource.adobe.com/gil/html/group___variant.html#ga0">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types1&gt;&amp; v1,       variant&lt;Types2&gt;&amp; v2, UOP op);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; 
   BOP::result_type <a class="code" href="http://opensource.adobe.com/gil/html/group___variant.html#ga0">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types1&gt;&amp; v1, <span class="keyword">const</span> variant&lt;Types2&gt;&amp; v2, UOP op);
</pre></div><p>
        GIL的 <code>any_image_view</code> 和 <code>any_image</code> 是 <code>variant</code> 的子类:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ImageViewTypes&gt;
<span class="keyword">class </span>any_image_view : <span class="keyword">public</span> variant&lt;ImageViewTypes&gt; {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> ... const_t; <span class="comment">// immutable equivalent of this</span>
    <span class="keyword">typedef</span> std::ptrdiff_t x_coord_t;
    <span class="keyword">typedef</span> std::ptrdiff_t y_coord_t;
    <span class="keyword">typedef</span> point2&lt;std::ptrdiff_t&gt; point_t;

    any_image_view();
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image_view(<span class="keyword">const</span> T&amp; obj);
    any_image_view(<span class="keyword">const</span> any_image_view&amp; v);

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; any_image_view&amp; operator=(<span class="keyword">const</span> T&amp; obj);
    any_image_view&amp;                       operator=(<span class="keyword">const</span> any_image_view&amp; v);

    <span class="comment">// parameters of the currently instantiated view</span>
    std::size_t num_channels()  <span class="keyword">const</span>;
    point_t     dimensions()    <span class="keyword">const</span>;
    x_coord_t   width()         <span class="keyword">const</span>;
    y_coord_t   height()        <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ImageTypes&gt;
<span class="keyword">class </span>any_image : <span class="keyword">public</span> variant&lt;ImageTypes&gt; {
    <span class="keyword">typedef</span> variant&lt;ImageTypes&gt; parent_t;
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> ... const_view_t;
    <span class="keyword">typedef</span> ... view_t;
    <span class="keyword">typedef</span> std::ptrdiff_t x_coord_t;
    <span class="keyword">typedef</span> std::ptrdiff_t y_coord_t;
    <span class="keyword">typedef</span> point2&lt;std::ptrdiff_t&gt; point_t;

    any_image();
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image(<span class="keyword">const</span> T&amp; obj);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image(T&amp; obj, <span class="keywordtype">bool</span> do_swap);
    any_image(<span class="keyword">const</span> any_image&amp; v);

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; any_image&amp; operator=(<span class="keyword">const</span> T&amp; obj);
    any_image&amp;                       operator=(<span class="keyword">const</span> any_image&amp; v);

    <span class="keywordtype">void</span> recreate(<span class="keyword">const</span> point_t&amp; dims, <span class="keywordtype">unsigned</span> alignment=1);
    <span class="keywordtype">void</span> recreate(x_coord_t width, y_coord_t height, <span class="keywordtype">unsigned</span> alignment=1);

    std::size_t num_channels()  <span class="keyword">const</span>;
    point_t     dimensions()    <span class="keyword">const</span>;
    x_coord_t   width()         <span class="keyword">const</span>;
    y_coord_t   height()        <span class="keyword">const</span>;
};
</pre></div><p>
Operations are invoked on variants via <code>apply_operation</code> passing a function object to perform the operation. The code for every allowed type in the variant is instantiated and the appropriate instantiation is selected via a switch statement. Since image view algorithms typically have time complexity at least linear on the number of pixels, the single switch statement of image view variant adds practically no measurable performance overhead compared to templated image views.<p>
Variants behave like the underlying type. Their copy constructor will invoke the copy constructor of the underlying instance. Equality operator will check if the two instances are of the same type and then invoke their operator==, etc. The default constructor of a variant will default-construct the first type. That means that <code>any_image_view</code> has shallow default-constructor, copy-constructor, assigment and equaty comparison, whereas <code>any_image</code> has deep ones.<p>
It is important to note that even though <code>any_image_view</code> and <code>any_image</code> resemble the static <code>image_view</code> and <code>image</code>, they do not model the full requirements of <code>ImageViewConcept</code> and <code>ImageConcept</code>. In particular they don't provide access to the pixels. There is no "any_pixel" or "any_pixel_iterator" in GIL. Such constructs could be provided via the <code>variant</code> mechanism, but doing so would result in inefficient algorithms, since the type resolution would have to be performed per pixel. Image-level algorithms should be implemented via <code>apply_operation</code>. That said, many common operations are shared between the static and dynamic types. In addition, all of the image view transformations and many STL-like image view algorithms have overloads operating on <code>any_image_view</code>, as illustrated with <code>copy_pixels:</code> <p>
<div class="fragment"><pre class="fragment">rgb8_view_t v1(...);  <span class="comment">// concrete image view</span>
bgr8_view_t v2(...);  <span class="comment">// concrete image view compatible with v1 and of the same size</span>
any_image_view&lt;Types&gt;  av(...);  <span class="comment">// run-time specified image view</span>

<span class="comment">// Copies the pixels from v1 into v2. </span>
<span class="comment">// If the pixels are incompatible triggers compile error </span>
<a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_copy_pixels.html#ga0">copy_pixels</a>(v1,v2);

<span class="comment">// The source or destination (or both) may be run-time instantiated.</span>
<span class="comment">// If they happen to be incompatible, throws std::bad_cast</span>
<a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_copy_pixels.html#ga0">copy_pixels</a>(v1, av);
<a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_copy_pixels.html#ga0">copy_pixels</a>(av, v2);
<a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_copy_pixels.html#ga0">copy_pixels</a>(av, av);
</pre></div><p>
By having algorithm overloads supporting dynamic constructs, we create a base upon which it is possible to write algorithms that can work with either compile-time or runtime images or views. The following code, for example, uses the GIL I/O extension to turn an image on disk upside down:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="http://opensource.adobe.com/gil/html/jpeg__dynamic__io_8hpp.html">boost\gil\extension\io\jpeg_dynamic_io.hpp</a>&gt;</span>

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image&gt;    <span class="comment">// Could be rgb8_image_t or any_image&lt;...&gt;</span>
<span class="keywordtype">void</span> save_180rot(<span class="keyword">const</span> std::string&amp; file_name) {
    Image img;
    <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga0">jpeg_read_image</a>(file_name, img);
    <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga2">jpeg_write_view</a>(file_name, rotated180_view(<a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>(img)));
}
</pre></div><p>
It can be instantiated with either a compile-time or a runtime image because all functions it uses have overloads taking runtime constructs. For example, here is how <code>rotated180_view</code> is implemented:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// implementation using templated view</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
<span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type rotated180_view(<span class="keyword">const</span> View&amp; src) { ... }

<span class="keyword">namespace </span>detail {
    <span class="comment">// the function, wrapped inside a function object</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result&gt; <span class="keyword">struct </span>rotated180_view_fn {
        <span class="keyword">typedef</span> Result result_type;
        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; result_type operator()(<span class="keyword">const</span> View&amp; src)<span class="keyword"> const </span>{ 
            <span class="keywordflow">return</span> result_type(rotated180_view(src)); 
        }
    };
}

<span class="comment">// overloading of the function using variant. Takes and returns run-time bound view.</span>
<span class="comment">// The returned view has a dynamic step</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ViewTypes&gt; <span class="keyword">inline</span> <span class="comment">// Models MPL Random Access Container of models of ImageViewConcept</span>
<span class="keyword">typename</span> dynamic_xy_step_type&lt;any_image_view&lt;ViewTypes&gt; &gt;::type rotated180_view(<span class="keyword">const</span> any_image_view&lt;ViewTypes&gt;&amp; src) { 
    <span class="keywordflow">return</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___variant.html#ga0">apply_operation</a>(src,detail::rotated180_view_fn&lt;<span class="keyword">typename</span> dynamic_xy_step_type&lt;any_image_view&lt;ViewTypes&gt; &gt;::type&gt;()); 
}
</pre></div><p>
Variants should be used with caution (especially algorithms that take more than one variant) because they instantiate the algorithm for every possible model that the variant can take. This can take a toll on compile time and executable size. Despite these limitations, <code>variant</code> is a powerful technique that allows us to combine the speed of compile-time resolution with the flexibility of run-time resolution. It allows us to treat images of different parameters uniformly as a collection and store them in the same container.<p>
<hr>
 <h2><a class="anchor" name="MetafunctionsDG">
12. Useful Metafunctions and Typedefs</a></h2>
Flexibility comes at a price. GIL types can be very long and hard to read. To address this problem, GIL provides typedefs to refer to any standard image, pixel iterator, pixel locator, pixel reference or pixel value. They follow this pattern: <p>
<em>ColorSpace</em> + <em>BitDepth</em> + ["s|f"] + ["c"] + ["_planar"] + ["_step"] + <em>ClassType</em> + "_t" <p>
Where <em>ColorSpace</em> also indicates the ordering of components. Examples are <code>rgb</code>, <code>bgr</code>, <code>cmyk</code>, <code>rgba</code>. <em>BitDepth</em> can be, for example, <code>8</code>,<code>16</code>,<code>32</code>. By default the bits are unsigned integral type. Append <code>s</code> to the bit depth to indicate signed integral, or <code>f</code> to indicate floating point. <code>c</code> indicates object whose associated pixel reference is immutable. <code>_planar</code> indicates planar organization (as opposed to interleaved). <code>_step</code> indicates the type has a dynamic step and <em>ClassType</em> is <code>_image</code> (image, using a standard allocator), <code>_view</code> (image view), <code>_loc</code> (pixel locator), <code>_ptr</code> (pixel iterator), <code>_ref</code> (pixel reference), <code>_pixel</code> (pixel value). Here are examples:<p>
<div class="fragment"><pre class="fragment">bgr8_image_t               i;     <span class="comment">// 8-bit unsigned (unsigned char) interleaved BGR image</span>
cmyk16_pixel_t;            x;     <span class="comment">// 16-bit unsigned (unsigned short) CMYK pixel value;</span>
cmyk16sc_planar_ref_t      p(x);  <span class="comment">// const reference to a 16-bit signed integral (signed short) planar CMYK pixel x.</span>
rgb32f_planar_step_ptr_t   ii;    <span class="comment">// step iterator to a floating point 32-bit (float) planar RGB pixel.</span>
</pre></div><p>
GIL provides the metafunctions that return the types of standard homogeneous memory-based GIL constructs given a channel type, a layout, and whether the construct is planar, has a step along the X direction, and is mutable:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false,                     <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>pixel_reference_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel, <span class="keyword">typename</span> Layout&gt; 
<span class="keyword">struct </span>pixel_value_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStep=false,  <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>iterator_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsXStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>locator_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsXStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>view_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;
<span class="keyword">struct </span>image_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keyword">typename</span> ChannelBitSizeVector, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;
<span class="keyword">struct </span>packed_image_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelBitSizeVector, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image_type { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
There are also helper metafunctions to construct packed and bit-aligned images with up to five channels:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image1_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image2_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image3_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image4_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <span class="keywordtype">unsigned</span> Size5, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image5_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image1_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2,
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image2_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image3_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image4_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <span class="keywordtype">unsigned</span> Size5, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image5_type { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
Here <code>ChannelValue</code> models <code>ChannelValueConcept</code>. We don't need <code>IsYStep</code> because GIL's memory-based locator and view already allow the vertical step to be specified dynamically. Iterators and views can be constructed from a pixel type:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt; 
<span class="keyword">struct </span>iterator_type_from_pixel { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStepX=false, <span class="keywordtype">bool</span> IsMutable=true&gt; 
<span class="keyword">struct </span>view_type_from_pixel { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
Using a heterogeneous pixel type will result in heterogeneous iterators and views. Types can also be constructed from horizontal iterator:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> XIterator&gt; 
<span class="keyword">struct </span>type_from_x_iterator {
    <span class="keyword">typedef</span> ... step_iterator_t;
    <span class="keyword">typedef</span> ... xy_locator_t;
    <span class="keyword">typedef</span> ... view_t;
};
</pre></div><p>
There are metafunctions to construct the type of a construct from an existing type by changing one or more of its properties:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PixelReference, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsMutable&gt;
<span class="keyword">struct </span>derived_pixel_reference_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models PixelConcept</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsStep, <span class="keyword">typename</span> IsMutable&gt;
<span class="keyword">struct </span>derived_iterator_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models PixelIteratorConcept</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsXStep, <span class="keyword">typename</span> IsMutable&gt;
<span class="keyword">struct </span>derived_view_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models ImageViewConcept</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar&gt;
<span class="keyword">struct </span>derived_image_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models ImageConcept</span>
};
</pre></div><p>
You can replace one or more of its properties and use <code>boost::use_default</code> for the rest. In this case <code>IsPlanar</code>, <code>IsStep</code> and <code>IsMutable</code> are MPL boolean constants. For example, here is how to create the type of a view just like <code>View</code>, but being grayscale and planar:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">typename</span> derived_view_type&lt;View, boost::use_default, gray_t, mpl::true_&gt;::type VT;
</pre></div><p>
You can get pixel-related types of any pixel-based GIL constructs (pixels, iterators, locators and views) using the following metafunctions provided by PixelBasedConcept, HomogeneousPixelBasedConcept and metafunctions built on top of them:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>color_space_type { <span class="keyword">typedef</span> ... type; };
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>channel_mapping_type { <span class="keyword">typedef</span> ... type; };
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>is_planar { <span class="keyword">typedef</span> ... type; };

<span class="comment">// Defined by homogeneous constructs</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>channel_type { <span class="keyword">typedef</span> ... type; };
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>num_channels { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
These are metafunctions, some of which return integral types which can be evaluated like this:<p>
<div class="fragment"><pre class="fragment">BOOST_STATIC_ASSERT(is_planar&lt;rgb8_planar_view_t&gt;::value == <span class="keyword">true</span>);
</pre></div><p>
GIL also supports type analysis metafunctions of the form: [pixel_reference/iterator/locator/view/image] + <code>"_is_"</code> + [basic/mutable/step]. For example:<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (view_is_mutable&lt;View&gt;::value) {
   ...
}
</pre></div><p>
A <em>basic</em> GIL construct is a memory-based construct that uses the built-in GIL classes and does not have any function object to invoke upon dereferencing. For example, a simple planar or interleaved, step or non-step RGB image view is basic, but a color converted view or a virtual view is not.<p>
<hr>
 <h2><a class="anchor" name="IO_DG">
13. I/O Extension</a></h2>
GIL's I/O extension provides low level image i/o utilities. It supports loading and saving several image formats, each of which requires linking against the corresponding library:<p>
<ul>
<li><b>JPEG</b>: To use JPEG files, include the file <code>gil/extension/io/jpeg_io.hpp</code>. If you are using run-time images, you need to include <code>gil/extension/io/jpeg_dynamic_io.hpp</code> instead. You need to compile and link against libjpeg.lib (available at <a href="http://www.ijg.org">http://www.ijg.org</a>). You need to have <code>jpeglib.h</code> in your include path.</li></ul>
<p>
<ul>
<li><b>TIFF</b>: To use TIFF files, include the file <code>gil/extension/io/tiff_io.hpp</code>. If you are using run-time images, you need to include <code>gil/extension/io/tiff_dynamic_io.hpp</code> instead. You need to compile and link against libtiff.lib (available at <a href="http://www.libtiff.org">http://www.libtiff.org</a>). You need to have <code>tiffio.h</code> in your include path.</li></ul>
<p>
<ul>
<li><b>PNG</b>: To use PNG files, include the file <code>gil/extension/io/png_io.hpp</code>. If you are using run-time images, you need to include <code>gil/extension/io/png_dynamic_io.hpp</code> instead. You need to compile and link against libpng.lib (available at <a href="http://wwwlibpng.org">http://wwwlibpng.org</a>). You need to have <code>png.h</code> in your include path.</li></ul>
<p>
You don't need to install all these libraries; just the ones you will use. Here are the I/O APIs for JPEG files (replace <code>"jpeg"</code> with <code>"tiff"</code> or <code>"png"</code> for the APIs of the other libraries):<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Returns the width and height of the JPEG file at the specified location.</span>
<span class="comment">// Throws std::ios_base::failure if the location does not correspond to a valid JPEG file</span>
point2&lt;std::ptrdiff_t&gt; <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga4">jpeg_read_dimensions</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*);

<span class="comment">// Allocates a new image whose dimensions are determined by the given jpeg image file, and loads the pixels into it.</span>
<span class="comment">// Triggers a compile assert if the image color space or channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its color space or channel depth are not </span>
<span class="comment">// compatible with the ones specified by Image</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img&gt; <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga0">jpeg_read_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;);

<span class="comment">// Allocates a new image whose dimensions are determined by the given jpeg image file, and loads the pixels into it,</span>
<span class="comment">// color-converting and channel-converting if necessary.</span>
<span class="comment">// Triggers a compile assert if the image color space or channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file or if it fails to read it.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img&gt;               <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga14">jpeg_read_and_convert_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img, <span class="keyword">typename</span> CCV&gt; <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga14">jpeg_read_and_convert_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;, CCV color_converter);

<span class="comment">// Loads the image specified by the given jpeg image file name into the given view.</span>
<span class="comment">// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its color space or channel depth are not </span>
<span class="comment">// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga6">jpeg_read_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);

<span class="comment">// Loads the image specified by the given jpeg image file name into the given view and color-converts (and channel-converts) it if necessary.</span>
<span class="comment">// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its dimensions don't match the ones of the view.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt;               <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga10">jpeg_read_and_convert_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> CCV&gt; <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga10">jpeg_read_and_convert_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;, CCV color_converter);

<span class="comment">// Saves the view to a jpeg file specified by the given jpeg image file name.</span>
<span class="comment">// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if it fails to create the file.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga2">jpeg_write_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);

<span class="comment">// Determines whether the given view type is supported for reading</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">struct </span>jpeg_read_support {
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = ...;
};

<span class="comment">// Determines whether the given view type is supported for writing</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">struct </span>jpeg_write_support {
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = ...;
};
</pre></div><p>
If you use the dynamic image extension, make sure to include <code>"jpeg_dynamic_io.hpp"</code> instead of <code>"jpeg_io.hpp"</code>. In addition to the above methods, you have the following overloads dealing with dynamic images:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Opens the given JPEG file name, selects the first type in Images whose color space and channel are compatible to those of the image file</span>
<span class="comment">// and creates a new image of that type with the dimensions specified by the image file.</span>
<span class="comment">// Throws std::ios_base::failure if none of the types in Images are compatible with the type on disk.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Images&gt; <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga0">jpeg_read_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, any_image&lt;Images&gt;&amp;);

<span class="comment">// Saves the currently instantiated view to a jpeg file specified by the given jpeg image file name.</span>
<span class="comment">// Throws std::ios_base::failure if the currently instantiated view type is not supported for writing by the I/O extension </span>
<span class="comment">// or if it fails to create the file.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Views&gt;  <span class="keywordtype">void</span> <a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga2">jpeg_write_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, any_image_view&lt;Views&gt;&amp;);
</pre></div><p>
All of the above methods have overloads taking <code>std::string</code> instead of <code>const char*</code><p>
<hr>
 <h2><a class="anchor" name="SampleImgCodeDG">
14. Sample Code</a></h2>
<h3><a class="anchor" name="PixelLevelExampleDG">
Pixel-level Sample Code</a></h3>
Here are some operations you can do with pixel values, pointers and references:<p>
<div class="fragment"><pre class="fragment">rgb8_pixel_t p1(255,0,0);     <span class="comment">// make a red RGB pixel</span>
bgr8_pixel_t p2 = p1;         <span class="comment">// RGB and BGR are compatible and the channels will be properly mapped. </span>
assert(p1==p2);               <span class="comment">// p2 will also be red.</span>
assert(p2[0]!=p1[0]);         <span class="comment">// operator[] gives physical channel order (as laid down in memory)</span>
assert(semantic_at_c&lt;0&gt;(p1)==semantic_at_c&lt;0&gt;(p2)); <span class="comment">// this is how to compare the two red channels</span>
<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(p1,green_t()) = <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(p2,blue_t());  <span class="comment">// channels can also be accessed by name</span>

<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* r;
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* g;
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* b;
rgb8c_planar_ptr_t ptr(r,g,b); <span class="comment">// constructing const planar pointer from const pointers to each plane</span>

rgb8c_planar_ref_t ref=*ptr;   <span class="comment">// just like built-in reference, dereferencing a planar pointer returns a planar reference</span>

p2=ref; p2=p1; p2=ptr[7]; p2=rgb8_pixel_t(1,2,3);    <span class="comment">// planar/interleaved references and values to RGB/BGR can be freely mixed</span>

<span class="comment">//rgb8_planar_ref_t ref2;      // compile error: References have no default constructors</span>
<span class="comment">//ref2=*ptr;                   // compile error: Cannot construct non-const reference by dereferencing const pointer</span>
<span class="comment">//ptr[3]=p1;                   // compile error: Cannot set the fourth pixel through a const pointer</span>
<span class="comment">//p1 = pixel&lt;float, rgb_layout_t&gt;();// compile error: Incompatible channel depth</span>
<span class="comment">//p1 = pixel&lt;bits8, rgb_layout_t&gt;();// compile error: Incompatible color space (even though it has the same number of channels)</span>
<span class="comment">//p1 = pixel&lt;bits8,rgba_layout_t&gt;();// compile error: Incompatible color space (even though it contains red, green and blue channels)</span>
</pre></div><p>
Here is how to use pixels in generic code:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayPixel, <span class="keyword">typename</span> RGBPixel&gt;
<span class="keywordtype">void</span> gray_to_rgb(<span class="keyword">const</span> GrayPixel&amp; src, RGBPixel&amp; dst) {
    gil_function_requires&lt;PixelConcept&lt;GrayPixel&gt; &gt;();    
    gil_function_requires&lt;MutableHomogeneousPixelConcept&lt;RGBPixel&gt; &gt;();

    <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;GrayPixel&gt;::type gray_cs_t;
    BOOST_STATIC_ASSERT((boost::is_same&lt;gray_cs_t,gray_t&gt;::value));

    <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;RGBPixel&gt;::type  rgb_cs_t;
    BOOST_STATIC_ASSERT((boost::is_same&lt;rgb_cs_t,rgb_t&gt;::value));

    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;GrayPixel&gt;::type gray_channel_t;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;RGBPixel&gt;::type  rgb_channel_t;

    gray_channel_t gray = <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(src,gray_color_t());
    static_fill(dst, channel_convert&lt;rgb_channel_t&gt;(gray));
}

<span class="comment">// example use patterns:</span>

<span class="comment">// converting gray l-value to RGB and storing at (5,5) in a 16-bit BGR interleaved image:</span>
bgr16_view_t b16(...);
gray_to_rgb(gray8_pixel_t(33), b16(5,5));

<span class="comment">// storing the first pixel of an 8-bit grayscale image as the 5-th pixel of 32-bit planar RGB image:</span>
rgb32f_planar_view_t rpv32;
gray8_view_t gv8(...);
gray_to_rgb(*gv8.begin(), rpv32[5]);
</pre></div><p>
As the example shows, both the source and the destination can be references or values, planar or interleaved, as long as they model <code>PixelConcept</code> and <code>MutablePixelConcept</code> respectively.<h3><a class="anchor" name="SafeAreaExampleDG">
Creating a Copy of an Image with a Safe Buffer</a></h3>
Suppose we want to convolve an image with multiple kernels, the largest of which is 2K+1 x 2K+1 pixels. It may be worth creating a margin of K pixels around the image borders. Here is how to do it:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView,   <span class="comment">// Models ImageViewConcept (the source view)</span>
          <span class="keyword">typename</span> DstImage&gt;  <span class="comment">// Models ImageConcept     (the returned image)</span>
<span class="keywordtype">void</span> create_with_margin(<span class="keyword">const</span> SrcView&amp; src, <span class="keywordtype">int</span> k, DstImage&amp; result) {
    gil_function_requires&lt;ImageViewConcept&lt;SrcView&gt; &gt;();
    gil_function_requires&lt;ImageConcept&lt;DstImage&gt; &gt;();
    gil_function_requires&lt;ViewsCompatibleConcept&lt;SrcView, typename DstImage::view_t&gt; &gt;();
    
    result=DstImage(src.width()+2*k, src.height()+2*k);
    <span class="keyword">typename</span> DstImage::view_t centerImg=subimage_view(<a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>(result), k,k,src.width(),src.height());
    <a class="code" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga0">std::copy</a>(src.begin(), src.end(), centerImg.begin());
}
</pre></div><p>
We allocated a larger image, then we used <code>subimage_view</code> to create a shallow image of its center area of top left corner at (k,k) and of identical size as <code>src</code>, and finally we copied <code>src</code> into that center image. If the margin needs initialization, we could have done it with <code>fill_pixels</code>. Here is how to simplify this code using the <code>copy_pixels</code> algorithm:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstImage&gt;
<span class="keywordtype">void</span> create_with_margin(<span class="keyword">const</span> SrcView&amp; src, <span class="keywordtype">int</span> k, DstImage&amp; result) {
    result.recreate(src.width()+2*k, src.height()+2*k);
    <a class="code" href="http://opensource.adobe.com/gil/html/group___image_view_s_t_l_algorithms_copy_pixels.html#ga0">copy_pixels</a>(src, subimage_view(<a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>(result), k,k,src.width(),src.height()));
}
</pre></div><p>
(Note also that <code>image::recreate</code> is more efficient than <code>operator=</code>, as the latter will do an unnecessary copy construction). Not only does the above example work for planar and interleaved images of any color space and pixel depth; it is also optimized. GIL overrides <code><a class="el" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga2">std::copy</a></code> - when called on two identical interleaved images with no padding at the end of rows, it simply does a <code>memmove</code>. For planar images it does <code>memmove</code> for each channel. If one of the images has padding, (as in our case) it will try to do <code>memmove</code> for each row. When an image has no padding, it will use its lightweight horizontal iterator (as opposed to the more complex 1D image iterator that has to check for the end of rows). It choses the fastest method, taking into account both static and run-time parameters.<h3><a class="anchor" name="HistogramExampleDG">
Histogram</a></h3>
The histogram can be computed by counting the number of pixel values that fall in each bin. The following method takes a grayscale (one-dimensional) image view, since only grayscale pixels are convertible to integers: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayView, <span class="keyword">typename</span> R&gt;
<span class="keywordtype">void</span> grayimage_histogram(<span class="keyword">const</span> GrayView&amp; img, R&amp; hist) {
    <span class="keywordflow">for</span> (<span class="keyword">typename</span> GrayView::iterator it=img.begin(); it!=img.end(); ++it)
        ++hist[*it];
}
</pre></div><p>
Using <code>boost::lambda</code> and GIL's <code>for_each_pixel</code> algorithm, we can write this more compactly:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayView, <span class="keyword">typename</span> R&gt;
<span class="keywordtype">void</span> grayimage_histogram(<span class="keyword">const</span> GrayView&amp; v, R&amp; hist) {
    for_each_pixel(v, ++var(hist)[_1]);
}
</pre></div><p>
Where <code>for_each_pixel</code> invokes <code>std::for_each</code> and <code>var</code> and <code>_1</code> are <code>boost::lambda</code> constructs. To compute the luminosity histogram, we call the above method using the grayscale view of an image:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> R&gt;
<span class="keywordtype">void</span> luminosity_histogram(<span class="keyword">const</span> View&amp; v, R&amp; hist) {
    grayimage_histogram(color_converted_view&lt;gray8_pixel_t&gt;(v),hist);
}
</pre></div><p>
This is how to invoke it:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hist[256];
<a class="code" href="http://opensource.adobe.com/gil/html/group___s_t_l_optimizations.html#ga4">std::fill</a>(hist,hist+256,0);
luminosity_histogram(my_view,hist);
</pre></div><p>
If we want to view the histogram of the second channel of the image in the top left 100x100 area, we call:<p>
<div class="fragment"><pre class="fragment">grayimage_histogram(nth_channel_view(subimage_view(img,0,0,100,100),1),hist);
</pre></div><p>
No pixels are copied and no extra memory is allocated - the code operates directly on the source pixels, which could be in any supported color space and channel depth. They could be either planar or interleaved.<h3><a class="anchor" name="ImageViewsExampleDG">
Using Image Views</a></h3>
The following code illustrates the power of using image views:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga0">jpeg_read_image</a>(<span class="stringliteral">"monkey.jpg"</span>, img);
step1=<a class="code" href="http://opensource.adobe.com/gil/html/group___image_model.html#ga0">view</a>(img);
step2=subimage_view(step1, 200,300, 150,150);
step3=color_converted_view&lt;rgb8_view_t,gray8_pixel_t&gt;(step2);
step4=rotated180_view(step3);
step5=subsampled_view(step4, 2,1);
<a class="code" href="http://opensource.adobe.com/gil/html/group___j_p_e_g___i_o.html#ga2">jpeg_write_view</a>(<span class="stringliteral">"monkey_transform.jpg"</span>, step5);
</pre></div><p>
The intermediate images are shown here: <div align="center">
<img src="monkey_steps.jpg" alt="monkey_steps.jpg">
</div>
<p>
Notice that no pixels are ever copied. All the work is done inside <code>jpeg_write_view</code>. If we call our <code>luminosity_histogram</code> with <code>step5</code> it will do the right thing.<p>
<hr>
 <h2><a class="anchor" name="ExtendingGIL_DG">
15. Extending the Generic Image Library</a></h2>
You can define your own pixel iterators, locators, image views, images, channel types, color spaces and algorithms. You can make virtual images that live on the disk, inside a jpeg file, somewhere on the internet, or even fully-synthetic images such as the Mandelbrot set. As long as they properly model the corresponding concepts, they will work with any existing GIL code. Most such extensions require no changes to the library and can thus be supplied in another module.<h3><a class="anchor" name="NewColorSpacesDG">
Defining New Color Spaces</a></h3>
Each color space is in a separate file. To add a new color space, just copy one of the existing ones (like <a class="el" href="rgb_8hpp.html">rgb.hpp</a>) and change it accordingly. If you want color conversion support, you will have to provide methods to convert between it and the existing color spaces (see color_convert.h). For convenience you may want to provide useful typedefs for pixels, pointers, references and images with the new color space (see typedefs.h).<h3><a class="anchor" name="NewChannelsDG">
Defining New Channel Types</a></h3>
Most of the time you don't need to do anything special to use a new channel type. You can just use it:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> pixel&lt;double,rgb_layout_t&gt;   rgb64_pixel_t;    <span class="comment">// 64 bit RGB pixel </span>
<span class="keyword">typedef</span> rgb64_pixel*                 rgb64_pixel_ptr_t;<span class="comment">// pointer to 64-bit interleaved data</span>
<span class="keyword">typedef</span> image_type&lt;double,rgb_layout_t&gt;::type rgb64_image_t;    <span class="comment">// 64-bit interleaved image</span>
</pre></div><p>
If you want to use your own channel class, you will need to provide a specialization of <code>channel_traits</code> for it (see <a class="el" href="channel_8hpp.html">channel.hpp</a>). If you want to do conversion between your and existing channel types, you will need to provide an overload of <code>channel_convert</code>.<h3><a class="anchor" name="NewColorConversionDG">
Overloading Color Conversion</a></h3>
Suppose you want to provide your own color conversion. For example, you may want to implement higher quality color conversion using color profiles. Typically you may want to redefine color conversion only in some instances and default to GIL's color conversion in all other cases. Here is, for example, how to overload color conversion so that color conversion to gray inverts the result but everything else remains the same:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// make the default use GIL's default</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcColorSpace, <span class="keyword">typename</span> DstColorSpace&gt;
<span class="keyword">struct </span>my_color_converter_impl
  : <span class="keyword">public</span> default_color_converter_impl&lt;SrcColorSpace,DstColorSpace&gt; {};

<span class="comment">// provide specializations only for cases you care about</span>
<span class="comment">// (in this case, if the destination is grayscale, invert it)</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcColorSpace&gt;
<span class="keyword">struct </span>my_color_converter_impl&lt;SrcColorSpace,gray_t&gt; {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcP, <span class="keyword">typename</span> DstP&gt;  <span class="comment">// Model PixelConcept</span>
    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> SrcP&amp; src, DstP&amp; dst)<span class="keyword"> const </span>{
        default_color_converter_impl&lt;SrcColorSpace,gray_t&gt;()(src,dst);
        <a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(dst,gray_color_t())=<a class="code" href="http://opensource.adobe.com/gil/html/group___channel_invert_algorithm.html#ga0">channel_invert</a>(<a class="code" href="http://opensource.adobe.com/gil/html/group___color_base_algorithm_color.html#ga0">get_color</a>(dst,gray_color_t()));
    }
};

<span class="comment">// create a color converter object that dispatches to your own implementation</span>
<span class="keyword">struct </span>my_color_converter {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcP, <span class="keyword">typename</span> DstP&gt;  <span class="comment">// Model PixelConcept</span>
    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> SrcP&amp; src,DstP&amp; dst)<span class="keyword"> const </span>{ 
        <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;SrcP&gt;::type SrcColorSpace;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;DstP&gt;::type DstColorSpace;
        my_color_converter_impl&lt;SrcColorSpace,DstColorSpace&gt;()(src,dst);
    }
};
</pre></div><p>
GIL's color conversion functions take the color converter as an optional parameter. You can pass your own color converter:<p>
<div class="fragment"><pre class="fragment">color_converted_view&lt;gray8_pixel_t&gt;(img_view,my_color_converter());
</pre></div><h3><a class="anchor" name="NewImagesDG">
Defining New Image Views</a></h3>
You can provide your own pixel iterators, locators and views, overriding either the mechanism for getting from one pixel to the next or doing an arbitrary pixel transformation on dereference. For example, let's look at the implementation of <code>color_converted_view</code> (an image factory method that, given any image view, returns a new, otherwise identical view, except that color conversion is performed on pixel access). First we need to define a model of <code>PixelDereferenceAdaptorConcept</code>; a function object that will be called when we dereference a pixel iterator. It will call <code>color_convert</code> to convert to the destination pixel type:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcConstRefP,  <span class="comment">// const reference to the source pixel</span>
          <span class="keyword">typename</span> DstP&gt;          <span class="comment">// Destination pixel value (models PixelValueConcept)</span>
<span class="keyword">class </span>color_convert_deref_fn {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> color_convert_deref_fn const_t;
    <span class="keyword">typedef</span> DstP                value_type;
    <span class="keyword">typedef</span> value_type          reference;      <span class="comment">// read-only dereferencing</span>
    <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp;   const_reference;
    <span class="keyword">typedef</span> SrcConstRefP        argument_type;
    <span class="keyword">typedef</span> reference           result_type;
    BOOST_STATIC_CONSTANT(<span class="keywordtype">bool</span>, is_mutable=<span class="keyword">false</span>);

    result_type operator()(argument_type srcP)<span class="keyword"> const </span>{
        result_type dstP;
        <a class="code" href="http://opensource.adobe.com/gil/html/group___pixel_algorithm.html#ga0">color_convert</a>(srcP,dstP);
        <span class="keywordflow">return</span> dstP;
    }
};
</pre></div><p>
We then use the <code>add_deref</code> member struct of image views to construct the type of a view that invokes a given function object (<code>deref_t</code>) upon dereferencing. In our case, it performs color conversion:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstP&gt;
<span class="keyword">struct </span>color_converted_view_type {
<span class="keyword">private</span>:
    <span class="keyword">typedef</span> <span class="keyword">typename</span> SrcView::const_t::reference src_pix_ref;  <span class="comment">// const reference to pixel in SrcView</span>
    <span class="keyword">typedef</span> color_convert_deref_fn&lt;src_pix_ref, DstP&gt; deref_t; <span class="comment">// the dereference adaptor that performs color conversion</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> SrcView::template add_deref&lt;deref_t&gt; add_ref_t;
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> <span class="keyword">typename</span> add_ref_t::type type; <span class="comment">// the color converted view type</span>
    <span class="keyword">static</span> type make(<span class="keyword">const</span> SrcView&amp; sv) { <span class="keywordflow">return</span> add_ref_t::make(sv, deref_t()); }
};
</pre></div><p>
Finally our <code>color_converted_view</code> code simply creates color-converted view from the source view:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DstP, <span class="keyword">typename</span> View&gt; <span class="keyword">inline</span>
<span class="keyword">typename</span> color_converted_view_type&lt;View,DstP&gt;::type color_convert_view(<span class="keyword">const</span> View&amp; src) {
    <span class="keywordflow">return</span> color_converted_view_type&lt;View,DstP&gt;::make(src);
}
</pre></div><p>
(The actual color convert view transformation is slightly more complicated, as it takes an optional color conversion object, which allows users to specify their own color conversion methods). See the GIL tutorial for an example of creating a virtual image view that defines the Mandelbrot set.<p>
<hr>
 <h2><a class="anchor" name="TechnicalitiesDG">
16. Technicalities</a></h2>
<h3><a class="anchor" name="CreatingReferenceProxyDG">
Creating a reference proxy</a></h3>
Sometimes it is necessary to create a proxy class that represents a reference to a given object. Examples of these are GIL's reference to a planar pixel (<code>planar_pixel_reference</code>) and GIL's subbyte channel references. Writing a reference proxy class can be tricky. One problem is that the proxy reference is constructed as a temporary object and returned by value upon dereferencing the iterator:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>rgb_planar_pixel_iterator {
   <span class="keyword">typedef</span> my_reference_proxy&lt;T&gt; reference;
   reference operator*()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> reference(red,green,blue); }
};
</pre></div><p>
The problem arises when an iterator is dereferenced directly into a function that takes a mutable pixel:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel&gt;    <span class="comment">// Models MutablePixelConcept</span>
<span class="keywordtype">void</span> invert_pixel(Pixel&amp; p);

rgb_planar_pixel_iterator myIt;
invert_pixel(*myIt);        <span class="comment">// compile error!</span>
</pre></div><p>
C++ does not allow for matching a temporary object against a non-constant reference. The solution is to:<ul>
<li>Use const qualifier on all members of the reference proxy object:</li></ul>
<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct </span>my_reference_proxy {
    <span class="keyword">const</span> my_reference_proxy&amp; operator=(<span class="keyword">const</span> my_reference_proxy&amp; p) <span class="keyword">const</span>;
    <span class="keyword">const</span> my_reference_proxy* operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; }
    ...
};
</pre></div><p>
<ul>
<li>Use different classes to denote mutable and constant reference (maybe based on the constness of the template parameter)</li></ul>
<p>
<ul>
<li>Define the reference type of your iterator with const qualifier:</li></ul>
<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>iterator_traits&lt;rgb_planar_pixel_iterator&gt; {
   <span class="keyword">typedef</span> <span class="keyword">const</span> my_reference_proxy&lt;T&gt; reference;
};
</pre></div><p>
A second important issue is providing an overload for <code>swap</code> for your reference class. The default <code>std::swap</code> will not work correctly. You must use a real value type as the temporary. A further complication is that in some implementations of the STL the <code>swap</code> function is incorreclty called qualified, as <code>std::swap</code>. The only way for these STL algorithms to use your overload is if you define it in the <code>std</code> namespace: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>std {
   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
   <span class="keywordtype">void</span> swap(my_reference_proxy&lt;T&gt;&amp; x, my_reference_proxy&lt;T&gt;&amp; y) {
      my_value&lt;T&gt; tmp=x;
      x=y;
      y=tmp;
   }
}
</pre></div><p>
Lastly, remember that constructors and copy-constructors of proxy references are always shallow and assignment operators are deep.<p>
We are grateful to Dave Abrahams, Sean Parent and Alex Stepanov for suggesting the above solution.<p>
<hr>
 <h2><a class="anchor" name="ConclusionDG">
17. Conclusion</a></h2>
The Generic Image Library is designed with the following five goals in mind:<p>
<ul>
<li><b> Generality.</b> Abstracts image representations from algorithms on images. It allows for writing code once and have it work for any image type. </li>
<li><b> Performance.</b> Speed has been instrumental to the design of the library. The generic algorithms provided in the library are in many cases comparable in speed to hand-coding the algorithm for a specific image type. </li>
<li><b> Flexibility.</b> Compile-type parameter resolution results in faster code, but severely limits code flexibility. The library allows for any image parameter to be specified at run time, at a minor performance cost. </li>
<li><b> Extensibility.</b> Virtually every construct in GIL can be extended - new channel types, color spaces, layouts, iterators, locators, image views and images can be provided by modeling the corresponding GIL concepts. </li>
<li><b> Compatibility.</b> The library is designed as an STL complement. Generic STL algorithms can be used for pixel manipulation, and they are specifically targeted for optimization. The library works with existing raw pixel data from another image library.</li>
</ul>
 <hr size="1"><address style="align: right;"><small>Generated on Thu Nov 8 21:53:19 2007 for Generic Image Library   by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>

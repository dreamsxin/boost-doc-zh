<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<!----><title>Generic Image Library : Generic Image Library Tutorial</title>

<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<link type="text/css" rel="stylesheet" href="adobe_source.css" />
<link rel="alternate" title="opensource.adobe.com RSS" href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" type="application/rss+xml" />
</head>

<body>
<table style="margin: 0pt; padding: 0pt; width: 100%;" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%">
<div class="qindex"><a class="qindex" href="index.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical List</a> | <a class="qindex" href="annotated.html">Class List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File List</a> | <a class="qindex" href="../index.html">GIL Home Page</a> </div>
<!-- End Header -->
<!-- Generated by Doxygen 1.5.6 -->
<h1><a class="anchor" name="GILTutorial">G</a>IL
教程</h1>
<dl compact="compact">
<dt><b>作者:</b></dt>
<dd>Lubomir Bourdev (<a href="mailto:lbourdev@adobe.com">lbourdev@adobe.com</a>)
and Hailin Jin (<a href="mailto:hljin@adobe.com">hljin@adobe.com</a>)
<br />
Adobe 系统公司</dd>
</dl>
<dl compact="compact">
<dt><b>版本:</b></dt>
<dd>2.1 </dd>
</dl>
<dl compact="compact">
<dt><b>日期:</b></dt>
<dd>September 15, 2007</dd>
</dl>
GIL是一个从算法角度抽象图像接口的C++函数库,GIL可以操纵种类繁多的图像格式,而其性能可以和针对某种特定图像格式的手写代码相媲美.
<p> <span style="font-family: 宋体; color: black;">本
文档是使用</span><span style="color: black;" lang="EN-US">GIL</span><span style="font-family: 宋体; color: black;">的一个快速起点</span><span style="color: black;" lang="EN-US">,</span><span style="font-family: 宋体; color: black;">这里没有讨论</span><span style="color: black;" lang="EN-US">GIL</span><span style="font-family: 宋体; color: black;">的底层设计</span><span style="color: black;" lang="EN-US">,</span><span style="font-family: 宋体; color: black;">也不是一个</span><span style="color: black;" lang="EN-US">GIL</span><span style="font-family: 宋体; color: black;">大全</span><span style="color: black;" lang="EN-US">,</span><span style="font-family: 宋体; color: black;">你可以在</span><span style="color: black;" lang="EN-US">GIL</span><span style="font-family: 宋体; color: black;">的主网站找到更详细的信息</span><a href="http://stlab.adobe.com/gil">http://stlab.adobe.com/gil</a><a href="http://opensource.adobe.com/gil"></a></p>
<p></p>
<ul>
<li><a class="el" href="giltutorial.html#InstallSec">安装</a></li>
<li><a class="el" href="giltutorial.html#ExampleSec">示例-计算图像梯度</a>
<ul>
<li><a class="el" href="giltutorial.html#InterfaceSec">接口和粘合代码</a></li>
<li><a class="el" href="giltutorial.html#FirstImplementationSec">第一次实现</a></li>
<li><a class="el" href="giltutorial.html#LocatorsSec">定位器</a></li>
<li><a class="el" href="giltutorial.html#GenericVersionSec">创建GIL算法的泛型版本</a></li>
<li><a class="el" href="giltutorial.html#ImageViewTransformationSec">图像视图变换</a></li>
<li><a class="el" href="giltutorial.html#OneDIteratorsSec">一维像素迭代器</a></li>
<li><a class="el" href="giltutorial.html#STLEquivalentsSec">STL 对应算法</a></li>
<li><a class="el" href="giltutorial.html#ColorConversionSec">颜色变换</a></li>
<li><a class="el" href="giltutorial.html#ImagesSec">图像</a></li>
<li><a class="el" href="giltutorial.html#VirtualViewSec">虚拟图像视图</a></li>
<li><a class="el" href="giltutorial.html#DynamicImageSec">运行时图像和图像视图</a></li>
<li><a class="el" href="giltutorial.html#ConclusionSec">结论</a></li>
</ul>
</li>
<li><a class="el" href="giltutorial.html#AppendixSec">附录</a>
<ul>
<li><a class="el" href="giltutorial.html#AppendixConventionSec">GIL实体类型的命名约定</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" name="InstallSec">
安装</a></h2>
GIL最新版本可以在GIL网站下载 <a href="http://stlab.adobe.com/gil.">http://stlab.adobe.com/gil</a><a href="http://opensource.adobe.com/gil.">.</a>
GIL已经审核通过加入boost,将来即可随同boost一起安装了 <a href="http://www.boost.org./">http://www.boost.org</a><a href="http://www.boost.org.">.</a>
GIL 仅仅包含头文件,并不需要任何的链接库,也不需要构建boost. 对于绝大多数的工程来说,包含头文件 <code><a class="el" title="Includes all GIL files for convenience." href="gil__all_8hpp.html">boost/gil/gil_all.hpp</a></code>
即可.
<h2><a class="anchor" name="ExampleSec">示
例-计算图像梯度</a></h2>
本教程将把使用GIL计算图像梯度的示例贯穿始终.我们将从一些非常简单的非泛化的代码开始,逐渐使之更加的泛化.我们从计算水平梯度开始,并且使用最简
单的梯度算法-中心差算法.要计算在水平位置x的像素梯度,使用公式: D[x] = (I[x-1] - I[x+1]) / 2
<p>为了简化,我们忽略了边界情况-对于图像的边界点像素而言,其邻居之一是不存在的.本文的重点是如何使用GIL,而不是一
个好的梯度算法.</p>
<h3><a class="anchor" name="InterfaceSec">接
口和粘合代码</a></h3>
我们算法的输入是一个8位无符号灰度图像, 输出是一个8位有符号灰度图像, 算法的接口如下所示:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" title="Includes all GIL files for convenience." href="gil__all_8hpp.html">boost/gil/gil_all.hpp</a>&gt;</span><br /><span class="keyword">using namespace </span>boost::gil;<br /><br /><span class="keywordtype">void</span> x_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br />    assert(src.dimensions() == dst.dimensions());<br />    ...    <span class="comment">// </span><span class="comment">计算梯度</span><span class="comment"></span><br />}<br /></pre>
</div>
<p><code>gray8c_view_t</code>
是一个8位灰度图像视图类型,像素是只读的(使用符号<code>"c"</code>表明),输出的类型是8位有符号整型值的
灰度图(使用<code>"s"</code>表明). 附录1是GIL实体类型命名约定的一个完整描述</p>
<p>GIL 严格区分<em>图像</em>和<em>图像视图</em>的
概念.一个GIL 图像视图,
是一个关于矩形格网像素集合的浅层,轻量级的视图.它提供了像素访问接口,但是并不拥有这些像素.视图的拷贝构造并不执行像素的深层拷贝.图像视图自身的
常量特性不会传播给图像像素,因而对图像视图总应该以常量引用的形式使用.可变的还是只读的是视图类型的一个属性.</p>
<p>GIL <em>图像</em>,是一种拥有所有权的视图.
它是像素的容器;它的构造/析构会分配/释放像素.它的拷贝构造会执行像素的深度拷贝,其操作符==会逐个比较像素值.图像的常量型会传递给像素-一个常
量引用的图像不允许修改其像素值.</p>
<p>绝大多数的 GIL
算法是施加在图像视图上的,极少有操纵图像本身的.GIL的设计理念和STL极其相似.GIL图像对应于STL里的容器,例如std::vector,
而 GIL's
图像视图对于STL里面的区间,STL内的区间常常表现为一对迭代器.STL算法作用在区间之上,这正如GIL算法作用在图像视图上一样.</p>
<p>GIL的图像视图可以从原生数据构造-维度,每行数据的字节数,用指针表现的数据块.下面是一段从你的代码到GIL的粘合
代码:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> ComputeXGradientGray8(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* src_pixels, ptrdiff_t src_row_bytes, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h,<br />                                   <span class="keywordtype">signed</span> <span class="keywordtype">char</span>* dst_pixels, ptrdiff_t dst_row_bytes) {<br />    gray8c_view_t src = <a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(w, h, (<span class="keyword">const</span> gray8_pixel_t*)src_pixels,src_row_bytes);<br />    gray8s_view_t dst = <a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(w, h, (     gray8s_pixel_t*)dst_pixels,dst_row_bytes);<br />    x_gradient(src,dst);<br />}<br /></pre>
</div>
<p>这段粘合代码速度很快,视图占用空间开销也很小-上面示例中每个视图实例只有16个字节,包含一个左上方像素指针和三个整
数-宽,高和每行字节数.</p>
<h3><a class="anchor" name="FirstImplementationSec">第一次实现</a></h3>
我们把焦点放在简单而非速度上面,计算水平梯度的算法如下:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> x_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;src.height(); ++y)<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=1; x&lt;src.width()-1; ++x)<br /> dst(x,y) = (src(x-1,y) - src(x+1,y)) / 2;<br />}<br /></pre>
</div>
<p>我们使用视图的操作符函数operator(x,y)获得给定位置的像素值引用,并且把其左右邻居差值的一半赋给它.
operator() 返回一个灰度像素的引用.灰度像素值可以转换为对应的颜色通道类型 (src对应的是unsigned
char),并且可以从通道值构造(这只对灰度像素有效). 上面的代码容易理解,但是并不高效,因为二元操作符 operator()
在一个二维格网中计算像素的位置,这会引起加法和乘法操作,下面是一个更快的版本:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> x_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;src.height(); ++y) {<br /> gray8c_view_t::x_iterator src_it = src.row_begin(y);<br /> gray8s_view_t::x_iterator dst_it = dst.row_begin(y);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=1; x&lt;src.width()-1; ++x)<br /> dst_it[x] = (src_it[x-1] - src_it[x+1]) / 2;<br /> }<br />}<br /></pre>
</div>
<p>对于每行数据，我们都使用迭代器，GIL的迭代器是随机访问迭代器。如果你对随机访问迭代器不熟悉，那么你可以认为它们就
是指针. 实际在上面的例子中,两个指针的类型都是C式的裸指针,并且操作符&nbsp; <code>operator</code>[] 提供快速的指针索引操作.</p>
<p>计算垂直方向梯度的代码和水平方向的很类似:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> y_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;src.width(); ++x) {<br /> gray8c_view_t::y_iterator src_it = src.col_begin(x);<br /> gray8s_view_t::y_iterator dst_it = dst.col_begin(x);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=1; y&lt;src.height()-1; ++y)<br /> dst_it[y] = (src_it[y-1] - src_it[y+1])/2;<br /> }<br />}<br /></pre>
</div>
<p>不是循环行,而是循环列,即创建一个<code>y_iterator</code>类型的实
例, 进行垂向迭代.
列迭代不能简单的使用指针,因为相邻像素之间的距离是图像一行数据的字节数.GIL在这里使用了一个8字节步长的迭代器-包含一个裸指针和一个步长.
它的操作符 <code>operator</code>[]  是乘以步长计算索引.</p>
<p>上面的算法实现<code>y_iterator</code>, 会比 <code>x_iterator</code>
慢很多(很容易达到一个数量级).这是由于内存访问的模式引起的,因为这种模式导致大量的缓存无效.
把对列的循环放在内部,会产生一个缓存友好,高效很多的版本:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> y_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=1; y&lt;src.height()-1; ++y) {<br /> gray8c_view_t::x_iterator src1_it = src.row_begin(y-1);<br /> gray8c_view_t::x_iterator src2_it = src.row_begin(y+1);<br /> gray8s_view_t::x_iterator dst_it = dst.row_begin(y);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;src.width(); ++x) {<br /> *dst_it = ((*src1_it) - (*src2_it))/2;<br /> ++dst_it;<br /> ++src1_it;<br /> ++src2_it;<br /> }<br /> }<br />}<br /></pre>
</div>
<p>上面的代码还表明了, 迭代器的累加和提领操作可以替换使用操作符&nbsp; <code>operator</code>[] 
.</p>
<h3><a class="anchor" name="LocatorsSec">使
用定位器</a></h3>
不幸的是,上面这个缓存友好的版本需要对源视图维护两个独立的迭代器. 对于每个像素,我们希望访问其上下邻居,而这可以通过GIL定位器实现:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> y_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> gray8c_view_t::xy_locator src_loc = src.xy_at(0,1);<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=1; y&lt;src.height()-1; ++y) {<br /> gray8s_view_t::x_iterator dst_it = dst.row_begin(y);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;src.width(); ++x) {<br /> (*dst_it) = (src_loc(0,-1) - src_loc(0,1)) / 2;<br /> ++dst_it;<br /> ++src_loc.x(); <span class="comment">// each dimension can be advanced separately</span><br />}<br />src_loc+=point2&lt;std::ptrdiff_t&gt;(-src.width(),1); <span class="comment">// carriage return</span><br />}<br />}<br /></pre>
</div>
<p>第一行代码创建了一个定位器,指向源视图的第二行的第一个像素.GIL像素定位器除了能够在垂直和水平两个方向都可以移动
以外,其他的行为和迭代器很类似. <code>src_loc.x()</code> 和 src_loc.y()
分别返回一个垂直和水平方向的迭代器,并可以沿着希望的方向移动,就和上面的代码一样. 同时,使用操作符 <code>operator+=
</code>和 <code>operator-=</code>还可以在两个方向上同时移动.
和图像视图类似, 定位器提供了二进制操作符 <code>operator()</code>
返回指定位置的像素引用.例如,<code>src_loc(0,1) </code>返回当前像素垂直方向的下一个像素.定
位器是轻量级的对象-上面的实例中定位器只有8个字节-包含了一个指向当前位置的裸指针,一个从当前行到下一行的偏移字节整型数值(垂直移动的时候需要这
个数值). 调用<code>++src_loc.x()</code>
只是单个C式指针的累加操作.但是上面的代码进行了过多的不必要的计算. 代码 <code>src_loc(0,1)</code>
不得不计算像素在两个维度上的偏移,这会比较慢. 注意到不管像素的位置如何,上下邻居的位置是不变的. 为了提高性能, GIL
可以缓存并且重用这个偏移值:</p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> y_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> gray8c_view_t::xy_locator src_loc = src.xy_at(0,1);<br /> gray8c_view_t::xy_locator::cached_location_t above = src_loc.cache_location(0,-1);<br /> gray8c_view_t::xy_locator::cached_location_t below = src_loc.cache_location(0, 1);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=1; y&lt;src.height()-1; ++y) {<br /> gray8s_view_t::x_iterator dst_it = dst.row_begin(y);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;src.width(); ++x) {<br /> (*dst_it) = (src_loc[above] - src_loc[below])/2;<br /> ++dst_it;<br /> ++src_loc.x(); <br /> }<br /> src_loc+=point2&lt;std::ptrdiff_t&gt;(-src.width(),1);<br /> }<br />}<br /></pre>
</div>
<p>实例中 <code>"src_loc[above]"</code>
对应于快速的指针索引操作,因而效率很高.</p>
<h3><a class="anchor" name="GenericVersionSec">创
建 GIL 算法更加泛化的版本</a></h3>
让我们把 <code>x_gradient</code> 更加泛化.
算法应该适合任何的图像视图,只要他们有相同的颜色通道个数.下面是新接口的样子:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> x_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br /> gil_function_requires&lt;ImageViewConcept&lt;SrcView&gt; &gt;();<br /> gil_function_requires&lt;MutableImageViewConcept&lt;DstView&gt; &gt;();<br /> gil_function_requires&lt;ColorSpacesCompatibleConcept&lt;<br /> <span class="keyword">typename</span> color_space_type&lt;SrcView&gt;::type, <br /> <span class="keyword">typename</span> color_space_type&lt;DstView&gt;::type&gt; &gt;();<br /> <br /> ... <span class="comment">// compute the gradient</span><br />}<br /></pre>
</div>
<p>现在的新算法使得输入的图像视图类型都成为模板参数,
这些模板参数可以使用内建的GIL图像视图类型,也可以使用用户自定义的图像视图类型. 下面的三行函数是可选的;它们使用 <code>boost::concept_check</code>
确保输入的两参数属于 GIL 图像视图, 并且第二个参数还是可变的,它们的颜色空间也是兼容的(例如,具有相同的通道数) .</p>
<p>GIL 并不强求使用GIL的内建构造类型,
你可以使用自己定义的颜色通道,颜色空间,迭代器,定位器,图像视图和图像. 但是要想使用GIL, 它们必须满足一组条件;话句话说,
它们必须是GIL概念的模型. GIL的概念定义在用户使用手册中.</p>
<p>在C++泛型编程中使用模板的最大弊端之一就是编译的错误消息难以理解.这是由于缺乏早期的类型检查导致的副作用-一个泛
型参数可能不满足函数的要求,这种情况可能在很深的嵌套层次中才被发现, 而这和错误的本质已经相差十万八千里. GIL 使用
boost::concept_check 来避免这种问题. 上面的这三行函数用来检验模板参数是否属于相关概念的模型,
如果模型是错误的,那么编译的错误消息就会在 函数 gil_function_requires中产生,
这和发生错误的地方非常的接近,也易于跟踪. 这种检查发生在编译期,没有运行时的性能影响.
使用概念检查的缺点是他们会给编译时间带来严重的影响,这也是为什么GIL只是在debug模式下执行概念检查的原因,也即只有宏 <code>BOOST_GIL_USE_CONCEPT_CHECK</code>
定义的时候才可以 (默认是关闭的).</p>
<p>泛型函数的主体和非泛型版本是非常类似的,最大的差别是需要对像素的颜色通道进行循环,计算每个通道的梯度:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> x_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;src.height(); ++y) {<br /> <span class="keyword">typename</span> SrcView::x_iterator src_it = src.row_begin(y);<br /> <span class="keyword">typename</span> DstView::x_iterator dst_it = dst.row_begin(y);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=1; x&lt;src.width()-1; ++x)<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c&lt;num_channels&lt;SrcView&gt;::value; ++c)<br /> dst_it[x][c] = (src_it[x-1][c]- src_it[x+1][c])/2;<br /> }<br />}<br /></pre>
</div>
<p>对每个通道使用一个显式的循环可能会是一个性能问题,GIL允许我们抽象对每个通道的操作:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Out&gt;<br /><span class="keyword">struct </span>halfdiff_cast_channels {<br /> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Out operator()(<span class="keyword">const</span> T&amp; in1, <span class="keyword">const</span> T&amp; in2)<span class="keyword"> const </span>{<br /> <span class="keywordflow">return</span> Out((in1-in2)/2);<br /> }<br />};<br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> x_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br /> <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;DstView&gt;::type dst_channel_t;<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;src.height(); ++y) {<br /> <span class="keyword">typename</span> SrcView::x_iterator src_it = src.row_begin(y);<br /> <span class="keyword">typename</span> DstView::x_iterator dst_it = dst.row_begin(y);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=1; x&lt;src.width()-1; ++x)<br /> static_transform(src_it[x-1], src_it[x+1], dst_it[x], <br /> halfdiff_cast_channels&lt;dst_channel_t&gt;());<br /> }<br />}<br /></pre>
</div>
<p><code>static_transform</code>
是一个GIL通道级别的算法,其他类似的算法还有 <code>static_generate</code>, <code>static_fill</code>
和 <code>static_for_each</code>. 它们在STL中对应是 <code>generate</code>,
<code>transform</code>, <code>fill</code>
和 <code>for_each</code> . GIL
通道算法使用静态递归进行循环;它们不会对通道进行显式的循环. 要注意某些现代的编译器(至少有 Visual Studio 8)
会展开通道级别的循环(译者注:即是在不使用halfdiff_cast_channels,使用双层循环的时候,编译器会消除内层的循环,这显然是一种
高级的编译优化),和上面的一样. 但是使用GIL通道级别的算法的另外一个优势是: 使得通道值在语义上对应起来,而不必依赖于内存的次序, 例如,
上面的代码可以匹配一个RGB的源类型和一个BGR的目标类型.</p>
<p>下面的代码是把我们函数的泛型版本应用在不同的图像类型上:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="comment">// 16-位灰度级数据调用</span><br /><span class="keywordtype">void</span> XGradientGray16_Gray32(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* src_pixels, ptrdiff_t src_row_bytes, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h,<br />                                  <span class="keywordtype">signed</span> <span class="keywordtype">int</span>* dst_pixels, ptrdiff_t dst_row_bytes) {<br />    gray16c_view_t src=<a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(w,h,(<span class="keyword">const</span> gray16_pixel_t*)src_pixels,src_row_bytes);<br />    gray32s_view_t dst=<a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(w,h,(     gray32s_pixel_t*)dst_pixels,dst_row_bytes);<br />    x_gradient(src,dst);<br />}<br /><br /><span class="comment">// 8位的RGB到16位的BGR</span><br /><span class="keywordtype">void</span> XGradientRGB8_BGR16(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* src_pixels, ptrdiff_t src_row_bytes, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h,<br />                                 <span class="keywordtype">signed</span> <span class="keywordtype">short</span>* dst_pixels, ptrdiff_t dst_row_bytes) {<br />    rgb8c_view_t  src = <a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(w,h,(<span class="keyword">const</span> rgb8_pixel_t*)src_pixels,src_row_bytes);<br />    rgb16s_view_t dst = <a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(w,h,(    rgb16s_pixel_t*)dst_pixels,dst_row_bytes);<br />    x_gradient(src,dst);<br />}<br /><br /><span class="comment">// 源和目标是也都可以是平面类型 - 梯度代码也是不必改变的</span><br /><span class="keywordtype">void</span> XGradientPlanarRGB8_RGB32(<br />           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* src_r, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* src_g, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* src_b, <br />           ptrdiff_t src_row_bytes, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h,<br />           <span class="keywordtype">signed</span> <span class="keywordtype">int</span>* dst_pixels, ptrdiff_t dst_row_bytes) {<br />    rgb16c_planar_view_t src=<a class="code" title="from raw RGB planar data" href="g_i_l_0140.html#g294f43780e7b88f43b91fdd6346cb51b">planar_rgb_view</a> (w,h, src_r,src_g,src_b,         src_row_bytes);<br />    rgb32s_view_t        dst=<a class="code" title="Constructing image views from raw interleaved pixel data." href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1">interleaved_view</a>(w,h,(rgb32s_pixel_t*)dst_pixels,dst_row_bytes);<br />    x_gradient(src,dst);<br />}<br /></pre>
</div>
<p>正如实例所表明的,源和目标的图像类型可以是间隔的,平面的,任何的通道深度(假定目标类型是可以被源类型赋值的),任何
兼容的颜色空间.</p>
<p>GIL 2.1 还内在的支持非字节对齐的图像类型, 例如 6-位 RGB222图像或者1-位的灰度图像.
GIL内在支持这种的图像类型, 可以在设计指南和示例文件中查看这方面更详细的信息.</p>
<h3><a class="anchor" name="ImageViewTransformationSec">图像视图变换</a></h3>
计算垂直梯度的另一个方法是旋转图像90, 计算水平梯度,然后再把结果旋转回来. 下面是使用GIL具体的代码形式:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> y_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br /> x_gradient(rotated90ccw_view(src), rotated90ccw_view(dst));<br />}<br /></pre>
</div>
<p><code>rotated90ccw_view</code>
以图像视图作为参数,并且返回一个在逆时针方向上旋转90度的图像视图. 这是一个GIL图像视图变换的实例.
GIL有大量的这样的变换函数,这包括基于坐标轴任意方向的旋转,视图变换,垂直或者水平方向的翻转,矩形子视图截取,颜色变换,子视图采样等等. <code>rotated90cw_view</code>是
这些变换函数之一, 得到视图的水平迭代器是原视图的垂直迭代器. 上面计算垂直梯度的代码可能由于内存访问模式的问题,导致速度有点慢; 但这不是函数<code>rotated90cw_view
的事</code></p>
<p>还有一个例子: 假如我们需要计算N维颜色通道空间图像的梯度,可以这样做:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> nth_channel_x_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keywordtype">int</span> n, <span class="keyword">const</span> DstView&amp; dst) {<br /> x_gradient(nth_channel_view(src, n), dst);<br />}<br /></pre>
</div>
<p><code>nth_channel_view</code>
是一个视图转换函数,它把一个N维颜色通道空间的视图转换为单一颜色通道(灰度)的视图.例如对于RGB视图,
返回的结果就是一个特定步长的视图,其水平迭代器前进的而时候,会跳过两个通道.
如果应用在平面RGB视图上,返回就是一个水平迭代器为C式指针的灰度视图. 图像视图的变换函数可以进行嵌套.
例如,为了计算偶数位像素第二个通道的梯度值,可以这样:</p>
<p></p>
<div class="fragment">
<pre class="fragment">y_gradient(subsampled_view(nth_channel_view(src, 1), 2,2), dst);<br /></pre>
</div>
<p>GIL 有时候会简化嵌套视图的使用.
例如两个嵌套的子视图(像素在X和Y方向上进行跃变)可以表现为一个单一的子视图,其像素跳跃步长是两个子视图跳跃步长的乘积.</p>
<h3><a class="anchor" name="OneDIteratorsSec">一
维像素迭代器</a></h3>
让我们再次回到函数 <code>x_gradient</code> .
很多的时候我们需要对图像视图的每个像素进行相同的算法操作,GIL提供了这样的抽象机制.
我们的算法使用了一种非常规的访问机制,它不访问第一和最后一列.
如果我们使用同一的形式重写算法就好了,并且这样也很有教学意义.我们要实现这样的一个版本:操纵每个像素,但是不包含图像的第一列和最后一列.使用
GIL我们可以这样做:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> x_gradient_unguarded(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;src.height(); ++y) {<br /> gray8c_view_t::x_iterator src_it = src.row_begin(y);<br /> gray8s_view_t::x_iterator dst_it = dst.row_begin(y);<br /><br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;src.width(); ++x)<br /> dst_it[x] = (src_it[x-1] - src_it[x+1]) / 2;<br /> }<br />}<br /><br /><span class="keywordtype">void</span> x_gradient(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> assert(src.width()&gt;=2);<br /> x_gradient_unguarded(subimage_view(src, 1, 0, src.width()-2, src.height()),<br /> subimage_view(dst, 1, 0, src.width()-2, src.height()));<br />}<br /></pre>
</div>
<p><code>subimage_view</code>
是GIL图像视图变换另外的一个例子. 它的输入是一个图像视图和一个矩形区域(在这里即是定义 x_min,y_min,width,height)
,输出一个包含这个矩形区域的视图.上面的实现相对于操纵原始的视图,没有明显的性能退化.</p>
<p>对于函数 <code>x_gradient_unguarded</code>
操纵每个像素, 我们可以使用更紧凑的形式 :</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> x_gradient_unguarded(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> gray8c_view_t::iterator src_it = src.begin();<br /> <span class="keywordflow">for</span> (gray8s_view_t::iterator dst_it = dst.begin(); dst_it!=dst.end(); ++dst_it, ++src_it)<br /> *dst_it = (src_it.x()[-1] - src_it.x()[1]) / 2;<br />}<br /></pre>
</div>
<p>GIL 图像视图提供了函数 begin() 和 end()
,它们返回一维的像素迭代器,对图像的每个像素进行迭代, 从左到右,从上到下. 迭代器进行了恰当的回转-在每行的结尾它们会跳过无用的字节.
所以,它们的性能优化不是最佳, 因为他们需要跟踪当前位置相和行尾的关系.
累加操作需要进行一层额外的检查(我们到行尾了吗?),而这个检查在使用嵌套循环的时候是不需要的. 这些迭代器提供了轻量级的方法 x()
,用来得到我们前面使用的水平迭代器. 水平迭代器不知道和行尾的关系. 在本例中,水平迭代器就是C式指针.
在我们的例子中,必须使用水平迭代器正确的访问两个邻居, 因为它们可能位于图像视图之外.</p>
<h3><a class="anchor" name="STLEquivalentsSec">STL
对应算法</a></h3>
GIL 提供了很多和 STL对应的算法. 例如, <code>std::transform</code>
是一个STL算法,它使用一个泛型函数操作一个区间的所有元素,并且把结果放在对应的目标区间中. 在我们的实例中,
我们要把源视图每个像素水平相邻值差的一半赋给对应的目标像素. 如果使用一个仿函数来抽象这个操作,我们可以使用GIL的函数 <code>transform_pixel_positions</code>
这样做:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">struct </span>half_x_difference {<br />    <span class="keywordtype">int</span> operator()(<span class="keyword">const</span> gray8c_loc_t&amp; src_loc)<span class="keyword"> const </span>{<br />        <span class="keywordflow">return</span> (src_loc.x()[-1] - src_loc.x()[1]) / 2;<br />    }<br />};<br /><br /><span class="keywordtype">void</span> x_gradient_unguarded(<span class="keyword">const</span> gray8c_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br />    <a class="code" title="Like transform_pixels but passes to the function object pixel locators instead of..." href="g_i_l_0153.html#gc74f3114086b954dfd1735a918f68389">transform_pixel_positions</a>(src, dst, half_x_difference());<br />}</pre>
</div>
<p>IL 提供了和STL的算法<code>for_each_pixel</code> 和 <code>transform_pixels</code>对
应的算法<code>std::for_each</code> 和 <code>std::transform</code>
. 另外还提供了函数 <code>for_each_pixel_position</code> 和 <code>transform_pixel_positions</code>,
它们不是使用像素引用,而是使用像素定位器. 这样通过定位器,可以使用像素相邻的值,完成更加强大的功能.
GIL算法也可以使用两层嵌套的循环来提高效率(而不是使用一维的迭代器) </p>
<h3><a class="anchor" name="ColorConversionSec">颜
色变换</a></h3>
有的时候我们不是要计算图像颜色的梯度,而是要计算照明度的梯度.换句话说,我们需要把图像的颜色值转变到灰度值,然后计算其梯度.我们计算32位浮点数
RGB图像照明度的梯度,代码如下:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> x_gradient_rgb_luminosity(<span class="keyword">const</span> rgb32fc_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br /> x_gradient(color_converted_view&lt;gray8_pixel_t&gt;(src), dst);<br />}<br /></pre>
</div>
<p><code>color_converted_view</code>
是一个GIL视图变换函数,输入是任意的图像试图类型,返回一个特定颜色空间和通道类型的图像视图(颜色空间和颜色通道通过模板参数定义).
在上面的实例中,通过一个32位浮点RGB像素类型的视图构造了一个8位灰度整型值视图. 和其他的图像变换函数一样, <code>color_converted_view</code>
是一个快速浅拷贝函数. 它没有进行数据拷贝,也没有执行颜色变换. 它只是返回了视图,在每次访问像素的时候进行实时计算.</p>
<p>在泛型算法中,我们也许只是需要把颜色变换为灰度值,而保持其通道类型一致. 我们进行如下操作,
构造和源视图通道类型一致的灰度像素类型,然后把颜色转换为对应的像素类型:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> x_luminosity_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br /> <span class="keyword">typedef</span> pixel&lt;typename channel_type&lt;SrcView&gt;::type, gray_layout_t&gt; gray_pixel_t;<br /> x_gradient(color_converted_view&lt;gray_pixel_t&gt;(src), dst);<br />}<br /></pre>
</div>
<p>如果目标颜色空间和通道类型和源视图的一致, 颜色变换就没有必要. GIL能够检测到这一点,从而完全避免颜色变换.
也就是说<code>color_converted_view</code> 就返回原来的视图 </p>
<h3><a class="anchor" name="ImagesSec">图
像</a></h3>
上面的代码存在一个性能问题-函数 x_gradient
对绝大多数的像素引用两次(译者注:每个目标像素值计算需要引用源像素值两次,因为要计算二者之差),因而需要进行两次变换.有时候建立一个临时缓冲区,
对拷贝的源图像计算其梯度也许更加有效, 因为这样颜色变换只需要进行一次. 其非泛型算法如下:
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keywordtype">void</span> x_luminosity_gradient(<span class="keyword">const</span> rgb32fc_view_t&amp; src, <span class="keyword">const</span> gray8s_view_t&amp; dst) {<br />    gray8_image_t ccv_image(src.dimensions());<br />    <a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(color_converted_view&lt;gray8_pixel_t&gt;(src), <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(ccv_image));<br /><br />    x_gradient(<a class="code" title="Returns the constant-pixel view of an image." href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996">const_view</a>(ccv_image), dst);<br />}</pre>
</div>
<p>首先我们构造一个和源视图具有相同维度的8位灰度图像临时缓冲区,
然后我们把颜色变换后的视图拷贝到临时缓冲区,最后我们把算法 <code>x_gradient</code>
应用在这个临时缓冲区构造的只读视图上. 正如实例所示, GIL 提供了全局函数 <code>view</code>
和 <code>const_view</code> 把图像转变为像素可变和不可变的视图.</p>
<p>创建上面算法的泛型版本需要一点的小技巧:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> x_luminosity_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br />    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;DstView&gt;::type d_channel_t;<br />    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_convert_to_unsigned&lt;d_channel_t&gt;::type channel_t;<br />    <span class="keyword">typedef</span> pixel&lt;channel_t, gray_layout_t&gt;  gray_pixel_t;<br />    <span class="keyword">typedef</span> image&lt;gray_pixel_t, false&gt;       gray_image_t;<br /><br />    gray_image_t ccv_image(src.dimensions());<br />    <a class="code" title="std::copy for image views" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415">copy_pixels</a>(color_converted_view&lt;gray_pixel_t&gt;(src), <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(ccv_image));<br />    x_gradient(<a class="code" title="Returns the constant-pixel view of an image." href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996">const_view</a>(ccv_image), dst);<br />}<br /></pre>
</div>
<p>首先我们使用元函数 <code>channel_type</code>
得到目标视图的通道类型. 所谓元函数就是操纵类型的函数.
在GIL中,元函数都是这样的结构体:以类型作为模板参数,通过嵌套的typedef输出结果类型,并且命名为 type. 在这个实例中,<code>
channel_type </code> 是一个一元元函数,输入一个视图类型,得到一个和视图类型关联的颜色通道类型.</p>
<p>GIL 构造的相关类型包括: 像素类型, 像素迭代器,定位器,图像和视图类型等, 它们都是概念 <code>PixelBasedConcept</code>
的模型, 这意味着它们都提供了一组元函数来查询像素的属性,例如 <code>channel_type</code>,
<code>color_space_type</code>, <code>channel_mapping_type</code>,
和 <code>num_channels</code>.</p>
<p>得到目标视图的颜色通道类型以后,我们使用另外一个元函数删除其类型的符号位(如果存在符号位的话),然后就能够得到灰度
像素类型.从像素类型就可以得到图像类型. 使用像素类型和指示图像是间隔和还是平面的布尔值作为模板参数即可构造图像类型.
GIL中的单通道(灰度级)图像必定是间隔的. GIL可以使用多种方式构造图像类型, 除了直接构造,
我们还可以使用类型工厂元函数,其等价的代码如下:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> x_luminosity_gradient(<span class="keyword">const</span> SrcView&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br />    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;DstView&gt;::type d_channel_t;<br />    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_convert_to_unsigned&lt;d_channel_t&gt;::type channel_t;<br />    <span class="keyword">typedef</span> <span class="keyword">typename</span> image_type&lt;channel_t, gray_layout_t&gt;::type gray_image_t;<br />    <span class="keyword">typedef</span> <span class="keyword">typename</span> gray_image_t::value_type gray_pixel_t;<br /><br />    gray_image_t ccv_image(src.dimensions());<br />    copy_and_convert_pixels(src, <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(ccv_image));<br />    x_gradient(<a class="code" title="Returns the constant-pixel view of an image." href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996">const_view</a>(ccv_image), dst);<br />}<br /></pre>
</div>
<p>GIL 提供了一组元函数来产生GIL的类型- <code>image_type</code>
是这样的元函数之一,它通过给定的通道类型,颜色布局,平面的还是间隔的(默认的是间隔的)来构造图像类型.
还有其他类似的元函数,用来构造像素引用,迭代器,定位器和图像视图. GIL 还提供了如下的元函数 <code>derived_pixel_reference_type</code>,
<code>derived_iterator_type</code>, <code>derived_view_type</code>
和 <code>derived_image_type</code>
,这些元函数通过改变给定的源图像类型的一个或者多个属性,并且保持其他的属性不变来构造新的图像类型.</p>
<p>通过图像类型嵌套的类型定义 <code>value_type</code>
可以得到像素的类型. GIL 图像,图像视图和定位器都有内嵌的类型定义 <code>value_type</code>
和 <code>reference</code> ,指向像素和像素引用的类型.如果你有一个像素迭代器,你可以使用 <code>iterator_traits</code>
来获得这些类型定义. 另外还要注意到算法函数 <code>copy_and_convert_pixels</code>
是函数<code>copy_pixels</code> 实现颜色转换的一个精简版本.</p>
<h3><a class="anchor" name="VirtualViewSec">虚
拟图像视图</a></h3>
到现在为止,我们能够处理像素内容在内存中的图像类型了. GIL 允许你创建任何图像的视图,包括合成函数. 为了说明这一点,我们创建一个
Mandelbrot 集的视图. 首先,我们需要定义个仿函数, 用来计算在图像在给定位置x,y处的 Mandelbrot 集合(译者注,参见<a>http://en.wikipedia.org/wiki/Mandelbrot_set</a>)
的数值
<div class="fragment">
<pre class="fragment"><span class="comment">// models PixelDereferenceAdaptorConcept</span><br /><span class="keyword">struct </span>mandelbrot_fn {<br /> <span class="keyword">typedef</span> point2&lt;ptrdiff_t&gt; point_t;<br /><br /> <span class="keyword">typedef</span> mandelbrot_fn const_t;<br /> <span class="keyword">typedef</span> gray8_pixel_t value_type;<br /> <span class="keyword">typedef</span> value_type reference;<br /> <span class="keyword">typedef</span> value_type const_reference;<br /> <span class="keyword">typedef</span> point_t argument_type;<br /> <span class="keyword">typedef</span> reference result_type;<br /> BOOST_STATIC_CONSTANT(<span class="keywordtype">bool</span>, is_mutable=<span class="keyword">false</span>);<br /><br /> mandelbrot_fn() {}<br /> mandelbrot_fn(<span class="keyword">const</span> point_t&amp; sz) : _img_size(sz) {}<br /><br /> result_type operator()(<span class="keyword">const</span> point_t&amp; p)<span class="keyword"> const </span>{<br /> <span class="comment">// 规格化坐标为 (-2..1, -1.5..1.5)</span><br /><span class="keywordtype">double</span> t=get_num_iter(point2&lt;double&gt;(p.x/(<span class="keywordtype">double</span>)_img_size.x*3-2, p.y/(<span class="keywordtype">double</span>)_img_size.y*3-1.5f));<br /> <span class="keywordflow">return</span> value_type((bits8)(pow(t,0.2)*255)); <span class="comment">// 进行power运算以便查看</span><br />}<br /><span class="keyword">private</span>:<br /> point_t _img_size;<br /><br /> <span class="keywordtype">double</span> get_num_iter(<span class="keyword">const</span> point2&lt;double&gt;&amp; p)<span class="keyword"> const </span>{<br /> point2&lt;double&gt; Z(0,0);<br /> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;100; ++i) { <span class="comment">// 100 次迭代</span><br />Z = point2&lt;double&gt;(Z.x*Z.x - Z.y*Z.y + p.x, 2*Z.x*Z.y + p.y);<br /><span class="keywordflow">if</span> (Z.x*Z.x + Z.y*Z.y &gt; 4)<br /> <span class="keywordflow">return</span> i/(double)100;<br /> }<br /> <span class="keywordflow">return</span> 0;<br /> }<br />};<br /></pre>
</div>
<p>现在我们可以使用这个仿函数和GIL的<code>virtual_2d_locator</code>
来构造一个 200x200 像素的Mandelbrot集视图:</p>
<div class="fragment">
<pre class="fragment"><span class="keyword">typedef</span> mandelbrot_fn::point_t point_t;<br /><span class="keyword">typedef</span> virtual_2d_locator&lt;mandelbrot_fn,false&gt; locator_t;<br /><span class="keyword">typedef</span> image_view&lt;locator_t&gt; my_virt_view_t;<br /><br />point_t dims(200,200);<br /><br /><span class="comment">// 使用定位器构造Mandelbrot视图, 从左上角开始,步长是(1,1)</span><br />my_virt_view_t mandel(dims, locator_t(point_t(0,0), point_t(1,1), mandelbrot_fn(dims)));<br /></pre>
</div>
<p>我们可以把这个合成函数构造的图像图当成真正的图像一样使用. 例如,可以调用我们的算法 <code>x_gradient</code>
,计算Mandelbrot 集旋转90°以后的梯度,并且把原始图像和结果图像存储下来:</p>
<p></p>
<div class="fragment">
<pre class="fragment">gray8s_image_t img(dims);<br />x_gradient(rotated90cw_view(mandel), <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(img));<br /><br /><span class="comment">// 存储Mandelbrot集和旋转90°以后的梯度(jpeg 不能存储有符号类型,必须转换位无符号类型的)<br /></span><a class="code" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg..." href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde">jpeg_write_view</a>(<span class="stringliteral">"mandel.jpg"</span>,mandel);<br /><a class="code" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg..." href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde">jpeg_write_view</a>(<span class="stringliteral">"mandel_grad.jpg"</span>,color_converted_view&lt;gray8_pixel_t&gt;(<a class="code" title="Returns the constant-pixel view of an image." href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996">const_view</a>(img)));<br /></pre>
</div>
<p>下面是这两个文件的存储结果的样子:</p>
<p></p>
<div align="center"><img src="mandel.jpg" alt="mandel.jpg" />
</div>
<h3><a class="anchor" name="DynamicImageSec">
运行时指派的图像和图像视图</a></h3>
到现在为止我们能够使用泛型函数计算由模板参数构造的图像视图的梯度了. 但是有的时候图像视图的属性,例如颜色空间,通道深度,在编译期无法得到.
GIL的扩展<code>dynamic_image</code> ,也叫变体, 使得GIL的构造可以工作在运行期.
GIL提供了运行期实例化的图像类型 <code>any_image_view</code>,
和运行期实例化的图像视图类型<code>any_pixel_iterator</code>.
创建其他变体的机制也都有,例如 <code>any_pixel</code>, <code>any_pixel_iterator</code>等
等. 绝大多数的GIL算法和所有的视图转换函数都适应于运行时的类型. 另外二元算法,例如<code>copy_pixels</code>
, 其中的一个或者两个参数都是变体类型.
<p>我们利用算法<code>x_luminosity_gradient</code>
来说明变体图像视图类型的使用.为了简化,我们只是假定源视图为变体类型.
(作为使用多个变体类型的示例,参考GIL采用多个变体参数重载的算法函数).</p>
<p>首先,我们构造一个仿函数,以目标视图类型为模板参数, 同时仿函数的应用操作符以源视图类型为模板参数:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" title="Includes all of the GIL dynamic image extension files, for convenience." href="g_i_l_0083.html">boost/gil/extension/dynamic_image/dynamic_image_all.hpp</a>&gt;</span><br /><br /><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DstView&gt;<br /><span class="keyword">struct </span>x_gradient_obj {<br />    <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;        <span class="comment">// </span><span class="comment">这里需要typede</span><span class="comment">f</span><br />    <br />    <span class="keyword">const</span> DstView&amp; _dst;<br />    x_gradient_obj(<span class="keyword">const</span> DstView&amp; dst) : _dst(dst) {}<br /><br />    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView&gt; <br />    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> SrcView&amp; src)<span class="keyword"> const </span>{ x_luminosity_gradient(src, _dst); }<br />};<br /></pre>
</div>
<p>第二步是提供函数<code>x_luminosity_gradient</code>
的一个重载版本,它以变体图像类型作为参数. 然后把这个仿函数作为参数传递给GIL的函数 <code>apply_operation</code>调
用:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcViews, <span class="keyword">typename</span> DstView&gt;<br /><span class="keywordtype">void</span> x_luminosity_gradient(<span class="keyword">const</span> any_image_view&lt;SrcViews&gt;&amp; src, <span class="keyword">const</span> DstView&amp; dst) {<br />    <a class="code" title="Invokes a generic mutable operation (represented as a unary function object) on a..." href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505">apply_operation</a>(src, x_gradient_obj&lt;DstView&gt;(dst));<br />}<br /></pre>
</div>
<p><code>any_image_view&lt;SrcViews&gt;</code>是
一个图像视图变体类型. 它的模板参数是<code>SrcViews</code>,
这是变体类型所有可能图像视图类型的一个枚举. <code>src</code>
内部包含了一个当前实例化类型的索引,同时还包含图像实体的内存地址. 函数 <code>apply_operation</code>
通过一个switch 语句遍历索引,在每个case语句内部,
把裸内存转型为对应的视图类型实例对象,然后针对这个对象调用仿函数.针对变体类型调用转发会产生switch语句的性能开销.但是对于变体每个图像视图
的像素操作算法, 实际上不会带来性能衰退.</p>
<p>下面是我们构造变体类型的实例,然后调用相关算法的代码描述:</p>
<p></p>
<div class="fragment">
<pre class="fragment"><span class="preprocessor">#include &lt;boost/mpl/vector.hpp&gt;</span><br /><span class="preprocessor">#include &lt;<a class="code" title="Support for reading and writing JPEG files Requires libjpeg." href="g_i_l_0232.html">boost/gil/extension/io/jpeg_dynamic_io.hpp</a>&gt;</span><br /><br /><span class="keyword">typedef</span> mpl::vector&lt;gray8_image_t, gray16_image_t, rgb8_image_t, rgb16_image_t&gt; my_img_types;<br />any_image&lt;my_img_types&gt; runtime_image;<br /><a class="code" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name..." href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398">jpeg_read_image</a>(<span class="stringliteral">"input.jpg"</span>, runtime_image);<br /><br />gray8s_image_t gradient(runtime_image.dimensions());<br />x_luminosity_gradient(<a class="code" title="Returns the constant-pixel view of an image." href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996">const_view</a>(runtime_image), <a class="code" title="Returns the non-constant-pixel view of an image." href="g_i_l_0135.html#gad0335b7d343667d626556681486f198">view</a>(gradient));<br /><a class="code" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg..." href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde">jpeg_write_view</a>(<span class="stringliteral">"x_gradient.jpg"</span>, color_converted_view&lt;gray8_pixel_t&gt;(<a class="code" title="Returns the constant-pixel view of an image." href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996">const_view</a>(gradient)));<br /></pre>
</div>
<p>在这个例子当中, 我们创建了一个可能是8位,16位的RGB类型或灰度级类型的图像. 然后我们调用GIL的I/O
扩展, 从文件加载其颜色空间和通道深度. 如果磁盘的文件不匹配我们给定的类型, 就会抛出一个异常.
接着我们构造一个有符号的图像类型来存储梯度, 下一步调用函数<code>x_gradient</code> 计算梯度.
最后我们把结果存储到另外一个文件. 我们把图像存储为8位无符号类型, 因为JPEG I/O 不支持有符号的char类型.</p>
<p>注意这些自由函数和方法<code>jpeg_read_image</code>, <code>dimensions</code>,
<code>view</code> 和 <code>const_view</code>
是如何工作在模板参数和变体类型参数上的. 对于模板化的图像函数view(img) 得到一个模板化的 view,
而变体类型的图像则得到一个变体类型的图像. 例如<code>view(runtime_image)</code>
的返回类型是 <code>any_image_view&lt;Views&gt;</code>
,其中的 Views 枚举了相关的4种图像类型. <code>const_view(runtime_image)</code>
得到4种只读的 <code>any_image_view</code> 类型.</p>
<p>使用变体类型的一个警告: 实例化变体类型参数的算法就会实例化所有可能的视图类型. 对于2元算法而言,
这意味着需要实例化所有可能类型的2元组合! 这会引起编译时间和执行程序大小的膨胀.</p>
<h2><a class="anchor" name="ConclusionSec">结
论</a></h2>
这个教程展示了使用GIL算法进行泛型化高效图像处理的各种挑战.
我们使用一个很简单的算法,使之能够工作在各种情况下,这包括不同的存储位数,颜色空间,通道次序以及不同的平面/间隔结构.
我们展示了算法适用于完全抽象的图像类型, 甚至还包括运行时的图像类型. 相关的视频教程还展现了在复杂场景下生成的代码,
其性能也可以和针对某种特定图像类型的手写C代码相媲美.
<p>但是,甚至只是这样一个简单的算法,距离完全泛化和完全优化还很远. 例如, 使用的算法还只能操纵同质的图像类型,
也就是像素的通道类型必须是相同的. 实际上存在这样的图像,例如压缩的565 RGB 格式, 其颜色通道类型是不一致的.
GIL提供了操纵异质图像类型的概念和算法,我们把这个扩展算法x_gradient 的工作留给读者. 第二, 计算了梯度值以后,
我们只是简单的把它转换位目标通道的类型, 但是这可能不是我们期望的行为. 例如源图像的通道是[0..1] 范围内的浮点数,
而目标类型是unsigned char , 这就会造成目标结果总是0或1. 而实际上我们可能需要进行一次缩放,使得结果在目标类型值的范围内.
例如,函数<code>channel_convert</code>
就会在不同通道类型之间进行线性缩放,使得源通道值的范围转换为目标通道值的范围.</p>
<p>对于提高性能也还有很多工作要做. 通道级别的操作,例如半差操作, 可以抽象成为通道级别的原子算法,
而其性能消耗可以根据具体的通道类型进行选择. 另外可以使得某些操作针对于特定的处理器, 例如同时操纵一整行的像素值, 或者进行数据预取.
针对泛型算法的性能特化版本都可以实现. 最后,虽然编译器会越来越好,但是仍然可能对于泛型代码不能优化的情况,
例如内联化某些函数或者把一些变量放在寄存器当中. 如果性能是一个问题, 使用不同的编译器测试你的代码也许是一件值得的事情.</p>
<h2><a class="anchor" name="AppendixSec">附
录</a></h2>
<h3><a class="anchor" name="AppendixConventionSec">
GIL实体类型的命名约定</a></h3>
GIL实体(不是泛化的)类型的命名约定公式是:
<p><em>ColorSpace</em> + <em>BitDepth</em>
+ [<code>f</code> | <code>s</code>]+ [<code>c</code>]
+ [<code>_planar</code>] + [<code>_step</code>]
+ <em>ClassType</em> + <code>_t</code> </p>
<p>其中 <em>ColorSpace</em> 指示了颜色组成的次序. 例如<code>rgb</code>,
<code>bgr</code>, <code>cmyk</code>, <code>rgba</code>.
<em>BitDepth</em> 指示了颜色通道的位数,例如 <code>8</code>,<code>16</code>,<code>32</code>.
默认的通道类型是无符号整型;使用<code>s</code>表明是有符号整型,<code>f</code>表
明是浮点数,它总是有符号的. <code>c</code>表明只能对像素进行只读操作. _planar
表明是平面结构的(这和间隔结构相对). <code>_step</code> 指示特定的图像视图,
定位器和迭代器以non-trivial方式遍历数据(例如, 向后遍历或者每间隔一个像素遍历). <em>ClassType</em>
表明 <code>_image</code> (图像), <code>_view</code>
(图像视图), <code>_loc</code> (像素定位器) <code>_ptr</code>
(像素迭代器), <code>_ref</code> (像素引用), <code>_pixel</code>(像
素值).</p>
<p></p>
<div class="fragment">
<pre class="fragment">bgr8_image_t a; <span class="comment">// 8位间隔的BGR图像</span><br />cmyk16_pixel_t; b; <span class="comment">// 16-位 CMYK 像素类型;;</span><br />cmyk16c_planar_ref_t c(b); <span class="comment">// 指向16-位平面结构CMYK像素x的常量引用.</span><br />rgb32f_planar_step_ptr_t d; <span class="comment">// 指向32-位平面RGB像素的step 迭代器.</span>
</pre>
</div>
<p></p><div id="footer" title="footer: links to copyright and other legal information"><a href="licenses.html" class="el">Copyright © 2005 Adobe Systems Incorporated</a><ul id="list1">
<li id="terms">
<a href="http://www.adobe.com/misc/copyright.html" title="Terms of Use">Terms of Use</a></li>
<li>
<a href="http://www.adobe.com/misc/privacy.html" title="Privacy Policy">Privacy Policy</a></li>
<li>
<a href="http://access.adobe.com">Accessibility</a></li>
<li>
<a href="http://www.adobe.com/aboutadobe/antipiracy/main.html" title="Avoid software piracy">Avoid software piracy</a></li>
<li id="tms">
<a href="http://www.adobe.com/misc/agreement.html" title="Permissions and trademarks">Permissions and trademarks</a></li>
<li>
<a href="http://www.adobe.com/products/eulas/main.html" title="Product License Agreements">Product License Agreements</a></li>
</ul>
</div> 
<hr size="1" /><address style="text-align: right;"><small>Generated on Sat May 2 13:50:16 2009 for Generic Image Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.5.6 </small></address>
</td></tr></tbody></table></body></html>
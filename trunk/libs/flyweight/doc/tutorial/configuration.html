<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>



  
  
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">


  


  
  
  
  <title>Boost.Flyweight Documentation - Tutorial - Configuring Boost.Flyweight</title>
  <link rel="stylesheet" href="../style.css" type="text/css">



  
  
  <link rel="start" href="../index.html">



  
  
  <link rel="prev" href="key_value.html">



  
  
  <link rel="up" href="index.html">



  
  
  <link rel="next" href="extension.html">
</head>


<body>



<h1><img src="../../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Tutorial: Configuring Boost.Flyweight</h1>



<div class="prev_link"><a href="key_value.html"><img src="../prev.gif" alt="key-value flyweights" border="0"><br>



Key-value flyweights
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>



Boost.Flyweight tutorial
</a></div>



<div class="next_link"><a href="extension.html"><img src="../next.gif" alt="extending Boost.Flyweight" border="0"><br>



Extending Boost.Flyweight
</a></div>



<br style="" clear="all">



<hr>
<h2>Contents &nbsp;&#30446;&#24405;</h2>



<ul>



  <li><a href="#intro">Configurable aspects of
Boost.Flyweight &nbsp;Boost.Flyweight&#21487;&#37197;&#32622;&#30340;&#30028;&#38754;</a>
    
    
    <ul>



      <li><a href="#free_order_template">Free-order
template parameter interface &nbsp;&#27169;&#26495;&#21442;&#25968;&#39034;&#24207;&#33258;&#30001;&#30340;&#30028;&#38754;</a></li>



      <li><a href="#header_inclusion">Header
inclusion &nbsp;&#25152;&#21253;&#21547;&#30340;&#22836;&#25991;&#20214;</a></li>



    
    
    </ul>



  </li>



  <li><a href="#tagging">Tagging &nbsp;&#26631;&#35760;</a></li>



  <li><a href="#factories">Factory specification
&nbsp;&#24037;&#21378;&#35268;&#33539;</a>
    
    
    <ul>



      <li><a href="#factory_types">Types involved in
the configuration of factories &nbsp;&#37197;&#32622;&#24037;&#21378;&#26102;&#25152;&#38656;&#30340;&#31867;&#22411;</a></li>



      <li><a href="#hashed_factory"><code>hashed_factory</code></a></li>



      <li><a href="#set_factory"><code>set_factory</code></a></li>



      <li><a href="#assoc_container_factory"><code>assoc_container_factory</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#holders">Holder specification
&nbsp;Holder&#35268;&#33539;</a>
    
    
    <ul>



      <li><a href="#static_holder"><code>static_holder</code></a></li>



      <li><a href="#intermodule_holder"><code>intermodule_holder</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#locking">Locking policies
&nbsp;&#38145;&#23450;&#31574;&#30053;</a>
    
    
    <ul>



      <li><a href="#simple_locking"><code>simple_locking</code></a></li>



      <li><a href="#no_locking"><code>no_locking</code></a></li>



    
    
    </ul>



  </li>



  <li><a href="#tracking">Tracking policies
&nbsp;&#36319;&#36394;&#31574;&#30053;</a>
    
    
    <ul>



      <li><a href="#refcounted"><code>refcounted</code></a></li>



      <li><a href="#no_tracking"><code>no_tracking</code></a></li>



    
    
    </ul>



  </li>



</ul>



<h2><a name="intro">Configurable aspects of
Boost.Flyweight &nbsp;Boost.Flyweight&#21487;&#37197;&#32622;&#30340;&#30028;&#38754;</a></h2>



<p>
Most of the time, <code>flyweight</code> default
configuration is just good
enough and the user need not care about further tuning of her <code>flyweight</code>
instantiations; however, when the necessity for more control over
Boost.Flyweight
behavior arises, comprehensive mechanisms are provided to select,
configure and
even extend the following implementation aspects:</p>



<p>
&#32477;&#22823;&#22810;&#25968;&#26102;&#20505;&#65292;<code>flyweight</code>&#30340;&#40664;&#35748;&#37197;&#32622;&#36275;&#22815;&#22909;&#65292;&#24182;&#19988;&#29992;&#25143;&#19981;&#38656;&#35201;&#20851;&#23545;&#24515;&#23545;<code>flyweight</code>&#23454;
&#20363;&#30340;&#36827;&#19968;&#27493;&#35843;&#25972;&#65307;&#28982;&#32780;&#65292;&#24403;&#26377;&#24517;&#35201;&#23545;Boost.Flyweight&#30340;&#34892;&#20026;&#36827;&#34892;&#26356;&#22810;&#30340;&#25511;&#21046;&#26102;&#65292;&#25552;&#20379;&#20102;&#20840;&#38754;&#30340;&#26426;&#21046;&#21487;&#20379;&#25361;&#36873;&#65292;&#37197;&#32622;&#29978;&#33267;&#25193;&#23637;&#22914;&#19979;&#30340;&#23454;&#29616;&#26041;&#38754;&#12290;</p>



<ul>



  <li><a href="#tagging">Type tagging</a>.
&nbsp;&#31867;&#22411;&#26631;&#27880;</li>



  <li><a href="#factories">Factory</a> used to
store the shared values <code>flyweight</code> objects
refer to. &nbsp;&#29992;&#26469;&#23384;&#20648;&#34987;flyweight&#23545;&#35937;&#25152;&#24341;&#29992;&#30340;&#20849;&#20139;&#30340;&#20540;&#30340;&#24037;&#21378; </li>



  <li><a href="#holders">Mechanism of instantiation</a>
of the flyweight factory. &nbsp;flyweight&#24037;&#21378;&#30340;&#23454;&#20363;&#21270;&#26426;&#21046;</li>



  <li>Internal <a href="#locking">synchronization
mechanism</a> for access to the internal factory in multithreaded
environments. &nbsp;&#22312;&#22810;&#32447;&#31243;&#29615;&#22659;&#19979;&#23545;&#20869;&#37096;&#24037;&#21378;&#35775;&#38382;&#26102;&#30340;&#20869;&#37096;&#21516;&#27493;&#26426;&#21046;</li>



  <li><a href="#tracking">Tracking policy</a>
controlling how a value stored in the factory is handled when all the
flyweight objects associated to it are destroyed.
&nbsp;&#36319;&#36394;&#31574;&#30053;&#25511;&#21046;&#24403;&#25152;&#26377;&#20851;&#32852;&#21040;&#23384;&#20648;&#22312;&#24037;&#21378;&#20013;&#30340;&#20540;&#30340;flyweight
    
    
    <div id=":3b" class="ii gt"><wbr>&#23545;&#35937;&#37117;&#38144;&#27585;&#21518;&#23427;&#35813;&#24590;
&#20040;&#22788;&#29702;&#12290;</div>



  </li>



</ul>



<h3><a name="free_order_template">Free-order
template parameter interface &nbsp;&#27169;&#26495;&#21442;&#25968;&#39034;&#24207;&#33258;&#30001;&#30340;&#25509;&#21475;</a></h3>



<p>
The <code>flyweight</code> class template features a
"smart" specification
interface by which the configuration aspects can be provided as
optional template arguments
in whatever order the user pleases. For instance, a tagged <code>flyweight</code>
of <code>std::string</code>s with a <a href="#set_factory">set-based factory</a> and
<a href="#no_tracking">no tracking</a> can be
specified like this:</p>



<p>
<code>flyweight</code>&#31867;&#27169;&#26495;&#30340;&#29305;&#24615;&#26159;&#26377;&#19968;&#20010;&ldquo;&#26234;&#33021;&#30340;&rdquo;&#25509;&#21475;&#65292;
&#36890;&#36807;&#36825;&#20010;&#25509;&#21475;&#37197;&#32622;&#30028;&#38754;&#20316;&#20026;&#21487;&#36873;&#30340;&#27169;&#26495;&#21442;&#25968;&#20197;&#29992;&#25143;&#21916;&#27426;&#30340;&#20219;&#24847;&#39034;
&#24207;&#25552;&#20379;&#12290;&#20363;&#22914;&#65292;&#19968;&#20010;<code></code>&#21516;&#26102;&#25317;&#26377;tagged&#65292;<a href="configuration.html#set_factory">set-based factory</a>&#21644;<a href="configuration.html#no_tracking">no tracking</a>&#31561;&#20960;
&#39033;&#37197;&#32622;&#30028;&#38754;&#30340;<code>std::string</code>s&#31867;&#30340;<code>flyweight</code>&#21487;
&#20197;&#25353;&#36825;&#26679;&#30340;&#26041;&#24335;&#25351;&#23450;&#65306;</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">label_t</span><span class="special">&gt;,</span> <span class="identifier">set_factory</span><span class="special">&lt;&gt;,</span> <span class="identifier">no_tracking</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
or like this:</p>



<p>
&#25110;&#32773;&#20687;&#36825;&#26679;
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">no_tracking</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">label_t</span><span class="special">&gt;,</span> <span class="identifier">set_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
or in any other order; only <code>std::string</code> is
required to occupy
the first place in the specification.</p>



<p>
&#25110;&#32773;&#20197;&#20219;&#20309;&#20854;&#23427;&#39034;&#24207;&#65307;&#21482;&#35201;<code>std::string</code>&#20986;&#29616;&#22312;&#30340;&#31532;&#19968;&#30340;&#20301;&#32622;&#12290;</p>



<h3><a name="header_inclusion">Header inclusion
&nbsp;&#22836;&#25991;&#20214;&#21253;&#21547;</a></h3>



<p>
The example code shown at the <a href="basics.html#intro">introductory
section</a>
uses the
<a href="../reference/index.html#flyweight_synopsis"><code>"boost/flyweight.hpp"</code></a>
convenience header, which simply includes the headers for the class
template
<code>flyweight</code> and its default configuration
components:</p>



<p><a href="basics.html#intro">&#31616;&#20171;&#31456;&#33410;</a>&#20013;&#23637;&#31034;&#30340;&#31034;&#20363;&#20195;&#30721;
&#20351;&#29992;<a href="../reference/index.html#flyweight_synopsis"><code>"boost/flyweight.hpp"</code></a>&#31616;
&#26131;&#22836;&#25991;&#20214;&#65292;&#23427;&#21482;&#26159;&#31616;&#21333;&#30340;&#21253;&#21547;&#20102;<code>flyweight</code>&#31867;&#27169;&#26495;&#21644;&#23427;&#30340;&#40664;&#35748;&#37197;&#32622;&#32452;&#20214;&#30340;&#22836;&#25991;&#20214;&#12290;
</p>



<blockquote>
  
  
  <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// class template flyweight</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">hashed_factory</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// hashed flyweight factory</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">static_holder</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// regular factory instantiation</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">simple_locking</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// simple locking policy</span><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">refcounted</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// refcounting tracking policy</span></pre>



</blockquote>



<p>
When using components other than these, their specific headers must be
explicitly included.</p>



<p>
&#24403;&#20351;&#29992;&#38500;&#27492;&#20043;&#22806;&#20854;&#23427;&#30340;&#32452;&#20214;&#26102;&#65292;&#24517;&#39035;&#26174;&#31034;&#21253;&#21547;&#29305;&#23450;&#30340;&#22836;&#25991;&#20214;&#12290;
</p>



<h2><a name="tagging">Tagging &nbsp;&#26631;&#35760;</a></h2>



<p>
Consider the following two types:</p>



<p>
&#32771;&#34385;&#20197;&#19979;2&#31181;&#31867;&#22411;&#65306;
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">name_t</span><span class="special">;</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">ip_address_t</span><span class="special">;</span></pre>



</blockquote>



<p>
Although technically both types are identical, this is so by virtue of
coincidence, as there is no sensible relation between names and IP
addresses.
Internally, the fact that <code>name_t</code> and <code>ip_address_t</code>
are the same flyweight type causes values of both classes to be stored
together
in the same flyweight factory, although their respective ranges
are not expected to overlap. <i>Tagging</i> can be used to
turn these
into really different types:</p>



<p>&#34429;&#28982;&#20005;&#26684;&#26469;&#35828;&#36825;2&#31181;&#31867;&#22411;&#26159;&#23436;&#20840;&#19968;&#26679;&#30340;&#65292;&#20294;&#26159;&#36825;&#32431;&#23646;&#24039;&#21512;&#65292;&#22240;&#20026;&#22312;&#21517;&#23383;&#21644;IP&#22320;&#22336;&#20043;&#38388;&#27809;&#26377;&#26377;&#24847;&#20041;&#30340;&#20851;&#31995;&#12290;&#20174;&#20869;&#37096;&#30475;&#65292;<code>name_t</code>&#21644;<code>ip_address_t</code>&#26159;
&#30456;&#21516;flyweight&#31867;&#22411;&#30340;&#20107;&#23454;&#23548;&#33268;&#20004;&#31181;&#31867;&#22411;&#30340;&#20540;&#23384;&#22312;&#21516;&#19968;&#20010;flyweight&#24037;&#21378;&#37324;&#65292;&#34429;&#28982;&#21487;&#20197;&#39044;&#26009;&#23427;&#20204;&#21508;&#33258;&#30340;&#33539;&#22260;&#26159;&#19981;&#20250;&#26377;&#20132;&#38598;&#30340;&#12290;<i>&#26631;
&#27880; </i>&#21487;&#20197;&#20351;&#36825;&#20004;&#31181;&#31867;&#22411;&#25104;&#20026;&#30495;&#27491;&#19981;&#21516;&#30340;&#31867;&#22411;&#12290;
</p>



<blockquote>
  
  
  <pre><span class="keyword">struct</span> <span class="identifier">name_tag</span><span class="special">{};</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">name_tag</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">name_t</span><span class="special">;</span><br><span class="keyword">struct</span> <span class="identifier">ip_address_tag</span><span class="special">{};</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">ip_address_tag</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">ip_address_t</span><span class="special">;</span></pre>



</blockquote>



<p>
Now, <code>name_t</code> and <code>ip_address_t</code>
are different
flyweight classes having separate factories each. Tags are a purely
syntactic
device: any type can be used for tagging inside the <code>tag</code>
construct, though good style recommends using tag classes with
descriptive names which are local to the context where the flyweight
type
is being defined.</p>



<p>
&#29616;&#22312;&#65292;<code>name_t</code>&#21644;<code>ip_address_t</code>&#26159;
&#20998;&#21035;&#25317;&#26377;&#33258;&#36523;&#23384;&#20648;&#26742;&#30340;&#19981;&#21516;&#30340;flyweight&#31867;&#22411;&#12290;&#26631;&#35760;&#32431;&#31929;&#26159;&#19968;&#31181;&#35821;&#27861;&#35013;&#32622;&#65306;&#20219;&#20309;&#31867;&#22411;&#37117;&#21487;&#25343;&#26469;&#26500;&#36896;&#19968;&#20010;<code>tag</code>&#20570;
&#26631;&#35760;&#65292;&#28982;&#32780;&#22909;&#30340;&#39118;&#26684;&#24314;&#35758;tag&#31867;&#22411;&#24212;&#35813;&#20351;&#29992;&#20855;&#22791;&#25551;&#36848;&#24615;&#30340;&#31867;&#21517;&#23383;&#24182;&#19988;&#36825;&#20010;&#31867;&#22411;&#24212;&#35813;&#38752;&#36817;&#23450;&#20041;flyweight&#31867;&#22411;&#30340;&#19978;&#19979;&#25991;&#12290;
</p>



<h2><a name="factories">Factory specification
&nbsp;&#24037;&#21378;&#35268;&#33539;</a></h2>



<p>
<code>flyweight</code> uses a type of internal component
called
<i>factory</i> whose purpose is to store and retrieve the
different values
flyweight objects refer to at a given time. By default, a factory based
on
a hashed container is used, so that <code>flyweight&lt;T&gt;</code>
is
actually equivalent to</p>



<p>
<code>flyweight</code>&#20351;&#29992;&#19968;&#31181;&#31216;&#20043;&#20026;<span style="font-style: italic;">&#24037;&#21378;</span>&#30340;&#20869;&#37096;&#32452;&#20214;&#31867;&#22411;&#65292;&#24037;&#21378;&#34987;&#29992;&#26469;&#23384;&#21462;&#22312;&#26576;&#19968;
&#26102;&#21051;flyweight&#23545;&#35937;&#24341;&#29992;&#30340;&#19981;&#21516;&#30340;&#20540;&#12290;&#40664;&#35748;&#24773;&#20917;&#19979;&#65292;&#20351;&#29992;&#30340;&#26159;&#19968;&#20010;&#22522;&#20110;&#21704;&#24076;&#23481;&#22120;&#30340;&#24037;&#21378;&#65292;&#22240;&#27492;<code>flyweight&lt;T&gt;</code>&#23454;
&#38469;&#19978;&#30456;&#24403;&#20110;
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">hashed_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
where <code>hashed_factory</code> is a so-called <i>factory
specifier</i>.
Boost.Flyweight provides several predefined factory specifiers, which
not
only let the user select the specific type of factory used, but also
accept their own template arguments to customize each factory.</p>



<p>
&#22312;&#36825;&#37324;<code>hashed_factory</code>&#26159;&#19968;&#20010;&#25152;&#35859;&#30340;<span style="font-style: italic;">&#24037;&#21378;&#25551;&#36848;&#31526;</span>&#12290;Boost.Flyweight
&#25552;&#20379;&#20102;&#20960;&#20010;&#39044;&#23450;&#20041;&#30340;&#24037;&#21378;&#25551;&#36848;&#31526;&#65292;&#23427;&#20204;&#19981;&#20165;&#20801;&#35768;&#29992;&#25143;&#36873;&#25321;&#29305;&#23450;&#31867;&#22411;&#30340;&#24037;&#21378;&#65292;&#32780;&#19988;&#27599;&#20010;&#24037;&#21378;&#33258;&#24049;&#20063;&#25509;&#21463;&#27169;&#26495;&#21442;&#25968;&#26469;&#21152;&#20197;&#35746;&#21046;&#12290;
</p>



<h3><a name="factory_types">Types involved in the
configuration of factories &nbsp;&#37197;&#32622;&#24037;&#21378;&#26102;&#25152;&#38656;&#30340;&#31867;&#22411;</a></h3>



<p>
A given <code>flyweight</code> instantiation has
associated
<code>flyweight::key_type</code>
and <code>flyweight::value_type</code> types (which are
equal in the case
of regular flyweights or different if <a href="key_value.html">key-value
flyweights</a>
are used). Also, there is an internal <code>Entry</code>
type which
corresponds to the type of the objects actually stored in the factory:
<code>Entry</code> contains the shared <code>value_type</code>
objects
of <code>flyweight</code> as well a some internal
bookkeeping information;
also, <code>Entry</code> is implicitly convertible to
<code>const key_type&amp;</code>, so that factories can
rely on
<code>key_type</code> to look up <code>Entrie</code>s.
Since
<code>Entry</code> is internal to the implementation of <code>flyweight</code>,
it cannot be directly referred to by the user in the configuration of
factories. Instead, the proxy
<a href="../../../mpl/doc/refmanual/placeholders.html"><i>placeholder</i></a>
type <code>boost::mpl::_1</code> can be used.</p>



<p>
&#19968;&#20010;&#32473;&#23450;&#30340;<code>flyweight</code>&#23454;&#20363;&#26377;&#30456;&#20851;&#30340;<code>flyweight::key_type</code>&#21644;<code>flyweight::value_type</code>&#31867;
&#22411;&#65288;&#23427;&#20204;&#22312;&#26222;&#36890;flyweights&#24773;&#20917;&#19979;&#26159;&#30456;&#21516;&#30340;&#22312;<a href="key_value.html">&#38190;-&#20540;
flyweights</a>&#26102;&#19981;&#21516;&#30340;&#65289;&#12290;&#19982;&#27492;&#21516;&#26102;&#65292;&#36824;&#26377;&#19968;&#20010;&#20869;&#37096;&#30340;<code>Entry</code>&#31867;&#22411;&#30456;&#24403;
&#20110;&#23454;&#38469;&#23384;&#20648;&#22312;&#24037;&#21378;&#37324;&#30340;&#23545;&#35937;&#30340;&#31867;&#22411;&#65306;<code>Entry</code>&#21253;&#21547;<code>flyweight</code>&#23545;
&#35937;&#25152;&#20849;&#20139;&#30340;<code>value_type</code>&#65292;&#36824;&#21253;&#25324;&#19968;&#20123;&#20869;&#37096;<span class="mn">&#31807;
&#35760;</span>&#35760;&#20449;&#24687;&#65307;&#32780;&#19988;&#65292;<code>Entry</code>&#21487;&#20197;&#38544;&#24335;&#36716;&#25442;&#25104;<code>const
key_type&amp;&#65292;</code>&#22240;&#27492;&#24037;&#21378;&#21487;&#20197;&#20381;&#36182;<code>key_type</code>&#26469;
&#26597;&#25214;<code>Entrie</code>s&#12290;&#26082;&#28982;<code>Entry</code>&#26159;<code>flyweight</code>&#30340;
&#20869;&#37096;&#23454;&#29616;&#32454;&#33410;&#65292;&#23427;&#19981;&#33021;&#22312;&#37197;&#32622;&#24037;&#21378;&#30340;&#26102;&#20505;&#34987;&#29992;&#25143;&#30452;&#25509;&#24341;&#29992;&#12290;&#21487;&#20197;&#29992;&#20195;&#29702;&#30340;<i><a href="../../../mpl/doc/refmanual/placeholders.html"><i>&#21344;
&#20301;&#31526;</i></a></i>&#31867;&#22411;<big><code>boost::mpl::_1</code></big>&#20316;
&#20026;&#26367;&#20195;&#12290;
</p>



<h3><a name="hashed_factory"><code>hashed_factory</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/factories.html#hashed_factory_synopsis"><code>"boost/flyweight/hashed_factory.hpp"</code></a><br>



  <b>Syntax:</b> <code>hashed_factory&lt;[Hash[,Pred[,Allocator]]]&gt;</code>
</blockquote>



<p>
This specifier, which Boost.Flyweight takes by default, controls the
usage of a
factory internally based in a hash container. Values are determined to
be
equivalent by means of the
<a href="http://www.sgi.com/tech/stl/BinaryPredicate.html"><code>Binary
Predicate</code></a> <code>Pred</code>, and
indexed into the factory container
using <code>Hash</code>, which is assumed to be a <i>hash
function</i>, i.e. a
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary
Function</code></a> assigning to each value a hash
identifier of
type <code>std::size_t</code>. The <code>Allocator</code>
parameter is
used by the factory container for its memory allocation needs. The
default
types for these parameters are such that the expression</p>



<p>&#36825;&#26159;Boost.Flyweight&#40664;&#35748;&#20351;&#29992;&#30340;&#25551;&#36848;&#31526;&#65292;&#23427;&#25511;&#21046;&#19968;&#20010;&#22312;&#20869;&#37096;&#22522;&#20110;&#21704;&#24076;&#23481;&#22120;&#30340;&#24037;&#21378;&#30340;&#20351;&#29992;&#12290;<a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">&#20108;&#20803;&#35859;&#35789;</a><big><code>Pred</code></big>&#29992;
&#26469;&#21028;&#26029;&#20540;&#26159;&#21542;&#30456;&#31561;&#65292;<big><code>Hash</code></big>&#29992;&#26469;&#35745;&#31639;&#20986;&#21040;&#36825;&#20010;&#24037;&#21378;&#23481;
&#22120;&#30340;&#32034;&#24341;<code></code>&#65292;<br>



&#20551;&#23450;&#23427;&#26159;&#19968;&#20010;<i style="font-style: italic;">&#21704;&#24076;</i><span style="font-style: italic;">&#20989;&#25968;</span>&#65292;&#23601;&#26159;&#35828;&#65292;&#20026;&#27599;&#20010;&#20540;&#20998;&#37197;&#19968;&#20010;<big><code>std::size_t</code></big>&#31867;
&#22411;&#30340;&#21704;&#24076;&#26631;&#35782;&#31526;&#30340;<a href="http://www.sgi.com/tech/stl/UnaryFunction.html">&#19968;
&#20803;&#20989;&#25968;</a>&#12290;<big><code>Allocator</code></big>&#21442;
&#25968;&#34987;&#24037;&#21378;&#23481;&#22120;&#29992;&#26469;&#36827;&#34892;&#25152;&#38656;&#30340;&#20869;&#23384;&#20998;&#37197;&#12290;&#36825;&#20123;&#21442;&#25968;&#30340;&#40664;&#35748;&#31867;&#22411;&#30340;&#34920;&#36798;&#24335;
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">hashed_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span> </pre>



</blockquote>



<p>
is equivalent to<br>



&#30456;&#24403;&#20110;
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">T</span><span class="special">,</span><br><span class="identifier">hashed_factory</span><span class="special">&lt;</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">key_value</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">key_value</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="special">&gt;</span></pre>



</blockquote>



<p>
where <code>key_type</code> is the key type of the
flyweight and
<code>boost::mpl::_1</code>, as explained above, stands for
the
internal <code>Entry</code> type of the elements stored in
the factory.
Suppose we would like to configure <code>hashed_factory</code>
for
a <code>std::string</code> flyweight with
a special hash predicate <code>special_hash</code> and a
custom allocator
<code>custom_allocator</code>; this would be specified as
follows:</p>



<p>&#36825;&#37324;<big><code>key_type</code></big>&#26159;flyweight
&#30340;&#38190;&#31867;&#22411;&#65292;&#22914;&#21069;&#25152;&#35828;&#65292;<big><code>boost::mpl::_1</code></big>&#20195;
&#34920;&#23384;&#20648;&#22312;&#24037;&#21378;&#37324;&#30340;&#20803;&#32032;&#30340;&#20869;&#37096;<big><code>Entry</code></big>&#31867;&#22411;&#12290;&#20551;&#23450;&#25105;
&#20204;&#24819;&#35201;&#37197;&#32622;&#19968;&#20010;<big><code>std::string</code></big>&#30340;flyweight
&#30340;<code><big>hashed_factory</big>&#65292;</code>&#32473;&#23427;&#25552;&#20379;&#19968;&#20010;&#29305;&#21035;
&#30340;&#21704;&#24076;&#35859;&#35789;<big><code>special_hash</code></big>&#36824;&#26377;&#19968;&#20010;&#33258;&#23450;&#20041;
&#30340;&#20998;&#37197;&#22120;<code><big>custom_allocator</big>&#65292;</code>&#21487;&#20197;&#25353;
&#29031;&#19979;&#38754;&#30340;&#26041;&#24335;&#25351;&#23450;&#65306;
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">hashed_factory</span><span class="special">&lt;</span><br><span class="identifier">special_hash</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">key_value</span><span class="special">&gt;,</span><br><span class="identifier">custom_allocator</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="special">&gt;</span></pre>



</blockquote>



<h3><a name="set_factory"><code>set_factory</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/factories.html#set_factory_synopsis"><code>"boost/flyweight/set_factory.hpp"</code></a><br>



  <b>Syntax:</b> <code>set_factory&lt;[Compare[,Allocator]]&gt;</code>
</blockquote>



<p>
<code>set_factory</code> resorts to an <code>std::set</code>-like
ordered
container for the implementation of the flyweight factory.
<code>Compare</code> must be a
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code>Strict
Weak Ordering</code></a> on the value type <code>flyweight</code>
is
acting upon; as is customary with STL ordered containers, two values
are considered equivalent if none is less than the other according to <code>Pred</code>.
<code>Allocator</code> is an allocator type passed along to
the factory
internal container for its memory-related tasks. When default
parameters are
used, the expression</p>



<p><big><code>set_factory</code></big>&#37319;&#29992;&#19968;&#20010;
&#31867;&#20284;&#20110;<big><code>std::set</code></big>&#30340;&#26377;&#24207;&#23481;&#22120;&#26469;&#23454;&#29616;
flyweight&#24037;&#21378;&#12290;<big><code>Compare</code></big>&#23545;&#20110;<big><code>flyweight</code></big>&#29992;
&#21040;&#30340;&#20540;&#31867;&#22411;&#24517;&#39035;&#26159;<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">&#20005;
&#26684;&#24369;&#24207;</a>&#30340;&#65307;&#25353;&#29031;STL&#26377;&#24207;&#23481;&#22120;&#30340;&#24815;&#20363;&#65292;&#26681;&#25454;<big><code>Pred</code></big>&#26469;
&#21028;&#26029;&#22914;&#26524;&#27809;&#26377;&#19968;&#20010;&#20540;&#27604;&#21478;&#19968;&#20010;&#20540;&#23567;&#37027;&#20040;&#36825;&#20004;&#20010;&#20540;&#34987;&#35748;&#20026;&#26159;&#30456;&#31561;&#30340;&#12290;&nbsp;<big><code>Allocator</code><code></code></big>&#26159;
&#19968;&#20010;&#20256;&#36882;&#32473;&#24037;&#21378;&#20869;&#37096;&#23481;&#22120;&#30340;&#20998;&#37197;&#22120;&#31867;&#22411;&#65292;&#29992;&#26469;&#22788;&#29702;&#20869;&#23384;&#30456;&#20851;&#30340;&#20219;&#21153;&#12290;&#24403;&#20351;&#29992;&#40664;&#35748;&#30340;&#21442;&#25968;&#26102;&#65292;&#34920;&#36798;&#24335;
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">set_factory</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span></pre>



</blockquote>



<p>
is equivalent to<br>



&#30456;&#24403;&#20110;
</p>



<blockquote>
  
  
  <pre><span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">T</span><span class="special">,</span><br><span class="identifier">set_factory</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">key_type</span><span class="special">&gt;,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span> <span class="special">&gt;</span><br><span class="special">&gt;</span></pre>



</blockquote>



<p>
Usual tradeoffs arising in the comparison of ordered and hashed
containers
also apply when choosing between <code>set_factory</code>
and
<code>hashed_factory</code>:
so, set-based lookup and insertion of values are generally slower than
those based on hashing,
but the latter can be affected by pathological worst-case scenarios
with very
poor performance.</p>



<p>&#22312;&#27604;&#36739;&#26377;&#24207;&#23481;&#22120;&#21644;&#21704;&#24076;&#23481;&#22120;&#26102;&#24471;&#20986;&#30340;&#26435;&#34913;&#21516;&#26679;&#36866;&#29992;&#20110;&#22312;&#36873;&#25321;<big><code>set_factory</code></big>&#36824;
&#26159;<big><code>hashed_factory</code></big>&#26102;&#65306;&#22240;&#27492;&#65292;&#22522;&#20110;
set&#30340;&#26597;&#25214;&#21644;&#25554;&#20837;&#36890;&#24120;&#35201;&#24930;&#20110;&#37027;&#20123;&#22522;&#20110;&#21704;&#24076;&#30340;&#65292;&#20294;&#26159;&#21518;&#32773;&#33021;&#34987;&#30149;&#24577;&#30340;&#26368;&#24046;&#29615;&#22659;&#25152;&#24433;&#21709;&#32780;&#23548;&#33268;&#20855;&#26377;&#38750;&#24120;&#24046;&#30340;&#24615;&#33021;&#12290;
</p>



<h3><a name="assoc_container_factory"><code>assoc_container_factory</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/factories.html#assoc_container_factory_synopsis"><code>"boost/flyweight/assoc_container_factory.hpp"</code></a><br>



  <b>Syntax:</b> <code>assoc_container_factory&lt;ContainerSpecifier&gt;</code>
</blockquote>



<p>
This specifier can be seen as a generalization of
<code>hashed_factory</code> and <code>set_factory</code>
where the user
supplies the exact type of container on which the factory is based. The
way in which the container is specified might seem at first a little
daunting to those unfamiliar with the
<a href="../../../mpl/doc/index.html">Boost MPL Library</a>:
<code>ContainerSpecifier</code> must be an <a href="lambda_expressions.html"><code>MPL Lambda
Expression</code></a> such that, when invoked with the
types <code>Entry</code> and <code>key_type</code>
explained <a href="#factory_types">above</a>, it
produces the type of a container of <code>Entry</code>
elements satisfying the following
requirements:</p>



<p>&#36825;&#31181;&#25551;&#36848;&#31526;&#21487;&#20197;&#34987;&#30475;&#20316;&#26159;<big><code>hashed_factory</code></big>&#21644;<big><code>set_factory</code></big>&#30340;
&#19968;&#33324;&#21270;&#24418;&#24335;&#65292;&#27492;&#26102;&#29992;&#25143;&#25552;&#20379;&#24037;&#21378;&#25152;&#20381;&#36182;&#30340;&#23481;&#22120;&#30340;&#30830;&#20999;&#31867;&#22411;&#12290;&#23545;&#37027;&#20123;&#19981;&#29087;&#24713;<a href="../../../mpl/doc/index.html">Boost
MPL &#24211;</a>&#30340;&#20154;&#26469;&#35828;&#65292;&#25551;&#36848;&#23481;&#22120;&#30340;&#26041;&#24335;&#20045;&#30475;&#36215;&#26469;&#21487;&#33021;&#20250;&#26377;&#28857;&#21523;&#20154;&#65306;<big><code>ContainerSpecifier</code></big>&#24517;
&#39035;&#26159;&#19968;&#20010;<a href="lambda_expressions.html"><code>MPL
Lambda
</code>&#34920;&#36798;&#24335;<code></code></a>&#65292;&#24403;&#29992;<a href="#factory_types">&#19978;&#25991;</a>&#25551;&#36848;&#30340;&#31867;&#22411;<big><code>Entry</code></big>&#21644;<big><code>key_type</code></big>&#26469;
&#35843;&#29992;&#23427;&#26102;&#65292;&#23427;&#23558;&#29983;&#25104;&#19968;&#20010;&#28385;&#36275;&#20197;&#19979;&#35201;&#27714;&#30340;<code>Entry</code>&#20803;&#32032;&#30340;&#23481;&#22120;&#65306;<span style="text-decoration: underline;"></span>
</p>



<ol>



  <li>The container type must be a model of <a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html"><code>Unique
Associative Container</code></a> where equivalence of <code>Entry</code>s
is determined by the <code>key_type</code> values the
entries are convertible to .</li>



  
  
  <p>&#23481;&#22120;&#31867;&#22411;&#24517;&#39035;&#26159;<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">&#21807;&#19968;&#20851;&#32852;&#23481;&#22120;</a>&#27169;&#22411;&#65292;<big><code>Entry</code>s</big>&#30340;&#30456;&#31561;&#24615;&#26159;&#30001;&#21487;&#30001;&#23427;&#20204;&#36716;&#21270;&#32780;&#25104;&#30340;<big><code>key_type</code></big>&#30340;&#20540;&#26469;&#20915;&#23450;&#12290;</p>



  <li>The container must be <i>stable</i>, i.e. its
iterators must remain valid after insert and erase operations. Note
that this condition is not met by many existing implementations of
hashed containers that invalidate iterators upon a rehashing operation.
&nbsp;</li>


  
  
  <p>&#23481;&#22120;&#24517;&#39035;&#26159;<span style="font-style: italic;">&#31283;&#23450;</span>&#30340;&#65292;&#23601;&#26159;&#35828;&#65292;&#22312;&#25554;&#20837;&#21644;&#21024;&#38500;&#25805;&#20316;&#20043;&#21518;&#23427;&#30340;&#36845;&#20195;&#22120;&#24517;&#39035;&#20173;&#28982;&#26377;&#25928;&#12290;&#27880;&#24847;&#35768;&#22810;&#29616;&#25104;&#30340;&#21704;&#24076;&#23481;&#22120;&#30340;&#23454;&#29616;&#37117;&#19981;&#31526;&#21512;&#36825;&#20010;&#26631;&#20934;&#65292;&#23427;&#20204;&#30340;&#36845;&#20195;&#22120;&#22312;&#19968;
&#27425;&#37325;&#21704;&#24076;&#25805;&#20316;&#20043;&#21518;&#23601;&#26080;&#25928;&#20102;&#12290;</p>



</ol>



Let us see what a container specifier looks like with an example.
Suppose we have our own ordered container like the following:<br>



<br>



&#35753;&#25105;&#20204;&#20197;&#19968;&#20010;&#20363;&#23376;&#26469;&#30475;&#30475;&#23481;&#22120;&#25551;&#36848;&#31526;&#26159;&#24590;&#26679;&#30340;&#12290;&#20551;&#35774;&#25105;&#20204;&#26377;&#19968;&#20010;&#33258;&#24049;&#30340;&#26377;&#24207;&#23481;&#22120;&#20687;&#19979;&#38754;&#36825;&#20010;&#26679;&#23376;&#65306;
<blockquote>
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">typename</span> <span class="identifier">Elem</span><span class="special">,</span><br><span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">Elem</span><span class="special">&gt;,</span><br><span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">Elem</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">ultrafast_set</span><br><span class="special">{</span><br><span class="special">...</span><br><span class="special">};</span></pre>



</blockquote>



<p>
Then <code>ultrafast_set</code> can be plugged into
<code>assoc_container_factory</code> like this:</p>


<p>
<big><code>ultrafast_set</code></big>&#21487;&#20197;&#20687;&#36825;&#26679;&#30340;&#26041;&#24335;&#26893;&#20837;<code><big>assoc_container_factory</big>&#65306;</code>
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">assoc_container_factory</span><span class="special">&lt;</span><br><span class="comment">// MPL lambda expression follows</span><br><b><span class="identifier">ultrafast_set</span><span class="special">&lt;</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span></b><br><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span></pre>



</blockquote>



<p>
As has been explained, <code>mpl::_1</code> is a so-called
MPL
placeholder standing as a "slot" to be replaced with
<code>Entry</code> by the internal machinery of
Boost.Flyweight.
Note that we have not
relied on the default argument of <code>ultrafast_set</code>
for
<code>Compare</code> and instead we have provided a fixed
instantiation for <code>std::string</code>: this is so
because
requirements state that the type with which <code>ContainerSpecifier</code>
will be filled in internally is convertible to <code>const
key_type&amp;</code>
(here <code>const std::string&amp;</code>), and it is
based on
<code>key_type</code> that lookup and equivalence of
entries
should be determined. On the other hand, the default argument for the <code>Allocator</code>
parameter works
just fine, as is more apparent if we write it down explicitly:</p>



<p>&#27491;&#22914;&#24050;&#32463;&#25551;&#36848;&#30340;&#37027;&#26679;&#65292;<big><code>mpl::_1</code></big>&#30340;&#26159;&#19968;&#20010;&#25152;&#35859;&#30340;MPL&#21344;&#20301;&#31526;&#65292;&#20195;&#34920;&#19968;&#20010;&#34987;Boost.Flyweight&#30340;&#20869;&#37096;&#26426;&#21046;&#29992;<big><code>Entry</code></big>&#26367;&#25442;&#25481;&#30340;&ldquo;&#25554;&#27133;&rdquo; &nbsp;&#12290;&#27880;&#24847;&#25105;&#20204;&#27809;&#26377;&#20351;&#29992;<big><code>ultrafast_set</code></big>&#30340;
&#40664;&#35748;<big><code>Compare</code></big>&#21442;&#25968;&#32780;&#26159;&#25552;&#20379;&#20102;&#19968;&#20010;<code>std::string</code>&#31867;&#30340;&#19981;&#21464;&#23454;&#20363;&#65306; &#36825;&#26159;&#22240;&#20026;&#35268;&#33539;&#22768;&#26126;<big><code>ContainerSpecifier</code></big>&#20869;&#37096;&#23558;&#35201;&#22635;&#20805;&#30340;&#31867;&#22411;&#21487;&#20197;&#36716;&#25442;&#20026;<big><code>const
key_type&amp;</code></big>&#65288;&#36825;&#37324;&#26159;<big><code>const std::string&amp;</code></big>&#65289;&#65292;&#32780;&#19988;entries&#30340;&#26597;&#25214;&#21644;&#21028;&#31561;&#26159;&#22522;&#20110;<big><code>key_type</code></big>&#26469;&#20915;&#23450;&#30340;<code>&#12290;</code>&nbsp;
&#21478;&#19968;&#26041;&#38754;&#65292;<big><code>Allocator</code></big>&#21442;&#25968;&#30340;&#40664;&#35748;&#20540;&#21487;&#20197;&#24456;&#22909;&#30340;&#24037;&#20316;&#65292;&#22914;&#26524;&#25105;&#20204;&#26174;&#31034;&#24471;&#20889;&#20986;&#26469;&#20250;&#26356;&#26126;&#26174;&#65306;
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">assoc_container_factory</span><span class="special">&lt;</span><br><b><span class="identifier">ultrafast_set</span><span class="special">&lt;</span><br><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span><br><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span><br><span class="special">&gt;</span><br><span class="special">&gt;</span></b><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span> </pre>



</blockquote>



<h2><a name="holders">Holder specification &nbsp;Holder &nbsp;&#35268;&#33539;</a></h2>



<p>
Each flyweight type, that is, each distinct instantiation of the class
template <code>flyweight</code>, is associated with
exactly one factory
object. In most cases, how this factory object is created is of little
importance to the user of Boost.Flyweight, but there are special
circumstances where control of this aspect is necessary. An internal
component called <i>holder</i> is in charge of
instantiating the
factory class and some other internal information; this component is
stipulated by means of a <i>holder specifier</i>, <code>static_holder</code>
being the default one.</p>



<p>&#27599;&#20010;flyweight&#31867;&#22411;&#65292;&#23601;&#26159;&#35828;&#65292;&#27599;&#20010;<big><code>flyweight</code></big>&#31867;&#27169;&#26495;&#30340;&#19981;&#21516;&#23454;&#20363;&#65292;
&#21482;&#20250;&#26377;&#19968;&#20010;&#30456;&#20851;&#30340;&#24037;&#21378;&#23545;&#35937;&#12290;&#32477;&#22823;&#22810;&#25968;&#24773;&#20917;&#19979;&#65292;&#36825;&#20010;&#24037;&#21378;&#23545;&#35937;&#26159;&#22914;&#20309;&#21019;&#24314;&#30340;&#23545;Boost.Flyweight&#30340;&#29992;&#25143;&#26159;&#26080;&#20851;&#32039;&#35201;&#30340;&#65292;&#20294;&#26159;&#22312;&#19968;&#20123;&#29305;&#27530;&#30340;&#29615;&#22659;&#19979;&#23545;&#36825;&#20010;
&#30028;&#38754;&#30340;&#25511;&#21046;&#26159;&#24517;&#35201;&#30340;&#12290;&#19968;&#20010;&#21517;&#20026;<i>holder</i>&#30340;&#20869;&#37096;&#32452;&#20214;&#25484;&#31649;&#24037;&#21378;&#31867;&#21644;&#20854;&#23427;&#19968;&#20123;&#20869;&#37096;&#20449;&#24687;&#30340;&#23454;&#20363;&#21270;&#65307;&#35813;&#32452;&#20214;&#29992;&#19968;&#20010;<i>holder
&#25551;&#36848;&#31526;</i>&#26469;&#35268;&#23450;&#65292;&#40664;&#35748;&#30340;&#25551;&#36848;&#31526;&#26159;<code><big>static_holder</big>&#12290;</code>
</p>



<h3><a name="static_holder"><code>static_holder</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/holders.html#static_holder_synopsis"><code>"boost/flyweight/static_holder.hpp"</code></a><br>



  <b>Syntax:</b> <code>static_holder</code>
</blockquote>



<p>
This the default holder specifier of Boost.Flyweight, and produces
holders where the unique factory lives as a local static variable of
the
program.</p>



<p>&#36825;&#26159;Boost.Flyweight&#30340;&#40664;&#35748;holder&#40664;&#25551;&#36848;&#31526;&#65292;&#23427;&#29983;&#25104;&#30340;holder&#30340;&#24037;&#21378;&#20197;&#23616;&#37096;&#38745;&#24577;&#21464;&#37327;&#30340;&#26041;&#24335;&#23384;&#22312;&#20110;&#31243;&#24207;&#20013;&#12290;
</p>



<h3><a name="intermodule_holder"><code>intermodule_holder</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/holders.html#intermodule_holder_synopsis"><code>"boost/flyweight/intermodule_holder.hpp"</code></a><br>



  <b>Syntax:</b> <code>intermodule_holder</code>
</blockquote>



<p>
In most C++ environments, static variables do not mix well with
dynamically loaded modules in the sense that instances of the same
static variable can be duplicated across different modules, even
though by definition the variable should be unique. In many
cases, this duplication goes unnoticed if the modules do not
communicate
between each other using the affected types, but consider this
case where such communication does happen:</p>



<p>&#22312;&#22823;&#22810;&#25968;C++&#29615;&#22659;&#37324;&#65292;&#38745;&#24577;&#21464;&#37327;&#19981;&#33021;&#19982;&#21160;&#24577;&#21152;&#36733;&#30340;&#27169;&#22359;&#24456;&#22909;&#30340;&#21327;&#21516;&#21407;&#22240;&#22312;&#20110;&#21516;&#19968;&#20010;&#38745;&#24577;&#21464;&#37327;&#21487;&#20197;&#22312;&#19981;&#21516;&#30340;&#27169;&#22359;&#20013;&#37325;&#22797;&#65292;&#21363;&#20351;&#26681;&#25454;&#23450;&#20041;&#36825;&#20010;&#21464;&#37327;&#24212;
&#35813;&#26159;&#21807;&#19968;&#30340;&#12290;&#22312;&#24456;&#22810;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524;&#27169;&#22359;&#20043;&#38388;&#19981;&#36890;&#36807;&#21463;&#24433;&#21709;&#30340;&#31867;&#22411;&#26469;&#20132;&#20114;&#30340;&#35805;&#26159;&#19981;&#20250;&#27880;&#24847;&#21040;&#36825;&#20010;&#37325;&#22797;&#30340;&#65292;&#20294;&#26159;&#32771;&#34385;&#19968;&#19979;&#36825;&#31181;&#36890;&#35759;&#30830;&#23454;&#21457;&#29983;&#30340;&#20363;&#23376;&#65306;
</p>



<blockquote>
  
  
  <pre><span class="comment">// module 1</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span><br><span class="comment">// produce_string is exported so that it can be dynamically<br>// linked</span><br><span class="identifier">flyweight_string</span> <span class="identifier">produce_string</span><span class="special">()</span><br><span class="special">{</span><br><span class="keyword">return</span> <span class="identifier">flyweight_string</span><span class="special">(</span><span class="string">"boost"</span><span class="special">);</span><br><span class="special">}</span> </pre>



</blockquote>



<blockquote>
  
  
  <pre><span class="comment">// main program</span><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span><br><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span><br><span class="special">{</span><br><span class="special">...</span> <span class="comment">// import module 1</span><br><span class="identifier">flyweight_string</span> <span class="identifier">str1</span><span class="special">=</span><span class="identifier">produce_string</span><span class="special">();</span><br><span class="identifier">flyweight_string</span> <span class="identifier">str2</span><span class="special">(</span><span class="string">"boost"</span><span class="special">);</span><br><span class="identifier">assert</span><span class="special">(</span><span class="identifier">str1</span><span class="special">==</span><span class="identifier">str2</span><span class="special">);</span><br><span class="special">}</span> </pre>



</blockquote>



<p>
In many environments, this program results in an assertion
failure because the flyweight factory object used
by <code>flyweight_string</code> as seen within module 1
is
not the same factory object as seen within the main program: hence
the value representations internally pointed to by <code>str1</code>
and <code>str2</code> will differ and will be mistakenly
considered as not equal. Many other problems might arise
due to factory duplication, including undefined behavior.</p>



<p>&#22312;&#24456;&#22810;&#29615;&#22659;&#19979;&#36825;&#20010;&#31243;&#24207;&#23548;&#33268;&#26029;&#35328;&#38169;&#35823;&#65292;&#22240;&#20026;&#22312;&#27169;&#22359;1&#20013;&#30475;&#21040;&#30340;<big><code>flyweight_string</code></big>&#29992;
&#21040;&#30340;&#24037;&#21378;&#21644;&#20027;&#31243;&#24207;&#37324;&#30475;&#21040;&#30340;&#24037;&#21378;&#23545;&#35937;&#19981;&#26159;&#21516;&#19968;&#20010;&#65306;&#22240;&#27492;<big><code>str1</code></big>&#21644;<big><code>str2</code></big>&#20869;&#37096;&#25152;&#25351;&#21521;&#30340;&#20540;&#30340;&#34920;&#31034;&#26159;&#19981;&#21516;&#30340;&#65292;&#20110;&#26159;&#23427;&#20204;&#34987;&#38169;&#35823;&#30340;&#35748;&#20026;&#19981;&#30456;&#31561;&#12290;&#24037;&#21378;&#37325;&#22797;&#21487;&#33021;&#23548;&#33268;&#24456;&#22810;&#20854;&#23427;&#30340;&#38169;&#35823;&#65292;&#21253;&#25324;&#26410;&#23450;&#20041;&#30340;&#34892;&#20026;&#12290;
</p>



<p>
<code>intermodule_holder</code> specifies a factory holder
which
is capable of avoiding the duplication problem and ensuring that
all modules of a program are using the same factory instance.
To fix the example above, it suffices to redefine
<code>flyweight_string</code> in both modules as:</p>



<p><big><code>intermodule_holder</code></big>&#25351;&#23450;&#30340;&#24037;&#21378;&#30340;holder&#33021;&#22815;&#36991;&#20813;&#37325;&#22797;&#38382;&#39064;&#65292;&#23427;&#20445;&#35777;&#31243;&#24207;&#20013;&#25152;&#26377;&#30340;&#27169;&#22359;&#37117;&#20351;&#29992;&#21516;&#19968;&#20010;&#24037;&#21378;&#23454;&#20363;&#12290;&#21482;&#35201;&#22312;&#20004;&#20010;&#27169;&#22359;&#20013;&#37117;&#20687;&#36825;&#26679;&#37325;&#26032;&#23450;&#20041;<code><big>flyweight_string</big>&#65292;</code>&#23601;
&#21487;&#20197;&#20462;&#27491;&#19978;&#20363;&#20013;&#30340;&#38382;&#39064;&#12290;
</p>



<blockquote>
  
  
  <pre><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><span class="identifier"><b>intermodule_holder</b></span><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span> </pre>



</blockquote>



<p>
<code>intermodule_holder</code> is considerably more
onerous than
<code>static_holder</code> in terms of compilation times
and
introduces a non-negligible overhead at program start-up, so its use
should be reserved to the situations where it is really necessary.</p>



<p><big><code>intermodule_holder</code></big>&#20462;&#22312;&#32534;&#35793;&#26102;&#35201;&#27604;<big><code>static_holder</code></big>&#31528;&#37325;&#30340;&#22810;&#24182;&#19988;&#23548;&#33268;&#19981;&#21487;&#24573;&#35270;&#30340;&#31243;&#24207;&#21551;&#21160;&#26102;&#30340;&#39069;&#22806;&#24320;&#38144;&#65292;&#22240;&#27492;&#21482;&#26377;&#24403;&#30495;&#26377;&#24517;&#35201;&#26102;&#25165;&#20351;&#29992;&#23427;&#12290;
</p>



<h2><a name="locking">Locking policies &nbsp;&#38145;&#23450;&#31574;&#30053;</a></h2>



<p>
The internal factory associated to each <code>flyweight</code>
type is a shared resource and as such access to it must be properly
synchronized in multithreaded environments. A <i>locking policy</i>
specifies the synchronization mechanisms to be used for this purpose.</p>



<p>&#19982;&#27599;&#20010;<code>flyweight</code>&#31867;&#22411;&#20851;&#32852;&#30340;&#20869;&#37096;&#24037;&#21378;&#26159;&#19968;&#20010;&#20849;&#20139;&#36164;&#28304;&#65292;&#22240;&#27492;&#22312;&#22810;&#32447;&#31243;&#29615;&#22659;&#19979;
&#23545;&#23427;&#30340;&#35775;&#38382;&#24517;&#39035;&#34987;&#24688;&#24403;&#30340;&#21516;&#27493;&#12290;&#19968;&#31181;<span style="font-style: italic;">&#38145;&#23450;&#31574;&#30053;</span>&#25351;
&#23450;&#20102;&#29992;&#20110;&#27492;&#30446;&#30340;&#30340;&#21516;&#27493;&#26426;&#21046;&#12290;
</p>



<h3><a name="simple_locking"><code>simple_locking</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/locking.html#simple_locking_synopsis"><code>"boost/flyweight/simple_locking.hpp"</code></a><br>



  <b>Syntax:</b> <code>simple_locking</code>
</blockquote>



<p>
This is the default locking policy. It specifies the simplest native
synchronization primitives provided by the operating system, whenever
available.</p>



<p>&#36825;&#26159;&#40664;&#35748;&#30340;&#38145;&#23450;&#26426;&#21046;&#12290;&#21482;&#35201;&#21487;&#34892;&#23427;&#23601;&#20351;&#29992;&#25805;&#20316;&#31995;&#32479;&#25152;&#25552;&#20379;&#30340;&#26368;&#31616;&#30340;&#26412;&#26426;&#21516;&#27493;&#21407;&#35821;&#12290;
</p>



<h3><a name="no_locking"><code>no_locking</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/locking.html#no_locking_synopsis"><code>"boost/flyweight/no_locking.hpp"</code></a><br>



  <b>Syntax:</b> <code>no_locking</code>
</blockquote>



<p>
No synchronization is enforced so that irrestricted internal access
to the implementation shared resources is allowed.
Selecting <code>no_locking</code> results in somewhat
faster execution than
the default <code>simple_locking</code>, but it renders
the type
thread-unsafe, which can have catastrophic consequences.
This policy should not be used except in single-threaded environments
or
when there is an absolute guarantee that the particular <code>flyweight</code>
type will not be used in a concurrent scenario.</p>



<p>&#22240;&#20026;&#27809;&#26377;&#26045;&#21152;&#20219;&#20309;&#21516;&#27493;&#26426;&#21046;&#65292;&#25152;&#20197;&#21487;&#20197;&#23545;&#20849;&#20139;&#36164;&#28304;&#36827;&#34892;&#26080;&#38480;&#21046;&#35775;&#38382;&#12290;&#36873;&#25321;<code>no_locking</code>&#23548;
&#33268;&#25191;&#34892;&#36895;&#24230;&#35201;&#27604;&#40664;&#35748;&#30340;<code>simple_locking</code>&#24555;&#19968;&#28857;&#65292;&#20294;&#26159;&#31867;&#22411;&#22240;&#27492;&#19981;&#20877;&#32447;&#31243;&#23433;&#20840;&#20102;&#65292;&#36825;&#21487;&#33021;&#20250;&#26377;
&#28798;&#38590;&#24615;&#30340;&#21518;&#26524;&#12290;&#38500;&#38750;&#26159;&#22312;&#21333;&#32447;&#31243;&#30340;&#29615;&#22659;&#37324;&#25110;&#32773;&#24403;&#32477;&#23545;&#21487;&#20197;&#20445;&#35777;&#29305;&#23450;&#30340;<code>flyweight</code>&#31867;&#22411;&#19981;&#20250;&#22312;&#21516;&#27493;&#29615;
&#22659;&#19979;&#34987;&#20351;&#29992;&#65292;&#21542;&#21017;&#19981;&#24212;&#35813;&#20351;&#29992;&#36825;&#31181;&#31574;&#30053;&#12290;
</p>



<h2><a name="tracking">Tracking policies
&nbsp;&#36319;&#36394;&#31574;&#30053;</a></h2>



<p>
A <i>tracking policy</i> controls the lifetimes of the <code>flyweight</code>
objects and can act based on this information. For instance, a suitable
tracking mechanism can determine when a given value stored in the
factory
can be safely erased because it is no longer referenced by any
<code>flyweight</code>; this is precisely what the default
tracking policy,
<code>refcounted</code>, does.</p>



<p>
&#36319;&#36394;&#31574;&#30053;&#25511;&#21046;&#30528;<code>flyweight</code>&#23545;&#35937;&#30340;&#29983;&#23384;&#26399;&#12290;&#20363;&#22914;&#65292;&#19968;&#31181;&#21512;&#36866;&#30340;&#36319;&#36394;&#31574;&#30053;&#21487;&#20197;&#20915;&#23450;&#24403;&#24037;&#21378;&#37324;&#30340;&#26576;&#20010;&#32473;
&#23450;&#30340;&#20540;&#27809;&#26377;&#34987;&#20219;&#20309;<code>flyweight</code>&#23545;&#35937;&#24341;&#29992;&#30340;&#26102;&#20505;&#23427;&#21487;&#20197;&#34987;&#23433;&#20840;&#30340;&#28165;&#29702;&#65307;&#36825;&#27491;&#26159;&#40664;&#35748;&#30340;&#36319;&#36394;&#31574;&#30053;<code>refcounted</code>&#65292;
&#25152;&#20570;&#30340;&#20107;&#24773;</p>



<h3><a name="refcounted"><code>refcounted</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/tracking.html#refcounted_synopsis"><code>"boost/flyweight/refcounted.hpp"</code></a><br>



  <b>Syntax:</b> <code>refcounted</code>
</blockquote>



<p>
This tracking policy determines that values stored in the factory be
equipped with reference counting mechanisms so that a factory entry is
erased when the last <code>flyweight</code> object
associated to it
is destroyed.</p>



<p>
&#36825;&#31181;&#36319;&#36394;&#31574;&#30053;&#20915;&#23450;&#23384;&#20648;&#22312;&#24037;&#21378;&#37324;&#30340;&#20540;&#37197;&#26377;&#24341;&#29992;&#35745;&#25968;&#26426;&#21046;&#65292;&#20110;&#26159;&#24403;&#20851;&#32852;&#21040;&#35813;&#24037;&#21378;&#26465;&#30446;&#30340;&#26368;&#21518;&#19968;&#20010;<code>flyweight</code>&#23545;
&#35937;&#34987;&#38144;&#27585;&#30340;&#26102;&#20505;&#65292;&#35813;&#26465;&#30446;&#23558;&#34987;&#28165;&#29702;&#12290;</p>



<h3><a name="no_tracking"><code>no_tracking</code></a></h3>



<blockquote> <b>Header:</b> <a href="../reference/tracking.html#no_tracking_synopsis"><code>"boost/flyweight/no_tracking.hpp"</code></a><br>



  <b>Syntax:</b> <code>no_tracking</code>
</blockquote>



<p>
No flyweight tracking is done when this policy is selected, which
implies
that the values stored in the factory remain in it until program
termination.
As compared with <code>refcounted</code>, <code>no_tracking</code>
presents
advantages and drawbacks. The benefits are:</p>



<p>
&#24403;&#36873;&#25321;&#36825;&#31181;&#31574;&#30053;&#26102;&#65292;&#19981;&#36827;&#34892;flyweight&#30340;&#36319;&#36394;&#65292;&#36825;&#26263;&#31034;&#23384;&#20648;&#22312;&#24037;&#21378;&#37324;&#30340;&#20540;&#23558;&#19968;&#30452;&#23384;&#22312;&#30452;&#21040;&#31243;&#24207;&#32467;&#26463;&#12290;&#19982;<code>refcounted</code>&#30456;
&#27604;&#65292;<code>no_tracking</code>&#26082;&#26377;&#20248;&#28857;&#20063;&#26377;&#32570;&#28857;&#12290;&#20248;&#28857;&#26159;&#65306;</p>



<ul>



  <li>Non-tracked flyweight objects are faster to pass around
than refcounted ones. &nbsp;</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&#19981;&#36827;&#34892;&#36319;&#36394;&#30340;flyweight&#23545;&#35937;&#22312;&#20256;&#36882;&#26102;&#35201;&#24555;&#20110;&#20351;&#29992;&#20102;&#24341;&#29992;&#35745;&#25968;&#30340;&#12290;
<ul>



  <li>There is some reduction in memory usage due to the absence
of reference counters. &nbsp;</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&#30001;&#20110;&#27809;&#26377;&#24341;&#29992;&#35745;&#25968;&#20869;&#23384;&#20351;&#29992;&#19978;&#20250;&#26377;&#19968;&#20123;&#20943;&#23569;<br>



<br>



whereas potential drawbacks of using <code>no_tracking</code>
include:<br>



<br>



&#21453;&#20043;&#20351;&#29992;<code>no_tracking</code>&#28508;&#22312;&#30340;&#32570;&#28857;&#21253;&#25324;&#65306;
<ul>



  <li>The number of unused entries stored in the factory can keep
growing during the program lifetime, which can become a problem for
certain patterns of flyweight creation where the set of active values
"drifts" over time.</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&#23384;&#20648;&#22312;&#24037;&#21378;&#20013;&#27809;&#29992;&#30340;&#26465;&#30446;&#30340;&#25968;&#37327;&#22312;&#31243;&#24207;&#36816;&#34892;&#26399;&#38388;&#21487;&#33021;&#25345;&#32493;&#22686;&#38271;&#65292;&#36825;&#23545;&#26576;&#20123;&#31867;&#22411;flyweight&#30340;&#21019;&#24314;&#21487;&#33021;&#25104;&#20026;&#38382;&#39064;&#65292;&#36825;&#37324;&#27963;&#21160;&#30340;&#20540;&#20250;&#19981;&#26102;&#30340;&amp;
ldquo;&#28418;&#31227;&rdquo;&#12290;
<ul>



  <li>There can be a potential delay during program termination,
since it is then when all the factory entries get destroyed at once.</li>



</ul>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&#31243;&#24207;&#32456;&#27490;&#26102;&#21487;&#33021;&#20250;&#26377;&#19968;&#20010;&#28508;&#22312;&#30340;&#26102;&#24310;&#65292;&#22240;&#20026;&#36825;&#26102;&#25152;&#26377;&#30340;&#24037;&#21378;&#26465;&#30446;&#23558;&#34987;&#19968;&#36215;&#38144;&#27585;&#12290;
<hr>
<div class="prev_link"><a href="key_value.html"><img src="../prev.gif" alt="key-value flyweights" border="0"><br>



Key-value flyweights
</a></div>



<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>



Boost.Flyweight tutorial
</a></div>



<div class="next_link"><a href="extension.html"><img src="../next.gif" alt="extending Boost.Flyweight" border="0"><br>



Extending Boost.Flyweight
</a></div>



<br style="" clear="all">



<br>



<p>Revised November 8th 2008</p>



<p>&copy; Copyright 2006-2008 Joaqu&iacute;n M
L&oacute;pez Mu&ntilde;oz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>



</body>
</html>

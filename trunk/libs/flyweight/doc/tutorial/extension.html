<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>Boost.Flyweight Documentation - Tutorial - Extending
Boost.Flyweight</title>


  <link rel="stylesheet" href="../style.css" type="text/css">

  <link rel="start" href="../index.html">

  <link rel="prev" href="configuration.html">

  <link rel="up" href="index.html">

  <link rel="next" href="technical.html">

</head>


<body>

<h1><img src="../../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Tutorial: Extending Boost.Flyweight</h1>

<div class="prev_link"><a href="configuration.html"><img src="../prev.gif" alt="configuring Boost.Flyweight" border="0"><br>

Configuring Boost.Flyweight
</a></div>

<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>

Boost.Flyweight tutorial
</a></div>

<div class="next_link"><a href="technical.html"><img src="../next.gif" alt="technical issues" border="0"><br>

Technical issues
</a></div>

<br style="" clear="all">

<hr>
<h2>Contents &nbsp;&#30446;&#24405;</h2>

<ul>

  <li><a href="#intro">Introduction &nbsp;&#31616;&#20171;</a></li>

  <li><a href="#factories">Custom factories
&nbsp;&#23450;&#21046;&#24037;&#21378;</a></li>

  <li><a href="#holders">Custom holders
&nbsp;&#23450;&#21046;holders</a></li>

  <li><a href="#locking">Custom locking policies
&nbsp;&#23450;&#21046;&#38145;&#23450;&#31574;&#30053;</a></li>

  <li><a href="#tracking">Custom tracking policies
&nbsp;&#23450;&#21046;&#36319;&#36394;&#31574;&#30053;</a></li>

</ul>

<h2><a name="intro">Introduction &nbsp;&#31616;&#20171;</a></h2>

<p>
Boost.Flyweight provides public interface specifications of
its <a href="configuration.html">configurable aspects</a>
so that the user
can extend the library by implementing her own components and providing
them to
instantiations of the <code>flyweight</code> class
template.</p>

<p>
Boost.Flyweight<span class="mn">&#35268;&#23450;</span>&#20102;&#23427;&#30340;<a href="configuration.html">&#21487;&#37197;&#32622;&#30028;&#38754;</a>&#30340;&#20844;&#20849;&#25509;
&#21475;&#26631;&#20934;&#65292;&#20110;&#26159;&#29992;&#25143;&#21487;&#20197;&#23454;&#29616;&#22905;&#20204;&#33258;&#24049;&#30340;&#32452;&#20214;&#65292;&#28982;&#21518;&#25226;&#23427;&#20204;&#25552;&#20379;&#32473;<big><code>flyweight</code></big>&#31867;
&#27169;&#26495;&#30340;&#23454;&#20363;&#26469;&#25193;&#23637;&#36825;&#20010;&#24211;&#12290;
</p>

<p>
In most cases there are two types of entities involved in extending a
given
aspect of Boost.Flyweight:</p>

<p>&#22312;&#32477;&#22823;&#22810;&#25968;&#24773;&#20917;&#19979;&#25193;&#23637;Boost.Flyweight&#30340;&#26576;&#19968;&#30028;&#38754;&#26102;&#28041;&#21450;&#21040;2&#31181;&#31867;&#22411;&#30340;&#23454;&#20307;
</p>

<ul>

  <li>The component itself (for instance, a factory class
template).</li>

</ul>

<div style="margin-left: 40px;">&#32452;&#20214;&#26412;&#36523;&#65288;&#20363;&#22914;&#65292;&#19968;&#20010;&#24037;&#21378;&#31867;&#27169;&#26495;&#65289;</div>

<ul>

  <li>The associated <i>component specifier</i>,
which is the type provided as a template argument of a <code>flyweight</code>
instantiation.</li>

</ul>

<div style="margin-left: 40px;">&#30456;&#20851;&#30340;<span style="font-style: italic;">&#32452;&#20214;&#25551;&#36848;&#31526;</span>&#65292;&#23427;&#26159;<big><span style="font-family: monospace;"></span></big>&#25552;&#20379;&#32473;<big><code>flyweight</code></big>&#23454;
&#20363;&#30340;&#27169;&#26495;&#21442;&#25968;&#31867;&#22411;<br>

<br>

</div>

For example, the type
<a href="configuration.html#static_holder"><code>static_holder</code></a>
is a holder specifier which is used by <code>flyweight</code>
to generate
actual holder classes, in this case instantiations of the class
template <a href="../reference/holders.html#static_holder_class"><code>static_holder_class</code></a>.
Note that <code>static_holder</code> is a concrete type
while
<code>static_holder_class</code> is a class template, so a
specifier can be
seen as a convenient way to provide access to a family of related
concrete
components (the different possible instantiations of the class
template):
<code>flyweight</code> internally selects the particular
component
appropriate for its internal needs.<br>

<br>

&#20363;&#22914;&#65292;<big><a href="configuration.html#static_holder"><code>static_holder</code></a></big>&#31867;
&#22411;&#26159;&#19968;&#20010;&#25551;&#36848;&#31526;&#65292;<big><code>flyweight</code></big>&#29992;&#23427;&#26469;&#29983;&#25104;&#23454;&#38469;
&#30340;holder&#31867;&#65292;&#36825;&#31181;&#24773;&#20917;&#19979;&#26159;<big><a href="../reference/holders.html#static_holder_class"><code>static_holder_class</code></a></big>&#31867;
&#27169;&#26495;&#30340;&#23454;&#20363;&#12290;&#27880;&#24847;<big><code>static_holder</code></big>&#26159;&#19968;&#20010;
&#20855;&#20307;&#31867;&#22411;&#32780;<big><code>static_holder_class</code></big>&#26159;
&#19968;&#20010;&#27169;&#26495;&#31867;&#65292;&#20110;&#26159;&#19968;&#20010;&#25551;&#36848;&#31526;&#21487;&#20197;&#34987;&#30475;&#20316;&#26159;&#19968;&#31181;&#35775;&#38382;&#19968;&#26063;&#30456;&#20851;&#20855;&#20307;&#32452;&#20214;&#65288;&#21487;&#33021;&#30340;&#31867;&#27169;&#26495;&#30340;&#19981;&#21516;&#23454;&#20363;&#65289;&#30340;&#31616;&#20415;&#21150;&#27861;&#65306;<big><code>flyweight</code></big>&#22312;
&#20869;&#37096;&#36873;&#25321;&#36866;&#21512;&#23427;&#20869;&#37096;&#38656;&#35201;&#30340;&#29305;&#23450;&#30340;&#32452;&#20214;&#12290;
<h2><a name="factories">Custom factories
&nbsp;&#23450;&#21046;&#24037;&#21378;</a></h2>

<p>
In a way, factories resemble unique associative containers like <code>std::set</code>,
though their expected interface is much more concise:</p>

<p><span class="mn">&#22312;&#26576;&#31181;&#31243;&#24230;&#19978;&#65292;&#24037;&#21378;&#31867;&#20284;&#20110;&#21807;&#19968;&#20851;&#32852;&#23481;&#22120;&#27604;&#22914;</span><big><code>std::set</code></big><span class="mn">&#65292;&#28982;&#32780;&#23427;&#20204;&#26399;&#24453;&#30340;&#30028;&#38754;&#35201;&#31616;&#27905;&#30340;&#22810;&#65306;</span>
</p>

<blockquote>
  <pre><span class="comment">// example of a possible factory class template</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">custom_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <span class="special">...</span> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier"> insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span> </pre>

</blockquote>

<p>
Factories are parameterized by <code>Entry</code> and <code>Key</code>:
the first is the type of the objects stored, while the second is the
public
key type on which <code>flyweight</code> operates (e.g.
the <code>std::string</code>
in <code>flyweight&lt;std::string&gt;</code> or
<code>flyweight&lt;key_value&lt;std::string,texture&gt;
&gt;</code>). An entry holds a
shared value to which flyweight objects are associated as well as
internal bookkeeping information, but from the
point of view of the factory, though, the only fact known about <code>Entry</code>
is that it is implicitly convertible to <code>const Key&amp;</code>,
and it is
based on their associated <code>Key</code> that entries
are to be considered
equivalent or not. The factory <code>insert()</code>
member function locates a previously stored entry whose
associated <code>Key</code> is equivalent to that of the <code>Entry</code>
object being passed (for some equivalence relation on <code>Key</code>
germane to
the factory), or stores the new entry if no equivalent one is found. A
<code>handle_type</code> to the equivalent or newly
inserted entry is returned;
this <code>handle_type</code> is a token for further
access to an entry via
<code>erase()</code> and <code>entry()</code>.
Consult the
<a href="../reference/factories.html#factory">reference</a>
for the formal
definition of the <code>Factory</code> concept.</p>

<p>&#24037;&#21378;&#36890;&#36807;<big><code>Entry</code></big>&#21644;<big><code>Key</code></big>&#26469;
&#21442;&#25968;&#21270;&#65306;<big><code>Entry</code></big>&#26159;&#24037;&#21378;&#23384;&#20648;&#30340;&#23545;&#35937;&#30340;&#31867;&#22411;&#65292;<big><code>Key</code></big>&#26159;<big><code>flyweight</code></big>&#25805;
&#20316;&#30340;&#20844;&#24320;&#30340;&#38190;&#31867;&#22411;&#65288;<span class="mn">&#20363;&#22914;&#65292;</span><big><code>flyweight&lt;std::string&gt;</code></big><span class="mn">&#25110;&#32773;</span><big><code>flyweight&lt;key_value&lt;std::string,texture&gt;
&gt;</code></big><span class="mn">&#37324;</span>&#30340;<big><code>std::string</code></big>&#65289;&#12290;
&#19968;&#20010;entry&#21253;&#21547;&#19968;&#20010;flyweight&#23545;&#35937;&#20851;&#32852;&#21040;&#30340;&#20849;&#20139;&#30340;&#20540;&#36824;&#26377;&#19968;&#20123;&#20869;&#37096;<span class="mn">&#31807;&#35760;&#20449;&#24687;&#65292;&#28982;
&#32780;&#65292;&#20174;&#24037;&#21378;&#30340;&#35282;&#24230;&#26469;&#30475;&#65292;&#23427;&#25152;&#30693;&#36947;&#30340;&#20851;&#20110;</span><big><code>Entry</code></big><span class="mn">&#30340;</span><span class="mn">&#21807;&#19968;</span><span class="mn">&#20107;&#23454;&#26159;&#23427;&#21487;&#20197;&#38544;&#24335;&#30340;&#36716;&#25442;&#21040;</span><code><big>const
Key&amp;</big>&#65292;</code>&#28982;&#21518;entries<span class="mn">&#30340;
&#30456;&#31561;&#19982;&#21542;&#26159;&#22522;&#20110;&#23427;
&#20204;&#30456;&#20851;&#30340;</span><big><code>Key</code></big><span class="mn">&#26469;
&#21028;&#26029;&#30340;&#12290;&#24037;&#21378;&#30340;</span><big><code>insert()</code></big><span class="mn">&#25104;
&#21592;&#20989;&#25968;&#23450;&#20301;&#21040;&#19968;&#20010;&#20043;&#21069;&#23384;&#20648;&#36807;&#30340;</span>entry&#65292;&#22914;&#26524;<span class="mn">&#19982;&#23427;&#30456;&#20851;&#30340;</span><big><code>Key</code></big><span class="mn">&#31561;&#20110;&#20316;&#20026;&#21442;&#25968;&#20256;&#36882;&#30340;</span><big><code>Entry</code></big><span class="mn">&#30340;</span><code><big>Key</big></code>&#65288;&#22522;
&#20110;&#19982;&#24037;&#21378;&#23494;&#20999;&#30456;&#20851;&#30340;&#20316;&#29992;&#22312;<big><code>Key</code></big>&#19978;&#30340;&#26576;&#31181;&#30456;&#31561;&#20851;&#31995;<span class="mn"></span>&#65289;<code>&#65292;</code><span class="mn">&#25110;&#32773;&#22312;&#27809;&#26377;&#25214;&#21040;&#30456;&#31561;&#30340;</span><big><code>Key</code></big><span class="mn">&#26102;&#23384;&#20648;&#36825;&#20010;&#26032;&#30340;</span>entry&#12290;&#20989;&#25968;&#36820;&#22238;&#19968;&#20010;&#21040;&#26032;&#25554;&#20837;&#30340;&#25110;&#32773;&#30456;&#31561;&#30340;entry&#30340;<big><code>handle_type</code></big>&#65307;<span style="font-family: monospace;"></span><big><code></code></big>&#23427;
&#26159;&#21518;
&#32493;&#36890;&#36807;<big><code>erase()</code></big>&#21644;<big><code>entry()</code></big>&#23545;entry
&#35775;&#38382;&#30340;&#20196;&#29260;<code></code>
&nbsp;&#12290;&#24037;&#21378;&#27010;&#24565;&#30340;&#27491;&#24335;&#23450;&#20041;&#26597;&#38405;<a href="../reference/factories.html#factory">&#21442;
&#32771;</a>&#12290;
</p>

<p>
Let us see an actual example of realization of a custom factory class.
Suppose
we want to trace the different invocations by Boost.Flyweight of the
<code>insert()</code> and <code>erase()</code>
member functions: this can be
done by using a custom factory whose member methods emit trace messages
to the program console. We base the implementation of the repository
functionality on a regular <code>std::set</code>:</p>

<p>&#35753;&#25105;&#20204;&#30475;&#19968;&#20010;&#23454;&#29616;&#20102;&#23458;&#25143;&#21270;&#24037;&#21378;&#31867;&#30340;&#23454;&#38469;&#20363;&#23376;&#12290;&#20551;&#35774;&#25105;&#20204;&#24819;&#35201;&#36319;&#36394;Boost.Flyweight&#23545;<big><code>insert()</code></big>&#21644;<big><code>erase()</code></big>&#25104;
&#21592;&#20989;&#25968;&#30340;&#21508;&#31181;&#35843;&#29992;&#65306;&#36825;&#21487;&#20197;&#36890;&#36807;&#19968;&#20010;&#23450;&#21046;&#30340;&#24037;&#21378;&#26469;&#20570;&#21040;&#65292;&#23427;&#30340;&#25104;&#21592;&#20989;&#25968;&#36755;&#20986;&#35843;&#35797;&#20449;&#24687;&#21040;&#31243;&#24207;&#30340;&#25511;&#21046;&#21488;&#12290;&#25105;&#20204;&#22522;&#20110;&#19968;&#20010;&#26222;&#36890;&#30340;<big><code>std::set</code></big>&#23454;
&#29616;&#23384;&#20648;&#26742;&#30340;&#21151;&#33021;&#12290;
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">verbose_factory_class</span><br><span class="special">{</span> <br>&nbsp; <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">Entry</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">store_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; store_type</span> <span class="identifier">store</span><span class="special">;</span><br><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <span class="keyword">typename</span> <span class="identifier">store_type</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><br><span class="special">&nbsp; {</span><br><span class="identifier">&nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">handle_type</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">p</span><span class="special">=</span><span class="identifier">store</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; &nbsp; if</span><span class="special">(</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">second</span><span class="special">){</span> <span class="comment">/* new entry */</span><br><span class="identifier">&nbsp; &nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"new: "</span><span class="special">&lt;&lt;(</span><span class="keyword">const</span> <span class="identifier">Key</span><span class="special">&amp;)</span><span class="identifier">x</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">&nbsp; &nbsp; }</span><br><span class="keyword">&nbsp; &nbsp; else</span><span class="special">{</span> <span class="comment">&nbsp; &nbsp; &nbsp; &nbsp; /* existing entry */</span><br><span class="identifier">&nbsp; &nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"hit: "</span><span class="special">&lt;&lt;(</span><span class="keyword">const</span> <span class="identifier">Key</span><span class="special">&amp;)</span><span class="identifier">x</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="special">&nbsp; &nbsp; }</span><br><span class="keyword">&nbsp; &nbsp; return</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">first</span><span class="special">;</span><br><span class="special">&nbsp; }</span><br><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">)</span><br><span class="special">&nbsp; {</span><br><span class="identifier">&nbsp; &nbsp; std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="string">"del: "</span><span class="special">&lt;&lt;(</span><span class="keyword">const</span> <span class="identifier">Key</span><span class="special">&amp;)*</span><span class="identifier">h</span><span class="special">&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><br><span class="identifier">&nbsp; &nbsp; store</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">h</span><span class="special">);</span><br><span class="special">&nbsp; }</span><br><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">)</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; return</span> <span class="special">*</span><span class="identifier">h</span><span class="special">;</span><br><span class="special">&nbsp; }</span><br><span class="special">};</span> </pre>

</blockquote>

<p>
The code deserves some commentaries:</p>

<p>&#36825;&#27573;&#20195;&#30721;&#20540;&#24471;&#19968;&#20123;&#27880;&#37322;&#65306;
</p>

<ul>

  <li> Note that the factory is parameterized by <code>Entry</code>
and <code>Key</code>, as these types are provided
internally by Boost.Flyweight when the factory is instantiated as part
of the machinery of <code>flyweight</code>; but there is
nothing to prevent us from having more template parameters for finer
configuration of the factory type: for instance, we could extend <code>verbose_factory_class</code>
to accept some comparison predicate rather than the default <code>std::less&lt;Key&gt;</code>,
or to specify the allocator used by the internal <code>std::set</code>.</li>

</ul>

<div style="margin-left: 40px;">&#27880;&#24847;&#24037;&#21378;&#26159;&#36890;&#36807;<big><code>Entry</code></big>&#21644;<big><code>Key</code></big>&#26469;
&#21442;&#25968;&#21270;&#30340;&#65292;&#20316;&#20026;<big><code>flyweight</code></big>&#26426;&#21046;&#30340;&#19968;&#37096;&#20998;&#65292;&#24403;
&#24037;&#21378;&#34987;&#23454;&#20363;&#21270;&#26102;&#36825;&#20123;&#21442;&#25968;&#30001;Boost.Flyweight&#20869;&#37096;
&#25552;&#20379;&#65307;&#20294;&#26159;&#25105;&#20204;&#23436;&#20840;&#21487;&#20197;&#20351;&#29992;&#26356;&#22810;&#30340;&#27169;&#26495;&#21442;&#25968;&#26469;&#26356;&#31934;&#32454;&#30340;&#37197;&#21046;&#24037;&#21378;&#31867;&#65292;&#25105;&#20204;&#21487;&#20197;&#25193;&#23637;<code>verbose_factory_class</code>&#35753;
&#23427;&#25509;&#21463;&#38750;&#40664;&#35748;&#30340;&#27604;&#36739;&#35859;&#35789;<big><code>std::less&lt;Key&gt;</code></big>&#65292;
&#25110;&#32773;&#25351;&#23450;&#20869;&#37096;<big><code>std::set</code></big>&#29992;&#30340;&#20998;&#37197;&#22120;&#12290;</div>

<ul>

  <li> The fact that <code>Entry</code> is
convertible to <code>const Key&amp;</code> (which is
about the only property known about <code>Entry</code>) is
exploited in the specification of <code>std::less&lt;Key&gt;</code>
as the comparison predicate for the <code>std::set</code>
of <code>Entry</code>s used as the internal repository.</li>

</ul>

<div style="margin-left: 40px;">&#21033;&#29992;<big><code>Entry</code></big>&#21487;
&#20197;&#36716;&#25442;&#21040;<big><code>const Key&amp;</code></big>&#30340;&#20107;
&#23454;&#65288;&#36825;&#22823;&#27010;&#26159;<code></code>&#21807;&#19968;&#25152;
&#30693;&#30340;<code>Entry</code>&#23646;&#24615;&#65289;&#65292;&#25105;&#20204;&#25351;&#26126;<big><code>std::less&lt;Key&gt;</code></big>&#20316;
&#20026;&#23384;&#20648;<big><code>Entry</code>s</big>&#30340;&#20869;&#37096;&#23384;&#20648;
&#26742;&mdash;&mdash;<big><code>std::set</code></big>&#30340;
&#27604;&#36739;&#35859;&#35789;&#12290;</div>

<ul>

  <li> As our public <code>handle_type</code> we are
simply using an iterator to the internal <code>std::set</code>.</li>

</ul>

<div style="margin-left: 40px;">&#25105;&#20204;&#31616;&#21333;&#30340;&#20351;&#29992;&#19968;&#20010;&#25351;&#21521;&#20869;&#37096;<big><code>std::set</code></big>&#30340;
&#36845;&#20195;&#22120;&#20316;&#20026;&#25105;&#20204;&#20844;&#24320;&#30340;<code><big>handle_type</big></code>&#12290;</div>

<p>
In order to plug a custom factory into the specification of a <code>flyweight</code>
type, we need an associated construct called the <i>factory
specifier</i>.
A factory specifier is a <a href="lambda_expressions.html"><code>Lambda
Expression</code></a> accepting the two argument types <code>Entry</code>
and <code>Key</code> and returning the corresponding
factory class:</p>

<p>&#20026;&#20102;&#22312;&#19968;&#20010;&#19987;&#38376;&#21270;&#30340;<big><code>flyweight</code></big>&#31867;
&#22411;&#37324;&#20351;&#29992;&#19968;&#20010;&#23450;&#21046;&#30340;&#24037;&#21378;&#65292;&#25105;&#20204;&#38656;&#35201;&#19968;&#20010;&#30456;&#20851;
&#30340;&#27010;&#24565;&#21483;&#20570;<span style="font-style: italic;">&#24037;&#21378;&#25551;&#36848;&#31526;</span>&#12290;&#19968;
&#20010;&#24037;&#21378;&#25551;&#36848;&#31526;&#26159;&#19968;&#20010;<a href="lambda_expressions.html"><code>Lambda&nbsp;</code>&#34920;
&#36798;&#24335;</a>&#65292;&#23427;&#25509;&#21463;2&#20010;&#21442;&#25968;&#31867;&#22411;<big><code>Entry</code></big>&#21644;<big><code>Key</code></big>&#24182;
&#19988;&#36820;&#22238;&#30456;&#20851;&#30340;&#24037;&#21378;&#31867;&#65306;
</p>

<blockquote>
  <pre><span class="comment">// Factory specifier (metafunction class version)</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_factory_specifier</span><br><span class="special">{</span><br><span class="keyword">&nbsp; template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">&nbsp; struct</span> <span class="identifier">apply</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; typedef</span> <span class="identifier">custom_factory_class</span><span class="special">&lt;</span><span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">&nbsp; }</span> <br><span class="special">};</span><br><br><span class="comment">// Factory specifier (placeholder version)</span><br><br><span class="keyword">typedef</span> <span class="identifier">custom_factory_class</span><span class="special">&lt;</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><br><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><br><span class="special">&gt;</span> <span class="identifier">custom_factory_specifier</span><span class="special">;</span> </pre>

</blockquote>

<p>
There is one last detail: in order to implement <code>flyweight</code>
<a href="configuration.html#free_order_template">free-order
template
parameter interface</a>, it is necessary to explicitly tag a
factory specifier as such, so that it can be distinguised from other
types of specifiers. Boost.Flyweight provides three different
mechanisms
to do this tagging:</p>

<p>&#36824;&#26377;&#26368;&#21518;&#19968;&#20010;&#32454;&#33410;&#65306;&#20026;&#20102;&#23454;&#29616;<big><code>flyweight</code></big>&#30340;<a href="configuration.html#free_order_template">&#33258;&#30001;&#39034;&#24207;&#27169;&#26495;&#21442;&#25968;</a><a href="configuration.html#free_order_template">&#25509;&#21475;</a>&#65292;
&#24517;&#39035;&#26174;&#31034;&#30340;&#26631;&#35760;&#19968;&#20010;&#24037;&#21378;&#25551;&#36848;&#31526;&#65292;&#36825;&#26679;&#23427;&#25165;&#33021;&#21516;&#20854;&#23427;&#31867;&#22411;&#30340;&#25551;&#36848;&#31526;&#21306;&#20998;&#24320;&#12290;Boost.Flyweight&#25552;&#20379;3&#31181;&#26631;&#35760;&#30340;&#21150;&#27861;&#65306;<a href="configuration.html#free_order_template"><code></code></a>
</p>

<ol>

  <li>Have the specifier derive from the dummy type <code>factory_marker</code>.
Note that this mechanism cannot be used with placeholder expressions.
    <p>&#35753;&#36825;&#20010;&#25551;&#36848;&#31526;&#20174;&#19968;&#20010;&#31354;&#31867;&#22411;<big><code>factory_marker</code></big>&#27966;
&#29983;&#32780;&#26469;&#12290;&#27880;&#24847;&#36825;
&#31181;&#26426;&#21046;&#19981;&#33021;&#29992;&#20110;&#21344;&#20301;&#31526;&#34920;&#36798;&#24335;&#12290;</p>

    <blockquote>
      <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">factory_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_factory_specifier</span><span class="special">:</span> <span class="identifier"><b>factory_marker</b></span><br><span class="special">{</span><br><span class="keyword">&nbsp; template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span><br><span class="keyword">&nbsp; struct</span> <span class="identifier">apply</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; typedef</span> <span class="identifier">custom_factory_class</span><span class="special">&lt;</span><span class="identifier">Entry</span><span class="special">,</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">&nbsp; }</span><br><span class="special">};</span>
      </pre>

    </blockquote>

  </li>

  <li>Specialize a special class template called <a href="../reference/factories.html#is_factory"><code>is_factory</code></a>:
    <p>&#19987;&#38376;&#21270;&#19968;&#20010;&#21483;&#20570;<big><a href="../reference/factories.html#is_factory"><code>is_factory</code></a></big>&#30340;
&#29305;&#27530;&#31867;&#22411;&#12290;</p>

    <blockquote>
      <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">factory_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_factory_specifier</span><span class="special">{};</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_factory</span><span class="special">&lt;</span><span class="identifier">custom_factory_specifier</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><br><span class="special">}</span><br><span class="special">}</span>
      </pre>

    </blockquote>

  </li>

  <li>The third mechanism, which is the least intrusive, consists
in wrapping the specifier inside the <a href="../reference/factories.html#factory_construct"><code>factory</code></a>
construct:
    <p>&#31532;&#19977;&#31181;&#21150;&#27861;&#65292;&#36825;&#26159;&#23545;boost&#21517;&#23383;&#31354;&#38388;&#20837;&#20405;&#24615;&#26368;&#23567;&#30340;&#21150;&#27861;&#65292;&#26159;&#21253;&#35013;&#25551;&#36848;&#31526;&#21040;<big><a href="../reference/factories.html#factory_construct"><code>factory</code></a></big>&#30340;
&#26500;&#36896;&#20989;&#25968;&#37324;&#65306;</p>

    <blockquote>
      <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">factory_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier"> std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier"><b> factory</b></span><span class="special">&lt;</span><span class="identifier">custom_factory_specifier</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>
      </pre>

    </blockquote>

  </li>

</ol>

<p>
<a href="../examples.html#example7">Example 7</a> in
the examples section develops
in full the <code>verbose_factory_class</code> case
sketched above.</p>

<p>&#31034;&#20363;&#31456;&#33410;&#30340;<a href="../examples.html#example7">&#20363;7</a>&#23436;
&#25972;&#30340;&#23454;&#29616;&#20102;&#19978;&#38754;&#27010;&#36848;&#30340;<code>verbose_factory_class</code>&#20363;&#23376;&#12290;
</p>

<h2><a name="holders">Custom holders &nbsp;&#23450;&#21046;
holders</a></h2>

<p>
A holder is a class with a static member function <code>get()</code>
giving
access to a unique instance of a given type <code>C</code>:</p>

<p><big>holder</big>&#31867;&#30340;&#38745;&#24577;&#25104;&#21592;&#20989;&#25968;<big><code>get()</code></big>&#25552;
&#20379;&#21040;&#32473;&#23450;&#31867;&#22411;<big><code>C</code></big>&#30340;
&#21807;&#19968;&#23454;&#20363;&#30340;&#35775;&#38382;&#65306;
</p>

<blockquote>
  <pre><span class="comment">// example of a possible holder class template</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">custom_holder_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; static</span> <span class="identifier">C</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span><br><span class="special">};</span>
  </pre>

</blockquote>

<p>
<code>flyweight</code> internally uses a holder to create
its associated
factory as well as some other global data. A holder specifier is a
<a href="lambda_expressions.html"><code>Lambda
Expression</code></a> accepting the type <code>C</code>
upon which
the associated holder class operates:</p>

<p><big><code>flyweight</code></big>&#22312;&#20869;&#37096;&#20351;&#29992;&#19968;
&#20010;holder&#26469;&#21019;&#24314;&#19982;&#20043;&#30456;&#20851;&#30340;&#24037;&#21378;&#21644;&#20854;&#23427;&#19968;&#20123;&#20840;
&#23616;&#25968;&#25454;&#12290;&#19968;&#20010;holder&#25551;&#36848;&#31526;&#26159;&#19968;&#20010;<a href="lambda_expressions.html"><code>Lambda&nbsp;</code>&#34920;
&#36798;&#24335;</a>&#65292;&#25509;&#21463;&#19968;&#20010;&#23427;&#25152;&#25805;&#32437;&#30340;&#31867;&#22411;<big><code>C</code></big>&#20316;
&#20026;&#21442;&#25968;&#12290;
</p>

<blockquote>
  <pre><span class="comment">// Holder specifier (metafunction class version)</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_holder_specifier</span><br><span class="special">{</span><br><span class="keyword">&nbsp; template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">&gt;</span><br><span class="keyword">&nbsp; struct</span> <span class="identifier">apply</span><br><span class="special">&nbsp; {</span><br><span class="keyword">&nbsp; &nbsp; typedef</span> <span class="identifier">custom_holder_class</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">&nbsp; }</span> <br><span class="special">};</span><br><br><span class="comment">// Holder specifier (placeholder version)</span><br><br><span class="keyword">typedef</span> <span class="identifier">custom_holder_class</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">&gt;</span> <span class="identifier">custom_factory_specifier</span><span class="special">;</span>
  </pre>

</blockquote>

<p>
As is the case with <a href="#factories">factory
specifiers</a>, holder
specifiers must be tagged in order to be properly recognized when
provided to <code>flyweight</code>, and there are three
available mechanisms
to do so:</p>

<p>&#22914;&#21516;<a href="#factories">&#24037;&#21378;&#25551;&#36848;&#31526;</a>&#65292;&#20026;&#20102;&#25552;&#20379;&#32473;<big><code>flyweight</code></big>&#30340;
&#26102;&#20505;&#33021;&#34987;&#27491;&#30830;&#35782;&#21035;&#65292;holder&#25551;&#36848;&#31526;&#24517;&#39035;
&#34987;&#26631;&#35760;&#65292;&#26377;3&#31181;&#21150;&#27861;&#21487;&#20197;&#20570;&#21040;&#36825;&#19968;&#28857;&#65306;
</p>

<blockquote>
  <pre><span class="comment">// Alternatives for tagging a holder specifier</span><br><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">holder_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="comment">// 1: Have the specifier derive from holder_marker</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_holder_specifier</span><span class="special">:</span> <span class="identifier"><b>holder_marker</b></span><br><span class="special">{</span><br><span class="special">&nbsp; ...</span><br><span class="special">};</span><br><br><span class="comment">// 2: Specialize the is_holder class template</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_holder</span><span class="special">&lt;</span><span class="identifier">custom_holder_specifier</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><span class="special"><br>}}</span><br><br><span class="comment">// 3: use the holder&lt;&gt; wrapper when passing the specifier<br>// to flyweight</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier"><b>&nbsp; holder</b></span><span class="special">&lt;</span><span class="identifier">custom_holder_specifier</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>
  </pre>

</blockquote>

<h2><a name="locking">Custom locking policies
&nbsp;&#23450;&#21046;&#38145;&#23450;&#31574;&#30053;</a></h2>

<p>
A custom locking policy presents the following simple interface:</p>

<p>&#19968;&#20010;&#23458;&#25143;&#21270;&#30340;&#38145;&#23450;&#31574;&#30053;&#25552;&#20379;&#22914;&#19979;&#31616;&#21333;&#30340;&#25509;&#21475;&#65306;
</p>

<blockquote>
  <pre><span class="comment">// example of a custom policy</span><br><br><span class="keyword">class</span> <span class="identifier">custom_locking</span><br><span class="special">{</span><br><span class="keyword">&nbsp; typedef</span> <span class="special">...</span> <span class="identifier">mutex_type</span><span class="special">;</span><br><span class="keyword">&nbsp; typedef</span> <span class="special">...</span> <span class="identifier">lock_type</span><span class="special">;</span><br><span class="special">};</span>
  </pre>

</blockquote>

<p>
where <code>lock_type</code> is used to acquire/release
mutexes according to
the <i>scoped lock</i> idiom:</p>

<p>&#22312;&#36825;&#37324;<big><code>lock_type</code></big>&#26681;&#25454;<span style="font-style: italic;">&#33539;&#22260;&#38145;</span>&#24815;&#29992;&#27861;&#26469;&#20998;&#37197;/&#37322;&#25918;&#20114;&#26021;&#20307;&#65306;
</p>

<blockquote>
  <pre><span class="identifier">mutex_type</span> <span class="identifier">m</span><span class="special">;</span><br><span class="special">...</span><br><span class="special">{</span><br><span class="identifier">&nbsp; lock_type</span> <span class="identifier">lk</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span> <span class="comment">// acquire the mutex<br>&nbsp; // zone of mutual exclusion, no other thread can acquire the mutex</span><br><span class="special">&nbsp; ...</span><br><span class="special">}</span> <span class="comment">// m released at lk destruction</span>
  </pre>

</blockquote>

<p>
Formal definitions for the concepts
<a href="../reference/locking.html#preliminary"><code>Mutex</code></a>
and
<a href="../reference/locking.html#preliminary"><code>Scoped
Lock</code></a>
are given at the reference. To pass a locking policy as a template
argument of
<code>flyweight</code>, the class must be appropriately
tagged:</p>

<p>&#21442;&#32771;&#37096;&#20998;&#26377;<a href="../reference/locking.html#preliminary"><code></code>&#20114;
&#26021;&#20307;<code></code></a>&#21644;<a href="../reference/locking.html#preliminary"><code></code>&#33539;
&#22260;&#38145;<code></code></a>&#30340;&#27491;&#24335;&#23450;&#20041;&#12290;&#20026;&#20102;&#23558;&#38145;&#23450;&#31574;&#30053;&#20316;&#20026;<big><code>flyweight</code></big>&#30340;
&#27169;&#26495;&#21442;&#25968;&#20256;&#36882;&#65292;&#36825;&#20010;&#31867;&#24517;&#39035;&#34987;&#36866;&#24403;&#30340;&#26631;&#35760;&#65306;
</p>

<blockquote>
  <pre><span class="comment">// Alternatives for tagging a locking policy</span><br><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">locking_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="comment">// 1: Have the policy derive from locking_marker</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_locking</span><span class="special">:</span> <span class="identifier">locking_marker</span><br><span class="special">{</span><br><span class="special">&nbsp; ...</span><br><span class="special">};</span><br><br><span class="comment">// 2: Specialize the is_locking class template</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_locking</span><span class="special">&lt;</span><span class="identifier">custom_locking</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><span class="special"><br>}}</span><br><span class="comment"><br>// 3: use the locking&lt;&gt; wrapper when passing the policy<br>// to flyweight</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier">&nbsp; locking</span><span class="special">&lt;</span><span class="identifier">custom_locking</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>
  </pre>

</blockquote>

<p>
Note that a locking policy is its own specifier, i.e. there is no
additional class to be passed as a proxy for the real component as is
the case with factories and holders.</p>

<p>&#27880;&#24847;&#19968;&#20010;&#38145;&#23450;&#31574;&#30053;&#26159;&#23427;&#33258;&#24049;&#30340;&#25551;&#36848;&#31526;&#65292;&#23601;&#26159;&#35828;&#65292;&#36825;&#37324;&#19981;&#38656;&#35201;&#20687;&#24037;&#21378;&#21644;holders&#37027;&#26679;&#20256;&#36882;&#19968;&#20010;&#20316;&#20026;&#30495;&#23454;&#32452;&#20214;&#20195;&#29702;&#30340;&#39069;&#22806;&#30340;&#31867;&#22411;&#12290;
</p>

<h2><a name="tracking">Custom tracking policies
&nbsp;&#23450;&#21046;&#36319;&#36394;&#31574;&#30053;</a></h2>

<p>
Tracking policies contribute some type information to the process of
definition of the internal flyweight factory, and are given access
to that factory to allow for the implementation of the tracking
code. A tracking policy <code>Tracking</code> is defined
as a class with
the following nested elements:</p>

<p>&#36319;&#36394;&#31574;&#30053;&#22312;&#23450;&#20041;&#20869;&#37096;flyweight&#24037;&#21378;&#30340;&#36807;&#31243;&#20013;&#21152;&#20837;&#20102;&#19968;&#20123;&#31867;&#22411;&#20449;&#24687;&#65292;&#23427;&#34987;&#25480;&#26435;&#35775;&#38382;&#24037;&#21378;&#20197;&#23454;&#29616;&#36319;&#36394;&#20195;&#30721;&#12290;&#19968;&#20010;&#36319;&#36394;&#31574;&#30053;<big><code>Tracking</code></big>&#26159;
&#19968;&#20010;&#23450;&#20041;&#20102;&#20197;&#19979;&#20869;&#23884;&#20803;&#32032;&#30340;&#31867;&#65306;
</p>

<ul>

  <li>A type <code>Tracking::entry_type</code>.</li>

</ul>

<div style="margin-left: 40px;">&#19968;&#20010;<big><code>Tracking::entry_type</code></big>&#31867;
&#22411;</div>

<ul>

  <li>A type <code>Tracking::handle_type</code>.</li>

</ul>

<div style="margin-left: 40px;">&#19968;&#20010;<big><code>Tracking::handle_type</code></big>&#31867;
&#22411;<br>
<br>

</div>

Each of these elements build on the preceding one, in the sense that
Boost.Flyweight internal machinery funnels the results produced by an
element into the following:<br>

<br>

&#20869;&#37096;&#26426;&#21046;
<ul>

  <li><code>Tracking::entry_type</code> is a <a href="lambda_expressions.html"><code>Lambda Expression</code></a>
accepting two different types named <code>Value</code> and
    <code>Key</code> such that <code>Value</code>
is implicitly convertible to <code>const Key&amp;</code>.
The expression is expected to return a type implicitly convertible to
both <code>const Value&amp;</code> and <code>const
Key&amp;</code>. <code>Tracking::entry_type</code>
corresponds to the actual type of the entries stored into the <a href="configuration.html#factory_types">flyweight factory</a>:
by allowing the tracking policy to take part on the definition of this
type it is possible for the policy to add internal tracking information
to the entry data in case this is needed. If no additional information
is required, the tracking policy can simply return <code>Value</code>
as its <code>Tracking::entry_type</code> type.</li>

</ul>

<div style="margin-left: 40px;"><big><code>Tracking::entry_type</code></big>&#26159;
&#19968;&#20010;<a href="lambda_expressions.html"><code><big>Lambda</big>&nbsp;</code>&#34920;
&#36798;&#24335;</a>&#65292;&#23427;&#25509;&#21463;2&#20010;&#21517;&#20026;<code>Value</code>&#21644;<code>Key</code>&#30340;&#19981;&#21516;&#31867;&#22411;&#65292;
&#36825;&#20010;<big><code>Value</code></big>&#21487;&#20197;&#38544;&#24335;&#36716;&#25442;&#21040;<big><code>const Key&amp;</code></big>&#12290;
&#36825;&#20010;&#34920;&#36798;&#24335;&#36820;&#22238;&#30340;&#32467;&#26524;&#26159;&#19968;&#20010;&#21487;&#20197;&#38544;&#24335;&#36716;&#25442;&#21040;<big><code>const Value&amp;</code></big>&#21644;<big><code>const
Key&amp;</code></big>&#30340;&#31867;&#22411;&#12290;<big><code>Tracking::entry_type</code></big>&#30456;
&#24403;&#20110;&#23384;&#20648;&#22312;<a href="configuration.html#factory_types">flyweight&#24037;&#21378;</a>&#37324;
&#30340;entries&#30340;&#23454;&#38469;&#31867;&#22411;&#65306;&#36890;&#36807;&#20801;&#35768;&#36319;&#36394;&#31574;&#30053;&#21442;&#19982;&#21040;entry&#31867;&#22411;&#30340;&#23450;&#20041;&#65292;&#36319;&#36394;&#31574;&#30053;&#23601;&#21487;&#20197;&#22312;&#38656;&#35201;&#30340;&#26102;&#20505;&#28155;&#21152;&#20869;&#37096;&#36319;&#36394;&#20449;&#24687;&#21040;entry&#25968;&#25454;&#12290;&#22914;&#26524;&#19981;
&#38656;&#35201;&#39069;&#22806;&#30340;&#20449;&#24687;&#65292;&#36319;&#36394;&#31574;&#30053;&#21487;&#20197;&#31616;&#21333;&#30340;&#36820;&#22238;<big><code>Value</code></big>&#20316;&#20026;&#23427;&#30340;<big><code>Tracking::entry_type</code></big>&#31867;
&#22411;&#12290;</div>

<ul>

  <li> The binary <a href="lambda_expressions.html"><code>Lambda
Expression</code></a> <code>Tracking::handle_type</code>
is invoked with types <code>InternalHandle</code> and <code>TrackingHandler</code>
to produce a type <code>Handle</code>, which will be used
as the handle type of the flyweight factory. <a href="../reference/tracking.html#preliminary"><code>TrackingHandler</code></a>
is passed as a template argument to <code>Tracking::handle_type</code>
to offer functionality supporting the implementation of the tracking
code.</li>

</ul>

<div style="margin-left: 40px;">&#20108;&#20803;<a href="lambda_expressions.html"><code><big>Lambda</big>&nbsp;</code>&#34920;
&#36798;&#24335;</a><big><code>Tracking::handle_type</code></big>&#36890;&#36807;&#31867;&#22411;<big><code>InternalHandle</code></big>&#21644;<big><code>TrackingHandler</code></big>&#35843;
&#29992;&#20135;&#29983;&#19968;&#20010;<big><code>Handle</code></big>&#31867;&#22411;&#65292;&#35813;&#31867;&#22411;&#34987;&#29992;&#20316;flyweight&#24037;&#21378;&#30340;handle&#31867;&#22411;&#12290;&#20316;&#20026;&#27169;&#26495;&#21442;&#25968;&#20256;
&#36882;&#32473;<big><code>Tracking::handle_type</code></big>&#30340;<a href="../reference/tracking.html#preliminary"><code>TrackingHandler</code></a>&#29992;&#26469;&#23454;&#29616;&#36319;&#36394;&#20195;&#30721;&#12290;<br>
<br>

</div>

So, in order to define the factory of some instantiation
<code>fw_t</code> of <code>flyweight</code>, <code>Tracking::entry_type</code>
is invoked with an internal type <code>Value</code>
implicitly convertible
to&nbsp;<code>const fw_t::key_type&amp;</code> to
obtain
the entry type for the factory,
which must be convertible to both <code>const Value&amp;</code>
and
<code>const fw_t::key_type&amp;</code>.
Then, <code>Tracking::handle_type</code> is fed an
internal handle
type and a tracking policy helper to produce the factory handle type.
The observant reader might have detected an apparent circularity: <code>Tracking::handle_type</code>
produces the handle type of
the flyweight factory, and at the same time is passed a tracking helper
that grants access to the factory being defined!
The solution to this riddle comes from the realization of the fact that
<code>TrackingHandler</code> is an <i>incomplete
type</i> by the time it is passed to <code>Tracking::handle_type</code>:
only when <code>Handle</code> is instantiated at a later
stage will this
type be complete.<br>

<br>

&#20110;&#26159;&#65292;&#20026;&#20102;&#23450;&#20041;&#26576;&#20010;<big><code>flyweight</code></big>&#23454;&#20363;<big><code>fw_t</code></big>&#30340;&#24037;&#21378;<code>&#65292;</code><code></code>&#29992;
&#19968;&#20010;&#21487;&#20197;&#38544;&#24335;&#36716;&#25442;&#21040;<big><code>const fw_t::key_type&amp;</code></big>&#30340;<code></code>&#20869;
&#37096;&#31867;&#22411;<big><code>Value</code></big>&#26469;&#35843;&#29992;<big><code>Tracking::entry_type</code></big>&#65292;&#24471;&#21040;&#24037;&#21378;&#30340;entry&#31867;&#22411;&#65292;&#36825;&#20010;&#31867;&#22411;&#21487;&#20197;&#21516;&#26102;&#36716;&#25442;&#25104;<big><code>const
Value&amp;</code>&nbsp;</big>&#21644;<big>
<code>const fw_t::key_type&amp;</code></big>&#12290;&#28982;&#21518;&#65292;<code></code>&#25552;&#20379;&#19968;&#20010;&#20869;&#37096;handle&#31867;&#22411;&#21644;&#19968;&#20010;&#36319;&#36394;&#31574;&#30053;&#36741;&#21161;&#22120;&#32473;<big><code>Tracking::handle_type</code></big>&#29992;&#26469;&#29983;&#25104;&#24037;&#21378;&#30340;handle&#31867;&#22411;&#12290;&#25935;&#38160;&#30340;&#35835;&#32773;&#21487;&#33021;&#24050;&#32463;&#35266;&#23519;&#21040;&#19968;&#20010;&#26126;&#26174;&#30340;&#24490;&#29615;&#65306;<big><code>Tracking::handle_type</code></big>&#29983;
&#25104;flyweight&#24037;&#21378;&#30340;handle&#31867;&#22411;&#65292;&#21516;&#26102;&#23427;&#34987;&#20256;&#36882;&#19968;&#20010;&#21487;&#20197;&#35775;&#38382;&#27491;&#22312;&#34987;&#21019;&#24314;&#30340;&#24037;&#21378;&#30340;&#36319;&#36394;&#36741;&#21161;&#22120;&#65281;&#36825;&#20010;&#35868;&#39064;&#30340;&#35299;&#20915;&#26041;&#26696;&#22312;&#20110;&#65306;<big><code>TrackingHandler</code></big>&#22312;
&#20256;&#36882;&#32473;<big><code>Tracking::handle_type</code></big>&#26102;&#26159;&#19968;&#20010;&#19981;&#23436;&#20840;&#30340;&#31867;&#22411;&#65292;&#21482;&#26377;&#22312;<big><code>Handle</code></big>&#21518;&#26469;&#34987;
&#23454;&#20363;&#21270;&#20043;&#21518;&#23427;&#25165;&#25104;&#20026;&#19968;&#20010;&#23436;&#25972;&#30340;&#31867;&#22411;&#12290;<code></code>
<p>In order for a tracking policy to be passed to <code>flyweight</code>,
it must be tagged much in the same way as the rest of specifiers.</p>

<p>&#20026;&#20102;&#35753;&#19968;&#20010;&#36319;&#36394;&#31574;&#30053;&#21487;&#20197;&#20256;&#36882;&#32473;<big><code>flyweight</code></big>&#65292;&#23427;&#24517;&#39035;&#20687;&#20854;&#23427;&#26631;&#35782;&#31526;&#19968;&#26679;&#34987;&#26631;
&#35760;&#12290;
</p>

<blockquote>
  <pre><span class="comment">// Alternatives for tagging a tracking policy</span><br><br><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">flyweight</span><span class="special">/</span><span class="identifier">tracking_tag</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><br><br><span class="comment">// 1: Have the policy derive from tracking_marker</span><br><br><span class="keyword">struct</span> <span class="identifier">custom_tracking</span><span class="special">:</span> <span class="identifier"><b>tracking_marker</b></span><br><span class="special">{</span><br><span class="special">&nbsp; ...</span><br><span class="special">};</span><br><br><span class="comment">// 2: Specialize the is_tracking class template</span><br><br><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_tracking</span><span class="special">&lt;</span><span class="identifier">custom_tracking</span><span class="special">&gt;:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">{};</span><br><span class="special"><br>}}</span><br><br><span class="comment">// 3: use the tracking&lt;&gt; wrapper when passing the policy<br>// to flyweight</span><br><br><span class="keyword">typedef</span> <span class="identifier">flyweight</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span><br><span class="identifier"><b>&nbsp; tracking</b></span><span class="special">&lt;</span><span class="identifier">custom_tracking</span><span class="special">&gt;</span><br><span class="special">&gt;</span> <span class="identifier">flyweight_string</span><span class="special">;</span>
  </pre>

</blockquote>

<p>
Tracking policies are their own specifiers, that is, they are provided
directly
as template arguments to the <code>flyweight</code> class
template.</p>

<p>&#36319;&#36394;&#31574;&#30053;&#26159;&#23427;&#20204;&#33258;&#24049;&#30340;&#25551;&#36848;&#31526;&#65292;&#23601;&#26159;&#35828;&#65292;&#23427;&#20204;&#20316;&#20026;&#27169;&#26495;&#21442;&#25968;&#34987;&#30452;&#25509;&#25552;&#20379;&#32473;<big><code>flyweight</code></big>&#31867;
&#27169;&#26495;&#12290;
</p>

<hr>
<div class="prev_link"><a href="configuration.html"><img src="../prev.gif" alt="configuring Boost.Flyweight" border="0"><br>

Configuring Boost.Flyweight
</a></div>

<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight tutorial" border="0"><br>

Boost.Flyweight tutorial
</a></div>

<div class="next_link"><a href="technical.html"><img src="../next.gif" alt="technical issues" border="0"><br>

Technical issues
</a></div>

<br style="" clear="all">

<br>

<p>Revised December 2nd 2008</p>

<p>&copy; Copyright 2006-2008 Joaqu&iacute;n M
L&oacute;pez Mu&ntilde;oz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>



  
  
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">


  


  
  
  
  <title>Boost.Flyweight Documentation - Performance</title>
  <link rel="stylesheet" href="style.css" type="text/css">



  
  
  <link rel="start" href="index.html">



  
  
  <link rel="prev" href="reference/tracking.html">



  
  
  <link rel="up" href="index.html">



  
  
  <link rel="next" href="examples.html">
</head>


<body>



<h1><img src="../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Performance</h1>



<div class="prev_link"><a href="reference/tracking.html"><img src="prev.gif" alt="tracking policies" border="0"><br>



Tracking policies
</a></div>



<div class="up_link"><a href="index.html"><img src="up.gif" alt="index" border="0"><br>



Index
</a></div>



<div class="next_link"><a href="examples.html"><img src="next.gif" alt="examples" border="0"><br>



Examples
</a></div>



<br style="" clear="all">



<br style="" clear="all">



<hr>
<h2>Contents &nbsp;&#30446;&#24405;</h2>



<ul>



  <li><a href="#intro">Introduction &nbsp;&#31616;&#20171;</a></li>



  <li><a href="#memory">Memory consumption
&nbsp;&#20869;&#23384;&#28040;&#32791;</a>
    
    
    <ul>



      <li><a href="#flyweight_size">Flyweight size
&nbsp;Flyweight &#22823;&#23567;</a></li>



      <li><a href="#entry_size">Entry size
&nbsp;Entry &#22823;&#23567;</a></li>



      <li><a href="#overall_memory">Overall memory
consumption &nbsp;&#24635;&#30340;&#20869;&#23384;&#28040;&#32791;</a></li>



    
    
    </ul>



  </li>



  <li><a href="#time">Time efficiency &nbsp;&#26102;&#25928;</a>
    
    
    <ul>



      <li><a href="#initialization">Initialization
&nbsp;&#21021;&#22987;&#21270;</a></li>



      <li><a href="#assignment">Assignment
&nbsp;&#36171;&#20540;</a></li>



      <li><a href="#equality_comparison">Equality
comparison &nbsp;&#21028;&#31561;</a></li>



      <li><a href="#value_access">Value access
&nbsp;&#20540;&#23384;&#21462;</a></li>



    
    
    </ul>



  </li>



  <li><a href="#results">Experimental results
&nbsp;&#23454;&#39564;&#32467;&#26524;</a>
    
    
    <ul>



      <li><a href="#msvc_80">Microsoft Visual C++ 8.0</a>
        
        
        <ul>



          <li><a href="#msvc_80_memory">Memory
&nbsp;&#20869;&#23384;</a></li>



          <li><a href="#msvc_80_time">Execution time
&nbsp;&#25191;&#34892;&#26102;&#38388;</a></li>



        
        
        </ul>



      </li>



      <li><a href="#gcc_344">GCC 3.4.4</a>
        
        
        <ul>



          <li><a href="#gcc_344_memory">Memory
&nbsp;&#20869;&#23384;</a></li>



          <li><a href="#gcc_344_time">Execution time
&nbsp;&#25191;&#34892;&#26102;&#38388;</a></li>



        
        
        </ul>



      </li>



    
    
    </ul>



  </li>



  <li><a href="#conclusions">Conclusions &nbsp;&#32467;&#35770;</a></li>



</ul>



<h2><a name="intro">Introduction &nbsp;&#31616;&#20171;</a></h2>



<p>
We show how to estimate the memory reduction obtained by the usage of
Boost.Flyweight in a particular scenario and study the impact on the
execution
time for the different functional areas of <code>flyweight</code>.
Some experimental results are provided.</p>



<p>&#25105;&#20204;&#28436;&#31034;&#20102;&#24590;&#26679;&#35780;&#20272;&#22312;&#19968;&#20010;&#29305;&#23450;&#30340;&#24773;&#24418;&#19979;&#36890;&#36807;&#20351;&#29992;Boost.Flyweight&#21487;&#20197;&#20943;&#23569;&#30340;&#20869;&#23384;&#29992;&#37327;&#24182;&#19988;&#30740;&#31350;&#20102;<code>flyweight</code>&#21508;&#31181;&#20351;&#29992;&#24773;&#20917;&#19979;&#23545;&#25191;&#34892;&#26102;&#38388;&#30340;&#24433;&#21709;&#12290;&#26368;&#21518;&#32473;&#20986;&#20102;&#19968;&#20123;&#23454;&#39564;&#32467;&#26524;&#12290;</p>



<h2><a name="memory">Memory consumption
&nbsp;&#20869;&#23384;&#28040;&#32791;</a></h2>



<p>
As we saw in the <a href="tutorial/index.html#rationale">tutorial
rationale</a>,
the flyweight pattern is based on two types of objects:</p>



<p>&#27491;&#22914;&#25105;&#20204;&#24050;&#32463;&#22312;<a href="tutorial/index.html#rationale">&#25945;&#31243; &#21407;&#29702;</a>&#20013;&#25152;&#30475;&#21040;&#30340;&#65292;flyweight&#27169;&#24335;&#22522;&#20110;2&#31181;&#31867;&#22411;&#30340;&#23545;&#35937;&#65306;
</p>



<ul>



  <li>The flyweight objects proper, which have very small size,
typically that of a pointer.</li>



  
</ul>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flyweight&#23545;&#35937;&#26412;&#36523;&#65292;&#23427;&#20204;&#38750;&#24120;&#23567;&#65292;&#36890;&#24120;&#26159;&#19968;&#20010;&#25351;&#38024;&#30340;&#22823;&#23567;&#12290;
<ul>



  <li>The shared values, which are stored as internal <i>entries</i>
into the flyweight factory.</li>
</ul>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#20849;&#20139;&#30340;&#20540;&#65292;&#23427;&#20204;&#20316;&#20026;&#20869;&#37096;&#30340;<i>entries</i>&#23384;&#20648;&#22312;flyweight&#24037;&#21378;&#37324;<i></i>&#12290;
<ul>



</ul>



The overall memory consumption is then a function of the size of the
flyweight objects, the size of the entry objects and the degree of
value redundancy.<br>
<br>



&#20110;&#26159;&#24635;&#30340;&#20869;&#23384;&#28040;&#32791;&#23601;&#26159;&#19968;&#20010;&#20851;&#20110;flyweight&#23545;&#35937;&#30340;&#22823;&#23567;&#65292;entry&#23545;&#35937;&#30340;&#22823;&#23567;&#21644;&#20540;&#20887;&#20313;&#24230;&#30340;&#20989;&#25968;&#12290;
<h3><a name="flyweight_size">Flyweight size
&nbsp;Flyweight &#22823;&#23567;</a></h3>



<p>
The only data member of a <code>flyweight</code> object is
a so-called
<i>handle</i>, an opaque object of small size provided by
the internal
flyweight factory to refer to the entries it stores. For the default
<a href="tutorial/configuration.html#hashed_factory"><code>hashed_factory</code></a>,
this handle is merely a pointer, so <code>sizeof(flyweight&lt;T&gt;)=sizeof(void*)</code>,
4 bytes in typical 32-bit architectures.
For other types of factories, the handle is an iterator to an internal
container used in the implementation of the factory: again, its size
is typically that of a pointer.</p>



<p><code>flyweight</code>&#23545;&#35937;&#21807;&#19968;&#30340;&#25968;&#25454;&#25104;&#21592;&#26159;&#19968;&#20010;&#25152;&#35859;&#30340;<span style="font-style: italic;">&#21477;&#26564;</span>&#65292;&#36825;&#26159;&#30001;&#20869;&#37096;flyweight&#24037;&#21378;&#25152;&#25552;&#20379;&#30340;&#19968;&#20010;&#23567;&#22411;&#30340;&#19981;&#36879;&#26126;&#30340;&#23545;&#35937;&#65292;&#29992;&#26469;&#24341;&#29992;&#21040;&#24037;&#21378;&#37324;&#23384;&#20648;&#30340;entries&#12290;&#23545;&#40664;&#35748;&#30340;<a href="tutorial/configuration.html#hashed_factory">hashed_factory</a>&#65292;
&#36825;&#20010;&#21477;&#26564;&#20165;&#20165;&#26159;&#19968;&#20010;&#25351;&#38024;&#65292;&#22240;&#27492;<code>sizeof(flyweight&lt;T&gt;)=sizeof(void*)</code>&#65292; &#36890;&#24120;&#22312;32&#20301;&#26550;&#26500;&#19978;&#26159;4&#20010;&#23383;&#33410;&#30340;&#22823;&#23567;&#12290;&#23545;&#20854;&#23427;&#31867;&#22411;&#30340;&#24037;&#21378;&#65292;&#35813;&#21477;&#26564;&#26159;&#19968;&#20010;&#29992;&#26469;&#23454;&#29616;&#36825;&#20010;&#24037;&#21378;&#30340;&#20869;&#37096;&#23481;&#22120;&#30340;&#36845;&#20195;&#22120;&#65306;&#21516;&#26679;&#65292;&#23427;&#30340;&#22823;&#23567;&#36890;&#24120;&#26159;&#19968;&#20010;&#25351;&#38024;&#30340;&#22823;&#23567;&#12290;
</p>



<h3><a name="entry_size">Entry size &nbsp;Entry
&#22823;&#23567;</a></h3>



<p>
The entries stored in the factory associated to <code>flyweight&lt;T,...&gt;</code>
need not only hold a value of <code>T</code>, but also
contain additional
information related to the internal implementation of
<code>flyweight&lt;T,...&gt;</code>:</p>



<p>&#19982;<code>flyweight&lt;T,...&gt;</code>&#30456;&#20851;&#32852;&#30340;entries&#65292;&#22312;&#24037;&#21378;&#20013;&#23384;&#20648;&#26102;&#65292;&#19981;&#20165;&#21253;&#21547;&#19968;&#20010;T&#31867;&#22411;&#30340;&#20540;&#65292;
&#32780;&#19988;&#36824;&#21253;&#21547;&#19982;<code>flyweight&lt;T,...&gt;</code>&#30340;&#20869;&#37096;&#23454;&#29616;&#30456;&#20851;&#30340;&#39069;&#22806;&#20449;&#24687;&#12290;
</p>



<blockquote> <i>entry</i> = <code>sizeof(T)</code>
+ <i>overhead</i>.
</blockquote>



<p>
For the current implementation of Boost.Flyweight, the following
aspects
contribute to <i>overhead</i>:</p>



<p>&#23601;Boost.Flyweight&#30446;&#21069;&#30340;&#23454;&#29616;&#26469;&#35828;&#65292;&#20197;&#19979;&#20960;&#20010;&#26041;&#38754;&#20250;&#22686;&#21152;<span style="font-style: italic;">&#39069;&#22806;&#24320;&#38144;</span>&#65306;
</p>



<ul>



  <li>Usage of <a href="tutorial/key_value.html">key-value
flyweights</a>.</li>



  
</ul>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#20351;&#29992;<a href="tutorial/key_value.html">&#38190;-&#20540;flyweight</a>&#12290;
<ul>



  <li>Internal overhead of the <a href="tutorial/configuration.html#factories">factory</a>
container.</li>



  
</ul>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tutorial/configuration.html#factories">&#24037;&#21378;</a>&#23481;&#22120;&#30340;&#20869;&#37096;&#39069;&#22806;&#24320;&#38144;&#12290;
<ul>



  <li>Bookkeeping information associated to the <a href="tutorial/configuration.html#tracking">tracking
mechanism</a>.</li>



  


</ul>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tutorial/configuration.html#tracking">tracking&#26426;&#21046;</a>&#30456;&#20851;&#30340;&#34180;&#35760;&#20449;&#24687;&#12290;<br>



The table summarizes the separate contributions to <i>overhead</i>
introduced
by the different components taking part of the definition of
a <code>flyweight</code> instantiation. Values are given
in <i>words</i>,
i.e. the size of a pointer, which is 4 bytes in a typical 32-bit
architecture.
Alignment may introduce additional overhead.<br>
<br>



&#36825;&#20010;&#34920;&#26684;&#24635;&#32467;&#20102;&#23450;&#20041;&#19968;&#20010;<code>flyweight</code>&#23454;&#20363;&#30340;&#21508;&#20010;&#32452;&#25104;&#37096;&#20998;&#21508;&#33258;&#24341;&#36215;&#30340;<span style="font-style: italic;">&#39069;&#22806;&#24320;&#38144;</span>&#12290;&#36825;&#20123;&#20540;&#30340;&#21333;&#20301;&#37117;&#26159;<span style="font-style: italic;">&#23383;</span>&#65292;
&#25442;&#21477;&#35805;&#35828;&#65292;&#19968;&#20010;&#25351;&#38024;&#30340;&#22823;&#23567;&#65292;&#36890;&#24120;&#22312;32&#20301;&#26550;&#26500;&#19978;&#26159;4&#20010;&#23383;&#33410;&#12290;&#23545;&#40784;&#21487;&#33021;&#23548;&#33268;&#39069;&#22806;&#30340;&#24320;&#38144;&#12290;
<table cellspacing="0">



  <caption><b>Entry overhead of the components of
Boost.Flyweight.</b></caption> <tbody>



    <tr>



      <th colspan="2" align="center">component</th>



      <th align="center">overhead (words)</th>



    </tr>



    <tr>



      <td rowspan="2" align="center">&nbsp;&nbsp;<a href="tutorial/key_value.html#key_value"><code>key_value</code></a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;with <a href="tutorial/key_value.html#key_extractor">key extractor</a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;1<sup>(1)</sup>&nbsp;&nbsp;</td>



    </tr>



    <tr>



      <td align="center">&nbsp;&nbsp;without <a href="tutorial/key_value.html#key_extractor">key extractor</a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;1 + <code>sizeof(Key)&nbsp;&nbsp;</code></td>



    </tr>



    <tr class="odd_tr">



      <td rowspan="3" align="center">&nbsp;&nbsp;factory&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;<a href="tutorial/configuration.html#hashed_factory"><code>hashed_factory</code></a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;~2.5&nbsp;&nbsp;</td>



    </tr>



    <tr class="odd_tr">



      <td align="center">&nbsp;&nbsp;<a href="tutorial/configuration.html#set_factory"><code>set_factory</code></a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;4<sup>(2)</sup>&nbsp;&nbsp;</td>



    </tr>



    <tr class="odd_tr">



      <td align="center">&nbsp;&nbsp;<a href="tutorial/configuration.html#assoc_container_factory"><code>assoc_container_factory</code></a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;depends on
the container used&nbsp;&nbsp;</td>



    </tr>



    <tr>



      <td rowspan="2" align="center">&nbsp;&nbsp;tracking
mechanism&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;<a href="tutorial/configuration.html#refcounted"><code>refcounted</code></a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;1<sup>(3)</sup>&nbsp;&nbsp;</td>



    </tr>



    <tr>



      <td align="center">&nbsp;&nbsp;<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>&nbsp;&nbsp;</td>



      <td align="center">&nbsp;&nbsp;0&nbsp;&nbsp;</td>



    </tr>



  
  
  </tbody>
</table>



<sup>(1)</sup> <small>Assuming that <code>sizeof(Key)&lt;=sizeof(Value)</code>.</small>
<small>&nbsp;&#20551;&#23450;<code>sizeof(Key)&lt;=sizeof(Value)&#12290;</code></small><br>



<sup>(2)</sup> <small>For some implementations of <code>std::set</code>
this overhead reduces to 3.</small><small> &nbsp;&#23545;&#26576;&#20123;<code>std::set&#30340;&#23454;&#29616;&#36825;&#20010;&#39069;&#22806;&#24320;&#38144;&#38477;&#21040;3&#12290;</code> </small><br>



<sup>(3)</sup> <small>In some platforms this value
can be 2. &nbsp;&#22312;&#26576;&#20123;&#24179;&#21488;&#19978;&#36825;&#20010;&#20540;&#21487;&#33021;&#26159;2&#12290;</small>
<p>For instance, for the default configuration parameters of <code>flyweight</code>,
<i>overhead</i> is typically 2.5(<code>hashed_factory</code>)
+ 1(<code>refcounted</code>)
= 3 words.</p>


<p>&#20363;&#22914;&#65292;&#23601;<code>flyweight</code>&#30340;&#40664;&#35748;&#37197;&#32622;&#21442;&#25968;&#32780;&#35328;&#65292;<span style="font-style: italic;">&#39069;&#22806;&#24320;&#38144;</span>&#36890;&#24120;&#26159;2.5(<code>hashed_factory</code>)
+ 1(<code>refcounted</code>)
= 3&#20010;&#23383;&#12290;
</p>



<h3><a name="overall_memory">Overall memory
consumption &nbsp;&#24635;&#30340;&#20869;&#23384;&#28040;&#32791;</a></h3>



<p>
Consider a scenario where there are <i>N</i> different
objects of type <code>T</code>
jointly taking <i>M</i> different values. The objects
consume then
<i>S</i> = <i>N</i>&middot;<i>T</i>
bytes, where <i>T</i> is defined as the
average size of <code>T</code> (<code>sizeof(T)</code>
plus dynamic
memory allocated by <code>T</code> objects).
If we now replace <code>T</code> by some instantiation
<code>flyweight&lt;T,...&gt;</code>, the resulting
memory consumption
will be</p>



<p>&#32771;&#34385;&#36825;&#26679;&#19968;&#20010;&#22330;&#26223;&#65306;<i>N</i>&#20010;&#19981;&#21516;&#30340; <code>T</code>&#31867;&#22411;&#30340;&#23545;&#35937;&#24635;&#20849;&#21344;&#25454;&#20102;<i>M</i>&#20010;&#19981;&#21516;&#30340;&#20540;&#12290;&#37027;&#20040;&#36825;&#20123;&#23545;&#35937;&#28040;&#32791;<i>S</i> = <i>N</i>&middot;<i>T</i>&#23383;&#33410;&#65292;<i>T</i>&#26159;&#31867;&#22411;<code>T</code>&#30340;&#24179;&#22343;&#22823;&#23567;&#65288;<code>sizeof(T)</code>&#21152;&#19978;&nbsp;<code>T</code>&#23545;&#35937;&#21160;&#24577;&#20998;&#37197;&#30340;&#20869;&#23384;&#65289;&#12290;&#22914;&#26524;&#25105;&#20204;&#29616;&#22312;&#29992;&#26576;&#31181;<code>flyweight&lt;T,...&gt;</code>&#30340;&#23454;&#20363;&#26469;&#26367;&#25442; <code>T</code>&#65292;&#20869;&#23384;&#28040;&#32791;&#30340;&#32467;&#26524;&#23558;&#20250;&#26159;&#65306;
</p>



<blockquote> <i>S<sub>F</sub></i> = <i>N</i>&middot;<i>P</i>
+ <i>M</i>&middot;(<i>T</i> + <i>overhead</i>),
</blockquote>



<p>
where <i>P</i> is <code>sizeof(flyweight&lt;T,...&gt;)</code>,
typically
equal to <code>sizeof(void*)</code>, as seen <a href="#flyweight_size">before</a>.
The ratio <i>S<sub>F</sub></i> / <i>S</i>
is then</p>



<p>&#22312;&#36825;&#37324;P&#26159;<code>sizeof(flyweight&lt;T,...&gt;)</code>&#65292;&#23601;&#20687;<a href="#flyweight_size">&#20043;&#21069;</a>&#30475;&#21040;&#30340;&#65292;&#36890;&#24120;&#24773;&#20917;&#19979;&#31561;&#20110;<code>sizeof(void*)</code>&#12290;&#37027;&#20040;<i>S<sub>F</sub></i> / <i>S</i>&#30340;&#27604;&#20540;&#26159;
</p>



<blockquote> <i>S<sub>F</sub></i> / <i>S</i>
=
(<i>P</i> / <i>T</i>)+ (<i>M</i> /
  <i>N</i>)(1 + <i>overhead</i> / <i>T</i>).
</blockquote>



<p>
<i>S<sub>F</sub></i> / <i>S</i>
tends to its minimum, <i>P</i> / <i>T</i>,
as <i>M</i> / <i>N</i> tends to 0, i.e. when
the degree of value redundancy
among <code>T</code> objects grows higher. On the other
hand, the worst possible case
<i>S<sub>F</sub></i> / <i>S</i> =
1 + (<i>P</i> + <i>overhead</i>) / <i>T</i>
happens when <i>M</i> / <i>N</i> = 1, that
is, if there is no value redundancy at all; in this situation there is
no point in applying the flyweight pattern in the first place.</p>



<p>&#24403; <i>M</i> / <i>N</i>&#36235;&#36817;&#20110;0&#65292;&#20063;&#23601;&#26159;&#35828;&#65292;&#24403;<code>T</code>&#23545;&#35937;&#30340;&#20540;&#30340;&#20887;&#20313;&#24230;&#22686;&#21152;&#30340;&#26102;&#20505;&#65292;<i>S<sub>F</sub></i> / <i>S</i>&#36235;&#36817;&#20110;&#23427;&#30340;&#26368;&#23567;&#20540;<i>P</i> / <i>T</i>&#12290;&#21478;&#19968;&#26041;&#38754;&#65292;&#24403;<i>M</i> / <i>N</i> = 1&#65292;&#23601;&#26159;&#35828;&#65292;
&#26681;&#26412;&#23601;&#27809;&#26377;&#20887;&#20313;&#30340;&#20540;&#26102;&#65292;&#20986;&#29616;&#26368;&#24046;&#30340;&#24773;&#24418;
<i>S<sub>F</sub></i> / <i>S</i> =
1 + (<i>P</i> + <i>overhead</i>) / <i>T</i>&#65292;&#36825;&#31181;&#24773;&#20917;&#19979;&#24403;&#21021;&#24341;&#20837;flyweight&#27169;&#24335;&#23601;&#26159;&#27809;&#24847;&#20041;&#30340;&#12290;
</p>



<p align="center">
<img src="memory.png" alt="relative memory consumption of Boost.Flyweight as a function of value diversity" height="411" width="446"><br>



<b>Fig. 1: Relative memory consumption of Boost.Flyweight as a
function of value diversity.</b>
</p>



<h2>
<a name="time">Time efficiency &nbsp;&#26102;&#25928;</a>
</h2>



<p>
The introduction of the flyweight pattern involves an extra level of
indirection
that, in general, results in some execution overhead when accessing the
values. On
the other hand, manipulation of flyweight objects is considerably
faster than
moving around the heavy values they stand for. We analyze qualitatively
the
execution overheads or improvements associated to the different usage
contexts
of Boost.Flyweight.</p>



<p>&#24341;&#20837;flyweight&#27169;&#24335;&#29301;&#28041;&#21040;&#19968;&#23618;&#39069;&#22806;&#30340;&#38388;&#25509;&#65292;&#36890;&#24120;&#36825;&#20250;&#23548;&#33268;&#22312;&#23384;&#21462;&#20540;&#30340;&#26102;&#20505;&#20135;&#29983;&#19968;&#20123;&#39069;&#22806;&#24320;&#38144;&#12290;&#21478;&#19968;&#26041;&#38754;&#65292;&#25805;&#32437;flyweight&#23545;&#35937;&#35201;&#26174;&#33879;&#24555;&#20110;&#23427;&#20204;&#25152;&#20195;&#34920;&#30340;
&#37325;&#22411;&#23545;&#35937;&#12290;&#25105;&#20204;&#23450;&#24615;&#22320;&#20998;&#26512;Boost.Flyweight&#22312;&#19981;&#21516;&#20351;&#29992;&#29615;&#22659;&#19979;&#36816;&#34892;&#26102;&#30340;&#39069;&#22806;&#24320;&#38144;&#25110;&#32773;&#25913;&#36827;&#12290;
</p>



<h3><a name="initialization">Initialization
&nbsp;&#21021;&#22987;&#21270;</a></h3>



<p>
As compared with the initialization an object of type <code>T</code>,
constructing
a <code>flyweight&lt;T&gt;</code> performs
important extra work like looking
up the value in the flyweight factory and inserting it if it is not
present.
So, construction of flyweights (other than copy construction, which is
cheap), is expected to be noticeably slower than the construction of
the
underlying type <code>T</code>. Much of the time spent at
constructing
the associated <code>T</code> value proper can be saved,
however, by
using <a href="tutorial/key_value.html">key-value
flyweights</a>.</p>



<p>&#19982;&#19968;&#20010;<code>T</code>&#31867;&#22411;<code></code>&#23545;&#35937;&#30340;&#21021;&#22987;&#21270;&#30456;&#27604;&#65292;&#26500;&#36896;&#19968;&#20010;<code>flyweight&lt;T&gt;</code>&#35201;&#25191;&#34892;&#37325;&#35201;&#30340;&#39069;&#22806;&#24037;&#20316;&#27604;&#22914;&#22312;
flyweight&#24037;&#21378;&#37324;&#26597;&#25214;&#20540;&#24182;&#19988;&#22312;&#23427;&#19981;&#23384;&#22312;&#30340;&#26102;&#20505;&#25554;&#20837;&#23427;&#12290;&#22240;&#27492;&#65292;flyweights&#30340;&#21019;&#24314;&#65288;&#24182;&#38750;&#25335;&#36125;&#26500;&#36896;&#65292;&#36825;&#35201;&#24265;&#20215;&#24471;&#22810;&#65289;&#65292;&#21487;&#20197;&#39044;&#35745;&#35201;&#26174;&#33879;&#24930;&#20110;&#24213;&#23618;&#31867;&#22411;T&#30340;&#26500;&#36896;&#12290;&#28982;&#32780;&#65292;&#36890;&#36807;&#20351;&#29992;<a href="tutorial/key_value.html">&#38190;-&#20540;flyweight</a>&#65292;&#35768;&#22810;&#33457;&#36153;&#22312;&#26500;&#36896;<code>T</code>&#20540;&#26412;&#36523;&#30340;&#26102;&#38388;&#26159;&#21487;&#20197;&#36991;&#20813;&#30340;&#12290;
</p>



<h3><a name="assignment">Assignment &nbsp;&#36171;&#20540;</a></h3>



<p>
Assignment of flyweight objects is extremely fast, as it only involves
assigning an internal handle type used to refer to the shared value.
Moreover,
assignment of <code>flyweight</code> objects never throws.
Assignment time
is influenced by the type of <a href="tutorial/configuration.html#tracking">tracking
policy</a> used; in this regard,
<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>
is the fastest option.</p>



<p>flyweight&#23545;&#35937;&#30340;&#36171;&#20540;&#26497;&#24555;&#65292;&#22240;&#20026;&#36825;&#21482;&#28041;&#21450;&#21040;&#36171;&#20540;&#19968;&#20010;&#24341;&#29992;&#21040;&#20849;&#20139;&#20540;&#30340;&#21477;&#26564;&#12290;&#27492;&#22806;&#65292;<code>flyweight</code>&#23545;&#35937;&#30340;&#36171;&#20540;&#32477;&#19981;&#20250;&#25243;&#20986;&#24322;
&#24120;&#12290;&#36171;&#20540;&#30340;&#26102;&#38388;&#21463;&#21040;<a href="tutorial/configuration.html#tracking">tracking policy</a>&#31867;&#22411;&#30340;&#24433;&#21709;&#65307;&#23601;&#36825;&#19968;&#28857;&#32780;&#35328;&#65292;<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>&#26159;&#26368;&#24555;&#30340;&#36873;&#39033;&#12290;
</p>



<h3><a name="equality_comparison">Equality
comparison &nbsp;&#21028;&#31561;</a></h3>



<p>
Comparing two <code>flyweight</code> objects for equality
reduces to
checking that the <i>addresses</i> of the values they are
associated to
are equal; in general, this operation is much faster than comparing the
underlying values. This aspect is of particular relevance when the
flyweight
objects stand for complex values like those arising in the application
of
the <a href="examples.html#example3"><i>composite
pattern</i></a>.</p>



<p>&#21028;&#26029;2&#20010;<code>flyweight</code>&#23545;&#35937;&#26159;&#21542;&#30456;&#31561;&#38477;&#20026;&#21028;&#26029;&#23427;&#20204;&#25152;&#20851;&#32852;&#30340;&#20540;&#30340;<span style="font-style: italic;">&#22320;&#22336;</span>&#26159;&#21542;&#30456;&#21516;&#65307;&#36890;&#24120;&#24773;&#20917;&#19979;&#65292;&#36825;&#20010;&#25805;&#20316;&#35201;&#36828;&#36828;&#24555;&#36807;&#27604;&#36739;&#24213;&#23618;&#30340;&#20540;&#12290;<span style="color: rgb(0, 0, 0);">&#24403;</span>flyweight<span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);">&#23545;&#35937;
&#20195;&#34920;&#30340;&#26159;&#37027;&#20123;&#20986;&#29616;&#22312;&#32452;&#21512;&#27169;&#24335;&#30340;&#24212;&#29992;&#31243;&#24207;&#30340;&#22797;&#26434;&#30340;&#20540;&#26102;</span></span><span style="color: rgb(0, 0, 0);">&#36825;&#20010;&#26041;&#38754;&#29305;&#21035;&#37325;&#35201;&#12290;</span>
</p>



<h3><a name="value_access">Value access &nbsp;&#20540;&#23384;&#21462;</a></h3>



<p>
The conversion from <code>flyweight&lt;T&gt;</code>
to <code>const T&amp;</code>
relies on a level of indirection relating the flyweight objects to the
values they are associated to; so, value access is expected to be
slower
when using Boost.Flyweight as compared to using the associated values
directly. This overhead, however, can be masked by an indirect
improvement
resulting from locality and cache effects: as the set of different <code>T</code>
values handled by an instantiation of <code>flyweight&lt;T&gt;</code>
is
generally much smaller than the equivalent family of <code>T</code>
objects
when Boost.Flyweight is not used, active values can fit better
into the processor cache.</p>



<p><span style="color: rgb(0, 0, 0);">&#20174;</span><code style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);">flyweight&lt;T&gt;</span></code><span style="color: rgb(0, 0, 0);">&#21040;</span><code style="color: rgb(0, 0, 0);">const T&amp;</code><span style="color: rgb(0, 0, 0);">&#30340;&#36716;&#25442;&#20381;&#36182;&#20110;&#19968;&#23618;&#38388;&#25509;&mdash;&mdash;&#20174;flyweight&#23545;&#35937;&#25214;&#21040;&#23427;&#20204;&#25152;&#20851;&#32852;&#30340;&#20540;&#65307;&#22240;&#27492;&#21487;&#20197;&#39044;&#35745;&#65292;&#24403;&#20351;&#29992;</span>Boost.Flyweight&#26102;&#65292;<span style="color: rgb(0, 0, 0);">&#20540;&#30340;</span><span style="color: rgb(0, 0, 0);">&#23384;&#21462;&#20250;&#27604;&#30452;&#25509;&#20351;&#29992;&#30456;&#20851;&#30340;&#20540;&#35201;&#24930;&#19968;&#20123;&#12290;&#28982;&#32780;&#65292;&#36825;&#31181;&#39069;&#22806;&#36127;&#25285;&#33021;&#22815;&#34987;&#30001;&#20110;&#38598;&#20013;&#21644;&#32531;&#23384;&#25928;&#26524;&#24102;&#26469;&#30340;&#38388;&#25509;&#25913;&#36827;&#25152;&#25513;&#30422;&#65306;&#22240;&#20026;</span><span style="color: rgb(0, 0, 0);">&#19968;&#20010;</span><code>flyweight&lt;T&gt;</code><span style="color: rgb(0, 0, 0);">&#30340;</span><span style="color: rgb(0, 0, 0);">&#23454;&#20363;&#31649;&#29702;&#30340;</span><span style="color: rgb(0, 0, 0);">&#19981;&#21516;</span><code>T</code><span style="color: rgb(0, 0, 0);">&#20540;&#30340;&#38598;&#21512;</span>&#36890;&#24120;&#35201;&#27604;&#27809;&#26377;&#20351;&#29992;Boost.Flyweight &#26102;&#31561;&#20215;&#30340;<code>T</code>&#23545;&#35937;&#30340;&#23478;&#26063;&#23567;&#24471;&#22810;&#65292;&#27963;&#21160;&#30340;&#20540;&#21487;&#20197;&#26356;&#22909;&#30340;&#36866;&#24212;&#22788;&#29702;&#22120;&#30340;&#32531;&#23384;&#12290;<span style="color: rgb(0, 0, 0);"></span>
</p>



<h2><a name="results">Experimental results
&nbsp;&#23454;&#39564;&#32467;&#26524;</a></h2>



<p>
A <a href="examples.html#example6">profiling program</a>
was devised to test
the space and time efficiency of different instantiations of <code>flyweight</code>
against a base situation not using Boost.Flyweight. The profiled
scenarios are:</p>



<p>&#35774;&#35745;&#20102;&#19968;&#20010;<a href="examples.html#example6">&#20998;&#26512;&#31243;&#24207;</a>&#20197;&#19981;&#20351;&#29992;Boost.Flyweight&#30340;&#24773;&#20917;&#20316;&#20026;&#22522;&#25968;&#26469;&#23545;&#27604;&#27979;&#35797;&#19981;&#21516;<code>flyweight</code>&#23454;&#20363;&#30340;&#31354;&#38388;&#21644;&#26102;&#38388;&#25928;&#29575;&#12290;&#36825;&#20123;&#20998;&#26512;&#22330;&#26223;&#26159;&#65306;</p>



<ol>



  <li><code>std::string</code>.</li>



  <li><code>flyweight&lt;std::string&gt;</code>
with default configuration aspects (<a href="tutorial/configuration.html#hashed_factory"><code>hashed_factory</code></a>,
    <a href="tutorial/configuration.html#refcounted"><code>refcounted</code></a>
tracking, <a href="tutorial/configuration.html#simple_locking"><code>simple_locking</code></a>).
  </li>



  <li><code>flyweight&lt;std::string,<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>&gt;</code>.</li>



  <li><code>flyweight&lt;std::string,<a href="tutorial/configuration.html#set_factory"><code>set_factory</code></a>&gt;</code>.</li>



  <li><code>flyweight&lt;std::string,<a href="tutorial/configuration.html#set_factory"><code>set_factory</code></a>,<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>&gt;</code>.</li>



</ol>



<p>
Actually the types tested are not exactly those listed above, but
instrumented
versions that keep track of the allocated memory for profiling
purposes.
The program parses a text file into an array of words and then perform
various
manipulations involving the different context usages of Boost.Flyweight
discussed
<a href="#time">previously</a>. As our text file we
have used the
<a href="http://www.gutenberg.org/dirs/etext99/2donq10.txt">plain
text</a>
version of Project Gutenberg edition of <a href="http://www.gutenberg.org/etext/2000"><i>Don
Quijote</i></a> (2.04 MB).</p>
<p>&#23454;&#38469;&#27979;&#35797;&#30340;&#31867;&#22411;&#21644;&#19978;&#38754;&#21015;&#20986;&#26469;&#30340;&#19981;&#23436;&#20840;&#19968;&#33268;&#65292;&#32780;&#26159;&#20462;&#25913;&#21518;&#30340;&#21487;&#20197;&#36319;&#36394;&#20869;&#23384;&#20998;&#37197;&#30340;&#29256;&#26412;&#29992;&#20197;&#20998;&#26512;&#12290;&#35813;&#31243;&#24207;&#20998;&#26512;&#19968;&#20010;&#25991;&#26412;&#25991;&#20214;&#24182;&#23558;&#32467;&#26524;&#20445;&#23384;&#22312;&#19968;&#20010;&#21333;&#35789;&#25968;&#32452;&#37324;&#28982;&#21518;&#36827;&#34892;&#21508;&#31181;&#25805;&#20316;&#65292;&#28041;&#21450;&#21040;&#21069;&#38754;&#35752;&#35770;&#30340;Boost.Flyweight&#30340;&#21508;&#31181;&#20351;&#29992;&#29615;&#22659;&#12290;&#25105;&#20204;&#20351;&#29992;<i><a href="http://www.gutenberg.org/etext/2000"><i>Don
Quijote</i></a></i>&#30340;Project Gutenberg&#29256;&#26412;&#30340;<a href="http://www.gutenberg.org/dirs/etext99/2donq10.txt">&#32431;&#25991;&#26412;</a>&#26684;&#24335;&#20316;&#20026;&#25105;&#20204;&#30340;&#25991;&#26412;&#25991;&#20214;&#12290;
</p>



<h3><a name="msvc_80">Microsoft Visual C++ 8.0</a></h3>



<p>
The program was built with default release settings and <code>_SECURE_SCL=0</code>.
Tests were run under Windows XP in a machine equipped with an Intel
Core 2 Duo T5500
processor and 1 GB of RAM.</p>



<p>&#31243;&#24207;&#20351;&#29992;&#40664;&#35748;&#30340;release&#35774;&#32622;&#32534;&#35793;&#65292;&#24182;&#19988;&#35774;&#32622;<code>_SECURE_SCL</code>&#36873;&#39033;&#20026;0&#12290;&#27979;&#35797;&#31243;&#24207;&#36816;&#34892;&#22312;&#19968;&#21488;&#37197;&#22791;&#20102;Intel
Core 2 Duo T5500&#21644;1GB&#20869;&#23384;&#30340;Windwos&nbsp;XP&#26426;&#22120;&#19978;&#12290;
</p>



<h4><a name="msvc_80_memory">Memory &nbsp;&#20869;&#23384;</a></h4>



<p align="center">
<img src="memory_msvc_80.png" alt="memory consumption (MB), MSVC++ 8.0" height="322" width="798"><br>



<b>Fig. 2: Memory consumption, MSVC++ 8.0. Values in MB.</b>
</p>



<p>
The results show the memory consumption figures for the different
profiled
scenarios.
The standard library implementation of MSVC++ 8.0 features the
so-called
small buffer optimization for strings, by which <code>std::string</code>
objects hold a small buffer that can be used when the string is short,
thus avoding dynamic allocations. This results in <code>sizeof(std::string)</code>
being quite high, 28 bytes. In our particular test strings are almost
always
held in the small buffer, so the minimum <a href="#overall_memory"><i>S<sub>F</sub></i>
/ <i>S</i></a>
achievable is 4/28 = 14.3%, which is quite close to the experimental
results, given that the memory devoted to storage of shared values
is residual (around 3% of total memory) due to the high word redundancy
of the text source.</p>



<p>&#36825;&#20010;&#32467;&#26524;&#26174;&#31034;&#20102;&#19981;&#21516;&#30340;&#20998;&#26512;&#22330;&#26223;&#19979;&#20869;&#23384;&#28040;&#32791;&#25351;&#26631;&#12290;MSVC++8.0&#30340;&#26631;&#20934;&#24211;&#23454;&#29616;&#20102;&#19968;&#20010;&#25152;&#35859;&#30340;&#38024;&#23545;&#23383;&#31526;&#20018;&#30340;&#23567;&#32531;&#20914;&#21306;&#20248;&#21270;&#65292;&#24403;&#23383;&#31526;&#20018;&#36739;&#30701;&#30340;&#26102;&#20505;&#21487;&#20197;&#30452;&#25509;&#23384;&#20648;&#22312;<code>std::string</code>&#33258;&#24102;&#30340;&#36825;&#20010;&#23567;&#32531;&#20914;&#21306;&#37324;&#65292;&#20110;&#26159;&#36991;&#20813;&#20102;&#21160;&#24577;&#20998;&#37197;&#12290;&#36825;&#23548;&#33268;<code>sizeof(std::string)</code>&#30456;&#24403;&#39640;&#65292;&#26377;28&#20010;&#23383;&#33410;&#12290;&#22312;&#25105;&#20204;&#36825;&#20010;&#27979;&#35797;&#37324;&#23383;&#31526;&#20018;&#20960;&#20046;&#24635;&#26159;&#23384;&#20648;&#22312;&#36825;&#20010;&#23567;&#30340;&#32531;&#20914;&#21306;&#37324;&#65292;&#22240;&#27492;<a href="performance.html#overall_memory"><i>S<sub>F</sub></i>
/ <i>S</i></a>&#21487;&#20197;&#36798;&#22240;&#27492;&#21040;&#30340;&#26368;&#23567;&#20540;&#26159;4/28 = 14.3%&#65292;&#36825;&#36319;&#23454;&#39564;&#32467;&#26524;&#30456;&#24403;&#25509;&#36817;&#20102;&#65292;&#30001;&#20110;&#21407;&#25991;&#20013;&#21333;&#35789;&#39640;&#24230;&#30340;&#20887;&#20313;&#65292;&#29992;&#26469;&#23384;&#20648;&#20849;&#20139;&#20540;&#30340;&#20869;&#23384;&#19981;&#20540;&#19968;&#25552;&#65288;&#22823;&#27010;&#21344;&#24635;&#20869;&#23384;&#30340;3%&#65289;&#12290;
</p>



<h4><a name="msvc_80_time">Execution time
&nbsp;&#25191;&#34892;&#26102;&#38388;</a></h4>



<p align="center">
<img src="time_msvc_80.png" alt="execution time (s), MSVC++ 8.0" height="324" width="820"><br>



<b>Fig. 3: Execution time, MSVC++ 8.0. Values in seconds.</b>
</p>



<p>
The figure displays execution times for the profiled scenarios in
different
usage contexts. In accordance with our previous
<a href="#time">qualitative analysis</a>,
initialization of <code>flyweight</code>s
carries an important overhead with respect to the base case scenario
(between 10% and 40%
of additional execution time), while the other usage contexts
(assignment, equality comparison and value access) have performance
gains,
with speedup factors of up to 14 in some cases. The use of a <a href="tutorial/configuration.html#refcounted"><code>refcounted</code></a>
tracking policy introduces penalties with respect to
<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>
in initialization and assignment, but has no effect in equality
comparison
and value access.</p>



<p>&#36825;&#24133;&#22270;&#26174;&#31034;&#20102;&#19981;&#21516;&#30340;&#20998;&#26512;&#22330;&#26223;&#22312;&#21508;&#31181;&#20351;&#29992;&#29615;&#22659;&#19979;&#30340;&#25191;&#34892;&#26102;&#38388;&#12290;&#19982;&#25105;&#20204;&#20043;&#21069;&#30340;<a href="#time">&#23450;&#24615;&#20998;&#26512;</a>&#19968;&#33268;&#65292;&#19982;&#27604;&#36739;&#22522;&#25968;&#30456;&#27604;<code>flyweight</code>s&#30340;&#21021;&#22987;&#21270;&#26377;&#19968;&#20010;&#26126;&#26174;&#30340;&#39069;&#22806;&#24320;&#38144;&#65288;10% &#21040; 40%&#30340;&#39069;&#22806;&#25191;&#34892;&#26102;&#38388;&#19981;&#31561; &#65289;&#65292;&#28982;&#32780;&#20854;&#23427;&#30340;&#20351;&#29992;&#29615;&#22659;&#19979;&#65288;&#36171;&#20540;&#65292;&#21028;&#31561;&#21644;&#20540;&#23384;&#21462;&#65289;&#33719;&#24471;&#20102;&#24615;&#33021;&#30340;&#25552;&#21319;&#65292;&#22312;&#26576;&#20123;&#24773;&#20917;&#19979;&#21152;&#36895;&#31995;&#25968;&#39640;&#36798;14&#12290;&#19982;<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>&#36319;&#36394;&#31574;&#30053;&#30456;&#27604;<a href="tutorial/configuration.html#refcounted"><code>refcounted</code></a>&#36319;&#36394;&#31574;&#30053;&#22312;&#21021;&#22987;&#21270;&#21644;&#36171;&#20540;&#26102;&#24615;&#33021;&#26377;&#25152;&#19979;&#38477;&#65292;&#20294;&#26159;&#22312;&#21028;&#31561;&#21644;&#20540;&#23384;&#21462;&#26041;&#38754;&#27809;&#26377;&#20160;&#20040;&#21306;&#21035;&#12290;
</p>



<h3><a name="gcc_344">GNU GCC 3.4.4</a></h3>



<p>
The Cygwin/MinGW version of the compiler was used, with command options
<code>-ftemplate-depth-128 -O3 -finline-functions -DNDEBUG</code>.
Tests were run under a Cygwin terminal in the same machine as <a href="#msvc_80">before</a>.</p>
<p>&#20351;&#29992;&#30340;&#26159;Cygwin/MinGW&#37324;&#30340;&#29256;&#26412;&#65292;&#24102;&#26377;<code>-ftemplate-depth-128 -O3 -finline-functions -DNDEBUG</code>&#36873;&#39033;<code>&#12290;</code>&nbsp;&#27979;&#35797;&#31243;&#24207;&#36816;&#34892;&#30340;Cygwin&#32456;&#31471;&#21644;<a href="#msvc_80">&#20043;&#21069;</a>&#30340;&#27979;&#35797;&#22312;&#21516;&#19968;&#21488;&#26426;&#22120;&#19978;&#12290;</p>



<h4><a name="gcc_344_memory">Memory</a></h4>



<p align="center">
<img src="memory_gcc_344.png" alt="memory consumption (MB), GCC 3.4.4" height="322" width="798"><br>



<b>Fig. 4: Memory consumption, GCC 3.4.4. Values in MB.</b>
</p>



<p>
The standard library used by GCC 3.4.4 implements <code>std::string</code>
using <a href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>
optimization techniques, which leads to very small value redundancy for
some usage patterns. This explains why the memory reduction achieved
by Boost.Flyweight is so poor in this case. Other contexts where
assignment
is much less used than direct construction will favor Boost.Flyweight
over plain copy-on-write <code>std::string</code>s.</p>

<p>GCC 3.4.4&#20351;&#29992;&#30340;&#26631;&#20934;&#24211;&#23454;&#29616;<code>std::string</code>&#26102;&#20351;&#29992;&#20102;<a href="http://en.wikipedia.org/wiki/Copy-on-write">&#20889;&#25335;&#36125;</a>&#20248;&#21270;&#25216;&#26415;&#65292;&#23548;&#33268;&#22312;&#26576;&#20123;&#20351;&#29992;&#26041;&#24335;&#19979;&#20887;&#20313;&#30340;&#20540;&#38750;&#24120;&#23569;&#12290;&#36825;&#35299;&#37322;&#20102;&#20026;&#20160;&#20040;&#22312;&#36825;&#31181;&#26465;&#20214;&#19979;&#20351;&#29992;Boost.Flyweight&#25152;&#20943;&#23569;&#30340;&#20869;&#23384;&#23569;&#30340;&#21487;&#24604;&#12290;&#22312;&#37027;&#20123;&#26356;&#22810;&#30340;&#37319;&#29992;&#30452;&#25509;&#26500;&#36896;&#32780;&#38750;&#36171;&#20540;&#30340;&#20351;&#29992;&#29615;&#22659;&#19979;&#65292;Boost.Flyweight&#30340;&#34920;&#29616;&#20248;&#20110;&#26222;&#36890;&#30340;&#20889;&#25335;&#36125;<code>std::string</code>s&#12290;
</p>



<h4><a name="gcc_344_time">Execution time &nbsp;&#25191;&#34892;&#26102;&#38388;</a></h4>



<p align="center">
<img src="time_gcc_344.png" alt="execution time (s), GCC 3.4.4" height="324" width="820"><br>



<b>Fig. 5: Execution time, GCC 3.4.4. Values in seconds.</b>
</p>



<p>
Relative performance figures are similar to those obtained for
<a href="#msvc_80_time">MSVC++ 8.0</a>, although
some of the
speedups achieved by Boost.Flyweight are higher here (&times;25
in equality comparison and up to &times;100 in assignment when
<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>
is in effect).</p>

<p>&#30456;&#20851;&#30340;&#24615;&#33021;&#25351;&#26631;&#19982;<a href="performance.html#msvc_80_time">MSVC++ 8.0</a>&#30340;&#32467;&#26524;&#31867;&#20284;&#65292; &#28982;&#32780;&#36825;&#27425;&#26576;&#20123;&#20351;&#29992;Boost.Flyweight&#33719;&#24471;&#30340;&#21152;&#36895;&#25928;&#26524;&#26356;&#39640;&#65288;&#21028;&#31561;&#26102;&#25552;&#39640;&#20102;25&#20493;&#24403;&#20351;&#29992;<a href="tutorial/configuration.html#no_tracking"><code>no_tracking</code></a>&#26102;&#36171;&#20540;&#25552;&#39640;&#20102;100&#20493;&#65289;&#12290;
</p>



<h2><a name="conclusions">Conclusions &nbsp;&#32467;&#35770;</a></h2>



<p>
The introduction of Boost.Flyweight in application scenarios with very
high value redundancy yields important reductions in memory
consumption:
this is especially relevant when data volume approaches the limits of
physical memory in the machine, since Boost.Flyweight can avoid virtual
memory thrashing thus making the application viable. We have shown
how to estimate the achievable reduction in memory consumption from
some basic value statistics and knowledge of the <code>flyweight</code>
configuration aspects being used.</p>

<p>&#22312;&#20540;&#20887;&#20313;&#38750;&#24120;&#39640;&#30340;&#24212;&#29992;&#22330;&#21512;&#20351;&#29992;Boost.Flyweight&#21487;&#20197;&#26174;&#33879;&#20943;&#23569;&#20869;&#23384;&#29992;&#37327;&#65306;&#23588;&#20854;&#26159;&#24403;&#25968;&#25454;&#37327;&#36798;&#21040;&#26426;&#22120;&#29289;&#29702;&#20869;&#23384;&#38480;&#21046;&#30340;&#26102;&#20505;&#65292;&#22240;&#20026;
Boost.Flyweight&#21487;&#20197;&#36991;&#20813;&#34394;&#25311;&#20869;&#23384;&#38663;&#33633;&#20110;&#26159;&#35753;&#24212;&#29992;&#31243;&#24207;&#21487;&#29992;&#24615;&#26356;&#24378;&#12290;&#25105;&#20204;&#24050;&#32463;&#28436;&#31034;&#20102;&#24590;&#26679;&#35780;&#20272;&#21487;&#20197;&#20943;&#23569;&#30340;&#20869;&#23384;&#29992;&#37327;&#65292;&#36890;&#36807;&#19968;&#20123;&#22522;&#26412;&#30340;<span class="wbtr_mn">&#32479;&#35745;&#25968;&#23383;</span>&#21644;&#20351;&#29992;&#21040;&#37197;
&#32622;&#30340;<code>flyweight</code>&#36873;&#39033;&#30693;&#35782;&#12290;
</p>



<p>
Boost.Flyweight can also accelerate execution times in areas other than
object initialization, due to the fastest manipulation of small
flyweight objects and to locality and cache effects arising from the
drastic reduction of the set of allocated values.</p>

<p>
Boost.Flyweight&#21487;&#20197;&#21152;&#36895;&#38500;&#20102;&#23545;&#35937;&#21021;&#22987;&#21270;&#20197;&#22806;&#30340;&#25191;&#34892;&#36895;&#24230;&#65292;&#22240;&#20026;&#25805;&#32437;&#23567;&#22411;&#30340;flyweight&#23545;&#35937;&#24456;&#24555;&#65292;&#36824;&#26377;&#22240;&#20026;&#25152;&#20998;&#37197;&#30340;&#20540;&#30340;&#38598;&#21512;&#24613;&#21095;&#20943;&#23569;&#24102;&#26469;&#30340;&#38598;&#20013;&#21644;&#32531;&#23384;&#25928;&#26524;&#12290;
</p>



<hr>
<div class="prev_link"><a href="reference/tracking.html"><img src="prev.gif" alt="tracking policies" border="0"><br>



Tracking policies
</a></div>



<div class="up_link"><a href="index.html"><img src="up.gif" alt="index" border="0"><br>



Index
</a></div>



<div class="next_link"><a href="examples.html"><img src="next.gif" alt="examples" border="0"><br>



Examples
</a></div>



<br style="" clear="all">



<br style="" clear="all">



<br>



<p>Revised December 2nd 2008</p>



<p>&copy; Copyright 2006-2008 Joaqu&iacute;n M
L&oacute;pez Mu&ntilde;oz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>



</body>
</html>

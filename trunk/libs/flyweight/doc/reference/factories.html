<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Boost.Flyweight Documentation - Factories reference</title>


  <link rel="stylesheet" href="../style.css" type="text/css">

  <link rel="start" href="../index.html">

  <link rel="prev" href="tags.html">

  <link rel="up" href="index.html">

  <link rel="next" href="holders.html">

</head>

<body>

<h1><img src="../../../../boost.png" alt="Boost logo" align="middle" height="86" width="277">Boost.Flyweight
Factories reference</h1>

<div class="prev_link"><a href="tags.html"><img src="../prev.gif" alt="tags" border="0"><br>

Tags
</a></div>

<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight reference" border="0"><br>

Boost.Flyweight reference
</a></div>

<div class="next_link"><a href="holders.html"><img src="../next.gif" alt="holders" border="0"><br>

Holders
</a></div>

<br style="" clear="all">

<hr>
<h2>Contents &nbsp;目录</h2>

<ul>

  <li><a href="#factory">Factories and factory
specifiers &nbsp;工厂和工厂描述符</a></li>

  <li><a href="#factory_tag_synopsis">Header <code>"boost/flyweight/factory_tag.hpp"</code>
synopsis &nbsp;头文件"boost/flyweight/factory_tag.hpp"大意</a>
    <ul>

      <li><a href="#is_factory">Class template <code>is_factory
&nbsp;类模板 is_factory</code></a></li>

      <li><a href="#factory_construct">Class
template <code>factory &nbsp;类模板 factory</code></a></li>

    </ul>

  </li>

  <li><a href="#hashed_factory_fwd_synopsis">Header <code>"boost/flyweight/hashed_factory_fwd.hpp"</code>
synopsis &nbsp;头文件"boost/flyweight/hashed_factory_fwd.hpp"大意</a>
  </li>

  <li><a href="#hashed_factory_synopsis">Header <code>"boost/flyweight/hashed_factory.hpp"</code>
synopsis &nbsp;头文件"boost/flyweight/hashed_factory.hpp"大意</a>
    <ul>

      <li><a href="#hashed_factory_class">Class
template <code>hashed_factory_class &nbsp;类模板
hashed_factory_class</code></a></li>

      <li><a href="#hashed_factory">Class template <code>hashed_factory
类模板&nbsp; hashed_factory&nbsp;</code></a></li>

    </ul>

  </li>

  <li><a href="#set_factory_fwd_synopsis">Header <code>"boost/flyweight/set_factory_fwd.hpp"</code>
synopsis &nbsp;头文件"boost/flyweight/set_factory_fwd.hpp"大意</a>
  </li>

  <li><a href="#set_factory_synopsis">Header <code>"boost/flyweight/set_factory.hpp"</code>
synopsis &nbsp;头文件"boost/flyweight/set_factory.hpp"大意</a>
    <ul>

      <li><a href="#set_factory_class">Class
template <code>set_factory_class &nbsp;类模板 set_factory_class</code></a></li>

      <li><a href="#set_factory">Class template <code>set_factory
&nbsp;类模板 set_factory</code></a></li>

    </ul>

  </li>

  <li><a href="#assoc_container_factory_fwd_synopsis">Header
    <code>"boost/flyweight/assoc_container_factory_fwd.hpp"</code>
synopsis
&nbsp;头文件"boost/flyweight/assoc_container_factory_fwd.hpp"大意</a>
  </li>

  <li><a href="#assoc_container_factory_synopsis">Header
    <code>"boost/flyweight/assoc_container_factory.hpp"</code>
synopsis &nbsp;头文件"boost/flyweight/assoc_container_factory.hpp"大意</a>
    <ul>

      <li><a href="#assoc_container_factory_class">Class
template <code>assoc_container_factory_class
&nbsp;类模板&nbsp; assoc_container_factory_class</code></a></li>

      <li><a href="#assoc_container_factory">Class
template <code>assoc_container_factory &nbsp;类模板&nbsp;
assoc_container_factory</code></a></li>

    </ul>

  </li>

</ul>

<h2><a name="factory">Factories and factory
specifiers &nbsp;工厂和工厂描述符</a></h2>

<p>
Given a type <code>Key</code> and an
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>
type <code>Entry</code> implicitly convertible to <code>const
Key&amp;</code>, a
<i>factory of <code>Entry</code> elements</i>
(implicitly associated to
<code>Key</code>) is a
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a> entity able to store and retrieve
immutable elements of
type <code>Entry</code>. A factory is governed by an
associated equivalence
relation defined on <code>Key</code> so that no two
<code>Entry</code> objects convertible to equivalent <code>Key</code>s
can be stored simultaneously in the factory. Different factory types
can
use different equivalence relations.</p>

<p>给定一个<big><code>Key</code></big>类型和一个<a href="http://www.sgi.com/tech/stl/Assignable.html">可赋值</a>可
隐式转换成<big><code>const Key&amp;</code></big>的<big><code>Entry</code></big>类
型，一<big>个<i><code>Entry</code></i></big>（隐
含关联到<big><code>Key</code></big>）<i><code></code>元
素的工厂</i>是一个可默认构造的实体，它可以存取不可变的<big><code>Entry</code></big>类
型的元素。一
个工厂受定义在<big><code>Key</code></big>上的相等关系支配，2个可以转
换到相同<big><code>Key</code>s</big>的<big><code>Entry</code></big>对
象不能同时存储在工厂里。不同的工厂类型可以使用不同的相等关系。
</p>

<p>
In the following table, <code>Factory</code> is a factory
of elements
of type <code>Entry</code>, <code>f</code>
denotes an object of type <code>Factory</code>,
<code>x</code> is an object of type <code>Entry</code>
and <code>h</code> is a
value of <code>Factory::handle_type</code>.
</p>

<p style="text-align: left;">
在下面这个表格里，<big><code>Factory</code></big>是一个<big><code>Entry</code></big>类
型元素的工厂，<big><code>f</code></big>代表一个<big><code>Factory</code></big>类
型的
对象，<big><code>x</code></big>是一个<big><code>Entry</code></big>类
型的对象而<big><code>h</code></big>是<big><code>Factory::handle_type</code></big>类
型的值。</p>

<table cellspacing="0">

  <caption><b>Factory requirements.</b></caption>
  <tbody>

    <tr>

      <th align="center">expression</th>

      <th align="center">return type</th>

      <th align="center">assertion/note<br>

pre/post-condition</th>

    </tr>

    <tr>

      <td><code>Factory::handle_type</code></td>

      <td>handle to elements of type <code>T</code><br>

stored in the factory </td>

      <td><code>handle_type</code> is <a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>
and its copy and<br>

assignment operations never throw an exception.<br>

      <code>handle_type</code>是<a href="http://www.sgi.com/tech/stl/Assignable.html">可赋值的</a>而
且它的拷贝和赋<br>

值操作绝不会抛出异常 </td>

    </tr>

    <tr class="odd_tr">

      <td><code>f.insert(x);</code></td>

      <td><code>handle_type</code></td>

      <td>Inserts a copy of <code>x</code> if there
is no equivalent entry in <code>f</code>;<br>

returns a handle to the inserted or equivalent element.<br>

如果<code>f</code>里没有相等的entry插入一个<code>x</code>的拷
贝；返<br>

回一个到插入的或者相等的元素的句柄 </td>

    </tr>

    <tr>

      <td><code>f.erase(h);</code></td>

      <td><code>void</code></td>

      <td>Erases the element associated to <code>h</code>.<br>

This operation does not throw.<br>

清除关联到<code>h</code>的元素。这个操作不抛出异常 </td>

    </tr>

    <tr class="odd_tr">

      <td><code>f.entry(h);</code></td>

      <td><code>const Entry&amp;</code></td>

      <td>Returns a reference to the element associated to <code>h</code>.<br>

This operation does not throw.<br>

返回关联到<code>h</code>的元素的引用。这个操作不抛出异常 </td>

    </tr>

  </tbody>
</table>

<p>
Additionally to the basic thread safety guarantee which is implicitly
assumed
for most classes including the majority of components of the
C++ standard library, it is required that the member function <code>entry</code>
can be invoked simultaneously from different threads, even in the
presence
of concurrent accesses to <code>insert</code> and <code>erase</code>
(as long
as the entry returned by <code>entry</code> is not the one
which is being
erased).</p>

<p>除开大多数类型包括C++标准库的大部分组件隐含假设的基本线程安全保证以外，还要求成员函数<big><code>entry</code></big>可
以同时从不同的线程里调用，即使是在并发的访问<big><code>insert</code></big>和<big><code>erase</code></big>的
情况下（只要<big><code>entry</code></big>函数返回的entry不是正
在被清除的那个）。
</p>

<p>
A type <code>S</code> is said to be a <i>factory
specifier</i> if: &nbsp;一个类型<code>S</code>被称为是一个<span style="font-style: italic;">工厂描述符</span>如果：
</p>

<ol>

  <li>One of the following conditions is satisfied:
&nbsp;满足以下条件之一：
    <ol type="a">

      <li><a href="#is_factory"><code>is_factory&lt;S&gt;::type</code></a>
is <a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a>,
&nbsp;<a href="factories.html#is_factory"><code>is_factory&lt;S&gt;::type</code></a>
是 <a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a></li>

      <li><code>S</code> is of the form <a href="#factory_construct"><code>factory&lt;S'&gt;</code></a>.
        <code>S</code>的格式是<a href="factories.html#factory_construct"><code>factory&lt;S'&gt;</code></a></li>

    </ol>

  </li>

  <li><code>S</code>, or <code>S'</code>
if (b) applies, is an <a href="../../../mpl/doc/refmanual/lambda-expression.html"><code>MPL
Lambda Expression</code></a> such that invoking it with
types (<code>Entry</code>, <code>Key</code>)
resolves to a factory type of <code>Entry</code> elements
(implicitly associated to <code>Key</code>).</li>

</ol>

<div style="margin-left: 40px;"><code>S</code>，
或者<code>S'</code>如果条件b适用，是一个<a href="../../../mpl/doc/refmanual/lambda-expression.html"><code><big>MPL
Lambda</big> <big>表达式</big></code></a>，当用
类型（<big><code>Entry，</code>
<code>Key</code></big>）调用时生成一个<big><code>Entry</code></big>元
素（隐含关
联到<big><code>Key</code></big>）的工厂类型。</div>

<h2><a name="factory_tag_synopsis">Header
</a><a href="../../../../boost/flyweight/factory_tag.hpp"><code>"boost/flyweight/factory_tag.hpp"</code></a>
synopsis &nbsp;</h2>

<h2>头文件<a href="file:///boost/flyweight/factory_tag.hpp"><code>"boost/flyweight/factory_tag.hpp"</code></a>大
意</h2>

<blockquote>
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">struct</span> <span class="identifier">factory_marker</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">is_factory</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><span class="special">}</span> <span class="comment">// namespace boost</span> </pre>

</blockquote>

<h3><a name="is_factory">Class template <code>is_factory
&nbsp;类模板 is_factory</code></a></h3>

<p>
Unless specialized by the user, <code>is_factory&lt;T&gt;::type</code>
is
<a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a>
if <code>T</code> is derived from <code>factory_marker</code>,
and it is
<a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::false_</code></a>
otherwise.</p>

<p>除非用户进行专门化，如果<big><code>T</code></big>是从<big><code>factory_marker</code></big>派
生的，<big><code>is_factory&lt;T&gt;::type</code></big>是<big><a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::true_</code></a></big>，
否则是<big><a href="../../../mpl/doc/refmanual/bool.html"><code>boost::mpl::false_</code></a></big>。<a href="../../../mpl/doc/refmanual/bool.html"><code></code></a>
</p>

<h3><a name="factory_construct">Class template <code>factory
&nbsp;类模板 factory</code></a></h3>

<p>
<code>factory&lt;T&gt;</code> is a syntactic
construct meant to indicate
that <code>T</code> is a factory specifier without
resorting to the
mechanisms provided by the <code>is_factory</code> class
template.</p>

<p><big><code>factory&lt;T&gt;</code></big>是
一种表明<code>T</code>是
一个工厂描述符的语法构造，这样就不需要借助于<big><code>is_factory</code></big>类
模板提供的机制。
</p>

<h2><a name="hashed_factory_fwd_synopsis">Header
</a><a href="../../../../boost/flyweight/hashed_factory_fwd.hpp"><code>"boost/flyweight/hashed_factory_fwd.hpp"</code></a>
synopsis &nbsp;</h2>

<h2>头文件<a href="file:///boost/flyweight/hashed_factory_fwd.hpp"><code>"boost/flyweight/hashed_factory_fwd.hpp"</code></a>大
意</h2>

<blockquote>
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Hash</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Pred</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">hashed_factory_class</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Hash</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp;&nbsp;typename</span> <span class="identifier">Pred</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">hashed_factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><br><span class="special">}</span> <span class="comment">// namespace boost</span> </pre>

</blockquote>

<p>
<code>hashed_factory_fwd.hpp</code> forward declares the
class templates
<a href="#hashed_factory_class"><code>hashed_factory_class</code></a>
and <a href="#hashed_factory"><code>hashed_factory</code></a>.</p>

<p><big><code>hashed_factory_fwd.hpp</code></big>前
向声明了类模板<big><a href="factories.html#hashed_factory_class"><code>hashed_factory_class</code></a></big>和<big><a href="factories.html#hashed_factory"><code>hashed_factory</code></a></big>
</p>

<h2><a name="hashed_factory_synopsis">Header
</a><a href="../../../../boost/flyweight/hashed_factory.hpp"><code>"boost/flyweight/hashed_factory.hpp"</code></a>
synopsis &nbsp;</h2>

<h2>头文件<a href="file:///boost/flyweight/hashed_factory.hpp"><code>"boost/flyweight/hashed_factory.hpp"</code></a>大
意</h2>

<h3><a name="hashed_factory_class">Class template <code>hashed_factory_class
&nbsp;类模板 hashed_factory_class</code></a></h3>

<p>
<code>hashed_factory_class</code> is a <a href="#factory"><code>Factory</code></a>
implemented with a hashed container.</p>

<p><big><code>hashed_factory_class</code></big>是
一个用哈希容器实现的<a href="#factory">工厂</a>
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Hash</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Pred</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">hashed_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <b>implementation defined</b> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span> </pre>

</blockquote>

<p>
<code>Hash</code> is a
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a>
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary
Function</code></a>
taking a single argument of type <code>Key</code> and
returning a
value of type <code>std::size_t</code> in the range
<code>[0, std::numeric_limits&lt;std::size_t&gt;::max())</code>.
<code>Pred</code> is a
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a> <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
<code>Binary Predicate</code></a> inducing an
equivalence relation
on elements of <code>Key</code>. It is required that
a <code>Hash</code> object return the same value for
objects
equivalent under <code>Pred</code>.
The equivalence relation on <code>Key</code> associated to
the factory is
that induced by <code>Pred</code>.
The default arguments for <code>Hash</code> and <code>Pred</code>
are
<a href="../../../functional/hash/index.html"><code>boost::hash&lt;Key&gt;</code></a>
and <code>std::equal_to&lt;Key&gt;</code>,
respectively. <code>Allocator</code> must be an allocator
of <code>Entry</code> objects
satisfying the associated C++ requirements at <b>[lib.allocator.requirements]</b>.
The default argument is <code>std::allocator&lt;Entry&gt;</code>.
The internal
hashed container upon which <code>hashed_factory_class</code>
is based is
constructed with default initialized objects of type <code>Hash</code>,
<code>Pred</code> and <code>Allocator</code>.</p>

<p><big><code>Hash</code></big>是一个<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">可
默认构造</a>的<a href="http://www.sgi.com/tech/stl/UnaryFunction.html">一元函数</a>，
带一个<big><code>Key</code></big>类型的参数返回一个<big><code>[0,
std::numeric_limits&lt;std::size_t&gt;::max())</code></big>范
围的<big><code>std::size_t</code></big>类型的值。<big><code>Pred</code></big>是
一个可默认构造的二元谓词判断<big><code>Key</code></big>元素的相等关
系。要求对于使用<big><code>Pred</code></big>判断相等的对象<big><code>Hash</code></big>对
象返回相同的值。与工厂相关的<big><code>Key</code></big>上的相等关系是
由<big><code>Pred</code></big>得
出。<big><code>Hash</code></big>和<big><code>Pred</code></big>的
默认参数分别是<big><a href="../../../functional/hash/index.html"><code>boost::hash&lt;Key&gt;</code></a></big>
和 <code><big>std::equal_to&lt;Key&gt;</big></code>。<big><code>Allocator</code></big>必
须是满足C++标准<b>[lib.allocator.requirements]</b>中的相关要求的<big><code>Entry</code></big>对
象的分配器。默认的参数是<big><code>std::allocator&lt;Entry&gt;</code><code></code></big>。<big><code>hashed_factory_class</code></big>基
于的内部哈希容器是用<big><code>Hash</code></big>，<big><code>Pred</code></big>
和
<big><code>Allocator</code></big>类型的默认初始化对象创建的。
</p>

<h3><a name="hashed_factory">Class template <code>hashed_factory
&nbsp;类模板 &nbsp;hashed_factory</code></a></h3>

<p>
<a href="#factory"><code>Factory Specifier</code></a>
for <a href="#hashed_factory_class"><code>hashed_factory_class</code></a>.</p>

<p><big><a href="factories.html#hashed_factory_class"><code>hashed_factory_class</code></a></big>的<a href="#factory">工厂描述符</a>
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Hash</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Pred</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">hashed_factory</span><span class="special">;</span> </pre>

</blockquote>

<p>
<code>hashed_factory&lt;Hash,Pred,Allocator&gt;</code>
is an
<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL
Metafunction
Class</code></a> such that the type</p>

<p><big><code>hashed_factory&lt;Hash,Pred,Allocator&gt;</code></big>是
一个<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL
<big>元函数类</big></code></a>，于是类型
</p>

<blockquote>
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier"> hashed_factory</span><span class="special">&lt;</span><span class="identifier">Hash</span><span class="special">,</span><span class="identifier">Pred</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier"> Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span> </pre>

</blockquote>

<p>
is the same as</p>

<p>等同于
</p>

<blockquote>
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier"> hashed_factory_class</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span><span class="identifier">Hash</span><span class="special">,</span><span class="identifier">Pred</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier"> Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span> </pre>

</blockquote>

<p>
This implies that <code>Hash</code>, <code>Pred</code>
and <code>Allocator</code>
can be <a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
Placeholder Expressions</code></a> resolving to the actual
types used by
<code>hashed_factory_class</code>.</p>

<p>这暗示着<big><code>Hash</code></big>, <big><code>Pred</code></big>
和 <big><code>Allocator</code></big>可以是<a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
<big>占位符表达式</big></code></a><code><big>，
生
成</big></code><big><code>hashed_factory_class</code></big><code><big>用
到的实际类型</big></code>
</p>

<h2><a name="set_factory_fwd_synopsis">Header
</a><a href="../../../../boost/flyweight/set_factory_fwd.hpp"><code>"boost/flyweight/set_factory_fwd.hpp"</code></a>
synopsis &nbsp;</h2>

<h2>头文件<a href="file:///boost/flyweight/set_factory_fwd.hpp"><code>"boost/flyweight/set_factory_fwd.hpp"</code></a>大
意</h2>

<blockquote>
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Compare</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">set_factory_class</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Compare</span><span class="special">=</span><b>implementation defined</b><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Allocator</span><span class="special">=</span><b>implementation defined</b><br><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">set_factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><br><span class="special">}</span> <span class="comment">// namespace boost</span> </pre>

</blockquote>

<p>
<code>set_factory_fwd.hpp</code> forward declares the class
templates
<a href="#set_factory_class"><code>set_factory_class</code></a>
and <a href="#set_factory"><code>set_factory</code></a>.</p>

<p><big><code>set_factory_fwd.hpp</code></big>前
置声明了类模板<big><a href="factories.html#set_factory_class"><code>set_factory_class</code></a></big>
和 <big><a href="factories.html#set_factory"><code>set_factory</code></a></big>
</p>

<h2><a name="set_factory_synopsis">Header
</a><a href="../../../../boost/flyweight/set_factory.hpp"><code>"boost/flyweight/set_factory.hpp"</code></a>
synopsis &nbsp;</h2>

<h2>头文件<a href="../../../../boost/flyweight/set_factory.hpp"><code>"boost/flyweight/set_factory.hpp"</code></a>大
意</h2>

<h3><a name="set_factory_class">Class template <code>set_factory_class
&nbsp;类模板 set_factory_class</code></a></h3>

<p>
<code>set_factory_class</code> is a <a href="#factory"><code>Factory</code></a>
implemented on top of an orderded associative container.</p>

<p><big><code>set_factory_class</code></big>是
一个基于有序关联容器实现的<a href="#factory">工厂</a>
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Entry</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span><br><span class="keyword">&nbsp; typename</span> <span class="identifier">Compare</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><br><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">set_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <b>implementation defined</b> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="identifier">Entry</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span> </pre>

</blockquote>

<p>
<code>Compare</code> is a <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default
Constructible</code></a>
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code>Strict
Weak Ordering</code></a> on <code>Key</code>.
Two <code>Key</code>s
<code>x</code> and <code>y</code> are
considered equivalent if
<code>!c(x,y)&amp;&amp;!c(y,x)</code> for <code>c</code>
of type <code>Compare</code>.
The default argument of <code>Compare</code> is <code>std::less&lt;Key&gt;</code>.
<code>Allocator</code> must be an allocator of <code>Entry</code>
objects
satisfying the associated C++ requirements at <b>[lib.allocator.requirements]</b>.
The default argument is <code>std::allocator&lt;Entry&gt;</code>.
The internal
container upon which <code>set_factory_class</code> is
based is
constructed with default initialized objects of type <code>Compare</code>
and <code>Allocator</code>.</p>

<p><big><code>Compare</code></big>是一个<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">可
默认构造</a>而且在<big><code>Key</code></big>上<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">严格
弱序</a>的类型。如果对<big><code>Compare</code></big>类
型的<big><code>c</code></big>类来说<big><code>!c(x,y)&amp;&amp;!c(y,
x)</code></big>，2个<big><code>Key</code>s
<code>x</code></big> 和<big><code>y</code></big>被
看作相等<code>。</code><big><code>Compare</code></big>的
默认参数是<big><code>std::less&lt;Key&gt;</code></big>。<big><code>Allocator</code></big>必
须是满足C++标准<b>[lib.allocator.requirements]</b>里
的相关要求的<big><code>Entry</code></big>对象的分配器。默认的参数是<big><code>std::allocator&lt;Entry&gt;</code></big><code>。</code><code></code><code></code><big><code>set_factory_class</code></big>基
于的内部容器是用<big><code>Compare</code></big> 和 <big><code>Allocator</code></big>类
型的默认初始化对象创建的。<code></code>
</p>

<h3><a name="set_factory">Class template <code>set_factory
&nbsp;类模板 set_factory</code></a></h3>

<p>
<a href="#factory"><code>Factory Specifier</code></a>
for <a href="#set_factory_class"><code>set_factory_class</code></a>.</p>

<p><big><a href="factories.html#set_factory_class"><code>set_factory_class</code></a></big>的<a href="#factory">工厂描述符</a>
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">set_factory</span><span class="special">;</span> </pre>

</blockquote>

<p>
<code>set_factory&lt;Compare,Allocator&gt;</code>
is an
<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code>MPL
Metafunction
Class</code></a> such that the type</p>

<p><big><code>set_factory&lt;Compare,Allocator&gt;</code></big>是
一个<a href="../../../mpl/doc/refmanual/metafunction-class.html"><code><big>MPL</big>
<big>元函数类</big></code></a>，于是类型<br>

</p>

<blockquote>
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier"> set_factory</span><span class="special">&lt;</span><span class="identifier">Compare</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier"> Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span> </pre>

</blockquote>

<p>
is the same as</p>

<p>等同于
</p>

<blockquote>
  <pre><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><br><span class="identifier"> set_factory_class</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span><span class="identifier">Compare</span><span class="special">,</span><span class="identifier">Allocator</span><span class="special">&gt;,</span><br><span class="identifier"> Entry</span><span class="special">,</span><span class="identifier">Key</span><br><span class="special">&gt;::</span><span class="identifier">type</span> </pre>

</blockquote>

<p>
This implies that <code>Compare</code> and <code>Allocator</code>
can be <a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
Placeholder Expressions</code></a> resolving to the actual
types used by
<code>set_factory_class</code>.</p>

<p>这暗示着<big><code>Compare</code></big> 和 <big><code>Allocator</code></big>可
以是<a href="../../../mpl/doc/refmanual/placeholder-expression.html"><code>MPL
<big>占位符表达式</big></code></a><code><big>，</big></code><code><big>生</big></code><code><big>成</big></code><big><code>set_factory_class</code></big><code><big>用
到的实际类型</big></code>
</p>

<h2><a name="assoc_container_factory_fwd_synopsis">Header
</a><a href="../../../../boost/flyweight/assoc_container_factory_fwd.hpp"><code>"boost/flyweight/assoc_container_factory_fwd.hpp"</code></a>
synopsis &nbsp;</h2>

<h2>头文件<a href="file:///boost/flyweight/assoc_container_factory_fwd.hpp"><code>"boost/flyweight/assoc_container_factory_fwd.hpp"</code></a>大
意</h2>

<blockquote>
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">flyweights</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">assoc_container_factory_class</span><span class="special">;</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ContainerSpecifier</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">assoc_container_factory</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::flyweights</span><br><br><span class="special">}</span> <span class="comment">// namespace boost</span> </pre>

</blockquote>

<p>
<code>assoc_container_factory_fwd.hpp</code> forward
declares the class templates
<a href="#assoc_container_factory_class"><code>assoc_container_factory_class</code></a>
and <a href="#assoc_container_factory"><code>assoc_container_factory</code></a>.</p>

<p><big><code>assoc_container_factory_fwd.hpp</code></big>前
向声明了类模
板<big><a href="factories.html#assoc_container_factory_class"><code>assoc_container_factory_class</code></a></big>
和 <big><a href="factories.html#assoc_container_factory"><code>assoc_container_factory</code></a></big>
</p>

<h2><a name="assoc_container_factory_synopsis">Header
</a><a href="../../../../boost/flyweight/assoc_container_factory.hpp"><code>"boost/flyweight/assoc_container_factory.hpp"</code></a>
synopsis &nbsp;</h2>

<h2>头文件<a href="file:///boost/flyweight/assoc_container_factory.hpp"><code>"boost/flyweight/assoc_container_factory.hpp"</code></a>大
意</h2>

<h3><a name="assoc_container_factory_class">Class
template <code>assoc_container_factory_class &nbsp;类模板
&nbsp;assoc_container_factory_class</code></a></h3>

<p>
<code>assoc_container_factory_class</code> wraps a suitable
associative container
to provide a <a href="#factory"><code>Factory</code></a>
interface.</p>

<p><big><code>assoc_container_factory_class</code></big>包
装了一个合适的关
联容器用来提供<a href="#factory">工厂</a>的界面
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">assoc_container_factory_class</span><br><span class="special">{</span><br><span class="keyword">public</span><span class="special">:</span><br><span class="keyword">&nbsp; typedef</span> <span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">handle_type</span><span class="special">;</span><br><br><span class="identifier">&nbsp; handle_type</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span><br><span class="keyword">&nbsp; void</span> <span class="identifier">erase</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="keyword">&nbsp; const</span> <span class="keyword">typename</span> <span class="identifier">Container</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">entry</span><span class="special">(</span><span class="identifier">handle_type</span> <span class="identifier">h</span><span class="special">);</span><br><span class="special">};</span> </pre>

</blockquote>

<p>
<code>Container</code> must be an (ordered or unordered)
associative container
such that &nbsp;<code>Container</code>必须是一个（有序的或者无序的）关联容
器，该容器满足
</p>

<ol>

  <li><code>Container::key_type</code> is the same as
    <code>Container::value_type</code> (which is the entry
type associated to the factory). </li>

  <p><big><code>Container::key_type</code></big>等
同于<big><code>Container::value_type</code></big>（它
是相关工厂的entry类型）</p>

  <li>Unique keys (rather than equivalent keys) are supported.</li>

  <p>支持唯一的keys（而非相等的key）</p>

  <li><code>Container</code> is <i>stable</i>,
i.e. its iterators are not invalidated upon insert or erase operations.</li>

  <p>容器是<span style="font-style: italic;">稳定的</span>，
就是说，插入和删除操作之后它的迭代器依然有效<code></code><br>

  </p>

</ol>

The equivalence relation associated to <code>assoc_container_factory_class</code>
is the one induced by <code>Container</code>. If
equivalence of elements
of <code>Container::value_type</code> is determined solely
on the basis of a
type <code>value_type'</code> to which <code>value_type</code>
is
implicitly convertible, then <code>assoc_container_factory_class</code>
is
a factory of entries of type <code>value_type</code>
implicitly associated to
<code>value_type'</code>. For example, the instantiation<br>

<code></code><br>

<big><code>assoc_container_factory_class</code></big>上
的相等关系由<big><code>Container</code></big>导出。如果<big><code>Container::value_type</code></big>元
素的相等关系完全由类型<big><code>value_type'</code></big>决
定，而且<big><code>value_type</code></big>可以隐式转换成<code><big>value_type'</big>，</code>那
么<big><code>assoc_container_factory_class</code></big>是
一个隐式关联到<big><code>value_type'</code></big>的<big><code>value_type</code></big>类
型元素的工厂。例如，这个实例
<blockquote>
  <pre><span class="identifier">assoc_container_factory_class</span><span class="special">&lt;</span><br><span class="identifier">&nbsp; std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">derived</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">base</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="comment">// derived inherits from base</span><br><span class="special">&gt;</span> </pre>

</blockquote>

<p>
is a factory of <code>derived</code> elements implicitly
associated to
<code>base</code>.</p>

<p>是一个隐式关联到<big><code>base</code></big>的<big><code>derived</code></big>元
素的工厂
</p>

<h3><a name="assoc_container_factory">Class template
<code>assoc_container_factory &nbsp;类模板
&nbsp;assoc_container_factory</code></a></h3>

<p>
<a href="#factory"><code>Factory Specifier</code></a>
for <a href="#assoc_container_factory_class"><code>assoc_container_factory_class</code></a>.</p>

<p><big><a href="factories.html#assoc_container_factory_class"><code>assoc_container_factory_class</code></a></big>的<a href="#factory">工厂描述符</a>
</p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ContainerSpecifier</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">assoc_container_factory</span><span class="special">;</span> </pre>

</blockquote>

<p>
<code>ContainerSpecifier</code> must be an <a href="../../../mpl/doc/refmanual/lambda-expression.html"><code>MPL
Lambda
Expression</code></a> resolving, when invoked with (<code>Entry</code>,
<code>Key</code>), to a type <code>Container</code>
such that
<code>assoc_container_factory_class&lt;Container&gt;</code>
is a factory
of <code>Entry</code> elements implicitly associated to <code>Key</code>.</p>

<p><big><code>ContainerSpecifier</code></big>必
须是一个<a href="../../../mpl/doc/refmanual/lambda-expression.html"><code><big>MPL
Lambda</big> <big>表达式</big></code></a>，当用
（<big><code>Entry</code>，<code>Key</code></big>）
调用时，生成一个<code><big>Container</big>，</code>然后<big><code>assoc_container_factory_class&lt;Container&gt;</code></big>是
一个<code></code>隐式关联到<big><code>Key</code></big>的<big><code>Entry</code></big>元
素的工厂，
</p>

<hr>
<div class="prev_link"><a href="tags.html"><img src="../prev.gif" alt="tags" border="0"><br>

Tags
</a></div>

<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.Flyweight reference" border="0"><br>

Boost.Flyweight reference
</a></div>

<div class="next_link"><a href="holders.html"><img src="../next.gif" alt="holders" border="0"><br>

Holders
</a></div>

<br style="" clear="all">

<br>

<p>Revised August 13th 2008</p>

<p>&copy; Copyright 2006-2008 Joaqu&iacute;n M
L&oacute;pez Mu&ntilde;oz.
Distributed under the Boost Software License, Version 1.0. (See
accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)
</p>

</body>
</html>

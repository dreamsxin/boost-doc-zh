<!--
Copyright Daniel James 2006-2009
Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
--><library-reference>
    <header name="boost/unordered_set.hpp">
      <namespace name="boost">
        <class name="unordered_set">
          <template>
            <template-type-parameter name="Value">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;Value&gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose><simpara>
            An unordered associative container that stores unique values.<sbr/>
            保存唯一值的无序关联式容器。
          </simpara></purpose>
          <description>
            <para>Based on chapter 23 of
              <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">the working draft of the C++ standard [n2960]</ulink>.
              But without the updated rules for allocators.<sbr/>
              基于 <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">C++标准工作草案[n2690]</ulink> 
              第23章。但不包含对分配器的最新规则。
            </para>
            <para><emphasis role="bold">Template Parameters 模板参数</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry><emphasis>Value</emphasis></entry>
                      <entry>Value must be Assignable and CopyConstructible<sbr/>
                      Value 必须是可赋值和可复制构造的</entry></row>
                    <row>
                      <entry><emphasis>Hash</emphasis></entry>
                      <entry>A unary function object type that acts a hash function for a <code>Value</code>. It takes a single argument of type <code>Value</code> and returns a value of type std::size_t.<sbr/>
                      一元函数对象类型，用作 <code>Value</code> 的散列函数。
                      它接受单个类型为 <code>Value</code> 的参数，返回类型为 std::size_t 的值。</entry></row>
                    <row>
                      <entry><emphasis>Pred</emphasis></entry>
                      <entry>A binary function object that implements an equivalence relation on values of type <code>Value</code>.
                        A binary function object that induces an equivalence relation on values of type Key.
                        It takes two arguments of type Key and returns a value of type bool.<sbr/>
                        二元函数对象，实现类型 <code>Value</code> 的等同性关系。
                        它接受两个类型为 Value 的参数，返回类型为 bool 的值。</entry></row>
                    <row>
                      <entry><emphasis>Alloc</emphasis></entry>
                      <entry>An allocator whose value type is the same as the container's value type.<sbr/>
                      分配器，它的值类型与容器的值类型相同。</entry></row></tbody></tgroup></informaltable></para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.<sbr/>
            容器中的元素存放在多个桶中。具有相同散列码的键存放在同一个桶中。</para>
            <para>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.<sbr/>
            桶的数量可以通过调用 insert 自动增加，或者调用 rehash 进行调整。</para>
          </description>
          <typedef name="key_type">
            <type>Value</type>
          </typedef>
          <typedef name="value_type">
            <type>Value</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <purpose><simpara>lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <purpose><simpara>const lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An unsigned integral type.<sbr/>
              无符号整数类型。</para>
              <para><type>size_type</type> can represent any non-negative value of <type>difference_type</type>.<sbr/>
              <type>size_type</type> 可以表示 <type>difference_type</type> 的任一非负值。</para>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A signed integral type.<sbr/>
              有符号整数类型。</para>
              <para>Is identical to the difference type of <type>iterator</type> and <type>const_iterator</type>.<sbr/>
              与 <type>iterator</type> 和 <type>const_iterator</type> 的距离类型相同。</para>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is <type>value_type</type>. <sbr/>
              一个常量迭代器，它的值类型为 <type>value_type</type>。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
              <para>Convertible to <type>const_iterator</type>.<sbr/>
              可转换为 <type>const_iterator</type>。</para>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is <type>value_type</type>. <sbr/>
              一个常量迭代器，它的值类型为 <type>value_type</type>。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An iterator with the same value type, difference type and pointer and reference type as <type>iterator</type>.<sbr/>
              具有与 <type>iterator</type> 相同值类型、距离类型和指针、引用类型的迭代器。</para>
              <para>A local_iterator object can be used to iterate through a single bucket.<sbr/>
              local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator with the same value type, difference type and pointer and reference type as <type>const_iterator</type>.<sbr/>
              具有与 <type>const_iterator</type> 相同值类型、距离类型和指针、引用类型的迭代器。</para>
              <para>A const_local_iterator object can be used to iterate through a single bucket.<sbr/>
              const_local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <constructor specifiers="explicit">
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <postconditions>
              <code><methodname>size</methodname>() == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，最大负载因子为 1.0。</para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，最大负载因子为 1.0，并插入 [f,l) 的元素。</para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_set const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.<sbr/>
              复制构造函数。复制所含的元素、散列函数、谓词、最大负载因子和分配器。</para>
            </description>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_set &amp;&amp;</paramtype>
            </parameter>
            <description>
              <para>The move constructor.<sbr/>
              移动构造函数。</para>
            </description>
            <notes>
              <para>This is emulated on compilers without rvalue references.<sbr/>
              在不带右值引用的编译器上的模拟。</para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。 
              </para>
            </requires>
          </constructor>
          <constructor specifiers="explicit">
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an empty container, using allocator <code>a</code>.<sbr/>
                构造一个空容器，使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <constructor>
            <parameter name="x">
              <paramtype>unordered_set const&amp;</paramtype>
            </parameter>
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an container, copying <code>x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.<sbr/>
                构造一个容器，复制 <code>x</code> 所含的元素、散列函数、谓词、最大负载因子，但使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <destructor>
            <notes>
              <para>The destructor is applied to every element, and all memory is deallocated<sbr/>
              对每个元素调用构造函数，并释放所有内存。</para>
            </notes>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_set const&amp;</paramtype>
            </parameter>
            <type>unordered_set&amp;</type>
            <description>
              <para>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.<sbr/>
              赋值操作符。复制所含的元素、散列函数、谓词、最大负载因子，但不复制分配器。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_set)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_set)</code> 的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </method>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_set &amp;&amp;</paramtype>
            </parameter>
            <type>unordered_set&amp;</type>
            <description>
              <para>The move assignment operator.<sbr/>
              移动赋值操作符。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_set)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_set)</code> 的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。
              </para>
            </requires>
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><methodname>size</methodname>() == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<methodname>begin</methodname>(), <methodname>end</methodname>())</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns><code><methodname>size</methodname>()</code> of the largest possible container.<sbr/>
              最大可能容器的 <code><methodname>size</methodname>()</code>。 
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </method>
            <method name="cend" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator which refers to the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的 past-the-end 值。
              </returns>
            </method>
          </method-group>
          <method-group name="modifiers">
            <method name="emplace">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>std::pair&lt;iterator, bool&gt;</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中，当且仅当空器中没有相同键值的元素。</para>
              </description>
              <returns>
                <para>The bool component of the return type is true if an insert took place.<sbr/>
                如果插入成功，则返回类型的 bool 部分为 true。</para>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="emplace_hint">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中，当且仅当空器中没有相同键值的元素。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 
                支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>std::pair&lt;iterator, bool&gt;</type>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent value.<sbr/>
                插入 obj 到容器中，当且仅当空器中没有相同键值的元素。</para>
              </description>
              <returns>
                <para>The bool component of the return type is true if an insert took place.<sbr/>
                如果插入成功，则返回类型的 bool 部分为 true。</para>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent value.<sbr/>
                插入 obj 到容器中，当且仅当空器中没有相同键值的元素。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 
                支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent value.<sbr/>
                插入一组元素到容器中。元素当且仅当空器中没有相同键值的元素时被插入。</para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                当插入单个元素时，如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <returns>
                <para>The iterator following <code>position</code> before the erasure.<sbr/>
                在删除前紧跟 <code>position</code> 的迭代器。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  When the number of elements is a lot smaller than the number of buckets
                  this function can be very inefficient as it has to search through empty
                  buckets for the next element, in order to return the iterator.
                  The method <methodname>quick_erase</methodname> is faster, but has yet
                  to be standardized.<sbr/>
                  当元素的数量远小于桶的数量时，这个函数会非常低效，因为它必须对空桶搜索下一个元素以返回该迭代器。
                  方法 <methodname>quick_erase</methodname> 会更快一些，但尚未标准化。
                </para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <description>
                <para>Erase all elements with key equivalent to <code>k</code>.<sbr/>
                删除所有键值等于 <code>k</code> 的元素。</para>
              </description>
              <returns>
                <para>The number of elements erased.<sbr/>
                被删除的元素数量。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
              </throws>
            </method>
            <method name="erase">
              <parameter name="first">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erases the elements in the range from <code>first</code> to <code>last</code>.<sbr/>
                删除从 <code>first</code> 到 <code>last</code> 的元素。</para>
              </description>
              <returns>
                <para>The iterator following the erased elements - i.e. <code>last</code>.<sbr/>
                紧随被删除元素之后的迭代器 - 即 <code>last</code>。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
            </method>
            <method name="quick_erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is faster than <methodname>erase</methodname> as
                  it doesn't have to find the next element in the container -
                  a potentially costly operation.<sbr/>
                  这个方法快于 <methodname>erase</methodname>，因为它不需要在容器中查找下一个元素 - 这种查找可能很耗时间。
                </para>
                <para>
                  As it hasn't been standardized, it's likely that this may
                  change in the future.<sbr/>
                  由于该方法未被标准化，它可能会在以后有所变化。
                </para>
              </notes>
            </method>
            <method name="erase_return_void">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is now deprecated, use
                  <methodname>quick_return</methodname> instead. Although be
                  warned that as that isn't standardized yet, it could also
                  change.<sbr/>
                  该方法现在已不再使用，请用 <methodname>quick_return</methodname> 替代。不过这尚未标准化，可能会变。
                </para>
              </notes>
            </method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.<sbr/>
                删除容器中所有元素。</para>
              </description>
              <postconditions>
                <para><code><methodname>size</methodname>() == 0</code></para>
              </postconditions>
              <throws>
                <para>Never throws an exception.<sbr/>
                不会抛出。</para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype>unordered_set&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.<sbr/>
                如果分配器是相同的，则不会抛出，除非异常是从 <code>key_equal</code> 或 
                <code>hasher</code> 的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.<sbr/>
                  有关分配器不同时的行为的讨论，请见 <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.<sbr/>
              容器的散列函数。
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.<sbr/>
              容器的键值等同性谓词。
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <signature>
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.<sbr/>
                一个迭代器，指向键值等于 <code>k</code> 的元素，如果该元素不存在，返回 <code>b.end()</code>。</para>
              </returns>
              <notes><para>
                The templated overloads are a non-standard extensions which
                allows you to use a compatible hash function and equality
                predicate for a key of a different type in order to avoid
                an expensive type cast. In general, its use is not encouraged.<sbr/>
                这个模板化的重载是非标准化的扩展，使得你可以对不同类型的键使用兼容的散列函数和相等性谓词，
                以避免昂贵的类型转换。通常，并不鼓励使用。
              </para></notes>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to <code>k</code>.<sbr/>
                键值等于 <code>k</code> 的元素数量。</para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;const_iterator, const_iterator&gt;</type>
              </signature>
              <returns>
                <para>A range containing all elements with key equivalent to <code>k</code>.
                  If the container doesn't container any such elements, returns
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.<sbr/>
                  包含所有键值等于 <code>k</code> 的元素的区间。如果容器中没有这样的元素，返回 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.
                  </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.<sbr/>
                桶的数量。</para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.<sbr/>
                桶数量的上限。</para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para><code>n &lt; <methodname>bucket_count</methodname>()</code></para>
              </requires>
              <returns>
                <para>The number of elements in bucket <code>n</code>.<sbr/>
                桶 <code>n</code> 中的元素数量。</para>
              </returns>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key <code>k</code>.<sbr/>
                包含键值为 <code>k</code> 的元素的桶的索引。</para>
              </returns>
              <postconditions>
                <para>The return value is less than <code>bucket_count()</code><sbr/>
                返回值小于 <code>bucket_count()</code></para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的最后一个元素之后。</para>
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个常量局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </method>
            <method name="cend">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个常量局部迭代器，指向索引为 <code>n</code> 的桶中的最后一个元素之后。</para>
              </returns>
            </method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.<sbr/>
                每个桶中元素的平均数量。</para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.<sbr/>
                返回当前的最大负载因子。</para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para>Changes the container's maximum load factor, using <code>z</code> as a hint.<sbr/>
                修改容器的最大负载因子，以 <code>z</code> 为提示。</para>
              </effects>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.<sbr/>
                修改桶的数量，使得最少有 <code>n</code> 个桶，且负载因子小于最大负载因子。</para>
                <para>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.<sbr/>
                使迭代器失效，并会改变元素的顺序。指向元素的指针和引用不会失效。</para>
              </description>
              <throws>
                <para>The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.<sbr/>
                如果抛出异常，则该函数没有作用，除非异常是从容器的散列函数或比较函数中抛出的。</para>
              </throws>
            </method>
          </method-group>
          <free-function-group name="Equality Comparisons">
            <function name="operator==">
              <template>
                <template-type-parameter name="Value">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_set&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_set&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
            <function name="operator!=">
              <template>
                <template-type-parameter name="Value">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_set&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_set&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
          </free-function-group>
          <free-function-group name="swap">
            <function name="swap">
              <template>
                <template-type-parameter name="Value">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_set&lt;Value, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para><code>x.swap(y)</code></para>
              </effects>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>Hash</code> or <code>Pred</code>.<sbr/>
                如果分配器是相同的，则不会抛出异常，除非异常是从 <code>Hash</code> 或 
                <code>Pred</code> 的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.<sbr/>
                  有关分配器不同时的行为的讨论，请见 
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </function>
          </free-function-group>
        </class>
        <class name="unordered_multiset">
          <template>
            <template-type-parameter name="Value">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;Value&gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose><simpara>
            An unordered associative container that stores  values. The same key can be stored multiple times.<sbr/>
            保存值的无序关联式容器，相同的键值可以保存多次。
          </simpara></purpose>
          <description>
            <para>Based on chapter 23 of
              <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">the working draft of the C++ standard [n2960]</ulink>.
              But without the updated rules for allocators.<sbr/>
              基于 <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">C++标准工作草案[n2690]</ulink> 
              第23章。但不包含对分配器的最新规则。
            </para>
            <para><emphasis role="bold">Template Parameters 模板参数</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry><emphasis>Value</emphasis></entry>
                      <entry>Value must be Assignable and CopyConstructible<sbr/>
                      Value 必须是可赋值和可复制构造的</entry></row>
                    <row>
                      <entry><emphasis>Hash</emphasis></entry>
                      <entry>A unary function object type that acts a hash function for a <code>Value</code>. It takes a single argument of type <code>Value</code> and returns a value of type std::size_t.<sbr/>
                      一元函数对象类型，用作 <code>Value</code> 的散列函数。它接受单个类型为 <code>Value</code> 
                      的参数，返回类型为 std::size_t 的值。</entry></row>
                    <row>
                      <entry><emphasis>Pred</emphasis></entry>
                      <entry>A binary function object that implements an equivalence relation on values of type <code>Value</code>.
                        A binary function object that induces an equivalence relation on values of type Key.
                        It takes two arguments of type Key and returns a value of type bool.<sbr/>
                        二元函数对象，实现类型 <code>Value</code> 的等同性关系。
                        它接受两个类型为 Value 的参数，返回类型为 bool 的值。</entry></row>
                    <row>
                      <entry><emphasis>Alloc</emphasis></entry>
                      <entry>An allocator whose value type is the same as the container's value type.<sbr/>
                      分配器，它的值类型与容器的值类型相同。</entry></row></tbody></tgroup></informaltable></para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.<sbr/>
            容器中的元素存放在多个桶中。具有相同散列码的键存放在同一个桶中，相同键值的元素会连续存放在一起。</para>
            <para>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.<sbr/>
            桶的数量可以通过调用 insert 自动增加，或者调用 rehash 进行调整。</para>
          </description>
          <typedef name="key_type">
            <type>Value</type>
          </typedef>
          <typedef name="value_type">
            <type>Value</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <purpose><simpara>lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <purpose><simpara>const lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An unsigned integral type.<sbr/>
              无符号整数类型。</para>
              <para><type>size_type</type> can represent any non-negative value of <type>difference_type</type>.<sbr/>
              <type>size_type</type> 可以表示 <type>difference_type</type> 的任一非负值。</para>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A signed integral type.<sbr/>
              有符号整数类型。</para>
              <para>Is identical to the difference type of <type>iterator</type> and <type>const_iterator</type>.<sbr/>
              与 <type>iterator</type> 和 <type>const_iterator</type> 的距离类型相同。</para>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is <type>value_type</type>. <sbr/>
              一个常量迭代器，它的值类型为 <type>value_type</type>。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
              <para>Convertible to <type>const_iterator</type>.<sbr/>
              可转换为 <type>const_iterator</type>。</para>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is <type>value_type</type>. <sbr/>
              一个常量迭代器，它的值类型为 <type>value_type</type>。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An iterator with the same value type, difference type and pointer and reference type as <type>iterator</type>.<sbr/>
              具有与 <type>iterator</type> 相同值类型、距离类型和指针、引用类型的迭代器。</para>
              <para>A local_iterator object can be used to iterate through a single bucket.<sbr/>
              local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator with the same value type, difference type and pointer and reference type as <type>const_iterator</type>.<sbr/>
              具有与 <type>const_iterator</type> 相同值类型、距离类型和指针、引用类型的迭代器。</para>
              <para>A const_local_iterator object can be used to iterate through a single bucket.<sbr/>
              const_local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <constructor specifiers="explicit">
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <postconditions>
              <code><methodname>size</methodname>() == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，最大负载因子为 1.0。</para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，最大负载因子为 1.0，并插入 [f,l) 的元素。</para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_multiset const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.<sbr/>
              复制构造函数。复制所含的元素、散列函数、谓词、最大负载因子和分配器。</para>
            </description>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_multiset &amp;&amp;</paramtype>
            </parameter>
            <description>
              <para>The move constructor.<sbr/>
              移动构造函数。</para>
            </description>
            <notes>
              <para>This is emulated on compilers without rvalue references.<sbr/>
              在不带右值引用的编译器上的模拟。</para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。
              </para>
            </requires>
          </constructor>
          <constructor specifiers="explicit">
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an empty container, using allocator <code>a</code>.<sbr/>
                构造一个空容器，使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <constructor>
            <parameter name="x">
              <paramtype>unordered_multiset const&amp;</paramtype>
            </parameter>
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an container, copying <code>x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.<sbr/>
                构造一个容器，复制 <code>x</code> 所含的元素、散列函数、谓词、最大负载因子，但使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <destructor>
            <notes>
              <para>The destructor is applied to every element, and all memory is deallocated<sbr/>
              对每个元素调用构造函数，并释放所有内存。</para>
            </notes>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_multiset const&amp;</paramtype>
            </parameter>
            <type>unordered_multiset&amp;</type>
            <description>
              <para>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.<sbr/>
              赋值操作符。复制所含的元素、散列函数、谓词、最大负载因子，但不复制分配器。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_multiset)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_multiset)<code> 的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </method>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_multiset &amp;&amp;</paramtype>
            </parameter>
            <type>unordered_multiset&amp;</type>
            <description>
              <para>The move assignment operator.<sbr/>
              移动赋值操作符。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_multiset)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_multiset)</code> 的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。
              </para>
            </requires>
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><methodname>size</methodname>() == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<methodname>begin</methodname>(), <methodname>end</methodname>())</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns><code><methodname>size</methodname>()</code> of the largest possible container.<sbr/>
              最大可能容器的 <code><methodname>size</methodname>()</code>。 
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </method>
            <method name="cend" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator which refers to the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的 past-the-end 值。
              </returns>
            </method>
          </method-group>
          <method-group name="modifiers">
            <method name="emplace">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="emplace_hint">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container.<sbr/>
                插入 obj 到容器中。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container.<sbr/>
                插入 obj 到容器中。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container.<sbr/>
                插入一组元素到容器中。</para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                当插入单个元素时，如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <returns>
                <para>The iterator following <code>position</code> before the erasure.<sbr/>
                在删除前紧跟 <code>position</code> 的迭代器。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  When the number of elements is a lot smaller than the number of buckets
                  this function can be very inefficient as it has to search through empty
                  buckets for the next element, in order to return the iterator.
                  The method <methodname>quick_erase</methodname> is faster, but has yet
                  to be standardized.<sbr/>
                  当元素的数量远小于桶的数量时，这个函数会非常低效，因为它必须对空桶搜索下一个元素以返回该迭代器。
                  方法 <methodname>quick_erase</methodname> 会更快一些，但尚未标准化。
                </para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <description>
                <para>Erase all elements with key equivalent to <code>k</code>.<sbr/>
                删除所有键值等于 <code>k</code> 的元素。</para>
              </description>
              <returns>
                <para>The number of elements erased.<sbr/>
                被删除的元素数量。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
              </throws>
            </method>
            <method name="erase">
              <parameter name="first">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erases the elements in the range from <code>first</code> to <code>last</code>.<sbr/>
                删除从 <code>first</code> 到 <code>last</code> 的元素。</para>
              </description>
              <returns>
                <para>The iterator following the erased elements - i.e. <code>last</code>.<sbr/>
                紧随被删除元素之后的迭代器 - 即 <code>last</code>。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
            </method>
            <method name="quick_erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is faster than <methodname>erase</methodname> as
                  it doesn't have to find the next element in the container -
                  a potentially costly operation.<sbr/>
                  这个方法快于 <methodname>erase</methodname>，因为它不需要在容器中查找下一个元素 - 这种查找可能很耗时间。
                </para>
                <para>
                  As it hasn't been standardized, it's likely that this may
                  change in the future.<sbr/>
                  由于该方法未被标准化，它可能会在以后有所变化。
                </para>
              </notes>
            </method>
            <method name="erase_return_void">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is now deprecated, use
                  <methodname>quick_return</methodname> instead. Although be
                  warned that as that isn't standardized yet, it could also
                  change.<sbr/>
                  该方法现在已不再使用，请用 <methodname>quick_return</methodname> 替代。不过这尚未标准化，可能会变。
                </para>
              </notes>
            </method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.<sbr/>
                删除容器中所有元素。</para>
              </description>
              <postconditions>
                <para><code><methodname>size</methodname>() == 0</code></para>
              </postconditions>
              <throws>
                <para>Never throws an exception.<sbr/>
                不会抛出。</para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype>unordered_multiset&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.<sbr/>
                如果分配器是相同的，则不会抛出，除非异常是从 <code>key_equal</code> 或 <code>hasher</code> 
                的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.<sbr/>
                  有关分配器不同时的行为的讨论，请见 <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.<sbr/>
              容器的散列函数。
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.<sbr/>
              容器的键值等同性谓词。
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <signature>
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.<sbr/>
                一个迭代器，指向键值等于 <code>k</code> 的元素，如果该元素不存在，返回 <code>b.end()</code>。</para>
              </returns>
              <notes><para>
                The templated overloads are a non-standard extensions which
                allows you to use a compatible hash function and equality
                predicate for a key of a different type in order to avoid
                an expensive type cast. In general, its use is not encouraged.<sbr/>
                这个模板化的重载是非标准化的扩展，使得你可以对不同类型的键使用兼容的散列函数和相等性谓词，
                以避免昂贵的类型转换。通常，并不鼓励使用。
              </para></notes>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to <code>k</code>.<sbr/>
                键值等于 <code>k</code> 的元素数量。</para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;const_iterator, const_iterator&gt;</type>
              </signature>
              <returns>
                <para>A range containing all elements with key equivalent to <code>k</code>.
                  If the container doesn't container any such elements, returns
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.<sbr/>
                  包含所有键值等于 <code>k</code> 的元素的区间。如果容器中没有这样的元素，返回 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>. 
                  </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.<sbr/>
                桶的数量。</para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.<sbr/>
                桶数量的上限。</para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para><code>n &lt; <methodname>bucket_count</methodname>()</code></para>
              </requires>
              <returns>
                <para>The number of elements in bucket <code>n</code>.<sbr/>
                桶 <code>n</code> 中的元素数量。</para>
              </returns>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key <code>k</code>.<sbr/>
                包含键值为 <code>k</code> 的元素的桶的索引。</para>
              </returns>
              <postconditions>
                <para>The return value is less than <code>bucket_count()</code><sbr/>
                返回值小于 <code>bucket_count()</code></para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的 'one past the end' 元素。</para>
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个常量局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </method>
            <method name="cend">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的 'one past the end' 元素。</para>
              </returns>
            </method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.<sbr/>
                每个桶中元素的平均数量。</para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.<sbr/>
                返回当前的最大负载因子。</para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para>Changes the container's maximum load factor, using <code>z</code> as a hint.<sbr/>
                修改容器的最大负载因子，以 <code>z</code> 为提示。</para>
              </effects>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.<sbr/>
                修改桶的数量，使得最少有 <code>n</code> 个桶，且负载因子小于最大负载因子。</para>
                <para>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.<sbr/>
                使迭代器失效，并会改变元素的顺序。指向元素的指针和引用不会失效。</para>
              </description>
              <throws>
                <para>The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.<sbr/>
                如果抛出异常，则该函数没有作用，除非异常是从容器的散列函数或比较函数中抛出的。</para>
              </throws>
            </method>
          </method-group>
          <free-function-group name="Equality Comparisons">
            <function name="operator==">
              <template>
                <template-type-parameter name="Value">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
            <function name="operator!=">
              <template>
                <template-type-parameter name="Value">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
          </free-function-group>
          <free-function-group name="swap">
            <function name="swap">
              <template>
                <template-type-parameter name="Value">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para><code>x.swap(y)</code></para>
              </effects>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>Hash</code> or <code>Pred</code>.<sbr/>
                如果分配器是相同的，则不会抛出异常，除非异常是从 <code>Hash</code> 或 <code>Pred</code> 的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.<sbr/>
                  有关分配器不同时的行为的讨论，请见 <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </function>
          </free-function-group>
        </class>
      </namespace>
    </header>
    <header name="boost/unordered_map.hpp">
      <namespace name="boost">
        <class name="unordered_map">
          <template>
            <template-type-parameter name="Key">
            </template-type-parameter>
            <template-type-parameter name="Mapped">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Key&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Key&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;std::pair&lt;Key const, Mapped&gt; &gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose><simpara>
            An unordered associative container that associates unique keys with another value.<sbr/>
            将唯一值关联至另一个值的无序关联式容器。
          </simpara></purpose>
          <description>
            <para>Based on chapter 23 of
              <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">the working draft of the C++ standard [n2960]</ulink>.
              But without the updated rules for allocators.<sbr/>
              基于 <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">C++标准工作草案[n2690]</ulink>
              第23章。但不包含对分配器的最新规则。
            </para>
            <para><emphasis role="bold">Template Parameters 模板参数</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry><emphasis>Key</emphasis></entry>
                      <entry>Key must be Assignable and CopyConstructible.<sbr/>
                      Key 必须是可赋值和可复制构造的。</entry></row>
                    <row>
                      <entry><emphasis>Mapped</emphasis></entry>
                      <entry>Mapped must be CopyConstructible<sbr/>
                      Mapped 必须是可复制构造的。</entry></row>
                    <row>
                      <entry><emphasis>Hash</emphasis></entry>
                      <entry>A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type std::size_t.<sbr/>
                      一元函数对象类型，用作 <code>Key</code> 的散列函数。
                      它接受单个类型为 <code>Key</code> 的参数，返回类型为 std::size_t 的值。</entry></row>
                    <row>
                      <entry><emphasis>Pred</emphasis></entry>
                      <entry>A binary function object that implements an equivalence relation on values of type <code>Key</code>.
                        A binary function object that induces an equivalence relation on values of type Key.
                        It takes two arguments of type Key and returns a value of type bool.<sbr/>
                        二元函数对象，实现类型 <code>Key</code> 的等同性关系。
                        它接受两个类型为 Key 的参数，返回类型为 bool 的值。</entry></row>
                    <row>
                      <entry><emphasis>Alloc</emphasis></entry>
                      <entry>An allocator whose value type is the same as the container's value type.<sbr/>
                      分配器，它的值类型与容器的值类型相同。</entry></row></tbody></tgroup></informaltable></para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.<sbr/>
            容器中的元素存放在多个桶中。具有相同散列码的键存放在同一个桶中。</para>
            <para>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.<sbr/>
            桶的数量可以通过调用 insert 自动增加，或者调用 rehash 进行调整。</para>
          </description>
          <typedef name="key_type">
            <type>Key</type>
          </typedef>
          <typedef name="value_type">
            <type>std::pair&lt;Key const, Mapped&gt;</type>
          </typedef>
          <typedef name="mapped_type">
            <type>Mapped</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <purpose><simpara>lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <purpose><simpara>const lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An unsigned integral type.<sbr/>
              无符号整数类型。</para>
              <para><type>size_type</type> can represent any non-negative value of <type>difference_type</type>.<sbr/>
              <type>size_type</type> 可以表示 <type>difference_type</type> 的任一非负值。</para>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A signed integral type.<sbr/>
              有符号整数类型。</para>
              <para>Is identical to the difference type of <type>iterator</type> and <type>const_iterator</type>.<sbr/>
              与 <type>iterator</type> 和 <type>const_iterator</type> 的距离类型相同。</para>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A iterator whose value type is <type>value_type</type>. <sbr/>
              一个迭代器，它的值类型为 <type>value_type</type>。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
              <para>Convertible to <type>const_iterator</type>.<sbr/>
              可转换为 <type>const_iterator</type>。</para>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is <type>value_type</type>. <sbr/>
              一个常量迭代器，它的值类型为 <type>value_type</type>。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An iterator with the same value type, difference type and pointer and reference type as <type>iterator</type>.<sbr/>
              具有与 <type>iterator</type> 相同值类型、距离类型和指针、引用类型的迭代器。</para>
              <para>A local_iterator object can be used to iterate through a single bucket.<sbr/>
              local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator with the same value type, difference type and pointer and reference type as <type>const_iterator</type>.<sbr/>
              具有与 <type>iterator</type> 相同值类型、距离类型和指针、引用类型的常量迭代器。</para>
              <para>A const_local_iterator object can be used to iterate through a single bucket.<sbr/>
              const_local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <constructor specifiers="explicit">
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <postconditions>
              <code><methodname>size</methodname>() == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，最大负载因子为 1.0。</para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，
              最大负载因子为 1.0，并插入 [f,l) 的元素。</para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_map const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.<sbr/>
              复制构造函数。复制所含的元素、散列函数、谓词、最大负载因子和分配器。</para>
            </description>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_map &amp;&amp;</paramtype>
            </parameter>
            <description>
              <para>The move constructor.<sbr/>
              移动构造函数。</para>
            </description>
            <notes>
              <para>This is emulated on compilers without rvalue references.<sbr/>
              在不带右值引用的编译器上的模拟。</para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。
              </para>
            </requires>
          </constructor>
          <constructor specifiers="explicit">
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an empty container, using allocator <code>a</code>.<sbr/>
                构造一个空容器，使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <constructor>
            <parameter name="x">
              <paramtype>unordered_map const&amp;</paramtype>
            </parameter>
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an container, copying <code>x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.<sbr/>
                构造一个容器，复制 <code>x</code> 所含的元素、散列函数、谓词、最大负载因子，但使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <destructor>
            <notes>
              <para>The destructor is applied to every element, and all memory is deallocated<sbr/>
              对每个元素调用构造函数，并释放所有内存。</para>
            </notes>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_map const&amp;</paramtype>
            </parameter>
            <type>unordered_map&amp;</type>
            <description>
              <para>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.<sbr/>
              赋值操作符。复制所含的元素、散列函数、谓词、最大负载因子，但不复制分配器。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_map)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_map)</code> 的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </method>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_map &amp;&amp;</paramtype>
            </parameter>
            <type>unordered_map&amp;</type>
            <description>
              <para>The move assignment operator.<sbr/>
              移动赋值操作符。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_map)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_map)</code> 的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。
              </para>
            </requires>
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><methodname>size</methodname>() == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<methodname>begin</methodname>(), <methodname>end</methodname>())</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns><code><methodname>size</methodname>()</code> of the largest possible container.<sbr/>
              最大可能容器的 <code><methodname>size</methodname>()</code>。
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </method>
            <method name="cend" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator which refers to the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的 past-the-end 值。
              </returns>
            </method>
          </method-group>
          <method-group name="modifiers">
            <method name="emplace">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>std::pair&lt;iterator, bool&gt;</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中，当且仅当空器中没有相同键值的元素。</para>
              </description>
              <returns>
                <para>The bool component of the return type is true if an insert took place.<sbr/>
                如果插入成功，则返回类型的 bool 部分为 true。</para>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="emplace_hint">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中，当且仅当空器中没有相同键值的元素。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 
                支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>std::pair&lt;iterator, bool&gt;</type>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent key.<sbr/>
                插入 obj 到容器中，当且仅当空器中没有相同键值的元素。</para>
              </description>
              <returns>
                <para>The bool component of the return type is true if an insert took place.<sbr/>
                如果插入成功，则返回类型的 bool 部分为 true。</para>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent key.<sbr/>
                插入 obj 到容器中，当且仅当空器中没有相同键值的元素。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.<sbr/>
                如果插入成功，则迭代器指向新插入的元素。否则，指向具有相同键值的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 
                支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.<sbr/>
                插入一组元素到容器中。元素当且仅当空器中没有相同键值的元素时被插入。</para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                当插入单个元素时，如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <returns>
                <para>The iterator following <code>position</code> before the erasure.<sbr/>
                在删除前紧跟 <code>position</code> 的迭代器。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  When the number of elements is a lot smaller than the number of buckets
                  this function can be very inefficient as it has to search through empty
                  buckets for the next element, in order to return the iterator.
                  The method <methodname>quick_erase</methodname> is faster, but has yet
                  to be standardized.<sbr/>
                  当元素的数量远小于桶的数量时，这个函数会非常低效，因为它必须对空桶搜索下一个元素以返回该迭代器。
                  方法 <methodname>quick_erase</methodname> 会更快一些，但尚未标准化。
                </para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <description>
                <para>Erase all elements with key equivalent to <code>k</code>.<sbr/>
                删除所有键值等于 <code>k</code> 的元素。</para>
              </description>
              <returns>
                <para>The number of elements erased.<sbr/>
                被删除的元素数量。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
              </throws>
            </method>
            <method name="erase">
              <parameter name="first">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erases the elements in the range from <code>first</code> to <code>last</code>.<sbr/>
                删除从 <code>first</code> 到 <code>last</code> 的元素。</para>
              </description>
              <returns>
                <para>The iterator following the erased elements - i.e. <code>last</code>.<sbr/>
                紧随被删除元素之后的迭代器 - 即 <code>last</code>。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
            </method>
            <method name="quick_erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除所有键值等于 <code>k</code> 的元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is faster than <methodname>erase</methodname> as
                  it doesn't have to find the next element in the container -
                  a potentially costly operation.<sbr/>
                  这个方法快于 <methodname>erase</methodname>，因为它不需要在容器中查找下一个元素 - 这种查找可能很耗时间。
                </para>
                <para>
                  As it hasn't been standardized, it's likely that this may
                  change in the future.<sbr/>
                  由于该方法未被标准化，它可能会在以后有所变化。
                </para>
              </notes>
            </method>
            <method name="erase_return_void">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is now deprecated, use
                  <methodname>quick_return</methodname> instead. Although be
                  warned that as that isn't standardized yet, it could also
                  change.<sbr/>
                  该方法现在已不再使用，请用 <methodname>quick_return</methodname> 替代。不过这尚未标准化，可能会变。
                </para>
              </notes>
            </method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.<sbr/>
                删除容器中所有元素。</para>
              </description>
              <postconditions>
                <para><code><methodname>size</methodname>() == 0</code></para>
              </postconditions>
              <throws>
                <para>Never throws an exception.<sbr/>
                不会抛出。</para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype>unordered_map&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.<sbr/>
                如果分配器是相同的，则不会抛出，除非异常是从 <code>key_equal</code> 或 
                <code>hasher</code> 的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.<sbr/>
                  有关分配器不同时的行为的讨论，请见 
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.<sbr/>
              容器的散列函数。
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.<sbr/>
              容器的键值等同性谓词。
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <signature>
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.<sbr/>
                一个迭代器，指向键值等于 <code>k</code> 的元素，如果该元素不存在，返回 <code>b.end()</code>。</para>
              </returns>
              <notes><para>
                The templated overloads are a non-standard extensions which
                allows you to use a compatible hash function and equality
                predicate for a key of a different type in order to avoid
                an expensive type cast. In general, its use is not encouraged.<sbr/>
                这个模板化的重载是非标准化的扩展，使得你可以对不同类型的键使用兼容的散列函数和相等性谓词，
                以避免昂贵的类型转换。通常，并不鼓励使用。
              </para></notes>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to <code>k</code>.<sbr/>
                键值等于 <code>k</code> 的元素数量。</para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;const_iterator, const_iterator&gt;</type>
              </signature>
              <returns>
                <para>A range containing all elements with key equivalent to <code>k</code>.
                  If the container doesn't container any such elements, returns
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.<sbr/>
                  包含所有键值等于 <code>k</code> 的元素的区间。如果容器中没有这样的元素，返回 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>. 
                  </para>
              </returns>
            </overloaded-method>
            <method name="operator[]">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>mapped_type&amp;</type>
              <effects>
                <para>If the container does not already contain an elements with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code><sbr/>
                如果容器中没有包含键值等于 <code>k</code> 的元素，则插入值 
                <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code></para>
              </effects>
              <returns>
                <para>A reference to <code>x.second</code> where x is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code><sbr/>
                引向 <code>x.second</code> 的引用，其中 x 为容器中已有的元素，或者新插入的键值等于 <code>k</code> 的元素</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外的操作抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <overloaded-method name="at">
              <signature><type>Mapped&amp;</type>
                <parameter name="k"><paramtype>key_type const&amp;</paramtype></parameter></signature>
              <signature cv="const"><type>Mapped const&amp;</type>
                <parameter name="k"><paramtype>key_type const&amp;</paramtype></parameter></signature>
              <returns>
                <para>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.<sbr/>
                引向 <code>x.second</code> 的引用，其中 <code>x</code> 为键值等于 <code>k</code> 的(唯一)元素。</para>
              </returns>
              <throws>
                <para>An exception object of type <code>std::out_of_range</code> if no such element is present.<sbr/>
                如果这样的元素不存在，则抛出一个类型为 <code>std::out_of_range</code> 的异常对象。</para>
              </throws>
              <notes>
                <para>This is not specified in the draft standard, but that is probably an oversight. The issue has been raised in
                  <ulink url="http://groups.google.com/group/comp.std.c++/browse_thread/thread/ab7c22a868fd370b">comp.std.c++</ulink>.<sbr/>
                  这在标准草案中没有规定，不过这很可能是一个疏忽。该问题已经提交到 
                  <ulink url="http://groups.google.com/group/comp.std.c++/browse_thread/thread/ab7c22a868fd370b">comp.std.c++</ulink>.</para>
              </notes>
            </overloaded-method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.<sbr/>
                桶的数量。</para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.<sbr/>
                桶数量的上限。</para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para><code>n &lt; <methodname>bucket_count</methodname>()</code></para>
              </requires>
              <returns>
                <para>The number of elements in bucket <code>n</code>.<sbr/>
                桶 <code>n</code> 中的元素数量。</para>
              </returns>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key <code>k</code>.<sbr/>
                包含键值为 <code>k</code> 的元素的桶的索引。</para>
              </returns>
              <postconditions>
                <para>The return value is less than <code>bucket_count()</code><sbr/>
                返回值小于 <code>bucket_count()</code></para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的最后一个元素之后。</para>
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个常量局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </method>
            <method name="cend">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个常量局部迭代器，指向索引为 <code>n</code> 的桶中的最后一个元素之后。</para>
              </returns>
            </method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.<sbr/>
                每个桶中元素的平均数量。</para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.<sbr/>
                返回当前的最大负载因子。</para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para>Changes the container's maximum load factor, using <code>z</code> as a hint.<sbr/>
                修改容器的最大负载因子，以 <code>z</code> 为提示。</para>
              </effects>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.<sbr/>
                修改桶的数量，使得最少有 <code>n</code> 个桶，且负载因子小于最大负载因子。</para>
                <para>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.<sbr/>
                使迭代器失效，并会改变元素的顺序。指向元素的指针和引用不会失效。</para>
              </description>
              <throws>
                <para>The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.<sbr/>
                如果抛出异常，则该函数没有作用，除非异常是从容器的散列函数或比较函数中抛出的。</para>
              </throws>
            </method>
          </method-group>
          <free-function-group name="Equality Comparisons">
            <function name="operator==">
              <template>
                <template-type-parameter name="Key">
                </template-type-parameter>
                <template-type-parameter name="Mapped">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
            <function name="operator!=">
              <template>
                <template-type-parameter name="Key">
                </template-type-parameter>
                <template-type-parameter name="Mapped">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
          </free-function-group>
          <free-function-group name="swap">
            <function name="swap">
              <template>
                <template-type-parameter name="Key">
                </template-type-parameter>
                <template-type-parameter name="Mapped">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_map&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para><code>x.swap(y)</code></para>
              </effects>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>Hash</code> or <code>Pred</code>.<sbr/>
                如果分配器是相同的，则不会抛出异常，除非异常是从 <code>Hash</code> 或
                <code>Pred</code> 的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.<sbr/>
                  有关分配器不同时的行为的讨论，请见 
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </function>
          </free-function-group>
        </class>
        <class name="unordered_multimap">
          <template>
            <template-type-parameter name="Key">
            </template-type-parameter>
            <template-type-parameter name="Mapped">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Key&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Key&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;std::pair&lt;Key const, Mapped&gt; &gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose><simpara>
            An unordered associative container that associates  keys with another value. The same key can be stored multiple times.<sbr/>
            将键值关联至另一个值的无序关联式容器。相同的键值可以保存多次。
          </simpara></purpose>
          <description>
            <para>Based on chapter 23 of
              <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">the working draft of the C++ standard [n2960]</ulink>.
              But without the updated rules for allocators.<sbr/>
              基于 <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">C++标准工作草案[n2690]</ulink>
              第23章。但不包含对分配器的最新规则。
            </para>
            <para><emphasis role="bold">Template Parameters 模板参数</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry><emphasis>Key</emphasis></entry>
                      <entry>Key must be Assignable and CopyConstructible.<sbr/>
                      Key 必须是可赋值和可复制构造的。</entry></row>
                    <row>
                      <entry><emphasis>Mapped</emphasis></entry>
                      <entry>Mapped must be CopyConstructible<sbr/>
                      Mapped 必须是可复制构造的。</entry></row>
                    <row>
                      <entry><emphasis>Hash</emphasis></entry>
                      <entry>A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type std::size_t.<sbr/>
                      一元函数对象类型，用作 <code>Key</code> 的散列函数。它接受单个类型为 <code>Key</code> 的参数，
                      返回类型为 std::size_t 的值。</entry></row>
                    <row>
                      <entry><emphasis>Pred</emphasis></entry>
                      <entry>A binary function object that implements an equivalence relation on values of type <code>Key</code>.
                        A binary function object that induces an equivalence relation on values of type Key.
                        It takes two arguments of type Key and returns a value of type bool.<sbr/>
                        二元函数对象，实现类型 <code>Key</code> 的等同性关系。它接受两个类型为 Key 的参数，
                        返回类型为 bool 的值。</entry></row>
                    <row>
                      <entry><emphasis>Alloc</emphasis></entry>
                      <entry>An allocator whose value type is the same as the container's value type.<sbr/>
                      分配器，它的值类型与容器的值类型相同。</entry></row></tbody></tgroup></informaltable></para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.<sbr/>
            容器中的元素存放在多个桶中。具有相同散列码的键存放在同一个桶中，具有相同键值的元素会连续存放在一起。</para>
            <para>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.<sbr/>
            桶的数量可以通过调用 insert 自动增加，或者调用 rehash 进行调整。</para>
          </description>
          <typedef name="key_type">
            <type>Key</type>
          </typedef>
          <typedef name="value_type">
            <type>std::pair&lt;Key const, Mapped&gt;</type>
          </typedef>
          <typedef name="mapped_type">
            <type>Mapped</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <purpose><simpara>lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <purpose><simpara>const lvalue of <type>value_type</type>.</simpara></purpose>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An unsigned integral type.<sbr/>
              无符号整数类型。</para>
              <para><type>size_type</type> can represent any non-negative value of <type>difference_type</type>.<sbr/>
              <type>size_type</type> 可以表示 <type>difference_type</type> 的任一非负值。</para>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A signed integral type.<sbr/>
              有符号整数类型。</para>
              <para>Is identical to the difference type of <type>iterator</type> and <type>const_iterator</type>.<sbr/>
              与 <type>iterator</type> 和 <type>const_iterator</type> 的距离类型相同。</para>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A iterator whose value type is <type>value_type</type>. <sbr/>
              一个迭代器，它的值类型为 value_type。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
              <para>Convertible to <type>const_iterator</type>.<sbr/>
              可转换为 <type>const_iterator</type>。</para>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is <type>value_type</type>. <sbr/>
              一个常量迭代器，它的值类型为 value_type。</para>
              <para>The iterator category is at least a forward iterator.<sbr/>
              迭代器类别至少为前向迭代器。</para>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>An iterator with the same value type, difference type and pointer and reference type as <type>iterator</type>.<sbr/>
              具有与 <type>iterator</type> 相同值类型、距离类型和指针、引用类型的迭代器。</para>
              <para>A local_iterator object can be used to iterate through a single bucket.<sbr/>
              local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator with the same value type, difference type and pointer and reference type as <type>const_iterator</type>.<sbr/>
              具有与 <type>const_iterator</type> 相同值类型、距离类型和指针、引用类型的迭代器。</para>
              <para>A const_local_iterator object can be used to iterate through a single bucket.<sbr/>
              const_local_iterator 对象可用于遍历单个桶。</para>
            </description>
          </typedef>
          <constructor specifiers="explicit">
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <postconditions>
              <code><methodname>size</methodname>() == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，
              最大负载因子为 1.0。</para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><emphasis>implementation-defined</emphasis></default>
            </parameter>
            <parameter name="hf">
              <paramtype>hasher const&amp;</paramtype>
              <default>hasher()</default>
            </parameter>
            <parameter name="eq">
              <paramtype>key_equal const&amp;</paramtype>
              <default>key_equal()</default>
            </parameter>
            <parameter name="a">
              <paramtype>allocator_type const&amp;</paramtype>
              <default>allocator_type()</default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.<sbr/>
              构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，
              最大负载因子为 1.0，并插入 [f,l) 的元素。</para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_multimap const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.<sbr/>
              复制构造函数。复制所含的元素、散列函数、谓词、最大负载因子和分配器。</para>
            </description>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </constructor>
          <constructor>
            <parameter>
              <paramtype>unordered_multimap &amp;&amp;</paramtype>
            </parameter>
            <description>
              <para>The move constructor.<sbr/>
              移动构造函数。</para>
            </description>
            <notes>
              <para>This is emulated on compilers without rvalue references.<sbr/>
              在不带右值引用的编译器上的模拟。</para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。
              </para>
            </requires>
          </constructor>
          <constructor specifiers="explicit">
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an empty container, using allocator <code>a</code>.<sbr/>
                构造一个空容器，使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <constructor>
            <parameter name="x">
              <paramtype>unordered_multimap const&amp;</paramtype>
            </parameter>
            <parameter name="a">
              <paramtype>Allocator const&amp;</paramtype>
            </parameter>
            <description>
                <para>Constructs an container, copying <code>x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.<sbr/>
                构造一个容器，复制 <code>x</code> 所含的元素、散列函数、谓词、最大负载因子，但使用分配器 <code>a</code>。</para>
            </description>
          </constructor>
          <destructor>
            <notes>
              <para>The destructor is applied to every element, and all memory is deallocated<sbr/>
              对每个元素调用构造函数，并释放所有内存。</para>
            </notes>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_multimap const&amp;</paramtype>
            </parameter>
            <type>unordered_multimap&amp;</type>
            <description>
              <para>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.<sbr/>
              赋值操作符。复制所含的元素、散列函数、谓词、最大负载因子，但不复制分配器。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_multimap)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_multimap)</code>
                的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para><code>value_type</code> is copy constructible<sbr/>
              <code>value_type</code> 为可复制构造的</para>
            </requires>
          </method>
          <method name="operator=">
            <parameter>
              <paramtype>unordered_multimap &amp;&amp;</paramtype>
            </parameter>
            <type>unordered_multimap&amp;</type>
            <description>
              <para>The move assignment operator.<sbr/>
              移动赋值操作符。</para>
            </description>
            <notes>
              <para>
                On compilers without rvalue references, there is a single assignment
                operator with the signature <code>operator=(unordered_multimap)</code>
                in order to emulate move semantics.<sbr/>
                在没有右值引用的编译器上，有一个署名为 <code>operator=(unordered_multimap)</code>
                的赋值操作符，用于模拟移动语义。
              </para>
            </notes>
            <requires>
              <para>
                <code>value_type</code> is move constructible.
                (TODO: This is not actually required in this implementation).<sbr/>
                <code>value_type</code> 是可移动构造的。(待办：在本实现中并不真正要求)。
              </para>
            </requires>
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><methodname>size</methodname>() == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<methodname>begin</methodname>(), <methodname>end</methodname>())</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns><code><methodname>size</methodname>()</code> of the largest possible container.<sbr/>
              最大可能容器的 <code><methodname>size</methodname>()</code>。 
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.<sbr/>
              一个迭代器，引向容器的 past-the-end 值。
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。
              </returns>
            </method>
            <method name="cend" cv="const">
              <type>const_iterator</type>
              <returns>A constant iterator which refers to the past-the-end value for the container.<sbr/>
              一个常量迭代器，引向容器的 past-the-end 值。
              </returns>
            </method>
          </method-group>
          <method-group name="modifiers">
            <method name="emplace">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="emplace_hint">
              <template>
                <template-type-parameter name="Args" pack="1">
                </template-type-parameter>
              </template>
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="args" pack="1">
                <paramtype>Args&amp;&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts an object, constructed with the arguments <code>args</code>, in the container.<sbr/>
                插入一个从参数 <code>args</code> 构造的对象到容器中。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 
                支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
                <para>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.<sbr/>
                      如果编译器不支持可变数量模板参数或右值引用，则模拟至最多10个参数，且不支持右值引用或转移语义。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container.<sbr/>
                插入 obj 到容器中。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <parameter name="hint">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="obj">
                <paramtype>value_type const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container.<sbr/>
                插入 obj 到容器中。</para>
                <para>hint is a suggestion to where the element should be inserted.<sbr/>
                hint 是一个插入元素的建议点。</para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.<sbr/>
                一个迭代器，指向新插入的元素。</para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. <sbr/>
                标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 
                支持的唯一方法是，指向具有相同值的元素。</para>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container.<sbr/>
                插入一组元素到容器中。</para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.<sbr/>
                当插入单个元素时，如果从对 <code>hasher</code> 的调用以外抛出异常，该函数没有作用。</para>
              </throws>
              <notes>
                <para>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<sbr/>
                可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</para>
                <para>Pointers and references to elements are never invalidated.<sbr/>
                指向元素的指针和引用不会失效。</para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <returns>
                <para>The iterator following <code>position</code> before the erasure.<sbr/>
                在删除前紧跟 <code>position</code> 的迭代器。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  When the number of elements is a lot smaller than the number of buckets
                  this function can be very inefficient as it has to search through empty
                  buckets for the next element, in order to return the iterator.
                  The method <methodname>quick_erase</methodname> is faster, but has yet
                  to be standardized.<sbr/>
                  当元素的数量远小于桶的数量时，这个函数会非常低效，因为它必须对空桶搜索下一个元素以返回该迭代器。
                  方法 <methodname>quick_erase</methodname> 会更快一些，但尚未标准化。
                </para>
              </notes>
            </method>
            <method name="erase">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <description>
                <para>Erase all elements with key equivalent to <code>k</code>.<sbr/>
                删除所有键值等于 <code>k</code> 的元素。</para>
              </description>
              <returns>
                <para>The number of elements erased.<sbr/>
                被删除的元素数量。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
              </throws>
            </method>
            <method name="erase">
              <parameter name="first">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Erases the elements in the range from <code>first</code> to <code>last</code>.<sbr/>
                删除从 <code>first</code> 到 <code>last</code> 的元素。</para>
              </description>
              <returns>
                <para>The iterator following the erased elements - i.e. <code>last</code>.<sbr/>
                紧随被删除元素之后的迭代器 - 即 <code>last</code>。</para>
              </returns>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
            </method>
            <method name="quick_erase">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is faster than <methodname>erase</methodname> as
                  it doesn't have to find the next element in the container -
                  a potentially costly operation.<sbr/>
                  这个方法快于 <methodname>erase</methodname>，因为它不需要在容器中查找下一个元素 - 这种查找可能很耗时间。
                </para>
                <para>
                  As it hasn't been standardized, it's likely that this may
                  change in the future.<sbr/>
                  由于该方法未被标准化，它可能会在以后有所变化。
                </para>
              </notes>
            </method>
            <method name="erase_return_void">
              <parameter name="position">
                <paramtype>const_iterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Erase the element pointed to by <code>position</code>.<sbr/>
                删除 <code>position</code> 所指元素。</para>
              </description>
              <throws>
                <para>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<sbr/>
                仅当从 <code>hasher</code> 或 <code>key_equal</code> 抛出异常时抛出该异常。</para>
                <para>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.<sbr/>
                在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</para>
              </throws>
              <notes>
                <para>
                  This method is now deprecated, use
                  <methodname>quick_return</methodname> instead. Although be
                  warned that as that isn't standardized yet, it could also
                  change.<sbr/>
                  该方法现在已不再使用，请用 <methodname>quick_return</methodname> 替代。不过这尚未标准化，可能会变。
                </para>
              </notes>
            </method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.<sbr/>
                删除容器中所有元素。</para>
              </description>
              <postconditions>
                <para><code><methodname>size</methodname>() == 0</code></para>
              </postconditions>
              <throws>
                <para>Never throws an exception.<sbr/>
                不会抛出。</para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype>unordered_multimap&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.<sbr/>
                如果分配器是相同的，则不会抛出，除非异常是从 <code>key_equal</code> 或
                <code>hasher</code> 的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.<sbr/>
                  有关分配器不同时的行为的讨论，请见 
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.<sbr/>
              容器的散列函数。
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.<sbr/>
              容器的键值等同性谓词。
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <signature>
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <template>
                  <template-type-parameter name="CompatibleKey"/>
                  <template-type-parameter name="CompatibleHash"/>
                  <template-type-parameter name="CompatiblePredicate"/>
                </template>
                <parameter name="k">
                  <paramtype>CompatibleKey const&amp;</paramtype>
                </parameter>
                <parameter name="hash">
                  <paramtype>CompatibleHash const&amp;</paramtype>
                </parameter>
                <parameter name="eq">
                  <paramtype>CompatiblePredicate const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.<sbr/>
                一个迭代器，指向键值等于 <code>k</code> 的元素，如果该元素不存在，返回 <code>b.end()</code>。</para>
              </returns>
              <notes><para>
                The templated overloads are a non-standard extensions which
                allows you to use a compatible hash function and equality
                predicate for a key of a different type in order to avoid
                an expensive type cast. In general, its use is not encouraged.<sbr/>
                这个模板化的重载是非标准化的扩展，使得你可以对不同类型的键使用兼容的散列函数和相等性谓词，
                以避免昂贵的类型转换。通常，并不鼓励使用。
              </para></notes>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to <code>k</code>.<sbr/>
                键值等于 <code>k</code> 的元素数量。</para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype>key_type const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;const_iterator, const_iterator&gt;</type>
              </signature>
              <returns>
                <para>A range containing all elements with key equivalent to <code>k</code>.
                  If the container doesn't container any such elements, returns
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.<sbr/>
                  包含所有键值等于 <code>k</code> 的元素的区间。如果容器中没有这样的元素，返回 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.
                  </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.<sbr/>
                桶的数量。</para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.<sbr/>
                桶数量的上限。</para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para><code>n &lt; <methodname>bucket_count</methodname>()</code></para>
              </requires>
              <returns>
                <para>The number of elements in bucket <code>n</code>.<sbr/>
                桶 <code>n</code> 中的元素数量。</para>
              </returns>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype>key_type const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key <code>k</code>.<sbr/>
                包含键值为 <code>k</code> 的元素的桶的索引。</para>
              </returns>
              <postconditions>
                <para>The return value is less than <code>bucket_count()</code><sbr/>
                返回值小于 <code>bucket_count()</code></para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个局部迭代器，指向索引为 <code>n</code> 的桶中的最后一个元素之后。</para>
              </returns>
            </overloaded-method>
            <method name="cbegin" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the first element in the bucket with index <code>n</code>.<sbr/>
                一个常量局部迭代器，指向索引为 <code>n</code> 的桶中的第一个元素。</para>
              </returns>
            </method>
            <method name="cend">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>const_local_iterator</type>
              <requires>
                <para><code>n</code> shall be in the range <code>[0, bucket_count())</code>.<sbr/>
                <code>n</code> 应位于区间 <code>[0, bucket_count())</code>.</para>
              </requires>
              <returns>
                <para>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.<sbr/>
                一个常量局部迭代器，指向索引为 <code>n</code> 的桶中的最后一个元素之后。</para>
              </returns>
            </method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.<sbr/>
                每个桶中元素的平均数量。</para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.<sbr/>
                返回当前的最大负载因子。</para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para>Changes the container's maximum load factor, using <code>z</code> as a hint.<sbr/>
                修改容器的最大负载因子，以 <code>z</code> 为提示。</para>
              </effects>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.<sbr/>
                修改桶的数量，使得最少有 <code>n</code> 个桶，且负载因子小于最大负载因子。</para>
                <para>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.<sbr/>
                使迭代器失效，并会改变元素的顺序。指向元素的指针和引用不会失效。</para>
              </description>
              <throws>
                <para>The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.<sbr/>
                如果抛出异常，则该函数没有作用，除非异常是从容器的散列函数或比较函数中抛出的。</para>
              </throws>
            </method>
          </method-group>
          <free-function-group name="Equality Comparisons">
            <function name="operator==">
              <template>
                <template-type-parameter name="Key">
                </template-type-parameter>
                <template-type-parameter name="Mapped">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_multimap&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_multimap&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
            <function name="operator!=">
              <template>
                <template-type-parameter name="Key">
                </template-type-parameter>
                <template-type-parameter name="Mapped">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_multimap&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_multimap&lt;Key, Mapped, Hash, Pred, Alloc&gt; const&amp;</paramtype>
              </parameter>
              <type>bool</type>
              <notes>
                <para>This is a boost extension.<sbr/>
                这是 boost 的扩展。</para>
                <para>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.<sbr/>
                    如果两个容器不具有等效的相等性谓词，则行为未定义。</para>
              </notes>
            </function>
          </free-function-group>
          <free-function-group name="swap">
            <function name="swap">
              <template>
                <template-type-parameter name="Key">
                </template-type-parameter>
                <template-type-parameter name="Mapped">
                </template-type-parameter>
                <template-type-parameter name="Hash">
                </template-type-parameter>
                <template-type-parameter name="Pred">
                </template-type-parameter>
                <template-type-parameter name="Alloc">
                </template-type-parameter>
              </template>
              <parameter name="x">
                <paramtype>unordered_multimap&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <parameter name="y">
                <paramtype>unordered_multimap&lt;Key, Mapped, Hash, Pred, Alloc&gt;&amp;</paramtype>
              </parameter>
              <type>void</type>
              <effects>
                <para><code>x.swap(y)</code></para>
              </effects>
              <throws>
                <para>If the allocators are equal, doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>Hash</code> or <code>Pred</code>.<sbr/>
                如果分配器是相同的，则不会抛出异常，除非异常是从 <code>Hash</code> 或 
                <code>Pred</code> 的复制构造函数或复制赋值操作符抛出的。</para>
              </throws>
              <notes>
                <para>For a discussion of the behavior when allocators aren't equal see
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</link>.r/>
                  有关分配器不同时的行为的讨论，请见 
                  <link linkend="unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</link>。</para>
              </notes>
            </function>
          </free-function-group>
        </class>
      </namespace>
    </header>
  </library-reference>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><!--
                        (C) Jeremy Siek 2001.
                     (C) Gennaro Prota 2003-2004.

       Distributed under the Boost Software License, Version 1.0.
          (See accompanying file LICENSE_1_0.txt or copy at
                http://www.boost.org/LICENSE_1_0.txt)
 --><!--
   Copyright (c) 1996-1999
   Silicon Graphics Computer Systems, Inc.

   Permission to use, copy, modify, distribute and sell this software
   and its documentation for any purpose is hereby granted without fee,
   provided that the above copyright notice appears in all copies and
   that both that copyright notice and this permission notice appear
   in supporting documentation.  Silicon Graphics makes no
   representations about the suitability of this software for any
   purpose.  It is provided "as is" without express or implied warranty.

   Copyright (c) 1994
   Hewlett-Packard Company

   Permission to use, copy, modify, distribute and sell this software
   and its documentation for any purpose is hereby granted without fee,
   provided that the above copyright notice appears in all copies and
   that both that copyright notice and this permission notice appear
   in supporting documentation.  Hewlett-Packard Company makes no
   representations about the suitability of this software for any
   purpose.  It is provided "as is" without express or implied warranty.

  -->
<title>dynamic_bitset&lt;Block, Allocator&gt;</title></head>





<body alink="#003300" bgcolor="#ffffff" link="#006600" text="#000000" vlink="#7c7f87">
<img src="../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">

<p><!--end header-->
<br>
</p>

<!-- BEGIN TODO
TODO:
<ul>
 <li> ask to Jeremy about reference::operator&amp; and about
   making reference itself private</li>
 <li>check the whole synopsis against code changes </li>
 <li>document intersects() after we reach consensus</li>
</ul>
<br>
Note:
   Other things to do are marked by "[gps]"
END TODO -->


<h1>dynamic_bitset&lt;Block, Allocator&gt;</h1>

<h2>目录</h2>

<dl class="index">
<dt><a href="#description">Description（描述）</a></dt>

<dt><a href="#synopsis">Synopsis（概要）</a></dt>

<dt><a href="#definitions">Definitions（定义）</a></dt>

<dt><a href="#examples">Examples（示例）</a></dt>

<dt><a href="#rationale">Rationale（基本原理）</a></dt>

<dt><a href="#header-files">Header Files（头文件）</a></dt>

<dt><a href="#template-parameters">Template Parameters（模板参数）</a></dt>

<dt><a href="#concepts-modeled">Concepts modeled（概念原型）</a></dt>

<dt><a href="#type-requirements">Type requirements（类型需求）</a></dt>

<dt><a href="#public-base-classes">Public base classes（公有基类）</a></dt>

<dt><a href="#nested-type-names">Nested type names（嵌套类型名）</a></dt>

<dt><a href="#public-data-members">Public data members（公有数据成员）</a></dt>

<dt><a href="#constructors">Constructors（构造函数）</a></dt>

<dt><a href="#destructor">Destructor（析构函数）</a></dt>

<dt><a href="#member-functions">Member functions（成员函数）</a></dt>

<dt><a href="#non-member-functions">Non-member functions（非成员函数）</a></dt>

<dt><a href="#exception-guarantees">Exception guarantees（异常保证）</a></dt>

<dt><a href="#changes-from-previous-ver"><b>Changes from previous version(s)（版本变化）</b></a></dt>

<dt><a href="#see-also">See also（参见）</a></dt>

<dt><a href="#acknowledgements">Acknowledgements（感谢）</a></dt>
</dl>

<h3><a name="description">Description（描述）</a></h3>

<p><tt>dynamic_bitset</tt> 类表示一组二进制位。它通过 <tt>operator[]</tt> 提供对单独二进制位的值的访问，并提供了可以应用于内建整数类型的全部位操作符，比如 <tt>operator&amp;</tt> 和 <tt>operator&lt;&lt;</tt>。组内的二进制位数目在运行期通过 <tt>dynamic_bitset</tt> 的构造函数的一个参数指定。</p>

<p><tt>dynamic_bitset</tt> 类和 <a href="http://www.sgi.com/tech/stl/bitset.html"><tt>std::bitset</tt></a> 类几乎相同。区别在于 <tt>dynamic_bitset</tt> 的大小（二进制位的数目）是在运行期 <tt>dynamic_bitset</tt> 对象的构造过程中指定的，而 <tt>std::bitset</tt> 的大小是在编译期由一个整型模板参数指定。</p>

<p><tt>dynamic_bitset</tt> 的设计要解决的主要问题是表示一个有限集合的子集。每一个二进制位表示有限集合中的一个元素是否在子集中。这样一来，<tt>dynamic_bitset</tt> 的位操作，比如 <tt>operator&amp;</tt> 和 <tt>operator|</tt>，就对应于相应的集合操作，比如交集和并集。</p>

<h3><a name="synopsis">Synopsis（概要）</a></h3>

<pre>namespace boost {<br><br>template &lt;typename Block, typename Allocator&gt;<br>class dynamic_bitset<br>{<br>public:<br>    typedef Block <a href="#block_type">block_type</a>;<br>    typedef Allocator <a href="#allocator_type">allocator_type</a>;<br>    typedef <i>implementation-defined</i> <a href="#size_type">size_type</a>;<br>        <br>    static const int <a href="#bits_per_block">bits_per_block</a> = <i>implementation-defined</i>;<br>    static const size_type <a href="#npos">npos</a> = <i>implementation-defined</i>;<br><br>    class <a href="#reference">reference</a>
    {
        void operator&amp;(); // not defined
    public:
        // An automatically generated copy constructor.

        reference&amp; operator=(bool value);
        reference&amp; operator=(const reference&amp; rhs);

        reference&amp; operator|=(bool value);
        reference&amp; operator&amp;=(bool value);
        reference&amp; operator^=(bool value);
        reference&amp; operator-=(bool value);

        bool operator~() const;
        operator bool() const;
        reference&amp; flip();
    };
    typedef bool <a href="#const_reference">const_reference</a>;<br><br>    explicit <a href="#cons1">dynamic_bitset</a>(const Allocator&amp; alloc = Allocator());<br><br>    explicit <a href="#cons2">dynamic_bitset</a>(size_type num_bits, unsigned long value = 0,<br>                            const Allocator&amp; alloc = Allocator());<br><br>    template &lt;typename CharT, typename Traits, typename Alloc&gt;<br>    explicit <a href="#cons3">dynamic_bitset</a>(const std::basic_string&lt;CharT, Traits, Alloc&gt;&amp; s,<br>        typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type pos = 0,<br>        typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type n = std::basic_string&lt;CharT, Traits, Alloc&gt;::npos,<br>        const Allocator&amp; alloc = Allocator());<br><br>    template &lt;typename BlockInputIterator&gt;<br>    <a href="#cons4">dynamic_bitset</a>(BlockInputIterator first, BlockInputIterator last,<br>                   const Allocator&amp; alloc = Allocator());<br><br>    <a href="#cons5">dynamic_bitset</a>(const dynamic_bitset&amp; b);<br><br>    void <a href="#swap">swap</a>(dynamic_bitset&amp; b);<br><br>    dynamic_bitset&amp; <a href="#assign">operator=</a>(const dynamic_bitset&amp; b);<br><br>    allocator_type <a href="#get_allocator">get_allocator()</a> const;<br><br>    void <a href="#resize">resize</a>(size_type num_bits, bool value = false);<br>    void <a href="#clear">clear</a>();<br>    void <a href="#push_back">push_back</a>(bool bit);<br>    void <a href="#append1">append</a>(Block block);<br>    template &lt;typename BlockInputIterator&gt;<br>    void <a href="#append2">append</a>(BlockInputIterator first, BlockInputIterator last);<br><br>    dynamic_bitset&amp; <a href="#op-and-assign">operator&amp;=</a>(const dynamic_bitset&amp; b);<br>    dynamic_bitset&amp; <a href="#op-or-assign">operator|=</a>(const dynamic_bitset&amp; b);<br>    dynamic_bitset&amp; <a href="#op-xor-assign">operator^=</a>(const dynamic_bitset&amp; b);<br>    dynamic_bitset&amp; <a href="#op-sub-assign">operator-=</a>(const dynamic_bitset&amp; b);<br>    dynamic_bitset&amp; <a href="#op-sl-assign">operator&lt;&lt;=</a>(size_type n);<br>    dynamic_bitset&amp; <a href="#op-sr-assign">operator&gt;&gt;=</a>(size_type n);<br>    dynamic_bitset <a href="#op-sl">operator&lt;&lt;</a>(size_type n) const;<br>    dynamic_bitset <a href="#op-sr">operator&gt;&gt;</a>(size_type n) const;<br><br>    dynamic_bitset&amp; <a href="#set2">set</a>(size_type n, bool val = true);<br>    dynamic_bitset&amp; <a href="#set1">set</a>();<br>    dynamic_bitset&amp; <a href="#reset2">reset</a>(size_type n);<br>    dynamic_bitset&amp; <a href="#reset1">reset</a>();<br>    dynamic_bitset&amp; <a href="#flip2">flip</a>(size_type n);<br>    dynamic_bitset&amp; <a href="#flip1">flip</a>();<br>    bool <a href="#test">test</a>(size_type n) const;<br>    bool <a href="#any">any</a>() const;<br>    bool <a href="#none">none</a>() const;<br>    dynamic_bitset <a href="#op-not">operator~</a>() const;<br>    size_type <a href="#count">count</a>() const;<br><br>    reference <a href="#bracket">operator[]</a>(size_type pos);<br>    bool <a href="#const-bracket">operator[]</a>(size_type pos) const;<br><br>    unsigned long <a href="#to_ulong">to_ulong</a>() const;<br><br>    size_type <a href="#size">size</a>() const;<br>    size_type <a href="#num_blocks">num_blocks</a>() const;<br>    size_type <a href="#max_size">max_size</a>() const;<br>    bool <a href="#empty">empty</a>() const;<br><br>    bool <a href="#is_subset_of">is_subset_of</a>(const dynamic_bitset&amp; a) const;<br>    bool <a href="#is_proper_subset_of">is_proper_subset_of</a>(const dynamic_bitset&amp; a) const;<br><br>    size_type <a href="#find_first">find_first</a>() const;<br>    size_type <a href="#find_next">find_next</a>(size_type pos) const;<br><br><br><br>};<br><br>template &lt;typename B, typename A&gt;<br>bool <a href="#op-equal">operator==</a>(const dynamic_bitset&lt;B, A&gt;&amp; a, const dynamic_bitset&lt;B, A&gt;&amp; b);<br><br>template &lt;typename Block, typename Allocator&gt;<br>bool <a href="#op-not-equal">operator!=</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);<br><br>template &lt;typename B, typename A&gt;<br>bool <a href="#op-less">operator&lt;</a>(const dynamic_bitset&lt;B, A&gt;&amp; a, const dynamic_bitset&lt;B, A&gt;&amp; b);<br><br>template &lt;typename Block, typename Allocator&gt;<br>bool <a href="#op-less-equal">operator&lt;=</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);<br><br>template &lt;typename Block, typename Allocator&gt;<br>bool <a href="#op-greater">operator&gt;</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);<br><br>template &lt;typename Block, typename Allocator&gt;<br>bool <a href="#op-greater-equal">operator&gt;=</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);<br><br>template &lt;typename Block, typename Allocator&gt;<br>dynamic_bitset&lt;Block, Allocator&gt;<br><a href="#op-and">operator&amp;</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);<br><br>template &lt;typename Block, typename Allocator&gt;<br>dynamic_bitset&lt;Block, Allocator&gt;<br><a href="#op-or">operator|</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);<br><br>template &lt;typename Block, typename Allocator&gt;<br>dynamic_bitset&lt;Block, Allocator&gt;<br><a href="#op-xor">operator^</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);<br><br>template &lt;typename Block, typename Allocator&gt;<br>dynamic_bitset&lt;Block, Allocator&gt;<br><a href="#op-sub">operator-</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);<br><br>template &lt;typename Block, typename Allocator, typename CharT, typename Alloc&gt;<br>void <a href="#to_string">to_string</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b,<br>          std::basic_string&lt;CharT, Alloc&gt;&amp; s);<br><br>template &lt;typename Block, typename Allocator, typename BlockOutputIterator&gt;<br>void <a href="#to_block_range">to_block_range</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b,<br>                    BlockOutputIterator result);<br><br>template &lt;typename CharT, typename Traits, typename Block, typename Allocator&gt;<br>std::basic_ostream&lt;CharT, Traits&gt;&amp;<br><a href="#op-out">operator&lt;&lt;</a>(std::basic_ostream&lt;CharT, Traits&gt;&amp; os, const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);<br><br>template &lt;typename CharT, typename Traits, typename Block, typename Allocator&gt;<br>std::basic_istream&lt;CharT, Traits&gt;&amp;<br><a href="#op-in">operator&gt;&gt;</a>(std::basic_istream&lt;CharT, Traits&gt;&amp; is, dynamic_bitset&lt;Block, Allocator&gt;&amp; b);<br><br>} // namespace boost<br></pre>

<h3><a name="definitions">Definitions（定义）</a></h3>

<p>每一个二进制位代表布尔值 true 或者 false（1 或者 0）。<i>set</i> 一个二进制位就是将它赋值为 1。<i>clear</i> 或者 <i>reset</i> 一个二进制位就是将它赋值为 0。<i>flip</i> 一个二进制位就是如果它的值为 0 就变为 1，如果为 1 就变为 0。每一个二进制位有一个非负的 <i>position</i>。一个 bitset <tt>x</tt> 包含 <tt>x.size()</tt> 个二进制位，每一个二进制位被分配在区间 <tt>[0,x.size())</tt> 中一个唯一的 position。position 0 的那个二进制位被称为 <i>least significant bit</i>，而 position <tt>size() - 1</tt> 的是 <i>most significant bit</i>。当将一个 <tt>dynamic_bitset</tt> 实例变换为 unsigned long <tt>n</tt>，或从 unsigned long <tt>n</tt> 变换为一个 <tt>dynamic_bitset</tt> 实例时，bitset 中 position <tt>i</tt> 的二进制位的值与 <tt>(n &gt;&gt; i) &amp; 1</tt> 相同。</p>

<h3><a name="examples">Examples（示例）</a></h3>


<p><a href="./example/example1.cpp">Example 1</a> (设置并读出一些二进制位) </p>
<p><a href="./example/example2.cpp">Example 2</a> (从整数创建 bitsets) </p>
<p><a href="./example/example3.cpp">Example 3</a> (执行输入/输出和一些位操作)。<br></p><h3><a name="rationale">Rationale（基本原理）</a></h3>

<tt>dynamic_bitset</tt> 不是<a href="http://www.sgi.com/tech/stl/Container.html">容器</a>，不提供迭代器，是因为以下原因：

<ol></ol><ul><li>一个带有 proxy <tt>reference</tt> type（代理引用类型）的容器不能履行 C++ 标准中指定的容器的需求（除非有人诉诸怪异的迭代器语义）。<tt>std::vector&lt;bool&gt;</tt> 有一个 proxy <tt>reference</tt> type（代理引用类型）而不能履行容器的需求，并因此导致很多问题。一个常见问题是当有人试图将 <tt>std::vector&lt;bool&gt;</tt> 的迭代器用于一个诸如 <tt>std::search</tt> 这样的标准算法时。<tt>std::search</tt> 要求迭代器必须是一个 <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator（前向迭代器）</a>，但是 <tt>std::vector&lt;bool&gt;::iterator</tt> 由于 proxy reference（代理引用）而不符合这个要求。根据不同的实现，由于这样的误用，它们可能是或不是一个编译错误甚至是运行期错误。对这个问题的更深的讨论请参见 Scott Meyers 的 <i>Effective STL</i>。所以 <tt>dynamic_bitset</tt> 为避免这样的问题而不假装是一个容器。</li></ul><ol>
</ol>

<p>有些人更喜欢用名字 "toggle" 而不是 "flip"。选择名字 "flip" 是因为它是 <a href="http://www.sgi.com/tech/stl/bitset.html"><tt>std::bitset</tt></a> 中使用的名字。实际上，<tt>dynamic_bitset</tt> 中大多数函数名字的选择都是因为这个原因。</p>

<p>当一个前提条件被违反的时候，<tt>dynamic_bitset</tt> 不抛出异常（就像 <tt>std::bitset</tt> 所做的）。代之以使用 <tt>assert</tt>。关于这一点的解释参见 <a href="../../more/error_handling.html">Error and Exception Handling</a> 的指导方针。</p>

<h3><a name="header-files">Header Files（头文件）</a></h3>

<p>类 <tt>dynamic_bitset</tt> 被定义在头文件 <a href="../../boost/dynamic_bitset.hpp">boost/dynamic_bitset.hpp</a> 中。而且，头文件 <a href="../../boost/dynamic_bitset_fwd.hpp">boost/dynamic_bitset_fwd.hpp</a> 中有一个 <tt>dynamic_bitset</tt> 的前向声明。</p>

<h3><a name="template-parameters">Template parameters（模板参数）</a></h3>

<table summary="Describes the meaning of the template parameters and lists their corresponding default arguments" border="1">
<tbody><tr>
<th>参数</th>
<th>说明</th>
<th>缺省</th>
</tr>

<tr>
<td valign="top"><tt>Block</tt> </td>
<td valign="top">存储在二进制位中的整数类型。</td>
<td valign="top"><tt>unsigned long</tt> </td>
</tr>

<tr>
<td valign="top"><tt>Allocator</tt> </td>
<td valign="top">用于所有内部内存管理的分配器类型。</td>
<td valign="top"><tt>std::allocator&lt;Block&gt;</tt> </td>
</tr>
</tbody></table>

<h3><a name="concepts-modeled">Concepts Modeled（概念原型）</a></h3>

<a href="http://www.sgi.com/tech/stl/Assignable.html">Assignable</a>, <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">Default Constructible</a>, <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>, <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">LessThan Comparable</a>.

<h3><a name="type-requirements">Type requirements（类型需求）</a></h3>

<tt>Block</tt> 是一个无符号整数类型。<tt>Allocator</tt> 满足一个分配器的标准需求。

<h3><a name="public-base-classes">Public base classes（公有基类）</a></h3>

无。

<h3><a name="nested-type-names">Nested type names（嵌套类型名）</a></h3>

<hr>
<pre><a name="reference">dynamic_bitset::reference</a>
</pre>

<p>一个行为类似引向一个单独二进制位的引用的代理类。它包含一个赋值操作符，一个到 <tt>bool</tt> 的转换，一个 <tt>operator~</tt>，和一个成员函数 <tt>flip</tt>。它仅仅作为 <tt>dynamic_bitset</tt> 的 <tt>operator[]</tt> 的一个辅助类而存在。下表描述了对 <tt>reference</tt> 类型的合法的操作。假设 <tt>b</tt> 是一个 <tt>dynamic_bitset</tt> 的实例，<tt>i, j</tt> 是 <tt>size_type</tt> 而且在区间 <tt>[0,b.size())</tt> 中。还有，注意，当我们写 <tt>b[i]</tt> 时，我们的意思是一个由 <tt>b[i]</tt> 初始化的类型 <tt>reference</tt> 的对象。变量 <tt>x</tt> 是一个 <tt>bool</tt>。</p>

<table summary="Semantics of several expressions involving usage of dynamic_bitset::reference" border="1">
<tbody><tr>
<th>表达式</th>
<th>语义</th>
</tr>

<tr>
<td><tt>x = b[i]</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位赋给 <tt>x</tt>。</td>
</tr>

<tr>
<td><tt>(bool)b[i]</tt></td>
<td>返回 <tt>b</tt> 的第 i 个二进制位。</td>
</tr>

<tr>
<td><tt>b[i] = x</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位设置为 <tt>x</tt>，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] |= x</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位和 <tt>x</tt> 的值做或操作，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] &amp;= x</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位和 <tt>x</tt> 的值做与操作，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] ^= x</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位和 <tt>x</tt> 的值做异或操作，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] -= x</tt></td>
<td>如果 <tt>x==true</tt>，清空 <tt>b</tt> 的第 i 个二进制位。返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] = b[j]</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位设置为 <tt>b</tt> 的第 j 个二进制位的值，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] |= b[j]</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位和 <tt>b</tt> 的第 j 个二进制位做或操作，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] &amp;= b[j]</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位和 <tt>b</tt> 的第 j 个二进制位做与操作，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] ^= b[j]</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位和 <tt>b</tt> 的第 j 个二进制位做异或操作，并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>b[i] -= b[j]</tt></td>
<td>如果 <tt>b</tt> 的第 j 个二进制位被设置，清空 <tt>b</tt> 的第 i 个二进制位。并返回 <tt>b[i]</tt>。</td>
</tr>

<tr>
<td><tt>x = ~b[i]</tt></td>
<td>将 <tt>b</tt> 的第 i 个二进制位的反赋给 <tt>x</tt>。</td>
</tr>

<tr>
<td><tt>(bool)~b[i]</tt></td>
<td>返回 <tt>b</tt> 的第 i 个二进制位的反。</td>
</tr>

<tr>
<td><tt>b[i].flip()</tt> </td>
<td>对 <tt>b</tt> 的第 i 个二进制位取反，并返回 <tt>b[i]</tt>。</td>
</tr>
</tbody></table>

<hr>
<pre><a name="const_reference">dynamic_bitset::const_reference</a>
</pre>

类型 <tt>bool</tt>。

<hr>
<pre><a name="size_type">dynamic_bitset::size_type</a>
</pre>

无符号整数类型，代表 bit set 的大小。

<hr>
<pre><a name="block_type">dynamic_bitset::block_type</a>
</pre>

与 <tt>Block</tt> 类型相同。

<hr>
<pre><a name="allocator_type">dynamic_bitset::allocator_type;</a>
</pre>

与 <tt>Allocator</tt> 类型相同。

<hr>
<h3><a name="public-data-members">Public data members（公有数据成员）</a></h3>

<hr>
<pre><a name="bits_per_block">dynamic_bitset::bits_per_block</a>
</pre>

用来表示值的类型 <tt>Block</tt> 的，排除任何冗余二进制位后的二进制位的数目。在数字上等于 <tt>std::numeric_limits&lt;Block&gt;::digits</tt>。

<hr>
<pre><a name="npos">dynamic_bitset::npos</a>
</pre>

<tt>size_type</tt> 的最大值。[gps]

<hr>
<h3><a name="constructors">Constructors（构造函数）</a></h3>

<hr>
<pre><a name="cons1">dynamic_bitset</a>(const Allocator&amp; alloc = Allocator())<br></pre>

<b>作用：</b>构造一个大小为 0 的 bitset。<tt>alloc</tt> 对象的一个拷贝将被用于随后的 bitset 操作（比如 <tt>resize</tt>）中分配内存。<br>
<b>后置条件：</b><tt>this-&gt;size() == 0</tt>。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">Default Constructible（可缺省构造）</a>。）

<hr>
<pre><a name="cons2">dynamic_bitset</a>(size_type num_bits,<br>               unsigned long value = 0,<br>               const Allocator&amp; alloc = Allocator())<br></pre>

<b>作用：</b>从一个整数构造一个 bitset。前 <tt>M</tt> 个二进制位被初始化为 <tt>val</tt> 中的相应的二进制位，其他（如果有的话）全部被初始化为 0（这里的 <tt>M = min(num_bits, std::numeric_limits&lt;unsigned long&gt;::digits)</tt>）。<tt>alloc</tt> 对象的一个拷贝将被用于随后的 bitset 操作（比如 <tt>resize</tt>）中分配内存。例如，如下：<br><br><tt>dynamic_bitset b&lt;&gt;( 16, 7 ); 
</tt><br><br>将匹配 <a href="#cons4">由一个迭代器区间进行构造的构造函数</a> (不是这一个)，不过底层的实现还是会"做正确的事"并构造从值 7 构造一个 16 位的 bitset。<br><br>
<b>后置条件：</b>

<ul>
<li><tt>this-&gt;size() == num_bits</tt></li>

<li>对于区间 <tt>[0,M)</tt> 中的所有 <tt>i</tt>，<tt>(*this)[i] == (value &gt;&gt; i) &amp; 1</tt>。</li>

<li>对于区间 <tt>[M,num_bits)</tt> 中的所有 <tt>i</tt>，<tt>(*this)[i] == false</tt>。</li>
</ul>

<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>


<hr>
<pre><a name="cons5">dynamic_bitset</a>(const dynamic_bitset&amp; x)<br></pre>

<b>作用：</b>构造一个是 bitset <tt>x</tt> 的拷贝的 bitset。this bitset 的分配器是 <tt>x</tt> 中的分配器的一个拷贝。<br>
<b>后置条件：</b>对于区间 <tt>[0,x.size())</tt> 中的所有 <tt>i</tt>，<tt>(*this)[i] == x[i]</tt>。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/Assignable.html">Assignable（可赋值）</a>。）

<hr>
<pre>template &lt;typename BlockInputIterator&gt;<br>explicit<br><a name="cons4">dynamic_bitset</a>(BlockInputIterator first, BlockInputIterator last,<br>               const Allocator&amp; alloc = Allocator());<br></pre>

<b>作用：</b>基于一个 blocks 的区间构造一个 bitset。让 <tt>*first</tt> 为 block number 0，<tt>*++first</tt> 为 block number 1，等等。block number <tt>b</tt> 被用于初始化 dynamic_bitset 的位置区间 <tt>[b*bits_per_block, (b+1)*bits_per_block)</tt> 中的二进制位。对于每一个值为 <tt>bval</tt> 的 block number <tt>b</tt>，二进制位 <tt>(bval &gt;&gt; i) &amp; 1</tt> 相当于在 bitset 中位置 <tt>(b * bits_per_block + i)</tt> 上的二进制位（这里的 <tt>i</tt> 在区间 <tt>[0, bits_per_block)</tt> 中）。<br>
<pre><a id="cons4">dynamic_bitset</a>(BlockInputIterator first, BlockInputIterator last,<br>               const Allocator&amp; alloc = Allocator());<br></pre><b>作用:</b> 
<ul><li>如果该构造函数被调用时类型 <tt>BlockInputIterator</tt>
<i>实际上是一个整数类型</i>，那么该库的行为和以下调用一样：以参数 
<tt>static_cast&lt;size_type&gt;(first)</tt><tt>, last 和 alloc</tt> 调用由 <tt>unsigned long</tt> 进行构造的构造函数。<br><br>例子： <pre>// b is constructed as if by calling the constructor<br>//<br>//   dynamic_bitset(size_type num_bits,<br>//                  unsigned long value = 0,<br>//                  const Allocator&amp; alloc = Allocator())<br>//<br>// with arguments<br>//<br>//   static_cast&lt;dynamic_bitset&lt;unsigned short&gt;::size_type&gt;(8),<br>//   7,<br>//   Allocator()<br>//<br>dynamic_bitset&lt;unsigned short&gt; b(8, 7);<br></pre><br><i>注:</i><br>在编写本文档时(2008年10月)，这是符合 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438">library 
issue 438</a>&nbsp;建议决议的。这是一个<em> <tt>C++03之后</tt></em> 的变更，当前只在 <tt>C++0x</tt> 的工作草案中。非正式地讲，对于 <tt>C++03</tt> 的关键变化是第二个参数去掉了 <tt>static_cast</tt>，对于<em>何时</em>这个模板构造函数与(size, value)的那个构造函数效果相同有更大余地：在 C++03 中，仅当 
<tt>InputIterator</tt> 为整数类型时；而对于建议决议，则当它是一个整数类型或实现可以检测出不可能作为输入迭代器的其它任何类型时。由于 <tt>dynamic_bitset</tt> 的原因，我们把自己限制在两种变化中的第一个。<br><br>
</li><li><i>否则</i>(<i>即</i> 如果模板参数不是一个整数类型)，基于一个整数块区间构造—在条件子句的条件之下—一个 bitset。令 <tt>*first</tt> 为整数块 0, 
<tt>*++first</tt> 为整数块 1, 等等。整数块 <tt>b</tt> 用于初始化 dynamic_bitset 中位置为区间
<tt>[b*bits_per_block, (b+1)*bits_per_block)</tt> 的二进制位。对于每一个整数块 
<tt>b</tt> 以及值 <tt>bval</tt>, 二进制位 <tt>(bval &gt;&gt; i) &amp; 1</tt> 
对应于 bitset 中位置为 <tt>(b * bits_per_block + i)</tt> 的二进制位(其中 <tt>i</tt> 遍历区间 <tt>[0, bits_per_block)</tt>)。 
</li></ul><br><b>要求：</b>类型 <tt>BlockInputIterator</tt> 必须是一个 <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> 的原型，而它的 <tt>value_type</tt> 必须和 <tt>Block</tt> 是同一个类型。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>


<hr>
<pre>template&lt;typename Char, typename Traits, typename Alloc&gt;<br>explicit<br><a name="cons3">dynamic_bitset</a>(const <a href="http://www.sgi.com/tech/stl/basic_string.html">std::basic_string</a>&lt;Char,Traits,Alloc&gt;&amp; s,<br>               typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type pos = 0,<br>               typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type n = <a href="http://www.sgi.com/tech/stl/basic_string.html">std::basic_string</a>&lt;Char,Traits,Alloc&gt;::npos,<br>               const Allocator&amp; alloc = Allocator())<br></pre>

<b>前提条件：</b><tt>pos &lt;= s.size()</tt> 而且用于初始化二进制位的字符必须是 <tt>0</tt> 或者 <tt>1</tt>。<br>
<b>作用：</b>从一个 0 的或者 1 的 string 构造一个 bitset。前 <tt>M</tt> 个二进制位被初始化为 <tt>s</tt> 中相应的字符，这里的 <tt>M = min(s.size() - pos, n)</tt>。注意 <tt>s</tt> 中的<i>最高的</i>字符位置，不是最低的，对应于 least significant bit。也就是说，字符位置 <tt>pos + M - 1 - i</tt> 对应于二进制位 <tt>i</tt>。所以，例如，<tt>dynamic_bitset(string("1101"))</tt> 和 <tt>dynamic_bitset(13ul)</tt> 相同。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<h3><a name="destructor">Destructor（析构函数）</a></h3>

<hr>
<pre>~dynamic_bitset()<br></pre>

<b>作用：</b>释放与 this bitset 有关的内存并销毁这个 bitset 对象自身。<br>
<b>抛出：</b>不抛出异常。

<hr>
<h3><a name="member-functions">Member Functions（成员函数）</a></h3>

<hr>
<pre>void <a name="swap">swap</a>(dynamic_bitset&amp; b);<br></pre>

<b>作用：</b>this bitset 的内容与 bitset <tt>b</tt> 的内容被互相交换。<br>
<b>后置条件：</b>this bitset 与原来的 <tt>b</tt> 相等，而 <tt>b</tt> 也等于 this bitset 的先前版本。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="assign">operator=</a>(const dynamic_bitset&amp; x)<br></pre>

<b>作用：</b>this bitset 成为 bitset <tt>x</tt> 的一个拷贝。<br>
<b>后置条件：</b>对于区间 <tt>[0,x.size())</tt> 中的所有 <tt>i</tt>，<tt>(*this)[i] == x[i]</tt>。<br>
<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/Assignable.html">Assignable（可赋值）</a>。）

<hr>
<pre>allocator_type <a name="get_allocator">get_allocator()</a> const;<br></pre>
<b>返回：</b>用于构造 <tt>*this</tt> 的分配器对象的一个拷贝。

<hr>
<pre>void <a name="resize">resize</a>(size_type num_bits, bool value = false);<br></pre>

<b>作用：</b>将此 bitset 的二进制位数目变为 <tt>num_bits</tt>。如果 <tt>num_bits &gt; size()</tt>，那么区间 <tt>[0,size())</tt> 中的二进制位保持不变，<tt>[size(),num_bits)</tt> 中的二进制位全部被设置为 <tt>value</tt>。如果 <tt>num_bits &lt; size()</tt>，那么区间 <tt>[0,num_bits)</tt> 中的二进制位保持不变（而剩余的二进制位被抛弃）。<br>
<b>后置条件：</b><tt>this-&gt;size() == num_bits</tt>。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>


<hr>
<pre>void <a name="clear">clear</a>()<br></pre>

<b>作用：</b>bitset 的大小变为 0。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>void <a name="push_back">push_back</a>(bool value);<br></pre>

<b>作用：</b>将 bitset 的大小增加 1，并设置新的 most-significant bit 的值为 <tt>value</tt>。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>


<hr>
<pre>void <a name="append1">append</a>(Block value);<br></pre>

<b>作用：</b>将 <tt>value</tt> 中的二进制位附加到 bitset 中（加在最后）。这将 bitset 的大小增大 <tt>bits_per_block</tt>。如果 <tt>s</tt> 是 bitset 的原大小，那么对于区间 <tt>[0,bits_per_block)</tt> 中的 <tt>i</tt>，位置 <tt>(s + i)</tt> 上的二进制位被设置为 <tt>((value &gt;&gt; i) &amp; 1)</tt>。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>


<hr>
<pre>template &lt;typename BlockInputIterator&gt;<br>void <a name="append2">append</a>(BlockInputIterator first, BlockInputIterator last);<br></pre>

<b>作用：</b>这个函数提供和下面的代码相同的最终结果，但是一般更有效率。[gps]

<pre>for (; first != last; ++first)<br>  append(*first);<br></pre>

<b>要求：</b><tt>BlockInputIterator</tt> 类型必须是一个 <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> 的原型，而它的 <tt>value_type</tt> 必须和 <tt>Block</tt> 是同一个类型。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。<br>


<hr>
<pre>dynamic_bitset&amp; <a name="op-and-assign">operator&amp;=</a>(const dynamic_bitset&amp; rhs)<br></pre>

<b>要求：</b><tt>this-&gt;size() == rhs.size()</tt>。<br>
<b>作用：</b>将 <tt>rhs</tt> 中的所有二进制位与 this bitset 中的二进制位做按位与。这等价于：

<pre>for (size_type i = 0; i != this-&gt;size(); ++i)<br>  (*this)[i] = (*this)[i] &amp; rhs[i];<br></pre>

<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="op-or-assign">operator|=</a>(const dynamic_bitset&amp; rhs)<br></pre>

<b>要求：</b><tt>this-&gt;size() == rhs.size()</tt>。<br>
<b>作用：</b>将 <tt>rhs</tt> 中的所有二进制位与 this bitset 中的二进制位做按位与。这等价于：

<pre>for (size_type i = 0; i != this-&gt;size(); ++i)<br>  (*this)[i] = (*this)[i] | rhs[i];<br></pre>

<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="op-xor-assign">operator^=</a>(const dynamic_bitset&amp; rhs)<br></pre>

<b>要求：</b><tt>this-&gt;size() == rhs.size()</tt>.<br>
<b>作用：</b>将 <tt>rhs</tt> 中的所有二进制位与 this bitset 中的二进制位做按位异或。这等价于：

<pre>for (size_type i = 0; i != this-&gt;size(); ++i)<br>  (*this)[i] = (*this)[i] ^ rhs[i];<br></pre>

<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="op-sub-assign">operator-=</a>(const dynamic_bitset&amp; rhs)<br></pre>

<b>要求：</b><tt>this-&gt;size() == rhs.size()</tt>。<br>
<b>作用：</b>求出 this bitset 和 <tt>rhs</tt> bitset 的差集。这等价于：

<pre>for (size_type i = 0; i != this-&gt;size(); ++i)<br>  (*this)[i] = (*this)[i] &amp;&amp; !rhs[i];<br></pre>

<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="op-sl-assign">operator&lt;&lt;=</a>(size_type n)<br></pre>

<b>作用：</b>将 this bitset 中的二进制位向左移动 <tt>n</tt> 个二进制位。对于 bitset 中的每一个二进制位，位置 <tt>pos</tt> 上的二进制位持有位置 <tt>pos - n</tt> 上的二进制位原来的值，或者如果没有这样的二进制位存在，则为 0。<br>
<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="op-sr-assign">operator&gt;&gt;=</a>(size_type n)<br></pre>

<b>作用：</b>将 this bitset 中的二进制位向右移动 <tt>n</tt> 个二进制位。对于 bitset 中的每一个二进制位，位置 <tt>pos</tt> 上的二进制位持有位置 <tt>pos + n</tt> 上的二进制位原来的值，或者如果没有这样的二进制位存在，则为 0。<br>
<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset <a name="op-sl">operator&lt;&lt;</a>(size_type n) const<br></pre>

<b>返回：</b><tt>*this</tt> 的一个拷贝并向左移动 <tt>n</tt> 个二进制位。对于返回的 bitset 中的每一个二进制位，位置 pos 上的二进制位持有 this bitset 的位置 <tt>pos - n</tt> 上的二进制位的值，或者如果这样的二进制位不存在，则为 0。注意，表达式 <tt>b &lt;&lt; n</tt> 等价于构造一个 <tt>b</tt> 的临时拷贝，然后使用 <tt>operator&lt;&lt;=</tt>。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<pre>dynamic_bitset <a name="op-sr">operator&gt;&gt;</a>(size_type n) const<br></pre>

<b>返回：</b><tt>*this</tt> 的一个拷贝并向右移动 <tt>n</tt> 个二进制位。对于返回的 bitset 中的每一个二进制位，位置 pos 上的二进制位持有 this bitset 的位置 <tt>pos + n</tt> 上的二进制位的值，或者如果这样的二进制位不存在，则为 0。注意，表达式 <tt>b &gt;&gt; n</tt> 等价于构造一个 <tt>b</tt> 的临时拷贝，然后使用 <tt>operator&gt;&gt;=</tt>。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<pre>dynamic_bitset&amp; <a name="set1">set</a>()<br></pre>

<b>作用：</b>设置 this bitset 中的每一个二进制位为 1。<br>
<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="flip1">flip</a>()<br></pre>

<b>作用：</b>翻转 this bitset 中的每一个二进制位的值。<br>
<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset <a name="op-not">operator~</a>() const<br></pre>

<b>返回：</b><tt>*this</tt> 的一个拷贝，并翻转它的所有二进制位。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<pre>dynamic_bitset&amp; <a name="reset1">reset</a>()<br></pre>

<b>作用：</b>清空 this bitset 中的每一个二进制位。<br>
<b>返回：</b><tt>*this</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>dynamic_bitset&amp; <a name="set2">set</a>(size_type n, bool val = true)<br></pre>

<b>前提条件：</b><tt>n &lt; this-&gt;size()</tt>。<br>
<b>作用：</b>如果 <tt>val</tt> 为 <tt>true</tt>，则设置二进制位 <tt>n</tt>，如果 <tt>val</tt> 为 <tt>false</tt>，则清空二进制位 <tt>n</tt>。<br>
<b>返回：</b><tt>*this</tt>。

<hr>
<pre>dynamic_bitset&amp; <a name="reset2">reset</a>(size_type n)<br></pre>

<b>前提条件：</b><tt>n &lt; this-&gt;size()</tt>。<br>
<b>作用：</b>清空二进制位 <tt>n</tt>。<br>
<b>返回：</b><tt>*this</tt>。

<hr>
<pre>dynamic_bitset&amp; <a name="flip2">flip</a>(size_type n)<br></pre>

<b>前提条件：</b><tt>n &lt; this-&gt;size()</tt>。<br>
<b>作用：</b>翻转二进制位 <tt>n</tt>。<br>
<b>返回：</b><tt>*this</tt>。

<hr>
<pre>size_type <a name="size">size</a>() const<br></pre>

<b>返回：</b>this bitset 中的二进制位的数目。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>size_type <a name="num_blocks">num_blocks</a>() const<br></pre>

<b>返回：</b>this bitset 中的 blocks 的数目。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>size_type <a name="max_size">max_size</a>() const;<br></pre>

<b>返回：</b>拥有和 *this 相同类型的一个 <tt>dynamic_bitset</tt> 对象的最大大小。注意，如果有任何 <tt>dynamic_bitset</tt> 操作导致 <tt>size()</tt> 超过了 <tt>max_size()</tt>，则<i>行为是未定义的</i>。
<br><br>【在 lib issue 197 关闭之后，这个函数的语义可能会有轻微的改变 - G.P.S.】<br>

<hr>
<pre>bool <a name="empty">empty</a>() const;<br></pre>

<b>返回：</b>如果 <tt>this-&gt;size() == 0</tt>，则为 <tt>true</tt>，否则，为 <tt>false</tt>。<i>注意</i>：不要和 <tt>none()</tt> 混淆，那具有不同的语义。

 <!--  ***************** To be removed - gps *************************
<hr>
<pre>
void <a name="reserve">reserve</a>(size_type n);
</pre>

<b>前提条件：</b><tt>n &lt;= this-&gt;max_size()</tt>.<br>
<b>作用：</b>informs the <tt>dynamic_bitset</tt> of a planned
change in size(), so that reallocations can be managed accordingly.
If before the call the dynamic_bitset's capacity is >= n then no
reallocation happens and capacity remains unchanged. Otherwise
storage is allocated and capacity becomes greater or equal to n.
In any case, size() does not change.<br>
<b>抛出：</b>An allocation error if <tt>n &gt; capacity()</tt>
and memory is exhausted (<tt>std::bad_alloc</tt> if <tt>
Allocator=std::allocator</tt>). 

<hr>
<pre>
size_type <a name="capacity">capacity()</a> const;
</pre>

<b>返回：</b>the total number of elements that <tt>*this</tt>
can hold without requiring reallocation.<br>
 *************************************************************** -->

<hr>
<pre>size_type <a name="count">count</a>() const<br></pre>

<b>返回：</b>this bitset 中被设置的二进制位的数目。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>bool <a name="any">any</a>() const<br></pre>

<b>返回：</b>如果 this bitset 中有任何二进制位被设置，则为 <tt>true</tt>，否则，为 <tt>false</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>bool <a name="none">none</a>() const<br></pre>

<b>返回：</b>如果没有二进制位被设置，则为 <tt>true</tt>，否则，为 <tt>false</tt>。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>bool <a name="test">test</a>(size_type n) const<br></pre>

<b>前提条件：</b><tt>n &lt; this-&gt;size()</tt>。<br>
<b>返回：</b>如果二进制位 <tt>n</tt> 被设置，则为 <tt>true</tt>，如果二进制位 <tt>n</tt> 为 0，则为 <tt>false</tt>。

<hr>
<pre>reference <a name="bracket">operator[]</a>(size_type n)<br></pre>

<b>前提条件：</b><tt>n &lt; this-&gt;size()</tt>。<br>
<b>返回：</b>一个引向二进制位 <tt>n</tt> 的 <tt>reference</tt>。注意，这个 <tt>reference</tt> 是一个带有一个赋值操作符和一个到 <tt>bool</tt> 的转换的 proxy（代理）类，它允许你在赋值时使用 <tt>operator[]</tt>。也就是说，你既可以写 <tt>x = b[n]</tt>，也可以写 <tt>b[n] = x</tt>。然而，在其它很多方面，proxy（代理）和真正的引用类型 <tt>bool&amp;</tt> 不一样。

<hr>
<pre>bool <a name="const-bracket">operator[]</a>(size_type n) const<br></pre>

<b>前提条件：</b><tt>n &lt; this-&gt;size()</tt>。<br>
<b>返回：</b>和 <tt>test(n)</tt> 相同。

<hr>
<pre>unsigned long <a name="to_ulong">to_ulong</a>() const<br></pre>

<b>返回：</b><tt>*this</tt> 中的二进制位的相应的数字值。
<br>
<b>抛出：</b>如果那个值太大以致不能用一个 <tt>unsigned long</tt> 表示（也就是说，如果 <tt>*this</tt> 的任何一个 <tt>&gt;= std::numeric_limits&lt;unsigned long&gt;::digits</tt> 的位置有非 0 的二进制位），则抛出 <tt>std::overflow_error</tt>。

<hr>
<pre>bool <a name="is_subset_of">is_subset_of</a>(const dynamic_bitset&amp; a) const<br></pre>

<b>要求：</b><tt>this-&gt;size() == a.size()</tt><br>
<b>返回：</b>如果 this bitset 是 bitset <tt>a</tt> 的一个子集，则为 true。也就是说，如果对于 this bitset 中的每一个被设置的二进制位，bitset <tt>a</tt> 中相对应的二进制位也被设置，则返回 true。否则，这个函数返回 false。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>bool <a name="is_proper_subset_of">is_proper_subset_of</a>(const dynamic_bitset&amp; a) const<br></pre>

<b>要求：</b><tt>this-&gt;size() == a.size()</tt><br>
<b>返回：</b>如果 this bitset 是 bitset <tt>a</tt> 的一个真子集，则为 true。也就是说，如果对于 this set 中每一个被设置的二进制位，bitset <tt>a</tt> 中相对应二进制位也被设置，而且 <tt>this-&gt;count() &lt; a.count()</tt>，则返回 true。否则，这个函数返回 false。<br>
<b>抛出：</b>不抛出异常。

<hr>
<pre>size_type <a name="find_first">find_first</a>() const;<br></pre>

<b>返回：</b>被设置的二进制位的最小的索引 <tt>i</tt>，或者如果 <tt>*this</tt> 中没有被设置的二进制位，则为 <tt>npos</tt>。

<hr>
<pre>size_type <a name="find_next">find_next</a>(size_type pos) const;<br></pre>

<b>返回：</b>比 <tt>pos</tt> 大的被设置的二进制位的最小的索引 <tt>i</tt>，或者如果这样的索引不存在，则为 <tt>npos</tt>。

<hr>
<pre>bool <a name="op-equal">operator==</a>(const dynamic_bitset&amp; rhs) const<br></pre>

<b>返回：</b>如果 <tt>this-&gt;size() == rhs.size()</tt>，而且对于所有的在区间 <tt>[0,rhs.size())</tt> 中的 <tt>i</tt>，都有 <tt>(*this)[i] == rhs[i]</tt>，则为 <tt>true</tt>。否则，返回 <tt>false</tt>。<br>
<b>抛出：</b>不抛出异常。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable（可等值比较）</a>。）

<hr>
<pre>bool <a name="op-not-equal">operator!=</a>(const dynamic_bitset&amp; rhs) const<br></pre>

<b>返回：</b><tt>!((*this) == rhs)</tt><br>
<b>抛出：</b>不抛出异常。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable（可等值比较）</a>。）

<hr>
<pre>bool <a name="op-less">operator&lt;</a>(const dynamic_bitset&amp; rhs) const<br></pre>

<b>返回：</b>如果按照字典顺序 this bitset 比 <tt>rhs</tt> 小，则为 <tt>true</tt>，否则，返回 <tt>false</tt>。（关于字典顺序的定义，参见 <a href="http://www.sgi.com/tech/stl/lexicographical_compare.html">lexicographical_compare（字典式比较）</a>的描述）。<br>
<b>抛出：</b>不抛出异常。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">Less Than Comparable（可小于比较）</a>。）

<hr>
<pre>bool <a name="op-greater">operator&gt;</a>(const dynamic_bitset&amp; rhs) const<br></pre>

<b>返回：</b><tt>!((*this) &lt; rhs || (*this) ==
rhs)</tt><br>
<b>抛出：</b>不抛出异常。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">Less Than Comparable（可小于比较）</a>。）

<hr>
<pre>bool <a name="op-less-equal">operator&lt;=</a>(const dynamic_bitset&amp; rhs) const<br></pre>

<b>返回：</b><tt>(*this) &lt; rhs || (*this) == rhs</tt><br>
<b>抛出：</b>不抛出异常。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">Less Than Comparable（可小于比较）</a>。）

<hr>
<pre>bool <a name="op-greater-equal">operator&gt;=</a>(const dynamic_bitset&amp; rhs) const<br></pre>

<b>返回：</b><tt>(*this) &gt; rhs || (*this) == rhs</tt><br>
<b>抛出：</b>不抛出异常。<br>
（需求来自于 <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">Less Than Comparable（可小于比较）</a>。）

<hr>
<h3><a name="non-member-functions">Non-Member Functions（非成员函数）</a></h3>

<hr>
<pre>dynamic_bitset <a name="op-and">operator&amp;</a>(const dynamic_bitset&amp; a, const dynamic_bitset&amp; b)<br></pre>

<b>要求：</b><tt>a.size() == b.size()</tt><br>
<b>返回：</b>bitsets <tt>a</tt> 和 <tt>b</tt> 按位与形成的新的 bitset。注意，表达式 <tt>b1 &amp; b2</tt> 等价于创建一个临时的 <tt>b1</tt> 的拷贝，使用 <tt>operator&amp;=</tt>，并返回临时拷贝。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<pre>dynamic_bitset <a name="op-or">operator|</a>(const dynamic_bitset&amp; a, const dynamic_bitset&amp; b)<br></pre>

<b>要求：</b><tt>a.size() == b.size()</tt><br>
<b>返回：</b>bitsets <tt>a</tt> 和 <tt>b</tt> 按位或形成的新的 bitset。注意，表达式 <tt>b1 | b2</tt> 等价于创建一个临时的 <tt>b1</tt> 的拷贝，使用 <tt>operator|=</tt>，并返回临时拷贝。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<pre>dynamic_bitset <a name="op-xor">operator^</a>(const dynamic_bitset&amp; a, const dynamic_bitset&amp; b)<br></pre>

<b>要求：</b><tt>a.size() == b.size()</tt><br>
<b>返回：</b>bitsets <tt>a</tt> 和 <tt>b</tt> 按位异或形成的新的 bitset。注意，表达式 <tt>b1 ^ b2</tt> 等价于创建一个临时的 <tt>b1</tt> 的拷贝，使用 <tt>operator^=</tt>，并返回临时拷贝。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<pre>dynamic_bitset <a name="op-sub">operator-</a>(const dynamic_bitset&amp; a, const dynamic_bitset&amp; b)<br></pre>

<b>要求：</b><tt>a.size() == b.size()</tt><br>
<b>返回：</b>bitsets <tt>a</tt> 和 <tt>b</tt> 的差集形成的新的 bitset。注意，表达式 <tt>b1 – b2</tt> 等价于创建一个临时的 <tt>b1</tt> 的拷贝，使用 <tt>operator-=</tt>，并返回临时拷贝。<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。

<hr>
<pre>template &lt;typename CharT, typename Alloc&gt;<br>void <a name="to_string">to_string</a>(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b,<br>               <a href="http://www.sgi.com/tech/stl/basic_string.html">std::basic_string</a>&lt;Char,Traits,Alloc&gt;&amp; s)<br></pre>

<b>作用：</b>拷贝 <tt>b</tt> 的一个表示到 string <tt>s</tt> 中。如果一个二进制位被设置，则 string 中相应的字符为 <tt>'1'</tt>，如果没有设置，则为 <tt>'0'</tt>。string 的字符位置 <tt>i</tt> 对应于二进制位位置 <tt>b.size() - 1 – i</tt>。<br>
<b>抛出：</b>如果内存被耗尽，string 会抛出一个分配错误。<br>
<b>基本原理：</b>这个函数不是一个持有 0 个参数并返回一个 string 的成员函数是由于两个原因。首先，因为 string 不用拷贝（由于以传值方式传递），这个版本的性能稍微高一些。第二，作为一个成员函数，为了允许与 <tt>basic_string</tt> 的模板参数相关的弹性，成员函数需要显式模板参数。没有几个 C++ 程序员熟悉显式模板参数，而且一些 C++ 编译器也不能很好地处理它们。

<hr>
<pre>template &lt;typename Block, typename Alloc, typename BlockOutputIterator&gt;<br>void <a name="to_block_range">to_block_range</a>(const dynamic_bitset&lt;Block, Alloc&gt;&amp; b, BlockOutputIterator result)<br></pre>

<b>作用：</b>将 bitset 中的二进制位一次一个 block 地写入迭代器 <tt>result</tt> 中。第一个 block 写入代表 bitset 中位置区间 <tt>[0,bits_per_block)</tt> 内的二进制位，第二个 block 写入区间 <tt>[bits_pre_block,2*bits_per_block)</tt> 内的二进制位，并依此类推。对于每一个写入的 block <tt>bval</tt>，二进制位 <tt>(bval &gt;&gt; i) &amp; 1</tt> 对应于 bitset 中位置 <tt>(b * bits_per_block + i)</tt> 上的二进制位。<br>
<b>要求：</b>类型 <tt>BlockOutputIterator</tt> 必须是一个 <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> 的原型，而它的 <tt>value_type</tt> 必须和 <tt>Block</tt> 的类型相同。此外，输出区间的大小必须大于或等于 <tt>b.num_blocks()</tt>。

<hr>
<pre>template &lt;typename BlockIterator, typename Block, typename Alloc&gt;<br>void <a name="from_block_range">from_block_range</a>(BlockIterator first,<br>    BlockIterator last, const dynamic_bitset&lt;Block, Alloc&gt;&amp; b)<br></pre>

<b>作用：</b>从迭代器区间读 blocks 到 bitset 中。<br>
<b>要求：</b>类型 <tt>BlockIterator</tt> 必须是一个 <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> 的原型，而它的 <tt>value_type</tt> 必须和 <tt>Block</tt> 的类型相同。输出区间的大小必须小于或等于 <tt>b.num_blocks()</tt>。

<hr>
<pre>template &lt;typename Char, typename Traits, typename Block, typename Alloc&gt;<br>basic_ostream&lt;Char, Traits&gt;&amp;<br><a name="op-out">operator&lt;&lt;</a>(basic_ostream&lt;Char, Traits&gt;&amp; os, const dynamic_bitset&lt;Block, Alloc&gt;&amp; b)<br></pre>

<b>作用：</b>向流 <tt>os</tt> 中插入 b 的一个字面表示（高位在前）。粗略地说，输出和以下操作相同

<pre>std::basic_string&lt;Char, Traits&gt; s;<br>boost::to_string(x, s):<br>os &lt;&lt; s;<br></pre>

只不过 stream inserter（流插入器）会考虑将地区信息注入 <tt>os</tt>，而 <tt>boost::to_string()</tt> 不会这样做。更加精确的规范，按照 "as if" 规则给出：首先，对于 bitset <tt>b</tt> 中每一个合法的位置 i，让我们放入：<tt>character_of(b[i)]) = b[i]? os.widen('1') : os.widen('0');</tt> 再让 <tt>s</tt> 成为一个 <tt>std::basic_string&lt;Char, Traits&gt;</tt> 对象，长度为 <tt>b.size()</tt>，并且，对于每一个 <tt>[0, b.size())</tt> 中的 <tt>i</tt>，<tt>s[i]</tt> 是 <tt>character_of(b[i])</tt>。那么，输出，对 <tt>os</tt> 的影响和异常行为和输出对象 <tt>s</tt> 到 <tt>os</tt> 中相同（相同的宽度，相同的异常掩码，相同的填充，相同的 setstate() 逻辑）。<br>
<b>返回：</b>os<br>
<b>抛出：</b>如果向流中写入时发生问题，抛出 <tt>std::ios_base::failure</tt>。

<hr>
<pre>template &lt;typename Char, typename Traits, typename Block, typename Alloc&gt;<br>std::basic_istream&lt;Char,Traits&gt;&amp;<br><a name="op-in">operator&gt;&gt;</a>(std::basic_istream&lt;Char,Traits&gt;&amp; is, dynamic_bitset&lt;Block, Alloc&gt;&amp; b)<br></pre>

<b>作用：</b>从一个输入流中提取一个 <tt>dynamic_bitset</tt>。<br><br>
<i>定义：</i><br><br>
让 <i>Tr</i> 是 <i>is</i> 的 traits_type。那么：
<ol>
<li>对于一个从 <tt>is</tt> 中提取的（非 eof）字符 <tt>c</tt>，当且仅当 Tr::eq(c, is.widen('0')) 或 Tr::eq(c, is.widen('1')) 为 true 时，则 <tt>c</tt> 是一个 <i>bitset digit</i>。</li>
<li>如果 c 是一个 bitset digit，当 Tr::eq(c, is.widen('0')) 为 true 时，它<i>所对应的二进制位值</i>为 0，否则为 1。</li>
</ol>

函数一开始构造一个 <tt>sentry</tt> 对象 <tt>k</tt>，就好像 <tt>k</tt> 通过 <tt>typename std::basic_istream&lt;Char, Traits&gt;::sentry k(is)</tt> 构造。如果 <tt>bool(k)</tt> 为 true，它就调用 <tt>b.clear()</tt>，然后尝试从 <tt>is</tt> 中提取字符。对于每一个是 <tt>bitset digit</tt> 的字符 c，<i>相应的二进制位的值</i>附加在 <tt>b</tt> 的 less significant 末尾（附加有可能抛出异常 - gps）。如果 <tt>is.width()</tt> 大于 0 且小于 <tt>b.max_size()</tt>，那么附加的二进制位的最大值 <tt>n</tt> 为 <tt>is.width()</tt>，否则 <tt>n</tt> = <tt>b.max_size()</tt>。除非提取器通过一个异常退出，否则，字符的提取（以及相应的二进制位的附加）直到下面某一情况发生才会停止：<br>

<ul>
<li><tt>n</tt> 个二进制位被存入 bitset；</li>
<li>输入序列发生 end-of-file 或一个错误；</li>
<li>下一个可用输入字符不是一个 bitset digit</li>
</ul>
<br>如果没有导致函数退出的异常，则无论实际提取了多少个字符，<tt>is.width(0)</tt> 都会被调用。sentry 对象 k 被销毁。<br>
<br>如果函数没有提取到字符 [???]，它就会调用 is.setstate(std::ios::failbit)，这有可能抛出 <tt>std::ios_base::failure</tt>。


<br>------


<br>
<b>抛出：</b>如果内存耗尽会发生分配错误（如果 <tt>Allocator=std::allocator</tt>，则为 <tt>std::bad_alloc</tt>）。如果从流中读入出现问题，会抛出 <tt>std::ios_base::failure</tt>。

<hr>
<h3><a name="exception-guarantees">Exception guarantees（异常保证）</a></h3>

所有 <tt>dynamic_bitset</tt> 函数至少提供基本异常保证。<hr>
<h3><a name="changes-from-previous-ver">Changes from previous version(s)（版本变化）</a></h3><h4><i>Boost 1.37.0 的变化</i></h4>
<ul><li>由块区间进行构造的构造函数实现"做正确的事情"的行为，一个 la 标准序列。 </li></ul><!-- Changes from Boost 1.31.0 -->

<!-- Changes from Boost 1.31.0 -->
<h4><i>Boost 1.31.0 以来的变化</i></h4>
<ul>
<li>流提取器具有完全不同的语义：它现在在提取过程中会根据需要扩展 bitset，对于一个动态结构来说这是很自然的。新的行为模拟了 basic_string 的提取器，但有一些用户应该知道的区别，所以，请参考<a href="#op-in">文档</a>。
（其中一个区别涉及到 stream.width() &gt; bitset.max_size() &gt; 0 的情况，在实际情况中
dynamic_bitset 的提取器从来不会试图扩展到超过 max_size() 个字符，反之，basic_string
的提取器会继续下去，并且，在遵守标准的实现上，最终抛出一个 length_error。注意：这是标准的要求——特别是参见 library
issue 83——但并非所有的实现都遵守标准）<br><br>
流提取器现在也可以感知异常，在流上设置了异常掩码的情况下可以正常地工作。<br><br>
</li>
<li>增加了几个成员函数 (<tt>empty()</tt>, <tt>find_first()</tt>, <tt>find_next()</tt>, <tt>get_allocator()</tt>, <tt>intersects()</tt>, <tt>max_size()</tt> <!--, <tt>reserve()</tt>, <tt>capacity()</tt> -->)。</li>
<li>从 basic_string 构造的构造函数有一个新的参数，以前被彻底地忘记了。</li>

</ul>
<i>技术的和辅助的变化</i>
<ul>
<li>类 <tt>reference</tt> 被重新实现，因此，dynamic_bitset 的引用的行为更像标准容器元素的引用。特别是，现在它可以保证：当标准库的 swap() 函数应用于于这些引用相对应的 <tt>dynamic_bitset</tt>s 是，这些引用不会失效。
</li>
</ul>
<i>全面提高</i>
<br><br>有几个用于成员和非成员函数以及内嵌类 <tt>reference</tt> 的优化。

<hr>
<h3><a name="see-also">See also（参见）</a></h3>

<tt><a href="http://www.sgi.com/tech/stl/bitset.html">std::bitset</a></tt>, <tt><a href="http://www.sgi.com/tech/stl/Vector.html">std::vector</a></tt>,

<h3><a name="acknowledgements">Acknowledgements（感谢）</a></h3>

<p>我们衷心感谢 Boost 社群投入时间来审查和接受这个库。由于来自 Boost 成员的建议，这个库变得比以前更好。我们特别要感谢 Matt Marcus 承担了审查管理者的任务。而且，专门的感谢送给 James Kanze，他对国际化的帮助无法估量。</p>

<hr>
<table summary="">
<tbody><tr>
<td></td>
</tr>

<tr valign="top">
<td nowrap="nowrap">Copyright © 2001</td>
<td><a href="../../people/jeremy_siek.htm">Jeremy Siek</a>,
Indiana University (<a href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)<br>
<a href="http://freshsources.com">Chuck Allison</a>, Senior
Editor, C/C++ Users Journal (<a href="mailto:cda@freshsources.com">cda@freshsources.com</a>)<br>
</td>
</tr>

<tr valign="top">
<td nowrap="nowrap">Copyright © 2003-2004</td>
<td>Gennaro Prota</td>
</tr>
</tbody></table>

<!--  LocalWords:  dynamic bitset alt gif iostream hpp int bitsets const ul ulong
 -->
<!--  LocalWords:  STL LessThan alloc num typename BlockInputIterator html pos
 -->
<!--  LocalWords:  npos bool rhs OR's XOR's val CharT istream ostream os siek
 -->
<!--  LocalWords:  htm namespace enum sizeof BlockOutputIterator fwd ith jth
 -->
</body></html>
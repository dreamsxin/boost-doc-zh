<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />

<title>Boost Pointer Container Library</title><style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2007-11-25 13:38:02 -0500 (Sun, 25 Nov 2007) $
:Revision: $Revision: 41370 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* "! important" is used here to override other ``margin-top`` and
   ``margin-bottom`` styles that are later in the stylesheet or 
   more specific.  See http://www.w3.org/TR/CSS1#the-cascade */
.first {
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

img.borderless {
  border: 0 }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid thin gray }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid thin black }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style></head>
<body>
<div class="document" id="boost-pointer-container-library">
<h1 class="title"><img alt="Boost" src="boost.png" /> Pointer Container Library 指针容器库</h1>
<h2 class="subtitle" id="tutorial">Tutorial 教程</h2>
<p>The tutorial shows you the most simple usage of the
library. It is assumed that the reader is familiar
with the use of standard containers. Although
the tutorial is devided into sections, it is recommended
that you read it all from top to bottom.<br />本教程将向你展示本库最简单的用法。我们假定读者熟悉标准容器的使用。虽然本教程被分为几节，但是我们建议你从头到尾来阅读。</p>
<ul class="simple">
<li><a class="reference" href="#basic-usage">Basic usage 基本用法</a></li>
<li><a class="reference" href="#indirected-interface">Indirected interface 间接接口</a></li>
<li><a class="reference" href="#sequence-containers">Sequence containers 序列容器</a></li>
<li><a class="reference" href="#associative-containers">Associative containers 关联容器</a></li>
<li><a class="reference" href="#null-values">Null values 空值</a></li>
<li><a class="reference" href="#cloneability">Cloneability 可克隆性</a></li>
<li><a class="reference" href="#new-functions">New functions 新的函数</a></li>
<li><a class="reference" href="#std-auto-ptr-u-overloads">std::auto_ptr&lt;U&gt; overloads &nbsp;std::auto_ptr&lt;U&gt; 重载</a></li>
<li><a class="reference" href="#algorithms">Algorithms 算法</a></li>
</ul>
<div class="section">
<h1><a id="basic-usage" name="basic-usage">Basic usage 基本用法</a></h1>
<p>The most important aspect of a pointer container is that it manages
memory for you. This means that you in most cases do not need to worry
about deleting memory.<br />指针容器最重要的方面是它为你管理内存。这意味着你在多数情况下不需要担心内存的删除。</p>
<p>Let us assume that we have an OO-hierarchy of animals<br />我们来假定有一个动物的OO层次：</p>
<pre class="literal-block">class animal : <a class="reference" href="http://www.boost.org/libs/utility/utility.htm#Class_noncopyable">boost::noncopyable</a>
{
public:
    virtual      ~animal()   {}
    virtual void eat()       = 0;
    virtual int  age() const = 0;
    // ...
};

class mammal : public animal
{
    // ...
};

class bird : public animal
{
    // ...
};
</pre>
<p>Then the managing of the animals is straight-forward. Imagine a 
Zoo:<br />这样，对动物的管理就很简单了。想象一个动物园：</p>
<pre class="literal-block">class zoo<br />{<br />    boost::ptr_vector&lt;animal&gt; the_animals;<br />public:<br /><br />    void add_animal( animal* a )<br />    {<br />        the_animals.push_back( a );<br />    }<br />};<br /></pre>
<p>Notice how we just pass the class name to the container; there
is no <tt class="docutils literal"><span class="pre">*</span></tt> to indicate it is a pointer.
With this declaration we can now say:<br />留意我们是如何将类名传递给容器的；没有用 <tt class="docutils literal"><span class="pre">*</span></tt> 来表示它是一个指针。有了这个声明，我们现在可以写：</p>
<pre class="literal-block">zoo the_zoo;<br />the_zoo.add_animal( new mammal("joe") );<br />the_zoo.add_animal( new bird("dodo") );<br /></pre>
<p>Thus we heap-allocate all elements of the container
and never rely on copy-semantics.<br />因此，我们在堆上分配容器的所有元素，而且没有依赖于复制语义。</p>
</div>
<div class="section">
<h1><a id="indirected-interface" name="indirected-interface">Indirected interface 间接接口</a></h1>
<p>A particular feature of the pointer containers is that
the query interface is indirected. For example,<br />指针容器的一个特别之处在于查询接口是间接的。例如：</p>
<pre class="literal-block">boost::ptr_vector&lt;animal&gt; vec;<br />vec.push_back( new animal ); // you add it as pointer ... 你加了一个指针...<br />vec[0].eat();                // but get a reference back 但取出的是一个引用<br /></pre>
<p>This indirection also happens to iterators, so<br />这种间接性同样出现在迭代器上，所以：</p>
<pre class="literal-block">typedef std::vector&lt;animal*&gt; std_vec;<br />std_vec vec;<br />...<br />std_vec::iterator i = vec.begin();<br />(*i)-&gt;eat(); // '*' needed 需要用'*'<br /></pre>
<p>now becomes<br />现在变成：</p>
<pre class="literal-block">typedef boost::ptr_vector&lt;animal&gt;  ptr_vec;<br />ptr_vec vec;<br />ptr_vec::iterator i = vec.begin();<br />i-&gt;eat(); // no indirection needed 不再需要间接访问<br /></pre>
</div>
<div class="section">
<h1><a id="sequence-containers" name="sequence-containers">Sequence containers 序列容器</a></h1>
<p>The sequence containers are used when you do not need to
keep an ordering on your elements. You can basically
expect all operations of the normal standard containers
to be available. So, for example, with a  <tt class="docutils literal"><span class="pre">ptr_deque</span></tt>
and <tt class="docutils literal"><span class="pre">ptr_list</span></tt> object you can say:<br />当你不需要对元素保持某种顺序时，可以使用序列容器。基本上你可以期望普通标准容器的所有操作都可用。因此，比如对于  <tt class="docutils literal"><span class="pre">ptr_deque</span></tt> 和 <tt class="docutils literal"><span class="pre">ptr_list</span></tt> 对象，你可以写：</p>
<pre class="literal-block">boost::ptr_deque&lt;animal&gt; deq;<br />deq.push_front( new animal );    <br />deq.pop_front();<br /></pre>
<p>because <tt class="docutils literal"><span class="pre">std::deque</span></tt> and <tt class="docutils literal"><span class="pre">std::list</span></tt> have <tt class="docutils literal"><span class="pre">push_front()</span></tt>
and <tt class="docutils literal"><span class="pre">pop_front()</span></tt> members.<br />因为 <tt class="docutils literal"><span class="pre">std::deque</span></tt> 和 <tt class="docutils literal"><span class="pre">std::list</span></tt> 具有 <tt class="docutils literal"><span class="pre">push_front()</span></tt> 和 <tt class="docutils literal"><span class="pre">pop_front()</span></tt> 成员。</p>
<p>If the standard sequence supports
random access, so does the pointer container; for example:<br />如果标准序列容器支持随机访问，则指针容器也同样支持；例如：</p>
<pre class="literal-block">for( boost::ptr_deque&lt;animal&gt;::size_type i = 0u;<br />     i != deq.size(); ++i )<br />     deq[i].eat();<br /></pre>
<p>The <tt class="docutils literal"><span class="pre">ptr_vector</span></tt> also allows you to specify the size of
the buffer to allocate; for example<br /><tt class="docutils literal"><span class="pre">ptr_vector</span></tt> 还可以允许你指定所分配的缓冲区大小；例如：</p>
<pre class="literal-block">boost::ptr_vector&lt;animal&gt; animals( 10u );<br /></pre>
<p>will reserve room for 10 animals.<br />将保留10只动物的空间。</p>
</div>
<div class="section">
<h1><a id="associative-containers" name="associative-containers">Associative containers 关联容器</a></h1>
<p>To keep an ordering on our animals, we could use a <tt class="docutils literal"><span class="pre">ptr_set</span></tt>:<br />为了保持动物的顺序，我们可以使用 <tt class="docutils literal"><span class="pre">ptr_set</span></tt>:</p>
<pre class="literal-block">boost::ptr_set&lt;animal&gt; set;<br />set.insert( new monkey("bobo") );<br />set.insert( new whale("anna") );<br />...<br /></pre>
<p>This requires that <tt class="docutils literal"><span class="pre">operator&lt;()</span></tt> is defined for animals. One
way to do this could be<br />这时要求为动物定义 <tt class="docutils literal"><span class="pre">operator&lt;()</span></tt>。你可以这样做：</p>
<pre class="literal-block">inline bool operator&lt;( const animal&amp; l, const animal&amp; r )<br />{<br />    return l.name() &lt; r.name();<br />}<br /></pre>
<p>if we wanted to keep the animals sorted by name.<br />如果我们想按名称来保持动物顺序。</p>
<p>Maybe you want to keep all the animals in zoo ordered wrt.
their name, but it so happens that many animals have the
same name. We can then use a <tt class="docutils literal"><span class="pre">ptr_multimap</span></tt>:<br />也许你想按动物的名称来保持动物园中所有动物的顺序，但是通常有多只动物具有相同的名称。那么我们可以使用 <tt class="docutils literal"><span class="pre">ptr_multimap</span></tt>:</p>
<pre class="literal-block">typedef boost::ptr_multimap&lt;std::string,animal&gt; zoo_type;<br />zoo_type zoo;<br />std::string bobo = "bobo",<br />            anna = "anna";<br />zoo.insert( bobo, new monkey(bobo) );<br />zoo.insert( bobo, new elephant(bobo) );<br />zoo.insert( anna, new whale(anna) );<br />zoo.insert( anna, new emu(anna) );<br /></pre>
<p>Note that must create the key as an lvalue 
(due to exception-safety issues); the following would not 
have compiled<br />注意，必须将用左值来创建键值(由于异常安全性的问题)；以下代码将不能编译：</p>
<pre class="literal-block">zoo.insert( "bobo", // this is bad, but you get compile error 这不好，你会得到编译错误<br />            new monkey("bobo") );<br /></pre>
<p>If a multimap is not needed, we can use <tt class="docutils literal"><span class="pre">operator[]()</span></tt>
to avoid the clumsiness:<br />如果不需要 multimap，我们可以使用 <tt class="docutils literal"><span class="pre">operator[]()</span></tt>
来避免难看的代码：</p>
<pre class="literal-block">boost::ptr_map&lt;std::string,animal&gt; animals;<br />animals["bobo"].set_name("bobo");<br /></pre>
<p>This requires a default constructor for animals and
a function to do the initialization, in this case <tt class="docutils literal"><span class="pre">set_name()</span></tt>.<br />这样写需要 animals 具有缺省构造函数和一个完成初始化的函数，即这里的 <tt class="docutils literal"><span class="pre">set_name()</span></tt>。</p>
<p>A better alternative is to use <a class="reference" href="../../assign/index.html">Boost.Assign</a>
to help you out. In particular, consider<br />一种更好的方式是使用 <a class="reference" href="../../assign/index.html">Boost.Assign</a>
来协助你。特别地，请考虑：</p>
<ul class="simple">
<li><a class="reference" href="../../assign/doc/index.html#ptr_push_back">ptr_push_back(), ptr_push_front(), ptr_insert() 和 ptr_map_insert()</a></li>
<li><a class="reference" href="../../assign/doc/index.html#ptr_list_of">ptr_list_of()</a></li>
</ul>
<p>For example, the above insertion may now be written<br />例如，以上插入操作现在可写成：</p>
<pre class="literal-block">boost::ptr_multimap&lt;std::string,animal&gt; animals;<br /><br />using namespace boost::assign;<br />ptr_map_insert&lt;monkey&gt;( animals )( "bobo", "bobo" );<br />ptr_map_insert&lt;elephant&gt;( animals )( "bobo", "bobo" );<br />ptr_map_insert&lt;whale&gt;( animals )( "anna", "anna" );<br />ptr_map_insert&lt;emu&gt;( animals )( "anna", "anna" );<br /></pre>
</div>
<div class="section">
<h1><a id="null-values" name="null-values">Null values 空值</a></h1>
<p>By default, if you try to insert null into a container, an exception
is thrown. If you want to allow nulls, then you must
say so explicitly when declaring the container variable<br />缺省情况下，如果你尝试将 null 插入到容器中，将抛出一个异常。如果你想允许 null，那么你必须在声明容器变量时明确提出：</p>
<pre class="literal-block">boost::ptr_vector&lt; boost::nullable&lt;animal&gt; &gt; animals_type;<br />animals_type animals;<br />...<br />animals.insert( animals.end(), new dodo("fido") );<br />animals.insert( animals.begin(), 0 ) // ok<br /></pre>
<p>Once you have inserted a null into the container, you must
always check if the value is null before accessing the object<br />一旦你向容器插入了一个 null，你就必须在访问该对象前检查它是否为 null：</p>
<pre class="literal-block">for( animals_type::iterator i = animals.begin();<br />     i != animals.end(); ++i )<br />{<br />    if( !boost::is_null(i) ) // always check for validity 必须检查有效性<br />        i-&gt;eat();<br />}<br /></pre>
<p>If the container support random access, you may also check this as<br />如果容器支持随机访问，你也要检查，如下：</p>
<pre class="literal-block">for( animals_type::size_type i = 0u; <br />     i != animals.size(); ++i )<br />{<br />    if( !animals.is_null(i) )<br />         animals[i].eat();<br />}<br /></pre>
<p>Note that it is meaningless to insert
null into <tt class="docutils literal"><span class="pre">ptr_set</span></tt> and <tt class="docutils literal"><span class="pre">ptr_multiset</span></tt>.<br />注意，将
null 插入到 <tt class="docutils literal"><span class="pre">ptr_set</span></tt> 和 <tt class="docutils literal"><span class="pre">ptr_multiset</span></tt> 中是没有意义的。</p>
</div>
<div class="section">
<h1><a id="cloneability" name="cloneability">Cloneability 可克隆性</a></h1>
<p>In OO programming it is typical to prohibit copying of objects; the 
objects may sometimes be allowed to be Cloneable; for example,:<br />在OO编程中，禁止对象复制是很典型的；但是这些对象有时候又被允许为可克隆；例如：</p>
<pre class="literal-block">animal* animal::clone() const<br />{<br />    return do_clone(); // implemented by private virtual function 通过私有虚拟函数实现<br />}<br /></pre>
<p>If the OO hierarchy thus allows cloning, we need to tell the 
pointer containers how cloning is to be done. This is simply
done by defining a free-standing function, <tt class="docutils literal"><span class="pre">new_clone()</span></tt>, 
in the same namespace as
the object hierarchy:<br />如果其OO层次是允许克隆的，我们就需要告诉指针容器如何进行克隆。通常只要在与对象层次同一个名字空间中定义一个普通函数 <tt class="docutils literal"><span class="pre">new_clone()</span></tt> 来完成：</p>
<pre class="literal-block">inline animal* new_clone( const animal&amp; a )<br />{<br />    return a.clone();<br />}<br /></pre>
<p>That is all, now a lot of functions in a pointer container
can exploit the cloneability of the animal objects. For example<br />这就可以了，现在指针容器中的大多数函数都可以使用 animal 对象的可克隆性了。例如：</p>
<pre class="literal-block">typedef boost::ptr_list&lt;animal&gt; zoo_type;<br />zoo_type zoo, another_zoo;<br />...<br />another_zoo.assign( zoo.begin(), zoo.end() );<br /></pre>
<p>will fill another zoo with clones of the first zoo. Similarly,
<tt class="docutils literal"><span class="pre">insert()</span></tt> can now insert clones into your pointer container<br />将用第一个动物园的克隆物来填充另一个动物园。同样，现在
<tt class="docutils literal"><span class="pre">insert()</span></tt> 也可以将克隆物插入到你的指针容器中：</p>
<pre class="literal-block">another_zoo.insert( another_zoo.begin(), zoo.begin(), zoo.end() );<br /></pre>
<p>The whole container can now also be cloned<br />整个容器也可以被克隆：</p>
<pre class="literal-block">zoo_type yet_another_zoo = zoo.clone();<br /></pre>
<p>Copying or assigning the container has the same effect as cloning (though it is slightly cheaper):<br />复制或赋值整个容器具有与克隆相同的效果(不过它的代价稍低一点)：</p>
<pre class="literal-block">zoo_type yet_another_zoo = zoo;<br /></pre>
<p>Copying also support derived-to-base class conversions:<br />复制还可以支持派生类到基类的转换：</p>
<pre class="literal-block">boost::ptr_vector&lt;monkey&gt; monkeys = boost::assign::ptr_list_of&lt;monkey&gt;( "bobo" )( "bebe")( "uhuh" );<br />boost::ptr_vector&lt;animal&gt; animals = monkeys;<br /></pre>
<p>This also works for maps:<br />对于 map 同样可用：</p>
<pre class="literal-block">boost::ptr_map&lt;std::string,monkey&gt; monkeys = ...;<br />boost::ptr_map&lt;std::string,animal&gt; animals = monkeys;<br /></pre>
</div>
<div class="section">
<h1><a id="new-functions" name="new-functions">New functions 新的函数</a></h1>
<p>Given that we know we are working with pointers, a few new functions
make sense. For example, say you want to remove an
animal from the zoo<br />我们知道我们正在与指针打交道，有些新的函数是有意义的。例如，假设你想从动物园中删除一只动物：</p>
<pre class="literal-block">zoo_type::auto_type the_animal = zoo.release( zoo.begin() );<br />the_animal-&gt;eat();<br />animal* the_animal_ptr = the_animal.release(); // now this is not deleted 现在并没有被删除<br />zoo.release(2); // for random access containers 用于随机访问容器<br /></pre>
<p>You can think of <tt class="docutils literal"><span class="pre">auto_type</span></tt> as a non-copyable form of 
<tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt>. Notice that when you release an object, the
pointer is removed from the container and the containers size
shrinks. For containers that store nulls, we can exploit that
<tt class="docutils literal"><span class="pre">auto_type</span></tt> is convertible to <tt class="docutils literal"><span class="pre">bool</span></tt>:<br />你可以将 <tt class="docutils literal"><span class="pre">auto_type</span></tt> 视为 
<tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt> 的一种不可复制形式。留意，当你释放一个对象时，其指针是从容器中删除了，容器的大小也缩小了。对于可以保存 null 的容器，我们可以看到
<tt class="docutils literal"><span class="pre">auto_type</span></tt> 可以转换为 <tt class="docutils literal"><span class="pre">bool</span></tt>：</p>
<pre class="literal-block">if( ptr_vector&lt; nullable&lt;T&gt; &gt;::auto_type r = vec.pop_back() )<br />{<br />  ...<br />}  <br /></pre>
<p>You can also release the entire container if you
want to return it from a function<br />你也可以释放整个容器，如果你想从一个函数返回它：</p>
<pre class="literal-block">std::auto_ptr&lt; boost::ptr_deque&lt;animal&gt; &gt; get_zoo()<br />{<br />    boost::ptr_deque&lt;animal&gt;  result;<br />    ...<br />    return result.release(); // give up ownership 放弃拥有权<br />}<br />...<br />boost::ptr_deque&lt;animal&gt; animals = get_zoo();    <br /></pre>
<p>Let us assume we want to move an animal object from
one zoo to another. In other words, we want to move the 
animal and the responsibility of it to another zoo<br />我们来假定要将一只动物从一个动物园移到另一个动物园。换句话说，我们要迁移一只动物及其责任到另一个动物园：</p>
<pre class="literal-block">another_zoo.transfer( another_zoo.end(), // insert before end 插入到尾部之前<br />                      zoo.begin(),       // insert this animal ... 插入这一只动物...<br />                      zoo );             // from this container 从这个容器<br /></pre>

<p>This kind of "move-semantics" is different from
normal value-based containers. You can think of <tt class="docutils literal"><span class="pre">transfer()</span></tt>
as the same as <tt class="docutils literal"><span class="pre">splice()</span></tt> on <tt class="docutils literal"><span class="pre">std::list</span></tt>.<br />这种"迁移语义"不同于普通的基于值的容器。你可以将 <tt class="docutils literal"><span class="pre">transfer()</span></tt>
视作与 <tt class="docutils literal"><span class="pre">std::list</span></tt> 中的 <tt class="docutils literal"><span class="pre">splice()</span></tt> 一样。</p>
<p>If you want to replace an element, you can easily do so<br />如果你想替换一个元素，你可以很容易做到：</p>
<pre class="literal-block">zoo_type::auto_type old_animal = zoo.replace( zoo.begin(), new monkey("bibi") ); <br />zoo.replace( 2, old_animal.release() ); // for random access containers 用于随机访问容器<br /></pre>
<p>A map is slightly different to iterate over than standard maps.
Now we say<br />对于 map，其遍历与标准的 map 稍微有些不一样。我们要这样写：</p>
<pre class="literal-block">typedef boost::ptr_map&lt;std::string, boost::nullable&lt;animal&gt; &gt; animal_map;<br />animal_map map;<br />...<br />for( animal_map::const_iterator i = map.begin(), e = map.end(); i != e; ++i )<br />{<br />    std::cout &lt;&lt; "\n key: " &lt;&lt; i-&gt;first;<br />    std::cout &lt;&lt; "\n age: ";<br />    <br />    if( boost::is_null(i) )<br />        std::cout &lt;&lt; "unknown";<br />    else<br />        std::cout &lt;&lt; i-&gt;second-&gt;age(); <br /> }<br /></pre>
<p>Except for the check for null, this looks like it would with a normal map. But if <tt class="docutils literal"><span class="pre">age()</span></tt> had 
not been a <tt class="docutils literal"><span class="pre">const</span></tt> member function,
it would not have compiled.<br />除了要检查 null，看起来与普通的 map 一样。但是如果 <tt class="docutils literal"><span class="pre">age()</span></tt> 不是一个 <tt class="docutils literal"><span class="pre">const</span></tt> 成员函数，它将不能编译。</p>
<p>Maps can also be indexed with bounds-checking<br />Map 也可以进行带边界检查的索引访问：</p>
<pre class="literal-block">try<br />{<br />    animal&amp; bobo = map.at("bobo");<br />}<br />catch( boost::bad_ptr_container_operation&amp; e )<br />{<br />    // "bobo" not found 没有找到"bobo"<br />}        <br /></pre>
</div>
<div class="section">
<h1><a id="std-auto-ptr-u-overloads" name="std-auto-ptr-u-overloads"><tt class="docutils literal"><span class="pre">std::auto_ptr&lt;U&gt;</span></tt> overloads &nbsp;<tt class="docutils literal"><span class="pre">std::auto_ptr&lt;U&gt;</span></tt> 重载</a></h1>
<p>Every time there is a function that takes a <tt class="docutils literal"><span class="pre">T*</span></tt> parameter, there is
also a function taking an <tt class="docutils literal"><span class="pre">std::auto_ptr&lt;U&gt;</span></tt> parameter. This is of course done
to make the library intregrate seamlessly with <tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt>. For example<br />对于每一个接受 <tt class="docutils literal"><span class="pre">T*</span></tt> 参数的函数，都有另一个接受 <tt class="docutils literal"><span class="pre">std::auto_ptr&lt;U&gt;</span></tt> 参数的函数。这样当然是为了让本库与 <tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt> 无缝集成。例如：</p>
<pre class="literal-block">std::ptr_vector&lt;Base&gt; vec;<br />vec.push_back( new Base );<br /></pre>
<p>is complemented by<br />就可以有：</p>
<pre class="literal-block">std::auto_ptr&lt;Derived&gt; p( new Derived );<br />vec.push_back( p );   <br /></pre>
<p>Notice that the template argument for <tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt> does not need to
follow the template argument for <tt class="docutils literal"><span class="pre">ptr_vector</span></tt> as long as <tt class="docutils literal"><span class="pre">Derived*</span></tt>
can be implicitly converted to <tt class="docutils literal"><span class="pre">Base*</span></tt>.<br />注意，<tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt> 的模板参数无需与 <tt class="docutils literal"><span class="pre">ptr_vector</span></tt> 的模板参数一致，只要 <tt class="docutils literal"><span class="pre">Derived*</span></tt>
可以隐式转换为 <tt class="docutils literal"><span class="pre">Base*</span></tt>。</p>
</div>
<div class="section">
<h1><a id="algorithms" name="algorithms">Algorithms 算法</a></h1>
<p>Unfortunately it is not possible to use pointer containers with
mutating algorithms from the standard library. However,
the most useful ones
are instead provided as member functions:<br />很不幸，不可以将指针容器与标准库的可变算法共用。不过，这些算法中最有用的已经以成员函数的方式提供出来了：</p>
<pre class="literal-block">boost::ptr_vector&lt;animal&gt; zoo;<br />...<br />zoo.sort();                               // assume 'bool operator&lt;( const animal&amp;, const animal&amp; )'<br />                                          // 假定有 'bool operator&lt;(const animal&amp;, const animal&amp;)<br />zoo.sort( std::less&lt;animal&gt;() );          // the same, notice no '*' is present 同上，注意没有'*'<br />zoo.sort( zoo.begin(), zoo.begin() + 5 ); // sort selected range 对选定范围进行排序<br /></pre>
<p>Notice that predicates are automatically wrapped in an <a class="reference" href="indirect_fun.html">indirect_fun</a> object.<br />注意，其中的谓词会自动被包装在一个 <a class="reference" href="indirect_fun.html">indirect_fun</a> 对象中。</p>
<p>You can remove equal and adjacent elements using <tt class="docutils literal"><span class="pre">unique()</span></tt>:<br />你可以用 <tt class="docutils literal"><span class="pre">unique()</span></tt> 去除相等的连续元素：</p>
<pre class="literal-block">zoo.unique();                             // assume 'bool operator==( const animal&amp;, const animal&amp; )'<br />                                          // 假定有 'bool operator==( const animal&amp;, const animal&amp; )' <br />zoo.unique( zoo.begin(), zoo.begin() + 5, my_comparison_predicate() ); <br /></pre>
<p>If you just want to remove certain elements, use <tt class="docutils literal"><span class="pre">erase_if</span></tt>:<br />如果你只想删除特定元素，可以用 <tt class="docutils literal"><span class="pre">erase_if</span></tt>：</p>
<pre class="literal-block">zoo.erase_if( my_predicate() );<br /></pre>
<p>Finally you may want to merge two sorted containers:<br />最后，你可能想合并两个已排序的容器：</p>
<pre class="literal-block">boost::ptr_vector&lt;animal&gt; another_zoo = ...;<br />another_zoo.sort();                      // sorted wrt. to same order as 'zoo' 与'zoo'一样排序<br />zoo.merge( another_zoo );<br />BOOST_ASSERT( another_zoo.empty() );    <br /></pre>
<p>That is all; now you have learned all the basics!<br />就这么多了；现在你已经学完了所有基本用法！</p>
<hr /><p><strong>See also 参见</strong></p>
<ul class="simple">
<li><a class="reference" href="guidelines.html">Usage guidelines 用法指引</a></li>
<li><a class="reference" href="../../conversion/cast.htm#Polymorphic_castl">Cast utilities 转型工具</a></li>
</ul>
<p><strong>Navigate 导读</strong></p>
<ul class="simple">
<li><a class="reference" href="ptr_container.html">home 主页</a></li>
<li><a class="reference" href="examples.html">examples 例子</a></li>
</ul>
<hr /><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">LICENSE_1_0.txt</a>).</td>
</tr>
</tbody>
</table>
</div>
</div>
</body></html>
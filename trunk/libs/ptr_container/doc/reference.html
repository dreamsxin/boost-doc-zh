<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" /><title>Boost Pointer Container Library</title>

<style type="text/css">
/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2007-11-25 13:38:02 -0500 (Sun, 25 Nov 2007) $
:Revision: $Revision: 41370 $
:Copyright: This stylesheet has been placed in the public domain.
Default cascading style sheet for the HTML output of Docutils.
See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/
/* "! important" is used here to override other ``margin-top`` and
``margin-bottom`` styles that are later in the stylesheet or more specific. See http://www.w3.org/TR/CSS1#the-cascade */
.first {
margin-top: 0 ! important }
.last, .with-subtitle {
margin-bottom: 0 ! important }
.hidden {
display: none }
a.toc-backref {
text-decoration: none ;
color: black }
blockquote.epigraph {
margin: 2em 5em ; }
dl.docutils dd {
margin-bottom: 0.5em }
/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
font-weight: bold }
*/
div.abstract {
margin: 2em 5em }
div.abstract p.topic-title {
font-weight: bold ;
text-align: center }
div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
margin: 2em ;
border: medium outset ;
padding: 1em }
div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
font-weight: bold ;
font-family: sans-serif }
div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
color: red ;
font-weight: bold ;
font-family: sans-serif }
/* Uncomment (and remove this text!) to get reduced vertical space in
compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
margin-bottom: 0.5em }
div.compound .compound-last, div.compound .compound-middle {
margin-top: 0.5em }
*/
div.dedication {
margin: 2em 5em ;
text-align: center ;
font-style: italic }
div.dedication p.topic-title {
font-weight: bold ;
font-style: normal }
div.figure {
margin-left: 2em }
div.footer, div.header {
clear: both;
font-size: smaller }
div.line-block {
display: block ;
margin-top: 1em ;
margin-bottom: 1em }
div.line-block div.line-block {
margin-top: 0 ;
margin-bottom: 0 ;
margin-left: 1.5em }
div.sidebar {
margin-left: 1em ;
border: medium outset ;
padding: 1em ;
background-color: #ffffee ;
width: 40% ;
float: right ;
clear: right }
div.sidebar p.rubric {
font-family: sans-serif ;
font-size: medium }
div.system-messages {
margin: 5em }
div.system-messages h1 {
color: red }
div.system-message {
border: medium outset ;
padding: 1em }
div.system-message p.system-message-title {
color: red ;
font-weight: bold }
div.topic {
margin: 2em }
h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
margin-top: 0.4em }
h1.title {
text-align: center }
h2.subtitle {
text-align: center }
hr.docutils {
width: 75% }
img.align-left {
clear: left }
img.align-right {
clear: right }
img.borderless {
border: 0 }
ol.simple, ul.simple {
margin-bottom: 1em }
ol.arabic {
list-style: decimal }
ol.loweralpha {
list-style: lower-alpha }
ol.upperalpha {
list-style: upper-alpha }
ol.lowerroman {
list-style: lower-roman }
ol.upperroman {
list-style: upper-roman }
p.attribution {
text-align: right ;
margin-left: 50% }
p.caption {
font-style: italic }
p.credits {
font-style: italic ;
font-size: smaller }
p.label {
white-space: nowrap }
p.rubric {
font-weight: bold ;
font-size: larger ;
color: maroon ;
text-align: center }
p.sidebar-title {
font-family: sans-serif ;
font-weight: bold ;
font-size: larger }
p.sidebar-subtitle {
font-family: sans-serif ;
font-weight: bold }
p.topic-title {
font-weight: bold }
pre.address {
margin-bottom: 0 ;
margin-top: 0 ;
font-family: serif ;
font-size: 100% }
pre.line-block {
font-family: serif ;
font-size: 100% }
pre.literal-block, pre.doctest-block {
margin-left: 2em ;
margin-right: 2em ;
background-color: #eeeeee }
span.classifier {
font-family: sans-serif ;
font-style: oblique }
span.classifier-delimiter {
font-family: sans-serif ;
font-weight: bold }
span.interpreted {
font-family: sans-serif }
span.option {
white-space: nowrap }
span.pre {
white-space: pre }
span.problematic {
color: red }
span.section-subtitle {
/* font-size relative to parent (h1..h6 element) */
font-size: 80% }
table.citation {
border-left: solid thin gray }
table.docinfo {
margin: 2em 4em }
table.docutils {
margin-top: 0.5em ;
margin-bottom: 0.5em }
table.footnote {
border-left: solid thin black }
table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
padding-left: 0.5em ;
padding-right: 0.5em ;
vertical-align: top }
table.docutils th.field-name, table.docinfo th.docinfo-name {
font-weight: bold ;
text-align: left ;
white-space: nowrap ;
padding-left: 0 }
h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
font-size: 100% }
tt.docutils {
background-color: #eeeeee }
ul.auto-toc {
list-style-type: none }
</style>
</head>
<body>
<div class="document" id="boost-pointer-container-library">
<h1 class="title"><img alt="Boost" src="boost.png" /> Pointer Container Library 指针容器库</h1>
<h2 class="subtitle" id="reference">Reference 参考</h2>
<p>The documentation is divided into an explanation for each
container. When containers have the same interface, that common
interface is explained only once,
but links are always provided to more relevant information.
Please make sure you understand the <a class="reference" href="reference.html#the-Cloneable-concept">Cloneable</a>
concept and the <a class="reference" href="reference.html#the-clone-allocator-concept">Clone
Allocator</a> concept.<br />
本文档被分为各个容器的说明。由于各容器具有相同的接口，所以共同的接口只解释一次，不过会提供链接到更多的相关信息。请确认你已经理解了 <a class="reference" href="reference.html#the-Cloneable-concept">可
克隆</a> 概念和 <a class="reference" href="reference.html#the-clone-allocator-concept">克隆分配器</a>
概念。</p>
<ul class="simple">
<li><a class="reference" href="conventions.html">Conventions
约定</a></li>
<li><a class="reference" href="#the-cloneable-concept">The
Cloneable concept 可克隆概念</a></li>
<li><a class="reference" href="#the-clone-allocator-concept">The Clone Allocator
concept 克隆分配器概念</a></li>
<li><a class="reference" href="#class-hierarchy">Class
hierarchy 类层次</a>:
<ul>
<li><a class="reference" href="reversible_ptr_container.html">reversible_ptr_container</a>
<ul>
<li><a class="reference" href="ptr_sequence_adapter.html">ptr_sequence_adapter</a>
<ul>
<li><a class="reference" href="ptr_vector.html">ptr_vector</a></li>
<li><a class="reference" href="ptr_list.html">ptr_list</a></li>
<li><a class="reference" href="ptr_deque.html">ptr_deque</a></li>
<li><a class="reference" href="ptr_array.html">ptr_array</a></li>
</ul>
</li>
<li><a class="reference" href="associative_ptr_container.html">associative_ptr_container</a>
<ul>
<li><a class="reference" href="ptr_set_adapter.html">ptr_set_adapter</a></li>
<li><a class="reference" href="ptr_multiset_adapter.html">ptr_multiset_adapter</a></li>
<li><a class="reference" href="ptr_map_adapter.html">ptr_map_adapter</a></li>
<li><a class="reference" href="ptr_multimap_adapter.html">ptr_multi_map_adapter</a>
<ul>
<li><a class="reference" href="ptr_set.html">ptr_set</a></li>
<li><a class="reference" href="ptr_multiset.html">ptr_multi_set</a></li>
<li><a class="reference" href="ptr_map.html">ptr_map</a></li>
<li><a class="reference" href="ptr_multimap.html">ptr_multimap</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#serialization">Serialization
序列化</a></li>
<li><a class="reference" href="indirect_fun.html">Indirected
functions 间接函数</a></li>
<li><a class="reference" href="#class-nullable">Class
nullable 类 nullable</a></li>
<li><a class="reference" href="#exception-classes">Exception
classes 异常类</a></li>
<li><a class="reference" href="#disabling-the-use-of-exceptions">Disabling the use of
exceptions 禁止使用异常</a></li>
</ul>
<!-- - Class `reversible_ptr_container <reversible_ptr_container.html>`_ - Class `associative_ptr_container <associative_ptr_container.html>`_ - `Pointer container adapters`_ - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_ - `ptr_set_adapter <ptr_set_adapter.html>`_ - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_ - `ptr_map_adapter <ptr_map_adapter.html>`_ - `ptr_multimap_adapter <ptr_multimap_adapter.html>`_ - `Sequence containers`_ - `ptr_vector <ptr_vector.html>`_ - `ptr_deque <ptr_deque.html>`_ - `ptr_list <ptr_list.html>`_ - `ptr_array <ptr_array.html>`_ - `Associative containers`_ - `ptr_set <ptr_set.html>`_ - `ptr_multiset <ptr_multiset.html>`_ - `ptr_map <ptr_map.html>`_ - `ptr_multimap <ptr_multimap.html>`_ -->
<div class="section">
<h1><a id="the-cloneable-concept" name="the-cloneable-concept">The Cloneable concept 可克隆概念</a></h1>
<p><strong>Refinement of 精化自</strong></p>
<ul class="simple">
<li>Heap Allocable 可堆分配</li>
<li>Heap Deallocable 可堆释放</li>
</ul>
<p>The Cloneable concept is introduced to formalize the
requirements for copying heap-allocated objects. A type <tt class="docutils literal"><span class="pre">T</span></tt>
might be Cloneable even though it is not Assignable or Copy
Constructible. Notice that many operations on the containers do not
even require the stored type to be Cloneable.<br />
可克隆概念的引入是为了对复制堆分配对象的要求进行规范化。一个类型 <tt class="docutils literal"><span class="pre">T</span></tt>
即使不是可赋值或可复制构造的，也可以是可克隆的。注意，容器上的许多操作并不要求被保存类型是可克隆的。</p>
<p><strong>Notation 记号</strong></p>
<table class="docutils" border="1">
<colgroup><col width="21%" /><col width="41%" /><col width="18%" /><col width="20%" /></colgroup>
<tbody valign="top">
<tr>
<td><strong>Type 类型</strong></td>
<td><strong>Object</strong> (<tt class="docutils literal"><span class="pre">const</span></tt>
or non-<tt class="docutils literal"><span class="pre">const</span></tt>)<br />
<strong>对象</strong> (<tt class="docutils literal"><span class="pre">const</span></tt> 或 非<tt class="docutils literal"><span class="pre">const</span></tt>)</td>
<td><strong>Pointer 指针</strong></td>
<td><strong>Describes 说明</strong></td>
</tr>
<tr>
<td><tt class="docutils literal"><span class="pre">T</span></tt></td>
<td><tt class="docutils literal"><span class="pre">a</span></tt></td>
<td><tt class="docutils literal"><span class="pre">ptr</span></tt></td>
<td>A Cloneable type<br />
一个可克隆类型</td>
</tr>
</tbody>
</table>
<p><strong>Valid expressions 有效表达式</strong></p>
<table class="docutils" border="1">
<colgroup><col width="19%" /><col width="14%" /><col width="46%" /><col width="20%" /></colgroup>
<tbody valign="top">
<tr>
<td><strong>Expression 表达式</strong></td>
<td><strong>Type 类型</strong></td>
<td><strong>Semantics 语义</strong></td>
<td><strong>Postcondition 后续条件</strong></td>
</tr>
<tr>
<td><tt class="docutils literal"><span class="pre">new_clone(a);</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T*</span></tt></td>
<td>Allocate a new object that can be considered equivalent
to the <tt class="docutils literal"><span class="pre">a</span></tt>
object<br />
分配一个新的对象，新对象可被视为与 <tt class="docutils literal"><span class="pre">a</span></tt> 对象等价</td>
<td><tt class="docutils literal"><span class="pre">typeid(*new_clone(a))</span> <span class="pre">==</span> <span class="pre">typeid(a)</span></tt></td>
</tr>
<tr>
<td><tt class="docutils literal"><span class="pre">delete_clone(ptr);</span></tt></td>
<td><tt class="docutils literal"><span class="pre">void</span></tt></td>
<td>Deallocate an object previously allocated with <tt class="docutils literal"><span class="pre">allocate_clone()</span></tt>.
Must not throw<br />
以 <tt class="docutils literal"><span class="pre">allocate_clone()</span></tt>&amp;
nbsp;释放早前分配的对象。必须无抛出</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<div class="section">
<h2><a id="default-implementation" name="default-implementation">Default implementation 缺省实现</a></h2>
<p>In the <tt class="docutils literal"><span class="pre">&lt;boost/ptr_container/clone_allocator.hpp&gt;</span></tt>
header a default implementation
of the two functions is given:<br />
在 <tt class="docutils literal"><span class="pre">&lt;boost/ptr_container/clone_allocator.hpp&gt;</span></tt>
头文件中，给出了两个函数的缺省实现：</p>
<pre class="literal-block">namespace boost<br />{<br /> template&lt; class T &gt;<br /> inline T* new_clone( const T&amp; t )<br /> {<br /> return new T( t );<br /> }<br /><br /> template&lt; class T &gt;<br /> void delete_clone( const T* t )<br /> {<br /> checked_delete( t );<br /> }<br />}<br /></pre>
<p>Notice that this implementation makes normal Copy
Constructible classes automatically Cloneable unless <tt class="docutils literal"><span class="pre">operator</span>
<span class="pre">new()</span></tt> or <tt class="docutils literal"><span class="pre">operator</span>
<span class="pre">delete()</span></tt> are
hidden.<br />
注意，这个实现让普通的可复制构造类自动成为可克隆的，除非 <tt class="docutils literal"><span class="pre">operator</span> <span class="pre">new()</span></tt>
或 <tt class="docutils literal"><span class="pre">operator</span>
<span class="pre">delete()</span></tt> 被隐藏。</p>
<p>The two functions represent a layer of indirection which is
necessary to support classes that are not Copy Constructible by
default. Notice that the implementation relies on argument-dependent
lookup (ADL) to find the right version of <tt class="docutils literal"><span class="pre">new_clone()</span></tt>
and <tt class="docutils literal"><span class="pre">delete_clone()</span></tt>.
This means that one does not need to overload or specialize the
function in the boost namespace, but it can be placed together with the
rest of the interface of the class. If you are implementing a class
inline in headers, remember to forward declare the functions.<br />
这两个函数表示为一个间接层，为了支持缺省为不可复制构造的类，这是必须的。注意，该实现依赖于参数相关查找(ADL)来查找
<tt class="docutils literal"><span class="pre">new_clone()</span></tt>
和 <tt class="docutils literal"><span class="pre">delete_clone()</span></tt>
的正确版本。这意味着你不需要在 boost
名字空间中重载或特化这些函数，它可以与类的其它接口放在一起。如果你在头文件中以内联方式实现了一个类，请记得前向声明这些函数。</p>
<strong></strong>
<p><strong>Warning: We are considering the removal of
default
implementation above. Therefore always make sure that you overload the
functions for your types and do not rely on the defaults in any way.<br />
</strong><strong>警告：我们正在考虑去掉上述缺省实现。因此请总是确认你已经为你的类型重载了以上函数，不要
以任何方式依赖于缺省实现。</strong></p>
</div>
</div>
<div class="section">
<h1><a id="the-clone-allocator-concept" name="the-clone-allocator-concept">The Clone Allocator
concept 克隆分配器概念</a></h1>
<p>The Clone Allocator concept is introduced to formalize the way
pointer containers control memory of
the stored objects (and not the pointers to the stored objects).
The clone allocator allows
users to apply custom allocators/deallocators for the cloned objects.<br />
克隆分配器概念的引入是为了对指针容器控制所存对象的内存(不是指针的内存)的方法进行规范化。克隆分配器允许用户对被克隆对象指定定制的分配器/释放
器。</p>
<p>More information can be found below:<br />
在以下链接中可以找到更多信息：</p>
<div class="contents local topic">
<ul class="simple">
<li><a class="reference" href="#clone-allocator-requirements" id="id19" name="id19">Clone Allocator requirements <br />
克隆分配器要求</a></li>
<li><a class="reference" href="reference.html#class-heap-clone-allocator" id="id20" name="id20">Class <tt class="docutils literal"><span class="pre">heap_clone_allocator</span></tt></a><br />
<a class="reference" href="#class-heap-clone-allocator" id="id20" name="id20"> 类 <tt class="docutils literal"><span class="pre">heap_clone_allocator</span></tt></a></li>
<li><a class="reference" href="reference.html#class-view-clone-allocator" id="id21" name="id21">Class <tt class="docutils literal"><span class="pre">view_clone_allocator</span></tt></a><br />
<a class="reference" href="#class-view-clone-allocator" id="id21" name="id21"> 类 <tt class="docutils literal"><span class="pre">view_clone_allocator</span></tt></a></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id19" id="clone-allocator-requirements" name="clone-allocator-requirements">Clone Allocator
requirements 克隆分配器要求</a></h2>
<p><strong>Notation 记号</strong></p>
<table class="docutils" border="1">
<colgroup><col width="18%" /><col width="39%" /><col width="43%" /></colgroup>
<tbody valign="top">
<tr>
<td><strong>Type 类型</strong></td>
<td><strong>Object</strong> (<tt class="docutils literal"><span class="pre">const</span></tt>
or non-<tt class="docutils literal"><span class="pre">const</span></tt>)<br />
<strong>对象</strong> (<tt class="docutils literal"><span class="pre">const</span></tt> 或 非-<tt class="docutils literal"><span class="pre">const</span></tt>)</td>
<td><strong>Describes 说明</strong></td>
</tr>
<tr>
<td><tt class="docutils literal"><span class="pre">T</span></tt></td>
<td><tt class="docutils literal"><span class="pre">a</span></tt></td>
<td>A type<br />
一个类型</td>
</tr>
<tr>
<td><tt class="docutils literal"><span class="pre">T*</span></tt></td>
<td><tt class="docutils literal"><span class="pre">ptr</span></tt></td>
<td>A pointer to <tt class="docutils literal"><span class="pre">T</span></tt><br />
一个 <tt class="docutils literal"><span class="pre">T</span></tt>
指针<tt class="docutils literal"><span class="pre"></span></tt></td>
</tr>
</tbody>
</table>
<p><strong>Valid expressions 有效表达式</strong></p>
<table class="docutils" border="1">
<colgroup><col width="23%" /><col width="7%" /><col width="39%" /><col width="31%" /></colgroup>
<tbody valign="top">
<tr>
<td><strong>Expression 表达式</strong></td>
<td><strong>Type 类型</strong></td>
<td><strong>Semantics 语义</strong></td>
<td><strong>Postcondition 后续条件</strong></td>
</tr>
<tr>
<td><tt class="docutils literal"><span class="pre">CloneAllocator::allocate_clone(a);</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T*</span></tt></td>
<td>Allocate a new object that can be considered equivalent
to the
<tt class="docutils literal"><span class="pre">a</span></tt>
object<br />
分配一个新对象，新的对象可视为与对象
<tt class="docutils literal"><span class="pre">a</span></tt>
等价</td>
<td><tt class="docutils literal"><span class="pre">typeid(*CloneAllocator::allocate_clone(a))</span>
<span class="pre">==</span> <span class="pre">typeid(a)</span></tt></td>
</tr>
<tr>
<td><tt class="docutils literal"><span class="pre">CloneAllocator::deallocate_clone(ptr);</span></tt></td>
<td><tt class="docutils literal"><span class="pre">void</span></tt></td>
<td>Deallocate an object previously allocated with
<tt class="docutils literal"><span class="pre">CloneAllocator::allocate_clone()</span></tt>
or a compatible allocator.
Must not throw.<br />
释放一个之前以
<tt class="docutils literal"><span class="pre">CloneAllocator::allocate_clone()</span></tt>
或相兼容的分配器所分配的对象。必须无抛出。</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>The library comes with two predefined clone allocators.<br />
本库带有两个预定义的克隆分配器。</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="class-heap-clone-allocator" name="class-heap-clone-allocator">Class <tt class="docutils literal docutils literal"><span class="pre">heap_clone_allocator</span></tt> 类 <tt class="docutils literal docutils literal"><span class="pre">heap_clone_allocator</span></tt></a></h2>
<p>This is the default clone allocator used by all pointer
containers. For most
purposes you will never have to change this default.<br />
这是被所有指针容器使用的缺省克隆分配器。在大多数情况下你无须修改这一缺省值。</p>
<p><strong>Definition 定义</strong></p>
<pre class="literal-block">namespace boost<br />{ <br /> struct heap_clone_allocator<br /> {<br /> template&lt; class U &gt;<br /> static U* allocate_clone( const U&amp; r )<br /> {<br /> return new_clone( r );<br /> }<br /><br /> template&lt; class U &gt;<br /> static void deallocate_clone( const U* r )<br /> {<br /> delete_clone( r );<br /> }<br /> };<br />}<br /></pre>
<p>Notice that the above definition allows you to support custom
allocation
schemes by relying on <tt class="docutils literal"><span class="pre">new_clone()</span></tt> and <tt class="docutils literal"><span class="pre">delete_clone()</span></tt>.<br />
注意，以上定义允许你通过 <tt class="docutils literal"><span class="pre">new_clone()</span></tt> 和 <tt class="docutils literal"><span class="pre">delete_clone()</span></tt>
来支持定制化的分配方案。</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="class-view-clone-allocator" name="class-view-clone-allocator">Class <tt class="docutils literal docutils literal"><span class="pre">view_clone_allocator</span></tt>
&nbsp;类 <tt class="docutils literal docutils literal"><span class="pre">view_clone_allocator</span></tt></a></h2>
<p>This class provides a way to remove ownership properties of
the
pointer containers. As its name implies, this means that you can
instead use the pointer containers as a view into an existing
container.<br />
这个类提供了删除指针容器的所有权属性的一种方法。顾名思义，你可以将指针容器作为某个已有容器的视图来使用。</p>
<p><strong>Definition 定义</strong></p>
<pre class="literal-block">namespace boost<br />{<br /> struct view_clone_allocator<br /> {<br /> template&lt; class U &gt;<br /> static U* allocate_clone( const U&amp; r )<br /> {<br /> return const_cast&lt;U*&gt;(&amp;r);<br /> }<br /><br /> template&lt; class U &gt;<br /> static void deallocate_clone( const U* )<br /> {<br /> // empty<br /> }<br /> };<br />}<br /></pre>
<!-- **See also** - `Changing the clone allocator <examples.html#changing-the-clone-allocator>`_ -->
</div>
</div>
<div class="section">
<h1><a id="class-hierarchy" name="class-hierarchy">Class
hierarchy 类层次</a></h1>
<p>The library consists of the following types of classes:<br />
本库包含以下类类型：</p>
<ol class="arabic simple">
<li>Pointer container adapters 指针容器适配器</li>
</ol>
<!-- -->
<ol class="arabic simple" start="2">
<li>Pointer containers 指针容器</li>
</ol>
<p>The pointer container adapters are used when you
want to make a pointer container starting from
your own "normal" container. For example, you
might have a map class that is extends <tt class="docutils literal"><span class="pre">std::map</span></tt>
in some way; the adapter class then allows you
to use your map class as a basis for a new
pointer container.<br />
当你要从你自己的一个"普通"容器构造一个指针容器时，可以使用指针容器适配器。例如，你可能有一个以某种方式扩展了 <tt class="docutils literal"><span class="pre">std::map</span></tt>
的 map 类；那么适配器类可以让你以你的 map 类为基础构造一个新的指针容器。</p>
<p>The library provides an adapter for each type
of standard container highlighted as links below:<br />
本库为每种标准容器类型提供了一个适配器，如以下链接所示：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">reversible_ptr_container</span></tt>
<ul>
<li><a class="reference" href="ptr_sequence_adapter.html">ptr_sequence_adapter</a>
<ul>
<li><tt class="docutils literal"><span class="pre">ptr_vector</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_list</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_deque</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_array</span></tt></li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">associative_ptr_container</span></tt>
<ul>
<li><a class="reference" href="ptr_set_adapter.html">ptr_set_adapter</a></li>
<li><a class="reference" href="ptr_multiset_adapter.html">ptr_multiset_adapter</a></li>
<li><a class="reference" href="ptr_map_adapter.html">ptr_map_adapter</a></li>
<li><a class="reference" href="ptr_multimap_adapter.html">ptr_multi_map_adapter</a>
<ul>
<li><tt class="docutils literal"><span class="pre">ptr_set</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_multi_set</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_map</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_multimap</span></tt></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The pointer containers of this library are all built using
the adapters. There is a pointer container
for each type of "normal" standard container highlighted as links below.<br />
本库中的指针容器都是用适配器构建的。对于每种"普通"标准容器都有一个指针容器，如以下链接所示：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">reversible_ptr_container</span></tt>
<ul>
<li><tt class="docutils literal"><span class="pre">ptr_sequence_adapter</span></tt>
<ul>
<li><a class="reference" href="ptr_vector.html">ptr_vector</a></li>
<li><a class="reference" href="ptr_list.html">ptr_list</a></li>
<li><a class="reference" href="ptr_deque.html">ptr_deque</a></li>
<li><a class="reference" href="ptr_array.html">ptr_array</a></li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">associative_ptr_container</span></tt>
<ul>
<li><tt class="docutils literal"><span class="pre">ptr_set_adapter</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_multiset_adapter</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_map_adapter</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ptr_multi_map_adapter</span></tt>
<ul>
<li><a class="reference" href="ptr_set.html">ptr_set</a></li>
<li><a class="reference" href="ptr_multiset.html">ptr_multi_set</a></li>
<li><a class="reference" href="ptr_map.html">ptr_map</a></li>
<li><a class="reference" href="ptr_multimap.html">ptr_multimap</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a id="serialization" name="serialization">Serialization
序列化</a></h1>
<p>As of version 1.34.0 of Boost, the library support
serialization via <a class="reference" href="../../serialization/index.html">Boost.Serialization</a>.<br />
和 Boost 的版本 1.34.0 一样，本库通过 <a class="reference" href="../../serialization/index.html">Boost.Serialization</a>
支持序列化。</p>
<p>Of course, for serialization to work it is required
that the stored type itself is serializable. For maps, both
the key type and the mapped type must be serializable.<br />
当然，为了序列化可以工作，必须要求所存类型本身是可序列化的。对于 map，键类型和被映射类型都必须可序列化。</p>
<p>When dealing with serialization (and serialization of
polymophic objects in particular), pay special attention to these parts
of Boost.Serialization:<br />
在处理序列化(特别是多态对象的序列化)时，要特别注意 Boost.Serialization 中的以下部分：</p>
<ol class="arabic">
<li>
<p class="first">Output/saving requires a
const-reference:<br />输出/保存操作要求一个常量性引用：</p>
<pre class="literal-block">//<br />// serialization helper: we can't save a non-const object<br />// <br />template&lt; class T &gt;<br />inline T const&amp; as_const( T const&amp; r )<br />{<br /> return r;<br />}<br />...<br />Container cont;<br /><br />std::ofstream ofs("filename");<br />boost::archive::text_oarchive oa(ofs);<br />oa &lt;&lt; as_const(cont);<br /></pre>
<p>See <a class="reference" href="../../serialization/doc/rationale.html#trap">Compile
time trap when saving a non-const value</a> for
details.<br />细节请见 <a class="reference" href="../../serialization/doc/rationale.html#trap">保存一个非常量值时的编译期陷阱</a>。</p>
</li>
</ol>
<ol class="arabic" start="2">
<li>
<p class="first">Derived classes need to call <tt class="docutils literal"><span class="pre">base_object()</span></tt>
function:<br />派生类需要调用 <tt class="docutils literal"><span class="pre">base_object()</span></tt> 函数：</p>
<pre class="literal-block">struct Derived : Base<br />{<br /> template&lt; class Archive &gt;<br /> void serialize( Archive&amp; ar, const unsigned int version )<br /> {<br /> ar &amp; boost::serialization::base_object&lt;Base&gt;( *this );<br /> ...<br /> } <br />};<br /></pre>
<p>For details, see <a class="reference" href="../../serialization/doc/tutorial.html#derivedclasses">Derived
Classes</a>.<br />细节请见 <a class="reference" href="../../serialization/doc/tutorial.html#derivedclasses">派生类</a>。</p>
</li>
</ol>
<ol class="arabic" start="3">
<li>
<p class="first">You need to use <tt class="docutils literal"><span class="pre">BOOST_CLASS_EXPORT</span></tt>
to register the
derived classes in your class hierarchy:<br />你需要用 <tt class="docutils literal"><span class="pre">BOOST_CLASS_EXPORT</span></tt>
来将派生类注册到你的类层次中：</p>
<pre class="literal-block">BOOST_CLASS_EXPORT( Derived )<br /></pre>
<p>See <a class="reference" href="../../serialization/doc/traits.html#export">Export Key</a>
and <a class="reference" href="../../serialization/doc/special.html">Object Tracking</a>
for details.<br />细节请见 <a class="reference" href="../../serialization/doc/traits.html#export">输出键</a> 和 <a class="reference" href="../../serialization/doc/special.html">对象跟踪</a>。</p>
</li>
</ol>
<p>Remember these three issues and it might save you some trouble.<br />记住这三个问题可以减少你的麻烦。</p>
<!-- Map iterator operations +++++++++++++++++++++++ The map iterators are a bit different compared to the normal ones. The reason is that it is a bit clumsy to access the key and the mapped object through i->first and i->second, and one tends to forget what is what. Moreover, and more importantly, we also want to hide the pointer as much as possibble. The new style can be illustrated with a small example:: typedef ptr_map<string,int> map_t; map_t m; m[ "foo" ] = 4; // insert pair m[ "bar" ] = 5; // ditto ... for( map_t::iterator i = m.begin(); i != m.end(); ++i ) { *i += 42; // add 42 to each value cout << "value=" << *i << ", key=" << i.key() << "n"; } So the difference from the normal map iterator is that - ``operator*()`` returns a reference to the mapped object (normally it returns a reference to a ``std::pair``, and - that the key can be accessed through the ``key()`` function. -->
</div>
<div class="section">
<h1><a id="class-nullable" name="class-nullable">Class
<tt class="docutils literal"><span class="pre">nullable</span></tt> &nbsp;类
<tt class="docutils literal"><span class="pre">nullable</span></tt></a></h1>
<p>The purpose of the class is simply to tell the containers
that null values should be allowed. Its definition is
trivial:<br />本类的目的只是用于告诉容器允许使用空指针。它的定义很简单：</p>
<pre class="literal-block">namespace boost<br />{<br /> template&lt; class T &gt;<br /> struct nullable<br /> {<br /> typedef T type;<br /> }; <br />}<br /></pre>
<p>Please notice that <tt class="docutils literal"><span class="pre">nullable</span></tt> has no effect
on the containers
interface (except for <tt class="docutils literal"><span class="pre">is_null()</span></tt> functions).
For example, it
does not make sense to do<br />请留意，<tt class="docutils literal"><span class="pre">nullable</span></tt> 并不影响容器的接口(除了 <tt class="docutils literal"><span class="pre">is_null()</span></tt> 函数以外)。例如，这样写是没有意义的：</p>
<pre class="literal-block">boost::ptr_vector&lt; boost::nullable&lt;T&gt; &gt; vec;<br />vec.push_back( 0 ); // ok<br />vec.push_back( new boost::nullable&lt;T&gt; ); // no no! 不行！<br />boost::nullable&lt;T&gt;&amp; ref = vec[0]; // also no no! 也不行！<br /></pre>
</div>
<div class="section">
<h1><a id="exception-classes" name="exception-classes">Exception
classes 异常类</a></h1>
<p>There are three exceptions that are thrown by this library.
The exception hierarchy looks as follows:<br />本库会抛出三种异常类。异常类的层次如下：</p>
<pre class="literal-block">namespace boost<br />{<br /> class bad_ptr_container_operation : public std::exception<br /> {<br /> public:<br /> bad_ptr_container_operation( const char* what );<br /> };<br /> <br /> class bad_index : public bad_ptr_container_operation<br /> {<br /> public:<br /> bad_index( const char* what );<br /> };<br /><br /> class bad_pointer : public bad_ptr_container_operation<br /> {<br /> public:<br /> bad_pointer();<br /> bad_pointer( const char* what );<br /> };<br />}<br /></pre>
</div>
<div class="section">
<h1><a id="disabling-the-use-of-exceptions" name="disabling-the-use-of-exceptions">Disabling the use of
exceptions 禁止使用异常</a></h1>


<p>As of version 1.34.0 of Boost, the library allows you to
disable exceptions
completely. This means the library is more fit for domains where
exceptions
are not used. Furthermore, it also speeds up a operations a little.
Instead
of throwing an exception, the library simply calls <a class="reference" href="../../utility/assert.html">BOOST_ASSERT</a>.<br />和 Boost 版本 1.34.0 一样，本库允许你完全 禁用异常。这意味着本库更加适用于不能使用异常的领域。此外，这样也会加快一点点操作的速度。如果不抛出异常，本库会调用 <a class="reference" href="../../utility/assert.html">BOOST_ASSERT</a>。</p><p>To disable exceptions, simly define this macro before
including any header:<br />要禁用异常，只要在包含任何头文件之前定义这个宏：</p>
<pre class="literal-block">#define BOOST_PTR_CONTAINER_NO_EXCEPTIONS 1<br />#include &lt;boost/ptr_container/ptr_vector.hpp&gt;<br /></pre>
<p>It is, however, recommended that you define the macro on the
command-line, so
you are absolutely certain that all headers are compiled the same way.
Otherwise
you might end up breaking the One Definition Rule.<br />不过，建议你在命令行定义这个宏，这样你可以确保所有头文件以相同方式编译。否则你可能会破坏一处定义原则。</p>
<p>If <tt class="docutils literal"><span class="pre">BOOST_NO_EXCEPTIONS</span></tt> is
defined, then <tt class="docutils literal"><span class="pre">BOOST_PTR_CONTAINER_NO_EXCEPTIONS</span></tt>
is also defined.<br />如果定义了 <tt class="docutils literal"><span class="pre">BOOST_NO_EXCEPTIONS</span></tt>，则 <tt class="docutils literal"><span class="pre">BOOST_PTR_CONTAINER_NO_EXCEPTIONS</span></tt> 也被定义。</p>
<hr />
<p><strong>Navigate: 导读：</strong></p>
<ul class="simple">
<li><a class="reference" href="ptr_container.html">home 主页</a></li>
</ul>
<hr />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" /><tbody valign="top">
<tr class="field">
<th class="field-name">Copyright:</th>
<td class="field-body">Thorsten Ottosen 2004-2007.
Use, modification and distribution is subject to the Boost Software
License, Version 1.0 (see <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">LICENSE_1_0.txt</a>).</td>
</tr>
</tbody>
</table>
</div>
</div>
</body></html>
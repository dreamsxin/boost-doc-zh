<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<head>
		<title>Boost: mem_fn.hpp 文档</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	</head>
	<body bgcolor="white" style="MARGIN-LEFT: 5%; MARGIN-RIGHT: 5%">
		<table border="0" width="100%">
			<tr>
				<td width="277"><A href="../../index.htm"> <img src="../../boost.png" alt="boost.png (6897 bytes)" width="277" height="86" border="0"></A>
				</td>
				<td align="center">
					<h1>mem_fn.hpp</h1>
				</td>
			</tr>
			<tr>
				<td colspan="2" height="64">&nbsp;</td>
			</tr>
		</table>
		<h2>目录</h2>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Purpose">目的</a></h3>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#FAQ">常见问题</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q1"><b>mem_fn</b> 可以用来替代标准 <b>std::mem_fun[_ref]</b> 适配器吗？</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q2">在已存在代码中，我应该用 <b>mem_fn</b> 替换 <b>std::mem_fun[_ref]</b> 的每一次出现吗？</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q3"><b>mem_fn</b> 可以和 COM 方法一起工作吗？</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q4">为什么 BOOST_MEM_FN_ENABLE_STDCALL 不被自动定义？</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Interface">接口</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Synopsis">概要</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#CommonRequirements">共通需求</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#get_pointer">get_pointer</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#mem_fn">mem_fn</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Implementation">实现</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Files">文件</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Dependencies">相关内容</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#NumberOfArguments">参数数量</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#stdcall">"__stdcall", "__cdecl" 和 "__fastcall" 支持</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Acknowledgements">感谢</a></h3>
		<h2><a name="Purpose">Purpose（目的）</a></h2>
		<p><b>boost::mem_fn</b> 是标准函数 <b>std::mem_fun</b> 和 <b>std::mem_fun_ref</b> 的泛化。它支持带有多个参数的成员函数指针，并且返回的函数对象可以持有一个对象实例的指针，引用或者智能指针作为它的第一个参数。<STRONG>mem_fn</STRONG> 也支持指向数据成员的指针，它把它们看作不持有参数且返回一个成员的（常）引用的函数。</p>
		<p><b>mem_fn</b> 的目的分成两个部分。首先，它允许用户以熟悉的</p>
		<pre>    std::for_each(v.begin(), v.end(), boost::mem_fn(&amp;Shape::draw));</pre>
		<p>语法在一个容器上调用一个成员函数，即使这个容器存储的是智能指针。</p>
		<p>第二，它可以被想要将一个成员函数指针看做一个函数对象的库开发者当做一个构件来使用。一个库可以通过以下这种形式的重载定义一个增强的 <b>for_each</b> 算法：</p>
		<pre>
template&lt;class It, class R, class T&gt; void for_each(It first, It last, R (T::*pmf) ())
{
    std::for_each(first, last, boost::mem_fn(pmf));
}
</pre>
		<p>它将接受很方便的语法：</p>
		<pre>
    for_each(v.begin(), v.end(), &amp;Shape::draw);
</pre>
		<p>如果要文档化这个特性，库作者只需要简单地记述：</p>
		<h4 style="MARGIN-LEFT: 20pt">template&lt;class It, class R, class T&gt; void for_each(It first, It last, R (T::*pmf) ());</h4>
		<p style="MARGIN-LEFT: 20pt"><b>效果：</b>等价于 std::for_each(first, last, boost::mem_fn(pmf));</p>
		<p>而 <b>boost::mem_fn</b> 可以链接到本页。参见 <a href="bind.html"><b>bind</b> 文档</a>中的例子。</p>
		<p><b>mem_fn</b> 持有一个参数，一个指向成员的指针，并返回一个适用于标准或用户定义算法的函数对象：</p>
		<pre>
struct X
{
    void f();
};

void g(std::vector&lt;X&gt; &amp; v)
{
    std::for_each(v.begin(), v.end(), boost::mem_fn(&amp;X::f));
};

void h(std::vector&lt;X *&gt; const &amp; v)
{
    std::for_each(v.begin(), v.end(), boost::mem_fn(&amp;X::f));
};

void k(std::vector&lt;boost::shared_ptr&lt;X&gt; &gt; const &amp; v)
{
    std::for_each(v.begin(), v.end(), boost::mem_fn(&amp;X::f));
};
</pre>
		<p>返回的函数对象和输入的成员函数持有同样的参数，外加一个代表对象实例的“固定”的第一个参数。</p>
		<p>当函数对象以 <b>x</b> 为第一个参数被调用，这个 <b>x</b> 既不是一个指向适当类（上例中的 <b>X</b>）的指针，也不是引向适当类（上例中的 <b>X</b>）的引用，它用 <tt>get_pointer(x)</tt> 从 <b>x</b> 获得一个指针。库作者可以通过提供一个适当的 <b>get_pointer</b> 重载来“登记”他们的智能指针类，允许 <b>mem_fn</b> 识别并支持它们。</p>
		<p>【注意：<b>get_pointer</b> 并没有被限制于返回一个指针。它可以返回能用于一个成员函数调用表达式 <tt>(x-&gt;*pmf)(...)</tt> 中的任何对象。】</p>
		<p>【注意：这个库使用了一个 <b>get_pointer</b> 的未加限定的调用。因此，通过 argument-dependent lookup（参数依赖查找）它会发现除了一些 <b>boost::get_pointer</b> 重载之外，还有和对应的智能指针类定义在同一个名字空间中的 <b>get_pointer</b> 重载。】</p>
		<p>所有由 <b>mem_fn</b> 返回的函数对象都会暴露一个 <b>result_type</b> typedef，它代表这个成员函数的返回类型。对于数据成员，<STRONG>result_type</STRONG> 定义为这个成员的类型。</p>
		<h2><a name="FAQ">Frequently Asked Questions</a></h2>
		<h3><a name="Q1">Can <b>mem_fn</b> be used instead of the standard <b>std::mem_fun[_ref]</b>
				adaptors?</a></h3>
		<p>
			Yes. For simple uses, <b>mem_fn</b> provides additional functionality that the 
			standard adaptors do not. Complicated expressions that use <b>std::bind1st</b>, <b>std::bind2nd</b>
			or <a href="../compose/index.htm"><b>Boost.Compose</b></a> along with the 
			standard adaptors can be rewritten using <a href="bind.html"><b>boost::bind</b></a>
			that automatically takes advantage of <b>mem_fn</b>.
		</p>
		<h3><a name="Q2">Should I replace every occurence of <b>std::mem_fun[_ref]</b> with <b>mem_fn</b>
				in my existing code?</a></h3>
		<p>
			No, unless you have good reasons to do so. <b>mem_fn</b> is not 100% compatible 
			with the standard adaptors, although it comes pretty close. In particular, <b>mem_fn</b>
			does not return objects of type <b>std::[const_]mem_fun[1][_ref]_t</b>, as the 
			standard adaptors do, and it is not possible to fully describe the type of the 
			first argument using the standard <b>argument_type</b> and <b>first_argument_type</b>
			nested typedefs. Libraries that need adaptable function objects in order to 
			function might not like <b>mem_fn</b>.
		</p>
		<h3><a name="Q3">Does <b>mem_fn</b> work with COM methods?</a></h3>
		<p>
			Yes, if you <a href="#stdcall">#define BOOST_MEM_FN_ENABLE_STDCALL</a>.
		</p>
		<h3><a name="Q4">Why isn't BOOST_MEM_FN_ENABLE_STDCALL defined automatically?</a></h3>
		<p>
			Non-portable extensions, in general, should default to off to prevent vendor 
			lock-in. Had BOOST_MEM_FN_ENABLE_STDCALL been defined automatically, you could 
			have accidentally taken advantage of it without realizing that your code is, 
			perhaps, no longer portable. In addition, it is possible for the default 
			calling convention to be __stdcall, in which case enabling __stdcall support 
			will result in duplicate definitions.
		</p>
		<h2><a name="Interface">Interface</a></h2>
		<h3><a name="Synopsis">Synopsis</a></h3>
		<pre>
namespace boost
{

template&lt;class T&gt; T * <a href="#get_pointer_1">get_pointer</a>(T * p);

template&lt;class R, class T&gt; <i>unspecified-1</i> <a href="#mem_fn_1">mem_fn</a>(R (T::*pmf) ());

template&lt;class R, class T&gt; <i>unspecified-2</i> <a href="#mem_fn_2">mem_fn</a>(R (T::*pmf) () const);

template&lt;class R, class T&gt; <i>unspecified-2-1</i> <a href="#mem_fn_2_1">mem_fn</a>(R T::*pm);

template&lt;class R, class T, class A1&gt; <i>unspecified-3</i> <a href="#mem_fn_3">mem_fn</a>(R (T::*pmf) (A1));

template&lt;class R, class T, class A1&gt; <i>unspecified-4</i> <a href="#mem_fn_4">mem_fn</a>(R (T::*pmf) (A1) const);

template&lt;class R, class T, class A1, class A2&gt; <i>unspecified-5</i> <a href="#mem_fn_5">mem_fn</a>(R (T::*pmf) (A1, A2));

template&lt;class R, class T, class A1, class A2&gt; <i>unspecified-6</i> <a href="#mem_fn_6">mem_fn</a>(R (T::*pmf) (A1, A2) const);

// implementation defined number of additional overloads for more arguments

}
</pre>
		<h3><a name="CommonRequirements">Common requirements</a></h3>
		<p>
			All <tt><i>unspecified-N</i></tt> types mentioned in the Synopsis are <b>CopyConstructible</b>
			and <b>Assignable</b>. Their copy constructors and assignment operators do not 
			throw exceptions. <tt><i>unspecified-N</i>::result_type</tt> is defined as the 
			return type of the member function pointer passed as an argument to <b>mem_fn</b>
			(<b>R</b> in the Synopsis.) <tt><i>unspecified-2-1</i>::result_type</tt> is 
			defined as <tt>R</tt>.
		</p>
		<h3><a name="get_pointer">get_pointer</a></h3>
		<h4><a name="get_pointer_1">template&lt;class T&gt; T * get_pointer(T * p)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> <tt>p</tt>.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h3><a name="mem_fn">mem_fn</a></h3>
		<h4><a name="mem_fn_1">template&lt;class R, class T&gt; <i>unspecified-1</i> mem_fn(R 
				(T::*pmf) ())</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> a function object <i>f</i> such that the expression <tt><i>f(t)</i></tt>
				is equivalent to <tt>(t.*pmf)()</tt> when <i>t</i> is an l-value of type <STRONG>T </STRONG>
				or derived, <tt>(get_pointer(t)-&gt;*pmf)()</tt> otherwise.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h4><a name="mem_fn_2">template&lt;class R, class T&gt; <i>unspecified-2</i> mem_fn(R 
				(T::*pmf) () const)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> a function object <i>f</i> such that the expression <tt><i>f(t)</i></tt>
				is equivalent to <tt>(t.*pmf)()</tt> when <i>t</i> is of type <STRONG>T</STRONG>
				<EM>[const]<STRONG> </STRONG></EM>or derived, <tt>(get_pointer(t)-&gt;*pmf)()</tt>
				otherwise.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h4><a name="mem_fn_2_1">template&lt;class R, class T&gt; <i>unspecified-2-1</i> mem_fn(R 
				T::*pm)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> a function object <i>f</i> such that the expression <tt><i>f(t)</i></tt>
				is equivalent to <tt>t.*pm</tt> when <i>t</i> is of type <STRONG>T</STRONG> <EM>[const]<STRONG>
					</STRONG></EM>or derived, <tt>get_pointer(t)-&gt;*pm</tt> otherwise.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h4><a name="mem_fn_3">template&lt;class R, class T, class A1&gt; <i>unspecified-3</i> mem_fn(R 
				(T::*pmf) (A1))</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> a function object <i>f</i> such that the expression <tt><i>f(t, a1)</i></tt>
				is equivalent to <tt>(t.*pmf)(a1)</tt> when <i>t</i> is an l-value of type <STRONG>T
				</STRONG>or derived, <tt>(get_pointer(t)-&gt;*pmf)(a1)</tt> otherwise.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h4><a name="mem_fn_4">template&lt;class R, class T, class A1&gt; <i>unspecified-4</i> mem_fn(R 
				(T::*pmf) (A1) const)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> a function object <i>f</i> such that the expression <tt><i>f(t, a1)</i></tt>
				is equivalent to <tt>(t.*pmf)(a1)</tt> when <i>t</i> is of type <STRONG>T</STRONG>
				<EM>[const]<STRONG> </STRONG></EM>or derived, <tt>(get_pointer(t)-&gt;*pmf)(a1)</tt>
				otherwise.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h4><a name="mem_fn_5">template&lt;class R, class T, class A1, class A2&gt; <i>unspecified-5</i>
				mem_fn(R (T::*pmf) (A1, A2))</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> a function object <i>f</i> such that the expression <tt><i>f(t, a1, a2)</i></tt>
				is equivalent to <tt>(t.*pmf)(a1, a2)</tt> when <i>t</i> is an l-value of type <STRONG>
					T</STRONG> or derived, <tt>(get_pointer(t)-&gt;*pmf)(a1, a2)</tt> otherwise.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h4><a name="mem_fn_6">template&lt;class R, class T, class A1, class A2&gt; <i>unspecified-6</i>
				mem_fn(R (T::*pmf) (A1, A2) const)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> a function object <i>f</i> such that the expression <tt><i>f(t, a1, a2)</i></tt>
				is equivalent to <tt>(t.*pmf)(a1, a2)</tt> when <i>t</i> is of type <STRONG>T</STRONG>
				<EM>[const]</EM> or derived, <tt>(get_pointer(t)-&gt;*pmf)(a1, a2)</tt> otherwise.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h2><a name="Implementation">Implementation</a></h2>
		<h3><a name="Files">Files</a></h3>
		<ul>
			<li>
				<a href="../../boost/mem_fn.hpp">boost/mem_fn.hpp</a>
			(main header)
			<li>
				<a href="../../boost/bind/mem_fn_cc.hpp">boost/bind/mem_fn_cc.hpp</a>
			(used by mem_fn.hpp, do not include directly)
			<li>
				<a href="../../boost/bind/mem_fn_vw.hpp">boost/bind/mem_fn_vw.hpp</a>
			(used by mem_fn.hpp, do not include directly)
			<li>
				<a href="../../boost/bind/mem_fn_template.hpp">boost/bind/mem_fn_template.hpp</a>
			(used by mem_fn.hpp, do not include directly)
			<li>
				<a href="test/mem_fn_test.cpp">libs/bind/test/mem_fn_test.cpp</a>
			(test)
			<li>
				<a href="test/mem_fn_derived_test.cpp">libs/bind/test/mem_fn_derived_test.cpp</a>
			(test with derived objects)
			<li>
				<a href="test/mem_fn_fastcall_test.cpp">libs/bind/test/mem_fn_fastcall_test.cpp</a>
			(test for __fastcall)
			<li>
				<a href="test/mem_fn_stdcall_test.cpp">libs/bind/test/mem_fn_stdcall_test.cpp</a>
			(test for __stdcall)
			<li>
				<a href="test/mem_fn_void_test.cpp">libs/bind/test/mem_fn_void_test.cpp</a> (test 
				for void returns)</li>
		</ul>
		<h3><a name="Dependencies">Dependencies</a></h3>
		<ul>
			<li>
				<a href="../config/config.htm">Boost.Config</a></li>
		</ul>
		<h3><a name="NumberOfArguments">Number of Arguments</a></h3>
		<p>
			This implementation supports member functions with up to eight arguments. This 
			is not an inherent limitation of the design, but an implementation detail.
		</p>
		<h3><a name="stdcall">"__stdcall", "__cdecl" and "__fastcall" Support</a></h3>
		<p>
			Some platforms allow several types of member functions that differ by their <b>calling 
				convention</b> (the rules by which the function is invoked: how are 
			arguments passed, how is the return value handled, and who cleans up the stack 
			- if any.)
		</p>
		<p>
			For example, Windows API functions and COM interface member functions use a 
			calling convention known as <b>__stdcall</b>. Borland VCL components use <STRONG>__fastcall</STRONG>. 
			UDK, the component model of OpenOffice.org, uses <STRONG>__cdecl</STRONG>.
		</p>
		<p>
			To use <b>mem_fn</b> with <b>__stdcall</b> member functions, <b>#define</b> the 
			macro <b>BOOST_MEM_FN_ENABLE_STDCALL</b> before including, directly or 
			indirectly, <b>&lt;boost/mem_fn.hpp&gt;</b>.
		</p>
		<P>To use <B>mem_fn</B> with <B>__fastcall</B> member functions, <B>#define</B> the 
			macro <B>BOOST_MEM_FN_ENABLE_FASTCALL</B> before including <B>&lt;boost/mem_fn.hpp&gt;</B>.
		</P>
		<P>To use <B>mem_fn</B> with <B>__cdecl</B> member functions, <B>#define</B> the 
			macro <B>BOOST_MEM_FN_ENABLE_CDECL</B> before including <B>&lt;boost/mem_fn.hpp&gt;</B>.
		</P>
		<P><STRONG>It is best to define these macros in the project options, via -D on the 
				command line, or as the first line in the translation unit (.cpp file) where 
				mem_fn is used.</STRONG> Not following this rule can lead to obscure errors 
			when a header includes mem_fn.hpp before the macro has been defined.</P>
		<P>[Note: this is a non-portable extension. It is not part of the interface.]
		</P>
		<p>
			[Note: Some compilers provide only minimal support for the <b>__stdcall</b> keyword.]
		</p>
		<h2><a name="Acknowledgements">Acknowledgements</a></h2>
		<p>
			Rene Jager's initial suggestion of using traits classes to make <b>mem_fn</b> adapt 
			to user-defined smart pointers inspired the <b>get_pointer</b>-based design.
		</p>
		<p>
			Numerous improvements were suggested during the formal review period by Richard 
			Crossley, Jens Maurer, Ed Brey, and others. Review manager was Darin Adler.
		</p>
		<p>
			Steve Anichini pointed out that COM interfaces use <b>__stdcall</b>.
		</p>
		<p>
			Dave Abrahams modified <b>bind</b> and <b>mem_fn</b> to support void returns on 
			deficient compilers.
		</p>
		<p>Daniel Boelzle pointed out that UDK uses <STRONG>__cdecl</STRONG>.<br>
			<br>
			<br>
			<small>Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Copyright 
				2003-2005 Peter Dimov. Distributed under the Boost Software License, Version 
				1.0. See accompanying file <A href="../../LICENSE_1_0.txt">LICENSE_1_0.txt</A> or 
				copy at <A href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>.</small></p>
	</body>
</html>

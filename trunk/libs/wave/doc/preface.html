<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


  
  <title>Preface</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <link href="theme/style.css" rel="stylesheet" type="text/css"></head>
<body background="theme/bkd.gif" text="#000000">

<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">

  <tbody>
    <tr>
 
    <td width="21"> 
      <h1></h1>
      </td>

    <td width="885"> <font face="Verdana, Arial, Helvetica, sans-serif"><b><font size="6">Preface 前言</font></b></font></td>

    <td width="96"><a href="http://www.boost.org"><img src="theme/wave.gif" align="right" border="0" height="68" width="93"></a></td>

  </tr>

  </tbody>
</table>

<br>

<table border="0">

  <tbody>
    <tr>
 
    <td width="10"></td>

    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>

    <td width="30"><img src="theme/l_arr_disabled.gif" border="0" height="19" width="20"></td>

    <td width="30"><a href="introduction.html"><img src="theme/r_arr.gif" border="0"></a></td>

  </tr>

  </tbody>
</table>

<p>During the last time many new features have been developed as additions to the <tt>Spirit</tt> 
  <a href="references.html#spirit">[4]</a> parser construction framework and we 
  felt more and more, that it would be very helpful, to have a 'real world' example, 
  which could be used as a sandbox for testing the usability of certain features. 
  Additionally&nbsp;a recent discussion on the Boost mailing list showed the widespread 
  interest of developers to have a modern, open source C++ preprocessor library 
  to play with.&nbsp; So we had the idea to implement a C++ preprocessor to fit 
  this needs&nbsp;-&nbsp;<tt>Wave</tt> was born.<br>在过去的时间里，有许多新的功能被作为 <tt>Spirit</tt> 
  <a href="references.html#spirit">[4]</a>
分析器构建框架的附加特性被开发出来，我们越来越觉得，如果有一个'真实世界'的例子可以用作测试某种功能的可用性的沙盘，将会非常有用。此外，在
Boost邮件列表上最近的讨论显示，广大开发者对于一个现代的、开源的C++预处理器库怀有兴趣。因此我们有了这个想法，实现一个C++预处理器来适应
这一需求&nbsp;- 于是就有了 <tt>Wave</tt>。</p>

<p align="justify">The <tt>Wave</tt> C++ preprocessor library uses the <a href="http://www.boost.org/"> 
  </a> <tt>Spirit<a href="references.html#spirit">[4]</a></tt> parser construction 
  library to implement a C++ lexer with ISO/ANSI Standards conformant preprocessing 
  capabilities. It exposes an iterator interface, which returns the current preprocessed 
  token from the input stream. This preprocessed token is generated on the fly 
  while iterating over the preprocessor iterator sequence (in the terminology 
  of the STL these iterators are forward iterators).<br><tt>Wave</tt> C++预处理器库使用了 <a href="http://www.boost.org/"> 
  </a> <tt>Spirit<a href="references.html#spirit">[4]</a></tt> 分析器构建框架来实现一个符合ISO/ANSI标准预处理功能的C++ lexer。它提供一个迭代器接口，从输入流返回当前的预处理单词。当你对预处理器迭代器序列(用STL的术语来说，这个迭代器是前向迭代器)进行迭代时，预处理单词是就地生成的。 </p>

<p align="justify"> The C++ preprocessor is a macro processor that under normal 
  circumstances is used automatically by your C++ compiler to transform your program 
  before actual compilation. It is called a macro processor because it allows 
   to define macros, which are brief abbreviations for longer constructs. The 
  C++ preprocessor provides four separate facilities that you can use as you see 
  fit:<br>C++预处理器是一个宏处理器，在正常情况下，它会被你的C++编译器在进行实际编译前用来对你的程序进行转换。它被称为宏处理器，是因为它允许定义宏，宏是较长结构的缩写。C++预处理器提供了四个独立的工具，你可以按照你认为合适的方式来使用： </p>

<blockquote> 
  
  <p><b><img src="theme/bullet.gif" id="IMG1" height="13" width="13">&nbsp;</b>Inclusion 
    of header files 包含头文件<br>

    <b><img src="theme/bullet.gif" id="IMG1" height="13" width="13">&nbsp;</b>Macro 
    expansion 宏展开<br>

    <b><img src="theme/bullet.gif" id="IMG1" height="13" width="13">&nbsp;</b>Conditional 
    compilation 条件编译<br>

    <b><img src="theme/bullet.gif" id="IMG1" height="13" width="13">&nbsp;</b>Line 
    control 行控制</p>

</blockquote>

<p>These features are greatly underestimated today, even more, the preprocessor 
  has been frowned on for so long that its usage just hasn't been effectively 
  pushed until the Boost preprocessor library <a href="references.html#pp_lib">[7]</a> 
  came into being a few years ago. Only today we begin to understand, that preprocessor 
  generative metaprogramming combined with template metaprogramming in C++ is 
  by far one of the most powerful compile-time reflection/metaprogramming facilities 
  that any language has ever supported.<br>如今这些功能被大大地低估了，甚至长期以来预处理器都被是不被赞成的，直至几年前 Boost preprocessor 库<a href="references.html#pp_lib">[7]</a>诞生之前，它的用途都没有被有效推广。直到现在，我们才开始明白，预处理器生成的元程序和C++中的模板元编程相结合，是迄今为止所有语言所支持的编译期反射/元编程工具中最为强大的之一。</p>

<p>The C++ Standard <a href="http://webstore.ansi.org/ansidocstore/product.asp?sku=INCITS%2FISO%2FIEC%2B14882%2D1998">[2] </a>
was adopted back in 1998, but there is still no (known to me)
commercial C++ compiler, which has a bugfree implementation of the
rather simple preprocessor requirements mandated therein. This may be a
result of the mentioned underestimation or even banning of the
preprocessor from good programming style during the last few years or
may stem from the somewhat awkward standardese dialect of English used
to describe it. Two open source projects are exceptions of this: gcc
and Clang (a subproject of LLVM), both providing preprocessors with
very good standards conformance.<br>C++标准<a href="http://webstore.ansi.org/ansidocstore/product.asp?sku=INCITS%2FISO%2FIEC%2B14882%2D1998">[2]</a>是
在上1998年通过的，但是直到现在仍然没有(就我所知)一个商业C++编译器，对于那怕是简单的预处理要求，具有无错的实现。这可能是上述对预处理器的
低估所导致的，也可能是源于最近几年的优良编程风格对预处理器的抗拒，也可能是由于标准中使用了有点笨拙的英语方言来描述它。有两个开源项目是例外：
gcc 和 Clang (LLVM的一个子项目)，它们都提供了具有非常好的标准符合性的预处理器。 </p>

<p align="justify">So the main goals for the <tt>Wave</tt> project are:<br>因此，<tt>Wave</tt> 项目的主要目标是：</p>

<blockquote> 
  
  <p><b><img src="theme/bullet.gif" id="IMG1" height="13" width="13">&nbsp;</b>full 
    conformance with the C++ standard (ISO/IEC 14882:1998) <a href="references.html#iso_cpp">[1]</a> 
    and with the C99 standard (INCITS/ISO/IEC 9899:1999) <a href="references.html#iso_c">[2]</a><br>完全符合C++标准(ISO/IEC 14882:1998) <a href="references.html#iso_cpp">[1]</a> 
    和C99标准(INCITS/ISO/IEC 9899:1999) <a href="references.html#iso_c">[2]</a><br>

    <b><img src="theme/bullet.gif" height="13" width="13">&nbsp;</b>usage of <tt>Spirit<a href="references.html#spirit">[4]</a></tt> 
    for the parsing parts of the game (certainly :-)<br>使用 <tt>Spirit<a href="references.html#spirit">[4]</a></tt> 作为分析部分(这是当然的 :-)<br>

    <b><img src="theme/bullet.gif" height="13" width="13">&nbsp;</b>maximal usage 
    of STL and/or <tt>Boost</tt> libraries (for compactness and maintainability)<br>最大可能地使用 STL 和/或 <tt>Boost</tt> 库(为了简洁性和可维护性)<br>

    <b><img src="theme/bullet.gif" height="13" width="13">&nbsp;</b>straightforward 
    extendability for the implementation of additional features<br>简单地扩展即可实现其它功能<br>

    <b><img src="theme/bullet.gif" height="13" width="13">&nbsp;</b>building a 
    flexible library for different C++ lexing and preprocessing needs<br>为不同的 C++ lexing 和预处理需要构建一个灵活的库</p>

</blockquote>

<p>At the first steps it is not planned to make a very high performance
or very small C++ preprocessor. If you are looking for these objectives
you probably have to look at other places. Although our C++
preprocessor iterator works as expected and is usable as a reference
implementation, for instance for testing of other preprocessor oriented
libraries as the Boost Preprocessor library <a href="references.html#pp_lib">[7]</a> et.al. Nevertheless recent work has lead to surprising performance enhancements (if compared
  with earlier versions). Wave is still somewhat slower as for instance EDG
  based preprocessors (Intel, Comeau) on simple input files, however, as
  complexity increases, time dilates expontentially on EDG. Preprocessing time
  dilates linearly under Wave, which causes it to easily outperform EDG based
preprocessors when complexity increases.<br>首先，我们并不打算将它实现为一个非常高性能或非常小的C++预处理器。如果你正在寻找这样的东西，那么你可能要换个地方找找。虽然我们的C++预处理迭代器可以如预期地工作，也可作为参考实现，例如用于测试象 Boost Preprocessor 库<a href="references.html#pp_lib">[7]</a>这
样的面向预处理器的库。但是近期的工作取得了令人惊讶的性能提升(与早期版本相比)。对于简单的输入文件，Wave依然要比基于EDG的预处理器
(Intel,
Comeau)慢一点，不过随着复杂性的增加，EDG的时间是以指数方式增加。在Wave下的预处理时间则是线性增加的，所以在复杂性增加时，它可以轻易
胜过基于EDG的预处理器。</p>

<p>As tests showed, the <tt>Wave</tt> library is very conformant to the C++ Standard, 
  such that it compiles several strict conformant macro definitions, which are 
not even compilable with EDG based preprocessors (i.e. Comeau or Intel).<br>正如测试结果所显示的，<tt>Wave</tt> 库非常符合C++标准，例如它编译了几个严格符合性的宏定义，这些宏甚至不能与基于EDG的预处理器(如 Comeau 或 Intel)相兼容。 </p>

<table border="0">

  <tbody>
    <tr>
 
    <td width="10"></td>

    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>

    <td width="30"><img src="theme/l_arr_disabled.gif" border="0" height="19" width="20"></td>

    <td width="30"><a href="introduction.html"><img src="theme/r_arr.gif" border="0"></a></td>

  </tr>

  </tbody>
</table>

<hr size="1">
<p class="copyright">Copyright © 2003-2008 Hartmut Kaiser<br>

  <br>

<font size="2">Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt) </font> </p>

<span class="updated"></span>
<p class="copyright"><span class="updated">Last updated: 
  <!-- #BeginDate format:fcAm1m -->Sunday, December 2, 2007  19:03<!-- #EndDate -->
</span></p>

</body></html>
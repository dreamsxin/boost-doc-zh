<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<title>Compile Time Configuration</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="theme/style.css" rel="stylesheet" type="text/css"></head>
<body>
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr> 
    <td width="21"> <h1></h1></td>
    <td width="885"> <font face="Verdana, Arial, Helvetica, sans-serif"><b><font size="6">Compile 
      Time Configuration 编译期配置</font></b></font></td>
    <td width="96"><a href="http://www.boost.org"><img src="theme/wave.gif" align="right" border="0" height="68" width="93"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="macro_expansion_process.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="30"><a href="samples.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<p><b><a name="compiletime_config"></a>Library compile time configuration 库的编译期配置</b></p>
<p dir="ltr">The C++ preprocessor iterator library may be configured at compile 
  time by specifying different preprocessor constants to include different additional 
  features. The possible preprocessor constants are described in the following 
  table.<br>C++预处理迭代器库可以在编译期进行配置，方法是通过指定不同的预处理器常量来包含不同的额外特性。下表列出了可用的预处理器常量。 </p>
<table align="center" border="0" width="100%">
  <tbody><tr> 
    <td colspan="2" class="table_title"><b>Summary of possible preprocessor constants 
      for library configuration<br>可以用于库配置的预处理器常量概要</b></td>
  </tr>
  <tr> 
    <td class="table_cells" width="46%"><code>BOOST_WAVE_SUPPORT_WARNING_DIRECTIVE</code></td>
    <td class="table_cells" width="54%"> <p>Support the <span class="preprocessor">#warning</span> directive</p><p>支持 <span class="preprocessor">#warning</span> 指令</p></td>
  </tr>
  <tr> 
    <td class="table_cells" width="46%"><code>BOOST_WAVE_SUPPORT_MS_EXTENSIONS</code></td>
    <td class="table_cells" width="54%"> <p>Support several MS specific language 
        extensions (i.e. <tt>__int8</tt> et.al.)</p><p>支持几个 MS 专用的语言扩展(即 <tt>__int8</tt> 等等)</p></td>
  </tr>
  <tr> 
    <td class="table_cells"><code>BOOST_WAVE_PREPROCESS_ERROR_MESSAGE_BODY</code></td>
    <td class="table_cells"><p>Enable the preprocessing of the message bodies 
        of <span class="preprocessor">#error</span> and <span class="preprocessor">#warning</span> 
        directives.</p><p>激活对 <span class="preprocessor">#error</span> 和 <span class="preprocessor">#warning</span> 
        指令的信息体的预处理。</p></td>
  </tr>
  <tr> 
    <td class="table_cells"><code>BOOST_WAVE_EMIT_PRAGMA_DIRECTIVES</code></td>
    <td class="table_cells"><p>If defined, then the <span class="preprocessor">#pragma</span> 
        directives are returned as a token sequence to the caller, if not defined, 
        the whole <span class="preprocessor">#pragma</span> directive is skipped.</p><p>如果被定义，则 <span class="preprocessor">#pragma</span> 
        指令以一个单词序列返回给调用者，如果未定义，则忽略整个 <span class="preprocessor">#pragma</span> 指令。 </p></td>
  </tr>
  <tr> 
    <td class="table_cells"><code>BOOST_WAVE_PREPROCESS_PRAGMA_BODY</code></td>
    <td class="table_cells"><p>Enable the preprocessing of the bodies of all <span class="preprocessor"> 
        #pragma</span> directives.<br>
        Note though, that the body of an <tt>operator&nbsp;_Pragma()</tt> is always preprocessed as this is required by the C99 Standard <a href="references.html#iso_c">[2]</a>.</p><p>激活对所有 <span class="preprocessor"> 
        #pragma</span> 指令体的预处理。不过请注意，<tt>operator&nbsp;_Pragma()</tt> 的指令体总是要进行预处理的，这是 C99 标准<a href="references.html#iso_c">[2]</a>的要求。 
      </p></td>
  </tr>
  <tr> 
    <td class="table_cells"><code>BOOST_WAVE_ENABLE_COMMANDLINE_MACROS</code></td>
    <td class="table_cells"><p>Enable the functionality required to define macros 
        with the command line syntax (-DMACRO(x)=definition)<br>激活以命令行语法进行宏定义(-DMACRO(x)=definition)所需要的功能。</p></td>
  </tr>
  <tr> 
    <td class="table_cells"><code>BOOST_WAVE_STRINGTYPE</code></td>
    <td class="table_cells"><p>The tokens generated by the <tt>Wave</tt> library 
        contain the token data and the file position, where this token was found 
        in the input stream. <br>
        This constant may be used to redefine the data type, which is used to 
        hold the token data and the corresponding file name. If this isn't defined 
        it defaults to std::string. (The here defined data type should be compatible 
        to the std::string type)</p><p>由 <tt>Wave</tt> 库生成的单词含有单词数据和文件位置，即单词在输入流的何处被找到。<br>这个常量可用于重新定义数据类型，以保存单词数据和对应的文件名。如果未定义，则缺省为 std::string。(所定义的数据类型应兼容于 std::string 类型)</p></td>
  </tr>
  <tr> 
    <td class="table_cells"><code>BOOST_WAVE_SUPPORT_VARIADICS_PLACEMARKERS</code></td>
    <td class="table_cells"><p>If defined, then the preprocessor library supports 
        variadics and placemarkers. Note, to support C99 mode, this constant must 
        be defined too.<br>如果被定义，则预处理器库支持variadics和placemarkers。注意，要支持C99模式，这个常量也必须被定义。</p></td>
  </tr>
  <tr> 
    <td class="table_cells"><code>BOOST_WAVE_MAX_INCLUDE_LEVEL_DEPTH</code></td>
    <td class="table_cells"><p>If defined, it will determine the initial maximal 
        possible include file nesting depth supported. It defaults to 1024.<br>如果被定义，它将决定可支持的包含文件嵌套深度的初始最大值。缺省为1024.</p></td>
  </tr>
  <tr>
    <td class="table_cells"><code>BOOST_WAVE_SUPPORT_PRAGMA_ONCE</code></td>
    <td class="table_cells"><p>If defined, then the <code>#pragma once</code> directive is supported by <tt>Wave</tt>. This specifies that the file, in which the pragma resides, will be included 
      (opened) only once by the compiler in a build.<br>如果被定义，则 <tt>Wave</tt> 支持 <code>#pragma once</code> 指令。它指定该 pragma 所在的文件在一次构建中只能被编译器包含(打开)一次。 </p></td>
  </tr>
  <tr>
    <td class="table_cells"><code>BOOST_WAVE_SUPPORT_PRAGMA_MESSAGE</code></td>
    <td class="table_cells"><p>If defined, then the <code class="preprocessor">#pragma message("")</code> directive is supported by <tt>Wave</tt>.
This pragma simply generates a remark cotaining the message text. The
body of the #pragma message is preprocessed whenever the <code><code>BOOST_</code>WAVE_PREPROCESS_PRAGMA_BODY</code> constant is defined as well .</p><p>如果被定义，则 <tt>Wave</tt> 支持 <code class="preprocessor">#pragma message("")</code> 指令。这个 pragma 只是生成一个含有信息文字的注释。当 <code><code>BOOST_</code>WAVE_PREPROCESS_PRAGMA_BODY</code> 常量被定义时，#pragma 信息的内容也会被预处理。 </p></td>
  </tr>
  <tr>
    <td class="table_cells"><code>BOOST_WAVE_SUPPORT_INCLUDE_NEXT</code></td>
    <td class="table_cells"><p>If defined, then the <code>#include_next</code> directive is supported by <tt>Wave</tt>. This is syntactically equivalent to the <code class="preprocessor">#include</code>
directives, but may be used to inherit a header file (i.e. to include a
file, which is named as the current file containing the <code>#include_next</code>).</p><p>如果被定义，则 <tt>Wave</tt> 支持 <code>#include_next</code> 指令。该指令在语法上与 <code class="preprocessor">#include</code>
指令等价，但可以用于继承一个头文件(即包含一个与含有 <code>#include_next</code> 的当前文件同名的文件)。</p></td>
  </tr>
  <tr>
    <td class="table_cells"><code>BOOST_WAVE_USE_STRICT_LEXER</code></td>
    <td class="table_cells"><p>If this is defined to something != 0, then the C/C++ lexers recognize the 
      strict C99/C++ basic source character set. If it is not defined or defined 
    to zero, the lexers recognize the <span class="string">'$'</span> character as part of identifiers.</p><p>如果被定义为 != 0，则 C/C++ lexers 将识别严格的 C99/C++ 基本源代码字符集。如果未定义为零，则 lexers 将字符<span class="string">'$'</span>识别为标识符的一部分。</p></td>
  </tr>
  <tr>
    <td class="table_cells"><code>BOOST_WAVE_PRAGMA_KEYWORD</code></td>
    <td class="table_cells"><p>If
this is defined to a string literal it will be used as the pragma
keyword recogniyed by the library as specific Wave pragma's. This
constant defaults to <span class="literal">"wave"</span>, i.e. the library recognizes all      <span class="preprocessor">#pragma wave option [(argument)]</span>  directives and dispatches the handling to the interpret_pragma() preprocessing hook function (see: <a href="class_reference_ctxpolicy.html">Preprocessing Hooks</a>). The arguments part of the  pragma is optional.</p><p>如果被定义为一个字符串文字，则它将被本库当作 pragma
关键字识别为特定的 Wave pragma。该常量缺省为 <span class="literal">"wave"</span>，即本库识别所有      <span class="preprocessor">#pragma wave option [(argument)]</span>  指令并将它们的处理分发到 interpret_pragma() 预处理钩子函数(请见：<a href="class_reference_ctxpolicy.html">预处理钩子</a>)。pragma 的参数部分是可选的。<br>
      </p>    </td>
  </tr>
  <tr>
    <td class="table_cells"><code>BOOST_WAVE_USE_DEPRECIATED_PREPROCESSING_HOOKS</code></td>
    <td class="table_cells"><p>If defined to something not equal to zero (<span class="literal">'0'</span>)
Wave will be compiled to use the depreciated preprocessing hooks. The
interface of the preprocessing hooks has been changed after the Boost
V1.34.x releases. This constant allows to compile applications using
the older interface.<br>如果被定义为不等于零(<span class="literal">'0'</span>)，则
Wave 将被编译为使用旧的预处理钩子。这些预处理钩子的接口在 Boost
V1.34.x 版本后已经被修改。该常量允许使用旧的接口来编译应用程序。 </p></td>
  </tr>
  <tr>
    <td class="table_cells"><code>BOOST_WAVE_SUPPORT_LONGLONG_INTEGER_LITERALS</code></td>
    <td class="table_cells"><p>The C++ standard requires the preprocessor to use one of the following 
      types for integer literals: <code>long</code> or <code>unsigned long</code> depending on a optional 
      suffix (<span class="literal">'u'</span>, <span class="literal">'l'</span>, <span class="literal">'ul'</span>, or <span class="literal">'lu'</span>). Sometimes it is required to preprocess integer literals larger than that
        (i.e. <code>long long</code> or <code>unsigned long long</code>). Defining this pp constant enables the recognition of long long integers
even if these do not have the <span class="literal">'ll'</span> suffix.</p><p>C++标准要求预处理器根据一个可选的后缀(<span class="literal">'u'</span>, <span class="literal">'l'</span>, <span class="literal">'ul'</span>, 或 <span class="literal">'lu'</span>)使用以下各种整数类型之一：<code>long</code> 或 <code>unsigned long。有时需要预处理的整数文字更大些</code>(即 <code>long long</code> 或 <code>unsigned long long</code>)。定义了这个pp常量就可以识别出 long long 整数，即使没有使用 <span class="literal">'ll'</span> 后缀。</p>
      <p>This preprocessor constant is effective only, if your target platform supports 
        long long integers (<code>BOOST_HAS_LONG_LONG</code> is defined). Please note, that this setting doesn't relate to the Wave support option
        <code>support_option_long_long</code>, which enables the recognition of <span class="literal">'ll'</span> suffixes 
        only.<br>这个预处理器常量仅当你的目标平台支持 long long 整数时有效(定义了 <code>BOOST_HAS_LONG_LONG</code> 时)。请注意，这个设置与 Wave 的支持选项
        <code>support_option_long_long</code> 无关，后者只启用了对 <span class="literal">'ll'</span> 后缀的识别。
    </p>
      </td>
  </tr>
    <tr>
        <td class="table_cells">
            <code>BOOST_WAVE_SUPPORT_THREADING</code></td>
        <td class="table_cells">
            <p>This preprocessor constant allows to configer whether the Wave library will be built
                with threading support enabled or not. This value (if defined) should be set to
                zero ('0') if threading needs to be disabled and to a numerical value not equal
                to zero, if threading should be enabled explicitely.</p><p>这个预处理器常量允许对 Wave 库是否被构建为支持线程进行配置。如果要禁止线程，则该值(如果被定义)应被设为零('0')，如果要明确启用线程，则应设为一个不等于零的数字。
            </p>
            <p>
                If this constant is not defined, the Wave library will be built using the threading
                as picked up from the Boost build environment (see <code>BOOST_HAS_THREADS</code> in the Boost
                    configuration dosumentation).<br>如果这个常量未定义，则 Wave 库将从 Boost 构建环境(参见 Boost 配置文档中的 <code>BOOST_HAS_THREADS</code>)获取配置决定是否构建为支持线程。</p>
        </td>
    </tr>
</tbody></table>
<p dir="ltr"><b><a name="using_custom_lexer"></a>Using a different token type or lexer type in conjunction with Wave 将不同的单词类型或lexer类型用于Wave </b></p>
<p dir="ltr">It is possible to use the <tt>Wave</tt> library while
using your own token and/or lexer types. This may be achieved by
providing your lexer type as the second template parameter while
instantiating the <tt>boost::wave::context&lt;&gt;</tt> object. The token type used by the library is derived from the <tt>token_type</tt> typedef to be provided by the lexer type. If you want to provide your own token type only, you may use the <tt>boost::wave::lex_iterator&lt;&gt;</tt> type contained with the library. This type needs to be parametrized with the token type to use.<br>可以将你自己的单词类型和/或lexer类型用于 <tt>Wave</tt> 库。可以在初始化 <tt>boost::wave::context&lt;&gt;</tt> 对象时通过将你自己的lexer类型作为第二个模板参数来实现这一点。本库所使用的单词类型派生自由该lexer类型所提供的 <tt>token_type</tt> typedef。如果你只想提供自己的单词类型，可以使用本库中的 <tt>boost::wave::lex_iterator&lt;&gt;</tt> 类型。这个类型以其所用的单词类型进行参数化。 </p>
<p dir="ltr">The <tt>Wave</tt> library contains several samples illustrating these possibilities. The <tt>cpp_tokens</tt> sample shows the usage of a custom lexer and a custom token types. The lexer type used is functionally fully compatible to the <tt>re2c</tt> <a href="references.html#re2c">[3]</a> based lexer used by default. It is implemented based on the <tt>SLex</tt> <a href="references.html#slex">[5]</a>
lexer example written by Dan Nuffer. The token type used therein is
functionally equivalent to the default token type except for an
additional <tt>operator&lt;&lt;</tt> used for dumping the information carried by the token.<br><tt>Wave</tt> 库包含有几个示范这些可能性的例子。例子 <tt>cpp_tokens</tt> 示范了一个定制的lexer和一个定制的单词类型的使用。该lexer类型在功能上完全兼容于缺省使用的基于 <tt>re2c</tt> <a href="references.html#re2c">[3]</a> 的lexer。它是基于 Dan Nuffer 所编写的 <tt>SLex</tt> <a href="references.html#slex">[5]</a>
lexer实现的。所用的单词类型在功能上等价于缺省的单词类型，除了增加了一个 <tt>operator&lt;&lt;</tt> 用于输出单词所带的信息。</p>
<p dir="ltr"><b><a name="compilation_models"></a>Separation and inclusion compilation 
  models 分离和包含的编译模式</b></p>
<p dir="ltr">The <tt>Wave</tt> C++ preprocessor iterator library is build almost 
  completely as a header only library (except for the re2c based lexer). If you're 
  trying to include all required files at once you will mention, that the resulting 
  compilation times are very large (up to an hour - depending on your system configuration). 
  This straightforward method we'll call the inclusion compilation model. If you 
  do not pay attention to compilation times, that's the way to go, no special 
  handling is needed.<br><tt>Wave</tt>
C++ 预处理迭代器库被构建为一个差不多完全只有头文件的库(除了基于 re2c 的
lexer)。如果你尝试一次过包含所有需要的文件，你将会发现所需的编译时间非常长(最多一个小时 -
取决于你的系统配置)。我们把这种简单的方法称为包含编译模式。如果你不在意编译时间，就按这种方法去做，不需要特别的处理。</p>
<p dir="ltr">If you're interested in decreasing compilation times, the following 
  method is to be used. This we will call it the separation compilation model. 
  The trick is to separate the different objects such, that they are compilable 
  separately. The function, which instantiates the templated object in question 
  is factored out such, that its definition is visible to only one translation 
  unit. To simplify this further this creation function is packaged into a small 
  generator template structure.<br>如果你想减少编译时间，可以使用以下方法。我们称之为分离编译模式。诀窍是分离不同的对象，即将它们分开编译。问题在于，对模板对象进行实例化的函数，其定义仅在一个编译单元中可见。为了进一步简化它，我们将这个创建函数打包进一个小型的生成器模板结构。</p>
<p dir="ltr">There are two levels of separation implemented: the separation of 
  the compilation of the C++ lexer and the separation of the compilation of the 
  different Spirit grammars used. To use these separations you will have to define 
  two preprocessor constants while compiling the whole application and you will 
  have to explicitely instantiate some helper templates. The following tables 
  shows these constants in detail.<br>已实现了两个分离层：C++ lexer编译的分离和所用的不同Spirit语法编译的分离。要使用这些分离，你必须在编译整个应用时定义两个预处理器常量，并且要显式地实例化一些辅助模板。下表详细列出这些常量。</p>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td colspan="2" class="table_title"><b>Summary of possible compilation constants 
      required to enable the separation compilation model<br></b><b>启用分离编译模式所需的编译常量概要</b></td>
  </tr>
  <tr class="table_title"> 
    <td width="25%"><b>Separate 分离层</b></td>
    <td width="75%"><p><font face="Verdana, Arial, Helvetica, sans-serif">Preprocessor 
        constant 预处理器常量</font></p></td>
  </tr>
  <tr> 
    <td class="table_cells" width="25%"><code>C++ lexer</code></td>
    <td class="table_cells" width="75%"> <p><code><code>BOOST_</code>WAVE_SEPARATE_LEXER_INSTANTIATION</code></p></td>
  </tr>
  <tr> 
    <td class="table_cells" width="25%"><code>Spirit grammars</code></td>
    <td class="table_cells" width="75%"> <p><code><code>BOOST_</code>WAVE_SEPARATE_GRAMMAR_INSTANTIATION</code></p></td>
  </tr>
</tbody></table>
<p dir="ltr">The following table shows the explicit template instantiations required, 
  if you want to use the separation compilation model. The <tt>TokenT</tt> placeholder 
  type has to be replaced with your token type to use and the <code><tt>LexIteratorT</tt></code> placeholder type has to be replaced with your lex iterator type you've used while instantiation of the <tt>boost::wave::context&lt;&gt;</tt> object. You will achieve the best 
  results, if you place these into separate compilation units each. The <tt>IteratorT</tt> 
  placeholder should be replaced by the iterator type, which was used to instantiate 
  the <tt>boost::wave::context&lt;&gt;</tt> object.<br>下表列出了使用分离编译模式所要进行显式实例化的模板。<tt>TokenT</tt> 占位符类型要替换为你所使用的单词类型，而 <code><tt>LexIteratorT</tt></code> 占位符类型则要替换为你在初始化 <tt>boost::wave::context&lt;&gt;</tt> 对象时使用的lex迭代器类型。如果你将它们放在各自的编译单词中，将会得到最好的结果。<tt>IteratorT</tt> 
  占位符应替换为初始化 <tt>boost::wave::context&lt;&gt;</tt> 对象时使用的迭代器类型。</p>
<table align="center" border="0" width="90%">
  <tbody><tr> 
    <td colspan="2" class="table_title"><b>Summary of required explicit template 
      instantiations required when using the separation compilation model<br></b><b>使用分离编译模式时需要显式实例化的模板概要</b></td>
  </tr>
  <tr class="table_title"> 
    <td width="25%"><b>Separate 分离层</b></td>
    <td width="75%"><p><font face="Verdana, Arial, Helvetica, sans-serif">Templates 
        to explicitly instantiate 要显式实例化的模板</font></p></td>
  </tr>
  <tr> 
    <td class="table_cells" width="25%"><code>C++ lexer</code></td>
    <td class="table_cells" width="75%"> <code><span class="keyword">template</span> 
      cpplexer::re2clex::new_lexer_gen&lt;<tt>IteratorT</tt>&gt;;</code></td>
  </tr>
  <tr> 
    <td class="table_cells" width="25%"><code>Spirit grammars</code></td>
    <td class="table_cells" width="75%"> <p><code><span class="keyword">template</span> wave::grammars::expression_grammar_gen&lt;<tt>TokenT</tt>&gt;;<br>
        <span class="keyword"> template</span> wave::grammars::intlit_grammar_gen&lt;<tt>TokenT</tt>&gt;;<br>
        <span class="keyword"> template</span> wave::grammars::chlit_grammar_gen&lt;<tt>TokenT</tt>&gt;;<br>
        <span class="keyword"> template</span> wave::grammars::cpp_grammar_gen&lt;<tt>LexIteratorT</tt>&gt;;<br>
        <span class="keyword"> template</span> wave::grammars::predefined_macros_grammar_gen&lt;<tt>LexIteratorT</tt>&gt;;<br>
    <span class="keyword"> template</span> wave::grammars::defined_grammar_gen&lt;<tt>LexIteratorT</tt>&gt;;</code></p></td>
  </tr>
</tbody></table>
<p>To see an example of this you can look at the <tt>Wave</tt> driver program 
  included as an acompanion sample to the C++ preprocessor iterator library. The 
  corresponding files are named obviously <span class="string">"instantiate_...something.cpp"</span>, 
  where the <span class="string">'...somthing'</span> is a hint, which grammars 
  are explicitely instantiated inside. By using the separation model the compilation 
  times required to build the <tt>Wave</tt> example are dropped by up to 90%.<br>要看一下例子的话，你可以看 <tt>Wave</tt> 驱动器程序，它作为一个例子包含在这个 C++ 预处理迭代器库中。相应的文件被命名为 <span class="string">"instantiate_...something.cpp"</span>，其中 <span class="string">'...somthing'</span> 是一个提示，表示其中显式实例化的是哪一个语法。通过使用分离编译模式，构建这个 <tt>Wave</tt> 例子的编译时间减少了多达 90%.</p>
<table border="0">
  <tbody><tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="macro_expansion_process.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="30"><a href="samples.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</tbody></table>
<hr size="1">
<p class="copyright">Copyright © 2003-2008 Hartmut Kaiser<br>
  <br>
<font size="2">Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt) </font> </p>
<span class="updated"></span>
<p class="copyright"><span class="updated">Last updated: 
  <!-- #BeginDate format:fcAm1m -->Tuesday, July 29, 2008  20:38<!-- #EndDate -->
</span></p>
</body></html>
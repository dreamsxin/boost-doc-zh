<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<title>Samples</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="theme/style.css" type="text/css"></head>
<body background="theme/bkd.gif" text="#000000">
<table background="theme/bkd2.gif" border="0" cellspacing="2" width="100%">
  <tbody><tr>
    <td width="21">
      <h1></h1></td>
    <td width="885"> <font face="Verdana, Arial, Helvetica, sans-serif"><b><font size="6">Samples 例子</font></b></font></td>
    <td width="96"><a href="http://www.boost.org"><img src="theme/wave.gif" align="right" border="0" height="68" width="93"></a></td>
  </tr>
</tbody></table>
<br>
<table border="0">
  <tbody><tr>
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="wave_driver.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="30"><a href="wave_driver.html"><img style="border: 0px solid ; width: 20px; height: 19px;" alt="next" src="theme/r_arr.gif"></a></td>
  </tr>
</tbody></table>
<p dir="ltr">The <tt>Wave</tt> library contains several samples illustrating how to
use the different features. This section describes these samples and
its main characteristics.<br><tt>Wave</tt> 库带有几个例子，示范了如何使用不同的特性。本节将对这些例子及其主要特征进行说明。 </p>
<h2 dir="ltr">The quick_start sample</h2>
 <p>The <tt>quick_start</tt> sample shows a minimal way to use the <tt>Wave</tt>
preprocessor library. It simply opens the file given as the first
command line argument, preprocesses it assuming that there aren't any
additional include paths or macros defined and outputs the textual
representation of the tokens generated from the given input file. This
sample may be used to introduce yourself to <tt>Wave</tt>, because it does not contain all the potential additional complexity exposed by more complex samples.<br>例子 <tt>quick_start</tt> 示范了使用 <tt>Wave</tt> 预处理器库的最简单方法。它只是打开由第一个命令行参数给定的文件，对其进行预处理，假定没有任何包含路径或宏定义，然后将从给定的输入文件生成的单词的文字表示输出。这个例子可用于将你引入到 <tt>Wave</tt>，因为它不含有其它更复杂的例子所暴露出来的潜在的其它复杂性。 </p>
 <h2>The lexed_tokens sample</h2>
 <p>The <tt>lexed_tokens</tt> sample shows a minimal way to use the C++
lexing component of Wave without using the preprocessor. It opens the
file specified as the first command line argument and prints out the
contents of the tokens returned from the lexer.<br>例子 <tt>lexed_tokens</tt> 示范了不使用预处理器而使用Wave的C++ lexing组件的最简单方法。它打开由第一个命令行参数所指定的文件，然后打印由lexer所返回的单词的内容。 </p>
 <h2>The <strong>cpp_tokens sample </strong></h2>
<p dir="ltr">The <tt>cpp_tokens</tt> sample dumps out the information contained within the tokens returned from the iterator supplied by the <tt>Wave</tt> library. It shows, how to use the <tt>Wave</tt> library in conjunction with custom lexer and custom token types. The lexer used within this sample is <tt>SLex</tt> <a href="references.html#slex">[5]</a> based, i.e. it 
is feeded during runtime (at startup) with the token definitions
(regular expressions) and generates a resulting DFA table. This table
is used for token identification and is saved to disc afterwards to
avoid the table generation process at the next program startup. The
name of the file to which the DFA table is saved is <tt>wave_slex_lexer.dfa</tt>.<br>例子 <tt>cpp_tokens</tt> 输出单词内部所含的信息，这些单词是从 <tt>Wave</tt> 库所提供的迭代器返回的。它示范了如何将 <tt>Wave</tt> 库与定制的lexer和定制的单词类型一起使用。该例子中使用的lexer是基于 <tt>SLex</tt> <a href="references.html#slex">[5]</a>的，即它是在运行期(启动时)装入单词定义(正则表达式)并生成DFA表格的。这个表格用于单词识别，并被保存到磁盘上，以避免下一次程序启动时重新生成。保存DFA表格的文件名为 <tt>wave_slex_lexer.dfa</tt>. </p>
<p dir="ltr">The main advantage of this <tt>SLex</tt> based lexer if compared to the default <tt>Re2C</tt> <a href="references.html#re2c">[3]</a>
generated lexer is, that it provides not only the line information,
where a particular token was recognized, but also the related column
position. Otherwise the <tt>SLex</tt> based lexer is functionally fully compatible to the <tt>Re2C</tt>
based one, i.e. you always may switch your application to use it, if
you additionally need to get the column information back from the
preprocessing.<br>这个基于 <tt>SLex</tt> 的lexer与缺省的 <tt>Re2C</tt> <a href="references.html#re2c">[3]</a> 生成的lexer相比，其最大优点是，不仅提供了识别出特定单词的行信息，还有相关的列位置。除此以外，基于 <tt>SLex</tt> 的lexer在功能上完全兼容于基于 <tt>Re2C</tt> 的lexer，即如果你需要从预处理过程取回列信息，随时可以将你的应用转换为使用它。 </p>
<p dir="ltr">Since no additional command line parameters are supported by this
sample, it won't work well with include files, which aren't located in
the same directory as the inspected input file. The command line syntax
is straight forward:<br>由于这个例子不支持更多的命令行参数，所以它不能处理不是和输入文件在同一目录下的头文件。其命令行语法非常简单：</p>
<pre>    cpp_tokens input_file</pre>
<h2 dir="ltr">The list_includes sample </h2>
<p dir="ltr">The <tt>list_includes</tt> sample shows how the <tt>Wave</tt> library
may be used to generate a include file dependency list for a particular
input file. It completely depends on the default library configuration.
The command line syntax for this sample is given below:<br>例子 <tt>list_includes</tt> 示范了如何使用 <tt>Wave</tt> 库为特定的输入文件生成一个头文件依赖列表。它完全取决于缺省的库配置。这个例子的命令行语法给出如下： </p>
<pre>    Usage: list_includes [options] file ...:<br>        -h [ --help ]        : print out program usage (this message)<br>        -v [ --version ]     : print the version number<br>        -I [ --path ] dir    : specify additional include directory<br>        -S [ --syspath ] dir : specify additional system include directory<br></pre>
<p dir="ltr">Please note though, that this sample will output only those include
file names, which are visible to the preprocessor, i.e. given the
following code snippet, only one of the two include file directives is
triggered during preprocessing and for this reason only the
corresponding file name is reported by the <tt>list_includes</tt> sample:<br>不过请注意，该例子只输出哪些预处理器可见的头文件的名字，如，给定以下代码片断，在预处理过程中，只有一条包含文件指令会被触发，因此只有对应的那一个文件名会被 <tt>list_includes</tt> 例子报告：
</p><pre><span class="preprocessor">    #if</span> <span class="keyword">defined</span><span class="special">(</span>INCLUDE_FILE_A<span class="special">)</span>
<span class="preprocessor">    #  include</span> <span class="literal">"file_a.h"</span> <br><span class="preprocessor">    #else</span>
<span class="preprocessor">    #  include</span> <span class="literal">"file_b.h"</span>
<span class="preprocessor">    #endif</span></pre>
<h2 dir="ltr">The advanced_hooks sample</h2>
<p dir="ltr">The <tt>advanced_hooks</tt> sample is based on the <tt>quick_start</tt> sample mentioned above. It shows how you may want to use the advanced preprocessing hooks of the <tt>Wave</tt>
library to get in the output not only the preprocessed tokens from the
evaluated conditional blocks, but also the tokens recognized inside the
non-evaluated conditional blocks. To make the generated token stream
useful for further processing the tokens from the non-evaluated
conditional blocks are commented out.<br>例子 <tt>advanced_hooks</tt> 是基于前面的 <tt>quick_start</tt> 例子的。它示范了如何使用 <tt>Wave</tt> 库的高级预处理钩子，不仅从被求值的条件块中获取预经过处理的单词，还可以获得未被求值的条件块内部识别到的单词。为了让生成的单词流可用于进一步的处理，从未被求值的条件块中获得的单词会被注释掉。 </p>
<p dir="ltr">Here is a small sample what the <tt>advanced_hooks</tt> sample does. Consider the following input:<br>以下是 <tt>advanced_hooks</tt> 处理的一个小例子。考虑以下输入： </p>
<pre>    <span class="preprocessor">#define</span> TEST 1<br><span class="preprocessor">    #if</span> <span class="keyword">defined</span>(TEST)<br>    <span class="string">"TEST was defined: "</span> TEST<br>    <span class="preprocessor">#else</span>
    <span class="string">"TEST was not defined!"</span>
    <span class="preprocessor">#endif</span></pre>
<p>which will produce as its output:<br>将产生以下输出：</p>
<pre><span class="comment">    //"#if defined(TEST)</span>
    <span class="string">"TEST was defined: "</span> 1<br>    <span class="comment">//"#else</span>
    <span class="comment">//"TEST was not defined!"</span>
    <span class="comment">//"#endif</span></pre>
<p dir="ltr">As you can see, the sample application prints out the conditional directives in a commented out manner as well.<br>如你所见，这个例子程序以注释的方式打印出条件指令。 </p>
<h2 dir="ltr">The  wave sample</h2>
<p dir="ltr">Because of its general usefulness the <tt>wave</tt> sample is not
located in the sample directory of the library, but inside the tools
directory of Boost. The wave sample is usable as a full fledged
preprocessor executable on top of any other C++ compiler. It outputs
the textual representation of the preprocessed tokens generated from a
given input file. It is described in more details <a href="wave_driver.html">here</a>.<br>由于其通用性，这个 <tt>wave</tt> 例子没有被放在本库的例子目录中，而是位于Boost的工具目录中。这个wave例子被用作一个可以在任意C++编译器之上执行的正式的预处理器。它输出从一个给定的输入文件生成的预处理单词的文字表示。更多的细节在<span style="font-weight: bold;"></span><a href="wave_driver.html">此</a>说明。 </p>
<h2 dir="ltr">The  waveidl sample </h2>
<p dir="ltr">The main point of the <tt>waveidl</tt> sample is to show, how a completely independent lexer type may be used in conjunction with the default token type of the <tt>Wave</tt> library. The lexer used in this sample is supposed to be used for an IDL language based preprocessor. It is based on the <tt>Re2C</tt> tool too, but recognizes a different set of tokens as the default C++ lexer contained within the <tt>Wave</tt> library. So this lexer does not recognize any keywords (except <tt>true</tt> and <tt>false</tt>,
which are needed by the preprocessor itself). This is needed because
there exist different IDL languages, where identifiers of one language
may be keywords of others. Certainly this implies to postpone keyword
identification after the preprocessing, but allows to use <tt>Wave</tt> for all of the IDL derivatives.<br>例子 <tt>waveidl</tt> 的重点是，示范如何将一个完全独立的lexer类型与 <tt>Wave</tt> 库的缺省单词类型一起使用。在这个例子中使用的lexer被假定为要用于一个基于IDL语言的预处理器。它也是基于 <tt>Re2C</tt> 工具的，不过识别的是与 <tt>Wave</tt> 库所含的缺省C++ lexer不同的单词集。因此这个lexer不识别任何关键字(除了 <tt>true</tt> 和 <tt>false</tt>，它是预处理器本身需要的)。这是必须的，因为存在着不同的IDL语言，某种语言的标识符可能是另一种语言的关键字。当然，这意味着将关键字的识别推迟至预处理之后，不过这样可以允许将 <tt>Wave</tt> 用于所有IDL指令字。 </p>
<p dir="ltr">It is only possible to use the <tt>Wave</tt> library to write an IDL
preprocessor, because the token sets for both languages are very
similar. The tokens to be recognized by the <tt>waveidl</tt> IDL language preprocessor is nearly a complete subset of the full C++ token set.<br>用&nbsp;<tt>Wave</tt> 库来编写一个IDL预处理器只是一种可能，因为两种语言的单词集非常相似。<tt>waveidl</tt> IDL语言预处理器所识别的单词基本上是整个C++单词集的一个完全子集。 </p>
<p dir="ltr">The command line syntax usable for this sample is shown below:<br>这个例子所用的命令行语法如下：</p>
<pre>  Usage: waveidl [options] [@config-file(s)] file:<br><br><br>    Options allowed on the command line only:<br>      -h [ --help ]           : print out program usage (this message)<br>      -v [ --version ]        : print the version number<br>      -c [ --copyright ]      : print out the copyright statement<br>      --config-file filepath  : specify a config file (alternatively: @filepath)<br><br>        <br>    Options allowed additionally in a config file:<br>      -o [ --output ] path    : specify a file to use for output instead of stdout<br>      -I [ --include ] path   : specify an additional include directory<br>      -S [ --sysinclude ] syspath : specify an additional system include directory<br>      -D [ --define ] macro[=[value]] : specify a macro to define<br>      -P [ --predefine ] macro[=[value]] : specify a macro to predefine<br>      -U [ --undefine ] macro : specify a macro to undefine<br></pre>
<h2>The hannibal sample </h2>
<p>The <tt>hannibal</tt> sample shows how to base a spirit grammar on the <tt>Wave</tt> library. It was initially written and contributed to the <tt>Wave</tt> library by Danny Havenith (see his related web page <a href="http://havenith-verlinden.nl/hannibal/">here</a>). The grammar of this example uses <tt>Wave</tt> as its preprocessor. It implements around 120 of the approximately 250 grammar rules as they can be   found in <em>The C++ Programming Language, Third Edition</em>.
The 120 rules allow a C++ source file to be parsed for all type
information and declarations. In fact this grammar parses as good as
anything, it parses C++ declarations, including class and template
definitions, but skips function bodies. If so configured, the program
will output an xml dump of the generated parse tree.<br>例子 <tt>hannibal</tt> 示范了如何将一个spirit语法基于 <tt>Wave</tt> 库。它最初是由 Danny Havenith (相关主页请见 <a href="http://havenith-verlinden.nl/hannibal/">这里</a>)编写并贡献给 <tt>Wave</tt> 库的。这个例子的语法用 <tt>Wave</tt> 作为它的预处理器。它实现了 <em>The C++ Programming Language, Third Edition</em>
中大约250个语法规则中的约120个。这120个规则可以对一个C++源文件的所有类型信息和声明进行分析。事实上，这个语法分析与其它东西一样好，它
分析了C++声明，包括类和模板的定义，不过却跳过了函数体。按此配置，该程序将对所生成的分析树输出一个xml dump。 </p>
<p>It may be a good starting point for a grammar that can be used for
things like reverse engineering as some UML modelling tools do. Or
whatever use you may find for a grammar that gives you a list of all
templates and classes in a file and their members.<br>它可能是某种语法的一个好的起点，这种语法可以用于象某些UML建模工具所做的逆向工程那样的事情。或者用于你发现的某种语法，可以让你列出一个文件中的所有模板和类及其成员。<br>
</p>
<table border="0">
  <tbody><tr>
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="wave_driver.html"><img src="theme/l_arr.gif" border="0" height="19" width="20"></a></td>
    <td width="30"><a href="wave_driver.html"><img style="border: 0px solid ; width: 20px; height: 19px;" alt="next" src="theme/r_arr.gif"></a></td>
  </tr>
</tbody></table>
<hr size="1">
<p class="copyright">Copyright © 2003-2010 Hartmut Kaiser<br>
    <br>
<font size="2">Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt) </font> </p>
<span class="updated"></span>
<p class="copyright"><span class="updated">Last updated:
  <!-- #BeginDate format:fcAm1m -->Wednesday, June 21, 2006  22:12<!-- #EndDate -->
  </span></p>
<p>&nbsp;</p>
</body></html>
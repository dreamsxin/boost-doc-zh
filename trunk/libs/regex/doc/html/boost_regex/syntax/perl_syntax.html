<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Perl Regular Expression Syntax Perl&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="Boost.Regex">
<link rel="up" href="../syntax.html" title="Regular Expression Syntax &#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;">
<link rel="prev" href="../syntax.html" title="Regular Expression Syntax &#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;">
<link rel="next" href="basic_extended.html" title="POSIX Extended Regular Expression Syntax POSIX&#25193;&#23637;&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../syntax.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../syntax.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="basic_extended.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_regex.syntax.perl_syntax"></a><a class="link" href="perl_syntax.html" title="Perl Regular Expression Syntax Perl&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;"> Perl Regular Expression
      Syntax Perl&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;</a>
</h3></div></div></div>
<a name="boost_regex.syntax.perl_syntax.synopsis_______"></a><h4>
<a name="id4866715"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.synopsis_______">Synopsis &#25688;&#35201;</a>
      </h4>
<p>
        The Perl regular expression syntax is based on that used by the programming
        language Perl . Perl regular expressions are the default behavior in Boost.Regex
        or you can pass the flag <code class="literal">perl</code> to the <a class="link" href="../ref/basic_regex.html" title="basic_regex"><code class="computeroutput"><span class="identifier">basic_regex</span></code></a> constructor, for example:<br>
        Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;&#22522;&#20110;&#32534;&#31243;&#35821;&#35328;Perl&#30340;&#20351;&#29992;&#12290;Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#26159;Boost.Regex&#30340;&#40664;&#35748;&#34892;&#20026;&#65292;
        &#25110;&#32773;&#20320;&#21487;&#20197;&#23558;&#26631;&#35760; <code class="literal">perl</code> &#20256;&#20837; <a class="link" href="../ref/basic_regex.html" title="basic_regex"><code class="computeroutput"><span class="identifier">basic_regex</span></code></a> &#30340;&#26500;&#36896;&#65292;&#20363;&#22914;&#65306;
      </p>
<pre class="programlisting"><span class="comment">// e1 is a case sensitive Perl regular expression: 
</span><span class="comment">// since Perl is the default option there's no need to explicitly specify the syntax used here:
</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">e1</span><span class="special">(</span><span class="identifier">my_expression</span><span class="special">);</span>
<span class="comment">// e2 a case insensitive Perl regular expression:
</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">e2</span><span class="special">(</span><span class="identifier">my_expression</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span><span class="special">::</span><span class="identifier">perl</span><span class="special">|</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span><span class="special">::</span><span class="identifier">icase</span><span class="special">);</span>
</pre>
<a name="boost_regex.syntax.perl_syntax.perl_regular_expression_syntax__perl________________________"></a><h4>
<a name="id4866917"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.perl_regular_expression_syntax__perl________________________">Perl
        Regular Expression Syntax Perl&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;</a>
      </h4>
<p>
        In Perl regular expressions, all characters match themselves except for the
        following special characters:<br> &#22312;Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#20013;&#65292;&#38500;&#20102;&#19979;&#38754;&#30340;&#29305;&#27530;&#23383;&#31526;&#22806;&#65292;&#25152;&#26377;&#30340;&#23383;&#31526;&#37117;&#21305;&#37197;&#33258;&#24049;&#65306;
      </p>
<pre class="programlisting">.[{()\*+?|^$</pre>
<a name="boost_regex.syntax.perl_syntax.wildcard__________"></a><h5>
<a name="id4866958"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.wildcard__________">Wildcard
        &#36890;&#37197;&#31526;</a>
      </h5>
<p>
        The single character '.' when used outside of a character set will match
        any single character except:<br> &#21333;&#23383;&#31526;'.'&#22312;&#23383;&#31526;&#38598;&#20043;&#22806;&#20351;&#29992;&#26102;&#21487;&#20197;&#21305;&#37197;&#20219;&#24847;&#21333;&#23383;&#31526;&#65292;&#38500;&#20102;&#65306;
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          The NULL character when the <a class="link" href="../ref/match_flag_type.html" title="match_flag_type">flag
          <code class="literal">match_not_dot_null</code></a> is passed to the matching
          algorithms.<br> NULL&#23383;&#31526;&#65292;&#24403; <a class="link" href="../ref/match_flag_type.html" title="match_flag_type">&#26631;&#24535;<code class="literal">match_not_dot_null</code></a>
          &#34987;&#20256;&#20837;&#21305;&#37197;&#31639;&#27861;&#20013;&#26102;&#12290;
        </li>
<li>
          The newline character when the <a class="link" href="../ref/match_flag_type.html" title="match_flag_type">flag
          <code class="literal">match_not_dot_newline</code></a> is passed to the matching
          algorithms.<br> &#25442;&#34892;&#23383;&#31526;&#65292;&#24403; <a class="link" href="../ref/match_flag_type.html" title="match_flag_type">&#26631;&#35760;<code class="literal">match_not_dot_newline</code></a>
          &#34987;&#20256;&#20837;&#21305;&#37197;&#31639;&#27861;&#20013;&#26102;&#12290;
        </li>
</ul></div>
<a name="boost_regex.syntax.perl_syntax.anchors_______"></a><h5>
<a name="id4867054"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.anchors_______">Anchors &#38170;&#28857;</a>
      </h5>
<p>
        A '^' character shall match the start of a line.<br> '^'&#23383;&#31526;&#20250;&#21305;&#37197;&#34892;&#30340;&#36215;&#22987;&#12290;
      </p>
<p>
        A '$' character shall match the end of a line.<br> '$'&#23383;&#31526;&#20250;&#21305;&#37197;&#34892;&#30340;&#32456;&#27490;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.marked_sub_expressions_________________________"></a><h5>
<a name="id4867088"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.marked_sub_expressions_________________________">Marked
        sub-expressions &#34987;&#26631;&#35760;&#30340;&#23376;&#34920;&#36798;&#24335;</a>
      </h5>
<p>
        A section beginning <code class="literal">(</code> and ending <code class="literal">)</code>
        acts as a marked sub-expression. Whatever matched the sub-expression is split
        out in a separate field by the matching algorithms. Marked sub-expressions
        can also repeated, or referred to by a back-reference.<br> &#24320;&#22987;&#30340; <code class="literal">(</code>
        &#21644;&#32456;&#27490;&#30340; <code class="literal">)</code> &#20043;&#38388;&#30340;&#37096;&#20998;&#26159;&#34987;&#26631;&#35760;&#30340;&#23376;&#34920;&#36798;&#24335;&#12290;&#21305;&#37197;&#31639;&#27861;&#20250;&#23558;&#23376;&#34920;&#36798;&#24335;&#21305;&#37197;&#30340;&#37096;&#20998;&#20998;&#31163;&#25104;&#29420;&#31435;&#30340;&#37096;&#20998;&#12290;
        &#26631;&#35760;&#23376;&#34920;&#36798;&#24335;&#20063;&#21487;&#20197;&#34987;&#37325;&#22797;&#65292;&#25110;&#21518;&#21521;&#24341;&#29992;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.non_marking_grouping_____________"></a><h5>
<a name="id4867149"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.non_marking_grouping_____________">Non-marking
        grouping &#38750;&#26631;&#35760;&#32452;</a>
      </h5>
<p>
        A marked sub-expression is useful to lexically group part of a regular expression,
        but has the side-effect of spitting out an extra field in the result. As
        an alternative you can lexically group part of a regular expression, without
        generating a marked sub-expression by using <code class="literal">(?:</code> and <code class="literal">)</code>
        , for example <code class="literal">(?:ab)+</code> will repeat <code class="literal">ab</code>
        without splitting out any separate sub-expressions.<br> &#26631;&#35760;&#23376;&#34920;&#36798;&#24335;&#23545;&#20110;&#27491;&#21017;&#34920;&#36798;&#24335;&#20013;&#30340;&#25104;&#32452;&#25991;&#23383;&#37096;&#20998;&#26159;&#38750;&#24120;&#26377;&#29992;&#30340;&#65292;&#20294;&#23558;&#32467;&#26524;&#20998;&#32452;&#26159;&#26377;&#21103;&#20316;&#29992;&#30340;&#12290;
        &#20316;&#20026;&#36873;&#25321;&#65292;&#21487;&#20197;&#36890;&#36807; <code class="literal">(?:</code> &#21644; <code class="literal">)</code>
        &#20135;&#29983;&#25991;&#23383;&#20998;&#32452;&#65292;&#20294;&#19981;&#20135;&#29983;&#26631;&#35760;&#23376;&#34920;&#36798;&#24335;&#65292;&#20363;&#22914; <code class="literal">(?:ab)+</code>
        &#20250;&#37325;&#22797; <code class="literal">ab</code> &#20294;&#24182;&#19981;&#20998;&#38548;&#20986;&#21333;&#29420;&#30340;&#23376;&#34920;&#36798;&#24335;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.repeats_______"></a><h5>
<a name="id4867234"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.repeats_______">Repeats &#37325;&#22797;</a>
      </h5>
<p>
        Any atom (a single character, a marked sub-expression, or a character class)
        can be repeated with the <code class="literal">*</code>, <code class="literal">+</code>, <code class="literal">?</code>,
        and <code class="literal">{}</code> operators.<br> &#20219;&#24847;&#21407;&#23376;(&#21333;&#20010;&#23383;&#31526;&#65292;&#19968;&#20010;&#26631;&#35760;&#23376;&#34920;&#36798;&#24335;&#25110;&#19968;&#20010;&#23383;&#31526;&#32452;)&#21487;&#20197;&#36890;&#36807;
        <code class="literal">*</code>, <code class="literal">+</code>, <code class="literal">?</code> &#21644; <code class="literal">{}</code>
        &#25805;&#20316;&#31526;&#37325;&#22797;&#12290;
      </p>
<p>
        The <code class="literal">*</code> operator will match the preceding atom zero or more
        times, for example the expression <code class="literal">a*b</code> will match any of
        the following:<br> <code class="literal">*</code> &#25805;&#20316;&#31526;&#20250;&#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;&#38646;&#27425;&#25110;&#22810;&#27425;&#65292;&#20363;&#22914;&#34920;&#36798;&#24335;
        <code class="literal">a*b</code> &#21487;&#20197;&#21305;&#37197;&#19979;&#38754;&#30340;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">b</span>
<span class="identifier">ab</span>
<span class="identifier">aaaaaaaab</span>
</pre>
<p>
        The <code class="literal">+</code> operator will match the preceding atom one or more
        times, for example the expression <code class="literal">a+b</code> will match any of
        the following:<br> <code class="literal">+</code> &#25805;&#20316;&#31526;&#20250;&#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;&#19968;&#27425;&#25110;&#22810;&#27425;&#65292;
        &#20363;&#22914;&#34920;&#36798;&#24335; <code class="literal">a+b</code> &#21487;&#20197;&#21305;&#37197;&#19979;&#38754;&#30340;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">ab</span>
<span class="identifier">aaaaaaaab</span>
</pre>
<p>
        But will not match:<br> &#20294;&#19981;&#20250;&#21305;&#37197;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">b</span>
</pre>
<p>
        The <code class="literal">?</code> operator will match the preceding atom zero or one
        times, for example the expression ca?b will match any of the following:<br>
        <code class="literal">?</code> &#25805;&#20316;&#31526;&#20250;&#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;&#38646;&#27425;&#25110;&#19968;&#27425;&#65292;
        &#20363;&#22914;&#34920;&#36798;&#24335; <code class="literal">ca?b</code> &#20250;&#21305;&#37197;&#19979;&#38754;&#30340;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">cb</span>
<span class="identifier">cab</span>
</pre>
<p>
        But will not match:<br> &#20294;&#19981;&#20250;&#21305;&#37197;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">caab</span>
</pre>
<p>
        An atom can also be repeated with a bounded repeat:<br> &#21407;&#23376;&#21516;&#26679;&#21487;&#20197;&#34987;&#37325;&#22797;&#26377;&#30028;&#27425;&#25968;&#65306;
      </p>
<p>
        <code class="literal">a{n}</code> Matches 'a' repeated exactly n times.<br> <code class="literal">a{n}</code>
        &#21305;&#37197;'a'&#37325;&#22797;n&#27425;&#12290;
      </p>
<p>
        <code class="literal">a{n,}</code> Matches 'a' repeated n or more times.<br> <code class="literal">a{n,}</code>
        &#21305;&#37197;'a'&#37325;&#22797;n&#27425;&#25110;&#26356;&#22810;&#27425;&#12290;
      </p>
<p>
        <code class="literal">a{n, m}</code> Matches 'a' repeated between n and m times inclusive.<br>
        <code class="literal">a{n, m}</code> &#21305;&#37197;'a'&#37325;&#22797;n&#27425;&#21040;m&#27425;&#20043;&#38388;&#12290;
      </p>
<p>
        For example:<br> &#20363;&#22914;&#65306;
      </p>
<pre class="programlisting">^a{2,3}$</pre>
<p>
        Will match either of:<br> &#20250;&#21305;&#37197;&#22914;&#19979;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">aa</span>
<span class="identifier">aaa</span>
</pre>
<p>
        But neither of:<br> &#20294;&#19981;&#20250;&#21305;&#37197;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">a</span>
<span class="identifier">aaaa</span>
</pre>
<p>
        It is an error to use a repeat operator, if the preceding construct can not
        be repeated, for example:<br> &#22914;&#26524;&#21069;&#38754;&#30340;&#32467;&#26500;&#19981;&#33021;&#34987;&#37325;&#22797;&#65292;&#37027;&#20040;&#20351;&#29992;&#37325;&#22797;&#25805;&#20316;&#31526;&#26159;&#19968;&#20010;&#38169;&#35823;&#65292;&#20363;&#22914;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">a</span><span class="special">(*)</span>
</pre>
<p>
        Will raise an error, as there is nothing for the <code class="literal">*</code> operator
        to be applied to.<br> &#20294;&#25253;&#21578;&#19968;&#20010;&#38169;&#35823;&#65292;&#22240;&#20026; <code class="literal">*</code>
        &#25805;&#20316;&#31526;&#27809;&#26377;&#21487;&#20197;&#24212;&#29992;&#30340;&#23545;&#35937;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.non_greedy_repeats________________"></a><h5>
<a name="id4867649"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.non_greedy_repeats________________">Non
        greedy repeats &#38750;&#36138;&#23146;&#37325;&#22797;</a>
      </h5>
<p>
        The normal repeat operators are "greedy", that is to say they will
        consume as much input as possible. There are non-greedy versions available
        that will consume as little input as possible while still producing a match.<br>
        &#36890;&#24120;&#30340;&#37325;&#22797;&#26159;"&#36138;&#23146;&#30340;"&#65292;&#20063;&#35828;&#26126;&#35828;&#23427;&#20204;&#20250;&#28040;&#32791;&#23613;&#21487;&#33021;&#22810;&#30340;&#36755;&#20837;&#12290;&#21516;&#26679;&#23384;&#22312;&#38750;&#36138;&#23146;&#29256;&#26412;&#65292;&#29983;&#25104;&#21305;&#37197;&#26102;&#20250;&#28040;&#32791;&#23613;&#21487;&#33021;&#23569;&#30340;&#36755;&#20837;&#12290;
      </p>
<p>
        <code class="literal">*?</code> Matches the previous atom zero or more times, while
        consuming as little input as possible.<br> <code class="literal">*?</code> &#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;&#38646;&#27425;&#25110;&#22810;&#27425;&#65292;&#20294;&#23613;&#21487;&#33021;&#23569;&#22320;&#28040;&#32791;&#36755;&#20837;&#12290;
      </p>
<p>
        <code class="literal">+?</code> Matches the previous atom one or more times, while
        consuming as little input as possible.<br> <code class="literal">+?</code> &#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;&#19968;&#27425;&#25110;&#22810;&#27425;&#65292;&#20294;&#23613;&#21487;&#33021;&#23569;&#22320;&#28040;&#32791;&#36755;&#20837;&#12290;
      </p>
<p>
        <code class="literal">??</code> Matches the previous atom zero or one times, while
        consuming as little input as possible.<br> <code class="literal">??</code> &#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;&#38646;&#27425;&#25110;&#19968;&#27425;&#65292;&#20294;&#23613;&#21487;&#33021;&#23569;&#22320;&#28040;&#32791;&#36755;&#20837;&#12290;
      </p>
<p>
        <code class="literal">{n,}?</code> Matches the previous atom n or more times, while
        consuming as little input as possible.<br> <code class="literal">{n,}?</code> &#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;n&#27425;&#25110;&#26356;&#22810;&#27425;&#65292;&#20294;&#23613;&#21487;&#33021;&#23569;&#22320;&#28040;&#32791;&#36755;&#20837;&#12290;
      </p>
<p>
        <code class="literal">{n,m}?</code> Matches the previous atom between n and m times,
        while consuming as little input as possible.<br> <code class="literal">{n,m}?</code>
        &#21305;&#37197;&#21069;&#38754;&#30340;&#21407;&#23376;n&#27425;&#21040;m&#27425;&#65292;&#20294;&#23613;&#21487;&#33021;&#23569;&#22320;&#28040;&#32791;&#36755;&#20837;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.pocessive_repeats"></a><h5>
<a name="id4867787"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.pocessive_repeats">Pocessive
        repeats</a>
      </h5>
<p>
        By default when a repeated patten does not match then the engine will backtrack
        until a match is found. However, this behaviour can sometime be undesireable
        so there are also "pocessive" repeats: these match as much as possible
        and do not then allow backtracking if the rest of the expression fails to
        match.<br> &#32570;&#30465;&#24773;&#20917;&#19979;&#65292;&#24403;&#19968;&#20010;&#37325;&#22797;&#27169;&#24335;&#19981;&#33021;&#34987;&#21305;&#37197;&#26102;&#65292;&#24341;&#25806;&#23558;&#22238;&#28335;&#30452;&#33267;&#25214;&#21040;&#19968;&#20010;&#21305;&#37197;&#12290;&#20294;&#26159;&#65292;&#26377;&#26102;&#20505;&#36825;&#31181;&#34892;&#20026;&#19981;&#26159;&#29992;&#25143;&#25152;&#26399;&#26395;&#30340;&#65292;
        &#22240;&#27492;&#36824;&#26377;&#19968;&#31181;"pocessive"&#37325;&#22797;&#65306;&#23427;&#23613;&#21487;&#33021;&#22810;&#22320;&#36827;&#34892;&#21305;&#37197;&#19988;&#24403;&#21097;&#19979;&#30340;&#34920;&#36798;&#24335;&#19981;&#33021;&#21305;&#37197;&#26102;&#19981;&#20801;&#35768;&#36827;&#34892;&#22238;&#28335;&#12290;
      </p>
<p>
        <code class="literal">*+</code> Matches the previous atom zero or more times, while
        giving nothing back.<br> <code class="literal">*+</code> &#21305;&#37197;&#21069;&#19968;&#20010;&#21407;&#23376;&#38646;&#27425;&#25110;&#22810;&#27425;&#65292;&#20294;&#19981;&#36864;&#22238;&#12290;
      </p>
<p>
        <code class="literal">++</code> Matches the previous atom one or more times, while
        giving nothing back.<br> <code class="literal">++</code> &#21305;&#37197;&#21069;&#19968;&#20010;&#21407;&#23376;&#19968;&#27425;&#25110;&#22810;&#27425;&#65292;&#20294;&#19981;&#36864;&#22238;&#12290;
      </p>
<p>
        <code class="literal">?+</code> Matches the previous atom zero or one times, while
        giving nothing back.<br> <code class="literal">?+</code> &#21305;&#37197;&#21069;&#19968;&#20010;&#21407;&#23376;&#38646;&#27425;&#25110;&#19968;&#27425;&#65292;&#20294;&#19981;&#36864;&#22238;&#12290;
      </p>
<p>
        <code class="literal">{n,}+</code> Matches the previous atom n or more times, while
        giving nothing back.<br> <code class="literal">{n,}+</code> &#21305;&#37197;&#21069;&#19968;&#20010;&#21407;&#23376;n&#27425;&#25110;&#22810;&#27425;&#65292;&#20294;&#19981;&#36864;&#22238;&#12290;
      </p>
<p>
        <code class="literal">{n,m}+</code> Matches the previous atom between n and m times,
        while giving nothing back.<br> <code class="literal">{n,m}+</code> &#21305;&#37197;&#21069;&#19968;&#20010;&#21407;&#23376;n&#33267;m&#27425;&#65292;&#20294;&#19981;&#36864;&#22238;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.back_references_____________"></a><h5>
<a name="id4867923"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.back_references_____________">Back
        references &#21518;&#21521;&#24341;&#29992;</a>
      </h5>
<p>
        An escape character followed by a digit <span class="emphasis"><em>n</em></span>, where <span class="emphasis"><em>n</em></span>
        is in the range 1-9, matches the same string that was matched by sub-expression
        <span class="emphasis"><em>n</em></span>. For example the expression:<br> &#19968;&#20010;&#36716;&#20041;&#23383;&#31526;&#36319;&#30528;&#19968;&#20010;&#25968;&#23383;
        <span class="emphasis"><em>n/&#65292;/n</em></span> &#30340;&#33539;&#22260;&#26159;1-9&#65292;&#21305;&#37197;&#34987;&#23376;&#34920;&#36798;&#24335; <span class="emphasis"><em>n</em></span>
        &#21305;&#37197;&#30340;&#30456;&#21516;&#23383;&#31526;&#20018;&#12290;&#20363;&#22914;&#34920;&#36798;&#24335;&#65306;
      </p>
<pre class="programlisting">^(a*).*\1$</pre>
<p>
        Will match the string:<br> &#21305;&#37197;&#23383;&#31526;&#20018;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">aaabbaaa</span>
</pre>
<p>
        But not the string:<br> &#20294;&#19981;&#21305;&#37197;&#65306;
      </p>
<pre class="programlisting"><span class="identifier">aaabba</span>
</pre>
<p>
        You can also use the \g escape for the same function, for example:<br>
        &#20320;&#20063;&#21487;&#20197;&#29992; \g &#36716;&#20041;&#31526;&#36798;&#21040;&#30456;&#21516;&#21151;&#25928;&#65292;&#20363;&#22914;&#65306;
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Escape &#36716;&#20041;&#31526;
              </p>
              </th>
<th>
              <p>
                Meaning &#24847;&#20041;
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="literal">\g1</code>
              </p>
              </td>
<td>
              <p>
                Match whatever matched sub-expression 1<br> &#21305;&#37197;&#23376;&#34920;&#36798;&#24335;1&#30340;&#20869;&#23481;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\g{1}</code>
              </p>
              </td>
<td>
              <p>
                Match whatever matched sub-expression 1: this form allows for safer
                parsing of the expression in cases like <code class="literal">\g{1}2</code>
                or for indexes higher than 9 as in <code class="literal">\g{1234}</code><br>
                &#21305;&#37197;&#23376;&#34920;&#36798;&#24335;1&#30340;&#20869;&#23481;&#65306;&#35813;&#26041;&#24335;&#21487;&#20197;&#22312;&#20197;&#19979;&#24773;&#24418;&#26102;&#26356;&#23433;&#20840;&#22320;&#23545;&#34920;&#36798;&#24335;&#36827;&#34892;&#20998;&#26512;&#65306;&#22914;
                <code class="literal">\g{1}2</code> &#25110;&#22823;&#20110;9&#30340;&#32034;&#24341;&#22914; <code class="literal">\g{1234}</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\g-1</code>
              </p>
              </td>
<td>
              <p>
                Match whatever matched the last opened sub-expression<br> &#21305;&#37197;&#26368;&#21518;&#19968;&#20010;&#34987;&#25171;&#24320;&#30340;&#23376;&#34920;&#36798;&#24335;&#30340;&#20869;&#23481;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\g{-2}</code>
              </p>
              </td>
<td>
              <p>
                Match whatever matched the last but one opened sub-expression<br>
                &#21305;&#37197;&#20498;&#25968;&#31532;&#20108;&#20010;&#34987;&#25171;&#24320;&#30340;&#23376;&#34920;&#36798;&#24335;&#30340;&#20869;&#23481;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\g{one}</code>
              </p>
              </td>
<td>
              <p>
                Match whatever matched the sub-expression named "one"<br>
                &#21305;&#37197;&#21517;&#20026;"one"&#30340;&#23376;&#34920;&#36798;&#24335;&#30340;&#20869;&#23481;
              </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        Finally the \k escape can be used to refer to named subexpressions, for example
        <code class="literal">\k&lt;two&gt;</code> will match whatever matched the subexpression
        named "two".<br> &#26368;&#21518;&#65292;\k &#36716;&#20041;&#31526;&#21487;&#29992;&#20110;&#24341;&#29992;&#21629;&#21517;&#23376;&#34920;&#36798;&#24335;&#65292;&#20363;&#22914;
        <code class="literal">\k&lt;two&gt;</code> &#23558;&#21305;&#37197;&#21517;&#20026; "two" &#30340;&#23376;&#34920;&#36798;&#24335;&#30340;&#20869;&#23481;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.alternation_______"></a><h5>
<a name="id4868237"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.alternation_______">Alternation
        &#36873;&#25321;</a>
      </h5>
<p>
        The <code class="literal">|</code> operator will match either of its arguments, so
        for example: <code class="literal">abc|def</code> will match either "abc"
        or "def". <br> <code class="literal">|</code> &#25805;&#20316;&#31526;&#21305;&#37197;&#23427;&#30340;&#21442;&#25968;&#20043;&#19968;&#65292;
        &#20363;&#22914;&#65306;<code class="literal">abc|def</code> &#20250;&#21305;&#37197; "abc" &#25110; "def"&#12290;
      </p>
<p>
        Parenthesis can be used to group alternations, for example: <code class="literal">ab(d|ef)</code>
        will match either of "abd" or "abef".<br> &#25324;&#21495;&#21487;&#20197;&#29992;&#26469;&#23545;&#36873;&#25321;&#36827;&#34892;&#20998;&#32452;&#65292;&#20363;&#22914;&#65306;<code class="literal">ab(d|ef)</code>
        &#20250;&#21305;&#37197; "abd" &#25110; "abef"&#12290;
      </p>
<p>
        Empty alternatives are not allowed (these are almost always a mistake), but
        if you really want an empty alternative use <code class="literal">(?:)</code> as a
        placeholder, for example:<br> &#31354;&#30340;&#36873;&#25321;&#26159;&#19981;&#20801;&#35768;&#30340;(&#36825;&#36890;&#24120;&#37117;&#26159;&#38169;&#35823;)&#65292;&#20294;&#22914;&#26524;&#20320;&#30495;&#30340;&#38656;&#35201;&#19968;&#20010;&#31354;&#30340;&#36873;&#25321;&#65292;&#21487;&#20197;&#20351;&#29992;
        <code class="literal">(?:)</code> &#20316;&#20026;&#21344;&#20301;&#31526;&#65292;&#20363;&#22914;&#65306;
      </p>
<p>
        <code class="literal">|abc</code> is not a valid expression, but<br> <code class="literal">|abc</code>
        &#19981;&#26159;&#26377;&#25928;&#30340;&#34920;&#36798;&#24335;&#65292;&#20294;
      </p>
<p>
        <code class="literal">(?:)|abc</code> is and is equivalent, also the expression:<br>
        <code class="literal">(?:)|abc</code> &#26159;&#26377;&#25928;&#30340;&#34920;&#36798;&#24335;&#65292;&#24182;&#19988;&#19982;&#20197;&#19979;&#34920;&#36798;&#24335;&#65306;
      </p>
<p>
        <code class="literal">(?:abc)??</code> has exactly the same effect.<br> <code class="literal">(?:abc)??</code>
        &#26377;&#23436;&#20840;&#30456;&#21516;&#30340;&#20316;&#29992;
      </p>
<a name="boost_regex.syntax.perl_syntax.character_sets__________"></a><h5>
<a name="id4868388"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_sets__________">Character
        sets &#23383;&#31526;&#38598;</a>
      </h5>
<p>
        A character set is a bracket-expression starting with <code class="literal">[</code>
        and ending with <code class="literal">]</code>, it defines a set of characters, and
        matches any single character that is a member of that set.<br> &#23383;&#31526;&#38598;&#26159;&#19968;&#20010;&#20197;
        <code class="literal">[</code> &#24320;&#22987;&#65292;&#20197; <code class="literal">]</code> &#32467;&#26463;&#30340;&#26041;&#25324;&#21495;&#34920;&#36798;&#24335;&#65292;&#23427;&#23450;&#20041;&#20102;&#19968;&#20010;&#23383;&#31526;&#30340;&#38598;&#21512;&#65292;&#21305;&#37197;&#38598;&#21512;&#20013;&#30340;&#20219;&#24847;&#21333;&#20010;&#23383;&#31526;&#12290;
      </p>
<p>
        A bracket expression may contain any combination of the following:<br>
        &#26041;&#25324;&#21495;&#34920;&#36798;&#24335;&#21487;&#20197;&#21253;&#21547;&#19979;&#38754;&#30340;&#32452;&#21512;&#65306;
      </p>
<a name="boost_regex.syntax.perl_syntax.single_characters_____________"></a><h6>
<a name="id4868452"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.single_characters_____________">Single
        characters &#21333;&#20010;&#23383;&#31526;</a>
      </h6>
<p>
        For example <code class="literal">[abc]</code>, will match any of the characters 'a',
        'b', or 'c'.<br> &#20363;&#22914; <code class="literal">[abc]</code> &#21487;&#20197;&#21305;&#37197; 'a'&#12289;'b'
        &#25110; 'c'&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.character_ranges_____________"></a><h6>
<a name="id4868492"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_ranges_____________">Character
        ranges &#23383;&#31526;&#33539;&#22260;</a>
      </h6>
<p>
        For example <code class="literal">[a-c]</code> will match any single character in the
        range 'a' to 'c'. By default, for Perl regular expressions, a character x
        is within the range y to z, if the code point of the character lies within
        the codepoints of the endpoints of the range. Alternatively, if you set the
        <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;"><code class="literal">collate</code>
        flag</a> when constructing the regular expression, then ranges are locale
        sensitive.<br> &#20363;&#22914; <code class="literal">[a-c]</code> &#21487;&#20197;&#21305;&#37197;'a'&#21040;'c'&#33539;&#22260;&#20869;&#30340;&#20219;&#24847;&#21333;&#20010;&#23383;&#31526;&#12290;&#23545;&#20110;&#32570;&#30465;&#30340;Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#65292;
        &#22914;&#26524;&#23383;&#31526;x&#30340;&#32534;&#30721;&#28857;&#22312;&#33539;&#22260;&#20004;&#31471;&#23383;&#31526;y&#21644;z&#30340;&#32534;&#30721;&#28857;&#20043;&#38388;&#65292;&#23601;&#31216;&#23383;&#31526;x&#22312;&#33539;&#22260;y&#21040;z&#30340;&#20013;&#38388;&#12290;
        &#21478;&#22806;&#65292;&#22914;&#26524;&#22312;&#26500;&#36896;&#27491;&#21017;&#34920;&#36798;&#24335;&#26102;&#35774;&#32622;&#20102; <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;"><code class="literal">collate</code>
        &#26631;&#35760;</a>&#65292; &#37027;&#33539;&#22260;&#23601;&#26159;locale&#30456;&#20851;&#30340;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.negation_______"></a><h6>
<a name="id4868569"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.negation_______">Negation &#21542;&#23450;</a>
      </h6>
<p>
        If the bracket-expression begins with the ^ character, then it matches the
        complement of the characters it contains, for example <code class="literal">[^a-c]</code>
        matches any character that is not in the range <code class="literal">a-c</code>.<br>
        &#22914;&#26524;&#26041;&#25324;&#21495;&#34920;&#36798;&#24335;&#20197; ^ &#23383;&#31526;&#24320;&#22987;&#65292;&#37027;&#20040;&#23427;&#21305;&#37197;&#21253;&#21547;&#23383;&#31526;&#30340;&#34917;&#38598;&#65292;&#20363;&#22914;
        <code class="literal">[^a-c]</code> &#21305;&#37197;&#19981;&#22312; <code class="literal">a-c</code> &#33539;&#22260;&#20869;&#30340;&#20219;&#24847;&#23383;&#31526;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.character_classes__________"></a><h6>
<a name="id4868623"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_classes__________">Character
        classes &#23383;&#31526;&#31867;</a>
      </h6>
<p>
        An expression of the form <code class="literal">[[:name:]]</code> matches the named
        character class "name", for example <code class="literal">[[:lower:]]</code>
        matches any lower case character. See <a class="link" href="character_classes.html" title="Character Class Names &#23383;&#31526;&#31867;&#21517;&#31216;">character
        class names</a>.<br> &#24418;&#22914; <code class="literal">[[:name:]]</code> &#30340;&#34920;&#36798;&#24335;&#21305;&#37197;&#21629;&#21517;&#23383;&#31526;&#31867;"name"&#65292;&#20363;&#22914;
        <code class="literal">[[:lower:]]</code> &#20219;&#24847;&#23567;&#20889;&#23383;&#31526;&#12290; &#21442;&#35265; <a class="link" href="character_classes.html" title="Character Class Names &#23383;&#31526;&#31867;&#21517;&#31216;">&#23383;&#31526;&#31867;&#21517;&#31216;</a>&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.collating_elements_____________"></a><h6>
<a name="id4868691"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.collating_elements_____________">Collating
        Elements &#23545;&#29031;&#20803;&#32032;</a>
      </h6>
<p>
        An expression of the form <code class="literal">[[.col.]]</code> matches the collating
        element <span class="emphasis"><em>col</em></span>. A collating element is any single character,
        or any sequence of characters that collates as a single unit. Collating elements
        may also be used as the end point of a range, for example: <code class="literal">[[.ae.]-c]</code>
        matches the character sequence "ae", plus any single character
        in the range "ae"-c, assuming that "ae" is treated as
        a single collating element in the current locale.<br> &#24418;&#22914; <code class="literal">[[.col.]]</code>
        &#30340;&#34920;&#36798;&#24335;&#21305;&#37197;&#23545;&#29031;&#20803;&#32032; /col/&#12290;&#23545;&#29031;&#20803;&#32032;&#26159;&#20219;&#24847;&#30340;&#21333;&#20010;&#23383;&#31526;&#65292;&#25110;&#23545;&#24212;&#20110;&#26576;&#20010;&#21333;&#20010;&#21333;&#20803;&#30340;&#23383;&#31526;&#24207;&#21015;&#12290;
        &#23545;&#29031;&#36824;&#21487;&#20197;&#29992;&#20316;&#33539;&#22260;&#30340;&#31471;&#28857;&#65292;&#20363;&#22914; <code class="literal">[[.ae.]-c]</code>
        &#21305;&#37197;&#23383;&#31526;&#24207;&#21015;"ae"&#65292;&#21644;&#20219;&#24847;&#30340;&#21333;&#20010;&#23383;&#31526;&#22312;&#33539;&#22260;"ae"&#21040;c&#20043;&#38388;&#65292;
        &#20854;&#20013;"ae"&#34987;&#24403;&#21069;locale&#22788;&#29702;&#20026;&#21333;&#20010;&#23545;&#29031;&#20803;&#32032;&#12290;
      </p>
<p>
        As an extension, a collating element may also be specified via it's <a class="link" href="collating_names.html" title="Collating Names &#23545;&#29031;&#21517;&#31216;">symbolic name</a>, for example:<br>
        &#20316;&#20026;&#25193;&#23637;&#65292;&#23545;&#29031;&#20803;&#32032;&#21487;&#20197;&#36890;&#36807;&#20854; <a class="link" href="collating_names.html" title="Collating Names &#23545;&#29031;&#21517;&#31216;">&#31526;&#21495;&#21517;</a>
        &#25351;&#23450;&#65292;&#20363;&#22914;&#65306;
      </p>
<pre class="programlisting"><span class="special">[[.</span><span class="identifier">NUL</span><span class="special">.]]</span>
</pre>
<p>
        matches a <code class="literal">\0</code> character.<br> &#21305;&#37197;&#19968;&#20010; <code class="literal">\0</code>
        &#23383;&#31526;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.equivalence_classes__________"></a><h6>
<a name="id4868820"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.equivalence_classes__________">Equivalence
        classes &#31561;&#20215;&#31867;</a>
      </h6>
<p>
        An expression of the form <code class="literal">[[=col=]]</code>, matches any character
        or collating element whose primary sort key is the same as that for collating
        element <span class="emphasis"><em>col</em></span>, as with collating elements the name <span class="emphasis"><em>col</em></span>
        may be a <a class="link" href="collating_names.html" title="Collating Names &#23545;&#29031;&#21517;&#31216;">symbolic name</a>.
        A primary sort key is one that ignores case, accentation, or locale-specific
        tailorings; so for example <code class="computeroutput"><span class="special">[[=</span><span class="identifier">a</span><span class="special">=]]</span></code> matches
        any of the characters: a, &#192;, &#193;, &#194;, &#195;, &#196;, &#197;, A, &#224;, &#225;, &#226;, &#227;, &#228; and &#229;. Unfortunately implementation
        of this is reliant on the platform's collation and localisation support;
        this feature can not be relied upon to work portably across all platforms,
        or even all locales on one platform.<br> &#24418;&#22914; <code class="literal">[[=col=]]</code>
        &#30340;&#34920;&#36798;&#24335;&#21305;&#37197;&#20027;&#25490;&#24207;&#20851;&#38190;&#23383;&#31561;&#21516;&#20110;&#23545;&#29031;&#20803;&#32032; <span class="emphasis"><em>col</em></span>
        &#30340;&#20219;&#24847;&#23383;&#31526;&#25110;&#23545;&#29031;&#20803;&#32032;&#65292;&#20854;&#20013;&#21517;&#23383;&#20026; <span class="emphasis"><em>col</em></span>
        &#30340;&#23545;&#29031;&#20803;&#32032;&#21487;&#20197;&#26159;&#19968;&#20010; <a class="link" href="collating_names.html" title="Collating Names &#23545;&#29031;&#21517;&#31216;">&#31526;&#21495;&#21517;</a>&#12290;&#20027;&#25490;&#24207;&#20851;&#38190;&#23383;&#24573;&#30053;&#22823;&#23567;&#20889;&#12289;&#37325;&#38899;&#25110;&#29305;&#23450;&#21306;&#22495;(locale)&#30340;&#35009;&#21098;(tailorings)&#65307;
        &#25152;&#20197;&#22914; <code class="computeroutput"><span class="special">[[=</span><span class="identifier">a</span><span class="special">=]]</span></code> &#21305;&#37197;&#19979;&#38754;&#30340;&#23383;&#31526;&#65306;a, &#192;, &#193;, &#194;, &#195;, &#196;, &#197;,
        A, &#224;, &#225;, &#226;, &#227;, &#228; &#21644; &#229;&#12290; &#19981;&#24184;&#30340;&#26159;&#36825;&#20010;&#23454;&#29616;&#20381;&#36182;&#20110;&#24179;&#21488;&#30340;&#23545;&#29031;(collation)&#21644;&#22320;&#21306;(localization)&#25903;&#25345;&#65307;
        &#36825;&#20010;&#29305;&#24615;&#24182;&#19981;&#33021;&#24456;&#22909;&#22320;&#21487;&#31227;&#26893;&#24037;&#20316;&#20110;&#25152;&#26377;&#30340;&#24179;&#21488;&#65292;&#29978;&#33267;&#19968;&#20010;&#24179;&#21488;&#19978;&#30340;&#25152;&#26377;&#21306;&#22495;(locale)&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.escaped_characters_____________"></a><h6>
<a name="id4868952"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.escaped_characters_____________">Escaped
        Characters &#36716;&#20041;&#23383;&#31526;</a>
      </h6>
<p>
        All the escape sequences that match a single character, or a single character
        class are permitted within a character class definition. For example <code class="computeroutput"><span class="special">[\[\]]</span></code> would match either of <code class="computeroutput"><span class="special">[</span></code> or <code class="computeroutput"><span class="special">]</span></code>
        while <code class="computeroutput"><span class="special">[\</span><span class="identifier">W</span><span class="special">\</span><span class="identifier">d</span><span class="special">]</span></code>
        would match any character that is either a "digit", <span class="emphasis"><em>or</em></span>
        is <span class="emphasis"><em>not</em></span> a "word" character.<br> &#20219;&#24847;&#21305;&#37197;&#21333;&#20010;&#23383;&#31526;&#25110;&#21333;&#20010;&#23383;&#31526;&#31867;&#30340;&#36716;&#20041;&#24207;&#21015;&#37117;&#21487;&#20197;&#23450;&#20041;&#22312;&#23383;&#31526;&#31867;&#20013;&#12290;
        &#20363;&#22914;<code class="computeroutput"><span class="special">[\[\]]</span></code> &#21487;&#20197;&#21305;&#37197; <code class="computeroutput"><span class="special">[</span></code> &#25110; <code class="computeroutput"><span class="special">]</span></code>
        &#65292;&#32780; <code class="computeroutput"><span class="special">[\</span><span class="identifier">W</span><span class="special">\</span><span class="identifier">d</span><span class="special">]</span></code>
        &#21487;&#20197;&#21305;&#37197;&#20219;&#20309;&#19981;&#26159;"&#25968;&#23383;"/&#25110;&#19981;&#26159;/"&#21333;&#35789;"&#30340;&#23383;&#31526;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.combinations_______"></a><h6>
<a name="id4869101"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.combinations_______">Combinations
        &#32452;&#21512;</a>
      </h6>
<p>
        All of the above can be combined in one character set declaration, for example:
        <code class="literal">[[:digit:]a-c[.NUL.]]</code>.<br> &#25152;&#26377;&#19978;&#38754;&#30340;&#37117;&#21487;&#20197;&#22312;&#19968;&#20010;&#23383;&#31526;&#31867;&#22768;&#26126;&#20013;&#34987;&#32452;&#21512;&#65292;&#20363;&#22914;
        <code class="literal">[[:digit:]a-c[.NUL.]]</code>&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.escapes__________"></a><h5>
<a name="id4869141"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.escapes__________">Escapes
        &#36716;&#20041;&#31526;</a>
      </h5>
<p>
        Any special character preceded by an escape shall match itself.<br> &#20219;&#24847;&#29305;&#27530;&#23383;&#31526;&#21069;&#38754;&#21152;&#36716;&#20041;&#31526;&#37117;&#21305;&#37197;&#33258;&#24049;&#12290;
      </p>
<p>
        The following escape sequences are all synonyms for single characters:<br>
        &#19979;&#38754;&#30340;&#36716;&#20041;&#24207;&#21015;&#37117;&#21644;&#21333;&#20010;&#23383;&#31526;&#21516;&#20041;&#65306;
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Escape &#36716;&#20041;&#31526;
              </p>
              </th>
<th>
              <p>
                Character &#23383;&#31526;
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="literal">\a</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">\a</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\e</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">0x1B</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\f</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">\f</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\n</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">\n</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\r</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">\r</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\t</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">\t</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\v</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">\v</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\b</code>
              </p>
              </td>
<td>
              <p>
                <code class="literal">\b</code> (but only inside a character class declaration).<br>
                <code class="literal">\b</code> (&#20294;&#20165;&#22312;&#23383;&#31526;&#31867;&#22768;&#26126;&#20013;&#20351;&#29992;)
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\cX</code>
              </p>
              </td>
<td>
              <p>
                An ASCII escape sequence - the character whose code point is X %
                32<br> &#19968;&#20010;ASCII&#36716;&#20041;&#24207;&#21015; - &#23383;&#31526;&#30721;&#28857;&#20026; X % 32
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\xdd</code>
              </p>
              </td>
<td>
              <p>
                A hexadecimal escape sequence - matches the single character whose
                code point is 0xdd.<br> &#19968;&#20010;&#21313;&#20845;&#36827;&#21046;&#36716;&#20041;&#24207;&#21015; - &#21305;&#37197;&#30721;&#28857;&#20026;0xdd&#30340;&#21333;&#20010;&#23383;&#31526;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\x{dddd}</code>
              </p>
              </td>
<td>
              <p>
                A hexadecimal escape sequence - matches the single character whose
                code point is 0xdddd.<br> &#19968;&#20010;&#21313;&#20845;&#36827;&#21046;&#36716;&#20041;&#24207;&#21015; - &#21305;&#37197;&#30721;&#28857;&#20026;0xdddd&#30340;&#21333;&#20010;&#23383;&#31526;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\0ddd</code>
              </p>
              </td>
<td>
              <p>
                An octal escape sequence - matches the single character whose code
                point is 0ddd.<br> &#20843;&#36827;&#21046;&#36716;&#20041;&#24207;&#21015; - &#21305;&#37197;&#30721;&#28857;&#20026;0ddd&#30340;&#21333;&#20010;&#23383;&#31526;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">\N{name}</code>
              </p>
              </td>
<td>
              <p>
                Matches the single character which has the <a class="link" href="collating_names.html" title="Collating Names &#23545;&#29031;&#21517;&#31216;">symbolic
                name</a> <span class="emphasis"><em>name</em></span>. For example <code class="literal">\N{newline}</code>
                matches the single character \n.<br> &#21305;&#37197; <a class="link" href="collating_names.html" title="Collating Names &#23545;&#29031;&#21517;&#31216;">&#31526;&#21495;&#21517;</a>
                &#20026; <span class="emphasis"><em>name</em></span> &#30340;&#21333;&#20010;&#23383;&#31526;&#12290;&#20363;&#22914; <code class="literal">\N{newline}</code>
                &#21305;&#37197;&#21333;&#20010;&#23383;&#31526; \n&#12290;
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.syntax.perl_syntax._quot_single_character_quot__character_classes___quot___________quot__________"></a><h6>
<a name="id4869596"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax._quot_single_character_quot__character_classes___quot___________quot__________">"Single
        character" character classes: "&#21333;&#23383;&#31526;"&#23383;&#31526;&#31867;</a>
      </h6>
<p>
        Any escaped character <span class="emphasis"><em>x</em></span>, if <span class="emphasis"><em>x</em></span> is
        the name of a character class shall match any character that is a member
        of that class, and any escaped character <span class="emphasis"><em>X</em></span>, if <span class="emphasis"><em>x</em></span>
        is the name of a character class, shall match any character not in that class.<br>
        &#20219;&#24847;&#34987;&#36716;&#20041;&#30340;&#23383;&#31526; <span class="emphasis"><em>x/&#65292;&#22914;&#26524; /x</em></span> &#26159;&#19968;&#20010;&#23383;&#31526;&#31867;&#30340;&#21517;&#31216;&#65292;&#20250;&#21305;&#37197;&#36825;&#20010;&#23383;&#31526;&#31867;&#25104;&#21592;&#30340;&#20219;&#24847;&#23383;&#31526;&#12290;
        &#20219;&#24847;&#34987;&#36716;&#20041;&#30340;&#23383;&#31526; <span class="emphasis"><em>X</em></span>, &#22914;&#26524; <span class="emphasis"><em>x</em></span>
        &#26159;&#19968;&#20010;&#23383;&#31526;&#31867;&#30340;&#21517;&#31216;&#65292;&#21017;&#20250;&#21305;&#37197;&#19981;&#22312;&#36825;&#20010;&#31867;&#20013;&#30340;&#20219;&#24847;&#23383;&#31526;&#12290;
      </p>
<p>
        The following are supported by default:<br> &#19979;&#38754;&#26159;&#40664;&#35748;&#25903;&#25345;&#30340;&#65306;
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Escape sequence &#36716;&#20041;&#24207;&#21015;
              </p>
              </th>
<th>
              <p>
                Equivalent to &#31561;&#20215;&#20110;
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">d</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">digit</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">l</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">lower</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">s</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">space</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">u</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">upper</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">w</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">word</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">h</span></code>
              </p>
              </td>
<td>
              <p>
                Horizontal whitespace<br> &#27700;&#24179;&#31354;&#30333;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">v</span></code>
              </p>
              </td>
<td>
              <p>
                Vertical whitespace<br> &#22402;&#30452;&#31354;&#30333;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">D</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">digit</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">L</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">lower</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">S</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">space</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">U</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">upper</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">W</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">word</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">H</span></code>
              </p>
              </td>
<td>
              <p>
                Not Horizontal whitespace<br> &#38750;&#27700;&#24179;&#31354;&#30333;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">V</span></code>
              </p>
              </td>
<td>
              <p>
                Not Vertical whitespace<br> &#38750;&#22402;&#30452;&#31354;&#30333;
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.syntax.perl_syntax.character_properties_____________"></a><h6>
<a name="id4870285"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.character_properties_____________">Character
        Properties &#23383;&#31526;&#23646;&#24615;</a>
      </h6>
<p>
        The character property names in the following table are all equivalent to
        the <a class="link" href="character_classes.html" title="Character Class Names &#23383;&#31526;&#31867;&#21517;&#31216;">names used in character
        classes</a>.<br> &#19979;&#38754;&#34920;&#26684;&#20013;&#30340;&#23383;&#31526;&#23646;&#24615;&#21517;&#31216;&#37117;&#31561;&#20215;&#20110; <a class="link" href="character_classes.html" title="Character Class Names &#23383;&#31526;&#31867;&#21517;&#31216;">&#22312;&#23383;&#31526;&#31867;&#20013;&#20351;&#29992;&#30340;&#21517;&#23383;</a>&#12290;
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Form &#24418;&#24335;
              </p>
              </th>
<th>
              <p>
                Description &#35828;&#26126;
              </p>
              </th>
<th>
              <p>
                Equivalent character set form &#31561;&#20215;&#30340;&#23383;&#31526;&#38598;&#24418;&#24335;
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">pX</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that has the property X.<br> &#21305;&#37197;&#20219;&#24847;&#20855;&#26377;&#23646;&#24615;X&#30340;&#23383;&#31526;&#12290;
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">X</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">p</span><span class="special">{</span><span class="identifier">Name</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that has the property Name.<br> &#21305;&#37197;&#20219;&#24847;&#20855;&#26377;&#23646;&#24615;Name&#30340;&#23383;&#31526;&#12290;
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[[:</span><span class="identifier">Name</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">PX</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that does not have the property X.<br> &#21305;&#37197;&#20219;&#24847;&#19981;&#20855;&#26377;&#23646;&#24615;X&#30340;&#23383;&#31526;&#12290;
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">X</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="special">\</span><span class="identifier">P</span><span class="special">{</span><span class="identifier">Name</span><span class="special">}</span></code>
              </p>
              </td>
<td>
              <p>
                Matches any character that does not have the property Name.<br>
                &#21305;&#37197;&#20219;&#24847;&#19981;&#20855;&#26377;&#23646;&#24615;Name&#30340;&#23383;&#31526;&#12290;
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="special">[^[:</span><span class="identifier">Name</span><span class="special">:]]</span></code>
              </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        For example <code class="literal">\pd</code> matches any "digit" character,
        as does <code class="literal">\p{digit}</code>.<br> &#20363;&#22914; <code class="literal">\pd</code>
        &#21305;&#37197;&#20219;&#24847;&#30340;"&#25968;&#23383;"&#23383;&#31526;&#65292;&#21644; <code class="literal">\p{digit}</code>
        &#20316;&#29992;&#26159;&#19968;&#26679;&#30340;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.word_boundaries_____________"></a><h6>
<a name="id4870663"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.word_boundaries_____________">Word
        Boundaries &#21333;&#35789;&#36793;&#30028;</a>
      </h6>
<p>
        The following escape sequences match the boundaries of words:<br> &#19979;&#38754;&#30340;&#36716;&#20041;&#24207;&#21015;&#21305;&#37197;&#21333;&#35789;&#30340;&#36793;&#30028;&#65306;
      </p>
<p>
        <code class="literal">\&lt;</code> Matches the start of a word.<br> <code class="literal">\&lt;</code>
        &#21305;&#37197;&#21333;&#35789;&#30340;&#36215;&#28857;&#12290;
      </p>
<p>
        <code class="literal">\&gt;</code> Matches the end of a word.<br> <code class="literal">\&gt;</code>
        &#21305;&#37197;&#21333;&#35789;&#30340;&#32456;&#28857;&#12290;
      </p>
<p>
        <code class="literal">\b</code> Matches a word boundary (the start or end of a word).<br>
        <code class="literal">\b</code> &#21305;&#37197;&#21333;&#35789;&#30340;&#36793;&#30028;(&#36215;&#28857;&#25110;&#32456;&#28857;)&#12290;
      </p>
<p>
        <code class="literal">\B</code> Matches only when not at a word boundary.<br> <code class="literal">\B</code>
        &#21482;&#26377;&#19981;&#22312;&#21333;&#35789;&#36793;&#30028;&#26102;&#25165;&#21305;&#37197;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.buffer_boundaries________________"></a><h6>
<a name="id4870772"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.buffer_boundaries________________">Buffer
        boundaries &#32531;&#20914;&#21306;&#36793;&#30028;</a>
      </h6>
<p>
        The following match only at buffer boundaries: a "buffer" in this
        context is the whole of the input text that is being matched against (note
        that ^ and $ may match embedded newlines within the text).<br> &#19979;&#38754;&#30340;&#36716;&#20041;&#24207;&#21015;&#21305;&#37197;&#32531;&#20914;&#21306;&#36793;&#30028;&#65306;&#36825;&#37324;&#30340;"&#32531;&#20914;&#21306;"&#25351;&#29992;&#20110;&#21305;&#37197;&#30340;&#20840;&#37096;&#36755;&#20837;&#25991;&#26412;(&#27880;&#24847;&#65292;^&#21644;$&#21487;&#20197;&#29992;&#20110;&#21305;&#37197;&#25991;&#26412;&#20013;&#30340;&#34892;)&#12290;
      </p>
<p>
        \` Matches at the start of a buffer only.<br> \` &#21305;&#37197;&#32531;&#20914;&#21306;&#30340;&#36215;&#28857;&#12290;
      </p>
<p>
        \' Matches at the end of a buffer only.<br> \' &#21305;&#37197;&#32531;&#20914;&#21306;&#30340;&#32456;&#28857;
      </p>
<p>
        \A Matches at the start of a buffer only (the same as \`).<br> \A &#21305;&#37197;&#32531;&#20914;&#21306;&#30340;&#36215;&#28857;(&#21516;
        \` &#19968;&#26679;)&#12290;
      </p>
<p>
        \z Matches at the end of a buffer only (the same as \').<br> \z &#21305;&#37197;&#32531;&#20914;&#21306;&#30340;&#32456;&#28857;(&#21516;
        \' &#19968;&#26679;)&#12290;
      </p>
<p>
        \Z Matches an optional sequence of newlines at the end of a buffer: equivalent
        to the regular expression <code class="literal">\n*\z</code><br> \Z &#21305;&#37197;&#32531;&#20914;&#21306;&#32467;&#23614;&#21487;&#33021;&#23384;&#22312;&#30340;&#31354;&#34892;&#65306;&#31561;&#20215;&#20110;&#27491;&#21017;&#34920;&#36798;&#24335;
        <code class="literal">\n*\z</code>
      </p>
<a name="boost_regex.syntax.perl_syntax.continuation_escape_____________"></a><h6>
<a name="id4870863"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.continuation_escape_____________">Continuation
        Escape &#25345;&#32493;&#36716;&#20041;</a>
      </h6>
<p>
        The sequence <code class="literal">\G</code> matches only at the end of the last match
        found, or at the start of the text being matched if no previous match was
        found. This escape useful if you're iterating over the matches contained
        within a text, and you want each subsequence match to start where the last
        one ended.<br> &#24207;&#21015; <code class="literal">\G</code> &#21482;&#22312;&#19978;&#27425;&#21305;&#37197;&#32467;&#23614;&#25110;&#21305;&#37197;&#25991;&#26412;&#30340;&#36215;&#28857;(&#22914;&#26524;&#21069;&#38754;&#27809;&#26377;&#21305;&#37197;)&#12290;
        &#24403;&#20320;&#35201;&#36845;&#20195;&#25991;&#26412;&#20013;&#25152;&#26377;&#30340;&#21305;&#37197;&#65292;&#24182;&#19988;&#27599;&#20010;&#23376;&#24207;&#21015;&#37117;&#20174;&#19978;&#19968;&#27425;&#32467;&#26463;&#26102;&#24320;&#22987;&#21305;&#37197;&#30340;&#35805;&#65292;&#36825;&#20010;&#36716;&#20041;&#26159;&#24456;&#26377;&#29992;&#30340;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.quoting_escape_____________"></a><h6>
<a name="id4870917"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.quoting_escape_____________">Quoting
        escape &#24341;&#29992;&#36716;&#20041;</a>
      </h6>
<p>
        The escape sequence <code class="literal">\Q</code> begins a "quoted sequence":
        all the subsequent characters are treated as literals, until either the end
        of the regular expression or \E is found. For example the expression: <code class="literal">\Q\*+\Ea+</code>
        would match either of:<br> &#36716;&#20041;&#24207;&#21015; <code class="literal">\Q</code> &#24320;&#22987;&#19968;&#20010;"&#34987;&#24341;&#29992;&#24207;&#21015;"&#65306;&#25152;&#26377;&#21518;&#38754;&#30340;&#23383;&#31526;&#37117;&#34987;&#24403;&#20316;&#23383;&#38754;&#23545;&#24453;&#65292;&#38500;&#38750;&#27491;&#21017;&#34920;&#36798;&#24335;&#32467;&#26463;&#25110;&#30896;&#21040;
        \E&#12290; &#20363;&#22914;&#65292;&#34920;&#36798;&#24335;&#65306;<code class="literal">\Q\*+\Ea+</code> &#21487;&#20197;&#21305;&#37197;&#22914;&#19979;&#65306;
      </p>
<pre class="programlisting"><span class="special">\*+</span><span class="identifier">a</span>
<span class="special">\*+</span><span class="identifier">aaa</span>
</pre>
<a name="boost_regex.syntax.perl_syntax.unicode_escapes__unicode______"></a><h6>
<a name="id4871006"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.unicode_escapes__unicode______">Unicode
        escapes Unicode&#36716;&#20041;</a>
      </h6>
<p>
        <code class="literal">\C</code> Matches a single code point: in Boost regex this has
        exactly the same effect as a "." operator.<br> <code class="literal">\C</code>
        &#21305;&#37197;&#19968;&#20010;&#21333;&#19968;&#30340;&#30721;&#34920;&#65306;&#22312; Boost.Regex &#20013;&#36825;&#21644;"."&#25805;&#20316;&#31526;&#30340;&#20316;&#29992;&#26159;&#23436;&#20840;&#30456;&#21516;&#30340;&#12290;
      </p>
<p>
        <code class="literal">\X</code> Matches a combining character sequence: that is any
        non-combining character followed by a sequence of zero or more combining
        characters.<br> <code class="literal">\X</code> &#21305;&#37197;&#19968;&#20010;&#32452;&#21512;&#23383;&#31526;&#24207;&#21015;&#65306;&#20219;&#24847;&#38750;&#32452;&#21512;&#23383;&#31526;&#36319;&#19978;&#19968;&#20010;&#38646;&#25110;&#22810;&#20010;&#32452;&#21512;&#23383;&#31526;&#30340;&#24207;&#21015;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.matching_line_endings________________"></a><h6>
<a name="id4871075"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.matching_line_endings________________">Matching
        Line Endings &#21305;&#37197;&#34892;&#26411;&#31526;</a>
      </h6>
<p>
        The escape sequence <code class="literal">\R</code> matches any line ending character
        sequence, specifically it is identical to the expression <code class="literal">(?&gt;\x0D\x0A?|[\x0A-\x0C\x85\x{2028}\x{2029}])</code>.<br>
        &#36716;&#20041;&#24207;&#21015; <code class="literal">\R</code> &#21305;&#37197;&#20219;&#20309;&#34892;&#26411;&#31526;&#24207;&#21015;&#65292;&#29305;&#21035;&#22320;&#65292;&#23427;&#31561;&#21516;&#20110;&#34920;&#36798;&#24335;
        <code class="literal">(?&gt;\x0D\x0A?|[\x0A-\x0C\x85\x{2028}\x{2029}])</code>.
      </p>
<a name="boost_regex.syntax.perl_syntax.keeping_back_some_text___________________"></a><h6>
<a name="id4871136"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.keeping_back_some_text___________________">Keeping
        back some text &#22238;&#36864;&#19968;&#20123;&#25991;&#26412;</a>
      </h6>
<p>
        <code class="literal">\K</code> Resets the start location of $0 to the current text
        position: in other words everything to the left of \K is "kept back"
        and does not form part of the regular expression match. $` is updated accordingly.<br>
        <code class="literal">\K</code> &#23558;$0&#30340;&#24320;&#22987;&#20301;&#32622;&#37325;&#32622;&#20026;&#24403;&#21069;&#25991;&#26412;&#20301;&#32622;&#65306;&#25442;&#35328;&#20043;&#65292;\K
        &#24038;&#36793;&#30340;&#25152;&#26377;&#19996;&#35199;&#34987;"&#36864;&#22238;"&#19988;&#19981;&#20316;&#20026;&#35813;&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#21305;&#37197;&#37096;&#20998;&#12290;
        $` &#20063;&#34987;&#30456;&#24212;&#26356;&#26032;&#12290;
      </p>
<p>
        For example <code class="literal">foo\Kbar</code> matched against the text "foobar"
        would return the match "bar" for $0 and "foo" for $`.
        This can be used to simulate variable width lookbehind assertions.<br>
        &#20363;&#22914;&#65292;<code class="literal">foo\Kbar</code> &#29992;&#20110;&#21305;&#37197;&#25991;&#26412; "foobar"
        &#26102;&#65292;&#23558;&#23545; $0 &#36820;&#22238;&#21305;&#37197; "bar"&#65292;&#23545; $` &#36820;&#22238; "foo"&#12290;
        &#36825;&#21487;&#20197;&#34987;&#29992;&#20110;&#27169;&#25311;&#21487;&#21464;&#23485;&#24230;&#30340;&#21518;&#21521;&#29615;&#35270;&#26029;&#35328;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.any_other_escape_____________"></a><h6>
<a name="id4871213"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.any_other_escape_____________">Any
        other escape &#20854;&#23427;&#36716;&#20041;</a>
      </h6>
<p>
        Any other escape sequence matches the character that is escaped, for example
        \@ matches a literal '@'.<br> &#20854;&#23427;&#36716;&#20041;&#24207;&#21015;&#21305;&#37197;&#34987;&#36716;&#20041;&#30340;&#23383;&#31526;&#65292;&#20363;&#22914;
        \@&#21305;&#37197; '@'&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.perl_extended_patterns__perl____________"></a><h5>
<a name="id4871248"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.perl_extended_patterns__perl____________">Perl
        Extended Patterns Perl&#25193;&#23637;&#27169;&#24335;</a>
      </h5>
<p>
        Perl-specific extensions to the regular expression syntax all start with
        <code class="literal">(?</code>.<br> Perl&#25193;&#23637;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;&#37117;&#20197; <code class="literal">(?</code>
        &#24320;&#22987;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.named_subexpressions___________________"></a><h6>
<a name="id4871292"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.named_subexpressions___________________">Named
        Subexpressions &#21629;&#21517;&#23376;&#34920;&#36798;&#24335;</a>
      </h6>
<p>
        You can create a named subexpression using:<br> &#20320;&#21487;&#20197;&#22914;&#19979;&#21019;&#24314;&#19968;&#20010;&#21629;&#21517;&#23376;&#34920;&#36798;&#24335;&#65306;
      </p>
<pre class="programlisting"><span class="special">(?&lt;</span><span class="identifier">NAME</span><span class="special">&gt;</span><span class="identifier">expression</span><span class="special">)</span>
</pre>
<p>
        Which can be then be refered to by the name <span class="emphasis"><em>NAME</em></span>. Alternatively
        you can delimit the name using 'NAME' as in:<br> &#28982;&#21518;&#65292;&#35813;&#34920;&#36798;&#24335;&#21363;&#21487;&#36890;&#36807;&#21517;&#23383;
        <span class="emphasis"><em>NAME</em></span> &#26469;&#24341;&#29992;&#12290;&#25110;&#32773;&#20320;&#20063;&#21487;&#20197;&#29992; 'NAME' &#26469;&#20998;&#38548;&#35813;&#21517;&#23383;&#65292;&#22914;&#65306;
      </p>
<pre class="programlisting"><span class="special">(?</span><span class="char">'NAME'</span><span class="identifier">expression</span><span class="special">)</span>
</pre>
<p>
        These named subexpressions can be refered to in a backreference using either
        <code class="literal">\g{NAME}</code> or <code class="literal">\k&lt;NAME&gt;</code> and can
        also be refered to by name in a <a class="link" href="../format/perl_format.html" title="Perl Format String Syntax Perl&#26684;&#24335;&#21270;&#20018;&#35821;&#27861;">Perl</a>
        format string for search and replace operations, or in the <a class="link" href="../ref/match_results.html" title="match_results"><code class="computeroutput"><span class="identifier">match_results</span></code></a> member functions.<br>
        &#36825;&#20123;&#21629;&#21517;&#23376;&#34920;&#36798;&#24335;&#21487;&#20197;&#29992; <code class="literal">\g{NAME}</code> &#25110; <code class="literal">\k&lt;NAME&gt;</code>
        &#26469;&#21518;&#21521;&#24341;&#29992;&#65292;&#20063;&#21487;&#20197;&#22312;&#19968;&#20010; <a class="link" href="../format/perl_format.html" title="Perl Format String Syntax Perl&#26684;&#24335;&#21270;&#20018;&#35821;&#27861;">Perl</a>
        &#26684;&#24335;&#21270;&#20018;&#25110;&#22312; <a class="link" href="../ref/match_results.html" title="match_results"><code class="computeroutput"><span class="identifier">match_results</span></code></a> &#25104;&#21592;&#20989;&#25968;&#20013;&#36890;&#36807;&#21517;&#23383;&#26469;&#24341;&#29992;&#20197;&#36827;&#34892;&#25628;&#32034;&#21644;&#26367;&#25442;&#30340;&#25805;&#20316;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.comments_______"></a><h6>
<a name="id4871488"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.comments_______">Comments &#27880;&#37322;</a>
      </h6>
<p>
        <code class="literal">(?# ... )</code> is treated as a comment, it's contents are ignored.<br>
        <code class="literal">(?# ... )</code> &#20316;&#20026;&#27880;&#37322;&#65292;&#37324;&#38754;&#30340;&#20869;&#23481;&#34987;&#24573;&#30053;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.modifiers_______"></a><h6>
<a name="id4871530"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.modifiers_______">Modifiers
        &#20462;&#39280;</a>
      </h6>
<p>
        <code class="literal">(?imsx-imsx ... )</code> alters which of the perl modifiers are
        in effect within the pattern, changes take effect from the point that the
        block is first seen and extend to any enclosing <code class="literal">)</code>. Letters
        before a '-' turn that perl modifier on, letters afterward, turn it off.<br>
        <code class="literal">(?imsx-imsx ... )</code> &#25913;&#21464;&#22312;&#27169;&#24335;&#20013;perl&#20462;&#39280;&#31526;&#26159;&#21542;&#36215;&#20316;&#29992;&#65292;&#20174;&#22359;&#31532;&#19968;&#27425;&#34987;&#36935;&#21040;&#30340;&#28857;&#24320;&#22987;&#36215;&#20316;&#29992;&#65292;&#30452;&#21040;&#36935;&#21040;&#32467;&#26463;
        =)=&#12290; '-' &#20043;&#21069;&#30340;&#23383;&#27597;&#25171;&#24320;perl&#20462;&#39280;&#31526;&#65292;&#21518;&#38754;&#30340;&#23383;&#27597;&#20851;&#38381;&#12290;
      </p>
<p>
        <code class="literal">(?imsx-imsx:pattern)</code> applies the specified modifiers to
        pattern only.<br> <code class="literal">(?imsx-imsx:pattern)</code> &#21482;&#23558;&#29305;&#23450;&#30340;&#20462;&#39280;&#31526;&#24212;&#29992;&#20110;&#25351;&#23450;&#30340;&#27169;&#24335;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.non_marking_groups________________"></a><h6>
<a name="id4871606"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.non_marking_groups________________">Non-marking
        groups &#38750;&#26631;&#35760;&#20998;&#32452;</a>
      </h6>
<p>
        <code class="literal">(?:pattern)</code> lexically groups pattern, without generating
        an additional sub-expression.<br> <code class="literal">(?:pattern)</code> &#36827;&#34892;&#23383;&#38754;&#20998;&#32452;&#65292;&#20294;&#19981;&#20135;&#29983;&#39069;&#22806;&#30340;&#23376;&#34920;&#36798;&#24335;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.branch_reset_____________"></a><h6>
<a name="id4871650"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.branch_reset_____________">Branch
        reset &#20998;&#25903;&#37325;&#32622;</a>
      </h6>
<p>
        <code class="literal">(?|pattern)</code> resets the subexpression count at the start
        of each "|" alternative within <span class="emphasis"><em>pattern</em></span>.<br>
        <code class="literal">(?|pattern)</code> &#22312; <span class="emphasis"><em>pattern</em></span> &#20869;&#30340;&#27599;&#20010;
        "|" &#36873;&#25321;&#31526;&#24320;&#22987;&#37325;&#32622;&#23376;&#34920;&#36798;&#24335;&#35745;&#25968;&#12290;
      </p>
<p>
        The sub-expression count following this construct is that of whichever branch
        had the largest number of sub-expressions. This construct is useful when
        you want to capture one of a number of alternative matches in a single sub-expression
        index. <br> &#35813;&#32467;&#26500;&#20043;&#21518;&#30340;&#23376;&#34920;&#36798;&#24335;&#35745;&#25968;&#30001;&#20855;&#26377;&#26368;&#22823;&#23376;&#34920;&#36798;&#24335;&#25968;&#37327;&#30340;&#20998;&#25903;&#20915;&#23450;&#12290;&#24403;&#20320;&#24819;&#29992;&#21333;&#20010;&#23376;&#34920;&#36798;&#24335;&#32034;&#24341;&#25429;&#33719;&#22810;&#20010;&#21487;&#36873;&#21305;&#37197;&#20043;&#19968;&#30340;&#26102;&#20505;&#65292;&#21487;&#20351;&#29992;&#35813;&#32467;&#26500;&#12290;
      </p>
<p>
        In the following example the index of each sub-expression is shown below
        the expression:<br> &#22312;&#20197;&#19979;&#20363;&#23376;&#20013;&#65292;&#27599;&#20010;&#23376;&#34920;&#36798;&#24335;&#30340;&#32034;&#24341;&#22312;&#34920;&#36798;&#24335;&#20043;&#19979;&#32473;&#20986;&#65306;
      </p>
<pre class="programlisting"># before  ---------------branch-reset----------- after        
/ ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
# 1            2         2  3        2     3     4
</pre>
<a name="boost_regex.syntax.perl_syntax.lookahead_____________"></a><h6>
<a name="id4871737"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.lookahead_____________">Lookahead
        &#21069;&#21521;&#21305;&#37197;</a>
      </h6>
<p>
        <code class="literal">(?=pattern)</code> consumes zero characters, only if pattern
        matches.<br> <code class="literal">(?=pattern)</code> &#24403;&#27169;&#24335;&#21305;&#37197;&#26102;&#25104;&#21151;&#65292;&#20294;&#19981;&#28040;&#32791;&#23383;&#31526;&#12290;
      </p>
<p>
        <code class="literal">(?!pattern)</code> consumes zero characters, only if pattern
        does not match.<br> <code class="literal">(?!pattern)</code> &#24403;&#27169;&#24335;&#19981;&#21305;&#37197;&#26102;&#25104;&#21151;&#65292;&#20294;&#19981;&#28040;&#32791;&#23383;&#31526;&#12290;
      </p>
<p>
        Lookahead is typically used to create the logical AND of two regular expressions,
        for example if a password must contain a lower case letter, an upper case
        letter, a punctuation symbol, and be at least 6 characters long, then the
        expression:<br> &#21069;&#21521;&#21305;&#37197;&#30340;&#20856;&#22411;&#29992;&#27861;&#26159;&#21019;&#24314;&#20004;&#20010;&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36923;&#36753;&#19982;&#65292;&#20363;&#22914;&#19968;&#20010;&#23494;&#30721;&#24517;&#39035;&#21253;&#21547;&#19968;&#20010;&#23567;&#20889;&#23383;&#31526;&#65292;
        &#19968;&#20010;&#22823;&#20889;&#23383;&#31526;&#65292;&#19968;&#20010;&#26631;&#28857;&#31526;&#21495;&#65292;&#38271;&#24230;&#33267;&#23569;6&#20010;&#23383;&#31526;&#65292;&#37027;&#20040;&#34920;&#36798;&#24335;&#26159;&#65306;
      </p>
<pre class="programlisting"><span class="special">(?=.*[[:</span><span class="identifier">lower</span><span class="special">:]])(?=.*[[:</span><span class="identifier">upper</span><span class="special">:]])(?=.*[[:</span><span class="identifier">punct</span><span class="special">:]]).{</span><span class="number">6</span><span class="special">,}</span>
</pre>
<p>
        could be used to validate the password.<br> &#33021;&#34987;&#29992;&#26469;&#39564;&#35777;&#23494;&#30721;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.lookbehind_____________"></a><h6>
<a name="id4871874"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.lookbehind_____________">Lookbehind
        &#21518;&#21521;&#21305;&#37197;</a>
      </h6>
<p>
        <code class="literal">(?&lt;=pattern)</code> consumes zero characters, only if pattern
        could be matched against the characters preceding the current position (pattern
        must be of fixed length).<br> <code class="literal">(?&lt;=pattern)</code> &#21482;&#26377;&#24403;&#27169;&#24335;&#33021;&#22815;&#34987;&#24403;&#21069;&#20301;&#32622;&#20043;&#21069;&#30340;&#23383;&#31526;&#21305;&#37197;&#26102;&#25165;&#25104;&#21151;(&#27169;&#24335;&#24517;&#39035;&#26159;&#22266;&#23450;&#38271;&#24230;)&#65292;&#20294;&#24182;&#19981;&#28040;&#32791;&#23383;&#31526;&#12290;
      </p>
<p>
        <code class="literal">(?&lt;!pattern)</code> consumes zero characters, only if pattern
        could not be matched against the characters preceding the current position
        (pattern must be of fixed length).<br> <code class="literal">(?&lt;!pattern)</code>
        &#21482;&#26377;&#24403;&#27169;&#24335;&#19981;&#33021;&#22815;&#34987;&#24403;&#21069;&#20301;&#32622;&#20043;&#21069;&#30340;&#23383;&#31526;&#21305;&#37197;&#26102;&#25165;&#25104;&#21151;(&#27169;&#24335;&#24517;&#39035;&#26159;&#22266;&#23450;&#38271;&#24230;)&#65292;&#20294;&#24182;&#19981;&#28040;&#32791;&#23383;&#31526;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.independent_sub_expressions___________________"></a><h6>
<a name="id4871948"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.independent_sub_expressions___________________">Independent
        sub-expressions &#29420;&#31435;&#23376;&#34920;&#36798;&#24335;</a>
      </h6>
<p>
        <code class="literal">(?&gt;pattern)</code> <span class="emphasis"><em>pattern</em></span> is matched
        independently of the surrounding patterns, the expression will never backtrack
        into <span class="emphasis"><em>pattern</em></span>. Independent sub-expressions are typically
        used to improve performance; only the best possible match for pattern will
        be considered, if this doesn't allow the expression as a whole to match then
        no match is found at all.<br> <code class="literal">(?&gt;pattern)</code> <span class="emphasis"><em>pattern</em></span>
        &#29420;&#31435;&#20110;&#22806;&#22260;&#27169;&#24335;&#22320;&#34987;&#21305;&#37197;&#65292;&#34920;&#36798;&#24335;&#20915;&#19981;&#20250;&#34987;&#22238;&#28335;&#21040; <span class="emphasis"><em>pattern</em></span>
        &#20013;&#12290; &#29420;&#31435;&#23376;&#34920;&#36798;&#24335;&#36890;&#24120;&#29992;&#20110;&#25913;&#21892;&#24615;&#33021;&#65307;&#21482;&#26377;&#26368;&#22909;&#21487;&#33021;&#30340;&#21305;&#37197;&#25165;&#20250;&#34987;&#32771;&#34385;&#65292;&#22914;&#26524;&#34920;&#36798;&#24335;&#19981;&#33021;&#20316;&#20026;&#25972;&#20307;&#34987;&#21305;&#37197;&#65292;&#37027;&#23601;&#27809;&#26377;&#21305;&#37197;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.recursive_expressions________________"></a><h6>
<a name="id4872019"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.recursive_expressions________________">Recursive
        Expressions &#36882;&#24402;&#34920;&#36798;&#24335;</a>
      </h6>
<p>
        <code class="literal">(?<span class="emphasis"><em>N</em></span>) (?-<span class="emphasis"><em>N</em></span>) (?+<span class="emphasis"><em>N</em></span>)
        (?R) (?0)</code>
      </p>
<p>
        <code class="literal">(?R)</code> and <code class="literal">(?0)</code> recurse to the start
        of the entire pattern.<br> <code class="literal">(?R)</code> and <code class="literal">(?0)</code>
        &#36882;&#24402;&#33267;&#25972;&#20010;&#27169;&#26495;&#30340;&#24320;&#22987;&#12290;
      </p>
<p>
        <code class="literal">(?<span class="emphasis"><em>N</em></span>)</code> executes sub-expression <span class="emphasis"><em>N</em></span>
        recursively, for example <code class="literal">(?2)</code> will recurse to sub-expression
        2.<br> <code class="literal">(?<span class="emphasis"><em>N</em></span>)</code> &#37325;&#22797;&#25191;&#34892;&#23376;&#34920;&#36798;&#24335;/N/&#65292;&#20363;&#22914;
        <code class="literal">(?2)</code> &#23558;&#36882;&#24402;&#33267;&#23376;&#34920;&#36798;&#24335;2&#12290;
      </p>
<p>
        <code class="literal">(?-<span class="emphasis"><em>N</em></span>)</code> and <code class="literal">(?+<span class="emphasis"><em>N</em></span>)</code>
        are relative recursions, so for example <code class="literal">(?-1)</code> recurses
        to the last sub-expression to be declared, and <code class="literal">(?+1)</code> recurses
        to the next sub-expression to be declared.<br> <code class="literal">(?-<span class="emphasis"><em>N</em></span>)</code>
        &#21644; <code class="literal">(?+<span class="emphasis"><em>N</em></span>)</code> &#26159;&#30456;&#23545;&#36882;&#24402;&#65292;&#22240;&#27492;&#22914;
        <code class="literal">(?-1)</code> &#23558;&#36882;&#24402;&#33267;&#34987;&#22768;&#26126;&#30340;&#26368;&#21518;&#19968;&#20010;&#23376;&#34920;&#36798;&#24335;&#65292;&#32780;
        <code class="literal">(?+1)</code> &#21017;&#36882;&#24402;&#33267;&#34987;&#22768;&#26126;&#30340;&#19979;&#19968;&#20010;&#23376;&#34920;&#36798;&#24335;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.conditional_expressions________________"></a><h6>
<a name="id4872210"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.conditional_expressions________________">Conditional
        Expressions &#26465;&#20214;&#34920;&#36798;&#24335;</a>
      </h6>
<p>
        <code class="literal">(?(condition)yes-pattern|no-pattern)</code> attempts to match
        <span class="emphasis"><em>yes-pattern</em></span> if the <span class="emphasis"><em>condition</em></span> is
        true, otherwise attempts to match <span class="emphasis"><em>no-pattern</em></span>.<br>
        <code class="literal">(?(condition)yes-pattern|no-pattern)</code> &#24403; <span class="emphasis"><em>condition</em></span>
        &#25104;&#31435;&#26102;&#35797;&#22270;&#21305;&#37197; /yes-pattern/&#65292;&#21542;&#21017;&#35797;&#22270;&#21305;&#37197; /no-pattern/&#12290;
      </p>
<p>
        <code class="literal">(?(condition)yes-pattern)</code> attempts to match <span class="emphasis"><em>yes-pattern</em></span>
        if the <span class="emphasis"><em>condition</em></span> is true, otherwise fails.<br> <code class="literal">(?(condition)yes-pattern)</code>
        &#24403; <span class="emphasis"><em>condition</em></span> &#25104;&#31435;&#26102;&#35797;&#22270;&#21305;&#37197; /yes-pattern/&#65292;&#21542;&#21017;&#30452;&#25509;&#22833;&#36133;&#12290;
      </p>
<p>
        <span class="emphasis"><em>condition</em></span> may be either: a forward lookahead assert,
        the index of a marked sub-expression (the condition becomes true if the sub-expression
        has been matched), or an index of a recursion (the condition become true
        if we are executing directly inside the specified recursion).<br> <span class="emphasis"><em>condition</em></span>
        &#21487;&#20197;&#26159;&#19968;&#20010;&#21069;&#21521;&#21305;&#37197;&#26029;&#35328;&#65292; &#25110;&#32773;&#26159;&#19968;&#20010;&#26631;&#35760;&#23376;&#34920;&#36798;&#24335;&#24207;&#21495;(&#24403;&#23376;&#34920;&#36798;&#24335;&#21305;&#37197;&#26102;&#26465;&#20214;&#20026;&#30495;)&#65292;
        &#25110;&#26159;&#19968;&#20010;&#36882;&#24402;&#30340;&#32034;&#24341;(&#24403;&#25105;&#20204;&#22312;&#25351;&#23450;&#36882;&#24402;&#20013;&#30452;&#25509;&#25191;&#34892;&#26102;&#26465;&#20214;&#20026;&#30495;)&#12290;
      </p>
<p>
        Here is a summary of the possible predicates:<br> &#20197;&#19979;&#26159;&#21487;&#33021;&#30340;&#35859;&#35789;&#65306;
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="literal">(?(?=assert)yes-pattern|no-pattern)</code> Executes <span class="emphasis"><em>yes-pattern</em></span>
          if the forward look-ahead assert matches, otherwise executes <span class="emphasis"><em>no-pattern</em></span>.<br><code class="literal">(?(?=assert)yes-pattern|no-pattern)</code> &#22914;&#26524;&#21069;&#21521;&#21305;&#37197;&#25104;&#21151;&#21017;&#25191;&#34892;
          /yes-pattern/&#65292;&#21542;&#21017;&#25191;&#34892; /no-pattern/&#12290;
        </li>
<li>
<code class="literal">(?(?!assert)yes-pattern|no-pattern)</code> Executes <span class="emphasis"><em>yes-pattern</em></span>
          if the forward look-ahead assert does not match, otherwise executes <span class="emphasis"><em>no-pattern</em></span>.<br><code class="literal">(?(?!assert)yes-pattern|no-pattern)</code> &#22914;&#26524;&#21069;&#21521;&#21305;&#37197;&#19981;&#25104;&#21151;&#21017;&#25191;&#34892;
          /yes-pattern/&#65292;&#21542;&#21017;&#25191;&#34892; /no-pattern/&#12290;
        </li>
<li>
<code class="literal">(?(R)yes-pattern|no-pattern)</code> Executes <span class="emphasis"><em>yes-pattern</em></span>
          if we are executing inside a recursion, otherwise executes <span class="emphasis"><em>no-pattern</em></span>.<br><code class="literal">(?(R)yes-pattern|no-pattern)</code> &#22914;&#26524;&#26159;&#22312;&#26576;&#20010;&#36882;&#24402;&#30340;&#20869;&#37096;&#25191;&#34892;&#65292;&#21017;&#25191;&#34892;
          /yes-pattern/&#65292;&#21542;&#21017;&#25191;&#34892; /no-pattern/&#12290;
        </li>
<li>
<code class="literal">(?(R<span class="emphasis"><em>N</em></span>)yes-pattern|no-pattern)</code> Executes
          <span class="emphasis"><em>yes-pattern</em></span> if we are executing inside a recursion
          to sub-expression <span class="emphasis"><em>N</em></span>, otherwise executes <span class="emphasis"><em>no-pattern</em></span>.<br><code class="literal">(?(R<span class="emphasis"><em>N</em></span>)yes-pattern|no-pattern)</code> &#22914;&#26524;&#26159;&#22312;&#26576;&#20010;&#21040;&#23376;&#34920;&#36798;&#24335;/N/&#30340;&#36882;&#24402;&#20869;&#37096;&#25191;&#34892;&#65292;&#21017;&#25191;&#34892;
          /yes-pattern/&#65292;&#21542;&#21017;&#25191;&#34892; /no-pattern/&#12290;
        </li>
<li>
<code class="literal">(?(DEFINE)never-exectuted-pattern)</code> Defines a block of
          code that is never executed and matches no characters: this is usually
          used to define one or more named sub-expressions which are refered to from
          elsewhere in the pattern.<br><code class="literal">(?(DEFINE)never-exectuted-pattern)</code>
          &#23450;&#20041;&#19968;&#20010;&#20174;&#19981;&#25191;&#34892;&#20063;&#19981;&#21305;&#37197;&#20219;&#20309;&#23383;&#31526;&#30340;&#20195;&#30721;&#22359;&#65306; &#36890;&#24120;&#29992;&#20110;&#23450;&#20041;&#19968;&#20010;&#25110;&#22810;&#20010;&#20174;&#27169;&#26495;&#20854;&#23427;&#22320;&#26041;&#24341;&#29992;&#30340;&#21629;&#21517;&#23376;&#34920;&#36798;&#24335;&#12290;
        </li>
</ul></div>
<a name="boost_regex.syntax.perl_syntax.operator_precedence___________________"></a><h5>
<a name="id4872497"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.operator_precedence___________________">Operator
        precedence &#25805;&#20316;&#31526;&#20248;&#20808;&#32423;</a>
      </h5>
<p>
        The order of precedence for of operators is as follows:<br> &#25805;&#20316;&#31526;&#20248;&#20808;&#32423;&#22914;&#19979;&#65306;
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Collation-related bracket symbols <code class="computeroutput"><span class="special">[==]</span>
          <span class="special">[::]</span> <span class="special">[..]</span></code><br>
          &#23545;&#29031;&#30456;&#20851;&#30340;&#26041;&#25324;&#21495;&#23383;&#31526; <code class="computeroutput"><span class="special">[==]</span>
          <span class="special">[::]</span> <span class="special">[..]</span></code>
</li>
<li>
          Escaped characters <code class="literal">\</code><br> &#36716;&#20041;&#23383;&#31526; <code class="literal">\</code>
</li>
<li>
          Character set (bracket expression) <code class="computeroutput"><span class="special">[]</span></code><br>
          &#23383;&#31526;&#38598;(&#26041;&#25324;&#21495;&#34920;&#36798;&#24335;) <code class="computeroutput"><span class="special">[]</span></code>
</li>
<li>
          Grouping <code class="literal">()</code><br> &#20998;&#32452; <code class="literal">()</code>
</li>
<li>
          Single-character-ERE duplication <code class="literal">* + ? {m,n}</code><br> &#21333;&#23383;&#31526;-ERE&#37325;&#22797;
          <code class="literal">* + ? {m,n}</code>
</li>
<li>
          Concatenation <br> &#36830;&#25509;
        </li>
<li>
          Anchoring ^$<br> &#38170;&#28857; ^$
        </li>
<li>
          Alternation |<br> &#36873;&#25321; |
        </li>
</ol></div>
<a name="boost_regex.syntax.perl_syntax.what_gets_matched________________"></a><h4>
<a name="id4872685"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.what_gets_matched________________">What
        gets matched &#20160;&#20040;&#34987;&#21305;&#37197;</a>
      </h4>
<p>
        If you view the regular expression as a directed (possibly cyclic) graph,
        then the best match found is the first match found by a depth-first-search
        performed on that graph, while matching the input text.<br> &#22914;&#26524;&#20320;&#23558;&#27491;&#21017;&#34920;&#36798;&#24335;&#24403;&#20316;&#26377;&#21521;(&#21487;&#33021;&#24490;&#29615;)&#22270;&#65292;&#37027;&#20040;&#26368;&#20248;&#21305;&#37197;&#23601;&#26159;&#22312;&#21305;&#37197;&#36755;&#20837;&#25991;&#26412;&#36807;&#31243;&#20013;&#25353;&#29031;&#28145;&#24230;&#20248;&#20808;&#25628;&#32034;&#25214;&#21040;&#30340;&#31532;&#19968;&#20010;&#21305;&#37197;&#12290;
      </p>
<p>
        Alternatively:<br> &#25110;&#32773;&#35828;&#65306;
      </p>
<p>
        The best match found is the <a class="link" href="leftmost_longest_rule.html" title="The Leftmost Longest Rule &#26368;&#24038;&#26368;&#38271;&#21407;&#21017;">leftmost
        match</a>, with individual elements matched as follows;<br> &#25110;&#32773;&#35828;&#26368;&#20248;&#21305;&#37197;&#23601;&#26159;&#24403;&#21333;&#20010;&#20803;&#32032;&#22914;&#19979;&#21305;&#37197;&#26102;&#25214;&#21040;&#30340;
        <a class="link" href="leftmost_longest_rule.html" title="The Leftmost Longest Rule &#26368;&#24038;&#26368;&#38271;&#21407;&#21017;">&#26368;&#24038;&#21305;&#37197;</a>&#12290;
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Construct &#32467;&#26500;
              </p>
              </th>
<th>
              <p>
                What gets matched &#34987;&#21305;&#37197;&#30340;
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="literal">AtomA AtomB</code>
              </p>
              </td>
<td>
              <p>
                Locates the best match for <span class="emphasis"><em>AtomA</em></span> that has a
                following match for <span class="emphasis"><em>AtomB</em></span>.<br> &#26368;&#20339;&#21305;&#37197;&#23450;&#20301;&#20110;
                <span class="emphasis"><em>AtomA</em></span> &#21518;&#36319; <span class="emphasis"><em>AtomB</em></span> &#30340;&#21305;&#37197;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">Expression1 | Expression2</code>
              </p>
              </td>
<td>
              <p>
                If <span class="emphasis"><em>Expresion1</em></span> can be matched then returns that
                match, otherwise attempts to match <span class="emphasis"><em>Expression2</em></span>.<br>
                &#22914;&#26524; <span class="emphasis"><em>Expresion1</em></span> &#33021;&#22815;&#21305;&#37197;&#23601;&#36820;&#22238;&#36825;&#20010;&#21305;&#37197;&#65292;&#21542;&#21017;&#35797;&#22270;&#21305;&#37197;
                /Expression2/&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">S{N}</code>
              </p>
              </td>
<td>
              <p>
                Matches <span class="emphasis"><em>S</em></span> repeated exactly N times.<br> &#21305;&#37197;/S/&#31934;&#30830;&#37325;&#22797;/N/&#27425;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">S{N,M}</code>
              </p>
              </td>
<td>
              <p>
                Matches S repeated between N and M times, and as many times as possible.<br>
                &#21305;&#37197;/S/&#37325;&#22797;/N/&#21040;/M/&#27425;&#20043;&#38388;&#65292;&#24182;&#23613;&#21487;&#33021;&#22810;&#22320;&#37325;&#22797;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">S{N,M}?</code>
              </p>
              </td>
<td>
              <p>
                Matches S repeated between N and M times, and as few times as possible.<br>
                &#21305;&#37197;/S/&#37325;&#22797;/N/&#21040;/M/&#27425;&#20043;&#38388;&#65292;&#24182;&#23613;&#21487;&#33021;&#23569;&#22320;&#37325;&#22797;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">S?, S*, S+</code>
              </p>
              </td>
<td>
              <p>
                The same as <code class="literal">S{0,1}</code>, <code class="literal">S{0,UINT_MAX}</code>,
                <code class="literal">S{1,UINT_MAX}</code> respectively.<br> &#20998;&#21035;&#31561;&#21516;&#20110;
                <code class="literal">S{0,`}</code>, <code class="literal">S{0,UINT_MAX}</code>, <code class="literal">S{1,UINT_MAX}</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">S??, S*?, S+?</code>
              </p>
              </td>
<td>
              <p>
                The same as <code class="literal">S{0,1}?</code>, <code class="literal">S{0,UINT_MAX}?</code>,
                <code class="literal">S{1,UINT_MAX}?</code> respectively.<br> &#20998;&#21035;&#31561;&#21516;&#20110;
                <code class="literal">S{0,1}?</code>, <code class="literal">S{0,UINT_MAX}?</code>, <code class="literal">S{1,UINT_MAX}?</code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">(?&gt;S)</code>
              </p>
              </td>
<td>
              <p>
                Matches the best match for <span class="emphasis"><em>S</em></span>, and only that.<br>
                &#21305;&#37197;&#19988;&#21482;&#21305;&#37197;/S/&#30340;&#26368;&#20339;&#21305;&#37197;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">(?=S), (?&lt;=S)</code>
              </p>
              </td>
<td>
              <p>
                Matches only the best match for <span class="emphasis"><em>S</em></span> (this is only
                visible if there are capturing parenthesis within <span class="emphasis"><em>S</em></span>).<br>
                &#21482;&#21305;&#37197;/S/&#30340;&#26368;&#20339;&#21305;&#37197;(&#21482;&#26377;&#24403;/S/&#20013;&#26377;&#25429;&#33719;&#29992;&#25324;&#21495;&#26102;&#25165;&#21487;&#35265;)&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">(?!S), (?&lt;!S)</code>
              </p>
              </td>
<td>
              <p>
                Considers only whether a match for S exists or not.<br> &#21482;&#26377;&#24403;/S/&#21305;&#37197;&#25110;&#19981;&#21305;&#37197;&#26102;&#25165;&#32487;&#32493;&#32771;&#34385;&#12290;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="literal">(?(condition)yes-pattern | no-pattern)</code>
              </p>
              </td>
<td>
              <p>
                If condition is true, then only yes-pattern is considered, otherwise
                only no-pattern is considered.<br> &#22914;&#26524;&#26465;&#20214;&#20026;&#30495;&#65292;&#21482;&#26377;
                <span class="emphasis"><em>yes-pattern</em></span> &#34987;&#32771;&#34385;&#65292;&#21542;&#21017;&#21482;&#26377; <span class="emphasis"><em>no-pattern</em></span>
                &#34987;&#32771;&#34385;&#12290;
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.syntax.perl_syntax.variations_______"></a><h4>
<a name="id4873210"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.variations_______">Variations
        &#21464;&#20307;</a>
      </h4>
<p>
        The <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;">options
        <code class="literal">normal</code>, <code class="literal">ECMAScript</code>, <code class="literal">JavaScript</code>
        and <code class="literal">JScript</code></a> are all synonyms for <code class="literal">perl</code>.<br>
        <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;">&#36873;&#39033;
        =normal=&#65292;=ECMAScript=&#65292;<code class="literal">JavaScript</code> &#21644; <code class="literal">JScript</code></a>
        &#37117;&#26159; <code class="literal">perl</code> &#30340;&#21516;&#20041;&#35789;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.options_______"></a><h4>
<a name="id4873301"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.options_______">Options &#36873;&#39033;</a>
      </h4>
<p>
        There are a <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;">variety
        of flags</a> that may be combined with the <code class="literal">perl</code> option
        when constructing the regular expression, in particular note that the <code class="literal">newline_alt</code>
        option alters the syntax, while the <code class="literal">collate</code>, <code class="literal">nosubs</code>
        and <code class="literal">icase</code> options modify how the case and locale sensitivity
        are to be applied.<br> &#26500;&#36896;&#27491;&#21017;&#34920;&#36798;&#24335;&#26102;&#26377; <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;">&#19968;&#31995;&#21015;&#26631;&#31614;</a>
        &#21487;&#20197;&#21644; <code class="literal">perl</code> &#36873;&#39033;&#32452;&#21512;&#20351;&#29992;&#65292; &#23588;&#20854;&#27880;&#24847;&#30340;&#26159;
        <code class="literal">newline_alt</code> &#36873;&#39033;&#26356;&#25913;&#35821;&#27861;&#65292;&#32780; =collate=&#12289;<code class="literal">nosubs</code>
        &#21644; <code class="literal">icase</code> &#36873;&#39033;&#24433;&#21709;&#22823;&#23567;&#20889;&#21644;locale&#25935;&#24863;&#20869;&#23481;&#22914;&#20309;&#34987;&#24212;&#29992;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.pattern_modifiers________________"></a><h4>
<a name="id4873411"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.pattern_modifiers________________">Pattern
        Modifiers &#27169;&#24335;&#20462;&#39280;&#31526;</a>
      </h4>
<p>
        The perl <code class="literal">smix</code> modifiers can either be applied using a
        <code class="literal">(?smix-smix)</code> prefix to the regular expression, or with
        one of the <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;">regex-compile
        time flags <code class="literal">no_mod_m</code>, <code class="literal">mod_x</code>, <code class="literal">mod_s</code>,
        and <code class="literal">no_mod_s</code></a>.<br> perl&#30340; <code class="literal">smix</code>
        &#20462;&#39280;&#31526;&#21487;&#20197;&#36890;&#36807;&#24448;&#27491;&#21017;&#34920;&#36798;&#24335;&#20013;&#28155;&#21152; <code class="literal">(?smix-smix)</code>
        &#21069;&#32512;&#65292;&#25110;&#20351;&#29992; <a class="link" href="../ref/syntax_option_type/syntax_option_type_perl.html" title="Options for Perl Regular Expressions Perl&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#36873;&#39033;">regex&#32534;&#35793;&#26102;&#26631;&#31614;
        n<code class="literal">no_mod_m</code>, <code class="literal">mod_x</code>, <code class="literal">mod_s</code>
        &#21644; <code class="literal">no_mod_s</code></a> &#20043;&#19968;&#12290;
      </p>
<a name="boost_regex.syntax.perl_syntax.references_____________"></a><h4>
<a name="id4873532"></a>
        <a class="link" href="perl_syntax.html#boost_regex.syntax.perl_syntax.references_____________">References
        &#21442;&#32771;&#25163;&#20876;</a>
      </h4>
<p>
        <a href="http://perldoc.perl.org/perlre.html" target="_top">Perl 5.8</a>.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 1998 -2007 John Maddock<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../syntax.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../syntax.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="basic_extended.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

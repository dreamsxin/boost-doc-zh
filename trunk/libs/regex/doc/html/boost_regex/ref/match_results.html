<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>match_results</title><link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_2006-12-17_0120">
<link rel="start" href="../../index.html" title="Boost.Regex">
<link rel="up" href="../ref.html" title="Reference">
<link rel="prev" href="basic_regex.html" title="basic_regex">
<link rel="next" href="sub_match.html" title="sub_match"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="basic_regex.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="sub_match.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_regex.ref.match_results"></a><a href="match_results.html" title="match_results"> match_results</a>
</h3></div></div></div>
<a name="boost_regex.ref.match_results.synopsis"></a><h5>
<a name="id541842"></a>
        <a href="match_results.html#boost_regex.ref.match_results.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">regex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        Regular expressions are different from many simple pattern-matching algorithms
        in that as well as finding an overall match they can also produce sub-expression
        matches: each sub-expression being delimited in the pattern by a pair of
        parenthesis (...). There has to be some method for reporting sub-expression
        matches back to the user: this is achieved this by defining a class <code class="computeroutput"><span class="identifier">match_results</span></code> that acts as an indexed collection
        of sub-expression matches, each sub-expression match being contained in an
        object of type <a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>.
        <br>
        正则表达式和许多简单的模式匹配算法不同，既能寻找全部的匹配，也能产生子表达式的匹配：在模式中通过一双括号(...)界定的每个子表达式。
        需要有某种方法来向用户报告子表达式的匹配结果：这是通过定义类<code class="computeroutput"><span class="identifier">match_results</span></code>(子表达式匹配的有序集合)来实现的，每个子表达式匹配都包含在一个<a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>类型的对象中。
      </p>
<p>
        Template class <code class="computeroutput"><span class="identifier">match_results</span></code>
        denotes a collection of character sequences representing the result of a
        regular expression match. Objects of type <code class="computeroutput"><span class="identifier">match_results</span></code>
        are passed to the algorithms <a href="regex_match.html" title="regex_match"><code class="computeroutput"><span class="identifier">regex_match</span></code></a> and <a href="regex_search.html" title="regex_search"><code class="computeroutput"><span class="identifier">regex_search</span></code></a>, and are returned by
        the iterator <a href="regex_iterator.html" title="regex_iterator"><code class="computeroutput"><span class="identifier">regex_iterator</span></code></a>. Storage for the
        collection is allocated and freed as necessary by the member functions of
        class <code class="computeroutput"><span class="identifier">match_results</span></code>.
        <br>
        模板类<code class="computeroutput"><span class="identifier">match_results</span></code>表示一个表达正则表达式匹配结果的字符序列的集合。
        <code class="computeroutput"><span class="identifier">match_results</span></code>类的对象被传入到算法<a href="regex_match.html" title="regex_match"><code class="computeroutput"><span class="identifier">regex_match</span></code></a>和<a href="regex_search.html" title="regex_search"><code class="computeroutput"><span class="identifier">regex_search</span></code></a>中，被迭代器<a href="regex_iterator.html" title="regex_iterator"><code class="computeroutput"><span class="identifier">regex_iterator</span></code></a>返回。
        集合的存储空间在需要时由类<code class="computeroutput"><span class="identifier">match_results</span></code>的成员函数申请和释放。
      </p>
<p>
        The template class <code class="computeroutput"><span class="identifier">match_results</span></code>
        conforms to the requirements of a Sequence, as specified in (lib.sequence.reqmts),
        except that only operations defined for const-qualified Sequences are supported.
        <br>
        模板类<code class="computeroutput"><span class="identifier">match_results</span></code>同序列(Sequence)的需求一致，定义于(lib.sequence.reqmts)，除了只支持const序列的操作。
      </p>
<p>
        Class template <code class="computeroutput"><span class="identifier">match_results</span></code>
        is most commonly used as one of the typedefs <code class="computeroutput"><span class="identifier">cmatch</span></code>,
        <code class="computeroutput"><span class="identifier">wcmatch</span></code>, <code class="computeroutput"><span class="identifier">smatch</span></code>,
        or <code class="computeroutput"><span class="identifier">wsmatch</span></code>:
        <br>
        类模板<code class="computeroutput"><span class="identifier">match_results</span></code>最经常使用的是下面的typedef之一，
        <code class="computeroutput"><span class="identifier">cmatch</span></code>、<code class="computeroutput"><span class="identifier">wcmatch</span></code>、<code class="computeroutput"><span class="identifier">smatch</span></code>或<code class="computeroutput"><span class="identifier">wsmatch</span></code>：
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span><br>         <span class="keyword">class</span> <span class="identifier">Allocator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">sub_match</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;</span> <span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">match_results</span><span class="special">;</span><br><br><span class="keyword">typedef</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*&gt;</span>              <span class="identifier">cmatch</span><span class="special">;</span><br><span class="keyword">typedef</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*&gt;</span>           <span class="identifier">wcmatch</span><span class="special">;</span><br><span class="keyword">typedef</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span><span class="special">&gt;</span>   <span class="identifier">smatch</span><span class="special">;</span><br><span class="keyword">typedef</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">wstring</span><span class="special">::</span><span class="identifier">const_iterator</span><span class="special">&gt;</span>  <span class="identifier">wsmatch</span><span class="special">;</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span><br>         <span class="keyword">class</span> <span class="identifier">Allocator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">sub_match</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;</span> <span class="special">&gt;</span><br><span class="keyword">class</span> <span class="identifier">match_results</span><br><span class="special">{</span> <br><span class="keyword">public</span><span class="special">:</span> <br>   <span class="keyword">typedef</span>          <span class="identifier">sub_match</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;</span>                        <span class="identifier">value_type</span><span class="special">;</span><br>   <span class="keyword">typedef</span>          <span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span>                                       <span class="identifier">const_reference</span><span class="special">;</span><br>   <span class="keyword">typedef</span>          <span class="identifier">const_reference</span>                                         <span class="identifier">reference</span><span class="special">;</span><br>   <span class="keyword">typedef</span>          <span class="identifier">implementation</span> <span class="identifier">defined</span>                                  <span class="identifier">const_iterator</span><span class="special">;</span><br>   <span class="keyword">typedef</span>          <span class="identifier">const_iterator</span>                                          <span class="identifier">iterator</span><span class="special">;</span><br>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">iterator_traits</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;::</span><span class="identifier">difference_type</span> <span class="identifier">difference_type</span><span class="special">;</span><br>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">size_type</span>                                    <span class="identifier">size_type</span><span class="special">;</span><br>   <span class="keyword">typedef</span>          <span class="identifier">Allocator</span>                                               <span class="identifier">allocator_type</span><span class="special">;</span><br>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">iterator_traits</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;::</span><span class="identifier">value_type</span>      <span class="identifier">char_type</span><span class="special">;</span><br>   <span class="keyword">typedef</span>          <span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">&gt;</span>                                 <span class="identifier">string_type</span><span class="special">;</span><br><br>   <span class="comment">// construct/copy/destroy:<br></span>   <a class="link" href="match_results.html#boost_regex.match_results.construct">explicit match_results</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Allocator</span><span class="special">&amp;</span> <span class="identifier">a</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">());</span><br>   <a class="link" href="match_results.html#boost_regex.match_results.copy_construct">match_results</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span><br>   <a class="link" href="match_results.html#boost_regex.match_results.assign">match_results&amp; operator=</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span> <br>   <span class="special">~</span><span class="identifier">match_results</span><span class="special">();</span><br><br>   <span class="comment">// size:<br></span>   <span class="identifier">size_type</span> <a class="link" href="match_results.html#boost_regex.match_results.size">size</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">size_type</span> <a class="link" href="match_results.html#boost_regex.match_results.max_size">max_size</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">bool</span> <a class="link" href="match_results.html#boost_regex.match_results.empty">empty</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="comment">// element access:<br></span>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.length">length</a><span class="special">(</span><span class="keyword">int</span> <span class="identifier">sub</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.length">length</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.length">length</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.length">length</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">sub</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.position">position</a><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">sub</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.position">position</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.position">position</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br>   <span class="identifier">difference_type</span> <a class="link" href="match_results.html#boost_regex.match_results.position">position</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">sub</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">string_type</span> <a class="link" href="match_results.html#boost_regex.match_results.str">str</a><span class="special">(</span><span class="keyword">int</span> <span class="identifier">sub</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">string_type</span> <a class="link" href="match_results.html#boost_regex.match_results.str">str</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br>   <span class="identifier">string_type</span> <a class="link" href="match_results.html#boost_regex.match_results.str">str</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br>   <span class="identifier">string_type</span> <a class="link" href="match_results.html#boost_regex.match_results.str">str</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br>   <span class="identifier">string_type</span> <a class="link" href="match_results.html#boost_regex.match_results.str">str</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">const_reference</span> <a class="link" href="match_results.html#boost_regex.match_results.subscript">operator[]</a><span class="special">(</span><span class="keyword">int</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">const_reference</span> <a class="link" href="match_results.html#boost_regex.match_results.subscript">operator[]</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br>   <span class="identifier">const_reference</span> <a class="link" href="match_results.html#boost_regex.match_results.subscript">operator[]</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br>   <span class="identifier">const_reference</span> <a class="link" href="match_results.html#boost_regex.match_results.subscript">operator[]</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br>   <span class="identifier">const_reference</span> <a class="link" href="match_results.html#boost_regex.match_results.subscript">operator[]</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br><br>   <span class="identifier">const_reference</span> <a class="link" href="match_results.html#boost_regex.match_results.prefix">prefix</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br><br>   <span class="identifier">const_reference</span> <a class="link" href="match_results.html#boost_regex.match_results.suffix">suffix</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">const_iterator</span> <a class="link" href="match_results.html#boost_regex.match_results.begin">begin</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">const_iterator</span> <a class="link" href="match_results.html#boost_regex.match_results.end">end</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="comment">// format:<br></span>   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">OutputIterator</span><span class="special">&gt;</span><br>   <span class="identifier">OutputIterator</span> <a class="link" href="match_results.html#boost_regex.match_results.format">format</a><span class="special">(</span><span class="identifier">OutputIterator</span> <span class="identifier">out</span><span class="special">,</span><br>                        <span class="keyword">const</span> <span class="identifier">string_type</span><span class="special">&amp;</span> <span class="identifier">fmt</span><span class="special">,</span><br>                        <span class="identifier">match_flag_type</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="identifier">string_type</span> <a class="link" href="match_results.html#boost_regex.match_results.format2">format</a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">string_type</span><span class="special">&amp;</span> <span class="identifier">fmt</span><span class="special">,</span><br>                     <span class="identifier">match_flag_type</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br><br>   <span class="identifier">allocator_type</span> <a class="link" href="match_results.html#boost_regex.match_results.get_allocator">get_allocator</a><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br>   <span class="keyword">void</span> <a class="link" href="match_results.html#boost_regex.match_results.swap">swap</a><span class="special">(</span><span class="identifier">match_results</span><span class="special">&amp;</span> <span class="identifier">that</span><span class="special">);</span><br><br><span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_REGEX_MATCH_EXTRA</span><br>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">value_type</span><span class="special">::</span><span class="identifier">capture_sequence_type</span> <span class="identifier">capture_sequence_type</span><span class="special">;</span><br>   <span class="keyword">const</span> <span class="identifier">capture_sequence_type</span><span class="special">&amp;</span> <a class="link" href="match_results.html#boost_regex.match_results.captures">captures</a><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="preprocessor">#endif</span><br><br><span class="special">};</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="keyword">bool</span> <a class="link" href="match_results.html#boost_regex.match_results.op_eq">operator ==</a> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m1</span><span class="special">,</span><br>                  <span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m2</span><span class="special">);</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="keyword">bool</span> <a class="link" href="match_results.html#boost_regex.match_results.op_ne">operator !=</a> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m1</span><span class="special">,</span><br>                  <span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m2</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="identifier">basic_ostream</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">traits</span><span class="special">&gt;&amp;</span><br>   <a class="link" href="match_results.html#boost_regex.match_results.op_stream">operator &lt;&lt;</a> <span class="special">(</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">traits</span><span class="special">&gt;&amp;</span> <span class="identifier">os</span><span class="special">,</span><br>               <span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m</span><span class="special">);</span><br><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span><br><span class="keyword">void</span> <a class="link" href="match_results.html#boost_regex.match_results.op_swap">swap</a><span class="special">(</span><span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m1</span><span class="special">,</span><br>         <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m2</span><span class="special">);</span><span class="special"></span>
</pre>
<a name="boost_regex.ref.match_results.description"></a><h5>
<a name="id544746"></a>
        <a href="match_results.html#boost_regex.ref.match_results.description">Description</a>
      </h5>
<p>
        In all <code class="computeroutput"><span class="identifier">match_results</span></code> constructors,
        a copy of the Allocator argument is used for any memory allocation performed
        by the constructor or member functions during the lifetime of the object.
        <br>
        在<code class="computeroutput"><span class="identifier">match_results</span></code>的所有构造函数中，
        Allocator参数的拷贝应用于对象生命周期中构造或成员函数需要的内存分配。
      </p>
<a name="boost_regex.match_results.construct"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">match_results</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Allocator</span><span class="special">&amp;</span> <span class="identifier">a</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">());</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Constructs an object of class
        <code class="computeroutput"><span class="identifier">match_results</span></code>. The postconditions
        of this function are indicated in the table:
      </p>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
              <p>
                Element
              </p>
              </th>
<th>
              <p>
                Value
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                empty()
              </p>
              </td>
<td>
              <p>
                true
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                size()
              </p>
              </td>
<td>
              <p>
                0
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                str()
              </p>
              </td>
<td>
              <p>
                basic_string&lt;charT&gt;()
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.match_results.copy_construct"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">match_results</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Constructs an object of class match_results,
        as a copy of m.
      </p>
<a name="boost_regex.match_results.assign"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">match_results</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Assigns m to *this. The postconditions
        of this function are indicated in the table:
      </p>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
              <p>
                Element
              </p>
              </th>
<th>
              <p>
                Value
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                empty()
              </p>
              </td>
<td>
              <p>
                m.empty().
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                size()
              </p>
              </td>
<td>
              <p>
                m.size().
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                str(n)
              </p>
              </td>
<td>
              <p>
                m.str(n) for all integers n &lt; m.size().
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                prefix()
              </p>
              </td>
<td>
              <p>
                m.prefix().
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                suffix()
              </p>
              </td>
<td>
              <p>
                m.suffix().
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                (*this)[n]
              </p>
              </td>
<td>
              <p>
                m[n] for all integers n &lt; m.size().
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                length(n)
              </p>
              </td>
<td>
              <p>
                m.length(n) for all integers n &lt; m.size().
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                position(n)
              </p>
              </td>
<td>
              <p>
                m.position(n) for all integers n &lt; m.size().
              </p>
              </td>
</tr>
</tbody>
</table></div>
<a name="boost_regex.match_results.size"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">size_type</span> <span class="identifier">size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns the number of <a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a> elements stored in *this;
        that is the number of marked sub-expressions in the regular expression that
        was matched plus one.
        <br>
        <span class="bold"><strong>效果</strong></span>：返回*this中夏令的<a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>元素的数量；
        等于正则表达式中标记子表达式的数量加上1。
      </p>
<a name="boost_regex.match_results.max_size"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">size_type</span> <span class="identifier">max_size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns the maximum number of
        <a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>
        elements that can be stored in *this.
      </p>
<a name="boost_regex.match_results.empty"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns size() == 0.</p><a name="boost_regex.match_results.length"></a>
<p></p><pre class="programlisting"><span class="identifier">difference_type</span> <span class="identifier">length</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">sub</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="identifier">difference_type</span> <span class="identifier">length</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br><span class="identifier">difference_type</span> <span class="identifier">length</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br><span class="identifier">difference_type</span> <span class="identifier">length</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;)</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns the length of 
sub-expression <span class="emphasis"><em>sub</em></span>, that is to say: <code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">sub</span><span class="special">].</span><span class="identifier">length</span><span class="special">()</span></code>. </p>
<p>The overloads that accept a string refer to a named sub-expression <span class="emphasis"><em>n</em></span>. In the event that there is no such named 
sub-expression then returns an empty string. </p>
<p>The template overloads of this function, allow the string and/or character 
type to be different from the character type of the underlying sequence and/or 
regular expression: in this case the characters will be widened to the 
underlying character type of the original regular expression. A compiler error 
will occur if the argument passes a wider character type than the underlying 
sequence. These overloads allow a normal narrow character C string literal to be 
used as an argument, even when the underlying character type of the expression 
being matched may be something more exotic such as a Unicode character type.
</p><p></p><a name="boost_regex.match_results.position"></a>
<p></p><pre class="programlisting"><span class="identifier">difference_type</span> <span class="identifier">position</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">sub</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="identifier">difference_type</span> <span class="identifier">position</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br><span class="identifier">difference_type</span> <span class="identifier">position</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br><span class="identifier">difference_type</span> <span class="identifier">position</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;)</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns the starting 
location of sub-expression <span class="emphasis"><em>sub</em></span>, or -1 if 
<span class="emphasis"><em>sub</em></span> was not matched. Note that if this 
represents a partial match , then <code class="computeroutput"><span class="identifier">position</span><span class="special">()</span></code> will return 
the location of the partial match even though <code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">0</span><span class="special">].</span><span class="identifier">matched</span></code> is false.<br>
        <span class="bold"><strong>效果</strong></span>：返回子表达式<span class="emphasis"><em>sub</em></span>的开始位置，如果没有匹配则返回-1。
        注意，如果这表示一个部分匹配，即使<code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">0</span><span class="special">].</span><span class="identifier">matched</span></code>值为false，<code class="computeroutput"><span class="identifier">position</span><span class="special">()</span></code>也会返回部分匹配的位置。 
</p>
<p>The overloads that accept a string refer to a named sub-expression <span class="emphasis"><em>n</em></span>. In the event that there is no such named 
sub-expression then returns an empty string. </p>
<p>The template overloads of this function, allow the string and/or character 
type to be different from the character type of the underlying sequence and/or 
regular expression: in this case the characters will be widened to the 
underlying character type of the original regular expression. A compiler error 
will occur if the argument passes a wider character type than the underlying 
sequence. These overloads allow a normal narrow character C string literal to be 
used as an argument, even when the underlying character type of the expression 
being matched may be something more exotic such as a Unicode character type. 
</p><a name="boost_regex.match_results.str"></a>
<p></p><pre class="programlisting"><span class="identifier">string_type</span> <span class="identifier">str</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">sub</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="identifier">string_type</span> <span class="identifier">str</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br><span class="identifier">string_type</span> <span class="identifier">str</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br><span class="identifier">string_type</span> <span class="identifier">str</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br><span class="identifier">string_type</span> <span class="identifier">str</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">sub</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns sub-expression 
<span class="emphasis"><em>sub</em></span> as a string: <code class="computeroutput"><span class="identifier">string_type</span><span class="special">((*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">sub</span><span class="special">])</span></code>.<br>
        <span class="bold"><strong>效果</strong></span>：将子表达式<span class="emphasis"><em>sub</em></span>作为字符串返回：<code class="computeroutput"><span class="identifier">string_type</span><span class="special">((*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">sub</span><span class="special">])</span></code>。 </p>
<p>The overloads that accept a string, return the string that matched the named 
sub-expression <span class="emphasis"><em>n</em></span>. In the event that there 
is no such named sub-expression then returns an empty string. </p>
<p>The template overloads of this function, allow the string and/or character 
type to be different from the character type of the underlying sequence and/or 
regular expression: in this case the characters will be widened to the 
underlying character type of the original regular expression. A compiler error 
will occur if the argument passes a wider character type than the underlying 
sequence. These overloads allow a normal narrow character C string literal to be 
used as an argument, even when the underlying character type of the expression 
being matched may be something more exotic such as a Unicode character type. 
</p><a name="boost_regex.match_results.subscript"></a>
<p></p><pre class="programlisting"><span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="keyword">int</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br><span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="keyword">const</span> <span class="identifier">char_type</span><span class="special">*</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br><span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">&gt;</span><br><span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">A</span><span class="special">&gt;</span><br><span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reference to the 
<a class="link" title="sub_match" href="sub_match.html"><code class="computeroutput"><span class="identifier">sub_match</span></code></a> object 
representing the character sequence that matched marked sub-expression <span class="emphasis"><em>n</em></span>. If <code class="computeroutput"><span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span></code> then returns a reference to a <a class="link" title="sub_match" href="sub_match.html"><code class="computeroutput"><span class="identifier">sub_match</span></code></a> object representing the character 
sequence that matched the whole regular expression. If <span class="emphasis"><em>n</em></span> is out of range, or if <span class="emphasis"><em>n</em></span> is an unmatched sub-expression, then returns a 
<a class="link" title="sub_match" href="sub_match.html"><code class="computeroutput"><span class="identifier">sub_match</span></code></a> object 
whose matched member is false.<br>
        <span class="bold"><strong>效果</strong></span>：返回表示标记子表达式<span class="emphasis"><em>n</em></span>匹配的字符序列的<a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>的对象的引用。
        如果<code class="computeroutput"><span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span></code>，则返回表示匹配整个正则表达式的字符序列的<a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>的对象的引用。
        如果<span class="emphasis"><em>n</em></span>越界，或者<span class="emphasis"><em>n</em></span>是一个未匹配的子表达式，则返回一个<a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>对象，其matched成员是false。 </p>
<p>The overloads that accept a string, return a reference to the <a class="link" title="sub_match" href="sub_match.html"><code class="computeroutput"><span class="identifier">sub_match</span></code></a> object representing the character 
sequence that matched the named sub-expression <span class="emphasis"><em>n</em></span>. In the event that there is no such named 
sub-expression then returns a <a class="link" title="sub_match" href="sub_match.html"><code class="computeroutput"><span class="identifier">sub_match</span></code></a> object whose matched member is 
false. </p>
<p>The template overloads of this function, allow the string and/or character 
type to be different from the character type of the underlying sequence and/or 
regular expression: in this case the characters will be widened to the 
underlying character type of the original regular expression. A compiler error 
will occur if the argument passes a wider character type than the underlying 
sequence. These overloads allow a normal narrow character C string literal to be 
used as an argument, even when the underlying character type of the expression 
being matched may be something more exotic such as a Unicode character type.</p><a name="boost_regex.match_results.prefix"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">const_reference</span> <span class="identifier">prefix</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns a reference to the <a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>
        object representing the character sequence from the start of the string being
        matched or searched, to the start of the match found.
        <br>
        <span class="bold"><strong>效果</strong></span>：返回一个<a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>对象的引用，这个对象表示从要进行匹配或搜索的字符串的开始，到匹配的开始之间的字符序列。
      </p>
<a name="boost_regex.match_results.suffix"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">const_reference</span> <span class="identifier">suffix</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns a reference to the <a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>
        object representing the character sequence from the end of the match found
        to the end of the string being matched or searched.
        <br>
        <span class="bold"><strong>效果</strong></span>：返回一个<a href="sub_match.html" title="sub_match"><code class="computeroutput"><span class="identifier">sub_match</span></code></a>对象的引用，这个对象表示从匹配的结束，到用于匹配或搜索的字符串的结束之间的字符序列。
      </p>
<a name="boost_regex.match_results.begin"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">const_iterator</span> <span class="identifier">begin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns a starting iterator that
        enumerates over all the marked sub-expression matches stored in *this.
        <br>
        <span class="bold"><strong>效果</strong></span>：返回用于遍历*this存储的所有标记子表达式匹配的起始迭代器。
      </p>
<a name="boost_regex.match_results.end"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">const_iterator</span> <span class="identifier">end</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns a terminating iterator
        that enumerates over all the marked sub-expression matches stored in *this.
      </p>
<a name="boost_regex.match_results_format"></a><a name="boost_regex.match_results.format"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">OutputIterator</span><span class="special">&gt;</span>
<span class="identifier">OutputIterator</span> <span class="identifier">format</span><span class="special">(</span><span class="identifier">OutputIterator</span> <span class="identifier">out</span><span class="special">,</span>
                     <span class="keyword">const</span> <span class="identifier">string_type</span><span class="special">&amp;</span> <span class="identifier">fmt</span><span class="special">,</span>
                     <span class="identifier">match_flag_type</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Requires</strong></span>: The type <code class="computeroutput"><span class="identifier">OutputIterator</span></code>
        conforms to the Output Iterator requirements (C++ std 24.1.2).
      </p>
<p>
        <span class="bold"><strong>Effects</strong></span>: Copies the character sequence
        <code class="computeroutput"><span class="special">[</span><span class="identifier">fmt</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">fmt</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span></code>
        to <code class="computeroutput"><span class="identifier">OutputIterator</span></code> <span class="emphasis"><em>out</em></span>.
        For each format specifier or escape sequence in <span class="emphasis"><em>fmt</em></span>,
        replace that sequence with either the character(s) it represents, or the
        sequence of characters within <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> to which it refers. The bitmasks specified
        in flags determines what format specifiers or escape sequences are recognized,
        by default this is the format used by ECMA-262, ECMAScript Language Specification,
        Chapter 15 part 5.4.11 String.prototype.replace.
        <br>
        <span class="bold"><strong>效果</strong></span>：将字符序列<code class="computeroutput"><span class="special">[</span><span class="identifier">fmt</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">fmt</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span></code>拷贝到<code class="computeroutput"><span class="identifier">OutputIterator</span></code> <span class="emphasis"><em>out</em></span>。
        对于<span class="emphasis"><em>fmt</em></span>中每个格式说明(format specifier)或转义序列，用它表示的字符(串)，或它指向的<code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>中的字符序列来替换它。
        flags中指明的位掩码决定了哪些格式说明和转义序列被识别，
        默认是被ECMA-262、ECMAScript Language Specification、第15章part 5.4.11 String.prototype.replace中使用的格式。
      </p>
<p>
        See the <a href="../format.html" title="Search and Replace Format String Syntax">format syntax guide for more information</a>.
      </p>
<p>
        <span class="bold"><strong>Returns</strong></span>: out.
      </p>
<a name="boost_regex.match_results.format2"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">string_type</span> <span class="identifier">format</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">string_type</span><span class="special">&amp;</span> <span class="identifier">fmt</span><span class="special">,</span>
                  <span class="identifier">match_flag_type</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">format_default</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns a copy of the string <span class="emphasis"><em>fmt</em></span>.
        For each format specifier or escape sequence in <span class="emphasis"><em>fmt</em></span>,
        replace that sequence with either the character(s) it represents, or the
        sequence of characters within <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> to which it refers. The bitmasks specified
        in flags determines what format specifiers or escape sequences are recognized,
        by default this is the format used by ECMA-262, ECMAScript Language Specification,
        Chapter 15 part 5.4.11 String.prototype.replace.
      </p>
<p>
        See the <a href="../format.html" title="Search and Replace Format String Syntax">format syntax guide for more information</a>.
      </p>
<a name="boost_regex.match_results.get_allocator"></a><p>
      </p>
<pre class="programlisting"><span class="identifier">allocator_type</span> <span class="identifier">get_allocator</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Returns a copy of the Allocator
        that was passed to the object's constructor.
      </p>
<a name="boost_regex.match_results.swap"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">match_results</span><span class="special">&amp;</span> <span class="identifier">that</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Swaps the contents of the two sequences.
      </p>
<p>
        <span class="bold"><strong>Postcondition</strong></span>: *this contains the sequence
        of matched sub-expressions that were in that, that contains the sequence
        of matched sub-expressions that were in *this.
      </p>
<p>
        <span class="bold"><strong>Complexity</strong></span>: constant time.
      </p>
<a name="boost_regex.match_results.capture_type"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">value_type</span><span class="special">::</span><span class="identifier">capture_sequence_type</span> <span class="identifier">capture_sequence_type</span><span class="special">;</span>
</pre>
<p>
        Defines an implementation-specific type that satisfies the requirements of
        a standard library Sequence (21.1.1 including the optional Table 68 operations),
        whose value_type is a <code class="computeroutput"><span class="identifier">sub_match</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;</span></code>. This type happens to be <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">sub_match</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>,
        but you shouldn't actually rely on that.
        <br>
        定义一个实现决定的满足标准库序列(Sequence)需求(21.1.1 包括可选表的68个操作 including the optional Table 68 operations)的类型，
        其中value_type是<code class="computeroutput"><span class="identifier">sub_match</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;</span></code>。
        这个类型可能是<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">sub_match</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>，但你不能依赖于这个。
      </p>
<a name="boost_regex.match_results.captures"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">capture_sequence_type</span><span class="special">&amp;</span> <span class="identifier">captures</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <br></pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: returns a sequence containing all
        the captures obtained for sub-expression i.
        <br>
        <span class="bold"><strong>效果</strong></span>：返回包含子表达式i的所有捕捉的序列。
      </p>
<p>
        <span class="bold"><strong>Returns</strong></span>: <code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">i</span><span class="special">].</span><span class="identifier">captures</span><span class="special">();</span></code>
      </p>
<p>
        <span class="bold"><strong>Preconditions</strong></span>: the library must be built
        and used with BOOST_REGEX_MATCH_EXTRA defined, and you must pass the flag
        match_extra to the regex matching functions ( <a href="regex_match.html" title="regex_match"><code class="computeroutput"><span class="identifier">regex_match</span></code></a>, <a href="regex_search.html" title="regex_search"><code class="computeroutput"><span class="identifier">regex_search</span></code></a>, <a href="regex_iterator.html" title="regex_iterator"><code class="computeroutput"><span class="identifier">regex_iterator</span></code></a> or <a href="regex_token_iterator.html" title="regex_token_iterator"><code class="computeroutput"><span class="identifier">regex_token_iterator</span></code></a>) in order for
        this member function to be defined and return useful information.
        <br>
        <span class="bold"><strong>前置条件</strong></span>：库必须用BOOST_REGEX_MATCH_EXTRA编译生成，同时必须将标签match_extra传入正则表达式匹配函数中(<a href="regex_match.html" title="regex_match"><code class="computeroutput"><span class="identifier">regex_match</span></code></a>、<a href="regex_search.html" title="regex_search"><code class="computeroutput"><span class="identifier">regex_search</span></code></a>、<a href="regex_iterator.html" title="regex_iterator"><code class="computeroutput"><span class="identifier">regex_iterator</span></code></a>或<a href="regex_token_iterator.html" title="regex_token_iterator"><code class="computeroutput"><span class="identifier">regex_token_iterator</span></code></a>)，
        这样这个成员函数才被定义并且返回有意义的信息。
      </p>
<p>
        <span class="bold"><strong>Rationale</strong></span>: Enabling this feature has several
        consequences:
        <br>
        <span class="bold"><strong>解释</strong></span>：打开这个特性会有一些后果：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          sub_match occupies more memory resulting in complex expressions running
          out of memory or stack space more quickly during matching.
          <br>
          sub_match占用更多内存，导致在匹配复杂表达式时更容易出现内存或栈空间不足。
        </li>
<li>
          The matching algorithms are less efficient at handling some features (independent
          sub-expressions for example), even when match_extra is not used.
          <br>
          匹配算法在处理某些特性(例如独立子表达式 independent sub-expression)时会比较低效，即使match_extra标签没被设置。
        </li>
<li>
          The matching algorithms are much less efficient (i.e. slower), when match_extra
          is used. Mostly this is down to the extra memory allocations that have
          to take place.
          <br>
          使用match_extra标签时，匹配算法会更加低效(慢)。这主要是由于更多的内存申请发生。
        </li>
</ul></div>
<a name="boost_regex.match_results.op_eq"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">==</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m1</span><span class="special">,</span>
                  <span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m2</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Compares the two sequences for
        equality.
      </p>
<a name="boost_regex.match_results.op_ne"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">!=</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m1</span><span class="special">,</span>
                  <span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m2</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Compares the two sequences for
        inequality.
      </p>
<a name="boost_regex.match_results.op_stream"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">traits</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="identifier">basic_ostream</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">traits</span><span class="special">&gt;&amp;</span>
   <span class="keyword">operator</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">traits</span><span class="special">&gt;&amp;</span> <span class="identifier">os</span><span class="special">,</span>
               <span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Writes the contents of <span class="emphasis"><em>m</em></span>
        to the stream <span class="emphasis"><em>os</em></span> as if by calling <code class="computeroutput"><span class="identifier">os</span>
        <span class="special">&lt;&lt;</span> <span class="identifier">m</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span></code>;
        Returns <span class="emphasis"><em>os</em></span>.
      </p>
<a name="boost_regex.match_results.op_swap"></a><p>
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m1</span><span class="special">,</span>
         <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">&gt;&amp;</span> <span class="identifier">m2</span><span class="special">);</span>
</pre>
<p>
        <span class="bold"><strong>Effects</strong></span>: Swaps the contents of the two sequences.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 1998 -2007 John Maddock<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="basic_regex.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="sub_match.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
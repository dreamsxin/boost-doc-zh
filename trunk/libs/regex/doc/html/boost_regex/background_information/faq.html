<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>FAQ &#24120;&#35265;&#38382;&#39064;</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="Boost.Regex">
<link rel="up" href="../background_information.html" title="Background Information &#32972;&#26223;&#20449;&#24687;">
<link rel="prev" href="futher.html" title="References and Further Information &#21442;&#32771;&#36164;&#26009;&#21450;&#36827;&#19968;&#27493;&#30340;&#20449;&#24687;">
<link rel="next" href="performance.html" title="Performance &#24615;&#33021;">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="futher.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../background_information.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="performance.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_regex.background_information.faq"></a><a class="link" href="faq.html" title="FAQ &#24120;&#35265;&#38382;&#39064;"> FAQ &#24120;&#35265;&#38382;&#39064;</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Q.</strong></span> I can't get regex++ to work with escape
        characters, what's going on?<br> <span class="bold"><strong>Q.</strong></span> &#20026;&#20160;&#20040;&#25105;&#19981;&#33021;&#20351;
        regex++ &#19982;&#36716;&#20041;&#23383;&#31526;&#19968;&#36215;&#24037;&#20316;&#65311;
      </p>
<p>
        <span class="bold"><strong>A.</strong></span> If you embed regular expressions in C++
        code, then remember that escape characters are processed twice: once by the
        C++ compiler, and once by the Boost.Regex expression compiler, so to pass
        the regular expression \d+ to Boost.Regex, you need to embed "\d+"
        in your code. Likewise to match a literal backslash you will need to embed
        "\\" in your code.<br> <span class="bold"><strong>A.</strong></span> &#22914;&#26524;&#20320;&#23558;&#27491;&#21017;&#34920;&#36798;&#24335;&#23884;&#20837;
        C++ &#20195;&#30721;&#20013;&#65292;&#35760;&#24471;&#36716;&#20041;&#23383;&#31526;&#38656;&#35201;&#20889;&#20004;&#36941;&#65306;&#19968;&#27425;&#25552;&#20379;&#32473; C++ &#32534;&#35793;&#22120;&#65292;&#19968;&#27425;&#25552;&#20379;&#32473;
        Boost.Regex &#27491;&#21017;&#34920;&#36798;&#24335;&#32534;&#35793;&#22120;&#65292;&#25152;&#20197;&#24819;&#35201;&#23558;&#27491;&#21017;&#34920;&#36798;&#24335; \d+
        &#20256;&#32473; Boost.Regex&#65292;&#20320;&#38656;&#35201;&#22312;&#20195;&#30721;&#20013;&#23884;&#20837; "\d+"&#12290; &#21516;&#26679;&#22914;&#26524;&#20320;&#35201;&#24819;&#21305;&#37197;&#23383;&#38754;&#30340;&#21453;&#26012;&#26464;&#65292;&#38656;&#35201;&#20889;
        "\\"&#12290;
      </p>
<p>
        <span class="bold"><strong>Q.</strong></span> No matter what I do regex_match always
        returns false, what's going on?<br> <span class="bold"><strong>Q.</strong></span>
        regex_match &#24635;&#36820;&#22238; false&#65292;&#20026;&#20160;&#20040;&#65311;
      </p>
<p>
        <span class="bold"><strong>A.</strong></span> The algorithm regex_match only succeeds
        if the expression matches <span class="bold"><strong>all</strong></span> of the text,
        if you want to <span class="bold"><strong>find</strong></span> a sub-string within
        the text that matches the expression then use regex_search instead.<br>
        <span class="bold"><strong>A.</strong></span> &#31639;&#27861; regex_match &#21482;&#22312;&#34920;&#36798;&#24335;&#21305;&#37197;
        *&#20840;&#37096;* &#25991;&#26412;&#26102;&#25165;&#25104;&#21151;&#65292;&#22914;&#26524;&#20320;&#24819;&#35201;&#22312;&#25991;&#26412;&#20013; *&#23547;&#25214;* &#19968;&#20010;&#21305;&#37197;&#30340;&#23376;&#23383;&#31526;&#20018;&#26102;&#20351;&#29992;
        regex_search&#12290;
      </p>
<p>
        <span class="bold"><strong>Q.</strong></span> Why does using parenthesis in a POSIX
        regular expression change the result of a match?<br> <span class="bold"><strong>Q.</strong></span>
        &#22312; POSIX &#27491;&#21017;&#34920;&#36798;&#24335;&#20013;&#20351;&#29992;&#25324;&#21495;&#20026;&#20160;&#20040;&#20250;&#25913;&#21464;&#21305;&#37197;&#32467;&#26524;&#65311;
      </p>
<p>
        <span class="bold"><strong>A.</strong></span> For POSIX (extended and basic) regular
        expressions, but not for perl regexes, parentheses don't only mark; they
        determine what the best match is as well. When the expression is compiled
        as a POSIX basic or extended regex then Boost.Regex follows the POSIX standard
        leftmost longest rule for determining what matched. So if there is more than
        one possible match after considering the whole expression, it looks next
        at the first sub-expression and then the second sub-expression and so on.
        So...<br> <span class="bold"><strong>A.</strong></span> &#23545;&#20110; POSIX (&#25193;&#23637;&#21644;&#22522;&#26412;)
        &#27491;&#21017;&#34920;&#36798;&#24335;&#65292;&#19981;&#26159; perl &#27491;&#21017;&#34920;&#36798;&#24335;&#65292;&#25324;&#21495;&#24182;&#19981;&#20165;&#20165;&#26631;&#35760;&#65307;&#23427;&#20204;&#21516;&#26102;&#20915;&#23450;&#26368;&#20339;&#21305;&#37197;&#12290;
        &#24403;&#34920;&#36798;&#24335;&#20316;&#20026; POSIX &#22522;&#26412;&#25110;&#25193;&#23637;&#27491;&#21017;&#34920;&#36798;&#24335;&#32534;&#35793;&#26102;&#65292;Boost.Regex
        &#36981;&#24490; POSIX &#26631;&#20934;&#30340;&#26368;&#24038;&#26368;&#38271;&#21407;&#21017;&#20915;&#23450;&#21305;&#37197;&#32467;&#26524;&#12290; &#25152;&#20197;&#22914;&#26524;&#22312;&#32771;&#34385;&#23436;&#25972;&#20010;&#34920;&#36798;&#24335;&#21518;&#26377;&#22810;&#20110;&#19968;&#20010;&#21487;&#33021;&#30340;&#21305;&#37197;&#65292;&#20250;&#20851;&#27880;&#31532;&#19968;&#20010;&#23376;&#34920;&#36798;&#24335;&#65292;&#28982;&#21518;&#31532;&#20108;&#20010;&#65292;&#20381;&#27492;&#31867;&#25512;&#12290;
        &#25152;&#20197;...
      </p>
<p>
        "(0*)([0-9]*)" against "00123" would produce $1 = "00"
        $2 = "123"
      </p>
<p>
        where as<br> &#32780;
      </p>
<p>
        "0*([0-9])*" against "00123" would produce $1 = "00123"
      </p>
<p>
        If you think about it, had $1 only matched the "123", this would
        be "less good" than the match "00123" which is both further
        to the left and longer. If you want $1 to match only the "123"
        part, then you need to use something like:<br> &#32771;&#34385;&#19968;&#19979;&#65292;&#22914;&#26524; $1
        &#21482;&#21305;&#37197; "123"&#65292;&#36825; "&#19981;&#22914;" &#21305;&#37197; "00123"&#65292;&#31163;&#24038;&#36793;&#26356;&#36828;&#65292;&#20063;&#26356;&#38271;&#12290;&#22914;&#26524;&#35201;&#24819;
        $1 &#21482;&#21305;&#37197; "123"&#65292;&#37027;&#20040;&#38656;&#35201;&#20351;&#29992;&#19979;&#38754;&#30340;&#65306;
      </p>
<p>
        "0*([1-9][0-9]*)"
      </p>
<p>
        as the expression.<br> &#36825;&#26679;&#30340;&#34920;&#36798;&#24335;&#12290;
      </p>
<p>
        <span class="bold"><strong>Q.</strong></span> Why don't character ranges work properly
        (POSIX mode only)?<br> <span class="bold"><strong>Q.</strong></span> &#20026;&#20160;&#20040;&#23383;&#31526;&#33539;&#22260;&#24037;&#20316;&#19981;&#27491;&#24120;
        (POSIX &#27169;&#24335;)&#65311;
      </p>
<p>
        <span class="bold"><strong>A.</strong></span> The POSIX standard specifies that character
        range expressions are locale sensitive - so for example the expression [A-Z]
        will match any collating element that collates between 'A' and 'Z'. That
        means that for most locales other than "C" or "POSIX",
        [A-Z] would match the single character 't' for example, which is not what
        most people expect - or at least not what most people have come to expect
        from regular expression engines. For this reason, the default behaviour of
        Boost.Regex (perl mode) is to turn locale sensitive collation off by not
        setting the <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">collate</span></code>
        compile time flag. However if you set a non-default compile time flag - for
        example <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">extended</span></code> or <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">basic</span></code>,
        then locale dependent collation will be enabled, this also applies to the
        POSIX API functions which use either <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">extended</span></code>
        or <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">basic</span></code> internally. [Note - when <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">nocollate</span></code> in effect, the library behaves
        "as if" the LC_COLLATE locale category were always "C",
        regardless of what its actually set to - end note].<br> <span class="bold"><strong>A.</strong></span>
        POSIX &#26631;&#20934;&#35828;&#26126;&#23383;&#31526;&#33539;&#22260;&#34920;&#36798;&#24335;&#26159;&#21306;&#22495;&#25935;&#24863;&#30340; - &#20363;&#22914;&#34920;&#36798;&#24335;
        [A-Z] &#21487;&#20197;&#21305;&#37197;&#20219;&#24847;&#23545;&#24212; 'A' &#21040; 'Z' &#20043;&#38388;&#30340;&#23545;&#29031;&#20803;&#32032;&#12290; &#36825;&#24847;&#21619;&#30528;&#23545;&#20110;&#22823;&#22810;&#25968;&#38750;
        "C" &#38750; "POSIX" &#30340;&#21306;&#22495;&#32780;&#35328;&#65292;[A-Z] &#21487;&#20197;&#21305;&#37197;&#21333;&#23383;&#31526;
        't'&#65292;&#32780;&#19981;&#26159;&#20154;&#20204;&#26399;&#26395;&#30340; - &#33267;&#23569;&#19981;&#26159;&#22823;&#22810;&#25968;&#20154;&#25152;&#26399;&#26395;&#30340;&#12290;
        &#22522;&#20110;&#36825;&#20010;&#21407;&#22240;&#65292;Boost.Regex &#30340;&#40664;&#35748;&#34892;&#20026; (perl &#27169;&#24335;) &#20851;&#38381;&#23545;&#29031;&#30340;&#21306;&#22495;&#25935;&#24863;&#65292;&#19981;&#35774;&#23450;
        regex_constants::collate &#32534;&#35793;&#26102;&#26631;&#31614;&#12290; &#28982;&#32780;&#24403;&#20320;&#35774;&#32622;&#38750;&#40664;&#35748;&#32534;&#35793;&#26102;&#26631;&#31614;
        - &#20363;&#22914; <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">extended</span></code>
        &#25110; <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">basic</span></code>&#65292;&#21306;&#22495;&#30456;&#20851;&#23545;&#29031;&#20250;&#34987;&#24320;&#21551;&#65292;
        &#36825;&#21516;&#26102;&#20250;&#24212;&#29992;&#21040;&#20869;&#37096;&#20351;&#29992; <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">extended</span></code>
        &#25110; <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">basic</span></code> &#30340; POSIX API &#20989;&#25968;&#12290; [Note - &#24403;&#20351;&#29992;
        <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">nocollate</span></code> &#26102;&#65292;&#24211;&#35748;&#20026; LC_COLLATE &#21306;&#22495;&#20998;&#31867;&#24635;&#26159;
        "C"&#65292;&#32780;&#19981;&#31649;&#23454;&#38469;&#20540; - end note]&#12290;
      </p>
<p>
        <span class="bold"><strong>Q.</strong></span> Why are there no throw specifications
        on any of the functions? What exceptions can the library throw?<br> <span class="bold"><strong>Q.</strong></span> &#20989;&#25968;&#20026;&#20160;&#20040;&#27809;&#26377;&#24322;&#24120;&#35268;&#26684;&#22768;&#26126;&#65311;&#24211;&#20250;&#25243;&#20986;&#20160;&#20040;&#24322;&#24120;&#65311;
      </p>
<p>
        <span class="bold"><strong>A.</strong></span> Not all compilers support (or honor)
        throw specifications, others support them but with reduced efficiency. Throw
        specifications may be added at a later date as compilers begin to handle
        this better. The library should throw only three types of exception: [boost::regex_error]
        can be thrown by <a class="link" href="../ref/basic_regex.html" title="basic_regex"><code class="computeroutput"><span class="identifier">basic_regex</span></code></a> when compiling a regular
        expression, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span></code> can be thrown when a call
        to <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">::</span><span class="identifier">imbue</span></code> tries to open a message catalogue
        that doesn't exist, or when a call to <a class="link" href="../ref/regex_search.html" title="regex_search"><code class="computeroutput"><span class="identifier">regex_search</span></code></a> or <a class="link" href="../ref/regex_match.html" title="regex_match"><code class="computeroutput"><span class="identifier">regex_match</span></code></a> results in an "everlasting"
        search, or when a call to <code class="computeroutput"><span class="identifier">RegEx</span><span class="special">::</span><span class="identifier">GrepFiles</span></code>
        or <code class="computeroutput"><span class="identifier">RegEx</span><span class="special">::</span><span class="identifier">FindFiles</span></code> tries to open a file that cannot
        be opened, finally <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> can be thrown by just about any
        of the functions in this library.<br> <span class="bold"><strong>A.</strong></span>
        &#19981;&#26159;&#25152;&#26377;&#32534;&#35793;&#22120;&#37117;&#25903;&#25345; (&#25110;&#25215;&#35748;) &#24322;&#24120;&#35268;&#26684;&#22768;&#26126;&#65292;&#26377;&#19968;&#20123;&#20250;&#25903;&#25345;&#65292;&#20294;&#20250;&#38477;&#20302;&#25928;&#29575;&#12290;
        &#24322;&#24120;&#35268;&#26684;&#22768;&#26126;&#21487;&#33021;&#22312;&#20197;&#21518;&#32534;&#35793;&#22120;&#33021;&#26356;&#22909;&#22788;&#29702;&#30340;&#26102;&#20505;&#21152;&#20837;&#12290;&#24211;&#21482;&#20250;&#25243;&#20986;&#19977;&#31181;&#31867;&#22411;&#30340;&#24322;&#24120;&#65306;
        [boost::regex_error] &#21487;&#33021;&#22312; <a class="link" href="../ref/basic_regex.html" title="basic_regex"><code class="computeroutput"><span class="identifier">basic_regex</span></code></a> &#32534;&#35793;&#34920;&#36798;&#24335;&#26102;&#25243;&#20986;&#65292;<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span></code>
        &#21487;&#33021;&#22312;&#35843;&#29992; <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">::</span><span class="identifier">imbue</span></code>
        &#35797;&#22270;&#25171;&#24320;&#19981;&#23384;&#22312;&#30340;&#20449;&#24687;&#30446;&#24405;&#65292;&#25110;&#35843;&#29992; <a class="link" href="../ref/regex_search.html" title="regex_search"><code class="computeroutput"><span class="identifier">regex_search</span></code></a> &#25110; <a class="link" href="../ref/regex_match.html" title="regex_match"><code class="computeroutput"><span class="identifier">regex_match</span></code></a> &#23548;&#33268; "&#27704;&#36828;&#30340;"
        &#25628;&#32034;&#65292;&#25110;&#35843;&#29992; <code class="computeroutput"><span class="identifier">RegEx</span><span class="special">::</span><span class="identifier">GrepFiles</span></code>
        &#25110; <code class="computeroutput"><span class="identifier">RegEx</span><span class="special">::</span><span class="identifier">FindFiles</span></code> &#35797;&#22270;&#25171;&#24320;&#19981;&#33021;&#25171;&#24320;&#30340;&#25991;&#20214;&#26102;&#25243;&#20986;&#65292;&#26368;&#21518;
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> &#21487;&#33021;&#22312;&#24211;&#30340;&#20219;&#24847;&#20989;&#25968;&#20013;&#25243;&#20986;&#12290;
      </p>
<p>
        <span class="bold"><strong>Q.</strong></span> Why can't I use the "convenience"
        versions of regex_match / regex_search / regex_grep / regex_format / regex_merge?<br>
        <span class="bold"><strong>Q.</strong></span> &#20026;&#20160;&#20040;&#25105;&#19981;&#33021;&#20351;&#29992; regex_match
        / regex_search / regex_format / regex_merge &#30340; "&#31616;&#21270;" &#29256;&#26412;&#65311;
      </p>
<p>
        <span class="bold"><strong>A.</strong></span> These versions may or may not be available
        depending upon the capabilities of your compiler, the rules determining the
        format of these functions are quite complex - and only the versions visible
        to a standard compliant compiler are given in the help. To find out what
        your compiler supports, run &lt;boost/regex.hpp&gt; through your C++ pre-processor,
        and search the output file for the function that you are interested in. Note
        however, that very few current compilers still have problems with these overloaded
        functions.<br> <span class="bold"><strong>A.</strong></span> &#36825;&#20123;&#29256;&#26412;&#26159;&#21542;&#33021;&#29992;&#21462;&#20915;&#20110;&#20320;&#32534;&#35793;&#22120;&#30340;&#33021;&#21147;&#65292;&#35268;&#21017;&#24456;&#22797;&#26434;
        - &#21482;&#26377;&#26631;&#20934;&#20860;&#23481;&#30340;&#32534;&#35793;&#22120;&#21487;&#35265;&#30340;&#29256;&#26412;&#22312;&#24110;&#21161;&#20013;&#32473;&#20986;&#12290; &#35201;&#25214;&#20986;&#32534;&#35793;&#22120;&#25903;&#25345;&#30340;&#29256;&#26412;&#65292;&#29992;
        C++ &#39044;&#22788;&#29702;&#22120;&#36816;&#34892; &lt;boost/regex.hpp&gt;&#65292;&#22312;&#36755;&#20986;&#25991;&#20214;&#20013;&#25628;&#32034;&#20320;&#24863;&#20852;&#36259;&#30340;&#20989;&#25968;&#12290;
        &#27880;&#24847;&#65292;&#29616;&#22312;&#21482;&#26377;&#24456;&#23569;&#30340;&#32534;&#35793;&#22120;&#23545;&#36825;&#20123;&#37325;&#36733;&#20989;&#25968;&#20173;&#19981;&#25903;&#25345;&#12290;
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 1998 -2007 John Maddock<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="futher.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../background_information.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="performance.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

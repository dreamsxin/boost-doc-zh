<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  -->
<title>Boost Graph Library: Adjacency List</title></head>
<body alink="#ff0000" bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b">
<img src="../../../boost.png" alt="C++ Boost" height="86" width="277">

<br clear="">

<h1><a name="sec:adjacency-list-class"></a>
<pre>adjacency_list&lt;OutEdgeList, VertexList, Directed,<br>               VertexProperties, EdgeProperties,<br>               GraphProperties, EdgeList&gt;<br></pre>
</h1>


<p><tt>adjacency_list</tt> 类实现了一个泛型的邻接表图结构。其模板参数提供了许多配置选项，你可以选择一个最符合需要的版本。基本上，<a href="graph_theory_review.html#sec:adjacency-list-representation">adjacency-list</a>
就是一个二维结构，第一维的每个元素表示一个顶点，而每个顶点包含一个一维结构来表示该顶点的边列表。<a href="#fig:adj-list-graph">图 1</a> 示范了一个有向图的邻接表表示法。

</p>
<div align="center"><a name="fig:adj-list-graph"></a><a name="1509"></a>
<table>
<caption align="bottom"><strong>图 1:</strong> 一个有向图的邻接表表示法。</caption>
<tbody><tr><td><img src="./figs/adj-matrix-graph2.gif" height="284" width="386"></td>
<td><img src="./figs/adj-list2.gif" height="122" width="62"></td></tr>
</tbody></table>
</div><p><tt>adjacency_list</tt>&nbsp;类的
<tt>VertexList</tt> 模板参数控制使用哪种容器作为表示出边的两维容器。<tt>OutEdgeList</tt> 模板参数则控制使用哪种容器来表示边列表。<tt>OutEdgeList</tt> 和 <tt>VertexList</tt> 的选择将决定图结构的空间复杂度，也决定了某些图操作的时间复杂度。有关选择及其优缺点在 <a href="./using_adjacency_list.html#sec:choosing-graph-type">选择 <tt>Edgelist</tt> 和 <tt>VertexList</tt></a> 一节中讨论。

</p><p>模板参数 <tt>Directed</tt> 控制该图是有向的还是无向的，或是可同时访问入边和出边的有向图(我们称之为双向的)。双向图需要有向图的两倍空间(每条边)，因为其每条边要同时出现在出边列表和入边列表中。<a href="#fig:undir-adj-list-graph">图 2</a> 示范了一个无向图的邻接表表示法。

</p>
<div align="center"><a name="fig:undir-adj-list-graph"></a><a name="1509"></a>
<table>
<caption align="bottom"><strong>图 2:</strong> 一个无向图的邻接表表示法。</caption>
<tbody><tr><td><img src="./figs/undir-adj-matrix-graph2.gif" height="240" width="260"></td>
<td><img src="./figs/undir-adj-list.gif" height="122" width="62"></td></tr>
</tbody></table>
</div>

<p>有关如何使用 <tt>adjacency_list</tt> 类的教程，请见 <a href="./using_adjacency_list.html">使用
<tt>adjacency_list</tt></a> 一节。

</p><h3>Example 示例</h3>

<p><a href="../example/family-tree-eg.cpp"><tt>examples/family-tree-eg.cpp</tt></a>
中的例子示范了如何表示一个图的家族树。

</p><h3>Template Parameters 模板参数</h3>

<p>
<table border="1">
<tbody><tr>
<th>Parameter</th><th>Description</th><th>Default</th>
</tr>

<tr><td><tt>OutEdgeList</tt></td>
<td>用于表示每个顶点的边列表的容器的选择子。</td>
<td><tt>vecS</tt></td>
</tr>

<tr>
<td><tt>VertexList</tt></td>
<td>用于表示图中顶点列表的容器的选择子。</td>
<td><tt>vecS</tt></td>
</tr>

<tr>
<td><tt>Directed</tt></td>
<td>用于选择该图为有向图、无向图或双向图(同时访问出边和入边)的选择子。选项为 <tt>directedS</tt>, <tt>undirectedS</tt>, 和 <tt>bidirectionalS</tt>.</td>
<td><tt>directedS</tt></td>
</tr>

<tr>
<td><tt>VertexProperties</tt></td>
<td>用于指定内部属性存储。</td>
<td><tt>no_property</tt></td>
</tr>

<tr>
<td><tt>EdgeProperties</tt></td>
<td>用于指定内部属性存储。</td>
<td><tt>no_property</tt></td>
</tr>

<tr>
<td><tt>GraphProperties</tt></td>
<td>用于指定图对象的属性存储。</td>
<td><tt>no_property</tt></td>
</tr>

<tr><td><tt>EdgeList</tt></td>
<td>用于表示图中边列表的容器的选择子。</td>
<td><tt>listS</tt></td>
</tr>

</tbody></table>
</p><h3>Model of 以...为模型</h3>

<p>
<a href="./VertexAndEdgeListGraph.html">点边列表图VertexAndEdgeListGraph</a>,
<a href="./MutablePropertyGraph.html">可变属性图MutablePropertyGraph</a>, <a href="../../utility/CopyConstructible.html">可复制构造CopyConstructible</a>,
<a href="../../utility/Assignable.html">可赋值Assignable</a>, 和 <a href="../../serialization/doc/index.html">可序列化Serializable</a>。


</p><h3>Where Defined 定义于</h3>

<p>
<a href="../../../boost/graph/adjacency_list.hpp"><tt>boost/graph/adjacency_list.hpp</tt></a><br><br>另外，序列化函数位于
<a href="../../../boost/graph/adj_list_serialize.hpp"><tt>boost/graph/adj_list_serialize.hpp</tt></a>.
</p><h2>Vertex and Edge Properties 顶点属性与边属性</h2>

<p>象颜色、距离、权重这样的属性，以及其它用户自定义的属性，可以关联到图的顶点和边上。属性值可以通过由图提供的属性映射来读出或写入。属性映射通过函数 <tt>get(property, g)</tt> 获得。如何使用属性在 <a href="./using_adjacency_list.html#sec:adjacency-list-properties">内部属性Internal
Properties </a>一节中描述。属性映射是实现了在 <a href="../../property_map/doc/property_map.html">属性映射概念 Property Map
Concepts</a> 一节所定义的接口的对象，也可能是 <a href="bundles.html">绑定属性 bundled properties</a>，它具有更为简洁的语法。所有属性值的类型都必须是可复制构造、可赋值和可缺省构造的。从
<tt>adjacency_list</tt> 类获得的属性映射符合 <a href="../../property_map/doc/LvaluePropertyMap.html">左值属性映射 Lvalue Property
Map</a> 概念。如果 <tt>adjacency_list</tt> 是 const 的，则它的属性映射也是常性的，否则是可变的。

</p><p>如果图的 <tt>VertexList</tt> 是 <tt>vecS</tt>，则该图具有一个内建的顶点索引，可以通过 <tt>vertex_index_t</tt> 属性的属性映射来访问。该索引的值位于区间
<tt>[0, num_vertices(g))</tt> 中且连续取值。当从图中移除一个顶点时，其它顶点的索引将被调整，以保持这一特性。在使用这些索引来访问外部属性存储时必须是小心。顶点索引的属性映射是一个 <a href="../../property_map/doc/ReadablePropertyMap.html">可读属性映射Readable
Property Map</a>。

</p><h2>Iterator and Descriptor Stability/Invalidation 迭代器与描述符的稳定性/失效性</h2>在修改一个图的结构(通过增加或删除边)时，必须要留意。根据不同的
<tt>adjacency_list</tt> 类型以及具体的操作，有些指向该图的迭代器或描述符可能会失效。例如，以下代码将导致未定义(坏的)行为：

<pre>  typedef adjacency_list&lt;listS, vecS&gt; Graph; <b>// VertexList=vecS</b>
  Graph G(N);
  <b>// 填充该图...</b>

  <b>// 试图移除所有顶点。错误！</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end;
  for (tie(vi, vi_end) = vertices(G); vi != vi_end; ++vi)
    remove_vertex(*vi, G);

  <b>// 移除所有顶点。仍然是错的！</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end, next;
  tie(vi, vi_end) = vertices(G);
  for (next = vi; vi != vi_end; vi = next) {
    ++next;
    remove_vertex(*vi, G);
  }
</pre>这里错误的原因是，我们调用了
<tt>remove_vertex()</tt>，当该函数用于带 <tt>VertexList=vecS</tt> 的
<tt>adjacency_list</tt>时，会令图中所有迭代器及描述符(如 <tt>vi</tt> 和
<tt>vi_end</tt>)失效，从而导致后续循环出错。

<p>如果我们使用另一种不同的 <tt>adjacency_list</tt>，令
<tt>VertexList=listS</tt>，则在调用 <tt>remove_vertex</tt> 后，除了指向被移除顶点的迭代器外，其它迭代器不会失效。以下代码为示例。

</p><pre>  typedef adjacency_list&lt;listS, listS&gt; Graph; <b>// VertexList=listS</b>
  Graph G(N);
  <b>// 填充该图...</b>

  <b>// 试图移除所有顶点。错误！</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end;
  for (tie(vi, vi_end) = vertices(G); vi != vi_end; ++vi)
    remove_vertex(*vi, G);

  <b>// 移除所有顶点。正确。</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end, next;
  tie(vi, vi_end) = vertices(G);
  for (next = vi; vi != vi_end; vi = next) {
    ++next;
    remove_vertex(*vi, G);
  }
</pre>

<p>这个稳定性问题同样会影响顶点描述符和边描述符。例如，假设你使用了一个顶点描述符的向量来跟踪最短路径树中的父顶点(或前趋)(参见 <a href="../example/dijkstra-example.cpp"><tt>examples/dijkstra-example.cpp</tt></a>)。你通过调用
<tt>dijkstra_shortest_paths()</tt> 创建了这个父顶点向量，然后从图中移除了某个顶点。接着你又试图使用这个父顶点向量，但是由于所有顶点描述符已经失效，所以结果是错误的。

</p><pre>  std::vector&lt;Vertex&gt; parent(num_vertices(G));<br>  std::vector&lt;Vertex&gt; distance(num_vertices(G));<br><br>  dijkstra_shortest_paths(G, s, distance_map(&amp;distance[0]).<br>    predecessor_map(&amp;parent[0]));<br><br>  remove_vertex(s, G); <b>// 坏主意！父顶点向量中的顶点描述符是失效的。</b>

  <b>// 以下代码将产生错误结果</b>
  for(tie(vi, vend) = vertices(G); vi != vend; ++vi)
    std::cout &lt;&lt; p[*vi] &lt;&lt; " is the parent of " &lt;&lt; *vi &lt;&lt; std::endl;
</pre>


<p>注意，这里所讨论的迭代器和描述符失效，只考虑那些不是由操作直接导致的迭代器和描述符失效。例如，执行
<tt>remove_edge(u, v, g)</tt> 总会令 <i>(u,v)</i> 的任何边描述符或指向 <i>(u,v)</i> 的边迭代器失效，不论使用何种 <tt>adjacency_list</tt>。在这个对迭代器和描述符失效的讨论中，我们只关心 <tt>remove_edge(u, v, g)</tt> 对那些指向其它边(非 <i>(u,v)</i>)的描述符和迭代器的影响。

</p><p>一般来说，如果你希望你的顶点描述符和边描述符是稳定的(永不失效)，那么请对
<tt>adjacency_list</tt> 的
<tt>VertexList</tt> 和 <tt>OutEdgeList</tt> 模板参数使用 <tt>listS</tt> 或 <tt>setS</tt>。如果你不关心描述符和迭代器的稳定性，而更关心内存的消耗和图遍历的速度，那么就对
<tt>VertexList</tt> 和/或 <tt>OutEdgeList</tt> 模板参数使用 <tt>vecS</tt>。

</p><p>下表概括了哪些操作将导致描述符和迭代器失效。在该表中，<tt>EL</tt> 是 <tt>OutEdgeList</tt> 的缩写，<tt>VL</tt> 则代表
<tt>VertexList</tt>。类别 <b>Adj Iter</b> 包括了
<tt>out_edge_iterator</tt>, <tt>in_edge_iterator</tt>, 和
<tt>adjacency_iterator</tt> 类型。对于描述符和迭代器失效的更为详细的说明，在各个操作的文档中给出。

</p><p>

<table border="1">
<caption align="bottom"><strong>表:</strong>
    关于描述符和迭代器失效的概括
    </caption>
<tbody><tr>
    <th>Function</th>
    <th>Vertex Desc</th>
    <th>Edge Desc</th>
    <th>Vertex Iter</th>
    <th>Edge Iter</th>
    <th>Adj Iter</th>
</tr>
<tr>
<td>
    <tt>add_edge()</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>EL=vecS &amp;&amp; <br>Directed=directedS</tt></td>
    <td align="center"><tt>EL=vecS</tt></td>
</tr>
<tr>
    <td><tt>remove_edge()<br>remove_edge_if()<br>remove_out_edge_if()<br>
            remove_in_edge_if()<br>clear_vertex()</tt>
    </td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>EL=vecS &amp;&amp; <br>Directed=directedS</tt></td>
    <td align="center"><tt>EL=vecS</tt></td>
</tr>
<tr>
    <td><tt>add_vertex()</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>OK</tt></td>
    <td align="center"><tt>VL=vecS &amp;&amp; <br> Directed=directedS</tt></td>
    <td align="center"><tt>VL=vecS &amp;&amp; <br> Directed=directedS</tt></td>
</tr>
<tr>
    <td><tt>remove_vertex()</tt></td>
    <td align="center"><tt>VL=vecS</tt></td>
    <td align="center"><tt>VL=vecS</tt></td>
    <td align="center"><tt>VL=vecS</tt></td>
    <td align="center"><tt>VL=vecS</tt></td>
    <td align="center"><tt>VL=vecS</tt></td>
</tr>
</tbody></table>

</p><h2>Associated Types 关联类型</h2>

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::vertex_descriptor</tt>
<br>
和 <br>
<tt>adjacency_list_traits&lt;OutEdgeList, VertexList, Directed, EdgeList&gt;::vertex_descriptor</tt>
<br><br>与
<tt>adjacency_list</tt> 相关联的顶点描述符类型。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::edge_descriptor</tt><br>和<br>
<tt>adjacency_list_traits&lt;OutEdgeList, VertexList, Directed, EdgeList&gt;::edge_descriptor</tt>
<br><br>
与 <tt>adjacency_list</tt> 相关联的边描述符类型。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::vertex_iterator</tt>
<br><br>这是 <tt>vertices()</tt> 所返回的迭代器类型。若 <tt>VertexList=vecS</tt> 则 <tt>vertex_iterator</tt> 为
<a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">随机访问迭代器</a>。否则 <tt>vertex_iterator</tt> 为 <a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">双向迭代器</a>。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::edge_iterator</tt>
<br><br>这是 <tt>edges()</tt> 所返回的迭代器类型。<tt>edge_iterator</tt> 为 <a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">双向迭代器</a>。


<hr>


<tt>graph_traits&lt;adjacency_list&gt;::out_edge_iterator</tt>
<br><br>这是 <tt>out_edges()</tt> 所返回的迭代器类型。若 <tt>OutEdgeList=vecS</tt> 则 <tt>out_edge_iterator</tt> 为
<a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">
随机访问迭代器</a>。若 <tt>OutEdgeList=slistS</tt> 则
<tt>out_edge_iterator</tt> 为 <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">
前向迭代器</a>。否则 <tt>out_edge_iterator</tt> 为
<a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">
双向迭代器</a>。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::adjacency_iterator</tt>
<br><br>这是 <tt>adjacent_vertices()</tt> 所返回的迭代器类型。<tt>adjacency_iterator</tt> 为与 <tt>out_edge_iterator</tt> 相同的迭代器概念。
<hr>

<tt>adjacency_list::inv_adjacency_iterator</tt>
<br><br>这是 <tt>inv_adjacent_vertices()</tt> 所返回的迭代器类型。<tt>inv_adjacency_iterator</tt> 为与 <tt>out_edge_iterator</tt> 相同的迭代器概念。
<hr>

<tt>graph_traits&lt;adjacency_list&gt;::directed_category</tt><br>
和<br>
<tt>adjacency_list_traits&lt;OutEdgeList, VertexList, Directed, EdgeList&gt;::directed_category</tt>
<br><br>提供关于该图是有向图(<tt>directed_tag</tt>)或是无向图(<tt>undirected_tag</tt>)的信息。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::edge_parallel_category</tt><br>和<br>
<tt>adjacency_list_traits&lt;OutEdgeList, VertexList, Directed, EdgeList&gt;::edge_parallel_category</tt>
<br><br>用于描述该图类是否允许插入平行边(具有相同源及目标的边)。两个标签分别为 <tt>allow_parallel_edge-_tag</tt> 和
<tt>disallow_parallel_edge_tag</tt>。变体
<tt>setS</tt> 和 <tt>hash_setS</tt> 不允许平行边，而其它则允许平行边。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::vertices_size_type</tt><br>
和<br>
<tt>adjacency_list_traits&lt;OutEdgeList, VertexList, Directed_list, EdgeList&gt;::vertices_size_type</tt><br>
<br>该类型用于处理图中的顶点数量。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::edge_size_type</tt><br>
和<br>
<tt>adjacency_list_traits&lt;OutEdgeList, VertexList, Directed_list, EdgeList&gt;::edge_size_type</tt><br>
<br>
该类型用于处理图中的边数量。

<hr>

<tt>graph_traits&lt;adjacency_list&gt;::degree_size_type</tt>
<br><br>该类型用于处理图中与单个顶点关联的度数。

<hr>

<tt>property_map&lt;adjacency_list, Property&gt;::type</tt><br>
和<br>
<tt>property_map&lt;adjacency_list, Property&gt;::const_type</tt>
<br><br>用于图中顶点属性或边属性的属性映射类型。特定属性由模板参数 <tt>Property</tt> 指定，必须匹配于该图的
<tt>VertexProperties</tt> 或 <tt>EdgeProperties</tt> 中指定的某个属性。

<hr>

<tt>graph_property&lt;adjacency_list, Property&gt;::type</tt>
<br><br>由&nbsp;<tt>Property</tt> 标签所指定的图属性的属性值类型。

<hr>

<tt>adjacency_list::out_edge_list_selector</tt>
<br><br>类型&nbsp;<tt>OutEdgeListS</tt>.

<hr>

<tt>adjacency_list::vertex_list_selector</tt>
<br><br>类型&nbsp;<tt>VertexListS</tt>.

<hr>

<tt>adjacency_list::directed_selector</tt>
<br><br>类型&nbsp;<tt>DirectedS</tt>.

<hr>

<tt>adjacency_list::edge_list_selector</tt>
<br><br>类型&nbsp;<tt>EdgeListS</tt>.

<hr>

<h2>Member Functions 成员函数</h2>

<hr>

<pre>adjacency_list(const&nbsp;GraphProperty&amp;&nbsp;p = GraphProperty())<br></pre>缺省构造函数。创建一个零顶点零边的空图对象。

<hr>

<pre>adjacency_list(const&nbsp;adjacency_list&amp;&nbsp;x)<br></pre>复制构造函数。创建一个新的图，为图
<tt>x</tt> 的拷贝，包括边、顶点和属性。

<hr>

<pre>adjacency_list&amp; operator=(const&nbsp;adjacency_list&amp;&nbsp;x)<br></pre>赋值操作符。令本图成为图
<tt>x</tt> 的拷贝，包括边、顶点和属性。

<hr>

<pre>adjacency_list(vertices_size_type&nbsp;n,<br>               const&nbsp;GraphProperty&amp;&nbsp;p = GraphProperty())<br></pre>创建一个具有 <tt>n</tt> 个顶点和零条边的图对象。

<hr>

<a name="sec:iterator-constructor">
<pre>template &lt;class&nbsp;EdgeIterator&gt;<br>adjacency_list(EdgeIterator&nbsp;first, EdgeIterator&nbsp;last,<br>               vertices_size_type&nbsp;n,<br>               edges_size_type&nbsp;m = 0,<br>               const&nbsp;GraphProperty&amp;&nbsp;p&nbsp;=&nbsp;GraphProperty())<br></pre>
创建一个具有 <tt>n</tt> 个顶点的图对象，并以区间 <tt>[first, last)</tt> 给出的边列表中所指定的为边。<tt>EdgeIterator</tt> 必须为 </a><a href="http://www.sgi.com/tech/stl/InputIterator.html">输入迭代器</a>。<tt>EdgeIterator</tt> 的值类型必须为
<tt>std::pair</tt>，且 pair 中的类型为整数类型。这些整数对应于各顶点，且必须全部位于区间 <tt>[0, n)</tt> 中。


<hr>

<pre>template &lt;class&nbsp;EdgeIterator, class&nbsp;EdgePropertyIterator&gt;<br>adjacency_list(EdgeIterator&nbsp;first, EdgeIterator&nbsp;last,<br>               EdgePropertyIterator&nbsp;ep_iter,<br>               vertices_size_type&nbsp;n,<br>               edges_size_type&nbsp;m = 0,<br>               const&nbsp;GraphProperty&amp;&nbsp;p&nbsp;=&nbsp;GraphProperty())<br></pre>创建一个具有 <tt>n</tt> 个顶点的图对象，并以区间 <tt>[first, last)</tt> 给出的边列表中所指定的为边。<tt>EdgeIterator</tt> <tt>和 EdgePropertyIterator</tt> 必须为 <a href="http://www.sgi.com/tech/stl/InputIterator.html">输入迭代器</a>。<tt>EdgeIterator</tt> 的值类型必须为
<tt>std::pair</tt>，且 pair 中的类型为整数类型。这些整数对应于各顶点，且必须全部位于区间 <tt>[0, n)</tt> 中。<tt>ep_iter</tt> 的 <tt>value_type</tt> 应为 <tt>EdgeProperties</tt>。

<hr>

<pre>void clear()<br></pre>从图中移除所有边和顶点。

<hr>

<pre>void swap(adjacency_list&amp; x)<br></pre>交换本图与图 <tt>x</tt> 的顶点、边和属性。
<hr>

<h2>Non-Member Functions 非成员函数</h2>


<h4>Structure Access 结构访问</h4>

<hr>

<pre>std::pair&lt;vertex_iterator,&nbsp;vertex_iterator&gt;<br>vertices(const adjacency_list&amp; g)<br></pre>返回一个迭代器区间，提供对图
<tt>g</tt> 的顶点集的访问。

<hr>

<pre>std::pair&lt;edge_iterator,&nbsp;edge_iterator&gt;<br>edges(const adjacency_list&amp; g)<br></pre>返回一个迭代器区间，提供对图
<tt>g</tt> 的边集的访问。

<hr>

<pre>std::pair&lt;adjacency_iterator,&nbsp;adjacency_iterator&gt;<br>adjacent_vertices(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回一个迭代器区间，提供对图 <tt>g</tt> 的顶点 <tt>u</tt> 的邻接顶点的访问。例如，如果 <tt>u -&gt; v</tt>
是图中的一条边，则 <tt>v</tt> 将在这个迭代器区间中。

<hr>

<pre>std::pair&lt;inv_adjacency_iterator,&nbsp;inv_adjacency_iterator&gt;<br>inv_adjacent_vertices(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回一个迭代器区间，提供对图
<tt>g</tt> 中那些以 <tt>u</tt> 为邻接的顶点的访问(<tt>inv</tt> 即反向)。例如，如果 <tt>v -&gt; u</tt> 是图中的一条边，则 <tt>v</tt> 将在这个迭代器区间中。该函数仅对双向或无向 <tt>adjacency_list</tt> 有效。

<hr>


<pre>std::pair&lt;out_edge_iterator,&nbsp;out_edge_iterator&gt;<br>out_edges(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回一个迭代器区间，提供对图<tt></tt> <tt>g</tt> 的顶点
<tt>u</tt> 的出边的访问。如果是无向图，则该迭代器区间提供对顶点
<tt>u</tt> 的所有邻接边的访问。对于有向图和无向图的一条出边
<tt>e</tt>，都有 <tt>source(e, g) == u</tt> 且 <tt>target(e, g) == v</tt>，其中 <tt>v</tt> 为邻接于 <tt>u</tt> 的顶点。

<hr>

<pre>std::pair&lt;in_edge_iterator,&nbsp;in_edge_iterator&gt;<br>in_edges(vertex_descriptor&nbsp;v, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回一个迭代器区间，提供对图 <tt>g</tt> 的顶点&nbsp;<tt>v</tt><tt></tt> 的入边的访问。该操作仅当
<tt>bidirectionalS</tt> 被指定为 <tt>Directed</tt>
模板参数时有效。对于一条入边 <tt>e</tt>，<tt>target(e, g) == v</tt> 且 <tt>source(e, g) == u</tt> 对于邻接于 <tt>v</tt> 的顶点 <tt>u</tt> 成立，无论是有向图或无向图。

<hr>

<pre>vertex_descriptor<br>source(edge_descriptor&nbsp;e, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回边 <tt>e</tt> 的源顶点。

<hr>

<pre>vertex_descriptor<br>target(edge_descriptor&nbsp;e, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回边 <tt>e</tt> 的目标顶点。

<hr>

<pre>degree_size_type<br>out_degree(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回顶点 <tt>u</tt> 的出边数量。

<hr>

<pre>degree_size_type<br>in_degree(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回顶点 <tt>u</tt> 的入边数量。该操作仅当 <tt>bidirectionalS</tt> 被指定为 <tt>Directed</tt> 模板参数时有效。

<hr>

<pre>vertices_size_type<br>num_vertices(const adjacency_list&amp; g)<br></pre>返回图 <tt>g</tt> 中的顶点数量。

<hr>

<pre>edges_size_type<br>num_edges(const adjacency_list&amp; g)<br></pre>返回图 <tt>g</tt> 中的边数量。

<hr>

<pre>vertex_descriptor<br>vertex(vertices_size_type&nbsp;n, const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回图的顶点列表中的第 n 个顶点。

<hr>


<pre>std::pair&lt;edge_descriptor, bool&gt;<br>edge(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,<br>     const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回图 <tt>g</tt> 中连接顶点 <tt>u</tt>&nbsp;和 <tt>v</tt>&nbsp;的一条边。

<hr>

<pre>std::pair&lt;out_edge_iterator, out_edge_iterator&gt;<br>edge_range(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,<br>           const&nbsp;adjacency_list&amp;&nbsp;g)<br></pre>返回一对出边迭代器，给出表示从 <tt>u</tt> 到 <tt>v</tt> 的所有平行边的区间。该函数仅当
<tt>adjacency_list</tt> 的 <tt>OutEdgeList</tt> 是一个根据目标顶点对出边进行排序的容器，且允许平行边时可用。<tt>multisetS</tt> 选择子可指定这样的容器。

<hr>

<h4>Structure Modification 结构改变</h4>

<hr>

<pre>std::pair&lt;edge_descriptor, bool&gt;<br>add_edge(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,<br>         adjacency_list&amp; g)<br></pre>将边 <i>(u,v)</i> 增加至图中，并返回新边的边描述符。对于不允许平行边的图，如果要加入的边已在图中，则不会加入且 <tt>bool</tt> 标志为 <tt>false</tt>。标志为
<tt>false</tt> 时，返回的边描述符指向已存在的边。

<p>新边在出边列表中的位置通常是不确定的，不过通过选择适当的 <tt>OutEdgeList</tt>&nbsp;可以令出边列表有序。如果 <tt>VertexList</tt> 选择子为
<tt>vecS</tt>，且顶点描述符 <tt>u</tt> 或
<tt>v</tt> (为整数)具有大于当前图中顶点数的值，则该图被增大至顶点数为 <tt>std::max(u,v) + 1</tt>。

</p><p>如果 <tt>OutEdgeList</tt> 选择子为 <tt>vecS</tt>，则该操作会令顶点
<i>u</i> 的所有 <tt>out_edge_iterator</tt> 失效。如果 <tt>OutEdgeList</tt> 是一个在调用 <tt>push(container,
x)</tt> 时会令其迭代器失效的用户自定义容器(参见 <a href="using_adjacency_list.html#sec:custom-storage">定制邻接列表存储</a> 一节)，则同样会如此。如果该图是双向的，则<tt></tt> <i>v</i> 的 <tt>in_edge_iterator</tt> 也会失效。如果该图是无向的，则<tt></tt> <i>v</i> 的所有 <tt>out_edge_iterator</tt> 也会失效。如果图是有向的，则 <tt>add_edge()</tt> 也会令所有 <tt>edge_iterator</tt> 失效。


</p><hr>

<pre>std::pair&lt;edge_descriptor,&nbsp;bool&gt;<br>add_edge(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,<br>         const&nbsp;EdgeProperties&amp;&nbsp;p,<br>         adjacency_list&amp;&nbsp;g)<br></pre>将边 <i>(u,v)</i> 增加至图中，并将 <tt>p</tt> 附加为该边的内部属性存储值。具体细节请参见前一个
<tt>add_edge()</tt> 成员函数。

<hr>

<pre>void remove_edge(vertex_descriptor u, vertex_descriptor v,<br>                 adjacency_list&amp; g)<br></pre>从图中删除边 <i>(u,v)</i>。
<p>该操作会令所有指向边 <i>(u,v)</i> 的外部边描述符或迭代器失效。另外，如果 <tt>OutEdgeList</tt> 选择子为 <tt>vecS</tt>，则该操作会令所有指向顶点
<i>u</i> 的边列表的迭代器失效，对于无向图和双向图，则指向顶点 <i>v</i> 的同样会失效。还有，对于有向图，则所有
<tt>edge_iterator</tt> 失效。

</p><hr>

<pre>void remove_edge(edge_descriptor e, adjacency_list&amp; g)<br></pre>从图中删除边 <tt>e</tt>。本函数与
<tt>remove_edge(u, v, g)</tt> 函数的差别在于多重图的情况。<tt>remove_edge(e, g)</tt> 函数只删除一条边，而 <tt>remove_edge(u, v, g)</tt> 函数则删除所有边 <i>(u,v)</i>。
<p>该操作会令指向描述符 <tt>e</tt> 所指的同一条边的所有外部边描述符和迭代器失效。另外，该操作会令指向 <tt>target(e, g)</tt> 的边列表的所有迭代器失效。还有，对于有向图，则所有图的 <tt>edge_iterator</tt> 失效。

</p><hr>

<pre>void remove_edge(out_edge_iterator iter, adjacency_list&amp; g)<br></pre>与 <tt>remove_edge(*iter, g)</tt> 作用相同。差别在于该函数对于有向图具有常量时间复杂度，而 <tt>remove_edge(e, g)</tt>
的时间复杂度为 <i>O(E/V)</i>.

<hr>

<pre>template &lt;class <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>&gt;<br>void remove_out_edge_if(vertex_descriptor u, Predicate predicate,<br>                        adjacency_list&amp; g)<br></pre>从图中删除顶点 <i>u</i> 的所有满足断言的出边。即，如果断言对于某个边描述符返回 true，则该边被删除。
<p>对描述符和迭代器稳定性的影响与对每条被删边调用 <tt>remove_edge()</tt> 一样。

</p><hr>

<pre>template &lt;class <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>&gt;<br>void remove_in_edge_if(vertex_descriptor v, Predicate predicate,<br>                       adjacency_list&amp; g)<br></pre>从图中删除顶点 <i>v</i> 的所有满足断言的入边。即，如果断言对于某个边描述符返回 true，则该边被删除。
<p>对描述符和迭代器稳定性的影响与对每条被删边调用 <tt>remove_edge()</tt> 一样。
</p><p>该操作对无向和双向
<tt>adjacency_list</tt> 图有效，而对有向图无效。

</p><hr>

<pre>template &lt;class <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>&gt;<br>void remove_edge_if(Predicate predicate, adjacency_list&amp; g)<br></pre>从图中删除所有满足断言的边。即，如果断言对于某个边描述符返回 true，则该边被删除。
<p>对描述符和迭代器稳定性的影响与对每条被删边调用 <tt>remove_edge()</tt> 一样。<br></p><hr>

<a name="sec:add-vertex">
<pre>vertex_descriptor<br>add_vertex(adjacency_list&amp; g)<br></pre>
向图中增加一个顶点，并返回新顶点的顶点描述符。
</a>

<hr>

<pre>vertex_descriptor<br>add_vertex(const&nbsp;VertexProperties&amp;&nbsp;p,<br>           adjacency_list&amp; g)<br></pre>向图中增加一个顶点及指定的属性。返回新顶点的顶点描述符。


<hr>

<pre>void clear_vertex(vertex_descriptor u, adjacency_list&amp; g)<br></pre>删除顶点 <i>u</i> 的所有出边和入边。该顶点则仍然保留在图的顶点集中。
<p>对描述符和迭代器稳定性的影响与对以 <tt>u</tt> 作为源或目标的所有边调用 <tt>remove_edge()</tt> 一样。

</p><hr>

<pre>void clear_out_edges(vertex_descriptor u, adjacency_list&amp; g)<br></pre>删除顶点 <i>u</i> 的所有出边。该顶点则仍然保留在图的顶点集中。
<p>对描述符和迭代器稳定性的影响与对以 <tt>u</tt> 作为源的所有边调用 <tt>remove_edge()</tt> 一样。
</p><p>该操作不能应用于无向图(请使用 <tt>clear_vertex()</tt> 代替)。

</p><hr>

<pre>void clear_in_edges(vertex_descriptor u, adjacency_list&amp; g)<br></pre>删除顶点 <i>u</i> 的所有入边。该顶点则仍然保留在图的顶点集中。
<p>对描述符和迭代器稳定性的影响与对以 <tt>u</tt> 作为目标的所有边调用 <tt>remove_edge()</tt> 一样。
</p><p>该操作只能应用于双向图。

</p><hr>

<pre>void remove_vertex(vertex_descriptor u, adjacency_list&amp; g)<br></pre>从图的顶点集中删除顶点 <i>u</i>。它假定顶点 <i>u</i> 在被删除时没有出边和入边。确保此条件的一个方法是，在此之前先调用 <tt>clear_vertex()</tt>。
<p>如果该
<tt>adjacency_list</tt> 的 <tt>VertexList</tt> 模板参数为 <tt>vecS</tt>，则该操作会令图的所有顶点描述符、边描述符和迭代器均失效。各顶点的内建
<tt>vertex_index_t</tt> 属性被重编码，使得在操作后顶点索引仍然形成一个连续的区间
<tt>[0, num_vertices(g))</tt>。如果你使用了基于内建顶点索引的外部属性存储，则该外部存储需要调整。另一个选择是，不要使用内建顶点索引，而是使用一个属性来加入你自己的顶点索引属性。如果你需要频繁使用
<tt>remove_vertex()</tt> 函数，则 <tt>listS</tt> 选择子是 <tt>VertexList</tt> 模板参数的最佳选择。

</p><hr>

<h4><a name="property-map-accessors">Property Map Accessors 属性映射访问</a></h4>

<hr>

<pre>template &lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;<br>property_map&lt;adjacency_list, PropertyTag&gt;::type<br>get(PropertyTag, adjacency_list&amp; g)<br><br>template &lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;<br>property_map&lt;adjacency_list, Tag&gt;::const_type<br>get(PropertyTag, const adjacency_list&amp; g)<br></pre>返回由
<tt>PropertyTag</tt> 指定的顶点属性的属性映射对象。<tt>PropertyTag</tt> 必须与在该图的 <tt>VertexProperty</tt> 模板参数中所指定的某一个属性相匹配。

<hr>

<pre>template &lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X&gt;<br>typename property_traits&lt;property_map&lt;adjacency_list, PropertyTag&gt;::const_type&amp;gt::value_type<br>get(PropertyTag, const adjacency_list&amp; g, X x)<br></pre>返回 <tt>x</tt> 的属性值，其中 <tt>x</tt> 是一个顶点描述符或边描述符。
<hr>

<pre>template &lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X, class Value&gt;<br>void<br>put(PropertyTag, const adjacency_list&amp; g, X x, const Value&amp; value)<br></pre>将 <tt>x</tt> 的属性值设为
<tt>value</tt>。<tt>x</tt> 是一个顶点描述符或边描述符。<tt>Value</tt> 必须可以转换为
<tt>typename property_traits&lt;property_map&lt;adjacency_list, PropertyTag&gt;::type&amp;gt::value_type</tt>

<hr>

<pre>template &lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>typename graph_property&lt;adjacency_list, GraphPropertyTag&gt;::type&amp;<br>get_property(adjacency_list&amp; g, GraphPropertyTag);<br></pre>返回由 <tt>GraphPropertyTag</tt> 所指定的关联至图对象 <tt>g</tt> 的属性。该 <tt>graph_property</tt>
traits 类定义于 <a href="../../../boost/graph/adjacency_list.hpp"><tt>boost/graph/adjacency_list.hpp</tt></a>.

<hr>

<pre>template &lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>const typename graph_property&lt;adjacency_list, GraphPropertyTag&gt;::type&amp;<br>get_property(const adjacency_list&amp; g, GraphPropertyTag);<br></pre>返回由 <tt>GraphPropertyTag</tt> 所指定的关联至图对象 <tt>g</tt> 的属性。该 <tt>graph_property</tt>
traits 类定义于 <a href="../../../boost/graph/adjacency_list.hpp"><tt>boost/graph/adjacency_list.hpp</tt></a>.

<!-- add the shortcut property functions -->

<hr>



<h4><a name="serialization">Serialization 序列化</a></h4>

<hr>

<pre>template&lt;class <a href="../../serialization/doc/archives.html#saving_interface">SavingArchive</a>&gt;<br>SavingArchive&amp; operator&lt;&lt;(SavingArchive&amp; ar, const adjacency_list&amp; graph);<br></pre>将图序列化至存档中。要求图的顶点描述符和边描述符为 <a href="../../serialization/doc/index.html">可序列化Serializable</a>。<br>包含 <a href="../../../boost/graph/adj_list_serialize.hpp"><tt>boost/graph/adj_list_serialize.hpp</tt></a>.
<hr>

<pre>template&lt;class <a href="../../serialization/doc/archives.html#loading_interface">LoadingArchive</a>&gt;<br>LoadingArchive&amp; operator&gt;&gt;(LoadingArchive&amp; ar, const adjacency_list&amp; graph);<br></pre>从存档中读出图。要求图的顶点描述符和边描述符为 <a href="../../serialization/doc/index.html">可序列化Serializable</a>。<br>包含&nbsp;<a href="../../../boost/graph/adj_list_serialize.hpp"><tt>boost/graph/adj_list_serialize.hpp</tt></a>.
<hr>


<h3>See Also 参见</h3>

<a href="./adjacency_list_traits.html"><tt>adjacency_list_traits</tt></a>,
<a href="./property_map.html"><tt>property_map</tt></a>,
<a href="./graph_traits.html"><tt>graph_traits</tt></a>



<br>
<hr>
<table>
<tbody><tr valign="top">
<td nowrap="nowrap">Copyright © 2000-2001</td><td>
<a href="http://www.boost.org/people/jeremy_siek.htm">Jeremy Siek</a>,
Indiana University (<a href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)<br>
<a href="http://www.boost.org/people/liequan_lee.htm">Lie-Quan Lee</a>, Indiana University (<a href="mailto:llee@cs.indiana.edu">llee@cs.indiana.edu</a>)<br>
<a href="http://www.osl.iu.edu/%7Elums">Andrew Lumsdaine</a>,
Indiana University (<a href="mailto:lums@osl.iu.edu">lums@osl.iu.edu</a>)
</td></tr></tbody></table>

<!--  LocalWords:  gif ALT OutEdgeList EdgeList VertexList html VertexProperties EdgeProperties
 -->
<!--  LocalWords:  GraphPropertyTag cpp enum ai cout endl VertexAndEdgeListGraph
 -->
<!--  LocalWords:  MutablePropertyGraph hpp const ReadablePropertyMap listS num
 -->
<!--  LocalWords:  ReadWritePropertyMap vecS dijkstra ucs pre Adj Iter Desc ep
 -->
<!--  LocalWords:  EdgeIterator EdgePropertyIterator iter bool edge's IDs siek
 -->
<!--  LocalWords:  multigraph typename htm Univ Quan Lumsdaine
 -->
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><!--
  -- Copyright (c) 2005 Trustees of Indiana University
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  -->
    

    <title>Compressed Sparse Row Graph</title><style type="text/css">
      <!--
        .indent
        {
          padding-left: 50pt;
          padding-right: 50pt;
        }
       -->
    </style>

<script language="JavaScript" type="text/JavaScript">
<!--
function address(host, user) {
        var atchar = '@';
        var thingy = user+atchar+host;
        thingy = '<a hre' + 'f=' + "mai" + "lto:" + thingy + '>' + user+atchar+host + '</a>';
        document.write(thingy);
}
//-->
</script></head>
<body>
    <img src="../../../boost.png" alt="C++ Boost" height="86" width="277">
    <h1>Compressed Sparse Row Graph&nbsp;稀疏行压缩图</h1>
          
    <p>类模板 <code>compressed_sparse_row_graph</code> 是一个使用压缩的稀疏行(CSR)格式来存储有向图的图类。
   虽然CSR图比其它的图格式(如 <a href="adjacency_list.html"><code>adjacency_list</code></a>)具有小得多的开销，但是它们不提供任何可变性：你不能向一个CSR图增加或删除顶点或边。应在高性能应用中或对于那些你不会修改的图使用这一格式。</p>
        
    <p>CSR格式将顶点和边保存在不同的数组中，分别按顶点或边的标识符来对这些数组进行索引。边数组按各边的源顶点排序，但只保存边的目标顶点。顶点数组则保存各个顶点的第一条出边在边数组中的偏移量。对图中第 <i>i</i><sup>th</sup>
    个顶点的出边的迭代，可以通过访问 <tt>edge_array[vertex_array[i]]</tt>, <tt>edge_array[vertex_array[i]+1]</tt>,
    ..., <tt>edge_array[vertex_array[i+1]]</tt> 来实现。这种格式的最小内存用量为 <i>O(n + m)</i>，其中 <i>n</i> 和 <i>m</i> 分别为顶点和边的数量。<i>n</i> 和 <i>m</i> 的常倍数分别基于用于表示边数组和顶点数组中的索引的整数大小，它们可以用 <a href="#template-parms">模板参数</a> 来控制。</p>

    <ul>
      <li><a href="#synopsis">Synopsis 摘要</a></li>
      <li><a href="#where">Where Defined 定义于</a></li>
      <li><a href="#models">Models 模型</a></li>
      <li><a href="#template-parms">Template parameters 模板参数</a></li>
      <li><a href="#properties">Properties 属性</a></li>
      <li><a href="#member-functions">Member functions 成员函数</a>
        <ul>
          <li><a href="#constructors">Constructors 构造函数</a></li>
          <li><a href="#mutators">Mutators 可变函数</a></li>
          <li><a href="#property-access">Property access 属性访问</a></li>
        </ul></li>

      <li><a href="#non-members">Non-member functions 非成员函数</a>
        <ul>
          <li><a href="#vertex-access">Vertex access 顶点访问</a></li>
          <li><a href="#edge-access">Edge access 边访问</a></li>
          <li><a href="#property-map-accessors">Property map accessors 属性映射访问</a></li>
          <li><a href="#incremental-construction-functions">Incremental construction functions 递增构造函数</a></li>
        </ul></li>

      <li><a href="#example">Example 示例</a></li>
    </ul>

    <a name="synopsis"></a><h2>Synopsis 摘要</h2>

    <pre>namespace boost {<br><br>template&lt;typename <a href="#Directed">Directed</a> = directedS, typename <a href="#VertexProperty">VertexProperty</a> = void, <br>         typename <a href="#EdgeProperty">EdgeProperty</a> = void, typename <a href="#GraphProperty">GraphProperty</a> = no_property, <br>         typename <a href="#Vertex">Vertex</a> = std::size_t, typename <a href="#EdgeIndex">EdgeIndex</a> = Vertex&gt;<br>class compressed_sparse_row_graph<br>{<br>public:<br>  <i>// <a href="#constructors">Graph constructors</a></i>
  <a href="#default-const">compressed_sparse_row_graph</a>();<br><br>  template&lt;typename InputIterator&gt;<br>  <a href="#edge-const">compressed_sparse_row_graph</a>(InputIterator edge_begin, InputIterator edge_end,<br>                              vertices_size_type numverts,<br>                              edges_size_type numedges = 0,<br>                              const GraphProperty&amp; prop = GraphProperty());<br><br>  template&lt;typename InputIterator, typename EdgePropertyIterator&gt;<br>  <a href="#edge-prop-const">compressed_sparse_row_graph</a>(InputIterator edge_begin, InputIterator edge_end,<br>                              EdgePropertyIterator ep_iter,<br>                              vertices_size_type numverts,<br>                              edges_size_type numedges = 0,<br>                              const GraphProperty&amp; prop = GraphProperty());<br><br>  template&lt;typename Graph, typename VertexIndexMap&gt;<br>  <a href="#graph-const">compressed_sparse_row_graph</a>(const Graph&amp; g, const VertexIndexMap&amp; vi,<br>                              vertices_size_type numverts,<br>                              edges_size_type numedges); <br><br>  template&lt;typename Graph, typename VertexIndexMap&gt;<br>  compressed_sparse_row_graph(const Graph&amp; g, const VertexIndexMap&amp; vi);<br><br>  template&lt;typename Graph&gt;<br>  explicit <a href="#graph-const">compressed_sparse_row_graph</a>(const Graph&amp; g);<br><br>  <i>// <a href="#mutators">Graph mutators</a></i>
  template&lt;typename Graph, typename VertexIndexMap&gt;
  void <a href="#assign">assign</a>(const Graph&amp; g, const VertexIndexMap&amp; vi,<br>              vertices_size_type numverts, edges_size_type numedges);<br><br>  template&lt;typename Graph, typename VertexIndexMap&gt;<br>  void <a href="#assign">assign</a>(const Graph&amp; g, const VertexIndexMap&amp; vi);<br><br>  template&lt;typename Graph&gt;<br>  void <a href="#assign">assign</a>(const Graph&amp; g);<br><br>  <i>// <a href="#property-access">Property Access</a></i>
  VertexProperty&amp; <a href="#vertex-subscript">operator[]</a>(vertex_descriptor v);<br>  const VertexProperty&amp; <a href="#vertex-subscript">operator[]</a>(vertex_descriptor v) const;<br>  EdgeProperty&amp; <a href="#edge-subscript">operator[]</a>(edge_descriptor v);<br>  const EdgeProperty&amp; <a href="#edge-subscript">operator[]</a>(edge_descriptor v) const;<br>};<br><br><i>// <a href="IncidenceGraph.html">Incidence Graph requirements</a></i>
vertex_descriptor source(edge_descriptor, const compressed_sparse_row_graph&amp;);
vertex_descriptor target(edge_descriptor, const compressed_sparse_row_graph&amp;);
std::pair&lt;out_edge_iterator, out_edge_iterator&gt; 
  out_edges(vertex_descriptor, const compressed_sparse_row_graph&amp;);
degree_size_type out_degree(vertex_descriptor v, const compressed_sparse_row_graph&amp;);

<i>// <a href="AdjacencyGraph.html">Adjacency Graph requirements</a></i>
std::pair&lt;adjacency_iterator, adjacency_iterator&gt; 
  adjacent_vertices(vertex_descriptor, const compressed_sparse_row_graph&amp;);

<i>// <a href="VertexListGraph.html">Vertex List Graph requirements</a></i>
std::pair&lt;vertex_iterator, vertex_iterator&gt; vertices(const compressed_sparse_row_graph&amp;);
vertices_size_type num_vertices(const compressed_sparse_row_graph&amp;);

<i>// <a href="EdgeListGraph.html">Edge List Graph requirements</a></i>
std::pair&lt;edge_iterator, edge_iterator&gt; edges(const compressed_sparse_row_graph&amp;);
edges_size_type num_edges(const compressed_sparse_row_graph&amp;);

<i>// <a href="#vertex-access">Vertex access</a></i>
vertex_descriptor <a href="#vertex">vertex</a>(vertices_size_type i, const compressed_sparse_row_graph&amp;);<br><br><i>// <a href="#edge-access">Edge access</a></i>
std::pair&lt;out_edge_iterator, out_edge_iterator&gt; 
  <a href="#edge_range">edge_range</a>(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);<br>std::pair&lt;edge_descriptor, bool&gt; <br>  <a href="#edge">edge</a>(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);<br>edge_descriptor <a href="#edge_from_index">edge_from_index</a>(edges_size_type i, const compressed_sparse_row_graph&amp;);<br><br><i>// <a href="#property-map-accessors">Property map accessors</a></i>
template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>&gt;<br>property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::type<br><a href="#get">get</a>(PropertyTag, compressed_sparse_row_graph&amp; g)<br><br>template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>&gt;<br>property_map&lt;compressed_sparse_row_graph, Tag&gt;::const_type<br><a href="#get">get</a>(PropertyTag, const compressed_sparse_row_graph&amp; g)<br><br>template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>, class X&gt;<br>typename property_traits&lt;property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::const_type&amp;gt::value_type<br><a href="#get-x">get</a>(PropertyTag, const compressed_sparse_row_graph&amp; g, X x)<br><br>template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>, class X, class Value&gt;<br>void <a href="#put-x">put</a>(PropertyTag, const compressed_sparse_row_graph&amp; g, X x, const Value&amp; value);<br><br>template&lt;typename <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp;<br><a href="#get_property">get_property</a>(compressed_sparse_row_graph&amp; g, GraphPropertyTag);<br><br>template&lt;typename <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type const &amp;<br><a href="#get_property">get_property</a>(const compressed_sparse_row_graph&amp; g, GraphPropertyTag);<br><br>template&lt;typename <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>void <a href="#set_property">set_property</a>(const compressed_sparse_row_graph&amp; g, GraphPropertyTag,<br>                  const typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp; value);<br><br><i>// <a href="#incremental-construction-functions">Incremental construction functions</a></i>
template&lt;typename Graph&gt;
vertex_descriptor <a href="#add_vertex">add_vertex</a>(compressed_sparse_row_graph&amp; g);<br><br>template&lt;typename Graph&gt;<br>vertex_descriptor <a href="#add_vertices">add_vertices</a>(vertices_size_type count, compressed_sparse_row_graph&amp; g);<br><br>template&lt;typename Graph&gt;<br>edge_descriptor <a href="#add_edge">add_vertices</a>(vertex_descriptor src, vertex_descriptor tgt, compressed_sparse_row_graph&amp; g);<br><br>} <i>// end namespace boost</i>
   </pre>

    <a name="where"></a><h2>Where Defined 定义于</h2>
    <p><code>&lt;<a href="../../../boost/graph/compressed_sparse_row_graph.hpp">boost/graph/compressed_sparse_row_graph.hpp</a>&gt;</code></p>

    <a name="models"></a><h2>Models 模型</h2>
    
    <p><tt>compressed_sparse_row_graph</tt> 类模板符合(即实现了它们的要求)多个
    BGL <a href="graph_concepts.html">图概念</a>，可用于大多数的BGL算法。尤其是，它符合以下特定图概念：</p>

    <ul>
      <li><a href="Graph.html">图Graph</a></li>
      <li><a href="IncidenceGraph.html">关联图IncidenceGraph</a></li>
      <li><a href="AdjacencyGraph.html">邻接图AdjacencyGraph</a></li>
      <li><a href="VertexListGraph.html">点列表图VertexListGraph</a></li>
      <li><a href="EdgeListGraph.html">边列表图EdgeListGraph</a></li>
      <li><a href="PropertyGraph.html">属性图PropertyGraph</a></li>
    </ul>

    <a name="template-parms"></a><h2>Template Parameters 模板参数</h2>

    <p><tt>compressed_sparse_row_graph</tt> 类有几个模板参数，可以对内存的布局以及将哪些属性关联至图本身进行定制。所有参数均有缺省值，因此只关心图结构的用户可以使用类型 <tt>compressed_sparse_row_graph&lt;&gt;</tt> 而省略所有参数。</p>

    <b>参数Parameters</b>&nbsp;&nbsp;<br>
    <br>

    <a name="Directed"></a><code>Directed</code>
      <blockquote>决定该图是有向图、双向图或是无向图的选择子。目前，CSR图类型只支持有向图，因此该值必须为 <code>boost::directedS</code>.<br>
        <b>缺省值：</b><code>boost::directedS</code>
      </blockquote>

    <a name="VertexProperty"></a><code>VertexProperty</code>
      <blockquote>一个将被关联到图中各顶点的类类型。如果该值为 <code>void</code>，则没有属性被关联到图的顶点。<br>
        <b>缺省值：</b><code></code><code>void</code>
      </blockquote>

    <a name="EdgeProperty"></a><code>EdgeProperty</code>
    <blockquote>一个将被关联到图中各边的类类型。如果该值为 <code>void</code>，则没有属性被关联到图的边。<br>
        <b>缺省值：</b><code></code><code>void</code>
    </blockquote>

    <a name="GraphProperty"></a><code>GraphProperty</code>
    <blockquote>一组嵌套的属性模板，表示图本身的属性。如果该值为 <code>no_property</code>，则没有属性被关联至该图。<br>
        <b>缺省值：</b><code></code><code>no_property</code>
    </blockquote>

    <a name="Vertex"></a><code>Vertex</code>
    <blockquote>一个无符号整数类型，用作顶点数组的索引以及顶点描述符本身。较大的类型可允许CSR图保存更多的顶点；较小的类型则减少每个顶点的存储要求。<br>
        <b>缺省值：</b><code></code><code>std::size_t</code>
    </blockquote>

    <a name="EdgeIndex"></a><code>EdgeIndex</code>
    <blockquote>一个无符号整数类型，用作边数组的索引。和 <code>Vertex</code> 参数一样，较大的类型可允许更多的边，而较小的类型则减少每条边的存储用量。<code>EdgeIndex</code> 类型不得小于 <code>Vertex</code> 类型，但可以更大。例如，<code>Vertex</code> 可能是一个16位整数(允许图中最多有 32,767 个顶点)，而 <code>EdgeIndex</code> 可以是一个32位整数，这样可以允许用CSR格式保存一个完全图。<br>
        <b>缺省值：</b><code></code><code>Vertex</code>
    </blockquote>

    <a name="properties"></a><h2>Interior Properties 内部属性</h2>

    <p><tt>compressed_sparse_row_graph</tt> 允许通过它的 <a href="compressed_sparse_row.html#template-parms">模板参数</a> 把属性关联至顶点、边或图本身。这些属性可以通过 <a href="#property-access">成员的</a>
    和 <a href="#property-map-accessors">非成员的</a> 属性访问函数来访问，使用 <a href="bundles.html">绑定属性</a> 机制。</p>

    <p>CSR图提供两类内建属性：<tt>vertex_index</tt> 从顶点映射至 <tt>[0, n)</tt>，还有 <tt>edge_index</tt> 从边映射至 <tt>[0, m)</tt>，其中 <tt>n</tt> 和 <tt>m</tt> 分别为图中的顶点数和边数。 </p>

    <a name="member-functions"></a><h2>Member Functions 成员函数</h2>

    <a name="constructors"></a><h3>Constructors 构造函数</h3>
    <pre><a name="default-const"></a>
  compressed_sparse_row_graph();
    </pre>
    <p class="indent">构造一个没有顶点和边的图。</p>

    <hr>

    <pre><a name="edge-const"></a>
  template&lt;typename InputIterator&gt;
  compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty&amp; prop = GraphProperty());
    </pre>

    <p class="indent">构造一个具有 <code>numverts</code> 个顶点的图，图的边由迭代器区间 <code>[edge_begin,
      edge_end)</code> 指定。<tt>InputIterator</tt> 必须是 <a href="http://www.sgi.com/tech/stl/InputIterator.html">输入迭代器</a>，且 <code>value_type</code> 为一个整数值的 <code>std::pair</code>。这些整数值为各边的源顶点和目标顶点，必须位于区间 <code>[0,
      numverts)</code> 中。<code>[edge_begin,
      edge_end)</code> 中的边必须是已排序的，对于 <i>j &gt; i</i>，有：源自顶点 <i>i</i> 的所有边必须在源自顶点 <i>j</i> 的边之前。
    </p>

    <p class="indent">如果给出了值 <code>numedges</code>，则用于表示区间 <code>[edge_begin, edge_end)</code> 中有多少条边，在构造时它将被用于预分配数据结构的内存，以节省内存和时间。
    </p>

    <p class="indent">值 <code>prop</code> 用于初始化该图的属性。
    </p>

    <hr>

    <pre><a name="edge-prop-const"></a>
  template&lt;typename InputIterator, typename EdgePropertyIterator&gt;
  compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty&amp; prop = GraphProperty());
    </pre>
    <p class="indent">构造一个具有 <code>numverts</code> 个顶点的图，图的边由迭代器区间 <code>[edge_begin,
      edge_end)</code> 指定。它的语义与 <a href="#edge-const">edge range 构造函数</a> 相同，除了边的属性亦同时被初始化。类型
      <tt>EdgePropertyIterator</tt> 必须符合 <a href="http://www.sgi.com/tech/stl/InputIterator.html">输入迭代器</a>
      概念，且 <tt>value_type</tt> 可转换为 <tt>EdgeProperty</tt>。迭代器区间 <tt>[ep_iter, ep_ter +
        m)</tt> 将被用于初始化图中各边的属性，其中 <tt>m</tt> 为 <tt>edge_begin</tt> 到 <tt>edge_end</tt> 的距离。
    </p>

    <hr>

    <pre><a name="#graph-const"></a>
  template&lt;typename Graph, typename VertexIndexMap&gt;
  compressed_sparse_row_graph(const Graph&amp; g, const VertexIndexMap&amp; vi,
                              vertices_size_type numverts,
                              edges_size_type numedges); 

  template&lt;typename Graph, typename VertexIndexMap&gt;
  compressed_sparse_row_graph(const Graph&amp; g, const VertexIndexMap&amp; vi);

  template&lt;typename Graph&gt;
  explicit compressed_sparse_row_graph(const Graph&amp; g);
    </pre>

    <p class="indent">以给定的参数调用 <a href="#assign"><tt>assign</tt></a> 函数。
    </p>

    <hr>

    <a name="mutators"></a><h3>Mutators 可变函数</h3>
    <pre><a name="assign"></a>
  template&lt;typename Graph, typename VertexIndexMap&gt;
  void assign(const Graph&amp; g, const VertexIndexMap&amp; vi,
              vertices_size_type numverts, edges_size_type numedges);

  template&lt;typename Graph, typename VertexIndexMap&gt;
  void assign(const Graph&amp; g, const VertexIndexMap&amp; vi);

  template&lt;typename Graph&gt;
  void assign(const Graph&amp; g);
    </pre>

    <p class="indent">清除CSR图，并按另一个图的结构就地构造一个CSR图。图类型 <tt>Graph</tt> 必须是一个 <a href="IncidenceGraph.html">关联图</a>
      且带有一个 <tt>vertex(i, g)</tt> 函数，用于取出图中第
      <i>i</i><sup>th</sup> 个顶点。<br><b>Parameters参数</b>

      </p><ul>
        <li><tt>g</tt>: 作为输入的图。</li>
        
        <li><tt>vi</tt>: 一个从顶点至索引的映射。如果未提供，则使用 <tt>get(vertex_index, g)</tt>。</li>
        
        <li><tt>numverts</tt>: 图
          <tt>g</tt> 的顶点数量。如果未提供，则 <tt>Graph</tt> 必须为
          <a href="VertexListGraph.html">点列表图</a>。</li>
        
        <li><tt>numedges</tt>: 图
          <tt>g</tt> 的边数量。如果未提供，则 <tt>Graph</tt> 必须为
          <a href="EdgeListGraph.html">边列表图</a>。</li>
      </ul>
    <p></p>

    <hr>

    <a name="property-access"></a><h3>Property Access 属性访问</h3>

    <pre><a name="vertex-subscript"></a>
  VertexProperty&amp; operator[](vertex_descriptor v);
  const VertexProperty&amp; operator[](vertex_descriptor v) const;
    </pre>

    <p class="indent">取出与顶点 <tt>v</tt> 关联的属性值。仅当 <tt>VertexProperty</tt> 为非 <tt>no_property</tt> 的类类型时有效。
    </p>

    <hr>

    <pre><a name="edge-subscript">
  EdgeProperty&amp; operator[](edge_descriptor v);
  const EdgeProperty&amp; operator[](edge_descriptor v) const;
    </a></pre>

<a name="edge-subscript">    </a><p class="indent">
取出与边 <tt>v</tt> 关联的属性值。仅当&nbsp;<tt><tt>Edge</tt></tt><tt>Property</tt> 为非 <tt>no_property</tt> 的类类型时有效。
    </p>

<a name="edge-subscript">    </a><hr>
<a name="edge-subscript">    </a><a name="non-members"></a><h2>Non-member Functions 非成员函数</h2>

    <a name="vertex-access"></a><h3>Vertex access 顶点访问</h3>

    <pre><a name="vertex"></a>
  vertex_descriptor vertex(vertices_size_type i, const compressed_sparse_row_graph&amp;);
    </pre>
    <p class="indent">在常数时间内取出图中第 <i>i</i><sup>th</sup> 个顶点。
    </p>

    <hr>

    <a name="edge-access"></a><h3>Edge access 边访问</h3>
    <pre><a name="edge_range"></a>
  std::pair&lt;out_edge_iterator, out_edge_iterator&gt; 
    edge_range(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);
    </pre>

    <p class="indent">返回从 <tt>u</tt> 到 <tt>v</tt> 的所有边。要求其时间与 <tt>u</tt> 的出边数量成线性关系。
    </p>

    <hr>

    <pre><a name="edge"></a>
  std::pair&lt;edge_descriptor, bool&gt; 
    edge(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);
    </pre>

    <p class="indent">如果图中有一条边 <i>(u, v)</i>，则返回该边的描述符和 <tt>true</tt>；否则值对中的第二个值为 <tt>false</tt>。如果从 <tt>u</tt> 到 <tt>v</tt> 有多条边，则返回第一条边；用 <a href="#edge_range"><tt>edge_range</tt></a>
      取出所有边。
    </p>

    <hr>

    <pre><a name="edge_from_index"></a>
  edge_descriptor edge_from_index(edges_size_type i, const compressed_sparse_row_graph&amp;);
    </pre>

    <p class="indent">返回图中第 <i>i</i><sup>th</sup> 条边。该操作的时间要求与顶点数成对数关系。
    </p>

    <hr>

    <h3><a name="property-map-accessors">Property Map Accessors 属性映射访问</a></h3>

    <pre><a name="get"></a>
template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>&gt;<br>property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::type<br>get(PropertyTag, compressed_sparse_row_graph&amp; g)<br><br>template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>&gt;<br>property_map&lt;compressed_sparse_row_graph, Tag&gt;::const_type<br>get(PropertyTag, const compressed_sparse_row_graph&amp; g)<br>    </pre>
    
    <p class="indent">返回由 <tt>PropertyTag</tt> 指定的顶点属性的属性映射对象。<tt>PropertyTag</tt> 必须是一个成员指针，访问在
      <tt>VertexProperty</tt> 或 <tt>EdgeProperty</tt> 中的某个域。
    </p>

    <hr>

    <pre><a name="get-x"></a>
template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>, class X&gt;<br>typename property_traits&lt;property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::const_type&amp;gt::value_type<br>get(PropertyTag, const compressed_sparse_row_graph&amp; g, X x)<br>    </pre>

    <p class="indent">返回 <tt>x</tt> 的属性值，其中 <tt>x</tt>
      为一个顶点描述符或边描述符。
    </p>

    <hr>

    <pre><a name="put-x"></a>
template&lt;typename <a href="./PropertyTag.html">PropertyTag</a>, class X, class Value&gt;<br>void put(PropertyTag, const compressed_sparse_row_graph&amp; g, X x, const Value&amp; value);<br>    </pre>

    <p class="indent">将 <tt>x</tt> 的属性值设为
      <tt>value</tt>。<tt>x</tt> 为一个顶点描述符或边描述符。<tt>Value</tt> 必须可转换为 <tt>typename
      property_traits&lt;property_map&lt;compressed_sparse_row_graph,
      PropertyTag&gt;::type&amp;gt::value_type</tt>
    </p>

    <hr>

    <pre><a name="get_property"></a>
template&lt;typename <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp;<br>get_property(compressed_sparse_row_graph&amp; g, GraphPropertyTag);<br><br>template&lt;typename <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type const &amp;<br>get_property(const compressed_sparse_row_graph&amp; g, GraphPropertyTag);<br>    </pre>

    <p class="indent">返回由 <tt>GraphPropertyTag</tt> 指定的，关联至图对象 <tt>g</tt> 的属性。 
    </p>

    <hr>

    <pre><a name="set_property"></a>
template&lt;typename <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;<br>void set_property(const compressed_sparse_row_graph&amp; g, GraphPropertyTag,<br>                  const typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp; value);<br>    </pre>

    <p class="indent">设置由 <tt>GraphPropertyTag</tt> 指定的，关联至图对象 <tt>g</tt> 的属性。
    </p>

    <hr>

    <h3><a name="incremental-construction-functions">Incremental construction functions 递增构造函数</a></h3>

    <pre><a name="add_vertex"></a>
vertex_descriptor add_vertex(compressed_sparse_row_graph&amp; g)
    </pre>
    
    <p class="indent">增加一个新顶点至图 <tt>g</tt> 的末尾，并返回该顶点的描述符。新顶点将大于原 <tt>g</tt> 中的任一顶点。
    </p>

    <hr>

    <pre><a name="add_vertices"></a>
vertex_descriptor add_vertices(vertices_size_type count, compressed_sparse_row_graph&amp; g)
    </pre>
    
    <p class="indent">增加 <tt>count</tt> 个新顶点到图 <tt>g</tt> 的末尾，并返回最小新顶点的描述符。新的顶点将大于原 <tt>g</tt> 中的任一顶点。
    </p>

    <hr>

    <pre><a name="add_edge"></a>
edge_descriptor add_edge(vertex_descriptor src, vertex_descriptor tgt, compressed_sparse_row_graph&amp; g)
    </pre>
    
    <p class="indent">将从 <tt>src</tt> 到 <tt>tgt</tt> 的一条新边增加至图 <tt>g</tt>，并返回该边的描述符。必须在原&nbsp; <tt>g</tt>
      中没有一条边的源顶点大于 <tt>src</tt>。如果在该操作被调用之前，顶点
      <tt>src</tt> 具有出边，则必须没有一条出边的目标顶点大于 <tt>tgt</tt>。
    </p>

    <hr>
    <a name="example"></a><h2>Example 示例</h2>

    <br>[<a href="../example/csr-example.cpp">libs/graph/example/csr-example.cpp</a>]

    <p>我们将用 <tt>compressed_sparse_row_graph</tt> 图类来保存一个简单的 Web 图。在这个 web 图中，顶点代表 web 页面，而边代表从一个 web
    页面到另一个页面的链接。对于每个 web 页面，我们想关联一个 URL，所以我们先创建一个保存 URL 的 <tt>WebPage</tt> 类。然后我们就可以通过将创建
    <tt>WebPage</tt> 作为
    <tt>compressed_sparse_row_graph</tt> 类模板的参数来创建我们所要的图类型了。</p>

    <pre>class WebPage<br>{<br> public:<br>  std::string url;<br>};<br><br>// ...<br><br>typedef compressed_sparse_row_graph&lt;directedS, WebPage&gt; WebGraph;<br>WebGraph g(&amp;the_edges[0], &amp;the_edges[0] + sizeof(the_edges)/sizeof(E), 6);<br>    </pre>

    <p>We can then set the properties on the vertices of the graph
    using the <a href="bundles.html">bundled properties</a> syntax,
    and display the edges for the user.</p>

    <pre>// 设置各个顶点的 URLs<br>int index = 0;<br>BGL_FORALL_VERTICES(v, g, WebGraph)<br>  g[v].url = urls[index++];<br><br>// 输出各个链接<br>std::cout &lt;&lt; "The web graph:" &lt;&lt; std::endl;<br>BGL_FORALL_EDGES(e, g, WebGraph)<br>  std::cout &lt;&lt; "  " &lt;&lt; g[source(e, g)].url &lt;&lt; " -&gt; " &lt;&lt; g[target(e, g)].url <br>            &lt;&lt; std::endl;<br>    </pre>

    <p>有关
    <tt>compressed_sparse_row_graph</tt> 可以执行的其它操作，请见 <a href="../example/csr-example.cpp">完整的示例代码</a>。<br>
</p><hr>
<table>
<tbody><tr valign="top">
<td nowrap="nowrap">Copyright © 2005</td><td>
<a href="http://www.boost.org/people/doug_gregor.html">Doug Gregor</a>, Indiana University (<script language="Javascript">address("cs.indiana.edu", "dgregor")</script>)<br>
Jeremiah Willcock, Indiana University (<script language="Javascript">address("osl.iu.edu", "jewillco")</script>)<br>
  <a href="http://www.osl.iu.edu/%7Elums">Andrew Lumsdaine</a>,
Indiana University (<script language="Javascript">address("osl.iu.edu", "lums")</script>)
</td></tr></tbody></table>
  </body></html>
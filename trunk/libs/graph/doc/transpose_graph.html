<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  -->
<title>Boost Graph Library: Transpose Graph</title></head>

<body alink="#ff0000" bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b"> 
<img src="../../../boost.png" alt="C++ Boost" height="86" width="277"> 

<br clear="">

<h1><tt>transpose_graph</tt></h1>

<pre>template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class <a href="./MutableGraph.html">MutableGraph</a>&gt; <br>void transpose_graph(const VertexListGraph&amp; G, MutableGraph&amp; G_T,<br>    const bgl_named_params&lt;P, T, R&gt;&amp; params = <i>all defaults</i>)<br></pre>

<p>该函数计算一个有向图的转置。有向图 <i>G = (V, E)</i> 的转置是指图
<i>G<sup>T</sup> = (V, E<sup>T</sup>)</i>，其中 <i>E<sup>T</sup> =
{(v, u) in V x V: (u, v) in E}</i> . 即，<i>G<sup>T</sup></i> 将
<i>G</i> 的所有边反向。传入该算法的图 <tt>G_T</tt> 必须没有顶点和边。它的顶点和边将由 <tt>transpose_graph()</tt> 通过调用 <tt>add_vertex</tt> 和  <tt>add_edge</tt> 根据 <tt>G</tt> 中的每条边
<i>(u,v)</i> 加进去。

</p><h3>Example 示例</h3>以下是对一个图进行转置的例子：<a href="../example/transpose-example.cpp"><tt>example/transpose-example.cpp</tt></a>.

<h3>Where Defined 定义于</h3>

<p>
<a href="../../../boost/graph/transpose_graph.hpp"><tt>boost/graph/transpose_graph.hpp</tt></a>

</p><p>

</p><h3>Parameters 参数</h3>

IN: <tt>const VertexListGraph&amp; G</tt>
<blockquote>一个有向图。图的类型必须符合 <a href="./VertexListGraph.html">点列表图Vertex List Graph</a>。
</blockquote>

OUT: <tt>const MutableGraph&amp; G_T</tt>
<blockquote>转置后的图。图的类型必须符合 <a href="./MutableGraph.html">可变图Mutable Graph</a>。
</blockquote>

<h3>Named Parameters 命名参数</h3>

IN: <tt>vertex_copy(VertexCopier vc)</tt>
<blockquote>这是一个 <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">二元函数</a>，将原图的顶点属性复制至拷贝中的对应顶点。<br>

<b>缺省值：</b><tt>vertex_copier&lt;VertexListGraph, MutableGraph&gt;</tt>，它使用属性标签 <tt>vertex_all</tt> 来访问图的属性映射。

</blockquote>

IN: <tt>edge_copy(EdgeCopier ec)</tt>
<blockquote>这是一个 <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">二元函数</a>，将原图的边属性复制至拷贝中的对应边。<br>

<b>缺省值：</b><tt>edge_copier&lt;VertexListGraph, MutableGraph&gt;</tt>，它使用属性标签&nbsp;<tt>edge</tt><tt>_all</tt> 来访问图的属性映射。&nbsp;
</blockquote>

IN: <tt>vertex_index_map(VertexIndexMap i_map)</tt>
<blockquote>顶点索引映射类型必须符合 <a href="../../property_map/ReadablePropertyMap.html">可读属性映射</a>，且必须将 <tt>G</tt> 的顶点描述符映射至&nbsp;<tt>0 到 num_vertices(G))</tt>&nbsp;的整数。<br>

<b>缺省值：</b><tt>get(vertex_index, G)</tt>.
注意：如果你使用该缺省值，请确认你的图具有一个内部的 <tt>vertex_index</tt> 属性。例如，带 <tt>VertexList=listS</tt> 的
    <tt>adjacenty_list</tt> 并不具有内部的 <tt>vertex_index</tt> 属性。
</blockquote>


UTIL/OUT: <tt>orig_to_copy(Orig2CopyMap c)</tt>
<blockquote>它将原图中的顶点映射至拷贝中的顶点。<br><b>缺省值：</b>一个&nbsp;<a href="../../property_map/iterator_property_map.html">
  iterator_property_map</a>，创建自一个大小为&nbsp;<tt>num_vertices(g)</tt> 的输出图的边描述符类型的 <tt>std::vector</tt>，且以 <tt>i_map</tt> 作为索引映射。&nbsp;
</blockquote>

<h3>Complexity 复杂度</h3>

<p>时间复杂度为 <i>O(V + E)</i>.



<br>
</p><hr>
<table>
<tbody><tr valign="top">
<td nowrap="nowrap">Copyright © 2000-2001</td><td>
<a href="http://www.boost.org/people/jeremy_siek.htm">Jeremy Siek</a>, Indiana University (<a href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)
</td></tr></tbody></table>

</body></html>
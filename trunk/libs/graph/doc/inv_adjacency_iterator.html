<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><!--
  -- Copyright (c) 2000 Jeremy Siek
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Inverse Adjacency Iterator Adaptor Documentation</title></head>


<body bgcolor="#ffffff" text="#000000">

<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">

<h1>Inverse Adjacency Iterator Adaptor 反向邻接迭代器适配器</h1>定义于头文件
<a href="../../../boost/graph/adjacency_iterator.hpp">boost/graph/adjacency_iterator.hpp</a>

<p>反向邻接迭代器适配器将一个
<tt>in_edge_iterator</tt> 转换为反向邻接迭代器。即，它接受一个对边进行遍历的迭代器，并创建一个对这些边的<b><i>源</i></b>顶点进行遍历的迭代器。

<!--
With this adaptor it is trivial to take a graph type that models <a
href="IncidenceGraph.html">Incidence Graph</a> and add the
capabilities required of <a href="AdjacencyGraph.html">Adjacency
Graph</a>. -->


</p><h2>Synopsis 概要</h2>

<pre>namespace boost {<br>  template &lt;class Graph, class VertexDescriptor, class InEdgeIter&gt;<br>  class inv_adjacency_iterator_generator {<br>  public:<br>    typedef <a href="../../iterator/doc/iterator_adaptor.html">iterator_adaptor</a>&lt;...&gt; type;<br>  };<br>}<br></pre>

<hr>

<h3>Example 示例</h3>

<p>以下是一个如何使用
<tt>inv_adjacency_iterator_generator</tt> 类的例子。

</p><pre>#include &lt;boost/graph/adjacency_iterator.hpp&gt;<br><br>class my_graph {<br>  // ...<br>  typedef ... in_edge_iterator;<br>  typedef ... vertex_descriptor;<br>  typedef boost::inv_adjacency_iterator_generator&lt;my_graph, vertex_descriptor, in_edge_iterator&gt;::type inv_adjacency_iterator;<br>  // ...<br>};<br><br></pre>

<h3>Template Parameters 模板参数</h3>

<table border="1">
<tbody><tr>
<th>Parameter</th><th>Description</th>
</tr>

<tr>
<td><tt>Graph</tt></td>
<td>图类型，必须符合 <a href="./IncidenceGraph.html">关联图Incidence Graph</a>。</td>
</tr>

<tr>
<td><tt>VertexDescriptor</tt></td>
<td>必须是与
<tt>graph_traits&lt;Graph&gt;::vertex_descriptor</tt> 相同的类型。将此作为一个模板参数的原因是，<tt>inv_</tt><tt>adjacency_iterator_generator</tt> 的主要用途是在图类定义的<b><i>内部</i></b>，而在这样的上下文中我们不能对尚未完整定义的图类使用
<tt>graph_traits</tt>。<br>
<b>缺省值：</b><tt>graph_traits&lt;Graph&gt;::vertex_descriptor</tt></td>
</tr>

<tr>
<td><tt>InEdgeIter</tt></td>
<td>必须是与 <tt>graph_traits&lt;Graph&gt;::in_edge_iterator</tt> 相同的类型。<br>
<b>缺省值：</b><tt>graph_traits&lt;Graph&gt;::in_edge_iterator
</tt></td>
</tr>

</tbody></table>

<h3>Model of 以...为模型</h3>反向邻接迭代器适配器(类型
<tt>inv_</tt><tt>adjacency_iterator_generator&lt;...&gt;::type</tt>)是 <a href="../../utility/MultiPassInputIterator.html">多遍输入迭代器</a>。


<h3>Members 成员</h3>反向邻接迭代器类型实现了 <a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">随机访问迭代器</a>
概念所要求的成员函数和操作符，除了其引用类型与 <tt>value_type</tt>
相同，因此 <tt>operator*()</tt> 是以值方式返回的。此外它还有以下构造函数：&nbsp;

<pre>inv_adjacency_iterator_generator::type(const InEdgeIter&amp; it, const Graph* g)<br></pre>

<hr>
<p>Revised <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %b %Y" startspan -->19 Aug 2001<!--webbot bot="Timestamp" endspan i-checksum="14767" --></p>
<p>© Copyright Jeremy Siek 2000. Permission to copy, use,
modify, sell and distribute this document is granted provided this copyright
notice appears in all copies. This document is provided "as is"
without express or implied warranty, and with no claim as to its suitability for
any purpose.</p>

<!--  LocalWords:  VertexDescriptor InEdgeIter inv const Aug Siek
 -->
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns:st1="urn:schemas-microsoft-com:office:smarttags" xmlns="http://www.w3.org/TR/REC-html40"><head>


<META content="text/html; charset=utf-8" http-equiv=Content-Type>
<meta name="ProgId" content="Word.Document">
<meta name="Generator" content="Microsoft Word 11">
<meta name="Originator" content="Microsoft Word 11">
<link rel="Edit-Time-Data" href="int_const_guidelines.files/editdata.mso">
<o:smarttagtype namespaceuri="urn:schemas-microsoft-com:office:smarttags" name="chmetcnv" downloadurl=""></o:smarttagtype><!--[if gte mso 9]><xml>

 <o:DocumentProperties>

  <o:Author>shomnia</o:Author>

  <o:Template>Normal</o:Template>

  <o:LastAuthor>shomnia</o:LastAuthor>

  <o:Revision>12</o:Revision>

  <o:TotalTime>278</o:TotalTime>

  <o:Created>2009-06-15T14:08:00Z</o:Created>

  <o:LastSaved>2009-07-15T14:56:00Z</o:LastSaved>

  <o:Pages>1</o:Pages>

  <o:Words>1835</o:Words>

  <o:Characters>10462</o:Characters>

  <o:Lines>87</o:Lines>

  <o:Paragraphs>24</o:Paragraphs>

  <o:CharactersWithSpaces>12273</o:CharactersWithSpaces>

  <o:Version>11.5606</o:Version>

 </o:DocumentProperties>

</xml><![endif]--><!--[if gte mso 9]><xml>

 <w:WordDocument>

  <w:Zoom>120</w:Zoom>

  <w:ValidateAgainstSchemas/>

  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>

  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>

  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>

  <w:Compatibility>

   <w:UseFELayout/>

  </w:Compatibility>

  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>

 </w:WordDocument>

</xml><![endif]--><!--[if gte mso 9]><xml>

 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">

 </w:LatentStyles>

</xml><![endif]-->

<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:SimSun;}
h2
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:18.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h3
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	mso-outline-level:3;
	font-size:13.5pt;
	font-family:"Times New Roman";
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:SimSun;}
code
	{font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:SimSun;
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
pre
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:SimSun;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:42.55pt;
	mso-footer-margin:49.6pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:60837738;
	mso-list-template-ids:-928874132;}
@list l0:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1
	{mso-list-id:164170497;
	mso-list-template-ids:-1759979722;}
@list l1:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level2
	{mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level3
	{mso-level-tab-stop:108.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level4
	{mso-level-tab-stop:144.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level5
	{mso-level-tab-stop:180.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level6
	{mso-level-tab-stop:216.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level7
	{mso-level-tab-stop:252.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level8
	{mso-level-tab-stop:288.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level9
	{mso-level-tab-stop:324.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2
	{mso-list-id:618996338;
	mso-list-template-ids:1060914338;}
@list l2:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level2
	{mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level3
	{mso-level-tab-stop:108.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level4
	{mso-level-tab-stop:144.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level5
	{mso-level-tab-stop:180.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level6
	{mso-level-tab-stop:216.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level7
	{mso-level-tab-stop:252.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level8
	{mso-level-tab-stop:288.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level9
	{mso-level-tab-stop:324.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3
	{mso-list-id:1637488859;
	mso-list-template-ids:-1950600986;}
@list l3:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level2
	{mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level3
	{mso-level-tab-stop:108.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level4
	{mso-level-tab-stop:144.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level5
	{mso-level-tab-stop:180.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level6
	{mso-level-tab-stop:216.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level7
	{mso-level-tab-stop:252.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level8
	{mso-level-tab-stop:288.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3:level9
	{mso-level-tab-stop:324.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l4
	{mso-list-id:1858885217;
	mso-list-template-ids:-1428632146;}
@list l4:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l5
	{mso-list-id:1929842976;
	mso-list-template-ids:991986554;}
@list l5:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style><!--[if gte mso 10]>

<style>

 /* Style Definitions */

 table.MsoNormalTable

	{mso-style-name:\666E\901A\8868\683C;

	mso-tstyle-rowband-size:0;

	mso-tstyle-colband-size:0;

	mso-style-noshow:yes;

	mso-style-parent:"";

	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;

	mso-para-margin:0cm;

	mso-para-margin-bottom:.0001pt;

	mso-pagination:widow-orphan;

	font-size:10.0pt;

	font-family:"Times New Roman";

	mso-ansi-language:#0400;

	mso-fareast-language:#0400;

	mso-bidi-language:#0400;}

</style>

<![endif]-->

<meta name="Template" content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot"><!--[if gte mso 9]><xml>

 <o:shapelayout v:ext="edit">

  <o:idmap v:ext="edit" data="1"/>

 </o:shapelayout></xml><![endif]--></head><body style="" bgcolor="white" lang="ZH-CN" link="blue" vlink="purple">

<div class="Section1">

<h2 style="text-align: center;" align="center"><span lang="EN-US">Coding 
Guidelines for Integral Constant Expressions</span></h2>

<h2 style="text-align: center;" align="center"><span style="font-family: SimSun;">
整型常量表达式的编码指南</span></h2>

<p><span lang="EN-US">Integral Constant Expressions are used in many places in 
C++; as array bounds, as bit-field lengths, as enumerator initialisers, and as 
arguments to non-type template parameters. However many compilers have problems 
handling integral constant expressions; as a result of this, programming using 
non-type template parameters in particular can be fraught with difficulty, often 
leading to the incorrect assumption that non-type template parameters are 
unsupported by a particular compiler. This short article is designed to provide 
a set of guidelines and workarounds that, if followed, will allow integral 
constant expressions to be used in a manner portable to all the compilers 
currently supported by boost. Although this article is mainly targeted at boost 
library authors, it may also be useful for users who want to understand why 
boost code is written in a particular way, or who want to write portable code 
themselves.</span><span style="font-family: SimSun;"><br>
整型常量表达式使用在</span><span lang="EN-US">C++</span><span style="font-family: SimSun;">的 
很多地方，如数组的边界，位域的长度，枚举初始化和非类型模板的参数。然而很多编译器在处理整型常量表达式的时候会出现问题；在有些情况下使用非类型模板 
参数充满困难，这导致非类型模板参数不被一些编译器支持这一不正确的假设。这篇短文提供了一系列有关的指导原则及变通法则，如果遵守这些法则，这使得整型 
常量表达式对所有</span><span lang="EN-US">boost</span><span style="font-family: SimSun;">所支持的编译器以可移植的方式使用。尽管本文主要目标集中在</span><span lang="EN-US">boost</span><span style="font-family: SimSun;">库的作者，但是这对想理解</span><span lang="EN-US">boost</span><span style="font-family: SimSun;">库为什么以一些特殊方式写代码很有帮助，或者对想写可移植代码的人也有帮助。</span></p>

<h3><span lang="EN-US">What is an Integral Constant Expression?</span></h3>

<h3><span style="font-family: SimSun;">什么是整型常量表达式？</span></h3>

<p><span lang="EN-US">Integral constant expressions are described in section 
5.19 of the standard, and are sometimes referred to as &quot;compile time constants&quot;. 
An integral constant expression can be one of the following:</span><span style="font-family: SimSun;"><br>
整型常量表达式在</span><span lang="EN-US">5.19</span><span style="font-family: SimSun;">节的标准中描述，有时候也称为“编译时常量”。整型常量表达式为如下类型之一：</span></p>

<span lang="EN-US">1. A literal integral value, for example 0u or <st1:chmetcnv unitname="l" sourcevalue="3" hasspace="False" negative="False" numbertype="1" tcsc="0" w:st="on">
3L</st1:chmetcnv>.&nbsp;</span><span style="font-family: SimSun;"></span><br>
<span style="font-family: SimSun;">1. 常量整数值，如</span><span lang="EN-US">0u</span><span style="font-family: SimSun;">或</span><st1:chmetcnv unitname="l" sourcevalue="3" hasspace="False" negative="False" numbertype="1" tcsc="0" w:st="on"><span lang="EN-US">3L</span></st1:chmetcnv><span lang="EN-US">.<br>
<br>
</span><span lang="EN-US">2. An enumerator value.</span><br>
<span lang="EN-US"></span><span style="font-family: SimSun;">2. 枚举值<br>
<br>
</span><span lang="EN-US">3. Global integral constants, for example: <br>
</span><span style="font-family: SimSun;">3. 全局整数常量，如：</span><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;" lang="EN-US"><br>
     <code>const int my_INTEGRAL_CONSTANT = 3;<br>
<br>
</code></span><span lang="EN-US">4. Static member constants, for example: </span><span style="font-family: SimSun;"><br>
4.静态成员常量，如：</span><span lang="EN-US"><br>
     </span><code><span style="font-size: 10pt;" lang="EN-US">struct myclass</span></code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;" lang="EN-US"><br>
     <code>{ static const int value = 0; };<br>
<br>
</code></span><span lang="EN-US">5. Member enumerator values, for example:<br>
5. </span><span style="font-family: SimSun;">成员枚举值，如：</span><span lang="EN-US"><br>
     </span><code><span style="font-size: 10pt;" lang="EN-US">struct myclass</span></code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;" lang="EN-US"><br>
     <code>{ enum{ value = 0 }; };<br>
<br>
</code></span><span lang="EN-US">6. Non-type template parameters of integral or 
enumerator type.</span><span style="font-family: SimSun;"><br>
6.整型或枚举类型的非类型模板参数</span><span lang="EN-US">.<br>
<br>
</span><span lang="EN-US">7.The result of a </span><code><span style="font-size: 10pt;" lang="EN-US">
sizeof</span></code><span lang="EN-US"> expression, for example:</span><span style="font-family: SimSun;"><br>
7.sizeof表达式的结果，如：</span><span lang="EN-US"><br>
     </span><code><span style="font-size: 10pt;" lang="EN-US">sizeof(foo(a, b, 
c))<br>
<br>
</span></code><span lang="EN-US">8.The result of a </span><code><span style="font-size: 10pt;" lang="EN-US">
static_cast</span></code><span lang="EN-US">, where the target type is an 
integral or enumerator type, and the argument is either another integral 
constant expression, or a floating-point literal. <br>
8. static_cast</span><span style="font-family: SimSun;">的结果，这里目标类型是整型或者枚举类型，参数或者是另外一个整型常量表达式或是是一个浮点型常量。<br>
<br>
</span><span lang="EN-US">9. The result of applying a binary operator to two 
integral constant expressions:<br>
</span><span style="font-family: SimSun;">9.对两个整型常量表达式进行二元操作的结果：</span><span lang="EN-US"><br>
     </span><code><span style="font-size: 10pt;" lang="EN-US">INTEGRAL_CONSTANT1 
op INTEGRAL_CONSTANT2 </span></code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;" lang="EN-US"><br>
     <code></code></span><span lang="EN-US">provided that the operator is not an 
assignment operator, or comma operator.<br>
该操作符不是赋值或逗号运算符。<br>
<br>
</span><span lang="EN-US">10. The result of applying a unary operator to an 
integral constant expression: </span><span style="font-family: SimSun;"><br>
10.对一个整型常量表达式进行一元操作的结果：</span><span lang="EN-US"><br>
     </span><code><span style="font-size: 10pt;" lang="EN-US">op 
INTEGRAL_CONSTANT1</span></code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;" lang="EN-US"><br>
     </span><span lang="EN-US">provided that the operator is not the increment 
or decrement operator.</span><span style="font-family: SimSun;"><br>
该操作符不是增量或递减运算符。</span><ol start="1" type="1">
 
 
 
 
 
 
 
 
 
</ol>

<p><span lang="EN-US">&nbsp;</span></p>

<h3><span lang="EN-US">Coding Guidelines</span><span style="font-family: SimSun;"></span></h3>
<h3><span style="font-family: SimSun;">编码指南</span></h3>


<p><span lang="EN-US">The following guidelines are declared in no particular 
order (in other words you need to obey all of them - sorry!), and may also be 
incomplete, more guidelines may be added as compilers change and/or more 
problems are encountered.</span><span style="font-family: SimSun;"><br>
下面的指南声明没有先后顺序</span><span lang="EN-US">(</span><span style="font-family: SimSun;">换言之你要遵守所有的约定</span><span lang="EN-US">)</span><span style="font-family: SimSun;">，可能这些指南并不完整，当编译器发生变化或遇到更多的问题时，将添加更多的指南。</span></p>

<p><b><i><span lang="EN-US">When declaring constants that are class members 
always use the macro BOOST_STATIC_CONSTANT.<br>
</span></i></b><b><i><span style="font-family: SimSun;">当声明的常量作为类成员时总是使用宏</span><span lang="EN-US">BOOST_STATIC_CONSTANT</span></i></b></p>

<pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct myclass</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_CONSTANT(int, value = sizeof(T));</span></pre><pre><span lang="EN-US">};</span></pre>

<p style=""><span lang="EN-US">Rationale: not all compilers support inline 
initialisation of member constants, others treat member enumerators in strange 
ways (they&#39;re not always treated as integral constant expressions). The 
BOOST_STATIC_CONSTANT macro uses the most appropriate method for the compiler in 
question.</span><span style="font-family: SimSun;"><br>
理由：不是所有的编译器都支持成员常量的内联初始化，其它一些编译器对待枚举成员的方式很奇特（并不总是把它们看作常量表达式）</span><span lang="EN-US">BOOST_STATIC_CONSTANT</span><span style="font-family: SimSun;">宏在这个问题上对编译器使用最合适的解决方法。</span></p>

<p style=""><b><i><span lang="EN-US">Don&#39;t declare integral constant expressions 
whose type is wider than int.</span></i></b><b><i><span style="font-family: SimSun;"><br>
不要声明整数常量表达式，它的类型范围比</span><span lang="EN-US">int</span></i></b><b><i><span style="font-family: SimSun;">型更宽</span></i></b></p>

<p style=""><span lang="EN-US">Rationale: while in theory all integral types are 
usable in integral constant expressions, in practice many compilers limit 
integral constant expressions to types no wider than <b>int</b>.</span><span style="font-family: SimSun;"><br>
理由：理论上所有的整数类型都可以用于整数表达式，实际上很多编译器限制整数常量表达式的范围不超过</span><span lang="EN-US">int</span><span style="font-family: SimSun;">型。</span></p>

<p style=""><b><i><span lang="EN-US">Don&#39;t use logical operators in integral 
constant expressions; use template meta-programming instead.</span></i></b><b><i><span style="font-family: SimSun;"><br>
在整数常量表达式中不要使用逻辑操作符，使用模板元编程代替。</span></i></b></p>

<p style=""><span lang="EN-US">The header &lt;boost/type_traits/ice.hpp&gt; contains a 
number of workaround templates, that fulfil the role of logical operators, for 
example instead of:</span><span style="font-family: SimSun;"><br>
头文件</span><span lang="EN-US">&lt;boost/type_traits/ice.hpp&gt;</span><span style="font-family: SimSun;">包含了一些模板的可行方案，它们实现了逻辑操作符的作用，如代替：</span></p>

<p style=""><code><span style="font-size: 10pt;" lang="EN-US">INTEGRAL_CONSTANT1 
|| INTEGRAL_CONSTANT2</span></code></p>

<p style=""><span lang="EN-US">Use:</span><span style="font-family: SimSun;"><br>
使用：</span></p>

<p style=""><code><span style="font-size: 10pt;" lang="EN-US">
::boost::type_traits::ice_or&lt;INTEGRAL_CONSTANT1,INTEGRAL_CONSTANT2&gt;::value</span></code></p>

<p style=""><span lang="EN-US">Rationale: A number of compilers (particularly 
the Borland and Microsoft compilers), tend to not to recognise integral constant 
expressions involving logical operators as genuine integral constant 
expressions. The problem generally only shows up when the integral constant 
expression is nested deep inside template code, and is hard to reproduce and 
diagnose.</span><span style="font-family: SimSun;"><br>
理由：有些编译器</span><span lang="EN-US">(</span><span style="font-family: SimSun;">特别是</span><span lang="EN-US">Borland</span><span style="font-family: SimSun;">和微软的编译器</span><span lang="EN-US">)</span><span style="font-family: SimSun;">，它们倾向于不把包含逻辑操作的整型常量表达式作为真正的整型常量表达式。当整型常量表达式在模板代码中嵌套很深时，这个问题变会浮现出来，而且很难复制和诊断。</span></p>

<p style=""><b><i><span lang="EN-US">Don&#39;t use any operators in an integral 
constant expression used as a non-type template parameter</span></i></b><b><i><span style="font-family: SimSun;"><br>
不要使用任何操作符，当整型常量表达式作为一个非类型模板参数时</span></i></b></p>

<p style=""><span lang="EN-US">Rather than:</span><span style="font-family: SimSun;"><br>
而不是：</span></p>

<p style=""><code><span style="font-size: 10pt;" lang="EN-US">typedef 
myclass&lt;INTEGRAL_CONSTANT1 == INTEGRAL_CONSTANT2&gt; mytypedef;</span></code></p>

<p style=""><span lang="EN-US">Use:</span><span style="font-family: SimSun;"><br>
使用：</span></p>

<p style=""><code><span style="font-size: 10pt;" lang="EN-US">typedef myclass&lt; 
some_symbol&gt; mytypedef;</span></code></p>

<p style=""><span lang="EN-US">Where </span><code><span style="font-size: 10pt;" lang="EN-US">
some_symbol</span></code><span lang="EN-US"> is the symbolic name of a an 
integral constant expression whose value is </span><code><span style="font-size: 10pt;" lang="EN-US">
(INTEGRAL_CONSTANT1 == INTEGRAL_CONSTANT2).</span></code><code><span style="font-size: 10pt; font-family: SimSun;"><br>
这里</span></code><code><span style="font-size: 10pt;" lang="EN-US">some_symbol </span></code><code><span style="font-size: 10pt; font-family: SimSun;">
是整数常量表达式的符号名，它的值是</span></code><code><span style="font-size: 10pt;" lang="EN-US">(INTEGRAL_CONSTANT1 
== INTEGRAL_CONSTANT2)</span></code><code><span style="font-size: 10pt; font-family: SimSun;">。</span></code></p>

<p style=""><span lang="EN-US">Rationale: the older EDG based compilers (some of 
which are used in the most recent version of that platform&#39;s compiler), don&#39;t 
recognise expressions containing operators as non-type template parameters, even 
though such expressions can be used as integral constant expressions elsewhere.</span><span style="font-family: SimSun;"><br>
理由：老的基于</span><span lang="EN-US">EDG</span><span style="font-family: SimSun;">的编译器（它们其中的一些用于最新版本的平台编译器中），并不是别包含操作符的表达式作为非类型的模板参数，尽管一些表达式被用于整型常量表达式或其它。</span></p>

<p style=""><b><i><span lang="EN-US">Always use a fully qualified name to refer 
to an integral constant expression.</span></i></b><b><i><span style="font-family: SimSun;"><br>
总是使用一个完全合格的名字声明一个整数常量表达式</span></i></b></p>

<p style=""><span lang="EN-US">For example:<br>
</span><span style="font-family: SimSun;">例如：</span></p>

<pre><code><span lang="EN-US">typedef</span></code><span lang="EN-US"> myclass&lt; ::boost::is_integral&lt;some_type&gt;::value&gt; mytypedef;</span></pre>

<p style=""><span lang="EN-US">Rationale: at least one compiler (Borland&#39;s), 
doesn&#39;t recognise the name of a constant as an integral constant expression 
unless the name is fully qualified (which is to say it starts with ::).</span><span style="font-family: SimSun;"><br>
理由：至少一个编译器</span><span lang="EN-US">(Borland),</span><span style="font-family: SimSun;">不能识别积分常量表达式的名字，除非该名字是完全合格的</span><span lang="EN-US">(</span><span style="font-family: SimSun;">总是以</span><span lang="EN-US">::</span><span style="font-family: SimSun;">开头</span><span lang="EN-US">)</span></p>

<p style=""><b><i><span lang="EN-US">Always leave a space after a &#39;&lt;&#39; and before 
&#39;::&#39;</span></i></b><b><i><span style="font-family: SimSun;"><br>
在</span><span lang="EN-US">&#39;&lt;&#39;</span></i></b><b><i><span style="font-family: SimSun;">之后和</span><span lang="EN-US">&#39;::&#39;</span></i></b><b><i><span style="font-family: SimSun;">之前总是有一个空格</span></i></b></p>

<p style=""><span lang="EN-US">For example:</span><span style="font-family: SimSun;"><br>
例如：</span></p>

<pre><code><span lang="EN-US">typedef</span></code><span lang="EN-US"> myclass&lt; ::boost::is_integral&lt;some_type&gt;::value&gt; mytypedef;</span></pre><pre><span lang="EN-US"><span style="">                </span>^</span></pre><pre><span lang="EN-US"><span style="">                </span>ensure there is space here!<br>		     </span><span style="font-family: SimSun;">确保这里有一个空格</span></pre>

<p style=""><span lang="EN-US">Rationale: &lt;: is a legal digraph in it&#39;s own 
right, so &lt;:: is interpreted as the same as [:.<br>
</span><span style="font-family: SimSun;">理由：</span><span lang="EN-US">&lt;:</span><span style="font-family: SimSun;">是一个合法的合体字符，它拥有自己的意义，因此</span><span lang="EN-US">&lt;::</span><span style="font-family: SimSun;">被理解为</span><span lang="EN-US">[:.</span></p>

<p style=""><b><i><span lang="EN-US">Don&#39;t use local names as integral constant 
expressions</span></i></b><b><i><span style="font-family: SimSun;"><br>
不要使用局部名字命名整数常量表达式</span></i></b></p>

<p style=""><span lang="EN-US">Example:</span><span style="font-family: SimSun;"><br>
例如：</span></p>

<pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct foobar</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_CONSTANT(int, temp = computed_value);</span></pre><pre><span lang="EN-US"><span style="">   </span>typedef myclass&lt;temp&gt; mytypedef;<span style="">  </span>// error</span></pre><pre><span lang="EN-US">};</span></pre>

<p style=""><span lang="EN-US">Rationale: At least one compiler (Borland&#39;s) 
doesn&#39;t accept this.</span><span style="font-family: SimSun;"><br>
理由：至少一个编译器</span><span lang="EN-US">(Borland)</span><span style="font-family: SimSun;">不接受这种情况。</span></p>

<p style=""><span lang="EN-US">Although it is possible to fix this by using:</span><span style="font-family: SimSun;"><br>
尽管可以使用如下方式修正该</span><span lang="EN-US">bug</span><span style="font-family: SimSun;">：</span></p>

<pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct foobar</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_CONSTANT(int, temp = computed_value);</span></pre><pre><span lang="EN-US"><span style="">   </span>typedef foobar self_type;</span></pre><pre><span lang="EN-US"><span style="">   </span>typedef myclass&lt;(self_type::temp)&gt; mytypedef;<span style="">  </span>// OK</span></pre><pre><span lang="EN-US">};</span></pre>

<p style=""><span lang="EN-US">This breaks at least one other compiler (VC6), it 
is better to move the integral constant expression computation out into a 
separate traits class:<br>
</span><span style="font-family: SimSun;">这在至少一种编译器中将出现问题</span><span lang="EN-US">(VC6),</span><span style="font-family: SimSun;">最好把整数常量表达式的计算移到一个单独的</span><span lang="EN-US">traits</span><span style="font-family: SimSun;">类中：</span></p>

<pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct foobar_helper</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_CONSTANT(int, temp = computed_value);</span></pre><pre><span lang="EN-US">};</span></pre><pre><span lang="EN-US"><o:p>&nbsp;</o:p></span></pre><pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct foobar</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US"><span style="">   </span>typedef myclass&lt; ::foobar_helper&lt;T&gt;::value&gt; mytypedef;<span style="">  </span>// OK</span></pre><pre><span lang="EN-US">};</span></pre>

<p style=""><b><i><span lang="EN-US">Don&#39;t use dependent default parameters for 
non-type template parameters.</span></i></b><b><i><span style="font-family: SimSun;"><br>
不要使用依赖型的默认参数作为非类型模板参数</span></i></b></p>

<p style=""><span lang="EN-US">For example:</span><span style="font-family: SimSun;"><br>
例如：</span></p>

<pre><span lang="EN-US">template &lt;class T, int I = ::boost::is_integral&lt;T&gt;::value&gt;<span style="">  </span>// Error can&#39;t deduce value of I in some cases.</span><span style="font-family: SimSun;">错误，在一些情况下不能推断</span><span lang="EN-US">I</span><span style="font-family: SimSun;">的值</span></pre><pre><span lang="EN-US">struct foobar;</span></pre>

<p style=""><span lang="EN-US">Rationale: this kind of usage fails for Borland 
C++. Note that this is only an issue where the default value is dependent upon a 
previous template parameter, for example the following is fine:</span><span style="font-family: SimSun;"><br>
理由：这种用法在</span><span lang="EN-US">Broland C++</span><span style="font-family: SimSun;">中失效。注意这仅仅是一种默认值依赖前一个模板参数的情况，下面的例子是正确的：</span></p>

<pre><span lang="EN-US">template &lt;class T, int I = 3&gt;<span style="">  </span>// OK, default value is not dependent</span><span style="font-family: SimSun;">   正确，默认值没有依赖</span></pre><pre><span lang="EN-US">struct foobar;</span></pre>

<p style=""><span lang="EN-US">&nbsp;</span></p>

<h3 style=""><span lang="EN-US">Unresolved Issues</span></h3>
<h3 style=""><span lang="EN-US"></span><span style="font-family: SimSun;">
尚未解决的问题</span></h3>


<p style=""><span lang="EN-US">The following issues are either unresolved or 
have fixes that are compiler specific, and/or break one or more of the coding 
guidelines.</span><span style="font-family: SimSun;"><br>
下面这些问题或者是尚未解决的问题或者是已经修复的编译器相关的问题，或者是违反了一条或多条编码规范。</span></p>

<p style=""><b><i><span lang="EN-US">Be careful of numeric_limits</span></i></b><b><i><span style="font-family: SimSun;"><br>
小心</span><span lang="EN-US"> numeric_limits</span></i></b></p>

<p style=""><span lang="EN-US">There are three issues here:</span><span style="font-family: SimSun;"><br>
这里有三个问题：</span></p><span lang="EN-US">1. The header &lt;limits&gt; may be absent - it 
is recommended that you never include &lt;limits&gt; directly but use &lt;boost/pending/limits.hpp&gt; 
instead. This header includes the &quot;real&quot; &lt;limits&gt; header if it is available, 
otherwise it supplies it&#39;s own std::numeric_limits definition. Boost also 
defines the macro BOOST_NO_LIMITS if &lt;limits&gt; is absent.<br>
<br>
</span><span lang="EN-US"></span><span style="font-family: SimSun;">1.头文件</span><span lang="EN-US">&lt;limits&gt;</span><span style="font-family: SimSun;">可能不存在</span><span lang="EN-US">-</span><span style="font-family: SimSun;">不推荐你使用</span><span lang="EN-US">&lt;limits&gt;</span><span style="font-family: SimSun;">，直接使用</span><span lang="EN-US">&lt;boost/pending/limits.hpp&gt;</span><span style="font-family: SimSun;">代替。这个头文件包括“真正”的</span><span lang="EN-US">&lt;limits&gt;</span><span style="font-family: SimSun;">如果该文件可用，否则它提供自己的</span><span lang="EN-US">std::numeric_limits</span><span style="font-family: SimSun;">定义。</span><span lang="EN-US">Boost </span><span style="font-family: SimSun;">
也定义了宏</span><span lang="EN-US">BOOST_NO_LIMITS</span><span style="font-family: SimSun;">如果</span><span lang="EN-US">&lt;limits&gt;</span><span style="font-family: SimSun;">不存在。<br>
<br>
</span><span lang="EN-US">2.The implementation of std::numeric_limits may be 
defined in such a way that its static-const members may not be usable as 
integral constant expressions. This contradicts the standard but seems to be a 
bug that affects at least two standard library vendors; boost defines 
BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS in &lt;boost/config.hpp&gt; when this is the 
case.<br>
<br>
&nbsp;2.std::numeric_limits</span><span style="font-family: SimSun;">的实现可能定义成静态常量成员，不能够作为整数常量表达式。这一方式和标准冲突类似一个</span><span lang="EN-US">bug</span><span style="font-family: SimSun;">至少影响两个标准库厂商；当出现这种情况时，</span><span lang="EN-US">boost</span><span style="font-family: SimSun;">在</span><span lang="EN-US">&lt;boost/config.hpp&gt;</span><span style="font-family: SimSun;">中定义</span><span lang="EN-US">BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS <br>
<br>
</span><span lang="EN-US">3.There is a strange bug in VC6, where the members of 
std::numeric_limits can be &quot;prematurely evaluated&quot; in template code, for 
example:<br>
<br>
</span><span style="font-family: SimSun;">3.在</span><span lang="EN-US">VC6</span><span style="font-family: SimSun;">中有一个奇怪的</span><span lang="EN-US">bug</span><span style="font-family: SimSun;">，</span><span lang="EN-US">std::numeric_limits</span><span style="font-family: SimSun;">中的成员在模板代码中被“过早的执行&quot;，如：</span><ol start="1" type="1">
 
 
 
</ol>

<pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct limits_test</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_ASSERT(::std::numeric_limits&lt;T&gt;::is_specialized);</span></pre><pre><span lang="EN-US">};</span></pre>

<p style=""><span lang="EN-US">This code fails to compile with VC6 even though 
no instances of the template are ever created; for some bizarre reason </span><code><span style="font-size: 10pt;" lang="EN-US">
::std::numeric_limits&lt;T&gt;::is_specialized
</span></code><span lang="EN-US">always evaluates to false, irrespective of what 
the template parameter T is. The problem seems to be confined to expressions 
which depend on std::numeric_limts: for example if you replace </span><code><span style="font-size: 10pt;" lang="EN-US">
::std::numeric_limits&lt;T&gt;::is_specialized</span></code><span lang="EN-US"> with </span><code><span style="font-size: 10pt;" lang="EN-US">
::boost::is_arithmetic&lt;T&gt;::value</span></code><span lang="EN-US">, then 
everything is fine. The following workaround also works but conflicts with the 
coding guidelines:</span><span style="font-family: SimSun;"><br>
这段代码在</span><span lang="EN-US">VC6</span><span style="font-family: SimSun;">中编译失败，尽管没有模板实例被创建；因为一些奇异的原因</span><code><span style="font-size: 10pt;" lang="EN-US">::std::numeric_limits&lt;T&gt;::is_specialized
</span></code><code><span style="font-size: 10pt; font-family: SimSun;">总是被执行为</span></code><code><span style="font-size: 10pt;" lang="EN-US">false</span></code><code><span style="font-size: 10pt; font-family: SimSun;">，无论模板参数是多少。下面的变通方案是可行的，但是和编码规则有冲突：</span></code></p>

<pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct limits_test</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_CONSTANT(bool, check = ::std::numeric_limits&lt;T&gt;::is_specialized);</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_ASSERT(check);</span></pre><pre><span lang="EN-US">};</span></pre>

<p style=""><span lang="EN-US">So it is probably best to resort to something 
like this:</span><span style="font-family: SimSun;"><br>
因此可能最好的方案是求助于如下的示例：</span></p>

<pre><span lang="EN-US">template &lt;class T&gt;</span></pre><pre><span lang="EN-US">struct limits_test</span></pre><pre><span lang="EN-US">{</span></pre><pre><span lang="EN-US">#ifdef BOOST_MSVC</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_CONSTANT(bool, check = ::std::numeric_limits&lt;T&gt;::is_specialized);</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_ASSERT(check);</span></pre><pre><span lang="EN-US">#else</span></pre><pre><span lang="EN-US"><span style="">   </span>BOOST_STATIC_ASSERT(::std::numeric_limits&lt;T&gt;::is_specialized);</span></pre><pre><span lang="EN-US">#endif</span></pre><pre><span lang="EN-US">};</span></pre>

<p style=""><b><i><span lang="EN-US">Be careful how you use the sizeof operator</span></i></b><b><i><span style="font-family: SimSun;"><br>
小心看你如何使用</span><span lang="EN-US">sizeof</span></i></b><b><i><span style="font-family: SimSun;">操作符</span></i></b></p>

<p style=""><span lang="EN-US">As far as I can tell, all compilers treat sizeof 
expressions correctly when the argument is the name of a type (or a 
template-id), however problems can occur if:<br>
</span><span style="font-family: SimSun;">我能告诉你的是，所有的编译器能够正确对待</span><span lang="EN-US">sizeof</span><span style="font-family: SimSun;">表达式，当参数是类型名（或者模板</span><span lang="EN-US">id</span><span style="font-family: SimSun;">）的时候，然而如下情形可能产生错误：</span></p>

<span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.The argument is 
the name of a member-variable, or a local variable (code may not compile with 
VC6).</span><span style="font-family: SimSun;"></span><br>
<span style="font-family: SimSun;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
1.参数是成员变量的名字，或者局部变量（</span><span lang="EN-US">VC6</span><span style="font-family: SimSun;">下的代码可能编译不能通过）<br>
<br>
</span><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.The 
argument is an expression which involves the creation of a temporary (code will 
not compile with Borland C++).</span><span style="font-family: SimSun;"></span><br>
<span style="font-family: SimSun;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
2.参数是一个表达式，它包含临时变量的产生（</span><span lang="EN-US">Borland C++</span><span style="font-family: SimSun;">下的代码可能编译不能通过）<br>
<br>
</span><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.The 
argument is an expression involving an overloaded function call (code compiles 
but the result is a garbage value with Metroworks C++).</span><span style="font-family: SimSun;"></span><br>
<span style="font-family: SimSun;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
3.参数是一个包含重载函数的调用的表达式（</span><span lang="EN-US">Metroworks C++</span><span style="font-family: SimSun;">能够编译通过，但是结果是一个垃圾值）</span><ol start="1" type="1">
 
 
 
</ol>

<p style=""><b><i><span lang="EN-US">Don&#39;t use boost::is_convertible unless you 
have to</span></i></b><b><i><span style="font-family: SimSun;"><br>
不使用</span><span lang="EN-US">boost::is_convertible</span></i></b><b><i><span style="font-family: SimSun;">，除非你不得不用的时候</span></i></b></p>

<p style=""><span lang="EN-US">Since is_convertible is implemented in terms of 
the sizeof operator, it consistently gives the wrong value when used with the 
Metroworks compiler, and may not compile with the Borland&#39;s compiler (depending 
upon the template arguments used).</span><span style="font-family: SimSun;"><br>
因为</span><span lang="EN-US">is_convertible</span><span style="font-family: SimSun;">的实现依赖于</span><span lang="EN-US">sizeof</span><span style="font-family: SimSun;">操作符，当使用</span><span lang="EN-US">Metroworks</span><span style="font-family: SimSun;">编译器的时候，它总是给出错误的结果，可能在</span><span lang="EN-US">Borland’s</span><span style="font-family: SimSun;">的编译器中也不能编译通过</span><span lang="EN-US">(</span><span style="font-family: SimSun;">取决于使用的模板参数</span><span lang="EN-US">).</span></p>

<div class="MsoNormal" style="text-align: center;" align="center"><span lang="EN-US">

<hr align="center" size="2" width="100%">

</span></div>

<p style=""><i><span lang="EN-US">© Copyright Dr John Maddock 2001</span></i></p>

<p style=""><i><span lang="EN-US">Distributed under the Boost Software License, 
Version 1.0. (See accompanying file <a href="../LICENSE_1_0.txt">LICENSE_1_0.txt</a> 
or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)</span></i></p>

<DIV class=Section1>
<div class="Section1">
<i><span style="font-family: Arial;" lang="EN-US"> 中文版修订：2009/11/05<br>
<br>
Copyright © 2009 shomnia<br>
<br>
在 Boost Software License, Version 1.0 的条款下发布。(参看文件&nbsp;</span></i><a href="file:///Volumes/%C3%B0%E2%94%AC%E2%95%9DE%CC%88%C2%A5Y%CC%81/LICENSE_1_0.txt" style="color: blue; text-decoration: none; text-underline: none; text-line-through: none">
            LICENSE_1_0.txt</a><i><span style="font-family: Arial;" lang="EN-US"> 
或在线副本  
<a href="http://www.boost.org/LICENSE_1_0.txt" style="color: blue; text-decoration: none; text-underline: none; text-line-through: none">
http://www.boost.org/LICENSE_1_0.txt</a>) </span></i>
</div></DIV>

</div>

</body></html>
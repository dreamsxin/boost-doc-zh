<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>FAQ</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../boost_units.html" title="Chapter 22. Boost.Units 1.0.0">
<link rel="prev" href="Installation.html" title="Installation">
<link rel="next" href="Acknowledgements.html" title="Acknowledgements">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="Installation.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../boost_units.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="Acknowledgements.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_units.FAQ"></a><a class="link" href="FAQ.html" title="FAQ"> FAQ</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="FAQ.html#boost_units.FAQ.Distinguishing_Quantities_With_Same_Units">
      How does one distinguish between quantities that are physically different but
      have the same units (such as energy and torque)?</a></span></dt>
<dt><span class="section"><a href="FAQ.html#boost_units.FAQ.Angle_Are_Units"> Angles are treated
      as units</a></span></dt>
<dt><span class="section"><a href="FAQ.html#boost_units.FAQ.Why_Homogeneous_Systems"> Why are there
      homogeneous systems? Aren't heterogeneous systems sufficient?</a></span></dt>
<dt><span class="section"><a href="FAQ.html#boost_units.FAQ.NoConstructorFromValueType"> Why can't
      I construct a quantity directly from the value type?</a></span></dt>
<dt><span class="section"><a href="FAQ.html#boost_units.FAQ.ExplicitConversions"> Why are conversions
      explicit by default?</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_units.FAQ.Distinguishing_Quantities_With_Same_Units"></a><a class="link" href="FAQ.html#boost_units.FAQ.Distinguishing_Quantities_With_Same_Units" title="How does one distinguish between quantities that are physically different but have the same units (such as energy and torque)?">
      How does one distinguish between quantities that are physically different but
      have the same units (such as energy and torque)?
      <br />
      对于物理上不同但实际上拥有相同的单位的数量进行分析(例如能量和力矩)</a>
</h3></div></div></div>
<p>
        Because Boost.Units includes plane and solid angle units in the SI system,
        torque and energy are, in fact, distinguishable (see <a href="http://en.wikipedia.org/wiki/SI_units" target="_top">torque</a>).
        In addition, energy is a true <a href="http://mathworld.wolfram.com/Scalar.html" target="_top">scalar</a>
        quantity, while torque, despite having the same units as energy if plane
        angle is not included, is in fact a <a href="http://mathworld.wolfram.com/Pseudovector.html" target="_top">pseudovector</a>.
        Thus, a value type representing pseudovectors and encapsulating their algebra
        could also be implemented.
        <br />
        因为Boost.Units包含SI系统中平面和立体的角度单位，所以实际上，力矩和能量是可分辨的(见<a href="http://en.wikipedia.org/wiki/SI_units" target="_top">力矩(torque)</a>)。
        实际上，能量(energy)是一个纯粹的<a href="http://mathworld.wolfram.com/Scalar.html" target="_top">标量(scalar)</a>，而力矩(torque)虽然如果不包含平面角度的话拥有与能量相同的单位，但实际上是<a href="http://mathworld.wolfram.com/Pseudovector.html" target="_top">伪矢量(pseudovector)</a>。
        于是，一个表示伪矢量并封装其代数运算的数值类型是可以被实现的。
      </p>
<p>
        There are, however, a few SI units that are dimensionally indistinguishable
        within the SI system. These include the <a href="http://en.wikipedia.org/wiki/Becquerel" target="_top">becquerel</a>,
        which has units identical to frequency (Hz), and the <a href="http://en.wikipedia.org/wiki/Sievert" target="_top">sievert</a>,
        which is degenerate with the <a href="http://en.wikipedia.org/wiki/Gray_%28unit%29" target="_top">gray</a>.
        In cases such as this, the proper way to treat this difference is to recognize
        that expanding the set of base dimensions can provide disambiguation. For
        example, adding a base dimension for radioactive decays would allow the becquerel
        to be written as decays/second, differentiating it from the signature of
        hertz, which is simply 1/second.
        <br />
        确实是有一些SI单位的量纲是无法区分的。
        这其中包括<a href="http://en.wikipedia.org/wiki/Becquerel" target="_top">贝克(becquerel)</a>，和频率的单位是一样的(Hz)，又比如<a href="http://en.wikipedia.org/wiki/Sievert" target="_top">sievert</a>，is degenerate with the <a href="http://en.wikipedia.org/wiki/Gray_%28unit%29" target="_top">gray</a>(???)。
        这种情况下，对待这种差异的合适方法是识别和增加基础量纲来消除这种模棱两可的情况。
        例如，增加一种放射衰减的基础量纲可以使得贝克(becquerel)被写成decays/second，用来区分赫兹(hertz)，1/second。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_units.FAQ.Angle_Are_Units"></a><a class="link" href="FAQ.html#boost_units.FAQ.Angle_Are_Units" title="Angles are treated as units"> Angles are treated
      as units
      <br />
      角度被当成单位</a>
</h3></div></div></div>
<p>
        If you don't like this, you can just ignore the angle units and go on your
        merry way (periodically screwing up when a routine wants degrees and you
        give it radians instead...)
        <br />
        如果你不喜欢，就忽略它好了(当需要角度而你给了弧度的时候再想起好了...)
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_units.FAQ.Why_Homogeneous_Systems"></a><a class="link" href="FAQ.html#boost_units.FAQ.Why_Homogeneous_Systems" title="Why are there homogeneous systems? Aren't heterogeneous systems sufficient?"> Why are there
      homogeneous systems? Aren't heterogeneous systems sufficient?
      <br />
      为什么存在同构系统？异构系统不是足够了吗？</a>
</h3></div></div></div>
<p>
        Consider the following code:
        <br />
        考虑下面的代码：
      </p>
<pre class="programlisting"><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">sin</span><span class="special">(</span><span class="identifier">asin</span><span class="special">(</span><span class="number">180.0</span> <span class="special">*</span> <span class="identifier">degrees</span><span class="special">));</span>
</pre>
<p>
        What should this print? If only heterogeneous systems are available it would
        print 3.14159+ rad Why? Well, <code class="computeroutput"><span class="identifier">asin</span></code>
        would return a <code class="computeroutput"><span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">dimensionless</span><span class="special">&gt;</span></code>
        effectively losing the information that degrees are being used. In order
        to propogate this extra information we need homogeneous systems.
        <br />
        应该打印什么呢？如果只有异构系统，那么应该打印3.14159+ rad，不是吗？
        <code class="computeroutput"><span class="identifier">asin</span></code>应该返回<code class="computeroutput"><span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">dimensionless</span><span class="special">&gt;</span></code>，丢失了角度的信息。
        为了传递这个额外的信息我们需要同构系统。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_units.FAQ.NoConstructorFromValueType"></a><a class="link" href="FAQ.html#boost_units.FAQ.NoConstructorFromValueType" title="Why can't I construct a quantity directly from the value type?"> Why can't
      I construct a quantity directly from the value type?
      <br />
      为什么不能直接从数值类型构造数量</a>
</h3></div></div></div>
<p>
        This only breaks generic code--which ought to break anyway. The only literal
        value that ought to be converted to a quantity by generic code is zero, which
        should be handled by the default constructor. In addition, consider the search
        and replace problem allowing this poses:
        <br />
        这会中断泛型代码--本应该中断所有。泛型代码唯一接受的字面数值是0，被默认构造函数处理。另外，看一下下面的搜索和替换问题：
      </p>
<pre class="programlisting"><span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">&gt;</span>    <span class="identifier">q</span><span class="special">(</span><span class="number">1.0</span><span class="special">);</span>
</pre>
<p>
        Here, the intent is clear - we want a length of one in the SI system, which
        is one meter. However, imagine some well-intentioned coder attempting to
        reuse this code, but to have it perform the calculations in the CGS unit
        system instead. After searching for <code class="computeroutput"><span class="identifier">si</span><span class="special">::</span></code> and replacing it with <code class="computeroutput"><span class="identifier">cgs</span><span class="special">::</span></code> , we have:
        <br />
        意图很明显 - 我们需要一个SI系统的长度，也就是1米。但是，想象一下，当有人想用重用这段代码，但需要用CGS单位系统替代。
        用<code class="computeroutput"><span class="identifier">cgs</span><span class="special">::</span></code>替换了<code class="computeroutput"><span class="identifier">si</span><span class="special">::</span></code>以后：
      </p>
<pre class="programlisting"><span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">cgs</span><span class="special">::</span><span class="identifier">length</span><span class="special">&gt;</span>	<span class="identifier">q</span><span class="special">(</span><span class="number">1.0</span><span class="special">);</span>
</pre>
<p>
        Unfortunately, the meaning of this statement has suddenly changed from one
        meter to one centimeter. In contrast, as implemented, we begin with:
        <br />
        不幸的是，这段代码的意义变了，从1米变成了1分米。相反，就像现在实现的，我们这样写：
      </p>
<pre class="programlisting"><span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">&gt;</span>	<span class="identifier">q</span><span class="special">(</span><span class="number">1.0</span><span class="special">*</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">meter</span><span class="special">);</span>
</pre>
<p>
        and, after search and replace:
        <br />
        经过搜索和替换后：
      </p>
<pre class="programlisting"><span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">cgs</span><span class="special">::</span><span class="identifier">length</span><span class="special">&gt;</span>	<span class="identifier">q</span><span class="special">(</span><span class="number">1.0</span><span class="special">*</span><span class="identifier">cgs</span><span class="special">::</span><span class="identifier">meter</span><span class="special">);</span>
</pre>
<p>
        which gives us an error. Even if the code has a @using namespace boost::units::si;
        declaration, the latter is still safe, with:
        <br />
        会有一个编译错误。即使是使用@using namespace boost::units::si;声明的代码，也是安全的：
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">units</span><span class="special">::</span><span class="identifier">si</span><span class="special">;</span>
<span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">length</span><span class="special">&gt;</span>	<span class="identifier">q</span><span class="special">(</span><span class="number">1.0</span><span class="special">*</span><span class="identifier">meter</span><span class="special">);</span>
</pre>
<p>
        going to
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">units</span><span class="special">::</span><span class="identifier">cgs</span><span class="special">;</span>
<span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">length</span><span class="special">&gt;</span>	<span class="identifier">q</span><span class="special">(</span><span class="number">1.0</span><span class="special">*</span><span class="identifier">meter</span><span class="special">);</span>
</pre>
<p>
        The latter will involve an explicit conversion from meters to centimeters,
        but the value remains correct.
        <br />
        会导致一个从米到分米的显式转换，但值仍然是正确的。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_units.FAQ.ExplicitConversions"></a><a class="link" href="FAQ.html#boost_units.FAQ.ExplicitConversions" title="Why are conversions explicit by default?"> Why are conversions
    explicit by default?
    <br />
    为什么转换默认为显式的？</a>
</h3></div></div></div>
<p>
        Safety and the potential for unintended conversions leading to precision
        loss and hidden performance costs. Options are provided for forcing implicit
        conversions between specific units to be allowed.
        <br />
        安全，防止无意间的精度损失，防止性能损失。提供选项使得特定单位之间的显式转换被允许。
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2003 -2008 Matthias Christian Schabel, 2007-2008 Steven
      Watanabe<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="Installation.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../boost_units.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="Acknowledgements.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

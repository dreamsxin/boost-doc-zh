<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Class template unordered_multiset</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../unordered/reference.html#header.boost.unordered_set.hpp" title="Header &lt;boost/unordered_set.hpp&gt;">
<link rel="prev" href="unordered_set.html" title="Class template unordered_set">
<link rel="next" href="unordered_map.html" title="Class template unordered_map"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="unordered_set.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_set.hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_map.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.unordered_multiset"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template unordered_multiset</span></h2>
<p>boost::unordered_multiset — 
            An unordered associative container that stores  values. The same key can be stored multiple times.<br>boost::unordered_multiset — 
            保存值的无序关联式容器，相同的键值可以保存多次。
          </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis 概要</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash = <span class="type">boost::hash&lt;Value&gt;</span>, <br>         <span class="bold"><strong>typename</strong></span> Pred = <span class="type">std::equal_to&lt;Value&gt;</span>, <br>         <span class="bold"><strong>typename</strong></span> Alloc = <span class="type">std::allocator&lt;Value&gt;</span> &gt; <br><span class="bold"><strong>class</strong></span> <a class="link" href="unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a> {<br><span class="bold"><strong>public</strong></span>:<br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#boost.unordered_multisettypes">types</a></em></span>
  <span class="bold"><strong>typedef</strong></span> Value                                    <a name="boost.unordered_multiset.key_type"></a>key_type;            <br>  <span class="bold"><strong>typedef</strong></span> Value                                    <a name="boost.unordered_multiset.value_type"></a>value_type;          <br>  <span class="bold"><strong>typedef</strong></span> Hash                                     <a name="boost.unordered_multiset.hasher"></a>hasher;              <br>  <span class="bold"><strong>typedef</strong></span> Pred                                     <a name="boost.unordered_multiset.key_equal"></a>key_equal;           <br>  <span class="bold"><strong>typedef</strong></span> Alloc                                    <a name="boost.unordered_multiset.allocator_type"></a>allocator_type;      <br>  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::pointer         <a name="boost.unordered_multiset.pointer"></a>pointer;             <br>  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::const_pointer   <a name="boost.unordered_multiset.const_pointer"></a>const_pointer;       <br>  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::reference       <a name="boost.unordered_multiset.reference"></a>reference;             <span class="emphasis"><em>// lvalue of <span class="type">value_type</span>.</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="bold"><strong>typename</strong></span> allocator_type::const_reference <a name="boost.unordered_multiset.const_reference"></a>const_reference;       <span class="emphasis"><em>// const lvalue of <span class="type">value_type</span>.</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_multiset.html#boost.unordered_multiset.size_type">size_type</a>;<br>  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_multiset.html#boost.unordered_multiset.difference_type">difference_type</a>;<br>  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_multiset.html#boost.unordered_multiset.iterator">iterator</a>;<br>  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_multiset.html#boost.unordered_multiset.const_iterator">const_iterator</a>;<br>  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_multiset.html#boost.unordered_multiset.local_iterator">local_iterator</a>;<br>  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a class="link" href="unordered_multiset.html#boost.unordered_multiset.const_local_iterator">const_local_iterator</a>;<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#boost.unordered_multisetconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <span class="bold"><strong>explicit</strong></span> <a class="link" href="unordered_multiset.html#id3109784-bb">unordered_multiset</a>(size_type = <span class="emphasis"><em>implementation-defined</em></span>, <br>                              hasher <span class="bold"><strong>const</strong></span>&amp; = hasher(), <br>                              key_equal <span class="bold"><strong>const</strong></span>&amp; = key_equal(), <br>                              allocator_type <span class="bold"><strong>const</strong></span>&amp; = allocator_type());<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; <br>    <a class="link" href="unordered_multiset.html#id3109868-bb">unordered_multiset</a>(InputIterator, InputIterator, <br>                       size_type = implementation-defined, <br>                       hasher <span class="bold"><strong>const</strong></span>&amp; = hasher(), <br>                       key_equal <span class="bold"><strong>const</strong></span>&amp; = key_equal(), <br>                       allocator_type <span class="bold"><strong>const</strong></span>&amp; = allocator_type());<br>  <a class="link" href="unordered_multiset.html#id3129029-bb">unordered_multiset</a>(unordered_multiset <span class="bold"><strong>const</strong></span>&amp;);<br>  <span class="bold"><strong>explicit</strong></span> <a class="link" href="unordered_multiset.html#id3129050-bb">unordered_multiset</a>(Allocator <span class="bold"><strong>const</strong></span>&amp;);<br>  <a class="link" href="unordered_multiset.html#id3129078-bb">unordered_multiset</a>(unordered_multiset <span class="bold"><strong>const</strong></span>&amp;, Allocator <span class="bold"><strong>const</strong></span>&amp;);<br>  <a class="link" href="unordered_multiset.html#id3129119-bb">~unordered_multiset</a>();<br>  <span class="type">unordered_multiset&amp;</span> <a class="link" href="unordered_multiset.html#id3129122-bb"><span class="bold"><strong>operator</strong></span>=</a>(unordered_multiset <span class="bold"><strong>const</strong></span>&amp;);<br>  <span class="type">allocator_type</span> <a class="link" href="unordered_multiset.html#id3129150-bb">get_allocator</a>() <span class="bold"><strong>const</strong></span>;<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3129162-bb">size and capacity</a></em></span>
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_multiset.html#id3129167-bb">empty</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3129190-bb">size</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3129218-bb">max_size</a>() <span class="bold"><strong>const</strong></span>;<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3129241-bb">iterators</a></em></span>
  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3129250-bb">begin</a>();<br>  <span class="type">const_iterator</span> <a class="link" href="unordered_multiset.html#id3129255-bb">begin</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3129275-bb">end</a>();<br>  <span class="type">const_iterator</span> <a class="link" href="unordered_multiset.html#id3129283-bb">end</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">const_iterator</span> <a class="link" href="unordered_multiset.html#id3129300-bb">cbegin</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">const_iterator</span> <a class="link" href="unordered_multiset.html#id3129318-bb">cend</a>() <span class="bold"><strong>const</strong></span>;<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3129338-bb">modifiers</a></em></span>
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3129342-bb">emplace</a>(Args&amp;&amp;...);<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3129430-bb">emplace</a>(const_iterator, Args&amp;&amp;...);<br>  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3129541-bb">insert</a>(value_type <span class="bold"><strong>const</strong></span>&amp;);<br>  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3129604-bb">insert</a>(const_iterator, value_type <span class="bold"><strong>const</strong></span>&amp;);<br>  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_multiset.html#id3136384-bb">insert</a>(InputIterator, InputIterator);<br>  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3136461-bb">erase</a>(const_iterator);<br>  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3136526-bb">erase</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);<br>  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3136582-bb">erase</a>(const_iterator, const_iterator);<br>  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_multiset.html#id3136663-bb">clear</a>();<br>  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_multiset.html#id3136700-bb">swap</a>(unordered_multiset&amp;);<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3136753-bb">observers</a></em></span>
  <span class="type">hasher</span> <a class="link" href="unordered_multiset.html#id3136758-bb">hash_function</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">key_equal</span> <a class="link" href="unordered_multiset.html#id3136775-bb">key_eq</a>() <span class="bold"><strong>const</strong></span>;<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3136793-bb">lookup</a></em></span>
  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3136803-bb">find</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);<br>  <span class="type">iterator</span> <a class="link" href="unordered_multiset.html#id3136821-bb">find</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;<br>  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3136858-bb">count</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;<br>  <span class="type">std::pair&lt;iterator, iterator&gt;</span> <a class="link" href="unordered_multiset.html#id3136898-bb">equal_range</a>(key_type <span class="bold"><strong>const</strong></span>&amp;);<br>  <span class="type">std::pair&lt;const_iterator, const_iterator&gt;</span> <a class="link" href="unordered_multiset.html#id3136916-bb">equal_range</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3136967-bb">bucket interface</a></em></span>
  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3136972-bb">bucket_count</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3143752-bb">max_bucket_count</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3143773-bb">bucket_size</a>(size_type) <span class="bold"><strong>const</strong></span>;<br>  <span class="type">size_type</span> <a class="link" href="unordered_multiset.html#id3143820-bb">bucket</a>(key_type <span class="bold"><strong>const</strong></span>&amp;) <span class="bold"><strong>const</strong></span>;<br>  <span class="type">local_iterator</span> <a class="link" href="unordered_multiset.html#id3143870-bb">begin</a>(size_type);<br>  <span class="type">const_local_iterator</span> <a class="link" href="unordered_multiset.html#id3143888-bb">begin</a>(size_type) <span class="bold"><strong>const</strong></span>;<br>  <span class="type">local_iterator</span> <a class="link" href="unordered_multiset.html#id3143941-bb">end</a>(size_type);<br>  <span class="type">const_local_iterator</span> <a class="link" href="unordered_multiset.html#id3143959-bb">end</a>(size_type) <span class="bold"><strong>const</strong></span>;<br>  <span class="type">const_local_iterator</span> <a class="link" href="unordered_multiset.html#id3144007-bb">cbegin</a>(size_type) <span class="bold"><strong>const</strong></span>;<br>  <span class="type">const_local_iterator</span> <a class="link" href="unordered_multiset.html#id3144056-bb">cend</a>(size_type);<br><br>  <span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3144104-bb">hash policy</a></em></span>
  <span class="type"><span class="bold"><strong>float</strong></span></span> <a class="link" href="unordered_multiset.html#id3144109-bb">load_factor</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type"><span class="bold"><strong>float</strong></span></span> <a class="link" href="unordered_multiset.html#id3144130-bb">max_load_factor</a>() <span class="bold"><strong>const</strong></span>;<br>  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_multiset.html#id3144151-bb">max_load_factor</a>(<span class="bold"><strong>float</strong></span>);<br>  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_multiset.html#id3144183-bb">rehash</a>(size_type);<br>};<br><br><span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3144234-bb">Equality Comparisons</a></em></span>
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; <br>  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_multiset.html#boost.operator==_id3144238"><span class="bold"><strong>operator</strong></span>==</a>(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;, <br>                  unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;);<br><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; <br>  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="unordered_multiset.html#boost.operator%21=_id3144307"><span class="bold"><strong>operator</strong></span>!=</a>(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;, <br>                  unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp;);<br><br><span class="emphasis"><em>// <a class="link" href="unordered_multiset.html#id3144376-bb">swap</a></em></span>
<span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; <br>  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unordered_multiset.html#boost.swap_id3144381">swap</a>(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;, <br>            unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;);</pre></div>
<div class="refsect1" lang="en">
<a name="id3759464"></a><h2>Description 说明</h2>
<p>For the normative reference see chapter 23 of
              <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf" target="_top">the working draft of the C++ standard [n2461].<br>标准化参考请见 </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf" target="_top">C++标准工作草案[n2461]</a> 第23章。</p>
<p><span class="bold"><strong>Template Parameters 模板参数</strong></span>
              </p>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<tbody>
<tr>
<td><span class="emphasis"><em>Value</em></span></td>
<td>Value must be Assignable and CopyConstructible<br>Value 必须是可赋值和可复制构造的</td>
</tr>
<tr>
<td><span class="emphasis"><em>Hash</em></span></td>
<td>A unary function object type that acts a hash function for a <code class="computeroutput">Value</code>. It takes a single argument of type <code class="computeroutput">Value</code> and returns a value of type std::size_t.<br>一元函数对象类型，用作 <code class="computeroutput">Value</code> 的散列函数。它接受单个类型为 <code class="computeroutput">Value</code> 的参数，返回类型为 std::size_t 的值。</td>
</tr>
<tr>
<td><span class="emphasis"><em>Pred</em></span></td>
<td>A binary function object that implements an equivalence relation on values of type <code class="computeroutput">Value</code>.
                        A binary function object that induces an equivalence relation on values of type Key.
                        It takes two arguments of type Key and returns a value of type bool.<br>二元函数对象，实现类型 <code class="computeroutput">Value</code> 的等同性关系。它接受两个类型为 <code class="computeroutput">Value</code> 的参数，返回类型为 bool 的值。</td>
</tr>
<tr>
<td><span class="emphasis"><em>Alloc</em></span></td>
<td>An allocator whose value type is the same as the container's value type.<br>分配器，它的值类型与容器的值类型相同。</td>
</tr>
</tbody>
</table></div>
<p>The elements are organized into buckets. Keys with the same hash
code are stored in the same bucket and elements with equivalent keys
are stored next to each other.<br>容器中的元素存放在多个桶中。具有相同散列码的键存放在同一个桶中，相同键值的元素会连续存放在一起。</p>
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.<br>桶的数量可以通过调用 insert 自动增加，或者调用 rehash 进行调整。</p>
<div class="refsect2" lang="en">
<a name="id3759573"></a><h3>
<a name="boost.unordered_multisettypes"></a><code class="computeroutput">unordered_multiset</code> 
        public
       types 公有类型</h3>
<div class="orderedlist"><ol type="1">
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_multiset.size_type"></a>size_type;</p>
<p>An unsigned integral type.<br>无符号整数类型。</p>
<p><span class="type">size_type</span> can represent any non-negative value of <span class="type">difference_type</span>.<br>size_type 可以表示 difference_type 的任一非负值。</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_multiset.difference_type"></a>difference_type;</p>
<p>A signed integral type.<br>有符号整数类型。</p>
<p>Is identical to the difference type of <span class="type">iterator</span> and <span class="type">const_iterator</span>.<br>与 iterator 和 const_iterator 的距离类型相同。</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_multiset.iterator"></a>iterator;</p>
<p>A constant iterator whose value type is <span class="type">value_type</span>.<br>一个常量迭代器，它的值类型为 value_type。  </p>
<p>Any iterator category except output iterator.<br>除输出迭代器以外的任意迭代器类别。</p>
<p>Convertible to <span class="type">const_iterator</span>.<br>可转换为 const_iterator。</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_multiset.const_iterator"></a>const_iterator;</p>
<p>A constant iterator whose value type is <span class="type">value_type</span>.<br>一个常量迭代器，它的值类型为 value_type。  </p>
<p>Any iterator category except output iterator.<br>除输出迭代器以外的任意迭代器类别。</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_multiset.local_iterator"></a>local_iterator;</p>
<p>An iterator with the same value type, difference type and pointer and reference type as <span class="type">iterator</span>.<br>具有与 iterator 相同值类型、距离类型和指针、引用类型的迭代器。</p>
<p>A local_iterator object can be used to iterate through a single bucket.<br>local_iterator 对象可用于遍历单个桶。</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> <a name="boost.unordered_multiset.const_local_iterator"></a>const_local_iterator;</p>
<p>A constant iterator with the same value type, difference type and pointer and reference type as <span class="type">const_iterator</span>.<br>具有与 const_iterator 相同值类型、距离类型和指针、引用类型的迭代器。</p>
<p>A const_local_iterator object can be used to iterate through a single bucket.<br>const_local_iterator 对象可用于遍历单个桶。</p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3759803"></a><h3>
<a name="boost.unordered_multisetconstruct-copy-destruct"></a><code class="computeroutput">unordered_multiset</code> 
        public
       construct/copy/destruct&nbsp;公有构造/复制/析构</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="bold"><strong>explicit</strong></span> <a name="id3109784-bb"></a>unordered_multiset(size_type n = <span class="emphasis"><em>implementation-defined</em></span>, <br>                            hasher <span class="bold"><strong>const</strong></span>&amp; hf = hasher(), <br>                            key_equal <span class="bold"><strong>const</strong></span>&amp; eq = key_equal(), <br>                            allocator_type <span class="bold"><strong>const</strong></span>&amp; a = allocator_type());</pre>
<p>Constructs an empty container with at least n buckets, using hf as
the hash function, eq as the key equality predicate, a as the allocator
and a maximum load factor of 1.0.<br>构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，最大负载因子为 1.0。</p>
<div class="variablelist">
<table border="0">
<colgroup><col align="left" valign="top"></colgroup></table></div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td>
<p><span class="term">Postconditions:<br>后置条件：</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_multiset.html#id3129190-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; <br>  <a name="id3109868-bb"></a>unordered_multiset(InputIterator f, InputIterator l, <br>                     size_type n = implementation-defined, <br>                     hasher <span class="bold"><strong>const</strong></span>&amp; hf = hasher(), <br>                     key_equal <span class="bold"><strong>const</strong></span>&amp; eq = key_equal(), <br>                     allocator_type <span class="bold"><strong>const</strong></span>&amp; a = allocator_type());</pre>
<p>Constructs an empty container with at least n buckets, using hf as
the hash function, eq as the key equality predicate, a as the allocator
and a maximum load factor of 1.0 and inserts the elements from [f, l)
into it.<br>构造一个带至少 n 个桶的空容器，以 hf 作为散列函数，eq 作为键值等同性谓词，a 作为分配器，最大负载因子为 1.0，并插入 [f,l) 的元素。</p>
</li>
<li>
<pre class="literallayout"><a name="id3129029-bb"></a>unordered_multiset(unordered_multiset <span class="bold"><strong>const</strong></span>&amp;);</pre>
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.<br>复制构造函数。复制所含的元素、散列函数、谓词、最大负载因子和分配器。</p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>explicit</strong></span> <a name="id3129050-bb"></a>unordered_multiset(Allocator <span class="bold"><strong>const</strong></span>&amp; a);</pre>
<p>Constructs an empty container, using allocator <code class="computeroutput">a</code>.<br>构造一个空容器，使用分配器 <code class="computeroutput">a</code>。</p>
</li>
<li>
<pre class="literallayout"><a name="id3129078-bb"></a>unordered_multiset(unordered_multiset <span class="bold"><strong>const</strong></span>&amp; x, Allocator <span class="bold"><strong>const</strong></span>&amp; a);</pre>
<p>Constructs an container, copying <code class="computeroutput">x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code class="computeroutput">a</code>.<br>构造一个容器，复制 <code class="computeroutput">x</code> 所含的元素、散列函数、谓词、最大负载因子，但使用分配器 
<code class="computeroutput">a</code>。</p>
</li>
<li><pre class="literallayout"><a name="id3129119-bb"></a>~unordered_multiset();</pre></li>
</ol></div>
</div>
<pre class="literallayout"><span class="type">unordered_multiset&amp;</span> <a name="id3129122-bb"></a><span class="bold"><strong>operator</strong></span>=(unordered_multiset <span class="bold"><strong>const</strong></span>&amp;);</pre>
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.<br>赋值操作符。复制所含的元素、散列函数、谓词、最大负载因子，但不复制分配器。</p>
<pre class="literallayout"><span class="type">allocator_type</span> <a name="id3129150-bb"></a>get_allocator() <span class="bold"><strong>const</strong></span>;</pre>
<div class="refsect2" lang="en">
<a name="id3760126"></a><h3>
<a name="id3129162-bb"></a><code class="computeroutput">unordered_multiset</code> size and capacity 大小与容量</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id3129167-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p><p><span class="term">返回：</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_multiset.html#id3129190-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3129190-bb"></a>size() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p><p><span class="term">返回：</span></p></td>
<td><code class="computeroutput">std::distance(<a class="link" href="unordered_multiset.html#id3129245-bb">begin</a>(), <a class="link" href="unordered_multiset.html#id3129270-bb">end</a>())</code></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3129218-bb"></a>max_size() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p><p><span class="term">返回：</span></p></td>
<td>
<code class="computeroutput"><a class="link" href="unordered_multiset.html#id3129190-bb">size</a>()</code> of the largest possible container.<br>最大可能容器的 <code class="computeroutput"><a class="link" href="unordered_set.html#id2980375-bb">size</a>()</code>。 
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3760291"></a><h3>
<a name="id3129241-bb"></a><code class="computeroutput">unordered_multiset</code> iterators 迭代器</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id3129245-bb"></a><span class="type">iterator</span> <a name="id3129250-bb"></a>begin();<br><span class="type">const_iterator</span> <a name="id3129255-bb"></a>begin() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:<br>返回：</span></p></td>
<td>An iterator referring to the first element of the container, or if
the container is empty the past-the-end value for the container.<br>一个迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。  </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id3129270-bb"></a><span class="type">iterator</span> <a name="id3129275-bb"></a>end();<br><span class="type">const_iterator</span> <a name="id3129283-bb"></a>end() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>An iterator which refers to the past-the-end value for the container.<br>一个迭代器，引向容器的 past-the-end 值。 
              </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id3129300-bb"></a>cbegin() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>A constant iterator referring to the first element of the
container, or if the container is empty the past-the-end value for the
container.<br>一个常量迭代器，引向容器的第一个元素，或者如果容器为空，引向容器的 past-the-end 值。  </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id3129318-bb"></a>cend() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>A constant iterator which refers to the past-the-end value for the container.<br>一个常量迭代器，引向容器的 past-the-end 值。 
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3760483"></a><h3>
<a name="id3129338-bb"></a><code class="computeroutput">unordered_multiset</code> modifiers 修改器</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <span class="type">iterator</span> <a name="id3129342-bb"></a>emplace(Args&amp;&amp;... args);</pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container.<br>插入一个从参数 <code class="computeroutput">args</code> 
构造的对象到容器中。</p>
<div class="variablelist">
<table border="0">
<colgroup><col align="left" valign="top"></colgroup></table></div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>An iterator pointing to the inserted element.<br>一个迭代器，指向新插入的元素。</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td>
<p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.<br>如果从对 <code class="computeroutput">hasher</code> 的调用以外抛出异常，该函数没有作用。</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span><span class="term"><br>说明：</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br>可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</p>
<p>Pointers and references to elements are never invalidated.<br>指向元素的指针和引用不会失效。</p>
<p>Only available on compilers with support for variadic template arguments and rvalue references.<br>仅在支持可变参数模板和右值引用的编译器上可用。</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span>... Args&gt; <br>  <span class="type">iterator</span> <a name="id3129430-bb"></a>emplace(const_iterator hint, Args&amp;&amp;... args);</pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container.<br>插入一个从参数 <code class="computeroutput">args</code> 构造的对象到容器中。</p>
<p>hint is a suggestion to where the element should be inserted.<br>hint 是一个插入元素的建议点。</p>
<div class="variablelist">
<table border="0">
<colgroup><col align="left" valign="top"></colgroup></table></div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>An iterator pointing to the inserted element.<br>一个迭代器，指向新插入的元素。</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.<br>如果从对 <code class="computeroutput">hasher</code> 的调用以外抛出异常，该函数没有作用。</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span><span class="term"><br>说明：</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the
only practical way to use it, and the only way that Boost.Unordered
supports is to point to an existing element with the same value.</p>标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 支持的唯一方法是，指向具有相同值的元素。<br> 
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br>可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</p>
<p>Pointers and references to elements are never invalidated.<br>指向元素的指针和引用不会失效。</p>
<p>Only available on compilers with support for variadic template arguments and rvalue references.<br>仅在支持可变参数模板和右值引用的编译器上可用。</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id3129541-bb"></a>insert(value_type <span class="bold"><strong>const</strong></span>&amp; obj);</pre>
<p>Inserts obj in the container.<br>插入 obj 到容器中。</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>An iterator pointing to the inserted element.<br>一个迭代器，指向新插入的元素。</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.<br>如果从对 <code class="computeroutput">hasher</code> 的调用以外抛出异常，该函数没有作用。</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span><span class="term"><br>说明：</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br>可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</p>
<p>Pointers and references to elements are never invalidated.<br>指向元素的指针和引用不会失效。</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id3129604-bb"></a>insert(const_iterator hint, value_type <span class="bold"><strong>const</strong></span>&amp; obj);</pre>
<p>Inserts obj in the container.<br>插入 obj 到容器中。</p>
<p>hint is a suggestion to where the element should be inserted.<br>hint 是一个插入元素的建议点。</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>An iterator pointing to the inserted element.<br>一个迭代器，指向新插入的元素。</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.<br>如果从对 <code class="computeroutput">hasher</code> 的调用以外抛出异常，该函数没有作用。</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span><span class="term"><br>说明：</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the
only practical way to use it, and the only way that Boost.Unordered
supports is to point to an existing element with the same value.<br>标准对于提示的意义相当含糊。不过使用它的唯一可行的方法，也是 Boost.Unordered 支持的唯一方法是，指向具有相同值的元素。 </p>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br>可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</p>
<p>Pointers and references to elements are never invalidated.<br>指向元素的指针和引用不会失效。</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a>&gt; <br>  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id3136384-bb"></a>insert(InputIterator first, InputIterator last);</pre>
<p>Inserts a range of elements into the container.<br>插入一组元素到容器中。</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td><p>When inserting a single element, if an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.<br>当插入单个元素时，如果从对 <code class="computeroutput">hasher</code> 的调用以外抛出异常，该函数没有作用。</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span><span class="term"><br>说明：</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br>可能使迭代器失效，但仅当插入操作导致负载因子大于或等于最大负载因子时。</p>
<p>Pointers and references to elements are never invalidated.<br>指向元素的指针和引用不会失效。</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id3136461-bb"></a>erase(const_iterator position);</pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.<br>删除 <code class="computeroutput">position</code> 所指元素。</p>
<div class="variablelist">
<table border="0">
<colgroup><col align="left" valign="top"></colgroup></table></div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>
<p>The iterator following <code class="computeroutput">position</code> before the erasure.<br>在删除前紧跟 <code class="computeroutput">position</code> 的迭代器。</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.<br>仅当从 <code class="computeroutput">hasher</code> 或 <code class="computeroutput">key_equal</code> 抛出异常时抛出该异常。</p>
<p>In this implementation, this overload doesn't call either function
object's methods so it is no throw, but this might not be true in other
implementations.<br>在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3136526-bb"></a>erase(key_type <span class="bold"><strong>const</strong></span>&amp; k);</pre>
<p>Erase all elements with key equivalent to <code class="computeroutput">k</code>.<br>删除所有键值等于 <code class="computeroutput">k</code> 的元素。</p>
<div class="variablelist">
<table border="0">
<colgroup><col align="left" valign="top"></colgroup></table></div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>
<p>The number of elements erased.<br>被删除的元素数量。</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td><p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.<br>仅当从 <code class="computeroutput">hasher</code> 或 <code class="computeroutput">key_equal</code> 抛出异常时抛出该异常。</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id3136582-bb"></a>erase(const_iterator first, const_iterator last);</pre>
<p>Erases the elements in the range from <code class="computeroutput">first</code> to <code class="computeroutput">last</code>.<br>删除从 <code class="computeroutput">first</code> 到 <code class="computeroutput">last</code> 的元素。</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>
<p>The iterator following the erased elements - i.e. <code class="computeroutput">last</code>.<br>紧随被删除元素之后的迭代器 - 即 <code class="computeroutput">last</code>。</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.<br>仅当从 <code class="computeroutput">hasher</code> 或 <code class="computeroutput">key_equal</code> 抛出异常时抛出该异常。</p>
<p>In this implementation, this overload doesn't call either function
object's methods so it is no throw, but this might not be true in other
implementations.<br>在该实现中，这一重载不会调用函数对象方法，所以它不会抛出，不过在其它实现中不一定也是如此。</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id3136663-bb"></a>clear();</pre>
<p>Erases all elements in the container.<br>删除容器中所有元素。</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Postconditions:</span><span class="term"><br>后置条件：</span></p></td>
<td><p><code class="computeroutput"><a class="link" href="unordered_multiset.html#id3129190-bb">size</a>() == 0</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td>
<p>Never throws an exception.<br>不会抛出。</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id3136700-bb"></a>swap(unordered_multiset&amp;);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td>
<p>If the allocators are equal, doesn't throw an exception unless
it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">key_equal</code> or <code class="computeroutput">hasher</code>.<br>如果分配器是相同的，则不会抛出，除非异常是从 <code class="computeroutput">key_equal</code> 或 <code class="computeroutput">hasher</code> 的复制构造函数或复制赋值操作符抛出的。</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span><span class="term"><br>说明：</span></p></td>
<td>
<p>For a discussion of the behavior when allocators aren't equal see
                  <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</a>.<br>有关分配器不同时的行为的讨论，请见 <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</a>。</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3761218"></a><h3>
<a name="id3136753-bb"></a><code class="computeroutput">unordered_multiset</code> observers 观察器</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type">hasher</span> <a name="id3136758-bb"></a>hash_function() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>The container's hash function.<br>容器的散列函数。 
              </td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">key_equal</span> <a name="id3136775-bb"></a>key_eq() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>The container's key equality predicate.<br>容器的键值等同性谓词。 
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3761307"></a><h3>
<a name="id3136793-bb"></a><code class="computeroutput">unordered_multiset</code> lookup 查找</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id3136798-bb"></a><span class="type">iterator</span> <a name="id3136803-bb"></a>find(key_type <span class="bold"><strong>const</strong></span>&amp; k);<br><span class="type">iterator</span> <a name="id3136821-bb"></a>find(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>An iterator pointing to an element with key equivalent to <code class="computeroutput">k</code>, or <code class="computeroutput">b.end()</code> if no such element exists.<br>一个迭代器，指向键值等于 <code class="computeroutput">k</code> 的元素，如果该元素不存在，返回 <code class="computeroutput">b.end()</code>。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3136858-bb"></a>count(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td>
<p>The number of elements with key equivalent to <code class="computeroutput">k</code>.<br>键值等于 <code class="computeroutput">k</code> 的元素数量。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id3136893-bb"></a><span class="type">std::pair&lt;iterator, iterator&gt;</span> <a name="id3136898-bb"></a>equal_range(key_type <span class="bold"><strong>const</strong></span>&amp; k);<br><span class="type">std::pair&lt;const_iterator, const_iterator&gt;</span> <a name="id3136916-bb"></a>equal_range(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>A range containing all elements with key equivalent to <code class="computeroutput">k</code>.
                  If the container doesn't container any such elements, returns
                  <code class="computeroutput">std::make_pair(b.end(),b.end())</code>.<br>包含所有键值等于 <code class="computeroutput">k</code> 的元素的区间。如果容器中没有这样的元素，返回 <code class="computeroutput">std::make_pair(b.end(),b.end())</code>. 
                  </p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3761527"></a><h3>
<a name="id3136967-bb"></a><code class="computeroutput">unordered_multiset</code> bucket interface 桶接口</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3136972-bb"></a>bucket_count() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>The number of buckets.<br>桶的数量。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3143752-bb"></a>max_bucket_count() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>An upper bound on the number of buckets.<br>桶数量的上限。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3143773-bb"></a>bucket_size(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span><span class="term"><br>返回：</span></p></td>
<td><p><code class="computeroutput">n &lt; <a class="link" href="unordered_multiset.html#id3136972-bb">bucket_count</a>()</code></p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>The number of elements in bucket <code class="computeroutput">n</code>.<br>桶 <code class="computeroutput">n</code> 中的元素数量。</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id3143820-bb"></a>bucket(key_type <span class="bold"><strong>const</strong></span>&amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>The index of the bucket which would contain an element with key <code class="computeroutput">k</code>.<br>包含键值为 <code class="computeroutput">k</code> 的元素的桶的索引。</p></td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span><span class="term"><br>后置条件：</span></p></td>
<td><p>The return value is less than <code class="computeroutput">bucket_count()</code><br>返回值小于 <code class="computeroutput">bucket_count()</code></p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id3143865-bb"></a><span class="type">local_iterator</span> <a name="id3143870-bb"></a>begin(size_type n);<br><span class="type">const_local_iterator</span> <a name="id3143888-bb"></a>begin(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span><span class="term"><br>要求：</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.<br><code class="computeroutput">n</code> 应位于区间 <code class="computeroutput">[0, 
bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>A local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.<br>一个局部迭代器，指向索引为 <code class="computeroutput">n</code> 的桶中的第一个元素。</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id3143936-bb"></a><span class="type">local_iterator</span> <a name="id3143941-bb"></a>end(size_type n);<br><span class="type">const_local_iterator</span> <a name="id3143959-bb"></a>end(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span><span class="term"><br></span><span class="term">要求</span><span class="term">：</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.<br><code class="computeroutput">n</code> 应位于区间 <code class="computeroutput">[0, 
bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>A local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.<br>一个局部迭代器，指向索引为 <code class="computeroutput">n</code> 的桶中的最后一个元素之后。</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_local_iterator</span> <a name="id3144007-bb"></a>cbegin(size_type n) <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span><span class="term"><br></span><span class="term">要求</span><span class="term">：</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.<br><code class="computeroutput">n</code> 应位于区间 <code class="computeroutput">[0, 
bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>A constant local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.<br>一个常量局部迭代器，指向索引为 <code class="computeroutput">n</code> 的桶中的第一个元素。</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">const_local_iterator</span> <a name="id3144056-bb"></a>cend(size_type n);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span><span class="term"><br></span><span class="term">要求</span><span class="term">：</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.<br><code class="computeroutput">n</code> 应位于区间 <code class="computeroutput">[0, 
bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.<br>一个常量局部迭代器，指向索引为 <code class="computeroutput">n</code> 的桶中的最后一个元素之后。</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3761997"></a><h3>
<a name="id3144104-bb"></a><code class="computeroutput">unordered_multiset</code> hash policy 散列策略</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>float</strong></span></span> <a name="id3144109-bb"></a>load_factor() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>The average number of elements per bucket.<br>每个桶中元素的平均数量。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>float</strong></span></span> <a name="id3144130-bb"></a>max_load_factor() <span class="bold"><strong>const</strong></span>;</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span><span class="term"><br>返回：</span></p></td>
<td><p>Returns the current maximum load factor.<br>返回当前的最大负载因子。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id3144151-bb"></a>max_load_factor(<span class="bold"><strong>float</strong></span> z);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Effects:</span><span class="term"><br>作用：</span></p></td>
<td><p>Changes the container's maximum load factor, using <code class="computeroutput">z</code> as a hint.<br>修改容器的最大负载因子，以 <code class="computeroutput">z</code> 为提示。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id3144183-bb"></a>rehash(size_type n);</pre>
<p>Changes the number of buckets so that there at least <code class="computeroutput">n</code> buckets, and so that the load factor is less than the maximum load factor.<br>修改桶的数量，使得最少有 <code class="computeroutput">n</code> 个桶，且负载因子小于最大负载因子。</p>
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.<br>使迭代器失效，并会改变元素的顺序。指向元素的指针和引用不会失效。</p>
<div class="variablelist">
<table border="0">
<colgroup><col align="left" valign="top"></colgroup></table></div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td><p>The function has no effect if an exception is thrown, unless it
is thrown by the container's hash function or comparison function.<br>如果抛出异常，则该函数没有作用，除非异常是从容器的散列函数或比较函数中抛出的。</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3762189"></a><h3>
<a name="id3144234-bb"></a><code class="computeroutput">unordered_multiset</code> Equality Comparisons 等同性比较</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; <br>  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="boost.operator==_id3144238"></a><span class="bold"><strong>operator</strong></span>==(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; x, <br>                  unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p><p><span class="term"></span><span class="term">说明：</span></p></td>
<td><p>This is a boost extension.</p><p>这是 boost 的扩展。</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; <br>  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="boost.operator!=_id3144307"></a><span class="bold"><strong>operator</strong></span>!=(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; x, <br>                  unordered_multiset&lt;Value, Hash, Pred, Alloc&gt; <span class="bold"><strong>const</strong></span>&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span><span class="term"></span></p><p><span class="term">说明</span><span class="term">：</span></p></td>
<td><p>This is a boost extension.</p><p>这是 boost 的扩展。</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3762374"></a><h3>
<a name="id3144376-bb"></a><code class="computeroutput">unordered_multiset</code> swap</h3>
<div class="orderedlist"><ol type="1"><li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Value, <span class="bold"><strong>typename</strong></span> Hash, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; <br>  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="boost.swap_id3144381"></a>swap(unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; x, <br>            unordered_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; y);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span><span class="term"><br>作用：</span></p></td>
<td><p><code class="computeroutput">x.swap(y)</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span><span class="term"><br>抛出：</span></p></td>
<td><p>If the allocators are equal, doesn't throw an exception unless
it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">Hash</code> or <code class="computeroutput">Pred</code>.<br>如果分配器是相同的，则不会抛出异常，除非异常是从 <code class="computeroutput">Hash</code> 或 <code class="computeroutput">Pred</code> 的复制构造函数或复制赋值操作符抛出的。</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span><span class="term"><br>说明：</span></p></td>
<td><p>For a discussion of the behavior when allocators aren't equal see
                  <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">the implementation details</a>.<br>有关分配器不同时的行为的讨论，请见 <a class="link" href="../unordered/rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">实现细节</a>。</p></td>
</tr>
</tbody>
</table></div>
</li></ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2003, 2004 Jeremy B. Maitin-Shepard<br>Copyright © 2005-2008 Daniel
      James<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="unordered_set.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_set.hpp"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_map.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>







  
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">








  
  
  
  
  
  
  
  
  
  
  
  
  <title>Gregorian</title>
  <link rel="stylesheet" href="../boostbook.css" type="text/css">







  
  
  
  
  
  
  <meta name="generator" content="DocBook XSL Stylesheets V1.68.1">







  
  
  
  
  
  
  <link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">







  
  
  
  
  
  
  <link rel="up" href="../date_time.html" title="Chapter&nbsp;4.&nbsp;Boost.Date_Time">







  
  
  
  
  
  
  <link rel="prev" href="examples/general_usage_examples.html" title="General Usage Examples">







  
  
  
  
  
  
  <link rel="next" href="posix_time.html" title="Posix Time">
</head>


<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">







<table cellpadding="2" width="100%">







  <tbody>






    <tr>






      <td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>







      <td align="center"><a href="../../../index.htm">Home</a></td>







      <td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>







      <td align="center"><a href="../../../people/people.htm">People</a></td>







      <td align="center"><a href="../../../more/faq.htm">FAQ</a></td>







      <td align="center"><a href="../../../more/index.htm">More</a></td>







    </tr>






  
  
  
  
  
  
  </tbody>
</table>







<hr>
<div class="spirit-nav">
<a accesskey="p" href="examples/general_usage_examples.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../date_time.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="posix_time.html"><img src="../images/next.png" alt="Next"></a>
</div>







<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;">
<a name="date_time.gregorian"></a>格里历</h2>






</div>






</div>






</div>







<div class="toc">
<dl>







  <dt><span class="section"><a href="gregorian.html#date_time.gregorian.date_class">日期</a></span></dt>







  <dt><span class="section"><a href="gregorian.html#date_time.gregorian.date_duration">日期长度(aka Days)</a></span></dt>







  <dt><span class="section"><a href="gregorian.html#date_time.gregorian.date_period">日期段</a></span></dt>







  <dt><span class="section"><a href="gregorian.html#date_time.gregorian.date_iterators">日期迭代器</a></span></dt>







  <dt><span class="section"><a href="gregorian.html#date_time.gregorian.date_algorithms">日期生成器/算法</a></span></dt>







  <dt><span class="section"><a href="gregorian.html#date_time.gregorian.gregorian_calendar">格里历</a></span></dt>







</dl>






</div>







<h2>
<a name="id964138"></a>格里历日期系统</h2>







<p>
    <a href="gregorian.html#greg_intro">简介</a> --&nbsp;<a href="gregorian.html#greg_ex">用例</a>
  </p>







<a name="greg_intro"></a>
<h3>
<a name="id964167"></a>简介</h3>







<p>格里历日期系统提供了基于格里历的日期编程系统。格里历的第一次引入是在1582年，它修正了罗马儒略历的一个错误。不过，许多地区直到很后才采用这种修正。所以在历史日期上可能存在一些混乱。 </p>







<p>我们实现的日历是一种"预想的格里历"，即将格里历推广至1582年首次采用格里历之前的时间。当前的实现支持从
1400-Jan-01 到 9999-Dec-31 的日期。有很多被引用的1582年以前的日期是采用罗马儒略历的，所以如果要求对历史日期进行准确的计算，就必须要小心。更多细节请参见 Reingold &amp; Dershowitz 所写的 <a href="http://emr.cs.iit.edu/home/reingold/calendar-book/second-edition" target="_top">日历计算</a> 一书。这本书中的日期信息常被用于对格里历实现的正确性进行交叉测试。 </p>







<p>格里历系统的所有类型位于名字空间
boost::gregorian. 本库提供一个方便的头文件
boost/date_time/gregorian/gregorian_types.hpp，它包含了本库所有类，但不带输入/输出。另一个头文件
boost/date_time/gregorian/gregorian.hpp 则包含所有类型以及输入/输出代码。 </p>







<p>类 <a href="gregorian.html#date_time.gregorian.date_class" title="Date">boost::gregorian::date</a>
是用户使用的主要时间类型。如果你想学习编写一个进行特定日期计算的程序，如查找"四月第一个星期天"，请参见 <a href="gregorian.html#date_time.gregorian.date_algorithms" title="Date Generators/Algorithms">日期生成器与算法</a>。 
  </p>







<a name="greg_ex"></a>
<h3>
<a name="id964244"></a>用例</h3>







<p>
    </p>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead><tr>







    <th>例子</th>







    <th>说明</th>







  </tr>






  </thead>
  <tbody>







    <tr>







      <td valign="top">
      
      
      
      
      
      
      <div class="literallayout">
      
      
      
      
      
      
      <p><br>







      <a href="examples.html#date_time.examples.days_alive" title="Days Alive">已生活的日子</a>&nbsp;<br>







      <a href="examples.html#date_time.examples.days_between_new_year" title="Days Between New Years">距离新年的日子</a></p>






      </div>






      </td>







      <td>简单的日期算术。从时钟取出当天日期。</td>







    </tr>







    <tr>







      <td valign="top">
      
      
      
      
      
      
      <div class="literallayout">
      
      
      
      
      
      
      <p><a href="examples.html#date_time.examples.dates_as_strings" title="Dates as Strings">字符串表示的日期</a></p>






      </div>






      </td>







      <td>对日期字符串进行简单分析，以及将日期格式化为字符串</td>







    </tr>







    <tr>







      <td valign="top">
      
      
      
      
      
      
      <div class="literallayout">
      
      
      
      
      
      
      <p><a href="examples.html#date_time.examples.date_period_calc" title="Date Period Calculations">日期段计算</a></p>






      </div>






      </td>







      <td>检查某个日期是否在一组日期段中(如：某天是否假日/周末)</td>







    </tr>







    <tr>







      <td valign="top">
      
      
      
      
      
      
      <div class="literallayout">
      
      
      
      
      
      
      <p><a href="examples.html#date_time.examples.print_month" title="Print Month">打印月份</a></p>






      </div>






      </td>







      <td>一个小工具程序，从命令行打印出某月的所有天。想知道 1999-Jan-1 是星期五还是星期六？这个程序可以示范怎么做。</td>







    </tr>







    <tr>







      <td valign="top">
      
      
      
      
      
      
      <div class="literallayout">
      
      
      
      
      
      
      <p><a href="examples.html#date_time.examples.print_holidays" title="Print Holidays">打印假日</a></p>






      </div>






      </td>







      <td>使用日期生成器将抽象描述转换为具体的日期集。</td>







    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<p>
  </p>







<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="date_time.gregorian.date_class"></a>日期</h3>






</div>






</div>






</div>







<a href="gregorian.html#date_intro">简介</a> -- <a href="gregorian.html#date_header">头文件</a> --
  <a href="gregorian.html#date_construction">构造</a> --
  <a href="gregorian.html#date_construct_from_string">从字符串构造</a> --
  <a href="gregorian.html#date_construct_from_clock">从时钟构造</a> --
  <a href="gregorian.html#date_accessors">访问器</a> --
  <a href="gregorian.html#date_convert_to_string">转换为字符串</a> --
  <a href="gregorian.html#date_operators">操作符</a> --
  <a href="gregorian.html#date_tm_funcs">Struct tm 函数</a><a name="date_intro"></a>
<h3>
<a name="id964501"></a>简介</h3>







<p>类 boost::gregorian::date 是日期编程的主要接口。通常 date 类一旦构造出来就是不可变的，不过它也允许从另一个 
    date 进行赋值。创建 date 的方法包括：<a href="gregorian.html#date_construct_from_clock">从时钟读取当前日期</a>，使用 <a href="gregorian.html#date_time.gregorian.date_iterators" title="Date Iterators">日期迭代器</a>，以及 
    <a href="gregorian.html#date_time.gregorian.date_algorithms" title="Date Generators/Algorithms">日期算法或生成器</a>。  
  </p>







<p>在内部，boost::gregorian::date 是保存为一个32位整数类型的。该类特别被设计为不含虚函数。这样的设计可以进行高效的运算，以及处理大量日期时具有高效的内存使用率。
  </p>







<p>构造一个 date 时将检查所有的输入，所以不可能构造一个无效的 date.  如 2001-Feb-29 就不可能被构造为一个 date. 
    多个派生自 std::out_of_range 的异常将被抛出以表示日期输入的哪个方面有错。注意，如果需要，可以用一个无效日期的特殊值来作为 '无效' 或 '空' 的 date.
  </p>







<a name="date_header"></a>
<h3>
<a name="id964563"></a>头文件</h3>







<p>
    </p>







<pre class="programlisting">#include "boost/date_time/gregorian/gregorian.hpp" //包含所有类型及 i/o<br>或<br>#include "boost/date_time/gregorian/gregorian_types.hpp" //只有类型不含 i/o</pre>







<p>
  </p>







<a name="date_construction"></a>
<h3>
<a name="id964585"></a>构造</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date(greg_year, greg_month, greg_day)</pre>






      </td>







      <td>从日期的各部分进行构造。如果年、月或日超出范围，则抛出 bad_year,
bad_day_of_month, 或 bad_day_month (均派生自 std::out_of_range)。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,10);</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date(date d)</pre>






      </td>







      <td>复制构造函数</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d1(d);</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date(special_values sv)</pre>






      </td>







      <td>无限日期、无效日期、最大日期、最小日期的构造函函数</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d1(neg_infin);<br>date d2(pos_infin);<br>date d3(not_a_date_time);<br>date d4(max_date_time);<br>date d5(min_date_time);</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date()</pre>






      </td>







      <td>缺省构造函数。创建一个 date 对象，初始化为
not_a_date_time. 注：这个构造函数可以通过定义
DATE_TIME_NO_DEFAULT_CONSTRUCTOR 来禁止(请见 compiler_config.hpp)。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d; // d =&gt; not_a_date_time</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="date_construct_from_string"></a>
<h3>
<a name="id964752"></a>从字符串构造</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date from_string(std::string)</pre>






      </td>







      <td>从日期字符串构造，字符串的顺序应为年-月-日，如：2002-1-25</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">std::string ds("2002/1/25");<br>date d(from_string(ds));</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date from_undelimited_string(std::string)</pre>






      </td>







      <td>从 iso 类型的日期字符串构造，顺序为年-月-日，如：20020125</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">std::string ds("20020125");<br>date d(from_undelimited_string(ds));</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="date_construct_from_clock"></a>
<h3>
<a name="id964859"></a>从时钟构造</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">day_clock::local_day()</pre>






      </td>







      <td>取出本地日期，基于计算机的时区设置。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(day_clock::local_day());</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">day_clock::universal_day()</pre>






      </td>







      <td>取出UTC日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(day_clock::universal_day());</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="date_accessors"></a>
<h3>
<a name="id964964"></a>访问器</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">greg_year year() const</pre>






      </td>







      <td>取出日期中的年份。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,10); <br>d.year(); // --&gt; 2002</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">greg_month month() const</pre>






      </td>







      <td>取出日期中的月份。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,10); <br>d.month(); // --&gt; 1</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">greg_day day() const</pre>






      </td>







      <td>取出日期中的日子。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,10); <br>d.day(); // --&gt; 10</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">greg_ymd year_month_day() const</pre>






      </td>







      <td>返回一个 year_month_day 结构。在需要日期的所有三个组成部分时，这一方法更高效。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,10);<br>date::ymd_type ymd = d.year_month_day();<br>// ymd.year  --&gt; 2002, <br>// ymd.month --&gt; 1, <br>// ymd.day   --&gt; 10</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">greg_day_of_week day_of_week() const</pre>






      </td>







      <td>返回星期几(如：星期天、星期一等等)。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,10);<br>d.day(); // --&gt; 星期四</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">greg_day_of_year day_of_year() const</pre>






      </td>







      <td>返回本年的第几天。从 1 到 366 </td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2000,Jan,10);<br>d.day_of_year(); // --&gt; 10</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date end_of_month() const</pre>






      </td>







      <td>返回一个 <code class="computeroutput">date</code> 对象，设置为传入对象当月的最后一天。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2000,Jan,10);<br>d.end_of_month(); // --&gt; 2000-Jan-31</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_infinity() const</pre>






      </td>







      <td>返回 true 如果 date 为正无限或负无限。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(pos_infin); <br>d.is_infinity(); // --&gt; true</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_neg_infinity() const</pre>






      </td>







      <td>返回 true 如果 date 为负无限。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(neg_infin);<br>d.is_neg_infinity(); // --&gt; true</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_pos_infinity() const</pre>






      </td>







      <td>返回 true 如果 date 为正无限。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(neg_infin); <br>d.is_pos_infinity(); // --&gt; true</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_not_a_date() const</pre>






      </td>







      <td>返回 true 如果 date 不是一个日期 。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(not_a_date_time);<br>d.is_not_a_date(); // --&gt; true</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_special() const</pre>






      </td>







      <td>返回 true 如果 date 为任意 <code class="computeroutput">special_value</code>
      </td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(pos_infin); <br>date d2(not_a_date_time); <br>date d3(2005,Mar,1);<br>d.is_special(); // --&gt; true<br>d2.is_special(); // --&gt; true<br>d3.is_special(); // --&gt; false</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">special_value as_special() const</pre>






      </td>







      <td>返回相应的 <code class="computeroutput">special_value</code>，或者返回 <code class="computeroutput">not_special</code> 如果 date 为正常日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen"></pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">long modjulian_day() const</pre>






      </td>







      <td>返回修正后的罗马儒略历日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen"></pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">long julian_day() const</pre>






      </td>







      <td>返回罗马儒略历日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen"></pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">int week_number() const</pre>






      </td>







      <td>返回 ISO 8601 的周数。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen"></pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date end_of_month_day() const</pre>






      </td>







      <td>返回当月的最后一天。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2000,Feb,1);<br>//取得 Feb 28 -- 2000 为闰年<br>date eom = d.end_of_month_day();</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="date_convert_to_string"></a>
<h3>
<a name="id965521"></a>转换为字符串</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">std::string to_simple_string(date d)</pre>






      </td>







      <td>转换为 <code class="computeroutput">YYYY-mmm-DD</code> 字符串，其中 <code class="computeroutput">mmm</code> 为3字符的月份名。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">"2002-Jan-01"</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">std::string to_iso_string(date d)</pre>






      </td>







      <td>转换为 <code class="computeroutput">YYYYMMDD</code>，所有部分均为整数。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">"20020131"</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">std::string to_iso_extended_string(date d)</pre>






      </td>







      <td>转换为 <code class="computeroutput">YYYY-MM-DD</code>，所有部分均为整数。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">"2002-01-31"</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="date_operators"></a>
<h3>
<a name="id965676"></a>操作符</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator&lt;&lt;</pre>






      </td>







      <td>流输出操作符</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,1);<br>std::cout &lt;&lt; d &lt;&lt; std::endl;</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator&gt;&gt;</pre>






      </td>







      <td>流输入操作符。<span class="strong"><strong>注：</strong></span>与版本1.33相比，流操作已进行了显著改进。有关异常和错误条件的详情请见 <a href="date_time_io.html" title="Date Time Input/Output">日期时间 IO 系统</a>。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(not_a_date_time);<br>stringstream ss("2002-Jan-01");<br>ss &gt;&gt; d;</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator==, operator!=,<br>operator&gt;, operator&lt;,<br>operator&gt;=, operator&lt;=</pre>






      </td>







      <td>完整的比较操作符</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">d1 == d2, etc</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date operator+(date_duration) const</pre>






      </td>







      <td>返回加上一个日期偏移量后的 date</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,1);<br>date_duration dd(1);<br>date d2 = d + dd;</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date operator-(date_duration) const</pre>






      </td>







      <td>返回减去一个日期偏移量后的 date</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,1);<br>date_duration dd(1);<br>date d2 = d - dd;</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_duration operator-(date) const</pre>






      </td>







      <td>对两个 date 进行相减，返回一个 date_duration</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d1(2002,Jan,1);<br>date d2(2002,Jan,2);<br>date_duration dd = d2-d1;</pre>







	  </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="date_tm_funcs"></a>
<h3>
<a name="id965919"></a>Struct tm 函数</h3>







<p>以下函数用于 <code class="computeroutput">date</code> 对象与 <code class="computeroutput">tm</code> 结构的互转。</p>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">tm to_tm(date)</pre>






      </td>







      <td>将 <code class="computeroutput">date</code> 对象转换为 <code class="computeroutput">tm</code> 结构。字段 <code class="computeroutput">tm_hour</code>, <code class="computeroutput">tm_min</code>, 和 <code class="computeroutput">tm_sec</code> 均设为零。<code class="computeroutput">tm_isdst</code> 字段设为 -1.</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2005,Jan,1);<br>tm d_tm = to_tm(d);<br>/* tm_year =&gt; 105<br>   tm_mon  =&gt; 0<br>   tm_mday =&gt; 1<br>   tm_wday =&gt; 6 (星期六)<br>   tm_yday =&gt; 0<br>   tm_hour =&gt; 0<br>   tm_min  =&gt; 0<br>   tm_sec  =&gt; 0<br>   tm_isddst =&gt; -1 */</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date date_from_tm(tm datetm)</pre>






      </td>







      <td>将 <code class="computeroutput">tm</code> 结构转换为 <code class="computeroutput">date</code> 对象。字段 <code class="computeroutput">tm_wday </code>, <code class="computeroutput">tm_yday </code>, <code class="computeroutput">tm_hour</code>, <code class="computeroutput">tm_min</code>, <code class="computeroutput">tm_sec</code>, 和 <code class="computeroutput">tm_isdst</code> 均忽略。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">tm d_tm;<br>d_tm.tm_year = 105;<br>d_tm.tm_mon  = 0;<br>d_tm.tm_mday = 1;<br>date d = date_from_tm(d_tm);<br>// d =&gt; 2005-Jan-01</pre>







          </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







</div>







<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="date_time.gregorian.date_duration"></a>日期长度(aka Days)</h3>






</div>






</div>






</div>







<a href="gregorian.html#duration_intro">简介</a> --
  <a href="gregorian.html#duration_header">头文件</a> --
  <a href="gregorian.html#duration_construction">构造</a> --
  <a href="gregorian.html#duration_accessors">访问器</a> -- <a href="gregorian.html#duration_operators">操作符</a> --
  <a href="gregorian.html#additional_duration_types">其它日期长度类型</a><a name="duration_intro"></a>
<h3>
<a name="id966189"></a>简介</h3>







<p>类&nbsp;boost::gregorian::date_duration 是一个简单的日子计数器，用于 <a href="gregorian.html#date_time.gregorian.date_class" title="Date">gregorian::date</a> 的运算。日期长度可正可负。 
  </p>







<p>和版本1_32一样，date_duration 类被 typedef 为 boost::gregorian 名字空间中的 days. 在以下所有例子中，你都能看到 days 被用于替代 date_duration. </p>







<a name="duration_header"></a>
<h3>
<a name="id966219"></a>头文件</h3>







<p>
    </p>







<pre class="programlisting">#include "boost/date_time/gregorian/gregorian.hpp" //包含所有类型以及 i/o<br>或<br>#include "boost/date_time/gregorian/gregorian_types.hpp" //只有类型没有 i/o</pre>







<p>
  </p>







<a name="duration_construction"></a>
<h3>
<a name="id966242"></a>构造</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_duration(long)</pre>






      </td>







      <td>创建一个日期长度计数。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_duration dd(3); //3天</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">days(special_values sv)</pre>






      </td>







      <td>无限长度、非日期、最大日期、最小日期的构造函数</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">days dd1(neg_infin);<br>days dd2(pos_infin);<br>days dd3(not_a_date_time);<br>days dd4(max_date_time);<br>days dd5(min_date_time);</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="duration_accessors"></a>
<h3>
<a name="id966348"></a>访问器</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">long days() const</pre>






      </td>







      <td>返回 days 的计数。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_duration dd(3); dd.days() --&gt; 3</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_negative() const</pre>






      </td>







      <td>返回 true 如果 days 小于零。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_duration dd(-1); dd.is_negative() --&gt; true</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">static date_duration unit()</pre>






      </td>







      <td>返回日期长度类型的最小可能单元。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_duration::unit() --&gt; date_duration(1)</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_special() const</pre>






      </td>







      <td>返回 true 如果 days 为任意 <code class="computeroutput">special_value</code>
      </td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">days dd(pos_infin); <br>days dd2(not_a_date_time); <br>days dd3(25);<br>dd.is_special(); // --&gt; true<br>dd2.is_special(); // --&gt; true<br>dd3.is_special(); // --&gt; false</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="duration_operators"></a>
<h3>
<a name="id966518"></a>操作符</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator&lt;&lt;, operator&gt;&gt;</pre>






      </td>







      <td>流操作符。<span class="strong"><strong>注：</strong></span>从版本1.33起，流操作已经得到很大改进。详情请见 <a href="date_time_io.html" title="Date Time Input/Output">日期时间 IO 系统</a> (包括异常和错误的情况)。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(not_a_date_time);<br>stringstream ss("2002-Jan-01");<br>ss &gt;&gt; d; <br>std::cout &lt;&lt; d; // "2002-Jan-01"<br></pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator==, operator!=,<br>operator&gt;, operator&lt;,<br>operator&gt;=, operator&lt;=</pre>







	  </td>







      <td>完整的比较操作符。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">dd1 == dd2, etc</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_duration operator+(date_duration) const</pre>






      </td>







      <td>加日期长度。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_duration dd1(3);<br>date_duration dd2(5);<br>date_duration dd3 = dd1 + dd2;</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_duration operator-(date_duration) const</pre>






      </td>







      <td>减日期长度。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_duration dd1(3);<br>date_duration dd2(5);<br>date_duration dd3 = dd1 - dd2;</pre>







	  </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="additional_duration_types"></a>
<h3>
<a name="id966702"></a>其它日期长度类型</h3>







<p>以下这些类型是日期跨度的逻辑表示法。</p>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">months(int num_of_months)</pre>






      </td>







      <td>月份的逻辑表示法。根据不同的用法，<code class="computeroutput">months</code>
对象可以表示28到31天的跨度。该对象与某月的最后一天一起使用时，其行为会保持为月末。<span class="strong"><strong>警告：该行为可能导致非期望的结果。</strong></span>完整的细节和其它请参见：<a href="gregorian.html#snap_to_details">操作可逆性的缺陷</a>。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">months single(1);<br>date leap_year(2004,Jan,31);<br>date norm_year(2005,Jan,31);<br>leap_year + single; // =&gt; 2004-Feb-29<br>norm_year + single; // =&gt; 2005-Feb-28<br>date(2005,Jan,1) + single; // =&gt; 2005-Feb-01<br>date(2005,Feb,1) + single; // =&gt; 2005-Mar-01<br>date(2005,Feb,28) + single; // =&gt; 2005-Mar-31</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">years(int num_of_years)</pre>






      </td>







      <td>年份的逻辑表示法。<code class="computeroutput">years</code> 对象具有与 <code class="computeroutput">months</code> 对象的月末特殊行为相同的行为。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">years single(1);<br>date(2003,Feb,28) + single;<br>// 结果 =&gt; 2004-Feb-29<br>date(2004,Feb,29) + single;<br>// 结果 =&gt; 2005-Feb-28</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">weeks(int num_of_weeks)</pre>






      </td>







      <td>表示 <code class="computeroutput">n * 7</code> 天的日期长度类型。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">weeks single(1);<br>date(2005,Jan,1) + single; // =&gt; 2005-Jan-08</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<p>
<a name="snap_to_details"></a>
</p>







<h4>
<a name="id966897"></a>操作可逆性的缺陷</h4>







<p>
</p>







<p>当向一个日期加上某个月份数，然后再减去相同的月份数时，我们自然期望可以准确得到原来的日期。多数情况下 <code class="computeroutput">date_time</code> 库可以提供这一结果，但是有一个重大的例外：即由 <a href="gregorian.html#additional_duration_types">months</a> 长度类型所带来的月末效应。当开始日期为大月的28日、29日或30日时，<a href="gregorian.html#additional_duration_types">months</a> 长度类型会导致非预期的结果。而 <a href="gregorian.html#iterators_intro">month_iterator</a> 则不会发生这个问题，所以我们在以下例子中将它作为解决该问题的一种方法。
</p>







<p>

</p>







<p>如果开始的日期是在月中，那么加上或减去任意月份数，都会得到某个月同一天的日期(例如，如果你从15日开始，你还会以15日结束)。但当开始的日
期是某月最后一天时，加上或减去任意月份数，所得结果将保持为某月的最后一天(例如，如果你从1月31日开始，则会得到：2月28日、3月31日，等
等)。 </p>







<pre class="programlisting">    // 使用月份长度类型<br>    date d(2005, Nov, 30); // 11月的最后一天<br>    d + months(1); // 结果为12月最后一天 "2005-Dec-31"<br>    d - months(1); // 结果为10月最后一天 "2005-Oct-31"<br><br>    // 使用 month_iterator<br>    month_iterator itr(d); // 11月最后一天<br>    ++itr; // 结果为12月最后一天 "2005-Dec-31"<br>    --itr; // 回到原来的出发点 "2005-Nov-30"<br>    --itr; // 10月最后一天 "2005-Oct-31"<br>  </pre>







<p>
</p>







<p>

</p>







<p>如果开始日期为大月的28日，29日或 30日，则加上或减去一个月所得的结果可能变为月末，这可能不是所期望的。这样会导致最终结果与开始日期不同。 </p>







<pre class="programlisting">    // 使用月份长度类型<br>    date d(2005, Nov, 29);<br>    d += months(1); // "2005-Dec-29"<br>    d += months(1); // "2006-Jan-29"<br>    d += months(1); // "2006-Feb-28" --&gt; 变成月末<br>    d += months(1); // "2006-Mar-31" --&gt; 非期望结果<br>    d -= months(4); // "2005-Nov-30" --&gt; 非期望结果，不是开始的日期<br><br>    // 使用 month_iterator<br>    month_iterator itr(date(2005, Dec, 30));<br>    ++itr; // "2006-Jan-30" --&gt; ok<br>    ++itr; // "2006-Feb-28" --&gt; 不会发生月末效应<br>    ++itr; // "2006-Mar-30" --&gt; ok<br>    --itr; // "2006-Feb-28" --&gt; ok<br>    --itr; // "2006-Jan-30" --&gt; ok<br>    --itr; // "2005-Dec-30" --&gt; ok, 回到开始的日期<br>  </pre>







<p>
</p>







<p>

</p>







<p>这些额外的日期长度类型(<code class="computeroutput">months</code>, <code class="computeroutput">years</code>, 和 <code class="computeroutput">weeks</code>)是为了方便使用而提供的，它们可以很容易删掉以确保不会出现以上缺陷。要删除这些类型，只需要将宏
BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPES 去定义即可。</p>







<p>
</p>







</div>







<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="date_time.gregorian.date_period"></a>日期段</h3>






</div>






</div>






</div>







<a href="gregorian.html#period_intro">简介</a> --
  <a href="gregorian.html#period_header">头文件</a> --
  <a href="gregorian.html#period_construction">构造</a> --
  <a href="gregorian.html#date_period_mutators">修改器</a> --
  <a href="gregorian.html#period_accessors">访问器</a> --
  <a href="gregorian.html#period_convert_to_string">转换为字符串</a> --
  <a href="gregorian.html#period_operators">操作符</a><a name="period_intro"></a>
<h3>
<a name="id967080"></a>简介</h3>







<p>类&nbsp;boost::gregorian::date_period
提供了对两个日期之间的范围的直接表示。日期段可以通过简化程序的条件判断逻辑来简化一些计算类型。例如，测试某个日期是否在某个没有规律的时间表如周末
或假日中，就可以用一组日期段来实现。有多种方法来判断一个 date_period 是否与另一个 date period
交叉，以及生成重叠的日期段。<a href="examples.html#date_time.examples.date_period_calc" title="Date Period Calculations">日期段计算例子</a> 一节中提供了这个例子。
  </p>







<p>由相同的开始日期和结束日期所创建的日期段，称为零长度日期段。零长度日期段被认为是无效的(构造一个无效的日期段是完全合法的)。对于这些日期段，<code class="computeroutput">last</code> 点总是比 <code class="computeroutput">begin</code> 小一个单元。
  </p>







<p>日期段与无限值结合使用可以表示象 '直至另行通知为止' 这样的复杂概念。 </p>







<a name="period_header"></a>
<h3>
<a name="id967128"></a>头文件</h3>







<p>
    </p>







<pre class="programlisting">#include "boost/date_time/gregorian/gregorian.hpp" //包含所有类型和 i/o<br>或<br>#include "boost/date_time/gregorian/gregorian_types.hpp" //只有类型没有 i/o</pre>







<p>
  </p>







<a name="period_construction"></a>
<h3>
<a name="id967151"></a>构造</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period(date, date)</pre>






      </td>







      <td>创建一个 [begin, end) 日期段。如果 end &lt;= begin 则日期段无效。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2002,Jan,10),<br>               date(2002,Jan,12));</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period(date, days)</pre>






      </td>







      <td>创建一个 [begin, begin+len) 日期段，其中 end 点为 begin+len. 如果 len&nbsp;&lt;= 0 则日期段定义为无效。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2002,Jan,10),<br>               days(2));</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period(date_period)</pre>






      </td>







      <td>复制构造函数</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(dp);</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="date_period_mutators"></a>
<h3>
<a name="id967289"></a>修改器</h3>







<p>
    </p>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period shift(days)</pre>






      </td>







      <td>同时为 begin 和 end 加上偏移量。</td>







    </tr>







    <tr>






      <td>
              
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2005,Jan,1), days(3));<br>dp.shift(days(3)); <br>// dp == 2005-Jan-04 至 2005-Jan-07<br>             </pre>







	    </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period expand(days)</pre>






      </td>







      <td>从 begin 减去日期长度而为 end 加上日期长度。</td>







    </tr>







    <tr>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<p>
  </p>







<a name="period_accessors"></a>
<h3>
<a name="id967400"></a>访问器</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date begin()</pre>






      </td>







      <td>返回日期段的第一天。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2002,Jan,1),<br>               date(2002,Jan,10));<br>dp.begin() --&gt; 2002-Jan-01</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date last()</pre>






      </td>







      <td>返回日期段最后一天。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2002,Jan,1),<br>               date(2002,Jan,10));<br>dp.last() --&gt; 2002-Jan-09</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date end()</pre>






      </td>







      <td>返回日期段最后一天后的一天。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2002,Jan,1),<br>               date(2002,Jan,10));<br>dp.end() --&gt; 2002-Jan-10</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">days length()</pre>






      </td>







      <td>返回 date_period 的长度。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2002,Jan,1),<br>               days(2));<br>dp.length() --&gt; 2</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool is_null()</pre>






      </td>







      <td>返回 True 如果日期段是无效的。如：end 小于或等于 begin.</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp(date(2002,Jan,10),<br>               date(2002,Jan,1));<br>dp.begin() --&gt; true</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool contains(date)</pre>






      </td>







      <td>返回 True 如果 date 包含在日期段中。零长度日期段不包含任何日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2002,Jan,1);<br>date_period dp(d, date(2002,Jan,10));<br>dp.contains(date(2002,Jan,2));// true<br>date_period dp2(d, d);<br>dp.contains(date(2002,Jan,1));// false</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool contains(date_period)</pre>






      </td>







      <td>返回 True 如果 date period 包含在日期段中。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>                date(2002,Jan,10));<br>date_period dp2(date(2002,Jan,2),<br>                date(2002,Jan,3));<br>dp1.contains(dp2) --&gt; true<br>dp2.contains(dp1) --&gt; false</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">bool intersects(date_period)</pre>






      </td>







      <td>返回 True 如果两个日期段交叉。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>               date(2002,Jan,10));<br>date_period dp2(date(2002,Jan,2),<br>               date(2002,Jan,3));<br>dp2.intersects(dp1) --&gt; true</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period intersection(date_period)</pre>






      </td>







      <td>计算两个日期段的交集。返回 Null 如果没有交叉。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>                date(2002,Jan,10));<br>date_period dp2(date(2002,Jan,2),<br>                date(2002,Jan,3));<br>dp2.intersection(dp1) --&gt; dp2</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period is_adjacent(date_period)</pre>






      </td>







      <td>检验两个日期段是否相邻且不交叉。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>                date(2002,Jan,3));<br>date_period dp2(date(2002,Jan,3),<br>                date(2002,Jan,10));<br>dp2.is_adjacent(dp1) --&gt; true</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period is_after(date)</pre>






      </td>







      <td>判断日期段是否在给定的 date 之后。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,10),<br>                date(2002,Jan,30));<br>date d(2002,Jan,3);<br>dp1.is_after(d) --&gt; true</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period is_before(date)</pre>






      </td>







      <td>判断日期段是否在给定的 date 之前。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>                date(2002,Jan,3));<br>date d(2002,Jan,10);<br>dp1.is_before(d) --&gt; true</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period merge(date_period)</pre>






      </td>







      <td>返回两个日期段的并集。返回 Null 如果交叉。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>                date(2002,Jan,10));<br>date_period dp2(date(2002,Jan,9),<br>                date(2002,Jan,31));<br>dp2.merge(dp1)<br>// 2002-Jan-01/2002-Jan-31</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period span(date_period)</pre>






      </td>







      <td>合并两个日期段及它们之间的间隔，相当于 begin = min(p1.begin, p2.begin) 且 end = max(p1.end , p2.end)</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>                date(2002,Jan,5));<br>date_period dp2(date(2002,Jan,9),<br>                date(2002,Jan,31));<br>dp2.span(dp1); // 2002-Jan-01/2002-Jan-31</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period shift(days)</pre>






      </td>







      <td>同时为 begin 和 end 加上偏移量。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,1),<br>                date(2002,Jan,10));<br>dp1.shift(days(1));<br>// 2002-Jan-02/2002-Jan-11</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_period expand(days)</pre>






      </td>







      <td>从 begin 减去日期长度而为 end 加上日期长度。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date_period dp1(date(2002,Jan,4),<br>                date(2002,Jan,10));<br>dp1.expand(days(2));<br>// 2002-Jan-02/2002-Jan-12</pre>







	  </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="period_convert_to_string"></a>
<h3>
<a name="id967966"></a>转换为字符串</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">std::string to_simple_string(date_period dp)</pre>






      </td>







      <td>转换为 <code class="computeroutput">[YYYY-mmm-DD/YYYY-mmm-DD]</code> 字符串，其中 <code class="computeroutput">mmm</code> 为3字符的月份名。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">[2002-Jan-01/2002-Jan-31]</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="period_operators"></a>
<h3>
<a name="id968054"></a>操作符</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator&lt;&lt;</pre>






      </td>







      <td>date_period 的流输出操作符。使用 facet 来格式化时间点。典型的输出：[2002-Jan-01/2002-Jan-31].</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">std::cout &lt;&lt; dp &lt;&lt; std::endl;</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator&gt;&gt;</pre>






      </td>







      <td>date_period 的流输入操作符。使用 facet 来分析时间点。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">"[2002-Jan-01/2002-Jan-31]"</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator==, operator!=,<br>operator&gt;, operator&lt;</pre>







	  </td>







      <td>完整的比较操作符。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">dp1 == dp2, etc</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator&lt;</pre>






      </td>







      <td>返回 True 如果 dp1.end() 小于 dp2.begin()</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">dp1 &lt; dp2, etc</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">operator&gt;</pre>






      </td>







      <td>返回 True 如果 dp1.begin() 大于 dp2.end()</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">dp1 &gt; dp2, etc</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







</div>







<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="date_time.gregorian.date_iterators"></a>日期迭代器</h3>






</div>






</div>






</div>







<a href="gregorian.html#iterators_intro">简介</a> --
  <a href="gregorian.html#iterators_header">头文件</a> --
  <a href="gregorian.html#iterators_overview">概要</a><a name="iterators_intro"></a>
<h3>
<a name="id968281"></a>简介</h3>







<p>日期迭代器为对日期进行迭代提供了一个标准机制。日期迭代器是一种 <a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html" target="_top">双向迭代器</a> 并可用于大多日期集合以及其它日期生成任务。例如，<a href="examples.html#date_time.examples.print_month" title="Print Month">打印月份</a> 的例子对一个月中的所有日子进行迭代并打印出它们。  
  </p>







<p>这里的所有迭代器均派生自 boost::gregorian::date_iterator. 
  </p>







<a name="iterators_header"></a>
<h3>
<a name="id968319"></a>头文件</h3>







<p>
    </p>







<pre class="programlisting">#include "boost/date_time/gregorian/gregorian.hpp" //包含所有类型和 i/o<br>或<br>#include "boost/date_time/gregorian/gregorian_types.hpp" //只有类型没有 i/o</pre>







<p>
  </p>







<a name="iterators_overview"></a>
<h3>
<a name="id968342"></a>概要</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date_iterator</pre>






      </td>







      <td>所有日期级迭代器的公共(抽象)基类。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen"></pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">day_iterator(date start_date, int day_count=1)</pre>






      </td>







      <td>每次迭代 <code class="computeroutput">day_count</code> 个日子。该迭代器不提供后缀式的递增/递减操作符。只提供前缀式的递增/递减操作符。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">day_iterator day_itr(date(2005,Jan,1));<br>++d_itr; // 2005-Jan-02<br>day_iterator 2day_itr(date(2005,Feb,1),2);<br>++2d_itr; // 2005-Feb-03</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">week_iterator(...)<br>  Parameters:<br>    date start_date<br>    int week_offset (defaults to 1)</pre>






      </td>







      <td>每次迭代 <code class="computeroutput">week_offset</code> 个星期。该迭代器不提供后缀式的递增/递减操作符。只提供前缀式的递增/递减操作符。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">week_iterator wk_itr(date(2005,Jan,1));<br>++wk_itr; // 2005-Jan-08<br>week_iterator 2wk_itr(date(2005,Jan,1),2);<br>++2wk_itr; // 2005-Feb-15</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">month_iterator(...)<br>  Parameters:<br>    date start_date<br>    int month_offset (defaults to 1)</pre>






      </td>







      <td>迭代 <code class="computeroutput">month_offset</code>
个月份。在处理月末时有特殊规则。即：如果开始的日期是某月的最后一天，则总是将结果调整为月末。如果结果日期超出月末(如 Jan
31 + 1 month)则往回调整至月末(有关细节和例子，请参见 <a href="gregorian.html#snap_to_details">操作可逆性的缺陷</a>。<span class="strong"><strong>注：</strong></span><code class="computeroutput">month_iterator</code>
不会产生这一缺陷)。该迭代器不提供后缀式的递增/递减操作符。只提供前缀式的递增/递减操作符。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">month_iterator m_itr(date(2005,Jan,1));<br>++m_itr; // 2005-Feb-01<br>month_iterator 2m_itr(date(2005,Feb,1),2);<br>++2m_itr; // 2005-Apr-01</pre>






      </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">year_iterator(...)<br>  Parameters:<br>    date start_date<br>    int year_offset (defaults to 1)</pre>






      </td>







      <td>迭代 year_offset 个年份。year_iterator
总是得到同一天的结果，除了当日期为非闰年的 Feb 28 时。在这种情况下，迭代器将在结果为闰年时返回 Feb 29
(如：2003-Feb-28, 2004-Feb-29, 2005-Feb-28)。该迭代器不提供后缀式的递增/递减操作符。只提供前缀式的递增/递减操作符。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">year_iterator y_itr(date(2005,Jan,1));<br>++y_itr; // 2006-Jan-01<br>year_iterator 2y_itr(date(2005,Feb,1),2);<br>++2y_itr; // 2007-Feb-01</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







</div>







<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="date_time.gregorian.date_algorithms"></a></h3>






</div>






</div>






</div>







<h2>
<a name="id968597"></a>日期生成器/算法</h2>







<a href="gregorian.html#algo_intro">简介</a> --
  <a href="gregorian.html#algo_header">头文件</a> --
  <a href="gregorian.html#algo_overview">类的概要</a> --
  <a href="gregorian.html#algo_func_overview">函数的概要</a><a name="algo_intro"></a>
<h3>
<a name="id968641"></a>简介</h3>







<p>日期算法或生成器是一些生成其它日期或日期时间表的工具。生成器函数以日期的某些部分如月份和日子开始，并通过提供其它部分以生成一个具体的日期。这使得程序员可以表示象"二月的第一个星期天"这样的概念，并在提供一个或多个年份后创建一组具体的日期。<span class="emphasis"><em>注：</em></span>从 boost 的
1_31_0 版本起，日期生成器的名字已被改变。旧的名字现在还可以使用，但是不再提供文档，并可能在某个时候取消。 </p>







<p>同时还提供了生成一个日期或计算一段日期长度的独立函数。这些函数以一个 date 对象和一个 weekday 对象为参数。 </p>







<p>所有日期生成器类和函数均位于 boost::gregorian 名字空间中。
  </p>







<p>例子 <a href="examples.html#date_time.examples.print_holidays" title="Print Holidays">打印假日</a> 示范了详细的用法。 
  </p>







<a name="algo_header"></a>
<h3>
<a name="id968684"></a>头文件</h3>







<pre class="programlisting">#include "boost/date_time/gregorian/gregorian.hpp"</pre>







<p>
  </p>







<a name="algo_overview"></a>
<h3>
<a name="id968704"></a>概要</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">类和 get_date 参数</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">year_based_generator<br>date get_date(greg_year year)</pre>






      </td>







      <td>以下类型的统一(抽象)的日期生成器基类：<code class="computeroutput">partial_date</code>, <code class="computeroutput">nth_day_of_the_week_in_month</code>, <code class="computeroutput">first_day_of_the_week_in_month</code>, 和 <code class="computeroutput">last_day_of_the_week_in_month</code>.</td>







    </tr>







    <tr>






      <td>例子 <a href="examples.html#date_time.examples.print_holidays" title="Print Holidays">打印假日</a> 示范了详细的用法。</td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">last_day_of_the_week_in_month(greg_weekday, <br>                              greg_month)<br>date get_date(greg_year year)</pre>






      </td>







      <td>计算象一月的最后一个星期天这样的日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">last_day_of_the_week_in_month lwdm(Monday,Jan);<br>date d = lwdm.get_date(2002);<br>//2002-Jan-28</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">first_day_of_the_week_in_month(greg_weekday,<br>                               greg_month)<br>date get_date(greg_year year)</pre>






      </td>







      <td>计算象一月的第一个星期一这样的日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">first_day_of_the_week_in_month fdm(Monday,Jan);<br>date d = fdm.get_date(2002);<br>//2002-Jan-07</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">nth_day_of_the_week_in_month(week_num, <br>                             greg_weekday,<br>                             greg_month)<br>date get_date(greg_year year)</pre>






      </td>







      <td>
      <code class="computeroutput">week_num</code> 是 <code class="computeroutput">nth_day_of_the_week_in_month</code> 的一个公有枚举成员。计算象一月的第一个星期一、三月的第二个星期二、十二月的第三个星期日等这样的日期。(支持第一到第五个，第五个相当于最后一个)</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">typedef nth_day_of_the_week_in_month nth_dow;<br>nth_dow ndm(nth_dow::third, Monday,Jan);<br>date d = ndm.get_date(2002);<br>//2002-Jan-21</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">partial_date(greg_day, greg_month)<br>date get_date(greg_year year)</pre>






      </td>







      <td>为给定的月份和日子提供一个年份以生成日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">partial_date pd(1,Jan);<br>date d = pd.get_date(2002);<br>//2002-Jan-01</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">first_day_of_the_week_after(greg_weekday)<br>date get_date(date d)</pre>






      </td>







      <td>计算象 Jan 1,2002 后的第一个星期天这样的日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">first_day_of_the_week_after fdaf(Monday);<br>date d = fdaf.get_date(date(2002,Jan,1));<br>//2002-Jan-07</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">first_day_of_the_week_before(greg_weekday)<br>date get_date(date d)</pre>






      </td>







      <td>计算象 Feb 1,2002 之前的第一个星期一这样的日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">first_day_of_the_week_before fdbf(Monday);<br>date d = fdbf.get_date(date(2002,Feb,1));<br>//2002-Jan-28</pre>







	  </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







<a name="algo_func_overview"></a>
<h3>
<a name="id969014"></a>函数概要</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">函数原型</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">days days_until_weekday date, greg_weekday)</pre>






      </td>







      <td>计算从给定日期到给定周日的天数。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2004,Jun,1); // 星期二<br>greg_weekday gw(Friday);<br>days_until_weekday(d, gw); // 3天</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">days days_before_weekday(date, greg_weekday)</pre>






      </td>







      <td>计算从给定日期到前一个给定周日的天数。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2004,Jun,1); // 星期二<br>greg_weekday gw(Friday);<br>days_before_weekday(d, gw); // 4天</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date next_weekday(date, greg_weekday)</pre>






      </td>







      <td>生成一个 date 对象，表示给定日期之后的某个周日的日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2004,Jun,1); // 星期二<br>greg_weekday gw(Friday);<br>next_weekday(d, gw); // 2004-Jun-4</pre>







	  </td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">date previous_weekday(date, greg_weekday)</pre>






      </td>







      <td>生成一个 date 对象，表示给定日期之前的某个周日的日期。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">date d(2004,Jun,1); // 星期二<br>greg_weekday gw(Friday);<br>previous_weekday(d, gw); // 2004-May-28</pre>







	  </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







</div>







<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="date_time.gregorian.gregorian_calendar"></a>格里历</h3>






</div>






</div>






</div>







<a href="gregorian.html#gregcal_intro">简介</a> --
  <a href="gregorian.html#gregcal_header">头文件</a> --
  <a href="gregorian.html#gregcal_functions">函数</a><a name="gregcal_intro"></a>
<h3>
<a name="id969222"></a>简介</h3>







<p>类&nbsp;boost::gregorian::gregorian_calendar 实现了创建格里历日期系统所需的函数。包括将日期的年-月-日格式转换为天数表示法以及相反的转换。 </p>







<p>对于多数用途，这个类只是被 <a href="gregorian.html#date_time.gregorian.date_class" title="Date">gregorian::date</a>
访问而不是由用户直接使用。不过，也有一些有用的函数可能被象 end_of_month_day 这样的函数使用。 </p>







<p>例子 <a href="examples.html#date_time.examples.print_month" title="Print Month">打印月份</a> 示范了以上功能。 
  </p>







<a name="gregcal_header"></a>
<h3>
<a name="id969265"></a>头文件</h3>







<p>
    </p>







<pre class="programlisting">#include "boost/date_time/gregorian/gregorian.hpp" //包含所有类型和 i/o<br>或<br>#include "boost/date_time/gregorian/gregorian_types.hpp" //只有类型没有 i/o</pre>







<p>
  </p>







<a name="gregcal_functions"></a>
<h3>
<a name="id969288"></a>函数</h3>







<div class="informaltable">
<table class="table">







  <colgroup><col><col></colgroup>
  <thead>
  <tr>







    <th rowspan="2" valign="top">语法</th>







    <th>说明</th>







  </tr>







  <tr>






    <th>例子</th>






  </tr>







  </thead>
  <tbody>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">static short day_of_week(ymd_type)</pre>






      </td>







      <td>返回星期几(0==星期天，1==星期一，等等)</td>







    </tr>







    <tr>






      <td>参见 <a href="gregorian.html#date_time.gregorian.date_class" title="Date">gregorian::date</a> day_of_week</td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">static date_int_type day_number(ymd_type)</pre>






      </td>







      <td> 将 ymd_type 转换为天数。该天数是一个从 epoch 起计的绝对数字。</td>







    </tr>







    <tr>






      <td>&nbsp;</td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">static short end_of_month_day(year_type,<br>                              month_type)</pre>






      </td>







      <td>给定年份和月份，确定该月最后一天。</td>







    </tr>







    <tr>






      <td>&nbsp;</td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">static ymd_type from_day_number(date_int_type)</pre>






      </td>







      <td>将天数转换为 ymd 结构。</td>







    </tr>







    <tr>






      <td>&nbsp;</td>






    </tr>







    <tr>







      <td rowspan="2" valign="top">
      
      
      
      
      
      
      <pre class="screen">static bool is_leap_year(year_type)</pre>






      </td>







      <td>返回 true 如果指定年份是闰年。</td>







    </tr>







    <tr>






      <td>
      
      
      
      
      
      
      <pre class="screen">gregorian_calendar::is_leap_year(2000)<br>//--&gt; true</pre>






      </td>






    </tr>







  
  
  
  
  
  
  </tbody>
</table>






</div>







</div>







</div>







<table width="100%">






  <tbody>






    <tr>







      <td align="left"></td>







      <td align="right"><small>Copyright &copy; 2001-2005 CrystalClear Software, Inc</small></td>







    </tr>






  
  
  
  
  
  
  </tbody>
</table>







<hr>
<div class="spirit-nav">
<a accesskey="p" href="examples/general_usage_examples.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../date_time.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="posix_time.html"><img src="../images/next.png" alt="Next"></a>
</div>







</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Appendices</title><link rel="stylesheet" href="../boostbook.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.3"><link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset"><link rel="up" href="../xpressive.html" title="Chapter&nbsp;27.&nbsp;Boost.Xpressive"><link rel="prev" href="../boost_xpressive/acknowledgments.html" title="Acknowledgments"><link rel="next" href="../tools.html" title="Part&nbsp;II.&nbsp;Boost Tools">







</head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../boost_xpressive/acknowledgments.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../tools.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="xpressive.appendices"></a><a class="link" href="appendices.html" title="Appendices">Appendices 附录</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.appendix_1__history">Appendix
      1: History 附录1：历史</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.appendix_2__not_yet_implemented">Appendix
      2: Not Yet Implemented 附录2：尚未实现的</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.appendix_3__differences_from_boost_regex">Appendix
      3: Differences from Boost.Regex 附录3：与Boost.Regex的差异</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.perf"> Appendix 4: Performance
      Comparison 附录4：性能比较</a></span></dt>
<dt><span class="section"><a href="appendices.html#xpressive.appendices.appendix_5__implementation_notes">Appendix
      5: Implementation Notes 附录5：实现说明</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.appendices.appendix_1__history"></a><a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history" title="Appendix 1: History">Appendix
      1: History 附录1：历史</a>
</h3></div></div></div>
<a name="boost_xpressive.appendices.appendix_1__history.version_2_1_0_6_12_2008"></a><h3>
<a name="id4186084"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_2_1_0_6_12_2008">Version
        2.1.0 6/12/2008</a>
      </h3>
<p>
        New Features:<br>新特性：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="computeroutput"><span class="identifier">skip</span><span class="special">()</span></code>
          primitive for static regexes, which allows you to specify parts of the
          input string to ignore during regex matching.<br><code class="computeroutput"><span class="identifier"></span></code>静态regex的 <code class="computeroutput"><span class="identifier">skip</span><span class="special">()</span></code>
原语，允许你指定在regex匹配时忽略部分的输入串。
        </li>
<li>
          Range-based <code class="computeroutput"><span class="identifier">regex_replace</span><span class="special">()</span></code> algorithm interface.<br>基于区间的 <code class="computeroutput"><span class="identifier">regex_replace</span><span class="special">()</span></code> 算法接口。
        </li>
<li>
<code class="computeroutput"><span class="identifier">regex_replace</span><span class="special">()</span></code>
          accepts formatter objects and formatter lambda expressions in addition
          to format strings.<br>除了格式化串以外，<code class="computeroutput"><span class="identifier">regex_replace</span><span class="special">()</span></code>
          还接受格式化器对象和格式化器lambda表达式。
        </li>
</ul></div>
<p>
        Bugs Fixed:<br>缺陷修复：
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          Semantic actions in look-aheads, look-behinds and independent sub-expressions
          execute eagerly instead of causing a crash.<br>在顺序环视、逆序环视中语义动作以及独立子表达式的执行不再导致崩溃。
        </li></ul></div>
<a name="boost_xpressive.appendices.appendix_1__history.version_2_0_1_10_23_2007"></a><h3>
<a name="id4186181"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_2_0_1_10_23_2007">Version
        2.0.1 10/23/2007</a>
      </h3>
<p>
        Bugs Fixed:<br>缺陷修复：
      </p>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><span class="identifier">sub_match</span><span class="special">&lt;&gt;</span></code>
          constructor copies singular iterator causing debug assert.<br><code class="computeroutput"><span class="identifier">sub_match</span><span class="special">&lt;&gt;</span></code>
          构造函数复制单个迭代器导致调试断言。
        </li></ul></div>
<a name="boost_xpressive.appendices.appendix_1__history.version_2_0_0__10_12_2007"></a><h3>
<a name="id4186230"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_2_0_0__10_12_2007">Version
        2.0.0, 10/12/2007</a>
      </h3>
<p>
        New Features:<br>新特性：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Semantic actions<br>语义动作
        </li>
<li>
          Custom assertions<br>定制断言
        </li>
<li>
          Named captures<br>命名捕获
        </li>
<li>
          Dynamic regex grammars<br>动态regex语法
        </li>
<li>
          Recursive dynamic regexes with <code class="literal">(?R)</code> construct<br>带 <code class="literal">(?R)</code> 结构的递归动态regex
        </li>
<li>
          Support for searching non-character data<br>支持查找非字符数据
        </li>
<li>
          Better errors for invalid static regexes<br>对于无效静态regex更好的错误提示
        </li>
<li>
          Range-based regex algorithm interface<br>基于区间的regex算法接口
        </li>
<li>
<code class="computeroutput"><span class="identifier">match_flag_type</span><span class="special">::</span><span class="identifier">format_perl</span></code>, <code class="computeroutput"><span class="identifier">match_flag_type</span><span class="special">::</span><span class="identifier">format_sed</span></code>,
          and <code class="computeroutput"><span class="identifier">match_flag_type</span><span class="special">::</span><span class="identifier">format_all</span></code><br><code class="computeroutput"><span class="identifier">match_flag_type</span><span class="special">::</span><span class="identifier">format_perl</span></code>, <code class="computeroutput"><span class="identifier">match_flag_type</span><span class="special">::</span><span class="identifier">format_sed</span></code>, 和 <code class="computeroutput"><span class="identifier">match_flag_type</span><span class="special">::</span><span class="identifier">format_all</span></code>
</li>
<li>
<code class="computeroutput"><span class="keyword">operator</span><span class="special">+(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">sub_match</span><span class="special">&lt;&gt;)</span></code>
          and variants<br><code class="computeroutput"><span class="keyword">operator</span><span class="special">+(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">sub_match</span><span class="special">&lt;&gt;)</span></code> 及其变体
        </li>
<li>
          Version 2 regex traits get <code class="computeroutput"><span class="identifier">tolower</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">toupper</span><span class="special">()</span></code><br>
          regex traits 版本2，带 <code class="computeroutput"><span class="identifier">tolower</span><span class="special">()</span></code> 和 <code class="computeroutput"><span class="identifier">toupper</span><span class="special">()</span></code>
</li>
</ul></div>
<p>
        Bugs Fixed:<br>缺陷修复：
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          Complementing single-character sets like <code class="computeroutput"><span class="special">~(</span><span class="identifier">set</span><span class="special">=</span><span class="char">'a'</span><span class="special">)</span></code> works.<br>单字符集合的取补，如 <code class="computeroutput"><span class="special">~(</span><span class="identifier">set</span><span class="special">=</span><span class="char">'a'</span><span class="special">)</span></code> 可用了。
        </li></ul></div>
<a name="boost_xpressive.appendices.appendix_1__history.version_1_0_2__april_27__2007"></a><h3>
<a name="id4186468"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_1_0_2__april_27__2007">Version
        1.0.2, April 27, 2007</a>
      </h3>
<p>
        Bugs Fixed:<br>缺陷修复：
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          Back-references greater than nine work as advertized.<br>大于9个的后向引用可用。
        </li></ul></div>
<p>
        This is the version that shipped as part of Boost 1.34.<br>这是作为 Boost 1.34 的组成部分交付的版本。
      </p>
<a name="boost_xpressive.appendices.appendix_1__history.version_1_0_1__october_2__2006"></a><h3>
<a name="id4186508"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_1_0_1__october_2__2006">Version
        1.0.1, October 2, 2006</a>
      </h3>
<p>
        Bugs Fixed:<br>缺陷修复：
      </p>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><span class="identifier">match_results</span><span class="special">::</span><span class="identifier">position</span><span class="special">()</span></code>
          works for nested results.<br><code class="computeroutput"><span class="identifier">match_results</span><span class="special">::</span><span class="identifier">position</span><span class="special">()</span></code>
          可用于嵌套结果。
        </li></ul></div>
<a name="boost_xpressive.appendices.appendix_1__history.version_1_0_0__march_16__2006"></a><h3>
<a name="id4186564"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_1_0_0__march_16__2006">Version
        1.0.0, March 16, 2006</a>
      </h3>
<p>
        Version 1.0!<br>版本 1.0!
      </p>
<a name="boost_xpressive.appendices.appendix_1__history.version_0_9_6__august_19__2005"></a><h3>
<a name="id4186591"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_0_9_6__august_19__2005">Version
        0.9.6, August 19, 2005</a>
      </h3>
<p>
        The version reviewed for acceptance into Boost. The review began September
        8, 2005. Xpressive was accepted into Boost on September 28, 2005.<br>这个版本为进入 Boost 而进行审查。审查从 September
        8, 2005 开始。Xpressive 在 September 28, 2005 被纳入 Boost。
      </p>
<a name="boost_xpressive.appendices.appendix_1__history.version_0_9_3__june_30__2005"></a><h3>
<a name="id4186620"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_0_9_3__june_30__2005">Version
        0.9.3, June 30, 2005</a>
      </h3>
<p>
        New Features:<br>新特性：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          TR1-style regex_traits interface<br>TR1-风格的 regex_traits 接口
        </li>
<li>
          Speed enhancements<br>速度提高
        </li>
<li><code class="computeroutput"><span class="identifier">syntax_option_type</span><span class="special">::</span><span class="identifier">ignore_white_space</span></code><br></li>
</ul></div>
<a name="boost_xpressive.appendices.appendix_1__history.version_0_9_0__september_2__2004"></a><h3>
<a name="id4186680"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_0_9_0__september_2__2004">Version
        0.9.0, September 2, 2004</a>
      </h3>
<p>
        New Features:<br>新特性：
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          It sort of works.<br>初期工作。
        </li></ul></div>
<a name="boost_xpressive.appendices.appendix_1__history.version_0_0_1__november_16__2003"></a><h3>
<a name="id4186715"></a>
        <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_1__history.version_0_0_1__november_16__2003">Version
        0.0.1, November 16, 2003</a>
      </h3>
<p>
        Announcement of xpressive: <a href="http://lists.boost.org/Archives/boost/2003/11/56312.php" target="_top">http://lists.boost.org/Archives/boost/2003/11/56312.php</a><br>xpressive 的声明：<a href="http://lists.boost.org/Archives/boost/2003/11/56312.php" target="_top">http://lists.boost.org/Archives/boost/2003/11/56312.php</a>
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.appendices.appendix_2__not_yet_implemented"></a><a class="link" href="appendices.html#boost_xpressive.appendices.appendix_2__not_yet_implemented" title="Appendix 2: Not Yet Implemented">Appendix
      2: Not Yet Implemented 附录2：尚未实现的</a>
</h3></div></div></div>
<p>
        The following features are planned for xpressive 2.X:<br>以下特性计划在 xpressive 2.X 实现：
      </p>
<div class="itemizedlist"><ul type="disc">
<li><code class="computeroutput"><span class="identifier">syntax_option_type</span><span class="special">::</span><span class="identifier">collate</span></code></li>
<li>
          Collation sequences such as <code class="literal">[.a.]</code><br>校对序列，如 <code class="literal">[.a.]</code>
</li>
<li>
          Equivalence classes like <code class="literal">[=a=]</code><br>等价类，如 <code class="literal">[=a=]</code>
</li>
<li>
          Control of nested results generation with <code class="computeroutput"><span class="identifier">syntax_option_type</span><span class="special">::</span><span class="identifier">nosubs</span></code>,
          and a <code class="computeroutput"><span class="identifier">nosubs</span><span class="special">()</span></code>
          modifier for static xpressive.<br>用 <code class="computeroutput"><span class="identifier">syntax_option_type</span><span class="special">::</span><span class="identifier">nosubs</span></code> 控制嵌套结果的生成，以及静态xpressive的 <code class="computeroutput"><span class="identifier">nosubs</span><span class="special">()</span></code>
          修饰符。
        </li>
</ul></div>
<p>
        Here are some wish-list features. You or your company should consider hiring
        me to implement them!<br>以下是一些希望增加的特性列表。你或你的公司应该考虑雇用我来实现它们！
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Optimized DFA back-end for simple, fast regexing.<br>优化的DFA后端，为了简单、快速的regexing。
        </li>
<li>
          Different regex compiler front ends for basic, extended, awk, grep and
          egrep regex syntax.<br>用于基本的、扩展的、awk、grep 和 egrep regex 语法的不同的regex编译器前端。
        </li>
<li>
          Fine-grained control over the dynamic regex syntax<br>对动态regex语法的细粒度控制
        </li>
<li>
          Optional integration with ICU for full Unicode support.<br>与ICU的可选集成，以全面支持Unicode。
        </li>
<li>
          Improved localization support, possibly as a custom facet for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>.<br>改进本地化支持，如对 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code> 的一个定制 facet。
        </li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.appendices.appendix_3__differences_from_boost_regex"></a><a class="link" href="appendices.html#boost_xpressive.appendices.appendix_3__differences_from_boost_regex" title="Appendix 3: Differences from Boost.Regex">Appendix
      3: Differences from Boost.Regex 附录3：与Boost.Regex的差异</a>
</h3></div></div></div>
<p>
        Since many of xpressive's users are likely to be familiar with the <a href="../../../libs/regex" target="_top">Boost.Regex</a> library, I would be remiss if
        I failed to point out some important differences between xpressive and <a href="../../../libs/regex" target="_top">Boost.Regex</a>. In particular:<br>由于xpressive的许多用户都很熟悉 <a href="../../../libs/regex" target="_top">Boost.Regex</a> 库，如果我不指出 xpressive 和 <a href="../../../libs/regex" target="_top">Boost.Regex</a> 之间的主要差异，将是失职的。特别是：<br>
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          is a template on the iterator type, not the character type.<br><code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          是基于迭代器类型而不是字符类型的模板。
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          cannot be constructed directly from a string; rather, you must use <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">()</span></code>
          or <code class="computeroutput"><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code>
          to build a regex object from a string.<br><code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          不能直接从字符串构造；你必须使用 <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">()</span></code> 或 <code class="computeroutput"><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code>
          来从字符串构造一个regex对象。
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          does not have an <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code> member function; rather, the <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
          member function is in the <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code> factory.<br><code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          没有 <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code> 成员函数；<code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
          成员函数是在 <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code> 工厂中的。
        </li>
<li>
<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          has a subset of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>'s
          members. <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          does not. The members lacking are: <code class="computeroutput"><span class="identifier">assign</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]()</span></code>, <code class="computeroutput"><span class="identifier">max_size</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">compare</span><span class="special">()</span></code>, and <code class="computeroutput"><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;)</span></code>.<br><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> 具有 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>
          成员函数的一个子集。<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          则没有。缺少的成员包括有：<code class="computeroutput"><span class="identifier">assign</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]()</span></code>, <code class="computeroutput"><span class="identifier">max_size</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">compare</span><span class="special">()</span></code>, 和 <code class="computeroutput"><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;)</span></code>.
        </li>
<li>
          Other member functions that exist in <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> but do not exist in <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          are: <code class="computeroutput"><span class="identifier">set_expression</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">get_allocator</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">getloc</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">getflags</span><span class="special">()</span></code>,
          and <code class="computeroutput"><span class="identifier">str</span><span class="special">()</span></code>.<br>其它在 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> 中有而在 <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          中没有的成员函数包括有：<code class="computeroutput"><span class="identifier">set_expression</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">get_allocator</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">getloc</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">getflags</span><span class="special">()</span></code>, 和 <code class="computeroutput"><span class="identifier">str</span><span class="special">()</span></code>.
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          does not have a RegexTraits template parameter. Customization of regex
          syntax and localization behavior will be controlled by <code class="computeroutput"><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code> and a custom regex facet for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>.<br><code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> 不带 RegexTraits 模板参数。对regex语法和本地化行为的定制由 <code class="computeroutput"><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code> 和为 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>&nbsp;定制的 regex facet 来控制。
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          and <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">match_results</span><span class="special">&lt;&gt;</span></code>
          do not have an Allocator template parameter. This is by design.<br><code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">match_results</span><span class="special">&lt;&gt;</span></code> 不带 Allocator 模板参数。这是设计的原因。
        </li>
<li>
<code class="computeroutput"><span class="identifier">match_not_dot_null</span></code> and
          <code class="computeroutput"><span class="identifier">match_not_dot_newline</span></code> have
          moved from the <code class="computeroutput"><span class="identifier">match_flag_type</span></code>
          enum to the <code class="computeroutput"><span class="identifier">syntax_option_type</span></code>
          enum, and they have changed names to <code class="computeroutput"><span class="identifier">not_dot_null</span></code>
          and <code class="computeroutput"><span class="identifier">not_dot_newline</span></code>.<br><code class="computeroutput"><span class="identifier">match_not_dot_null</span></code> 和
          <code class="computeroutput"><span class="identifier">match_not_dot_newline</span></code> 从 <code class="computeroutput"><span class="identifier">match_flag_type</span></code>
          enum 移至 <code class="computeroutput"><span class="identifier">syntax_option_type</span></code>
          enum，并且改名为 <code class="computeroutput"><span class="identifier">not_dot_null</span></code> 和 <code class="computeroutput"><span class="identifier">not_dot_newline</span></code>.
        </li>
<li>
          The following <code class="computeroutput"><span class="identifier">syntax_option_type</span></code>
          enumeration values are not supported: <code class="computeroutput"><span class="identifier">escape_in_lists</span></code>,
          <code class="computeroutput"><span class="identifier">char_classes</span></code>, <code class="computeroutput"><span class="identifier">intervals</span></code>, <code class="computeroutput"><span class="identifier">limited_ops</span></code>,
          <code class="computeroutput"><span class="identifier">newline_alt</span></code>, <code class="computeroutput"><span class="identifier">bk_plus_qm</span></code>, <code class="computeroutput"><span class="identifier">bk_braces</span></code>,
          <code class="computeroutput"><span class="identifier">bk_parens</span></code>, <code class="computeroutput"><span class="identifier">bk_refs</span></code>, <code class="computeroutput"><span class="identifier">bk_vbar</span></code>,
          <code class="computeroutput"><span class="identifier">use_except</span></code>, <code class="computeroutput"><span class="identifier">failbit</span></code>, <code class="computeroutput"><span class="identifier">literal</span></code>,
          <code class="computeroutput"><span class="identifier">perlex</span></code>, <code class="computeroutput"><span class="identifier">basic</span></code>,
          <code class="computeroutput"><span class="identifier">extended</span></code>, <code class="computeroutput"><span class="identifier">emacs</span></code>, <code class="computeroutput"><span class="identifier">awk</span></code>,
          <code class="computeroutput"><span class="identifier">grep</span></code> ,<code class="computeroutput"><span class="identifier">egrep</span></code>,
          <code class="computeroutput"><span class="identifier">sed</span></code>, <code class="computeroutput"><span class="identifier">JavaScript</span></code>,
          <code class="computeroutput"><span class="identifier">JScript</span></code>.<br>以下 <code class="computeroutput"><span class="identifier">syntax_option_type</span></code>
          枚举值不被支持：<code class="computeroutput"><span class="identifier">escape_in_lists</span></code>,
          <code class="computeroutput"><span class="identifier">char_classes</span></code>, <code class="computeroutput"><span class="identifier">intervals</span></code>, <code class="computeroutput"><span class="identifier">limited_ops</span></code>,
          <code class="computeroutput"><span class="identifier">newline_alt</span></code>, <code class="computeroutput"><span class="identifier">bk_plus_qm</span></code>, <code class="computeroutput"><span class="identifier">bk_braces</span></code>,
          <code class="computeroutput"><span class="identifier">bk_parens</span></code>, <code class="computeroutput"><span class="identifier">bk_refs</span></code>, <code class="computeroutput"><span class="identifier">bk_vbar</span></code>,
          <code class="computeroutput"><span class="identifier">use_except</span></code>, <code class="computeroutput"><span class="identifier">failbit</span></code>, <code class="computeroutput"><span class="identifier">literal</span></code>,
          <code class="computeroutput"><span class="identifier">perlex</span></code>, <code class="computeroutput"><span class="identifier">basic</span></code>,
          <code class="computeroutput"><span class="identifier">extended</span></code>, <code class="computeroutput"><span class="identifier">emacs</span></code>, <code class="computeroutput"><span class="identifier">awk</span></code>,
          <code class="computeroutput"><span class="identifier">grep</span></code> ,<code class="computeroutput"><span class="identifier">egrep</span></code>,
          <code class="computeroutput"><span class="identifier">sed</span></code>, <code class="computeroutput"><span class="identifier">JavaScript</span></code>,
          <code class="computeroutput"><span class="identifier">JScript</span></code>.
        </li>
<li>
          The following <code class="computeroutput"><span class="identifier">match_flag_type</span></code>
          enumeration values are not supported: <code class="computeroutput"><span class="identifier">match_not_bob</span></code>,
          <code class="computeroutput"><span class="identifier">match_not_eob</span></code>, <code class="computeroutput"><span class="identifier">match_perl</span></code>, <code class="computeroutput"><span class="identifier">match_posix</span></code>,
          and <code class="computeroutput"><span class="identifier">match_extra</span></code>.<br>以下 <code class="computeroutput"><span class="identifier">match_flag_type</span></code>
          枚举值不被支持：<code class="computeroutput"><span class="identifier">match_not_bob</span></code>,
          <code class="computeroutput"><span class="identifier">match_not_eob</span></code>, <code class="computeroutput"><span class="identifier">match_perl</span></code>, <code class="computeroutput"><span class="identifier">match_posix</span></code>,
          and <code class="computeroutput"><span class="identifier">match_extra</span></code>.
        </li>
</ul></div>
<p>
        Also, in the current implementation, the regex algorithms in xpressive will
        not detect pathological behavior and abort by throwing an exception. It is
        up to you to write efficient patterns that do not behave pathologically.<br>还有，在当前的实现中，xpressive中的regex算法不检测反常行为，并以抛出异常的方式退出。编写无反常行为的高效模式的责任在你。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.appendices.perf"></a><a class="link" href="appendices.html#boost_xpressive.appendices.perf" title="Appendix 4: Performance Comparison"> Appendix 4: Performance
      Comparison 附录4：性能比较</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.perf.perf_gcc"> xpressive
        vs. Boost.Regex with GCC (Cygwin)</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.perf.perf_msvc"> xpressive
        vs. Boost.Regex with Visual C++</a></span></dt>
</dl></div>
<p>
        The performance of xpressive is competitive with <a href="../../../libs/regex" target="_top">Boost.Regex</a>.
        I have run performance benchmarks comparing static xpressive, dynamic xpressive
        and <a href="../../../libs/regex" target="_top">Boost.Regex</a> on two platforms: gcc
        (Cygwin) and Visual C++. The tests include short matches and long searches.
        For both platforms, xpressive comes off well on short matches and roughly
        on par with <a href="../../../libs/regex" target="_top">Boost.Regex</a> on long searches.<br>xpressive 的性能可以与 <a href="../../../libs/regex" target="_top">Boost.Regex</a> 相比。我在两个平台上运行了性能测试，比较了静态xpressive、动态xpressive 和 <a href="../../../libs/regex" target="_top">Boost.Regex</a>：gcc
        (Cygwin) 和 Visual C++。测试包括了短匹配和长查找。在两个平台上，xpressive都在短匹配上胜出，而在长查找中则大致与 <a href="../../../libs/regex" target="_top">Boost.Regex</a> 相同。
      </p>
<p>
        &lt;disclaimer&gt; As with all benchmarks, the true test is how xpressive
        performs with <span class="emphasis"><em>your</em></span> patterns, <span class="emphasis"><em>your</em></span>
        input, and <span class="emphasis"><em>your</em></span> platform, so if performance matters
        in your application, it's best to run your own tests. &lt;/disclaimer&gt;<br>&lt;disclaimer&gt; 和所有基准测试一样，真实的测试视乎xpressive如何执行<span class="emphasis"><em>你的</em></span>模式，<span class="emphasis"><em>你的</em></span>输入，和<span class="emphasis"><em>你的</em></span>平台，所以，如果性能对于你的应用是至关重要的，最好能运行你自己的测试。 &lt;/disclaimer&gt;
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.appendices.perf.perf_gcc"></a><a class="link" href="appendices.html#boost_xpressive.appendices.perf.perf_gcc" title="xpressive vs. Boost.Regex with GCC (Cygwin)"> xpressive
        vs. Boost.Regex with GCC (Cygwin)</a>
</h4></div></div></div>
<p>
          Below are the results of a performance comparison between:<br>以下是它们之间的性能比较结果：
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            static xpressive<br>静态xpressive
          </li>
<li>
            dynamic xpressive<br>动态xpressive
          </li>
<li><a href="../../../libs/regex" target="_top">Boost.Regex</a></li>
</ul></div>
<div class="variablelist">
<p class="title"><b>Test Specifications 测试规范</b></p>
<dl>
<dt><span class="term">Hardware: 硬件：</span></dt>
<dd><p>
              hyper-threaded 3GHz Xeon with 1Gb RAM
            </p></dd>
<dt><span class="term">Operating System: 操作系统：</span></dt>
<dd><p>
              Windows XP Pro + Cygwin
            </p></dd>
<dt><span class="term">Compiler: 编译器：</span></dt>
<dd><p>
              GNU C++ version 3.4.4 (Cygwin special)
            </p></dd>
<dt><span class="term">C++ Standard Library: &nbsp;C++标准库：</span></dt>
<dd><p>
              GNU libstdc++ version 3.4.4
            </p></dd>
<dt><span class="term"><a href="../../../libs/regex" target="_top">Boost.Regex</a>
          Version:</span></dt>
<dd><p>
              1.33+, BOOST_REGEX_USE_CPP_LOCALE, BOOST_REGEX_RECURSIVE
            </p></dd>
<dt><span class="term">xpressive Version:</span></dt>
<dd><p>
              0.9.6a
            </p></dd>
</dl>
</div>
<a name="boost_xpressive.appendices.perf.perf_gcc.comparison_1__short_matches"></a><h3>
<a name="id4188091"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.perf.perf_gcc.comparison_1__short_matches">Comparison
          1: Short Matches 比较1：短匹配</a>
        </h3>
<p>
          The following tests evaluate the time taken to match the expression to
          the input string. For each result, the top number has been normalized relative
          to the fastest time, so 1.0 is as good as it gets. The bottom number (in
          parentheses) is the actual time in seconds. The best time has been marked
          in green.<br>以下测试评估了将正则表达式与输入串进行匹配所花的时间。对于每一个结果，上面的数字已相对于最快时间进行了规范化，所以1.0是最好的。底下的数字(括号上的)是以秒计的实际时间。最佳时间以绿色标出。
        </p>
<div class="informaltable">
<h5>
<a name="id4188122"></a><span class="table-title">Short Matches 短匹配</span>
</h5>
<table class="table">
<colgroup><col><col><col><col><col></colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Text</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(8.79e‑07s)</span></td>
<td><span class="highlight">1.08<p></p>(9.54e‑07s)</span></td>
<td>2.51<p></p>(2.2e‑06s)</td>
<td>100- this is a line of ftp response which contains a message string</td>
<td><code class="literal">^([0-9]+)(\-| |$)(.*)$</code></td>
</tr>
<tr>
<td><span class="highlight">1.06<p></p>(1.07e‑06s)</span></td>
<td><span class="highlight">1<p></p>(1.01e‑06s)</span></td>
<td>4.01<p></p>(4.06e‑06s)</td>
<td>1234-5678-1234-456</td>
<td><code class="literal">([[:digit:]]{4}[- ]){3}[[:digit:]]{3,4}</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(1.4e‑06s)</span></td>
<td>1.13<p></p>(1.58e‑06s)</td>
<td>2.89<p></p>(4.05e‑06s)</td>
<td>john_maddock@compuserve.com</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(1.28e‑06s)</span></td>
<td>1.16<p></p>(1.49e‑06s)</td>
<td>3.07<p></p>(3.94e‑06s)</td>
<td>foo12@foo.edu</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(1.22e‑06s)</span></td>
<td>1.2<p></p>(1.46e‑06s)</td>
<td>3.22<p></p>(3.93e‑06s)</td>
<td>bob.smith@foo.tv</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1.04<p></p>(8.64e‑07s)</span></td>
<td><span class="highlight">1<p></p>(8.34e‑07s)</span></td>
<td>2.5<p></p>(2.09e‑06s)</td>
<td>EH10 2QQ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td>1.11<p></p>(9.09e‑07s)</td>
<td><span class="highlight">1<p></p>(8.19e‑07s)</span></td>
<td>2.47<p></p>(2.03e‑06s)</td>
<td>G1 1AA</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td>1.12<p></p>(9.38e‑07s)</td>
<td><span class="highlight">1<p></p>(8.34e‑07s)</span></td>
<td>2.5<p></p>(2.08e‑06s)</td>
<td>SW1 1ZZ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(7.9e‑07s)</span></td>
<td><span class="highlight">1.06<p></p>(8.34e‑07s)</span></td>
<td>2.49<p></p>(1.96e‑06s)</td>
<td>4/1/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(8.19e‑07s)</span></td>
<td><span class="highlight">1.04<p></p>(8.49e‑07s)</span></td>
<td>2.4<p></p>(1.97e‑06s)</td>
<td>12/12/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1.09<p></p>(8.95e‑07s)</span></td>
<td><span class="highlight">1<p></p>(8.19e‑07s)</span></td>
<td>2.4<p></p>(1.96e‑06s)</td>
<td>123</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td>1.11<p></p>(8.79e‑07s)</td>
<td><span class="highlight">1<p></p>(7.9e‑07s)</span></td>
<td>2.57<p></p>(2.03e‑06s)</td>
<td>+3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td><span class="highlight">1.09<p></p>(8.94e‑07s)</span></td>
<td><span class="highlight">1<p></p>(8.19e‑07s)</span></td>
<td>2.47<p></p>(2.03e‑06s)</td>
<td>-3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.appendices.perf.perf_gcc.comparison_2__long_searches"></a><h3>
<a name="id4188600"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.perf.perf_gcc.comparison_2__long_searches">Comparison
          2: Long Searches 比较2：长查找</a>
        </h3>
<p>
          The next test measures the time to find <span class="emphasis"><em>all</em></span> matches
          in a long English text. The text is the <a href="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip" target="_top">complete
          works of Mark Twain</a>, from <a href="http://promo.net/pg/" target="_top">Project
          Gutenberg</a>. The text is 19Mb long. As above, the top number is the
          normalized time and the bottom number is the actual time. The best time
          is in green.<br>下一个测试计量在一篇较长的英文中找出<span class="emphasis"><em>所有</em></span>匹配所花的时间。文章是 <a href="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip" target="_top">complete
          works of Mark Twain</a>，来自 <a href="http://promo.net/pg/" target="_top">Project
          Gutenberg</a>。该文章长度为19Mb。同上，上面的数字是规范化的时间，底下的数字则是实际时间。最佳时间为绿色。
        </p>
<div class="informaltable">
<h5>
<a name="id4188646"></a><span class="table-title">Long Searches 长查找</span>
</h5>
<table class="table">
<colgroup><col><col><col><col></colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(0.0263s)</span></td>
<td><span class="highlight">1<p></p>(0.0263s)</span></td>
<td>1.78<p></p>(0.0469s)</td>
<td><code class="literal">Twain</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(0.0234s)</span></td>
<td><span class="highlight">1<p></p>(0.0234s)</span></td>
<td>1.79<p></p>(0.042s)</td>
<td><code class="literal">Huck[[:alpha:]]+</code></td>
</tr>
<tr>
<td>1.84<p></p>(1.26s)</td>
<td>2.21<p></p>(1.51s)</td>
<td><span class="highlight">1<p></p>(0.687s)</span></td>
<td><code class="literal">[[:alpha:]]+ing</code></td>
</tr>
<tr>
<td><span class="highlight">1.09<p></p>(0.192s)</span></td>
<td>2<p></p>(0.351s)</td>
<td><span class="highlight">1<p></p>(0.176s)</span></td>
<td><code class="literal">^[^
]*?Twain</code></td>
</tr>
<tr>
<td>1.41<p></p>(0.08s)</td>
<td>1.21<p></p>(0.0684s)</td>
<td><span class="highlight">1<p></p>(0.0566s)</span></td>
<td><code class="literal">Tom|Sawyer|Huckleberry|Finn</code></td>
</tr>
<tr>
<td>1.56<p></p>(0.195s)</td>
<td>1.12<p></p>(0.141s)</td>
<td><span class="highlight">1<p></p>(0.125s)</span></td>
<td><code class="literal">(Tom|Sawyer|Huckleberry|Finn).{0,30}river|river.{0,30}(Tom|Sawyer|Huckleberry|Finn)</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.appendices.perf.perf_msvc"></a><a class="link" href="appendices.html#boost_xpressive.appendices.perf.perf_msvc" title="xpressive vs. Boost.Regex with Visual C++"> xpressive
        vs. Boost.Regex with Visual C++</a>
</h4></div></div></div>
<p>
          Below are the results of a performance comparison between:<br>以下是它们之间的性能比较结果：
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            static xpressive<br>静态xpressive
          </li>
<li>
            dynamic xpressive<br>动态xpressive
          </li>
<li><a href="../../../libs/regex" target="_top">Boost.Regex</a></li>
</ul></div>
<div class="variablelist">
<p class="title"><b>Test Specifications 测试规范</b></p>
<dl>
<dt><span class="term">Hardware: 硬件：</span></dt>
<dd><p>
              hyper-threaded 3GHz Xeon with 1Gb RAM
            </p></dd>
<dt><span class="term">Operating System: 操作系统：</span></dt>
<dd><p>
              Windows XP Pro
            </p></dd>
<dt><span class="term">Compiler: 编译器：</span></dt>
<dd><p>
              Visual C++ .NET 2003 (7.1)
            </p></dd>
<dt><span class="term">C++ Standard Library: &nbsp;C++标准库：</span></dt>
<dd><p>
              Dinkumware, version 313
            </p></dd>
<dt><span class="term"><a href="../../../libs/regex" target="_top">Boost.Regex</a>
          Version:</span></dt>
<dd><p>
              1.33+, BOOST_REGEX_USE_CPP_LOCALE, BOOST_REGEX_RECURSIVE
            </p></dd>
<dt><span class="term">xpressive Version:</span></dt>
<dd><p>
              0.9.6a
            </p></dd>
</dl>
</div>
<a name="boost_xpressive.appendices.perf.perf_msvc.comparison_1__short_matches"></a><h3>
<a name="id4188997"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.perf.perf_msvc.comparison_1__short_matches">Comparison
          1: Short Matches 比较1：短匹配</a>
        </h3>
<p>
          The following tests evaluate the time taken to match the expression to
          the input string. For each result, the top number has been normalized relative
          to the fastest time, so 1.0 is as good as it gets. The bottom number (in
          parentheses) is the actual time in seconds. The best time has been marked
          in green.<br>以下测试评估了将正则表达式与输入串进行匹配所花的时间。对于每一个结果，上面的数字已相对于最快时间进行了规范化，所以1.0是最好的。底下的数字(括号上的)是以秒计的实际时间。最佳时间以绿色标出。
        
        </p>
<div class="informaltable">
<h5>
<a name="id4189028"></a><span class="table-title">Short Matches 短匹配</span>
</h5>
<table class="table">
<colgroup><col><col><col><col><col></colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Text</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(3.2e‑007s)</span></td>
<td>1.37<p></p>(4.4e‑007s)</td>
<td>2.38<p></p>(7.6e‑007s)</td>
<td>100- this is a line of ftp response which contains a message string</td>
<td><code class="literal">^([0-9]+)(\-| |$)(.*)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(6.4e‑007s)</span></td>
<td>1.12<p></p>(7.15e‑007s)</td>
<td>1.72<p></p>(1.1e‑006s)</td>
<td>1234-5678-1234-456</td>
<td><code class="literal">([[:digit:]]{4}[- ]){3}[[:digit:]]{3,4}</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(9.82e‑007s)</span></td>
<td>1.3<p></p>(1.28e‑006s)</td>
<td>1.61<p></p>(1.58e‑006s)</td>
<td>john_maddock@compuserve.com</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(8.94e‑007s)</span></td>
<td>1.3<p></p>(1.16e‑006s)</td>
<td>1.7<p></p>(1.52e‑006s)</td>
<td>foo12@foo.edu</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(9.09e‑007s)</span></td>
<td>1.28<p></p>(1.16e‑006s)</td>
<td>1.67<p></p>(1.52e‑006s)</td>
<td>bob.smith@foo.tv</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.06e‑007s)</span></td>
<td><span class="highlight">1.07<p></p>(3.28e‑007s)</span></td>
<td>1.95<p></p>(5.96e‑007s)</td>
<td>EH10 2QQ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.13e‑007s)</span></td>
<td><span class="highlight">1.09<p></p>(3.42e‑007s)</span></td>
<td>1.86<p></p>(5.81e‑007s)</td>
<td>G1 1AA</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.2e‑007s)</span></td>
<td><span class="highlight">1.09<p></p>(3.5e‑007s)</span></td>
<td>1.86<p></p>(5.96e‑007s)</td>
<td>SW1 1ZZ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(2.68e‑007s)</span></td>
<td>1.22<p></p>(3.28e‑007s)</td>
<td>2<p></p>(5.36e‑007s)</td>
<td>4/1/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(2.76e‑007s)</span></td>
<td>1.16<p></p>(3.2e‑007s)</td>
<td>1.94<p></p>(5.36e‑007s)</td>
<td>12/12/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(2.98e‑007s)</span></td>
<td><span class="highlight">1.03<p></p>(3.06e‑007s)</span></td>
<td>1.85<p></p>(5.51e‑007s)</td>
<td>123</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.2e‑007s)</span></td>
<td>1.12<p></p>(3.58e‑007s)</td>
<td>1.81<p></p>(5.81e‑007s)</td>
<td>+3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.28e‑007s)</span></td>
<td>1.11<p></p>(3.65e‑007s)</td>
<td>1.77<p></p>(5.81e‑007s)</td>
<td>-3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.appendices.perf.perf_msvc.comparison_2__long_searches"></a><h3>
<a name="id4189496"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.perf.perf_msvc.comparison_2__long_searches">Comparison
          2: Long Searches 比较2：长查找</a>
        </h3>
<p>
          The next test measures the time to find <span class="emphasis"><em>all</em></span> matches
          in a long English text. The text is the <a href="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip" target="_top">complete
          works of Mark Twain</a>, from <a href="http://promo.net/pg/" target="_top">Project
          Gutenberg</a>. The text is 19Mb long. As above, the top number is the
          normalized time and the bottom number is the actual time. The best time
          is in green.<br>下一个测试计量在一篇较长的英文中找出<span class="emphasis"><em>所有</em></span>匹配所花的时间。文章是 <a href="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip" target="_top">complete
          works of Mark Twain</a>，来自 <a href="http://promo.net/pg/" target="_top">Project
          Gutenberg</a>。该文章长度为19Mb。同上，上面的数字是规范化的时间，底下的数字则是实际时间。最佳时间为绿色。
        
        </p>
<div class="informaltable">
<h5>
<a name="id4189544"></a><span class="table-title">Long Searches 长查找</span>
</h5>
<table class="table">
<colgroup><col><col><col><col></colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(0.019s)</span></td>
<td><span class="highlight">1<p></p>(0.019s)</span></td>
<td>2.98<p></p>(0.0566s)</td>
<td><code class="literal">Twain</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(0.0176s)</span></td>
<td><span class="highlight">1<p></p>(0.0176s)</span></td>
<td>3.17<p></p>(0.0556s)</td>
<td><code class="literal">Huck[[:alpha:]]+</code></td>
</tr>
<tr>
<td>3.62<p></p>(1.78s)</td>
<td>3.97<p></p>(1.95s)</td>
<td><span class="highlight">1<p></p>(0.492s)</span></td>
<td><code class="literal">[[:alpha:]]+ing</code></td>
</tr>
<tr>
<td>2.32<p></p>(0.344s)</td>
<td>3.06<p></p>(0.453s)</td>
<td><span class="highlight">1<p></p>(0.148s)</span></td>
<td><code class="literal">^[^
]*?Twain</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(0.0576s)</span></td>
<td><span class="highlight">1.05<p></p>(0.0606s)</span></td>
<td>1.15<p></p>(0.0664s)</td>
<td><code class="literal">Tom|Sawyer|Huckleberry|Finn</code></td>
</tr>
<tr>
<td>1.24<p></p>(0.164s)</td>
<td>1.44<p></p>(0.191s)</td>
<td><span class="highlight">1<p></p>(0.133s)</span></td>
<td><code class="literal">(Tom|Sawyer|Huckleberry|Finn).{0,30}river|river.{0,30}(Tom|Sawyer|Huckleberry|Finn)</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="xpressive.appendices.appendix_5__implementation_notes"></a><a class="link" href="appendices.html#xpressive.appendices.appendix_5__implementation_notes" title="Appendix 5: Implementation Notes">Appendix
      5: Implementation Notes 附录5：实现说明</a>
</h3></div></div></div>
<div class="toc"><dl><dt><a href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___"><span class="section"></span></a><a href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___">Cycle
        collection with <code class="literal">tracking_ptr&lt;&gt;&nbsp;</code></a><span class="section"><a href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___">带</a></span><a href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___"><span class="section"></span></a><a href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___"> <code class="literal">tracking_ptr&lt;&gt;</code></a><span class="section"><a href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___"> 的循环
        collection<code class="literal"></code></a></span></dt></dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___"></a><a class="link" href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___" title="Cycle collection with tracking_ptr&lt;&gt;">Cycle
        collection with <code class="literal">tracking_ptr&lt;&gt;</code></a>
</h4></div></div></div>
<p>
          In xpressive, regex objects can refer to each other and themselves by value
          or by reference. In addition, they ref-count their referenced regexes to
          keep them alive. This creates the possibility for cyclic reference counts,
          and raises the possibility of memory leaks. xpressive avoids leaks by using
          a type called <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>. This doc describes at a high level
          how <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>
          works.<br>在xpressive中，regex对象可以以值方式或引用方式相互引用或自身引用。另外，它们对所引用的regexes进行引用计数以确保它们的生存。这样就可能产生循环的引用计数，并可能导致内存泄漏。xpressive通过使用一个名为 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> 的类型来防止泄漏。本文档从较高的层面来说明 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> 是如何工作的。
        </p>
<a name="boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.constraints"></a><h3>
<a name="id4189846"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.constraints">Constraints 约束</a>
        </h3>
<p>
          Our solution must meet the following design constraints:<br>我们的解决方案必须符合以下设计约束：
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            No dangling references: All objects referred to directly or indirectly
            must be kept alive as long as the references are needed.<br>没有悬空的引用：所有被直接或间接的对象必须在引用需要的期间保持生存。
          </li>
<li>
            No leaks: all objects must be freed eventually.<br>没有泄漏：所有对象最后必须被释放。
          </li>
<li>
            No user intervention: The solution must not require users to explicitly
            invoke some cycle collection routine.<br>没有用户干预：解决方案必须不需要用户显式地执行一些周期性的收集例程。
          </li>
<li>
            Clean-up is no-throw: The collection phase will likely be called from
            a destructor, so it must never throw an exception under any circumstance.<br>无抛出的清理：收集的阶段通常都是从析构函数调用的，所以在任何情况下都必须不会抛出异常。
          </li>
</ul></div>
<a name="boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.handle_body_idiom"></a><h3>
<a name="id4189904"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.handle_body_idiom">Handle-Body
          Idiom 句柄-实体惯用法</a>
        </h3>
<p>
          To use <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>,
          you must separate your type into a handle and a body. In the case of xpressive,
          the handle type is called <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> and the body is called <code class="computeroutput"><span class="identifier">regex_impl</span><span class="special">&lt;&gt;</span></code>.
          The handle will store a <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> to the body.<br>要使用 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>，你必须将你的类型分为句柄和实体。对于xpressive，句柄类型名为 <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> 而实体类型名为 <code class="computeroutput"><span class="identifier">regex_impl</span><span class="special">&lt;&gt;</span></code>。
         句柄将保存一个到实体的 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>。
        </p>
<p>
          The body type must inherit from <code class="computeroutput"><span class="identifier">enable_reference_tracking</span><span class="special">&lt;&gt;</span></code>. This gives the body the bookkeeping
          data structures that <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> will use. In particular, it gives
          the body:<br>实体类型必须继承自 <code class="computeroutput"><span class="identifier">enable_reference_tracking</span><span class="special">&lt;&gt;</span></code>。这为实体提供了一些 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> 会用到的簿记数据结构。特定地，实体中有：
        </p>
<div class="orderedlist"><ol type="1">
<li>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span>
            <span class="special">&gt;</span> <span class="identifier">refs_</span></code>
            : collection of bodies to which this body refers, and<br><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span>
            <span class="special">&gt;</span> <span class="identifier">refs_</span></code>
            : 收集了该实体所引用的实体，和
          </li>
<li>
<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">weak_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span>
            <span class="special">&gt;</span> <span class="identifier">deps_</span></code>
            : collection of bodies which refer to this body.<br><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">weak_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span>
            <span class="special">&gt;</span> <span class="identifier">deps_</span></code>
            : 收集了引用了该实体的实体。
          </li>
</ol></div>
<a name="boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.references_and_dependencies"></a><h3>
<a name="id4190142"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.references_and_dependencies">References
          and Dependencies 引用与依赖</a>
        </h3>
<p>
          We refer to (1) above as the "references" and (2) as the "dependencies".
          It is crucial to the understanding of <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> to recognize that the set of references
          includes both those objects that are referred to directly as well as those
          that are referred to indirectly (that is, through another reference). The
          same is true for the set of dependencies. In other words, each body holds
          a ref-count directly to every other body that it needs.<br>我们将以上的(1)称为"引用"，而(2)称为"依赖"。要弄明白 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>，很重要的一点是，要知道这个"引用"集合既包含直接引用的对象，也包含那些间接引用的对象(即通过另一个引用来引用的)。对于"依赖"集合也同样如此。换句话说，每一个实体都持有对它所需的每一个其它实体的直接引用计数。
        </p>
<p>
          Why is this important? Because it means that when a body no longer has
          a handle referring to it, all its references can be released immediately
          without fear of creating dangling references.<br>为什么这点很重要？因为它意味着当一个实体不再有某个句柄引向它的时候，它的所有引用物就可以立即释放，而不用害怕会导致悬空的引用。
        </p>
<p>
          References and dependencies cross-pollinate. Here's how it works:<br>引用和依赖是交叉pollinate的。以下是它的工作方式：
        </p>
<div class="orderedlist"><ol type="1">
<li>
            When one object acquires another as a reference, the second object acquires
            the first as a dependency.<br>当一个对象获得另一个对象作为引用时，第二个对象获得第一个对象作为依赖。
          </li>
<li>
            In addition, the first object acquires all of the second object's references,
            and the second object acquires all of the first object's dependencies.<br>此外，第一个对象获得第二个对象的所有引用，且第二个对象获得第一个对象的所有依赖。
          </li>
<li>
            When an object picks up a new reference, the reference is also added
            to all dependent objects.<br>当一个对象增加一个新的引用时，该引用也会被增加到所有依赖对象中。
          </li>
<li>
            When an object picks up a new dependency, the dependency is also added
            to all referenced objects.<br>当一个对象增加一个新的依赖时，该依赖也会被增加到所有引用对象中。
          </li>
<li>
            An object is never allowed to have itself as a dependency. Objects may
            have themselves as references, and often do.<br>对象不允许以自己为依赖。但对象可以把自己作为引用，而且经常如此。
          </li>
</ol></div>
<p>
          Consider the following code:<br>考虑以下代码：
        </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">expr</span><span class="special">;</span>
<span class="special">{</span>
    <span class="identifier">sregex</span> <span class="identifier">group</span>  <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span>                 <span class="comment">// (1)<br></span>    <span class="identifier">sregex</span> <span class="identifier">fact</span>   <span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span> <span class="special">|</span> <span class="identifier">group</span><span class="special">;</span>                                <span class="comment">// (2)<br></span>    <span class="identifier">sregex</span> <span class="identifier">term</span>   <span class="special">=</span> <span class="identifier">fact</span> <span class="special">&gt;&gt;</span> <span class="special">*((</span><span class="char">'*'</span> <span class="special">&gt;&gt;</span> <span class="identifier">fact</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="char">'/'</span> <span class="special">&gt;&gt;</span> <span class="identifier">fact</span><span class="special">));</span>   <span class="comment">// (3)<br></span>    <span class="identifier">expr</span>          <span class="special">=</span> <span class="identifier">term</span> <span class="special">&gt;&gt;</span> <span class="special">*((</span><span class="char">'+'</span> <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="char">'-'</span> <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">));</span>   <span class="comment">// (4)<br></span><span class="special">}</span>                                                               <span class="comment">// (5)<br></span></pre>
<p>
          Here is how the references and dependencies propagate, line by line:<br>以下逐行列出引用和依赖是如何传播的：
        </p>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  Expression
                </p>
                </th>
<th>
                <p>
                  Effects
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  1) <code class="computeroutput"><span class="identifier">sregex</span> <span class="identifier">group</span>
                  <span class="special">=</span> <span class="char">'('</span>
                  <span class="special">&gt;&gt;</span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span> <span class="special">&gt;&gt;</span>
                  <span class="char">')'</span><span class="special">;</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="literal">group: cnt<code class="literal">1 refs</code>{expr} deps={}<br>
                  expr: cnt<code class="literal">2 refs</code>{} deps={group}</code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  2) <code class="computeroutput"><span class="identifier">sregex</span> <span class="identifier">fact</span>
                  <span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span> <span class="special">|</span>
                  <span class="identifier">group</span><span class="special">;</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="literal">group: cnt<code class="literal">2 refs</code>{expr} deps={fact}<br>
                  expr: cnt<code class="literal">3 refs</code>{} deps={group,fact}<br> fact:
                  cnt<code class="literal">1 refs</code>{expr,group} deps={}</code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  3) <code class="computeroutput"><span class="identifier">sregex</span> <span class="identifier">term</span>
                  <span class="special">=</span> <span class="identifier">fact</span>
                  <span class="special">&gt;&gt;</span> <span class="special">*((</span><span class="char">'*'</span> <span class="special">&gt;&gt;</span>
                  <span class="identifier">fact</span><span class="special">)</span>
                  <span class="special">|</span> <span class="special">(</span><span class="char">'/'</span> <span class="special">&gt;&gt;</span>
                  <span class="identifier">fact</span><span class="special">));</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="literal">group: cnt<code class="literal">3 refs</code>{expr} deps={fact,term}<br>
                  expr: cnt<code class="literal">4 refs</code>{} deps={group,fact,term}<br>
                  fact: cnt<code class="literal">2 refs</code>{expr,group} deps={term}<br>
                  term: cnt<code class="literal">1 refs</code>{expr,group,fact} deps={}</code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  4) <code class="computeroutput"><span class="identifier">expr</span> <span class="special">=</span>
                  <span class="identifier">term</span> <span class="special">&gt;&gt;</span>
                  <span class="special">*((</span><span class="char">'+'</span>
                  <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="char">'-'</span> <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">));</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="literal">group: cnt<code class="literal">5 refs</code>{expr,group,fact,term}
                  deps={expr,fact,term}<br> expr: cnt<code class="literal">5 refs</code>{expr,group,fact,term}
                  deps={group,fact,term}<br> fact: cnt<code class="literal">5 refs</code>{expr,group,fact,term}
                  deps={expr,group,term}<br> term: cnt<code class="literal">5 refs</code>{expr,group,fact,term}
                  deps={expr,group,fact}</code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  5) <code class="computeroutput"><span class="special">}</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="literal">expr: cnt<code class="literal">2 refs</code>{expr,group,fact,term}
                  deps={group,fact,term}</code>
                </p>
                </td>
</tr>
</tbody>
</table></div>
<p>
          This shows how references and dependencies propagate when creating cycles
          of objects. After line (4), which closes the cycle, every object has a
          ref-count on every other object, even to itself. So how does this not leak?
          Read on.<br>这显示了在创建循环对象时，它们的引用和依赖是如何传播的。在第(4)行之后，当循环结束时，每个对象都有到每个其它对象的引用计数，甚至是到它们自身的引用。那么，怎样做才能不泄漏呢？继续看下去。
        </p>
<a name="boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.cycle_breaking"></a><h3>
<a name="id4191115"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.cycle_breaking">Cycle
          Breaking 打破循环</a>
        </h3>
<p>
          Now that the bodies have their sets of references and dependencies, the
          hard part is done. All that remains is to decide when and where to break
          the cycle. That is the job of <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>, which is part of the handle. The
          <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>
          holds 2 <code class="computeroutput"><span class="identifier">shared_ptr</span></code>s. The
          first, obviously, is the <code class="computeroutput"><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span></code> -- the reference to the body to which
          this handle refers. The other <code class="computeroutput"><span class="identifier">shared_ptr</span></code>
          is used to break the cycle. It ensures that when all the handles to a body
          go out of scope, the body's set of references is cleared.<br>现在实体中存有它们的引用集合和依赖集合，困难的部分已经完成。剩下的就是决定何时以及在何处打破这个循环。这是 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> 的任务，它是句柄的组成部分。<code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>
          持有2个 <code class="computeroutput"><span class="identifier">shared_ptr</span></code>。显然，第一个是 <code class="computeroutput"><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span></code> -- 到该句柄所引向的实体的引用。另一个 <code class="computeroutput"><span class="identifier">shared_ptr</span></code>
          则用于打破循环。它确保当指向某个实体的所有句柄离开作用域时，实体的引用集合被清除。
        </p>
<p>
          This suggests that more than one handle can refer to a body. In fact,
          <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>
          gives you copy-on-write semantics -- when you copy a handle, the body is
          shared. That makes copies very efficient. Eventually, all the handles to
          a particular body go out of scope. When that happens, the ref count to
          the body might still be greater than 0 because some other body (or this
          body itself!) might be holding a reference to it. However, we are certain
          that the cycle-breaker's ref-count goes to 0 because the cycle-breaker
          only lives in handles. No more handles, no more cycle-breakers.<br>可以有一个以上的句柄引向同一个实体。事实上，<code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code>
具有写时复制的语义 --
当你复制一个句柄时，其实体是共享的。这样令得复制操作非常高效。最后，指向某个特定实体的所有句柄离开作用域。当此事发生时，该实体的引用计数可能还会
大于0，因为某些其它的实体(或该实体本身)可能持有它的引用。不过，我们可以肯定循环破坏者的引用计数为0，因为循环破坏者只存在于句柄中。没有其它句
柄，也没有其它循环破坏者。 </p>
<p>
          What does the cycle-breaker do? Recall that the body has a set of references
          of type <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>. Let's call this type "references_type".
          The cycle-breaker is a <code class="computeroutput"><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">references_type</span><span class="special">&gt;</span></code>. It uses a custom deleter, which is
          defined as follows:<br>循环破坏者都做些什么呢？记得在实体中有一个引用集合，其类型为 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">body</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>。我们称之为"references_type"。循环破坏者是一个 <code class="computeroutput"><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">references_type</span><span class="special">&gt;</span></code>。它使用一个定制的删除器，定义如下：
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">DerivedT</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">reference_deleter</span>
<span class="special">{</span>
    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">DerivedT</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">*</span><span class="identifier">refs</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">refs</span><span class="special">-&gt;</span><span class="identifier">clear</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          The job of to the cycle breaker is to ensure that when the last handle
          to a body goes away, the body's set of references is cleared. That's it.<br>循环破坏者的任务是确保当一个实体的最后一个句柄离开时，实体的引用集合被清除。这就是了。
        </p>
<p>
          We can clearly see how this guarantees that all bodies are cleaned up eventually.
          Once every handle has gone out of scope, all the bodies' sets of references
          will be cleared, leaving none with a non-zero ref-count. No leaks, guaranteed.<br>我们可以清楚地看到，它是如何保证最后所有实体都被清除。一旦所有句柄离开作用域，所有实体的引用集合将被清除，不会留下非零引用计数的东西。保证没有泄漏。
        </p>
<p>
          It's a bit harder to see how this guarantees no dangling references. Imagine
          that there are 3 bodies: A, B and C. A refers to B which refers to C. Now
          all the handles to B go out of scope, so B's set of references is cleared.
          Doesn't this mean that C gets deleted, even though it is being used (indirectly)
          by A? It doesn't. This situation can never occur because we propagated
          the references and dependencies above such that A will be holding a reference
          directly to C in addition to B. When B's set of references is cleared,
          no bodies get deleted, because they are all still in use by A.<br>要
看出它如何保证不会有悬空引用有一点难度。想象有3个实体：A, B 和 C。A 引用 B，B 引用
C。现在B的所有句柄离开了作用域，所以B的引用集合被清除。这是否意味着即使 C 还被 A
(间接)使用着，它也会被删除？不会的。这种情况永远不会发生，因为我们传播了引用和依赖，这样A除了持有B的引用，也直接持有到C的引用。当B的引用集
合被清除时，没有实体被删除，因为它们全都还被 A 使用着。 </p>
<a name="boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.future_work"></a><h3>
<a name="id4191123"></a>
          <a class="link" href="appendices.html#boost_xpressive.appendices.appendix_5__implementation_notes.cycle_collection_with___tracking_ptr___.future_work">Future
          Work 未来的工作</a>
        </h3>
<p>
          All these <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code>s and <code class="computeroutput"><span class="identifier">shared_ptr</span></code>s
          and <code class="computeroutput"><span class="identifier">weak_ptr</span></code>s! Very inefficient.
          I used them because they were handy. I could probably do better.<br>这些所有的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code>s 和 <code class="computeroutput"><span class="identifier">shared_ptr</span></code>s 和 <code class="computeroutput"><span class="identifier">weak_ptr</span></code>s! 都非常低效。我完全是因为方便才使用它们的。我可能可以做得更好些。
        </p>
<p>
          Also, some objects stick around longer than they need to. Consider:<br>还有，有些对象存在的时间会比所需的时间长一些。例如：
        </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">b</span><span class="special">;</span>
<span class="special">{</span>
    <span class="identifier">sregex</span> <span class="identifier">a</span> <span class="special">=</span> <span class="identifier">_</span><span class="special">;</span>
    <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">a</span><span class="special">);</span>
    <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">_</span><span class="special">;</span>
<span class="special">}</span>
<span class="comment">// a is still alive here!  a在这里还活着！<br></span></pre>
<p>
          Due to the way references and dependencies are propagated, the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code> of references can only grow. It never
          shrinks, even when some references are no longer needed. For xpressive
          this isn't an issue. The graphs of referential objects generally stay small
          and isolated. If someone were to try to use <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> as a general ref-count-cycle-collection
          mechanism, this problem would have to be addressed.<br>由于引用和依赖的传播方式，保存引用的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code> 只增不减。即使有些引用已不再需要，它也不会缩减。对于xpressive来说这不是一个问题。对象的引用图通常都很小且相互独立。如果有人试图把 <code class="computeroutput"><span class="identifier">tracking_ptr</span><span class="special">&lt;&gt;</span></code> 用作通用的引用计数循环收集机制，这个问题就必须要解决。
        </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2007 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../boost_xpressive/acknowledgments.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../tools.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
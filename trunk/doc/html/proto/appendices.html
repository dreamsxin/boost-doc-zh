<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Appendices</title>

<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../proto.html" title="Chapter&nbsp;14.&nbsp;Boost.Proto">
<link rel="prev" href="../PolymorphicFunctionObject.html" title="Concept PolymorphicFunctionObject">
<link rel="next" href="../ref.html" title="Chapter&nbsp;15.&nbsp;Boost.Ref"></head>
<body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="../PolymorphicFunctionObject.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../proto.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../ref.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="proto.appendices"></a><a class="link" href="appendices.html" title="Appendices">Appendices
附录</a>
</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.history">
Appendix A: History 附录A：历史</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.rationale">
Appendix B: Rationale 附录B：基本原理</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.implementation">
Appendix C: Implementation Notes 附录C：实现说明</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.acknowledgements">
Appendix D: Acknowledgements 附录D：鸣谢</a></span></dt>
</dl>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_proto.appendices.history"></a><a class="link" href="appendices.html#boost_proto.appendices.history" title="Appendix A: History"> Appendix A: History 附录A：历史</a>
</h3>
</div>
</div>
</div>
<div class="variablelist">
<p class="title"></p>
<dl>
<dt><span class="term">August 11, 2008</span></dt>
<dd>
<p> Proto v4 is merged to Boost trunk with more powerful
transform protocol. <br>Proto v4 合并至 Boost 主干，具有更强大的变换协议。 </p>
</dd>
<dt><span class="term">April 7, 2008</span></dt>
<dd>
<p> Proto is accepted into Boost.<br>Proto 被接受进入 Boost。 </p>
</dd>
<dt><span class="term">March 1, 2008</span></dt>
<dd>
<p> Proto's Boost review begins.<br>Proto 的 Boost 评审开始。 </p>
</dd>
<dt><span class="term">January 11, 2008</span></dt>
<dd>
<p> Boost.Proto v3 brings separation of grammars and
transforms and a "round" lambda syntax for defining transforms
in-place.<br>Boost.Proto v3 将语法和变换分离，并带有一个就地定义变换的"round" lambda 语法。 </p>
</dd>
<dt><span class="term">April 15, 2007</span></dt>
<dd>
<p> Boost.Xpressive is ported from Proto compilers to Proto
transforms. Support for old Proto compilers is dropped.<br>Boost.Xpressive 从 Proto 编译器修改为 Proto 变换。不再支持旧的 Proto 编译器。 </p>
</dd>
<dt><span class="term">April 4, 2007</span></dt>
<dd>
<p> Preliminary submission of Proto to Boost.<br>给 Boost 的 Proto 初步提交物。 </p>
</dd>
<dt><span class="term">December 11, 2006</span></dt>
<dd>
<p> The idea for transforms that decorate grammar rules is
born in a private email discussion with Joel de Guzman and Hartmut
Kaiser. The first transforms are committed to CVS 5 days later on
December 16.<br>在 Joel de Guzman 和 Hartmut Kaiser 的一封私人邮件讨论中，诞生了用变换来装饰语法规则的想法。5天后，12月16日，第一个变换被提交到CVS上。 </p>
</dd>
<dt><span class="term">November 1, 2006</span></dt>
<dd>
<p> The idea for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
and the whole grammar facility is hatched during a discussion with
Hartmut Kaiser on the spirit-devel list. The first version of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
is checked into CVS 3 days later. Message is <a href="http://osdir.com/ml/parsers.spirit.devel/2006-11/msg00003.html" target="_top">here</a>.<br>Hartmut Kaiser 在 spirit-devel 列表上的讨论中，提出了 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
和整个语法工具的想法。3天后，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
的第一个版本签入至CVS。相关信息在 <a href="http://osdir.com/ml/parsers.spirit.devel/2006-11/msg00003.html" target="_top">此处</a>。 </p>
</dd>
<dt><span class="term">October 28, 2006</span></dt>
<dd>
<p> Proto is reborn, this time with a uniform expression
types that are POD. Announcement is <a href="http://lists.boost.org/Archives/boost/2006/10/112453.php" target="_top">here</a>.<br> Proto 重生，这次将表达式类型为统一为POD。相关声明在 <a href="http://lists.boost.org/Archives/boost/2006/10/112453.php" target="_top">此处</a>。 </p>
</dd>
<dt><span class="term">April 20, 2005</span></dt>
<dd>
<p> Proto is born as a major refactorization of
Boost.Xpressive's meta-programming. Proto offers expression types,
operator overloads and "compilers", an early formulation of what later
became transforms. Announcement is <a href="http://lists.boost.org/Archives/boost/2005/04/85256.php" target="_top">here</a>.<br> Proto 作为
Boost.Xpressive 元编程的主要重构物诞生了。Proto 提供了表达式类型、操作符重载和"编译器"--变换的早期形式。相关声明在 <a href="http://lists.boost.org/Archives/boost/2005/04/85256.php" target="_top">此处</a>。 </p>
</dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_proto.appendices.rationale"></a><a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix B: Rationale"> Appendix B: Rationale 附录B：基本原理</a>
</h3>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.rationale.static_initialization">
Static Initialization 静态初始化</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.rationale.preprocessor">
Why Not Reuse MPL, Fusion, et cetera? 为何不重用 MPL, Fusion 等？</a></span></dt>
</dl>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_proto.appendices.rationale.static_initialization"></a><a class="link" href="appendices.html#boost_proto.appendices.rationale.static_initialization" title="Static Initialization"> Static Initialization 静态初始化</a>
</h4>
</div>
</div>
</div>
<p> Proto expression types are PODs (Plain Old Data), and do not
have constructors. They are brace-initialized, as follows:<br>Proto 表达式类型是POD(旧的平面数据)，不带构造函数。它们可以用花括号来初始化，如下： </p>
<pre class="programlisting"><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_i</span> <span class="special">=</span> <span class="special">{</span><span class="number">1</span><span class="special">};</span>
</pre>
<p> The reason is so that expression objects like <code class="computeroutput"><span class="identifier">_i</span></code>
above can be <span class="emphasis"><em>statically
initialized</em></span>. Why is static initialization
important? The terminals of many domain- specific embedded languages
are likely to be global const objects, like <code class="computeroutput"><span class="identifier">_1</span></code>
and <code class="computeroutput"><span class="identifier">_2</span></code> from the
Boost Lambda Library. Were these object to require run-time
initialization, it might be possible to use these objects before they
are initialized. That would be bad. Statically initialized objects
cannot be misused that way.<br>其原因是，这样象上面的 <code class="computeroutput"><span class="identifier">_i</span></code>
这样的表达式对象就可以<span class="emphasis"><em>被静态初始化</em></span>。为什么静态初始化这么重要？许多领域专用嵌入式语言的终结符很可能是全局的常量对象，如 Bosot Lambda 库中的 <code class="computeroutput"><span class="identifier">_1</span></code> 和 <code class="computeroutput"><span class="identifier">_2</span></code>。如果这些对象要在运行期初始化的话，对象就可能会在初始化之前被使用。这是有问题的。静态初始化的对象不会发生这种问题。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_proto.appendices.rationale.preprocessor"></a><a class="link" href="appendices.html#boost_proto.appendices.rationale.preprocessor" title="Why Not Reuse MPL, Fusion, et cetera?"> Why Not Reuse
MPL, Fusion, et cetera? 为何不重用 MPL, Fusion 等？</a>
</h4>
</div>
</div>
</div>
<p> Anyone who has peeked at Proto's source code has probably
wondered, "Why all the dirty preprocessor gunk? Couldn't this have been
all implemented cleanly on top of libraries like MPL and Fusion?" The
answer is that Proto could have been implemented this way, and in fact
was at one point. The problem is that template metaprogramming (TMP)
makes for longer compile times. As a foundation upon which other
TMP-heavy libraries will be built, Proto itself should be as
lightweight as possible. That is achieved by prefering preprocessor
metaprogramming to template metaprogramming. Expanding a macro is far
more efficient than instantiating a template. In some cases, the
"clean" version takes 10x longer to compile than the "dirty" version.<br>任
何一个看过Proto源代码的人都可能会觉得奇怪，"为什么到处是难看的预处理器语句？不能使用象MPL和Fusion这样的库来实现得更漂亮吗？"答案
是，Proto可以用这些方法来实现，事实上也曾经如此。问题是模板元编程(TMP)需要较长的编译时间。作为其它重度使用TMP的库的构建基础，
Proto本身应该尽可能轻量。这需要通过预处理器元编程而不是模板元编程来实现。展开一个宏要比实例化一个模板高效得多。在某些情形下，"漂亮"版要比
"难看"版多花10倍以上的编译时间。 </p>
<p> The "clean and slow" version of Proto can still be found at
http://svn.boost.org/svn/boost/branches/proto/v3. Anyone who is
interested can download it and verify that it is, in fact, unusably
slow to compile. Note that this branch's development was abandoned, and
it does not conform exactly with Proto's current interface.<br>"
漂亮且慢"的Proto版本仍然可以在&nbsp;http://svn.boost.org/svn/boost/branches/proto/v3
中找到。有兴趣的读者可以下载它，并且看看它在编译时是否不一般地慢。注意，这一分支的开发已经不再继续，它并不完全符合当前的Proto接口。 </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_proto.appendices.implementation"></a><a class="link" href="appendices.html#boost_proto.appendices.implementation" title="Appendix C: Implementation Notes"> Appendix C:
Implementation Notes 附录C：实现说明</a>
</h3>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.implementation.sfinae">
Quick-n-Dirty Type Categorization 快速而难看的类型分类</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_proto.appendices.implementation.function_arity">
Detecting the Arity of Function Objects 检测函数对象的arity</a></span></dt>
</dl>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_proto.appendices.implementation.sfinae"></a><a class="link" href="appendices.html#boost_proto.appendices.implementation.sfinae" title="Quick-n-Dirty Type Categorization"> Quick-n-Dirty
Type Categorization 快速而难看的类型分类</a>
</h4>
</div>
</div>
</div>
<p> Much has already been written about dispatching on type
traits using SFINAE (Substitution Failure Is Not An Error) techniques
in C++. There is a Boost library, Boost.Enable_if, to make the
technique idiomatic. Proto dispatches on type traits extensively, but
it doesn't use <code class="computeroutput"><span class="identifier">enable_if</span><span class="special">&lt;&gt;</span></code>
very often. Rather, it dispatches based on the presence or absence of
nested types, often typedefs for void.<br>很多人都写过使用C++中的SFINAE(替换失败并非错误)技术按类型traits进行分派的代码。有一个Boost库，Boost.Enable_if，使这一技术成为惯用法。Proto大量地使用了按类型traits进行分派，但是它并不经常使用 <code class="computeroutput"><span class="identifier">enable_if</span><span class="special">&lt;&gt;</span></code>。相以，它基于嵌套类型的存在与否来进行分派，这个嵌套类型通常被 typedef 为 void。 </p>
<p> Consider the implementation of <code class="computeroutput"><span class="identifier">is_expr</span><span class="special">&lt;&gt;</span></code>.
It could have been written as something like this:<br>想一下 <code class="computeroutput"><span class="identifier">is_expr</span><span class="special">&lt;&gt;</span></code> 的实现。它可以写成象以下这样： </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">is_expr</span><br><span class="special">:</span> <span class="identifier">is_base_and_derived</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">some_expr_base</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="special">{};</span>
</pre>
<p> Rather, it is implemented as this:<br>更好的方法是实现为这样： </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Void</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">is_expr</span><br><span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span><br><span class="special">{};</span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">is_expr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">::</span><span class="identifier">proto_is_expr_</span><span class="special">&gt;</span><br><span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><br><span class="special">{};</span>
</pre>
<p> This relies on the fact that the specialization will be
preferred if <code class="computeroutput"><span class="identifier">T</span></code> has a nested <code class="computeroutput"><span class="identifier">proto_is_expr_</span></code>
that is a typedef for <code class="computeroutput"><span class="keyword">void</span></code>. All Proto
expression types have such a nested typedef.<br>这依赖于一个事实，即如果 <code class="computeroutput"><span class="identifier">T</span></code> 带有一个嵌套的 <code class="computeroutput"><span class="identifier">proto_is_expr_</span></code>，它可以 typedef 为 <code class="computeroutput"><span class="keyword">void</span></code>，则会优选模板的特化版。所有Proto表达式类型都带有这样的一个嵌套typedef。 </p>
<p> Why does Proto do it this way? The reason is because, after
running extensive benchmarks while trying to improve compile times, I
have found that this approach compiles faster. It requires exactly one
template instantiation. The other approach requires at least 2: <code class="computeroutput"><span class="identifier">is_expr</span><span class="special">&lt;&gt;</span></code>
and <code class="computeroutput"><span class="identifier">is_base_and_derived</span><span class="special">&lt;&gt;</span></code>,
plus whatever templates <code class="computeroutput"><span class="identifier">is_base_and_derived</span><span class="special">&lt;&gt;</span></code>
may instantiate.<br>为什么Proto要以这种方法来实现呢？原因是，在进行了旨在改进编译时间的性能测试后，我发现这种方式的编译更快。它只需要一个模板实例化。另外一种方法则至少需要2个：<code class="computeroutput"><span class="identifier">is_expr</span><span class="special">&lt;&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">is_base_and_derived</span><span class="special">&lt;&gt;</span></code>，而且模板 <code class="computeroutput"><span class="identifier">is_base_and_derived</span><span class="special">&lt;&gt;</span></code>
还可能进行其它的实例化。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="boost_proto.appendices.implementation.function_arity"></a><a class="link" href="appendices.html#boost_proto.appendices.implementation.function_arity" title="Detecting the Arity of Function Objects"> Detecting
the Arity of Function Objects 检测函数对象的arity</a>
</h4>
</div>
</div>
</div>
<p> In several places, Proto needs to know whether or not a
function object <code class="computeroutput"><span class="identifier">Fun</span></code> can be
called with certain parameters and take a fallback action if not. This
happens in <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
and in the <code class="computeroutput"><a class="link" href="../boost/proto/call.html" title="Struct template call">proto::call&lt;&gt;</a></code>
transform. How does Proto know? It involves some tricky
metaprogramming. Here's how.<br>Proto的多处地方需要知道一个函数对象 <code class="computeroutput"><span class="identifier">Fun</span></code> 是否可以用指定的参数来调用，如果不行的话则需要进行回退。这在 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
和 <code class="computeroutput"><a class="link" href="../boost/proto/call.html" title="Struct template call">proto::call&lt;&gt;</a></code>
变换中都有发生。Proto是如何知道的呢？这里有一些巧妙的元编程。下面来说一下。 </p>
<p> Another way of framing the question is by trying to implement
the following <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code>
Boolean metafunction, which checks to see if a function object <code class="computeroutput"><span class="identifier">Fun</span></code>
can be called with parameters of type <code class="computeroutput"><span class="identifier">A</span></code> and <code class="computeroutput"><span class="identifier">B</span></code>:<br>构思这一问题的另一个方法是，尝试实现以下 <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code>
布尔元函数，它检查某个函数对象 <code class="computeroutput"><span class="identifier">Fun</span></code>
是否可以用类型为 <code class="computeroutput"><span class="identifier">A</span></code> 和 <code class="computeroutput"><span class="identifier">B</span></code> 的参数来调用：
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Fun</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">B</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">can_be_called</span><span class="special">;</span>
</pre>
<p> First, we define the following <code class="computeroutput"><span class="identifier">dont_care</span></code>
struct, which has an implicit conversion from anything. And not just
any implicit conversion; it has a ellipsis conversion, which is the
worst possible conversion for the purposes of overload resolution:<br>首先，我们定义以下 <code class="computeroutput"><span class="identifier">dont_care</span></code>
结构，它带有一个自任何类型的隐式转换。而且不仅是任意的隐式转换；它还有一个带省略号的转换，这是在重载解析中最坏情况下的可选转换：</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">dont_care</span><br><span class="special">{</span><br><span class="identifier">dont_care</span><span class="special">(...);</span><br><span class="special">};</span>
</pre>
<p> We also need some private type known only to us with an
overloaded comma operator (!), and some functions that detect the
presence of this type and return types with different sizes, as
follows:<br>我们还需要一些东西，只有我们自己知道的带有一个逗号操作符重载(!)的私有类型，一些函数用于检测该类型是否出现并返回不同大小的类型，如下： </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">private_type</span><br><span class="special">{</span><br><span class="identifier">private_type</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="keyword">operator</span><span class="special">,(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span><br><span class="special">};</span><br><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="identifier">yes_type</span><span class="special">;</span> <span class="comment">// sizeof(yes_type) == 1<br></span><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="special">(&amp;</span><span class="identifier">no_type</span><span class="special">)[</span><span class="number">2</span><span class="special">];</span> <span class="comment">// sizeof(no_type) == 2<br></span><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span><br><span class="identifier">no_type</span> <span class="identifier">is_private_type</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;);</span><br><span class="identifier">yes_type</span> <span class="identifier">is_private_type</span><span class="special">(</span><span class="identifier">private_type</span> <span class="keyword">const</span> <span class="special">&amp;);</span>
</pre>
<p> Next, we implement a binary function object wrapper with a
very strange conversion operator, whose meaning will become clear
later.<br>接着，我们实现一个二元函数包装器，它带有一个非常奇特的转换操作符，其意义稍后就会弄清楚。 </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Fun</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">funwrap2</span> <span class="special">:</span> <span class="identifier">Fun</span><br><span class="special">{</span><br><span class="identifier">funwrap2</span><span class="special">();</span><br><span class="keyword">typedef</span> <span class="identifier">private_type</span> <span class="keyword">const</span> <span class="special">&amp;(*</span><span class="identifier">pointer_to_function</span><span class="special">)(</span><span class="identifier">dont_care</span><span class="special">,</span> <span class="identifier">dont_care</span><span class="special">);</span><br><span class="keyword">operator</span> <span class="identifier">pointer_to_function</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span><br><span class="special">};</span>
</pre>
<p> With all of these bits and pieces, we can implement <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code>
as follows:<br>有了所有这些东西，我们就可以如下实现 <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code> 了： </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Fun</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">B</span><span class="special">&gt;</span><br><span class="keyword">struct</span> <span class="identifier">can_be_called</span><br><span class="special">{</span><br><span class="keyword">static</span> <span class="identifier">funwrap2</span><span class="special">&lt;</span><span class="identifier">Fun</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">fun</span><span class="special">;</span><br><span class="keyword">static</span> <span class="identifier">A</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">;</span><br><span class="keyword">static</span> <span class="identifier">B</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">;</span><br><span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">const</span> <span class="identifier">value</span> <span class="special">=</span> <span class="special">(</span><br><span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">no_type</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">is_private_type</span><span class="special">(</span> <span class="special">(</span><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span><span class="identifier">b</span><span class="special">),</span> <span class="number">0</span><span class="special">)</span> <span class="special">))</span><br><span class="special">);</span><br><span class="keyword">typedef</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">bool_</span><span class="special">&lt;</span><span class="identifier">value</span><span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span><br><span class="special">};</span>
</pre>
<p> The idea is to make it so that <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span><span class="identifier">b</span><span class="special">)</span></code> will always
compile by adding our own binary function overload, but doing it in
such a way that we can detect whether our overload was selected or not.
And we rig it so that our overload is selected if there is really no
better option. What follows is a description of how <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code>
works.<br>其中的思想是，通过增加我们自己的二元函数重载，使得 <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span><span class="identifier">b</span><span class="special">)</span></code> 总是可以被编译，不过，这样一来我们就可以检测到我们的重载是否被选中。而我们把它装配成只有在没有更好的选择时，才选中我们的重载。以下说明 <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code> 如何工作。 </p>
<p> We wrap <code class="computeroutput"><span class="identifier">Fun</span></code> in a type
that has an implicit conversion to a pointer to a binary function. An
object <code class="computeroutput"><span class="identifier">fun</span></code> of class
type can be invoked as <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">)</span></code> if it has such a
conversion operator, but since it involves a user-defined conversion
operator, it is less preferred than an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>, which requires
no such conversion.<br>我们将 <code class="computeroutput"><span class="identifier">Fun</span></code> 包入一个类型，该类型带有一个到二元函数指针的隐式转换。如果一个类类型带有这样的一个转换操作符，则这个类类型的对象 <code class="computeroutput"><span class="identifier">fun</span></code> 就可以用 <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">)</span></code> 来调用，不过，由于其中包含了一次用户自定义的转换操作符，所以它不如一个重载的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 优先，因为后者不需要转换。 </p>
<p> The function pointer can accept any two arguments by virtue
of the <code class="computeroutput"><span class="identifier">dont_care</span></code> type.
The conversion sequence for each argument is guaranteed to be the worst
possible conversion sequence: an implicit conversion through an
ellipsis, and a user-defined conversion to <code class="computeroutput"><span class="identifier">dont_care</span></code>.
In total, it means that <code class="computeroutput"><span class="identifier">funwrap2</span><span class="special">&lt;</span><span class="identifier">Fun</span><span class="special">&gt;()(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">)</span></code> will always
compile, but it will select our overload only if there really is no
better option.<br>由于 <code class="computeroutput"><span class="identifier">dont_care</span></code> 类型，这个函数指针可以接受任意类型的两个参数。每个参数的转换序列都可以保证是最坏情况下的可选转换序列：一个通过省略号进行的隐式转换，和一个到 <code class="computeroutput"><span class="identifier">dont_care</span></code> 的用户自定义转换。总的来说，这意味着 <code class="computeroutput"><span class="identifier">funwrap2</span><span class="special">&lt;</span><span class="identifier">Fun</span><span class="special">&gt;()(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">)</span></code> 总是可以被编译，不过仅当没有更好的选择时，它才会选择我们的重载。 </p>
<p> If there is a better option --- for example if <code class="computeroutput"><span class="identifier">Fun</span></code>
has an overloaded function call operator such as <code class="computeroutput"><span class="keyword">void</span>
<span class="keyword">operator</span><span class="special">()(</span><span class="identifier">A</span>
<span class="identifier">a</span><span class="special">,</span> <span class="identifier">B</span>
<span class="identifier">b</span><span class="special">)</span></code> --- then <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></code> will resolve to
that one instead. The question now is how to detect which function got
picked by overload resolution.<br>如果有一个更好的选择 --- 例如，如果 <code class="computeroutput"><span class="identifier">Fun</span></code>
带有一个重载的函数调用操作符，如 <code class="computeroutput"><span class="keyword">void</span>
<span class="keyword">operator</span><span class="special">()(</span><span class="identifier">A</span>
<span class="identifier">a</span><span class="special">,</span> <span class="identifier">B</span>
<span class="identifier">b</span><span class="special">)</span></code> --- 则 <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></code> 将被决议为那个选择。现在的问题是，如何通过重载决议来检测哪一个函数被选中。 </p>
<p> Notice how <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">)</span></code> appears in <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code>: <code class="computeroutput"><span class="special">(</span><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">),</span> <span class="number">0</span><span class="special">)</span></code>. Why do we use
the comma operator there? The reason is because we are using this
expression as the argument to a function. If the return type of <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></code> is <code class="computeroutput"><span class="keyword">void</span></code>,
it cannot legally be used as an argument to a function. The comma
operator sidesteps the issue.<br>留意在 <code class="computeroutput"><span class="identifier">can_be_called</span><span class="special">&lt;&gt;</span></code> 中的 <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">)</span></code> 是如何出现的：<code class="computeroutput"><span class="special">(</span><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">),</span> <span class="number">0</span><span class="special">)</span></code>。为什么我们要用逗号操作符？原因是，我们要把这个表达式作为一个函数的参数来使用。 如果 <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></code> 的返回类型为 <code class="computeroutput"><span class="keyword">void</span></code>，它就不能合法地作为一个函数的参数来使用。逗号操作符回避了这个问题。 </p>
<p> This should also make plain the purpose of the overloaded
comma operator in <code class="computeroutput"><span class="identifier">private_type</span></code>.
The return type of the pointer to function is <code class="computeroutput"><span class="identifier">private_type</span></code>.
If overload resolution selects our overload, then the type of <code class="computeroutput"><span class="special">(</span><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">),</span> <span class="number">0</span><span class="special">)</span></code> is <code class="computeroutput"><span class="identifier">private_type</span></code>.
Otherwise, it is <code class="computeroutput"><span class="keyword">int</span></code>. That fact is
used to dispatch to either overload of <code class="computeroutput"><span class="identifier">is_private_type</span><span class="special">()</span></code>, which encodes
its answer in the size of its return type.<br>在 <code class="computeroutput"><span class="identifier">private_type</span></code> 中重载逗号操作符的目的就很显而易见了。这个函数指针的返回类型是 <code class="computeroutput"><span class="identifier">private_type</span></code>。如果重载决议选中了我们的重载，则 <code class="computeroutput"><span class="special">(</span><span class="identifier">fun</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span>
<span class="identifier">b</span><span class="special">),</span> <span class="number">0</span><span class="special">)</span></code> 的类型为 <code class="computeroutput"><span class="identifier">private_type</span></code>。否则，其类型为 <code class="computeroutput"><span class="keyword">int</span></code>。这一事实用于分派 <code class="computeroutput"><span class="identifier">is_private_type</span><span class="special">()</span></code> 的重载，后者将答案写在返回类型的大小中。 </p>
<p> That's how it works with binary functions. Now repeat the
above process for functions up to some predefined function arity, and
you're done.<br>以上就是如何使用这一方法对二元函数进行判断。现在，可以重复以上过程直至某个预定义的函数airty为止。 </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="boost_proto.appendices.acknowledgements"></a><a class="link" href="appendices.html#boost_proto.appendices.acknowledgements" title="Appendix D: Acknowledgements"> Appendix D:
Acknowledgements 附录D：鸣谢</a>
</h3>
</div>
</div>
</div>
<p> I'd like to thank Joel de Guzman and Hartmut Kaiser for being
willing to take a chance on using Proto for their work on Spirit-2 and
Karma when Proto was little more than a vision. Their requirements and
feedback have been indespensable. </p>
<p> Thanks also to the developers of <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a>. I found many good ideas there.
</p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%">
<tbody>
<tr>
<td align="left"></td>
<td align="right">
<div class="copyright-footer">Copyright © 2008 Eric
Niebler
<p> Distributed under the Boost Software License, Version
1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
</p>
</div>
</td>
</tr>
</tbody>
</table>
<hr>
<div class="spirit-nav"><a accesskey="p" href="../PolymorphicFunctionObject.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../proto.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../ref.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
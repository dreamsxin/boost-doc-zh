<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Users' Guide</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../proto.html" title="Chapter&nbsp;14.&nbsp;Boost.Proto">
<link rel="prev" href="../proto.html" title="Chapter&nbsp;14.&nbsp;Boost.Proto">
<link rel="next" href="reference.html" title="Reference"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../proto.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../proto.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="proto.users_guide"></a><a class="link" href="users_guide.html" title="Users' Guide"> Users' Guide 用户指南</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started"> Getting Started 入门</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end"> Fronts Ends: Defining
      Terminals and Non-Terminals of Your DSEL 前端：为你的DSEL定义终结符和非终结符</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form"> Intermediate
      Form: Understanding and Introspecting Expressions 中间格式：理解和窥探表达式</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end"> Back Ends: Making
      Expression Templates Do Useful Work 后端：让表达式模板做有用的事</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples">Examples 示例</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.resources"> Background and Resources 背景与资源</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.glossary">Glossary 术语</a></span></dt>
</dl></div>
<a name="proto.users_guide.compilers__compiler_construction_toolkits__and_proto"></a><h4>
<a name="id3473549"></a>
      <a class="link" href="users_guide.html#proto.users_guide.compilers__compiler_construction_toolkits__and_proto">Compilers,
      Compiler Construction Toolkits, and Proto 编译器，编译器构造工具，和 Proto</a>
    </h4>
<p>
      Most compilers have front ends and back ends. The front end parses the text
      of an input program into some intermediate form like an abstract syntax tree,
      and the back end takes the intermediate form and generates an executable from
      it.<br>多数编译器都具有前端和后端。前端负责将输入的程序进行解析为一些中间格式，如抽象语法树，而后端则接受这些中间格式并由它生成一个可执行文件。
    </p>
<p>
      A library built with Proto is essentially a compiler for a domain-specific
      embedded language (DSEL). It also has a front end, an intermediate form, and
      a back end. The front end is comprised of the symbols (a.k.a., terminals),
      members, operators and functions that make up the user-visible aspects of the
      DSEL. The back end is made of evaluation contexts and transforms that give
      meaning and behavior to the expression templates generated by the front end.
      In between is the intermediate form: the expression template itself, which
      is an abstract syntax tree in a very real sense.<br>一
个以 Proto
构建的库实质上是某种领域专用嵌入式语言(DSEL)的编译器。它也有前端、中间格式和后端。前端由符号(又称终结符)、成员、操作符以及弥补DSEL的
用户可见性方面的函数组成。后端则由求值上下文和变换构成，为前端所生成的表达式模板赋予意义和行为。在两者中间则是中间格式：表达式模板本身，它是非常
现实的意义下的抽象语法树。 </p>
<p>
      To build a library with Proto, you will first decide what your interface will
      be; that is, you'll design a programming language for your domain and build
      the front end with tools provided by Proto. Then you'll design the back end
      by writing evaluation contexts and/or transforms that accept expression templates
      and do interesting things with them.<br>要用 Proto 来构建一个库，你首先要决定你的接口是什么样的；即你要为你的问题域设计一个编程语言，并使用 Proto 所提供的工具构建前端。然后，你要通过编写求值上下文和/或接受表达式模板并对它们做一些有意义的事情的变换操作来设计后端。
    </p>
<p class="title">
      This users' guide is organized as follows. After a <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started" title="Getting Started">Getting
      Started guide</a>, we'll cover the tools Proto provides for defining and
      manipulating the three major parts of a compiler:<br>这个用户指南组织如下。在一个 <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started" title="Getting Started">入门指南</a> 之后，我们将介绍 Proto 所提供的工具，它们用于定义和操纵一个编译器的三个主要部分：</p>
<div class="variablelist">

<dl>
<dt><span class="term"><a class="link" href="users_guide.html#boost_proto.users_guide.front_end" title="Fronts Ends: Defining Terminals and Non-Terminals of Your DSEL">Front
      Ends 前端</a></span></dt>
<dd><p>
          How to define the aspects of your DSEL with which your users will interact
          directly.<br>如何定义你的DSEL与用户直接交互的外貌。
        </p></dd>
<dt><span class="term"><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form" title="Intermediate Form: Understanding and Introspecting Expressions">Intermediate
      Form 中间格式</a></span></dt>
<dd><p>
          What Proto expression templates look like, how to discover their structure
          and access their constituents.<br>Proto 表达式模板看起来是什么样的，如何发现其结构及访问其中的要素。
        </p></dd>
<dt><span class="term"><a class="link" href="users_guide.html#boost_proto.users_guide.back_end" title="Back Ends: Making Expression Templates Do Useful Work">Back
      Ends 后端</a></span></dt>
<dd><p>
          How to define evaluation contexts and transforms that make expression templates
          do interesting things.<br>如何定义求值上下文和变换，让表达式模板做有意义的事。
        </p></dd>
</dl>
</div>
<p>
      After that, you may be interested in seeing some <a class="link" href="users_guide.html#boost_proto.users_guide.examples" title="Examples">Examples</a>
      to get a better idea of how the pieces all fit together.<br>在此之后，你将看到一些 <a class="link" href="users_guide.html#boost_proto.users_guide.examples" title="Examples">例子</a>，可以对这部组成部分如何很好地合起来有更好的认识。
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.getting_started"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started" title="Getting Started"> Getting Started 入门</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto">Installing
        Proto 安装 Proto</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.naming"> Naming
        Conventions 命名约定</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.hello_world">Hello
        World</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator">Hello
        Calculator</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.installing_proto"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto" title="Installing Proto">Installing
        Proto 安装 Proto</a>
</h4></div></div></div>
<a name="boost_proto.users_guide.getting_started.installing_proto.getting_proto"></a><h6>
<a name="id3473737"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.getting_proto">Getting
          Proto 获取 Proto</a>
        </h6>
<p>
          You can get Proto by downloading <code class="literal">proto.zip</code> from <a href="http://www.boost-consulting.com/vault/index.php?directory=Template%20Metaprogramming" target="_top">http://www.boost-consulting.com/vault/index.php?directory=Template%20Metaprogramming</a>,
          by downloading Boost (Proto is in version 1.37 and later), or by accessing
          Boost's SVN repository on SourceForge.net. Just go to <a href="http://svn.boost.org/trac/boost/wiki/BoostSubversion" target="_top">http://svn.boost.org/trac/boost/wiki/BoostSubversion</a>
          and follow the instructions there for anonymous SVN access.<br>你可以通过从 <a href="http://www.boost-consulting.com/vault/index.php?directory=Template%20Metaprogramming" target="_top">http://www.boost-consulting.com/vault/index.php?directory=Template%20Metaprogramming</a> 下载 <code class="literal">proto.zip</code> 获得 Proto，也可以通过下载 Boost (Proto 在版本 1.37 及后续版本中)，或访问位于 SourceForge.net 的
          Boost's SVN 版本库来获取。请到 <a href="http://svn.boost.org/trac/boost/wiki/BoostSubversion" target="_top">http://svn.boost.org/trac/boost/wiki/BoostSubversion</a>
          查阅进行匿名 SVN 访问的指令。
        </p>
<a name="boost_proto.users_guide.getting_started.installing_proto.building_with_proto"></a><h6>
<a name="id3473790"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.building_with_proto">Building
          with Proto 用 Proto 来构建</a>
        </h6>
<p>
          Proto is a header-only template library, which means you don't need to
          alter your build scripts or link to any separate lib file to use it. All
          you need to do is <code class="computeroutput"><span class="preprocessor">#include</span>
          <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>. Or, you might decide to just include
          the core of Proto (<code class="computeroutput"><span class="preprocessor">#include</span>
          <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>) and whichever contexts and transforms
          you happen to use.<br>Proto 是一个只有头文件的模板库，这意味着你在使用它的时候不需要修改你的构建脚本或链接任何独立的库文件来。你需要做的只是 <code class="computeroutput"><span class="preprocessor">#include</span>
          <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>。或者，你也可以决定只包含 Proto 的核心(<code class="computeroutput"><span class="preprocessor">#include</span>
          <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>)以及你想要使用的上下文和变换。
        </p>
<a name="boost_proto.users_guide.getting_started.installing_proto.requirements"></a><h6>
<a name="id3473926"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.requirements">Requirements 要求</a>
        </h6>
<p>
          Proto depends on Boost. You must use either Boost version 1.34.1 or higher,
          or the version in SVN trunk.<br>Proto 依赖于 Boost。你必须使用 Boost 版本 1.34.1 或更高版本，或是 SVN trunk 中的版本。
        </p>
<a name="boost_proto.users_guide.getting_started.installing_proto.supported_compilers"></a><h6>
<a name="id3473955"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.supported_compilers">Supported
          Compilers 支持的编译器</a>
        </h6>
<p>
          Currently, Boost.Proto is known to work on the following compilers:<br>目前已知 Boost.Proto 可以使用以下编译器：
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            Visual C++ 7.1 and higher
          </li>
<li>
            GNU C++ 3.4 and higher
          </li>
<li>
            Intel on Linux 8.1 and higher
          </li>
<li>
            Intel on Windows 9.1 and higher
          </li>
</ul></div>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
            Please send any questions, comments and bug reports to eric &lt;at&gt;
            boostpro &lt;dot&gt; com.</p><p>有任何问题、建议和缺陷，请报告至 eric@boostpro.com。
          </p></td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.naming"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming" title="Naming Conventions"> Naming
        Conventions 命名约定</a>
</h4></div></div></div>
<p>
          Proto is a large library and probably quite unlike any library you've used
          before. Proto uses some consistent naming conventions to make it easier
          to navigate, and they're described below.<br>Proto 是一个大型库，可能与你所使用过的其它库很不一样。Proto 使用了一些一致的命名约定，使得它更容易操纵，以下对这些命名约定进行说明。
        </p>
<a name="boost_proto.users_guide.getting_started.naming.functions"></a><h6>
<a name="id3474036"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.functions">Functions 函数</a>
        </h6>
<p>
          All of Proto's functions are defined in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          namespace. For example, there is a function called <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> defined in <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          that accepts a terminal expression and returns the terminal's value.&nbsp;<br>所有的 Proto 函数定义在 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          命名空间内。例如，有一个名为 <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> 的函数被定义在 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          中，它接受一个终结符表达式并返回该终结符的值。
        </p>
<a name="boost_proto.users_guide.getting_started.naming.metafunctions"></a><h6>
<a name="id3474116"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.metafunctions">Metafunctions 元函数</a>
        </h6>
<p>
          Proto defines <span class="emphasis"><em>metafunctions</em></span> that correspond to each
          of Proto's free functions. The metafunctions are used to compute the functions'
          return types. All of Proto's metafunctions live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span></code>
          namespace and have the same name as the functions to which they correspond.
          For instance, there is a class template <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;&gt;</span></code> that you can use to compute the
          return type of the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> function.<br>Proto 为每一个 Proto 普通函数定义了一个相对应的 <span class="emphasis"><em>元函数</em></span>。这些元函数用于计算该函数的返回类型。所有的 Proto 元函数位于 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span></code>
          名字空间内，并具有与相对应的函数相同的名字。例如，有一个类模板 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;&gt;</span></code>，你可以用它来计算 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> 函数的返回类型。
        </p>
<a name="boost_proto.users_guide.getting_started.naming.function_objects"></a><h6>
<a name="id3474253"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.function_objects">Function
          Objects 函数对象</a>
        </h6>
<p>
          Proto defines <span class="emphasis"><em>function object</em></span> equivalents of all of
          its free functions. (A function object is an instance of a class type that
          defines an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
          member function.) All of Proto's function object types are defined in the
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span></code> namespace and have the same
          name as their corresponding free functions. For example, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span></code> is a class that defines a function
          object that does the same thing as the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> free function.<br>Proto 为其每一个普通函数定义了等价的 <span class="emphasis"><em>函数对象</em></span>(函数对象是一个定义了 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
          成员函数的类类型的一个实例)。所有的 Proto 函数对象类型都定义在
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span></code> 名字空间内，并具有与相对应的普通函数相同的名字。例如，<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span></code> 是一个类，它定义了一个函数对象，该函数对象与 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> 普通函数完成相同的事情。
        </p>
<a name="boost_proto.users_guide.getting_started.naming.primitive_transforms"></a><h6>
<a name="id3474399"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.primitive_transforms">Primitive
          Transforms 基本变换</a>
        </h6>
<p>
          Proto also defines <span class="emphasis"><em>primitive transforms</em></span> -- class types
          that can be used to compose larger transforms for manipulating expression
          trees. Many of Proto's free functions have corresponding primitive transforms.
          These live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          namespace and their names have a leading underscore. For instance, the
          transform corresponding to the <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> function is called <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>.<br>Proto 还定义了一些 <span class="emphasis"><em>基本变换</em></span> -- 可用于组成操纵表达式树所用的较大型变换的类类型。多数的 Proto 普通函数都有相对应的基本变换。这些变换位于 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          名字空间内，它们的名字以下划线打头。例如，与 <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> 函数相对应的变换名为 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>。
        </p>
<p>
          The following table summarizes the discussion above:<br>下表概括了以上的说明：
        </p>
<div class="table">
<a name="id3474491"></a><p class="title"><b>Table&nbsp;15.1.&nbsp;Proto Naming Conventions<br>表 15.1. Proto 命名约定</b></p>
<div class="table-contents"><table class="table" summary="Proto Naming Conventions">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
              <p>
                Entity 实体
              </p>
              </th>
<th>
              <p>
                Example 例子
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                Free Function 普通函数
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                Metafunction 元函数
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                Function Object 函数对象
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                Transform 变换
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>
              </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.hello_world"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_world" title="Hello World">Hello
        World</a>
</h4></div></div></div>
<p>
          Below is a very simple program that uses Proto to build an expression template
          and then execute it.<br>以下是一个非常简单的程序，它使用 Proto 来构建一个表达式模板，然后执行它。
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">ostream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>

<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_context</span> <span class="identifier">ctx</span><span class="special">;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="string">"hello"</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="string">" world"</span> <span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          This program outputs the following:<br>该程序的输出如下：
        </p>
<pre class="programlisting">hello, world<br></pre>
<p>
          This program builds an object representing the output operation and passes
          it to an <code class="computeroutput"><span class="identifier">evaluate</span><span class="special">()</span></code>
          function, which then executes it.<br>这个程序构建了一个表示输出操作的对象，并将它传递给一个 <code class="computeroutput"><span class="identifier">evaluate</span><span class="special">()</span></code>
          函数，后者对该操作进行执行。
        </p>
<p>
          The basic idea of expression templates is to overload all the operators
          so that, rather than evaluating the expression immediately, they build
          a tree-like representation of the expression so that it can be evaluated
          later. For each operator in an expression, at least one operand must be
          Protofied in order for Proto's operator overloads to be found. In the expression
          ...<br>表达式模板的基本意思是重载所有操作符，不再立即对表达式进行求值，而对该表达式构建一个树型的表示，以便在晚些时候进行求值。对于表达式中的每一个操作符，必须至少要有一个操作数是Proto化的，这样才可以找到 Proto 的操作符重载。在表达式 ...
        </p>
<pre class="programlisting"><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="string">"hello"</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="string">" world"</span>
</pre>
<p>
          ... the Protofied sub-expression is <code class="computeroutput"><span class="identifier">cout_</span></code>,
          which is the Proto-ification of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code>.
          The presence of <code class="computeroutput"><span class="identifier">cout_</span></code> "infects"
          the expression, and brings Proto's tree-building operator overloads into
          consideration. Any literals in the expression are then Protofied by wrapping
          them in a Proto terminal before they are combined into larger Proto expressions.<br>... 中，Proto化的子表达式是 <code class="computeroutput"><span class="identifier">cout_</span></code>，它是 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code> 的Proto化产物。<code class="computeroutput"><span class="identifier">cout_</span></code> 的出现"感染"了整个表达式，进而带来 Proto 的操作符重载，进行表达式树的构建。在这个表达式中的任何字面值都随后被Proto化，它们被包装为一个 Proto 终结符，然后被组装进更大的 Proto 表达式中。
        </p>
<p>
          Once Proto's operator overloads have built the expression tree, the expression
          can be lazily evaluated later by walking the tree. That is what <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
          does. It is a general tree-walking expression evaluator, whose behavior
          is customizable via a <span class="emphasis"><em>context</em></span> parameter. The use of
          <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>
          assigns the standard meanings to the operators in the expression. (By using
          a different context, you could give the operators in your expressions different
          semantics. By default, Proto makes no assumptions about what operators
          actually <span class="emphasis"><em>mean</em></span>.)<br>一旦 Proto 的操作符重载构建了这棵表达式树，这个表达式就可以在晚些时候通过遍历来进行惰性求值。这正是 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
          所做的事情。它是一个通用的表达式树遍历求值器，其行为可以通过一个 <span class="emphasis"><em>上下文</em></span> 参数来进行定制。<code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>
          的使用为表达式中的操作符赋予了标准意义(通过使用不同的上下文，你可以为表达式中的操作符赋予不同的语义。缺省情况下，Proto 对于操作符的实际意义不作任何假设)。
        </p>
<a name="boost_proto.users_guide.getting_started.hello_world.proto_design_philosophy"></a><h6>
<a name="id3475428"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_world.proto_design_philosophy">Proto
          Design Philosophy &nbsp;Proto的设计哲学</a>
        </h6>
<p>
          Before we continue, let's use the above example to illustrate an important
          design principle of Proto's. The expression template created in the <span class="emphasis"><em>hello
          world</em></span> example is totally general and abstract. It is not tied
          in any way to any particular domain or application, nor does it have any
          particular meaning or behavior on its own, until it is evaluated in a
          <span class="emphasis"><em>context</em></span>. Expression templates are really just heterogeneous
          trees, which might mean something in one domain, and something else entirely
          in a different one.&nbsp;<br>在我们继续往下之前，我们用上述例子来说明 Proto 的一个非常重要的设计原则。在 <span class="emphasis"><em>hello
          world</em></span> 例子中所创建的表达式模板完全是通用和抽象的。它没有以任何方式与任何特定的问题域或应用相结合，本身也没有任何特定的含义或行为，直至它在一个<span class="emphasis"><em>上下文</em></span>中被求值。表达式模板只是一个异类树，可能在某个问题域中具有某种意义，而在另一个问题域中则具有完全不同的意义。
        </p>
<p>
          As we'll see later, there is a way to create Proto expression trees that
          are <span class="emphasis"><em>not</em></span> purely abstract, and that have meaning and
          behaviors independent of any context. There is also a way to control which
          operators are overloaded for your particular domain. But that is not the
          default behavior. We'll see later why the default is often a good thing.<br>正如我们稍后将看到的，可以有方法创建非纯抽象的 Proto 表达式树，它具有独立于上下文的意义和行为。也有方法为你的特定问题域控制对哪些操作符进行重载。不过这些不是缺省的行为。稍后我们将看到为什么缺省值通常是好事。
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.hello_calculator"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
        Calculator</a>
</h4></div></div></div>
<p>
          "Hello, world" is nice, but it doesn't get you very far. Let's
          use Proto to build a DSEL (domain-specific embedded language) for a lazily-evaluated
          calculator. We'll see how to define the terminals in your mini-language,
          how to compose them into larger expressions, and how to define an evaluation
          context so that your expressions can do useful work. When we're done, we'll
          have a mini-language that will allow us to declare a lazily-evaluated arithmetic
          expression, such as <code class="computeroutput"><span class="special">(</span><span class="identifier">_2</span>
          <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span>
          <span class="special">*</span> <span class="number">100</span></code>,
          where <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="identifier">_2</span></code> are placeholders for values to be
          passed in when the expression is evaluated.<br>"Hello,
world" 的例子不错，不过它没有把你带得很远。下面我们用 Proto 来为惰性求值计算器构建一个 DSEL
(领域专用嵌入式语言)。我们将看到如何定义你的小型语言中的终结符，如何用它们来组成更大的表达式，以及如何定义一个求值上下文使得你的表达式可以做一
些有用的事。在我们完成了以上工作后，我们就有了一个小型语言，可以让我们声明一个惰性求值的算术计算器，如 <code class="computeroutput"><span class="special">(</span><span class="identifier">_2</span>
          <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span>
          <span class="special">*</span> <span class="number">100</span></code>，其中 <code class="computeroutput"><span class="identifier">_1</span></code> 和 <code class="computeroutput"><span class="identifier">_2</span></code> 为数值占位符，在对该表达式进行求值将传入这些数值。
        </p>
<a name="boost_proto.users_guide.getting_started.hello_calculator.defining_terminals"></a><h6>
<a name="id3475585"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.defining_terminals">Defining
          Terminals 定义终结符</a>
        </h6>
<p>
          The first order of business is to define the placeholders <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="identifier">_2</span></code>.
          For that, we'll use the <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>
          metafunction.<br>要做的第一件事是定义占位符 <code class="computeroutput"><span class="identifier">_1</span></code> 和 <code class="computeroutput"><span class="identifier">_2</span></code>。为此，我们要使用 <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code> 元函数。
        </p>
<pre class="programlisting"><span class="comment">// Define a placeholder type 定义一个占位符类型<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder</span>
<span class="special">{};</span>

<span class="comment">// Define the Protofied placeholder terminals 定义Proto化的占位符终结符<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{}};</span>
</pre>
<p>
          The initialization may look a little odd at first, but there is a good
          reason for doing things this way. The objects <code class="computeroutput"><span class="identifier">_1</span></code>
          and <code class="computeroutput"><span class="identifier">_2</span></code> above do not require
          run-time construction -- they are <span class="emphasis"><em>statically initialized</em></span>,
          which means they are essentially initialized at compile time. See the
          <a class="link" href="appendices.html#boost_proto.appendices.rationale.static_initialization" title="Static Initialization">Static
          Initialization</a> section in the <a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix B: Rationale">Rationale</a>
          appendix for more information.<br>乍一看，这个初始化有些奇怪，不过这样做是有很好的理由的。这里的对象 <code class="computeroutput"><span class="identifier">_1</span></code> 和 <code class="computeroutput"><span class="identifier">_2</span></code> 不需要运行期的构造 -- 它们是 <span class="emphasis"><em>静态初始化的</em></span>，即本质上它们是在编译期初始化的。更多信息请见 <a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix B: Rationale">基本原理</a> 附录中的
          <a class="link" href="appendices.html#boost_proto.appendices.rationale.static_initialization" title="Static Initialization">静态初始化</a> 一节。<a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix B: Rationale"></a>&nbsp;
        </p>
<a name="boost_proto.users_guide.getting_started.hello_calculator.constructing_expression_trees"></a><h6>
<a name="id3475894"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.constructing_expression_trees">Constructing
          Expression Trees 构造表达式树</a>
        </h6>
<p>
          Now that we have terminals, we can use Proto's operator overloads to combine
          these terminals into larger expressions. So, for instance, we can immediately
          say things like:<br>现在我们有终结符了，我们可以用 Proto 的操作符重载来把这些终结符组合成更大的表达式。例如，我们可以马上写出：
        </p>
<pre class="programlisting"><span class="comment">// This builds an expression template 构建一个表达式模板<br></span><span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">;</span>
</pre>
<p>
          This creates an expression tree with a node for each operator. The type
          of the resulting object is large and complex, but we are not terribly interested
          in it right now.<br>这将构建一个表达式树，其中每个操作符一个节点。结果对象的类型很长很复杂，不过我们现在还不需要过于担心。
        </p>
<p>
          So far, the object is just a tree representing the expression. It has no
          behavior. In particular, it is not yet a calculator. Below we'll see how
          to make it a calculator by defining an evaluation context.<br>到目前为止，这个对象只是代表这个表达式的一棵树。它没有行为。具体地说，它还不是一个计算器。下面我们将看到如何通过定义一个求值上下文使它变为一个计算器。
        </p>
<a name="boost_proto.users_guide.getting_started.hello_calculator.evaluating_expression_trees"></a><h6>
<a name="id3476002"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.evaluating_expression_trees">Evaluating
          Expression Trees 对表达式树求值</a>
        </h6>
<p>
          No doubt you want your expression templates to actually <span class="emphasis"><em>do</em></span>
          something. One approach is to define an <span class="emphasis"><em>evaluation context</em></span>.
          The context is like a function object that associates behaviors with the
          node types in your expression tree. The following example should make it
          clear. It is explained below.<br>毫无疑问，你希望你的表达式模板可以真真正正地做些什么。一个方法是定义一个 <span class="emphasis"><em>求值上下文</em></span>。这个上下文类似于一个函数对象，把行为关联到你的表达式树中的节点类型上。以下例子可以清楚地说明这一点。我们在后面再作解释。
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// Values to replace the placeholders 用于替换占位符的值<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">args</span><span class="special">;</span>
    
    <span class="comment">// Define the result type of the calculator. 定义计算器的结果类型<br></span>    <span class="comment">// (This makes the calculator_context "callable".) 使calculator_context变成"可调用"的<br></span>    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Handle the placeholders: 对占位符进行处理：<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">I</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          In <code class="computeroutput"><span class="identifier">calculator_context</span></code>,
          we specify how Proto should evaluate the placeholder terminals by defining
          the appropriate overloads of the function call operator. For any other
          nodes in the expression tree (e.g., arithmetic operations or non-placeholder
          terminals), Proto will evaluate the expression in the "default"
          way. For example, a binary plus node is evaluated by first evaluating the
          left and right operands and adding the results. Proto's default evaluator
          uses the <a href="../../../libs/typeof/index.html" target="_top">Boost.Typeof</a>
          library to compute return types.<br>在 <code class="computeroutput"><span class="identifier">calculator_context</span></code>
中，我们通过定义合适的函数调用操作符重载，指定 Proto
应如何对占位符终结符进行求值。对于表达式树中的其它节点(如算术操作或非占位符的终结符)，Proto
将以"缺省"的方式对表达式进行求值。例如，一个二元加法节点的求值方式为，首先求出左、右操作数的值，然后相加得到结果。Proto
的缺省求值器使用了 <a href="../../../libs/typeof/index.html" target="_top">Boost.Typeof</a>
          库来计算返回类型。
        </p>
<p>
          Now that we have an evaluation context for our calculator, we can use it
          to evaluate our arithmetic expressions, as below:<br>现在我们有一个求值上下文，可用于我们的计算器，我们可以用它来对我们的算术表达式进行求值，如下：
        </p>
<pre class="programlisting"><span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">45</span><span class="special">);</span> <span class="comment">// the value of _1 is 45<br></span><span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">50</span><span class="special">);</span> <span class="comment">// the value of _2 is 50<br></span>
<span class="comment">// Create an arithmetic expression and immediately evaluate it<br>// 创建一个算术表达式并立即对它求值<br></span><span class="keyword">double</span> <span class="identifier">d</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">,</span> <span class="identifier">ctx</span> <span class="special">);</span>

<span class="comment">// This prints "10" 打印"10"<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">d</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
          Later, we'll see how to define more interesting evaluation contexts and
          expression transforms that give you total control over how your expressions
          are evaluated.<br>稍后，我们将看到如何定义更多有趣的求值上下文和表达式变换，让你可以完全地控制如何对你的表达式进行求值。
        </p>
<a name="boost_proto.users_guide.getting_started.hello_calculator.customizing_expression_trees"></a><h6>
<a name="id3476640"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.customizing_expression_trees">Customizing
          Expression Trees 定制表达式树</a>
        </h6>
<p>
          Our calculator DSEL is already pretty useful, and for many DSEL scenarios,
          no more would be needed. But let's keep going. Imagine how much nicer it
          would be if all calculator expressions overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> so that they could be used as function
          objects. We can do that by creating a calculator <span class="emphasis"><em>domain</em></span>
          and telling Proto that all expressions in the calculator domain have extra
          members. Here is how to define a calculator domain:<br>我们的计算器DSEL已经相当有用，对于多数的DSEL情形，没有更多要做的事情。不过让我们继续前进。想象一下，如果所有计算器表达式都重载了 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 以便可以它们可以象函数对象那样来使用，这该多好。我们可以做到这一点，方法是创建一个计算器<span class="emphasis"><em>域</em></span>并告诉 Proto 计算器域中的所有表达式都有额外的成员。以下是如何定义一个计算器域的方法：
        </p>
<pre class="programlisting"><span class="comment">// Forward-declare an expression wrapper 前向声明一个表达式包装器<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span><span class="special">;</span>

<span class="comment">// Define a calculator domain. Expression within<br></span><span class="comment">// the calculator domain will be wrapped in the<br></span><span class="comment">// calculator&lt;&gt; expression wrapper.<br>// 定义一个计算器域。在此计算器域中的表达式都将被包装在<br>// calculator&lt;&gt; 表达式包装器中。<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          type will be an expression wrapper. It will behave just like the expression
          that it wraps, but it will have extra member functions that we will define.
          The <code class="computeroutput"><span class="identifier">calculator_domain</span></code> is
          what informs Proto about our wrapper. It is used below in the definition
          of <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>.
          Read on for a description.<br>类型 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          是一个表达式包装器。其行为与所包裹的表达式一样，不过它多了一个我们将要定义的成员函数。<code class="computeroutput"><span class="identifier">calculator_domain</span></code> 则用于将我们的包装器告知 Proto。它将在下面的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 定义中使用。继续看下去。
        </p>
<pre class="programlisting"><span class="comment">// Define a calculator expression wrapper. It behaves just like<br></span><span class="comment">// the expression it wraps, but with an extra operator() member<br></span><span class="comment">// function that evaluates the expression.    <br>// 定义一个计算器表达式的包装器。其行为与所包裹的表达式一样，不过它多了一个<br>// 对表达式进行求值的 operator() 成员函数<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">calculator</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">())</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Overload operator() to invoke proto::eval() with<br></span>    <span class="comment">// our calculator_context.<br>    // 重载 operator()，以我们的 calculator_context 调用 proto::eval()<br></span>    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a1</span><span class="special">);</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a2</span><span class="special">);</span>
        
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          struct is an expression <span class="emphasis"><em>extension</em></span>. It uses <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code>
          to effectively add additional members to an expression type. When composing
          larger expressions from smaller ones, Proto notes what domain the smaller
          expressions are in. The larger expression is in the same domain and is
          automatically wrapped in the domain's extension wrapper.<br>结构 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          是一个表达式 <span class="emphasis"><em>扩展</em></span>。它用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code>
          来高效地将额外成员添加到一个表达式类型中。当从较小的表达式组成较大的表达式时，Proto 会留意到小表达式是属于哪个域的。这样，大表达式将被置于同一个域并自动被包装到该域的扩展包装器中。
        </p>
<p>
          All that remains to be done is to put our placeholders in the calculator
          domain. We do that by wrapping them in our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper, as below:<br>剩下要做的就是将我们的占位符也放入这个计算器域中。我们通过将它们包进我们的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 包装器中来做到这一点，如下：
        </p>
<pre class="programlisting"><span class="comment">// Define the Protofied placeholder terminals, in the<br></span><span class="comment">// calculator domain.<br>// 在计算器域中定义Proto化的占位符终结符。<br></span><span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>
</pre>
<p>
          Any larger expression that contain these placeholders will automatically
          be wrapped in the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper and have our <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
          overload. That means we can use them as function objects as follows.<br>任何含有这些占位符的较大表达式都将自动被包进 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 包装器中，并且带有我们的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
          重载。这意味着我们可以象下面那样把它们当作函数对象为使用。
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">result</span> <span class="special">=</span> <span class="special">((</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">)(</span><span class="number">45.0</span><span class="special">,</span> <span class="number">50.0</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="special">(</span><span class="number">50.0</span> <span class="special">-</span> <span class="number">45.0</span><span class="special">)</span> <span class="special">/</span> <span class="number">50.0</span> <span class="special">*</span> <span class="number">100</span><span class="special">));</span>
</pre>
<p>
          Since calculator expressions are now valid function objects, we can use
          them with standard algorithms, as shown below:<br>由于计算器表达式现在已经是有效的函数对象了，所以我们可以将它们用于标准算法，示范如下：
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">a1</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">56</span><span class="special">,</span> <span class="number">84</span><span class="special">,</span> <span class="number">37</span><span class="special">,</span> <span class="number">69</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a2</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">65</span><span class="special">,</span> <span class="number">120</span><span class="special">,</span> <span class="number">60</span><span class="special">,</span> <span class="number">70</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a3</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">0</span> <span class="special">};</span>

<span class="comment">// Use std::transform() and a calculator expression<br></span><span class="comment">// to calculate percentages given two input sequences:<br>// 使用 std::transform() 和一个计算器表达式来计算给定的两个输入序列的百分比：<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">a1</span><span class="special">,</span> <span class="identifier">a1</span><span class="special">+</span><span class="number">4</span><span class="special">,</span> <span class="identifier">a2</span><span class="special">,</span> <span class="identifier">a3</span><span class="special">,</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">);</span>
</pre>
<p>
          Now, let's use the calculator example to explore some other useful features
          of Proto.<br>现在，我们用这个计算器例子来展示 Proto 的其它一些有用的特性。
        </p>
<a name="boost_proto.users_guide.getting_started.hello_calculator.detecting_invalid_expressions"></a><h6>
<a name="id3478204"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.detecting_invalid_expressions">Detecting
          Invalid Expressions 检测无效表达式</a>
        </h6>
<p>
          You may have noticed that you didn't have to define an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">-()</span></code>
          or <code class="computeroutput"><span class="keyword">operator</span><span class="special">/()</span></code>
          -- Proto defined them for you. In fact, Proto overloads <span class="emphasis"><em>all</em></span>
          the operators for you, even though they may not mean anything in your domain-specific
          language. That means it may be possible to create expressions that are
          invalid in your domain. You can detect invalid expressions with Proto by
          defining the <span class="emphasis"><em>grammar</em></span> of your domain-specific language.<br>你可能已经注意到，你并不需要定义重载的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">-()</span></code> 或 <code class="computeroutput"><span class="keyword">operator</span><span class="special">/()</span></code>
          -- Proto 已经为你定义了。实际上，Proto 为你重载了<span class="emphasis"><em>所有的</em></span>
         操作符，即使是它们在你的领域专用语言中并没有意义。这意味着有可能创建一些在你的问题域中是无效的表达式。你可以通过定义你的领域专用语言的<span class="emphasis"><em>语法</em></span>来让 Proto 检测无效的表达式。
        </p>
<p>
          For simplicity, assume that our calculator DSEL should only allow addition,
          subtraction, multiplication and division. Any expression involving any
          other operator is invalid. Using Proto, we can state this requirement by
          defining the grammar of the calculator DSEL. It looks as follows:<br>为简单起见，假设我们的计算器DSEL只允许加、减、乘、除。任何涉及其它操作符的表达式都是无效的。使用 Proto，我们可以通过定义这个计算器DSEL的语法来声明这些要求。如下：
        </p>
<pre class="programlisting"><span class="comment">// Define the grammar of calculator expressions 定义计算器表达式的语法<br></span><span class="keyword">struct</span> <span class="identifier">calculator_grammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          You can read the above grammar as follows: an expression tree conforms
          to the calculator grammar if it is a binary plus, minus, multiplies or
          divides node, where both child nodes also conform to the calculator grammar;
          or if it is a terminal. In a Proto grammar, <code class="computeroutput"><a class="link" href="../boost/proto/_.html" title="Struct _">proto::_</a></code> is a wildcard that matches
          any type, so <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span>
          <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code>
          matches any terminal, whether it is a placeholder or a literal.<br>你可以这样来读以上语法：一个表达式树符合这个计算器语法，如果它是一个二元加法、减法、乘法或除法，且它的两个子树都符合这个计算器语法；或者如果它是一个终结符。在 Proto 语法中，<code class="computeroutput"><a class="link" href="../boost/proto/_.html" title="Struct _">proto::_</a></code> 是一个匹配任何类型的通配符，所以 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span>
          <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code> 匹配任何终结符，无论它是一个占位符或字面值。
        </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
            This grammar is actually a little looser than we would like. Only placeholders
            and literals that are convertible to doubles are valid terminals. Later
            on we'll see how to express things like that in Proto grammars.</p><p>这个语法实际上比我们想要的稍微宽松了一些。只有可以转换为 double 的占位符和字面值才是有效的终结符。稍后我们将看到如何在 Proto 语法中来表示这样的情况。
          </p></td></tr>
</tbody></table></div>
<p>
          Once you have defined the grammar of your DSEL, you can use the <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code> metafunction to check
          whether a given expression type conforms to the grammar. For instance,
          we might add the following to our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> overload:<br>一旦你定义了你的DSEL语法，你就可以使用 <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code> 元函数来检测一个给定的表达式类型是否符合该语法。例如，我们可以将以下代码增加到我们的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> 重载中：
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="comment">/* ... as before ... */</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">/* ... */</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// Check here that the expression we are about to<br></span>        <span class="comment">// evaluate actually conforms to the calculator grammar.<br>        // 这里检测我们要求值的表达式实际上是否符合计算器语法。<br></span>        <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator_grammar</span><span class="special">&gt;));</span>
        <span class="comment">/* ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          The addition of the <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code> line enforces at compile time that we
          only evaluate expressions that conform to the calculator DSEL's grammar.
          With Proto grammars, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code> it is very easy to give the users of
          your DSEL short and readable compile-time errors when they accidentally
          misuse your DSEL.<br>这行新增的 <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code> 在编译期确定我们只能对符合计算器DSEL语法的表达式进行求值。通过使用 Proto 语法、<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code>，可以很容易地在你的DSEL用户不小心误用了你的DSEL时，给出简短易读的编译期错误。
        </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
            <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code>
            is part of the Boost Metaprogramming Library. To use it, just <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>.</p><p><code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code>
            是 Boost Metaprogramming 库的一部分。要使用它，只要 <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>.
          </p></td></tr>
</tbody></table></div>
<a name="boost_proto.users_guide.getting_started.hello_calculator.controlling_operator_overloads"></a><h6>
<a name="id3479063"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.controlling_operator_overloads">Controlling
          Operator Overloads 控制操作符的重载</a>
        </h6>
<p>
          Grammars and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
          make it possible to detect when a user has created an invalid expression
          and issue a compile-time error. But what if you want to prevent users from
          creating invalid expressions in the first place? By using grammars and
          domains together, you can disable any of Proto's operator overloads that
          would create an invalid expression. It is as simple as specifying the DSEL's
          grammar when you define the domain, as shown below:<br>语法和 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
可以在用户创建一个无效表达式时进行检查并引发编译期错误。不过，如果你想在第一时间阻止用户创建无效的表达式工，又应如何呢？通过合用语法和领域，你可
以禁止任何可能创建无效表达式的 Proto 操作符重载。这很简单，只要在你定义领域时指定DSEL的语法就行了，示范如下： </p>
<pre class="programlisting"><span class="comment">// Define a calculator domain. Expression within<br></span><span class="comment">// the calculator domain will be wrapped in the<br></span><span class="comment">// calculator&lt;&gt; expression wrapper.<br></span><span class="comment">// NEW: Any operator overloads that would create an<br></span><span class="comment">//      expression that does not conform to the<br></span><span class="comment">//      calculator grammar is automatically disabled.<br>// 定义一个计算器域。在该计算器域中的表达式将被包进 calculator&lt;&gt; 表达式包装器中。<br>// 新增：任何会创建一个不符合计算器语法的操作符重载都会被自动禁止。<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator</span><span class="special">&gt;,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          The only thing we changed is we added <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
          as the second template parameter to the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> template when defining <code class="computeroutput"><span class="identifier">calculator_domain</span></code>. With this simple addition,
          we disable any of Proto's operator overloads that would create an invalid
          calculator expression.<br>我们唯一修改的地方是，在定义 <code class="computeroutput"><span class="identifier">calculator_domain</span></code> 时增加了 <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
          作为 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> 模板的第二个模板参数。通过这一个简单的添加，我们禁止了任何会创建出无效的计算器表达式的 Proto 操作符重载。
        </p>
<a name="boost_proto.users_guide.getting_started.hello_calculator.____and_much_more"></a><h6>
<a name="id3479292"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.____and_much_more">...
          And Much More &nbsp;... 还有更多</a>
        </h6>
<p>
          Hopefully, this gives you an idea of what sorts of things Proto can do
          for you. But this only scratches the surface. The rest of this users' guide
          will describe all these features and others in more detail.<br>我们希望，以上可以使你了解 Proto 可以为你做什么样的事情。不过，这只仅仅触及到表面。这个用户指南的其余部分将讲述所有这些特性以及其它更多细节。
        </p>
<p>
          Happy metaprogramming!<br>元编程快乐！
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.front_end"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end" title="Fronts Ends: Defining Terminals and Non-Terminals of Your DSEL"> Fronts Ends: Defining
      Terminals and Non-Terminals of Your DSEL 前端：为你的DSEL定义终结符和非终结符</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.making_terminals">Making
        Terminals 制造终结符</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads">Proto's
        Operator Overloads &nbsp;Proto的操作符重载</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions">Making
        Lazy Functions 制造惰性函数</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions">Adding
        Members by Extending Expressions 通过扩展表达式增加成员</a></span></dt>
</dl></div>
<p>
        Here is the fun part: designing your own mini-programming language. In this
        section we'll talk about the nuts and bolts of designing a DSEL interface
        using Proto. We'll cover the definition of terminals and lazy functions that
        the users of your DSEL will get to program with. We'll also talk about Proto's
        expression template-building operator overloads, and about ways to add additional
        members to expressions within your domain.<br>以
下是比较有趣的部分：设计你自己的小型编程语言。在这一节中，我们将讨论使用 Proto
来设计一个DSEL接口的相关细节。我们将涵盖终结符定义和惰性函数，它们是你的DSEL用户要用来写程序的。我们也将讨论 Proto
的表达式模板构建的操作符重载，以及为你的领域中的表达式增加成员的方法。 </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.making_terminals"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_terminals" title="Making Terminals">Making
        Terminals 制造终结符</a>
</h4></div></div></div>
<p>
          As we saw with the Calculator example from the Introduction, the simplest
          way to get a DSEL up and running is simply to define some terminals, as
          follows.<br>正如我们在"简介"中看到的计算器例子，获得一个DSEL并运行它的最简单方法是定义一些终结符，如下。
        </p>
<pre class="programlisting"><span class="comment">// Define a literal integer Proto expression. 定义一个字面值整数 Proto 表达式。<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">{</span><span class="number">0</span><span class="special">};</span>

<span class="comment">// This creates an expression template. 创建一个表达式模板。<br></span><span class="identifier">i</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
<p>
          With some terminals and Proto's operator overloads, you can immediately
          start creating expression templates.<br>有了一些终结符和 Proto 的操作符重载，你就可以马上开始创建表达式模板了。
        </p>
<p>
          Defining terminals -- with aggregate initialization -- can be a little
          awkward at times. Proto provides an easier-to-use wrapper for literals
          that can be used to construct Protofied terminal expressions. It's called
          <code class="computeroutput"><a class="link" href="../boost/proto/literal.html" title="Struct template literal">proto::literal&lt;&gt;</a></code>.<br>定义终结符 -- 加上初始化 -- 通常有些难看。Proto 为字面值提供了一个更为易用的包装器，可以用于构造Proto化的终结符表达式工。它名为 <code class="computeroutput"><a class="link" href="../boost/proto/literal.html" title="Struct template literal">proto::literal&lt;&gt;</a></code>。
        </p>
<pre class="programlisting"><span class="comment">// Define a literal integer Proto expression.</span><span class="comment"> 定义一个字面值整数 Proto 表达式。</span><span class="comment"> <br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

<span class="comment">// Proto literals are really just Proto terminal expressions.<br></span><span class="comment">// For example, this builds a Proto expression template:<br>// Proto 字面值其实就是 Proto 终结符表达式工。例如，以下创建一个 Proto 表达式模板：<br></span><span class="identifier">i</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
<p>
          There is also a <code class="computeroutput"><a class="link" href="../boost/proto/lit.html" title="Function lit">proto::lit()</a></code> function for constructing
          a <code class="computeroutput"><a class="link" href="../boost/proto/literal.html" title="Struct template literal">proto::literal&lt;&gt;</a></code> in-place. The above
          expression can simply be written as:<br>还有一个 <code class="computeroutput"><a class="link" href="../boost/proto/lit.html" title="Function lit">proto::lit()</a></code> 函数用于就地构造 <code class="computeroutput"><a class="link" href="../boost/proto/literal.html" title="Struct template literal">proto::literal&lt;&gt;</a></code>。以上表达式可以简化为：
        </p>
<pre class="programlisting"><span class="comment">// proto::lit(0) creates an integer terminal expression</span><br><span class="comment">// proto::lit(0) 创建一个整数终结符表达式<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">lit</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.proto_s_operator_overloads"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads" title="Proto's Operator Overloads">Proto's
        Operator Overloads &nbsp;Proto的操作符重载</a>
</h4></div></div></div>
<p>
          Once we have some Proto terminals, expressions involving those terminals
          build expression trees for us. Proto defines overloads for each of C++'s
          overloadable operators in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          namespace. As long as one operand is a Proto expression, the result of
          the operation is a tree node representing that operation.<br>一旦我们有了一些 Proto 终结符之后，包含这些终结符的表达式将会为我们构建相应的表达式树。Proto 在 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          名字空间中为C++的每一个可重载的操作符都定义了重载。只要有一个操作数是 Proto 表达式工，操作的结果就是一个表示该操作的树节点。
        </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
            Proto's operator overloads live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
            namespace and are found via ADL (argument-dependent lookup). That is
            why expressions must be "tainted" with Proto-ness for Proto
            to be able to build trees out of expressions.</p><p>
            Proto 的操作符重载位于 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
            名字空间内，要通过ADL(参数依赖查找)来查找。这就是为什么表达式必须要被Proto化对象"感染"，Proto
            才能构建出表达式树的原因。
          </p></td></tr>
</tbody></table></div>
<p>
          As a result of Proto's operator overloads, we can say:<br>作为 Proto 操作符重载的结果，我们可以写：
        </p>
<pre class="programlisting"><span class="special">-</span><span class="identifier">_1</span><span class="special">;</span>        <span class="comment">// OK, build a unary-negate tree node<br></span><span class="identifier">_1</span> <span class="special">+</span> <span class="number">42</span><span class="special">;</span>    <span class="comment">// OK, build a binary-plus tree node<br></span></pre>
<p>
          For the most part, this Just Works and you don't need to think about it,
          but a few operators are special and it can be helpful to know how Proto
          handles them.<br>大多数情况下，都可以正常工作，你无需担心它，不过有少数的操作符比较特殊，知道 Proto
          是如何处理它们的可以有所帮助。
        </p>
<a name="boost_proto.users_guide.front_end.proto_s_operator_overloads.assignment__subscript__and_function_call_operators"></a><h6>
<a name="id3479813"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads.assignment__subscript__and_function_call_operators">Assignment,
          Subscript, and Function Call Operators 赋值、下标和函数调用操作符</a>
        </h6>
<p>
          Proto also overloads <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>, and <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>, but these operators are member functions
          of the expression template rather than free functions in Proto's namespace.
          The following are valid Proto expressions:<br>Proto 也重载了 <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>, 和 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>, 不过这些操作符是表达式模板的成员函数，而不是 Proto 名字空间下的普通函数。以下是有效的 Proto 表达式：
        </p>
<pre class="programlisting"><span class="identifier">_1</span> <span class="special">=</span> <span class="number">5</span><span class="special">;</span>     <span class="comment">// OK, builds a binary assign tree node<br></span><span class="identifier">_1</span><span class="special">[</span><span class="number">6</span><span class="special">];</span>      <span class="comment">// OK, builds a binary subscript tree node<br></span><span class="identifier">_1</span><span class="special">();</span>       <span class="comment">// OK, builds a unary function tree node<br></span><span class="identifier">_1</span><span class="special">(</span><span class="number">7</span><span class="special">);</span>      <span class="comment">// OK, builds a binary function tree node<br></span><span class="identifier">_1</span><span class="special">(</span><span class="number">8</span><span class="special">,</span><span class="number">9</span><span class="special">);</span>    <span class="comment">// OK, builds a ternary function tree node<br></span><span class="comment">// ... etc.<br></span></pre>
<p>
          For the first two lines, assignment and subscript, it should be fairly
          unsurprising that the resulting expression node should be binary. After
          all, there are two operands in each expression. It may be surprising at
          first that what appears to be a function call with no arguments, <code class="computeroutput"><span class="identifier">_1</span><span class="special">()</span></code>,
          actually creates an expression node with one child. The child is <code class="computeroutput"><span class="identifier">_1</span></code> itself. Likewise, the expression
          <code class="computeroutput"><span class="identifier">_1</span><span class="special">(</span><span class="number">7</span><span class="special">)</span></code> has two
          children: <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="number">7</span></code>.<br>头两行，赋值和下标操作，产生的表达式节点是二元的，这应该不足为奇。毕竟，每个表达式都有两个操作数。可能会令人惊奇的首先是不带参数的函数调用，<code class="computeroutput"><span class="identifier">_1</span><span class="special">()</span></code>,
          实际上它将创建一个带有一个子节点的表达式节点。这个子节点就是 <code class="computeroutput"><span class="identifier">_1</span></code> 本身。同样，表达式
          <code class="computeroutput"><span class="identifier">_1</span><span class="special">(</span><span class="number">7</span><span class="special">)</span></code> 有两个子节点：<code class="computeroutput"><span class="identifier">_1</span></code> 和 <code class="computeroutput"><span class="number">7</span></code>。
        </p>
<p>
          Because these operators can only be defined as member functions, the following
          expressions are invalid:<br>因为这些操作符只能被定义为成员函数，所以以下表达式是无效的：
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span><span class="special">;</span>
<span class="identifier">i</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">;</span>         <span class="comment">// ERROR: cannot assign _1 to an int<br></span>
<span class="keyword">int</span> <span class="special">*</span><span class="identifier">p</span><span class="special">;</span>
<span class="identifier">p</span><span class="special">[</span><span class="identifier">_1</span><span class="special">];</span>          <span class="comment">// ERROR: cannot use _1 as an index<br></span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">(</span><span class="identifier">_1</span><span class="special">);</span>   <span class="comment">// ERROR: cannot call std::sin() with _1<br></span></pre>
<p>
          Also, C++ has special rules for overloads of <code class="computeroutput"><span class="keyword">operator</span><span class="special">-&gt;</span></code> that make it useless for building
          expression templates, so Proto does not overload it.<br>还有，C++对于 <code class="computeroutput"><span class="keyword">operator</span><span class="special">-&gt;</span></code> 的重载具有特殊的规则，使得它不能用于构建表达式模板，因此 Proto 没有重载它。
        </p>
<a name="boost_proto.users_guide.front_end.proto_s_operator_overloads.the_address_of_operator"></a><h6>
<a name="id3480240"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads.the_address_of_operator">The
          Address-Of Operator 取址操作符</a>
        </h6>
<p>
          Proto overloads the address-of operator for expression types, so that the
          following code creates a new unary address-of tree node:<br>Proto 为表达式类型重载了取址操作符，以下代码将会创建一个新的单参取址操作的树节点：
        </p>
<pre class="programlisting"><span class="special">&amp;</span><span class="identifier">_1</span><span class="special">;</span>    <span class="comment">// OK, creates a unary address-of tree node<br></span></pre>
<p>
          It does <span class="emphasis"><em>not</em></span> return the address of the <code class="computeroutput"><span class="identifier">_1</span></code> object. However, there is special
          code in Proto such that a unary address-of node is implicitly convertible
          to a pointer to its child. In other words, the following code works and
          does what you might expect, but not in the obvious way:<br>它不是返回 <code class="computeroutput"><span class="identifier">_1</span></code> 对象的地址。不过，在 Proto 中有特殊的代码，使得一个单参取址节点可以隐式转换为其子节点的指针。换言之，以下代码可以工作且结果如你所想，只不过方式不太明显而已：
        </p>
<pre class="programlisting"><span class="keyword">typedef</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">_1_type</span><span class="special">;</span>

<span class="identifier">_1_type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">_1_type</span> <span class="keyword">const</span> <span class="special">*</span> <span class="identifier">p</span> <span class="special">=</span> <span class="special">&amp;</span><span class="identifier">_1</span><span class="special">;</span> <span class="comment">// OK, &amp;_1 implicitly converted<br></span></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.making_lazy_functions"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions" title="Making Lazy Functions">Making
        Lazy Functions 制造惰性函数</a>
</h4></div></div></div>
<p>
          If we limited ourselves to nothing but terminals and operator overloads,
          our domain-specific embedded languages wouldn't be very expressive. Imagine
          that we wanted to extend our calculator DSEL with a full suite of math
          functions like <code class="computeroutput"><span class="identifier">sin</span><span class="special">()</span></code>
          and <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>
          that we could invoke lazily as follows.<br>如果我们把自己仅限制在终结符和操作符重载上，那么我们的DSEL不会太有表达力。想象一下，我们想以一整套数学函数，如 <code class="computeroutput"><span class="identifier">sin</span><span class="special">()</span></code> 和 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>，来扩展我们的计算器DSEL，以便我们可以象下面这样对这些函数进行惰性执行。
        </p>
<pre class="programlisting"><span class="comment">// A calculator expression that takes one argument<br></span><span class="comment">// and takes the sine of it.<br>// 一个计算器表达式工，带有一个参数和正弦函数。<br></span><span class="identifier">sin</span><span class="special">(</span><span class="identifier">_1</span><span class="special">);</span>
</pre>
<p>
          We would like the above to create an expression template representing a
          function invocation. When that expression is evaluated, it should cause
          the function to be invoked. (At least, that's the meaning of function invocation
          we'd like the calculator DSEL to have.) You can define <code class="computeroutput"><span class="identifier">sin</span></code>
          quite simply as follows.<br>我们希望以上代码可以创建一个表示这次函数调用的表达式模板。当对此表达式进行求值时，将引发对此函数的调用。(至少，这是我们所想要的计算器DSEL应具有的函数调用的意义)。你可以象下面这样非常简单地定义 <code class="computeroutput"><span class="identifier">sin</span></code>。&nbsp;
        </p>
<pre class="programlisting"><span class="comment">// "sin" is a Proto terminal containing a function pointer<br>// "sin" 是一个 Proto 终结符，包含一个函数指针<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">(*)(</span><span class="keyword">double</span><span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">sin</span> <span class="special">=</span> <span class="special">{&amp;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">};</span>
</pre>
<p>
          In the above, we define <code class="computeroutput"><span class="identifier">sin</span></code>
          as a Proto terminal containing a pointer to the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">()</span></code> function. Now we can use <code class="computeroutput"><span class="identifier">sin</span></code> as a lazy function. The <code class="computeroutput"><span class="identifier">default_context</span></code> that we saw in the Introduction
          knows how to evaluate lazy functions. Consider the following:<br>在上述代码中，我们将 <code class="computeroutput"><span class="identifier">sin</span></code>
          定义为一个含有一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">()</span></code> 函数指针的 Proto 终结符。现在我们可以将 <code class="computeroutput"><span class="identifier">sin</span></code> 作为惰性函数来使用。我们在"简介"中看到的 <code class="computeroutput"><span class="identifier">default_context</span></code> 知道如何对惰性函数进行求值。考虑以下代码：
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">pi</span> <span class="special">=</span> <span class="number">3.1415926535</span><span class="special">;</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="comment">// Create a lazy "sin" invocation and immediately evaluate it<br>// 创建一个惰性"sin"调用并马上对它求值<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="identifier">sin</span><span class="special">(</span><span class="identifier">pi</span><span class="special">/</span><span class="number">2</span><span class="special">),</span> <span class="identifier">ctx</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
          The above code prints out:<br>以上代码将打印出：
        </p>
<pre class="programlisting">1</pre>
<p>
          It is important to note that there is nothing special about terminals that
          contain function pointers. <span class="emphasis"><em>Any</em></span> Proto expression has
          an overloaded function call operator. Consider:<br>有一点很重要，含有函数指针的终结符并没有什么特殊。<span class="emphasis"><em>任何</em></span> Proto 表达式都有一个重载的函数调用操作符。考虑：
        </p>
<pre class="programlisting"><span class="comment">// This compiles! 这是可以编译的！<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">lit</span><span class="special">(</span><span class="number">1</span><span class="special">)(</span><span class="number">2</span><span class="special">)(</span><span class="number">3</span><span class="special">,</span><span class="number">4</span><span class="special">)(</span><span class="number">5</span><span class="special">,</span><span class="number">6</span><span class="special">,</span><span class="number">7</span><span class="special">,</span><span class="number">8</span><span class="special">);</span>
</pre>
<p>
          That may look strange at first. It creates an integer terminal with <code class="computeroutput"><a class="link" href="../boost/proto/lit.html" title="Function lit">proto::lit()</a></code>, and then invokes it like
          a function again and again. What does it mean? To be sure, the <code class="computeroutput"><span class="identifier">default_context</span></code> wouldn't know what to
          do with it. The <code class="computeroutput"><span class="identifier">default_context</span></code>
          only knows how to evaluate expressions that are sufficiently C++-like.
          In the case of function call expressions, the left hand side must evaluate
          to something that can be invoked: a pointer to a function, a reference
          to a function, or a TR1-style function object. That doesn't stop you from
          defining your own evaluation context that gives that expression a meaning.
          But more on that later.<br>这看起来很怪异。它首先以 <code class="computeroutput"><a class="link" href="../boost/proto/lit.html" title="Function lit">proto::lit()</a></code> 创建一个整数终结符，然后一遍一遍地象函数一样调用它。这意味着什么呢？可以肯定的是，<code class="computeroutput"><span class="identifier">default_context</span></code> 不知道这要做什么。<code class="computeroutput"><span class="identifier">default_context</span></code>
          只知道如何完全按C++的方式来对表达式求值。对于函数调用表达式，其左边的操作数必须求值为某种可以调用的东西：函数指针、函数引用或TR1风格的函数对象。不过这并不妨碍你定义自己的求值上下文，来给这个表达式赋予某种意义。那是后话。
        </p>
<a name="boost_proto.users_guide.front_end.making_lazy_functions.making_lazy_functions__continued"></a><h6>
<a name="id3481054"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions.making_lazy_functions__continued">Making
          Lazy Functions, Continued 制造惰性函数(续)</a>
        </h6>
<p>
          Now, what if we wanted to add a <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> function to our calculator DSEL that
          users could invoke as follows?<br>现在，如果我们想把 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 函数增加到我们的计算器DSEL中，让用户可以象下面那样来调用，又该如何？
        </p>
<pre class="programlisting"><span class="comment">// A calculator expression that takes one argument<br></span><span class="comment">// and raises it to the 2nd power<br>// 一个计算器表达式，带有一个参数并计算其平方<br></span><span class="identifier">pow</span><span class="special">&lt;</span> <span class="number">2</span> <span class="special">&gt;(</span><span class="identifier">_1</span><span class="special">);</span>
</pre>
<p>
          The simple technique described above of making <code class="computeroutput"><span class="identifier">pow</span></code>
          a terminal containing a function pointer doesn't work here. If <code class="computeroutput"><span class="identifier">pow</span></code> is an object, then the expression
          <code class="computeroutput"><span class="identifier">pow</span><span class="special">&lt;</span>
          <span class="number">2</span> <span class="special">&gt;(</span><span class="identifier">_1</span><span class="special">)</span></code> is
          not valid C++. <code class="computeroutput"><span class="identifier">pow</span></code> needs
          to be a real function template. But it must be an unusual function; it
          must return an expression template.<br>前面所讲的简单技术，把 <code class="computeroutput"><span class="identifier">pow</span></code>
          做成一个含有函数指针的终结符，在这里是不行的。如果 <code class="computeroutput"><span class="identifier">pow</span></code> 是一个对象，则表达式
          <code class="computeroutput"><span class="identifier">pow</span><span class="special">&lt;</span>
          <span class="number">2</span> <span class="special">&gt;(</span><span class="identifier">_1</span><span class="special">)</span></code> 不是有效的C++表达式。<code class="computeroutput"><span class="identifier">pow</span></code> 必须是一个真实的函数模板。但是它又必须是一个不平常的函数；它必须返回一个表达式模板。
        </p>
<p>
          Before we can write the <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> function, we need a function object that
          wraps an invocation of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pow</span><span class="special">()</span></code>.<br>在我们编写 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 函数之前，我们需要一个函数对象来包装对 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pow</span><span class="special">()</span></code> 的调用。
        </p>
<pre class="programlisting"><span class="comment">// Define a pow_fun function object<br>// 定义一个 pow_fun 函数对象<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">Exp</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">pow_fun</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pow</span><span class="special">(</span><span class="identifier">d</span><span class="special">,</span> <span class="identifier">Exp</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          Now, let's try to define a function template that returns an expression
          template. We'll use the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> metafunction to calculate the type
          of a Proto expression that represents a function call. It is analogous
          to <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>. (We'll see a couple
          of different ways to solve this problem, and each will demonstrate another
          utility for defining Proto front-ends.)<br>现在，我们来试一下定义一个返回表达式模板的函数模板。我们将使用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> 元函数来计算表示一个函数调用的 Proto 表达式的类型。它类似于 <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>. (我们将看到解决这一问题的几种不同方法，每一种示范了定义 Proto 前端的不同工具)。
        </p>
<pre class="programlisting"><span class="comment">// Define a lazy pow() function for the calculator DSEL.<br></span><span class="comment">// Can be used as: pow&lt; 2 &gt;(_1)<br>// 为计算器DSEL定义一个惰性的 pow() 函数。可以这样来使用：pow&lt;2&gt;(_1)<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">Exp</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">,</span> <span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span>
<span class="special">&gt;::</span><span class="identifier">type const</span>
<span class="identifier">pow</span><span class="special">(</span><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">arg</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
            <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
          <span class="special">,</span> <span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="identifier">result</span> <span class="special">=</span> <span class="special">{{{}},</span> <span class="identifier">arg</span><span class="special">};</span>
    <span class="keyword">return</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          In the code above, notice how the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>
          metafunctions are used to calculate the return type: <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> returns an expression template representing
          a function call where the first child is the function to call and the second
          is the argument to the function. (Unfortunately, the same type calculation
          is repeated in the body of the function so that we can initialize a local
          variable of the correct type. We'll see in a moment how to avoid that.)<br>在以上代码中，留意 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> 和 <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>
          元函数是如何用于计算返回类型的：<code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 返回一个表示函数调用的表达式模板，其第一个子节点为要调用的函数，第二个为该函数的参数。(不幸的是，在函数体中，为了可以初始化一个正确类型的局部变量，我们重复了相同的类型计算。待会我们将看到如何避免这一点)。
        </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
            As with <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>,
            there are metafunctions corresponding to all of the overloadable C++
            operators for calculation expression types.</p><p>跟&nbsp;<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> 相似，对于所有可重载的C++操作符，都有相应的元函数用于计算得到表达式的类型。
          </p></td></tr>
</tbody></table></div>
<p>
          With the above definition of the <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> function, we can create calculator expressions
          like the one below and evaluate them using the <code class="computeroutput"><span class="identifier">calculator_context</span></code>
          we implemented in the Introduction.<br>有了以上的 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 函数定义，我们就可以象下面那样创建计算器表达式，并使用我们在"简介"中实现的 <code class="computeroutput"><span class="identifier">calculator_context</span></code> 来进行求值。
        </p>
<pre class="programlisting"><span class="comment">// Initialize a calculator context 初始化一个计算器上下文<br></span><span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">3</span><span class="special">);</span> <span class="comment">// let _1 be 3<br></span>
<span class="comment">// Create a calculator expression that takes one argument,<br></span><span class="comment">// adds one to it, and raises it to the 2nd power; and then<br></span><span class="comment">// immediately evaluate it using the calculator_context.<br>// 创建一个带一个参数的计算器表达式，将参数加一，再求平方；然后马上使用<br>// calculator_context 对它进行求值。<br></span><span class="identifier">assert</span><span class="special">(</span> <span class="number">16</span> <span class="special">==</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="identifier">pow</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;(</span> <span class="identifier">_1</span> <span class="special">+</span> <span class="number">1</span> <span class="special">),</span> <span class="identifier">ctx</span> <span class="special">)</span> <span class="special">);</span>
</pre>
<a name="boost_proto.users_guide.front_end.making_lazy_functions.protofying_lazy_function_arguments"></a><h6>
<a name="id3482159"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions.protofying_lazy_function_arguments">Protofying
          Lazy Function Arguments 将惰性函数的参数Proto化</a>
        </h6>
<p>
          Above, we defined a <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> function template that returns an expression
          template representing a lazy function invocation. But if we tried to call
          it as below, we'll run into a problem.<br>前面，我们定义了一个 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 函数模板，它返回一个表达式模板，以表示一个惰性函数的调用。但是，如果我们试着按以下方式调用它，就是遇到问题。
        </p>
<pre class="programlisting"><span class="comment">// ERROR: pow() as defined above doesn't work when<br></span><span class="comment">// called with a non-Proto argument.<br>// 错误：前面所定义的pow()在使用非Proto化的参数时不能工作<br></span><span class="identifier">pow</span><span class="special">&lt;</span> <span class="number">2</span> <span class="special">&gt;(</span> <span class="number">4</span> <span class="special">);</span>
</pre>
<p>
          Proto expressions can only have other Proto expressions as children. But
          if we look at <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>'s
          function signature, we can see that if we pass it a non-Proto object, it
          will try to make it a child.<br>Proto 表达式只能以其它 Proto 表达式作为子节点。但如果我们看一下 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 的函数签名，我们可以看到，如果我们传给它一个非Proto化的对象，它会尝试把它当成子节点。
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">Exp</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">,</span> <span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="comment">// &lt;=== ERROR! This may not be a Proto type! 错误！这可能不是一个Proto类型！<br></span><span class="special">&gt;::</span><span class="identifier">type const</span>
<span class="identifier">pow</span><span class="special">(</span><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">arg</span><span class="special">)</span>
</pre>
<p>
          What we want is a way to make <code class="computeroutput"><span class="identifier">Arg</span></code>
          into a Proto terminal if it is not a Proto expression already, and leave
          it alone if it is. For that, we can use <code class="computeroutput"><a class="link" href="../boost/proto/as_child_id3262302.html" title="Function as_child">proto::as_child()</a></code>.
          The following implementation of the <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> function handles all argument types,
          expression templates or otherwise.<br>我们想要的就是，当 <code class="computeroutput"><span class="identifier">Arg</span></code>
          不是一个 Proto 表达式时，把它放入一个 Proto 终结符中，而如果它已经是一个 Proto 表达式则保留它。为此，我们可以使用 <code class="computeroutput"><a class="link" href="../boost/proto/as_child_id3262302.html" title="Function as_child">proto::as_child()</a></code>。以下的 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 函数实现可以处理所有参数类型，包括表达式模板或其它类型。
        </p>
<pre class="programlisting"><span class="comment">// Define a lazy pow() function for the calculator DSEL. Use<br></span><span class="comment">// proto::as_child() to Protofy the argument, but only if it<br></span><span class="comment">// is not a Proto expression type to begin with!<br>// 为计算器DSEL定义一个惰性pow()函数。用proto::as_child()来对参数<br>// 进行Proto化，仅当参数不是Proto表达式类型时才进行！<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">Exp</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;</span><span class="identifier">Arg</span> <span class="keyword">const</span><span class="special">&gt;::</span><span class="identifier">type</span>
<span class="special">&gt;::</span><span class="identifier">type const</span>
<span class="identifier">pow</span><span class="special">(</span><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">arg</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
            <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
          <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;</span><span class="identifier">Arg</span> <span class="keyword">const</span><span class="special">&gt;::</span><span class="identifier">type</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="identifier">result</span> <span class="special">=</span> <span class="special">{{{}},</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">(</span><span class="identifier">arg</span><span class="special">)};</span>
    <span class="keyword">return</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          Notice how we use the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;&gt;</span></code> metafunction to calculate the return
          type, and the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">()</span></code>
          function to actually normalize the argument.<br>留意一下我们是如何使用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;&gt;</span></code> 元函数来计算返回类型的，以及如何用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">()</span></code>
          函数来实际地规范参数。
        </p>
<a name="boost_proto.users_guide.front_end.making_lazy_functions.lazy_functions_made_simple_with__literal_make_expr____literal_"></a><h6>

          <a name="id3483058"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions.lazy_functions_made_simple_with__literal_make_expr____literal_">Lazy
          Functions Made Simple With <code class="literal">make_expr()</code>&nbsp; 用&nbsp;<code class="literal">make_expr()</code>&nbsp;简化惰性函数<code class="literal"></code></a></h6>
<p>
          The versions of the <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> function we've seen above are rather
          verbose. In the return type calculation, you have to be very explicit about
          wrapping non-Proto types. Worse, you have to restate the return type calculation
          in the body of <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>
          itself. Proto provides a helper for building expression templates directly
          that handles these mundane details for you. It's called <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code>.
          We can redefine <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>
          with it as below.<br>上面我们看到的这个版本的 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> 函数真的很冗长。在计算返回类型时，你必须非常明确地包装非Proto类型。更糟的是，你必须在 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>
          的函数体中再计算一次这个返回类型。Proto 提供了一个辅助工具直接构建表达式模板，代你处理这些麻烦的细节。这个工具名为 <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code>。我们可以如下重新定义 <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>。&nbsp;
        </p>
<pre class="programlisting"><span class="comment">// Define a lazy pow() function for the calculator DSEL.<br></span><span class="comment">// Can be used as: pow&lt; 2 &gt;(_1)<br>// 为计算器DSEL定义一个惰性pow()函数。可以这样使用它：pow&lt;2&gt;(_1)<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">Exp</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span>  <span class="comment">// Tag type 标签类型<br></span>  <span class="special">,</span> <span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span>          <span class="comment">// First child (by value) 第一个子节点(传值)<br></span>  <span class="special">,</span> <span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span>           <span class="comment">// Second child (by reference) 第二个子节点(传引用)<br></span><span class="special">&gt;::</span><span class="identifier">type const</span>
<span class="identifier">pow</span><span class="special">(</span><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">arg</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span><span class="special">&gt;(</span>
        <span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;()</span>    <span class="comment">// First child (by value)</span><span class="comment"> 第一个子节点(传值)</span><span class="comment"> <br></span>      <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">arg</span><span class="special">)</span>   <span class="comment">// Second child (by reference)</span><span class="comment"> 第二个子节点(传引用)</span><span class="comment"> <br></span>    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          There are some things to notice about the above code. We use <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;&gt;</span></code>
          to calculate the return type. The first template parameter is the tag type
          for the expression node we're building -- in this case, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span></code>,
          which is the tag type Proto uses for function call expressions.<br>以上代码中有一些地方要注意。我们使用了 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;&gt;</span></code>
          来计算返回的类型。第一个模板参数是我们要构建的表达式节点的标签类型 -- 在这个例子中是 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span></code>，它是 Proto 中用于函数调用表达式的标签类型。
        </p>
<p>
          Subsequent template parameters to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;&gt;</span></code> represent children nodes. If a
          child type is not already a Proto expression, it is made into a terminal
          with <code class="computeroutput"><a class="link" href="../boost/proto/as_child_id3262302.html" title="Function as_child">proto::as_child()</a></code>. A type such as <code class="computeroutput"><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span></code>
          results in terminal that is held by value, whereas a type like <code class="computeroutput"><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span></code> (note the reference) indicates that
          the result should be held by reference.<br><code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;&gt;</span></code> 接下来的模板参数代表两个子节点。如果某个子节点类型不是 Proto 表达式，那么就用 <code class="computeroutput"><a class="link" href="../boost/proto/as_child_id3262302.html" title="Function as_child">proto::as_child()</a></code> 将它放入一个终结符中。象 <code class="computeroutput"><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span></code>
          这样的类型在终结符中会以值的方式保存，而象 <code class="computeroutput"><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span></code> (注意这个引用)这样的类型则表示其结果以引用的方式保存。
        </p>
<p>
          In the function body is the runtime invocation of <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code>.
          It closely mirrors the return type calculation. <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code>
          requires you to specify the node's tag type as a template parameter. The
          arguments to the function become the node's children. When a child should
          be stored by value, nothing special needs to be done. When a child should
          be stored by reference, you must use the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> function to wrap the argument. Without
          this extra information, the <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code>
          function couldn't know whether to store a child by value or by reference.<br>在函数体中，是 <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code> 的运行期调用。它与返回类型的计算几乎一样。<code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code>
          要求你将节点的标签类型指定为一个模板参数。传递给函数的参数变为节点的子节点。当一个子节点要以值的方式保存时，不需要做特殊处理。当一个子节点要以引用的方式保存时，你必须用 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> 函数来包装这个参数。如果没有这些额外的信息，<code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code> 函数就不可能知道要以值的方式还是引用的方式来保存子节点。
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.adding_members_by_extending_expressions"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions" title="Adding Members by Extending Expressions">Adding
        Members by Extending Expressions 通过扩展表达式增加成员</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.domains">Domains 领域</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.extends">
          The <code class="literal">extends&lt;&gt;</code> Expression Wrapper&nbsp;</a></span><a href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.extends"><span class="section"></span></a><a href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.extends">&nbsp; <code class="literal">extends&lt;&gt;</code>表达式包装器</a></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.expression_generators">Expression
          Generators 表达式生成器</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.inhibiting_overloads">
          Controlling Operator Overloads 控制操作符重载</a></span></dt>
</dl></div>
<p>
          In this section, we'll see how to associate Proto expressions with a <span class="emphasis"><em>domain</em></span>,
          how to add members to expressions within a domain, and how to control which
          operators are overloaded in a domain.<br>在这一节中，我们将看到如何把 Proto 表达式与一个<span class="emphasis"><em>领域</em></span>关联起来，如果往领域内的表达式增加成员，以及如何一个领域中哪些操作符被重载。
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.adding_members_by_extending_expressions.domains"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.domains" title="Domains">Domains 领域</a>
</h5></div></div></div>
<p>
            In the <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
            Calculator</a> section, we looked into making calculator expressions
            directly usable as lambda expressions in calls to STL algorithms, as
            below:<br>在 <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
            Calculator</a> 一节中，我们已经看到可以在调用STL算法时直接创建计算器表达式并象 lambda 表达式那样使用它，如下：
          </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">data</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">1.</span><span class="special">,</span> <span class="number">2.</span><span class="special">,</span> <span class="number">3.</span><span class="special">,</span> <span class="number">4.</span><span class="special">};</span>

<span class="comment">// Use the calculator DSEL to square each element ... HOW?<br>// 使用计算器DSEL对每个元素计算平方 ... 如何？<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">data</span> <span class="special">+</span> <span class="number">4</span><span class="special">,</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_1</span> <span class="special">);</span>
</pre>
<p>
            The difficulty, if you recall, was that by default Proto expressions
            don't have interesting behaviors of their own. They're just trees. In
            particular, the expression <code class="computeroutput"><span class="identifier">_1</span>
            <span class="special">*</span> <span class="identifier">_1</span></code>
            won't have an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            that takes a double and returns a double like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">()</span></code> expects -- unless we give it one. To
            make this work, we needed to define an expression wrapper type that defined
            the <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            member function, and we needed to associate the wrapper with the calculator
            <span class="emphasis"><em>domain</em></span>.<br>如果你还记得，难点在于缺省情况下 Proto 表达式并不关心它们自己的行为。它们仅仅是一些树。具体地说，表达式 <code class="computeroutput"><span class="identifier">_1</span>
            <span class="special">*</span> <span class="identifier">_1</span></code>
            并不象 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">()</span></code> 所期望那样带有一个 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            来接受一个 double 并返回<code class="computeroutput"><span class="special"></span></code>一个 double -- 除非我们给它一个。要让它能用，我们必须定义一个表达式包装器类型，其中定义了 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            成员函数，然后我们必须把这个包装器关联到这个计算器<span class="emphasis"><em>领域</em></span>。
          </p>
<p>
            In Proto, the term <span class="emphasis"><em>domain</em></span> refers to a type that
            associates expressions in that domain to an expression <span class="emphasis"><em>generator</em></span>.
            The generator is just a function object that accepts an expression and
            does something to it, like wrapping it in an expression wrapper.<br>在 Proto 中，术语 <span class="emphasis"><em>领域domain</em></span> 是指一个类型，用于把该领域中的表达式关联至一个表达式<span class="emphasis"><em>生成器</em></span>。这个生成器是一个函数对象，它接受一个表达式并对它做一些事情，如把表达式包入一个表达式包装器。
          </p>
<p>
            You can also use a domain to associate expressions with a grammar. When
            you specify a domain's grammar, Proto ensures that all the expressions
            it generates in that domain conform to the domain's grammar. It does
            that by disabling any operator overloads that would create invalid expressions.<br>你也可以用一个领域来将表达式与某种语法关联起来。当你指定一个领域语法，Proto 将确保它在此领域中生成的表达式都符合该领域的语法。它是通过禁止掉一些可能创建无效表达式的操作符重载来实现这一点的。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.adding_members_by_extending_expressions.extends"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.extends" title="The extends&lt;&gt; Expression Wrapper">
          The <code class="literal">extends&lt;&gt;</code> Expression Wrapper&nbsp; <code class="literal">extends&lt;&gt;</code>表达式包装器</a></h5></div></div></div>
<p>
            The first step to giving your calculator expressions extra behaviors
            is to define a calculator domain. All expressions within the calculator
            domain will be imbued with calculator-ness, as we'll see.<br>要给你的计算器表达式赋予额外的行为，第一步是定义一个计算器域。在这个计算器域中的所有表达式都将被注入计算器的特征，如后所见。
          </p>
<pre class="programlisting"><span class="comment">// A type to be used as a domain tag (to be defined below)<br>// 一个被用作为领域标签的类型(稍后定义)<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span><span class="special">;</span>
</pre>
<p>
            We use this domain type when extending the <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
            type, which we do with the <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            class template. Here is our expression wrapper, which imbues an expression
            with calculator-ness. It is described below.<br>当我们用 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
 类模板扩展 <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
            类型时，将会使用这个领域类型。。以下是我们的表达式包装器，它向一个表达式注入计算器特征。说明如下。
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions<br></span><span class="comment">// function objects.<br>// calculator&lt;&gt; 表达式包装器把表达式变为函数对象。<br></span><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">Expr</span> <span class="special">&gt;,</span> <span class="identifier">calculator_domain</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">Expr</span> <span class="special">&gt;,</span> <span class="identifier">calculator_domain</span> <span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">calculator</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">()</span> <span class="special">)</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span> <span class="identifier">expr</span> <span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// This is usually needed because by default, the compiler-<br></span>    <span class="comment">// generated assignment operator hides extends&lt;&gt;::operator=<br>    // 缺省情况下通常都需要这个，因为编译器生成的赋值操作符会隐藏</span><span class="comment"> extends&lt;&gt;::operator=</span><span class="comment"> <br></span>    <span class="keyword">using</span> <span class="identifier">base_type</span><span class="special">::</span><span class="keyword">operator</span> <span class="special">=;</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Hide base_type::operator() by defining our own which<br></span>    <span class="comment">// evaluates the calculator expression with a calculator context.<br>    // 定义我们自己的 operator() 来隐藏 base_type::operator()，用一个计算器上下文来对计算器表达式求值。<br></span>    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// As defined in the Hello Calculator section.<br>        // 和 Hello Calculator 一节中的定义一样。<br></span>        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>

        <span class="comment">// ctx.args is a vector&lt;double&gt; that holds the values<br></span>        <span class="comment">// with which we replace the placeholders (e.g., _1 and _2)<br></span>        <span class="comment">// in the expression.<br>        // ctx.args 是一个 vector&lt;double&gt;，保存了我们用于替换表达式中的占位符(如 _1 和 _2)的值。<br></span>        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">d1</span> <span class="special">);</span> <span class="comment">// _1 gets the value of d1  _1获得d1的值<br></span>        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">d2</span> <span class="special">);</span> <span class="comment">// _2 gets the value of d2  _2获得d2的值<br></span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span> <span class="special">);</span> <span class="comment">// evaluate the expression 对表达式求值<br></span>    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            We want calculator expressions to be function objects, so we have to
            define an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            that takes and returns doubles. The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper above does that with
            the help of the <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            template. The first template to <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            parameter is the expression type we are extending. The second is the
            type of the wrapped expression. The third parameter is the domain that
            this wrapper is associated with. A wrapper type like <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> that inherits from <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code> behaves just like
            the expression type it has extended, with any additional behaviors you
            choose to give it.<br>我们希望计算器表达式是一个函数对象，因此我们必须定义一个 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            来接受和返回 doubles。上面这个 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 包装器在 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            模板的帮助下完成此事。传给 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            的第一个模板参数是我们要扩展的表达式类型。第二个是被包装表达式的类型。第三个参数是该包装器所关联的领域。象 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 这样的派生自 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code> 的包装器类型，其行为是与其所扩展的表达式类型一样，再加上你选择给予它的其它行为。</p>
<div class="note" title="Note">
<table summary="Note" border="0">
<tbody>
<tr>
<td rowspan="2" align="middle" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th></tr>
<tr>
<td align="left" valign="top">
<p><span class="bold"><strong>Why not just inherit from <code class="literal">proto::expr&lt;&gt;</code>?</strong></span><span class="bold"><strong> 为什么不仅仅从 <code class="literal">proto::expr&lt;&gt;</code> 继承?</strong></span> </p>
<p>You might be thinking that this expression extension business is 
unnecessarily complicated. After all, isn't this why C++ supports inheritance? 
Why can't <code class="literal">calculator&lt;Expr&gt;</code> just inherit from 
<code class="literal">Expr</code> directly? The reason is because <code class="literal">Expr</code>, which presumably is an instantiation of <code class="computeroutput"><a class="link" title="Struct template expr" href="../boost/proto/expr.html">proto::expr&lt;&gt;</a></code>, has expression 
template-building operator overloads that will be incorrect for derived types. 
They will store <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by reference to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code>, effectively slicing off any derived parts. 
<code class="computeroutput"><a class="link" title="Struct template extends" href="../boost/proto/extends.html">proto::extends&lt;&gt;</a></code> gives your 
derived types operator overloads that don't slice off your additional members.<br>你也许会认为这个表达式扩展有点不必要地复杂化了。毕竟，这难道不是C++要支持继承的的原因吗？为什么 <code class="literal">calculator&lt;Expr&gt;</code> 不能仅仅直接从 
<code class="literal">Expr</code> 派生？原因是，因为 <code class="literal">Expr</code> 是 <code class="computeroutput"><a class="link" title="Struct template expr" href="../boost/proto/expr.html">proto::expr&lt;&gt;</a></code> 的一个实例，它具有表达式模板构建的操作符重载，这对于派生类型是不正确的。它们会以引用方式保存 <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>，指向 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code>，有效地切割掉派生类的其它部分。<code class="computeroutput"><a class="link" title="Struct template extends" href="../boost/proto/extends.html">proto::extends&lt;&gt;</a></code> 为你的派生类给出了不会切割掉其它成员的操作符重载。 
</p></td></tr></tbody></table></div>
<p>
            Although not strictly necessary in this case, we bring <code class="computeroutput"><span class="identifier">extends</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code>
            into scope with a <code class="computeroutput"><span class="keyword">using</span></code>
            declaration. This is really only necessary if you want expressions like
            <code class="computeroutput"><span class="identifier">_1</span> <span class="special">=</span>
            <span class="number">3</span></code> to create a lazily evaluated
            assignment. <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code> defines the appropriate
            <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>
            for you, but the compiler-generated <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code> will hide it unless you make it available
            with the <code class="computeroutput"><span class="keyword">using</span></code> declaration.<br>虽然在这里不是严格必需，但是我们还是用一个 <code class="computeroutput"><span class="keyword">using</span></code> 声明将 <code class="computeroutput"><span class="identifier">extends</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code>
            带入此作用域。实际上，只有当你想要象
            <code class="computeroutput"><span class="identifier">_1</span> <span class="special">=</span>
            <span class="number">3</span></code> 这样的表达式可以创建一个惰性求值的赋值操作时，才需要这样做。虽然 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code> 为你定义了适当的
            <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>，但是编译器所生成的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code> 会隐藏它，除非你用 <code class="computeroutput"><span class="keyword">using</span></code> 声明来使之可见。
          </p>
<p>
            Note that in the implementation of <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">()</span></code>, we evaluate the expression with the
            <code class="computeroutput"><span class="identifier">calculator_context</span></code> we
            defined earlier. As we saw before, the context is what gives the operators
            their meaning. In the case of the calculator, the context is also what
            defines the meaning of the placeholder terminals.<br>注意，在 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">()</span></code> 的实现中，我们用早先定义的
            <code class="computeroutput"><span class="identifier">calculator_context</span></code> 来对表达式进行求值。如前所述，上下文是给表达式赋予某种意义的。在这个计算器的例子中，上下文定义了占位符终结符的意义。
          </p>
<p>
            Now that we have defined the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> expression wrapper, we need to
            wrap the placeholders to imbue them with calculator-ness:<br>现在我们已经定义了 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 表达式包装器，我们需要对占位符进行包装，为它们注入计算器特征：
          </p>
<pre class="programlisting"><span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>
</pre>
<a name="boost_proto.users_guide.front_end.adding_members_by_extending_expressions.extends.retaining_pod_ness_with__literal_boost_proto_extends____literal_"></a><h6>

            <a name="id3485247"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.extends.retaining_pod_ness_with__literal_boost_proto_extends____literal_">Retaining
            POD-ness with <code class="literal">BOOST_PROTO_EXTENDS()</code> 用&nbsp;<code class="literal">BOOST_PROTO_EXTENDS()</code>&nbsp;保留POD性质<code class="literal"></code></a></h6>

<p>
            To use <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>, your extension type
            must derive from <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>.
            Unfortunately, that means that your extension type is no longer POD and
            its instances cannot be <span class="emphasis"><em>statically initialized</em></span>.
            (See the <a class="link" href="appendices.html#boost_proto.appendices.rationale.static_initialization" title="Static Initialization">Static
            Initialization</a> section in the <a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix B: Rationale">Rationale</a>
            appendix for why this matters.) In particular, as defined above, the
            global placeholder objects <code class="computeroutput"><span class="identifier">_1</span></code>
            and <code class="computeroutput"><span class="identifier">_2</span></code> will need to be
            initialized at runtime, which could lead to subtle order of initialization
            bugs.<br>要使用 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>，你的扩展类型必须派生自 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>。不幸的是，这意味着你的扩展类型不再是POD，且其实例不能被<span class="emphasis"><em>静态初始化</em></span>。(为什么会这样，请见附录&nbsp;<a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix B: Rationale">原理</a> 中 <a class="link" href="appendices.html#boost_proto.appendices.rationale.static_initialization" title="Static Initialization">静态初始化</a> 一节<a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix B: Rationale"></a>)。具体地说，按以上定义，全局占位符 <code class="computeroutput"><span class="identifier">_1</span></code> 和 <code class="computeroutput"><span class="identifier">_2</span></code> 必须在运行期初始化，这有可能导致微妙的初始化顺序问题。
          </p>
<p>
            There is another way to make an expression extension that doesn't sacrifice
            POD-ness : the <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code> macro. You can use it much like you
            use <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>. We can use <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code>
            to keep <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
            a POD and our placeholders statically initialized.<br>有另一个方法可以让表达式扩展无需牺牲POD特性：宏 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code>。你可以象使用 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code> 那样使用它。我们可以用 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code>
            来使 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 保持为一个 POD 且我们的占位符可以被静态初始化。
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions<br></span><span class="comment">// function objects.<br>// calculator&lt;&gt; 表达式包装器把表达式变为函数对象。<br></span><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
<span class="special">{</span>
    <span class="comment">// Use BOOST_PROTO_EXTENDS() instead of proto::extends&lt;&gt; to<br></span>    <span class="comment">// make this type a Proto expression extension.<br>    // 使用 BOOST_PROTO_EXTENDS() 代替 proto::extends&lt;&gt; 来让这个类型成为Proto表达式扩展。<br></span>    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">)</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">/* ... as before 如前 ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            With the new <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type, we can redefine our placeholders
            to be statically initialized:<br>用这个新的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 类型，我们可以重新定义我们的占位符，并进行静态初始化：
          </p>
<pre class="programlisting"><span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{{}}};</span>
<span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{{}}};</span>
</pre>
<p>
            We need to make one additional small change to accommodate the POD-ness
            of our expression extension, which we'll describe below in the section
            on expression generators.<br>我们还需要一个小的修改来提供我们的表达式扩展的POD性，我们将在本节稍后的表达生成器中描述这一点。
          </p>
<p>
            What does <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code> do? It defines a data member of expression
            type being extended; some nested typedefs that Proto requires; <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>,
            <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>
            and <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            overloads for building expression templates; and a nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            template for calculating the return type of <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>. In this case, however, the <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            overloads and the <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> template are not needed because
            we are defining our own <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> in the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type. Proto provides additional
            macros for finer control over which member functions are defined. We
            could improve our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type as follows:<br><code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code> 究竟做了些什么呢？它定义了一个要扩展的表达式类型的数据成员；一些 Proto 所需的嵌套 typedef；重载 <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>,
            <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code> 和 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 以构建表达式模板；以及一个嵌套的 <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> 模板用于计算 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 的返回类型。不过在这个例子中，并不需要 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            重载和 <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> 模板，因为我们在 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 类型中定义了我们自己的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>。<code class="computeroutput"><span class="special"></span></code>Proto 提供了其它的宏，以便更好地控制哪些成员函数要定义。我们可以如下改进我们的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 类型：
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions<br></span><span class="comment">// function objects.<br>// calculator&lt;&gt; 表达式包装器把表达式变为函数对象。<br></span><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
<span class="special">{</span>
    <span class="comment">// Use BOOST_PROTO_BASIC_EXTENDS() instead of proto::extends&lt;&gt; to<br></span>    <span class="comment">// make this type a Proto expression extension:</span><br><span class="comment">    // 使用 BOOST_PROTO_EXTENDS() 代替 proto::extends&lt;&gt; 来让这个类型成为Proto表达式扩展。<br></span>   &nbsp;<span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">)</span>

    <span class="comment">// Define operator[] to build expression templates:<br>    // 定义 operator[] 来构建表达式模板：<br></span>    <span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span>

    <span class="comment">// Define operator= to build expression templates:<br>    // 定义 operator= 来构建表达式模板：<br></span>    <span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">/* ... as before 如前 ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Notice that we are now using <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code> instead of <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code>. This just adds the data member and
            the nested typedefs but not any of the overloaded operators. Those are
            added separately with <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span></code>. We are leaving out the function call
            operator and the nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> template that could have been
            defined with Proto's <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_FUNCTION</span><span class="special">()</span></code> macro.<br>注意，现在我们用 <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code> 来替代 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code>。它只增加数据成员和嵌套 typedefs 而不重载任何操作符。操作符是通过 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span></code> 和 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span></code> 单独添加的。我们省去了函数调用操作符和嵌套的 <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> 模板，它们可以用 Proto 的 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_FUNCTION</span><span class="special">()</span></code> 宏来定义。
          </p>
<p>
            In summary, here are the macros you can use to define expression extensions,
            and a brief description of each.<br>总之，以下是你可以用来定义表达式扩展的宏，以及各个宏的简要说明。
          </p>
<div class="table">
<a name="id3486397"></a><p class="title"><b>Table&nbsp;15.2.&nbsp;Expression Extension Macros<br>表 15.2. 表达式扩展宏</b></p>
<div class="table-contents"><table class="table" summary="Expression Extension Macros">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  Macro 宏
                </p>
                </th>
<th>
                <p>
                  Purpose 用途
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  
</p>
<pre class="programlisting"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">(</span>
    <em class="replaceable"><code>expression</code></em>
  <span class="special">,</span> <em class="replaceable"><code>extension</code></em>
  <span class="special">,</span> <em class="replaceable"><code>domain</code></em>
<span class="special">)</span></pre>
<p>
                </p>
                </td>
<td>
                <p>
                  Defines a data member of type <code class="computeroutput">
                  <em class="replaceable"><code>
                    expression
                  </code></em>
                  </code> and some nested typedefs that Proto requires.<br>定义一个类型为 <code class="computeroutput">
                  <em class="replaceable"><code>
                    expression
                  </code></em>
                  </code> 的数据成员以及 Proto 所需的一些嵌套 typedefs。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span></code>
                </p>
                </td>
<td>
                <p>
                  Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>.
                  Only valid when preceded by <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code>.<br>定义 <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>。仅当在 <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code> 之后有效。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span></code>
                </p>
                </td>
<td>
                <p>
                  Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>.
                  Only valid when preceded by <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code>.<br>定义 <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>。仅当在 <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code> 之后有效。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_FUNCTION</span><span class="special">()</span></code>
                </p>
                </td>
<td>
                <p>
                  Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
                  and a nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> template for return type
                  calculation. Only valid when preceded by <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code>.<br>定义 <code class="computeroutput"><span class="keyword">operator()</span><span class="special"></span></code> 和嵌套的 <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> 模板用于返回类型计算。仅当在 <code class="computeroutput"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">()</span></code> 之后有效。
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  
</p>
<pre class="programlisting"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span>
    <em class="replaceable"><code>expression</code></em>
  <span class="special">,</span> <em class="replaceable"><code>extension</code></em>
  <span class="special">,</span> <em class="replaceable"><code>domain</code></em>
<span class="special">)</span></pre>
<p>
                </p>
                </td>
<td>
                <p>
                  Equivalent to:<br>相当于：
</p>
<pre class="programlisting"><span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">(</span><em class="replaceable"><code>expression</code></em><span class="special">,</span> <em class="replaceable"><code>extension</code></em><span class="special">,</span> <em class="replaceable"><code>domain</code></em><span class="special">)</span>
<span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span>
<span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span>
<span class="identifier">BOOST_PROTO_EXTENDS_FUNCTION</span><span class="special">()</span></pre>
<p>
                </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.adding_members_by_extending_expressions.expression_generators"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.expression_generators" title="Expression Generators">Expression
          Generators 表达式生成器</a>
</h5></div></div></div>
<p>
            The last thing that remains to be done is to tell Proto that it needs
            to wrap all of our calculator expressions in our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper. We have already wrapped
            the placeholders, but we want <span class="emphasis"><em>all</em></span> expressions that
            involve the calculator placeholders to be calculators. We can do that
            by specifying an expression generator when we define our <code class="computeroutput"><span class="identifier">calculator_domain</span></code>, as follows:<br>最后剩下要做的一件事就是，告知 Proto 它必须将我们所有的计算器表达式包入 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 包装器。我们已经包装了占位符，但是我们想要包含了这个计算器占位符的<span class="emphasis"><em>所有</em></span>表达式都是计算器。我们可以通过在定义我们的 <code class="computeroutput"><span class="identifier">calculator_domain</span></code> 时指定一个表达式生成器来实现这一点，如下：
          </p>
<pre class="programlisting"><span class="comment">// Define the calculator_domain we forward-declared above.<br></span><span class="comment">// Specify that all expression in this domain should be wrapped<br></span><span class="comment">// in the calculator&lt;&gt; expression wrapper.<br>// 定义我们先前已声明的 calculator_domain。指定该领域内的所有表达式都<br>// 要被包入 calculator&lt;&gt; 表达式包装器中。<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span> <span class="identifier">calculator</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The first template parameter to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> is the generator. "Generator"
            is just a fancy name for a function object that accepts an expression
            and does something to it. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;&gt;</span></code> is a very simple one --- it wraps
            an expression in the wrapper you specify. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> inherits from its generator parameter,
            so all domains are themselves function objects.<br>传给 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> 的第一个模板参数是生成器。"生成器Generator"
           一个函数对象的特别名字，这个函数对象接受一个表达式并对它做一些事情。<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;&gt;</span></code> 是一个非常简单的生成器 --- 它把一个表达式包入你指定的某个包装器。<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> 派生自它的生成器参数，因此所有领域本身都是函数对象。
          </p>
<p>
            If we used <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code> to keep our expression extension type
            POD, then we need to use <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;&gt;</span></code> instead of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;&gt;</span></code>, as follows:<br>如果我们使用 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code> 来让我们的表达式扩展类型保持为
            POD，则我们需要用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;&gt;</span></code> 代替 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;&gt;</span></code>，如下：
          </p>
<pre class="programlisting"><span class="comment">// If calculator&lt;&gt; uses BOOST_PROTO_EXTENDS() instead of <br></span><span class="comment">// use proto::extends&lt;&gt;, use proto::pod_generator&lt;&gt; instead<br></span><span class="comment">// of proto::generator&lt;&gt;.<br>// 如果 calculator&lt;&gt; 使用 BOOST_PROTO_EXTENDS() 代替 proto::extends()，<br>// 则使用 proto::pod_generator&lt;&gt; 代替 proto::generator&lt;&gt;。<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;</span> <span class="identifier">calculator</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            After Proto has calculated a new expression type, it checks the domains
            of the child expressions. They must match. Assuming they do, Proto creates
            the new expression and passes it to <code class="computeroutput">
            <em class="replaceable"><code>
              Domain
            </code></em>
            <span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> for any additional processing. If we
            don't specify a generator, the new expression gets passed through unchanged.
            But since we've specified a generator above, <code class="computeroutput"><span class="identifier">calculator_domain</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> returns <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> objects.<br>在 Proto 计算出一个新的表达式类型后，它要检查其子表达式的领域。它们必须相互匹配。如果确实如此，则 Proto 创建新的表达式并将它传递给 <code class="computeroutput">
            <em class="replaceable"><code>
              Domain
            </code></em>
            <span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> 进行其它处理。如果我们不指定生成器，则新的表达式将被原样传递。不过由于我们指定了上面的生成器，所以 <code class="computeroutput"><span class="identifier">calculator_domain</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> 将返回 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 对象。
          </p>
<p>
            Now we can use calculator expressions as function objects to STL algorithms,
            as follows:<br>现在我们可以把计算器表达式作为函数对象用于STL算法了，如下：
          </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">data</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">1.</span><span class="special">,</span> <span class="number">2.</span><span class="special">,</span> <span class="number">3.</span><span class="special">,</span> <span class="number">4.</span><span class="special">};</span>

<span class="comment">// Use the calculator DSEL to square each element ... WORKS! :-)<br>// 使用计算器DSEL将每个元素求平方 ... 可用！:-)<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">data</span> <span class="special">+</span> <span class="number">4</span><span class="special">,</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_1</span> <span class="special">);</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.adding_members_by_extending_expressions.inhibiting_overloads"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.adding_members_by_extending_expressions.inhibiting_overloads" title="Controlling Operator Overloads">
          Controlling Operator Overloads 控制操作符重载</a>
</h5></div></div></div>
<p>
            By default, Proto defines every possible operator overload for Protofied
            expressions. This makes it simple to bang together a DSEL. In some cases,
            however, the presence of Proto's promiscuous overloads can lead to confusion
            or worse. When that happens, you'll have to disable some of Proto's overloaded
            operators. That is done by defining the grammar for your domain and specifying
            it as the second parameter of the <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>
            template.<br>缺
省情况下，Proto 为Proto化的表达式定义了每一个可能的操作符重载。这样可以简化 bang together a
DSEL。但是，在某些情况下，Proto 的混杂重载可能导致混乱或更糟的结果。这时，你必须禁止 Proto
重载某些操作符。实现的方法是，为你的领域定义语法并将该语法指定为 <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code> 模板的第二个参数。
          </p>
<p>
            In the <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
            Calculator</a> section, we saw an example of a Proto grammar, which
            is repeated here:<br>在 <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
            Calculator</a> 一节中，我们已看过一个 Proto 语法的例子，重复如下：
          </p>
<pre class="programlisting"><span class="comment">// Define the grammar of calculator expressions<br>// 定义计算器表达式的语法<br></span><span class="keyword">struct</span> <span class="identifier">calculator_grammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            We'll have much more to say about grammars in subsequent sections, but
            for now, we'll just say that the <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
            struct describes a subset of all expression types -- the subset that
            comprise valid calculator expressions. We would like to prohibit Proto
            from creating a calculator expression that does not conform to this grammar.
            We do that by changing the definition of the <code class="computeroutput"><span class="identifier">calculator_domain</span></code>
            struct.<br>在后续章节中，我们将会讲述关于语法的更多内容，不过现在，我们只讲一下 <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
            结构，它描述了所有表达式类型的一个子集 -- 这个子集组成了有效的计算器表达式。我们要禁止 Proto
            创建一个不符合该语法的计算器表达式。我们通过修改 <code class="computeroutput"><span class="identifier">calculator_domain</span></code> 结构的定义来实现这一点。
          </p>
<pre class="programlisting"><span class="comment">// Define the calculator_domain. Expressions in the calculator<br></span><span class="comment">// domain are wrapped in the calculator&lt;&gt; wrapper, and they must<br></span><span class="comment">// conform to the calculator_grammar:<br>// 定义 calculator_domain。计算器领域中的表达式要被包入 calculator&lt;&gt; 包装器，<br>// 且必须符合 calculator_grammar：<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span> <span class="identifier">calculator</span> <span class="special">&gt;,</span> <span class="bold"><strong>calculator_grammar</strong></span>  <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The only new addition is <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
            as the second template parameter to the <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>
            template. That has the effect of disabling any of Proto's operator overloads
            that would create an invalid calculator expression.<br>新增的部分是把 <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
            作为第二个模板参数传给 <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>
            模板。其结果是禁止任何会创建无效计算器表达式的 Proto 操作符重载。
          </p>
<p>
            Another common use for this feature would be to disable Proto's unary
            <code class="computeroutput"><span class="keyword">operator</span><span class="special">&amp;</span></code>
            overload. It may be surprising for users of your DSEL that they cannot
            take the address of their expressions! You can very easily disable Proto's
            unary <code class="computeroutput"><span class="keyword">operator</span><span class="special">&amp;</span></code>
            overload for your domain with a very simple grammar, as below:<br>这一特性的另外一个常见用途是，禁止 Proto 的单参数
            <code class="computeroutput"><span class="keyword">operator</span><span class="special">&amp;</span></code>
            重载。可能会令你的DSEL用户意外的是，他们不能获得他们的表达式的地址！你可以用非常简单的语法很容易地为你的领域禁止掉 Proto 的单参数 <code class="computeroutput"><span class="keyword">operator</span><span class="special">&amp;</span></code>
            重载，如下：
          </p>
<pre class="programlisting"><span class="comment">// For expressions in my_domain, disable Proto's<br></span><span class="comment">// unary address-of operator.<br>// 对于 my_domain 中的表达式，禁止 Proto 的单参数求址操作符。<br></span><span class="keyword">struct</span> <span class="identifier">my_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span> <span class="identifier">my_wrapper</span> <span class="special">&gt;</span>
        <span class="comment">// A simple grammar that matches any expression that<br></span>        <span class="comment">// is not a unary address-of expression.<br>        // 一个简单的语法，匹配所有不是单参数求址表达式的表达式。<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;</span> <span class="identifier">_</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;</span>
            <span class="identifier">_</span> <span class="special">&gt;</span>
            <span class="special">&gt;</span></code> is a very simple grammar
            that matches all expressions except unary address-of expressions. In
            the section describing Proto's intermediate form, we'll have much more
            to say about grammars.<br>类型 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;</span>
            <span class="identifier">_</span> <span class="special">&gt;</span>
            <span class="special">&gt;</span></code> 是一个非常简单的语法，它匹配除了单参数求址表达式以外的所有表达式。在讲述 Proto 中间格式的一节中，我们将讲述关于语法的更多内容。
          </p>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.intermediate_form"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form" title="Intermediate Form: Understanding and Introspecting Expressions"> Intermediate
      Form: Understanding and Introspecting Expressions 中间格式：理解和窥探表达式</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child">
        Accessing Child Nodes 访问子节点</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.tags_and_metafunctions">
        Operator Tags and Metafunctions 操作符标签和元函数</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection">
        Expression Introspection: Defining a Grammar 表达式的内部：定义一个语法</a></span></dt>
</dl></div>
<p>
        By now, you know a bit about how to build a front-end for your DSEL "compiler"
        -- you can define terminals and functions that generate expression templates.
        But we haven't said anything about the expression templates themselves. What
        do they look like? What can you do with them? In this section we'll see.<br>现在，你已经知道如何为你的DSEL"编译器"构建一个前端
        -- 你可以定义终结符和生成表达式模板的函数。不过我们还没有讲到关于表达式模板本身的东西。它们看起来是怎样的呢？你可以对它们做些什么呢？在本节中，我们将会看到这些内容。
      </p>
<a name="boost_proto.users_guide.intermediate_form.the__literal_expr_lt__gt___literal__type"></a><h5>
<a name="id3488272"></a>
        <a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.the__literal_expr_lt__gt___literal__type">The
        <code class="literal">expr&lt;&gt;</code> Type &nbsp;类型&nbsp;<code class="literal">expr&lt;&gt;</code></a></h5>
<p>
        All Proto expressions are an instantiation of a template called <code class="computeroutput"><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code>
        (or a wrapper around such an instantiation). When we define a terminal as
        below, we are really initializing an instance of the <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
        template.<br>所有 Proto 表达式都是一个名为 <code class="computeroutput"><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code>
        的模板的实例(或是包含该实例的一个包装器)。当我们如下定义一个终结符时，我们实际上是初始化了一个 <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
        模板的实例。
      </p>
<pre class="programlisting"><span class="comment">// Define a placeholder type 定义一个占位符类型<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder</span>
<span class="special">{};</span>

<span class="comment">// Define the Protofied placeholder terminal 定义Proto化的占位符终结符<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
</pre>
<p>
        The actual type of <code class="computeroutput"><span class="identifier">_1</span></code> looks
        like this:<br><code class="computeroutput"><span class="identifier">_1</span></code> 的实际类型如下：
      </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;,</span> <span class="number">0</span> <span class="special">&gt;</span>
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> template is the most
        important type in Proto. Although you will rarely need to deal with it directly,
        it's always there behind the scenes holding your expression trees together.
        In fact, <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> <span class="emphasis"><em>is</em></span>
        the expression tree -- branches, leaves and all.<br><code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> 模板是 Proto 中最重要的类型。虽然你很少要直接处理它，但是它总是在幕后把你的表达式树保持在一起。事实上，<code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> <span class="emphasis"><em>就是</em></span>表达式树 -- 分支、叶子和所有。
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> template makes up the
        nodes in expression trees. The first template parameter is the node type;
        in this case, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span></code>.
        That means that <code class="computeroutput"><span class="identifier">_1</span></code> is a leaf-node
        in the expression tree. The second template parameter is a list of child
        types, or in the case of terminals, the terminal's value type. Terminals
        will always have only one type in the type list. The last parameter is the
        arity of the expression. Terminals have arity 0, unary expressions have arity
        1, etc.<br><code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> 模板负责拼凑表达式树中的节点。第一个模板参数是节点的类型；在这个例子中是 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span></code>。这意味着 <code class="computeroutput"><span class="identifier">_1</span></code> 是表达式树中的一个叶节点。第二个模板参数是一个子节点类型的列表，或者在终结符的情况下，为终结符的值类型。在这个类型列表中，终结符永远只有一个类型。最后一个参数是表达式的arity。终结符的arity为0，单参数表达式的arity为1，等等。
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> struct is defined as
        follows:<br><code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> 结构定义如下：
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Args</span><span class="special">,</span> <span class="keyword">long</span> <span class="identifier">Arity</span> <span class="special">=</span> <span class="identifier">Args</span><span class="special">::</span><span class="identifier">arity</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">expr</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Args</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">expr</span><span class="special">&lt;</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="identifier">Args</span><span class="special">,</span> <span class="number">1</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Args</span><span class="special">::</span><span class="identifier">child0</span> <span class="identifier">proto_child0</span><span class="special">;</span>
    <span class="identifier">proto_child0</span> <span class="identifier">child0</span><span class="special">;</span>
    <span class="comment">// ...<br></span><span class="special">};</span>
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> struct does not define
        a constructor, or anything else that would prevent static initialization.
        All <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> objects are initialized
        using <span class="emphasis"><em>aggregate initialization</em></span>, with curly braces. In
        our example, <code class="computeroutput"><span class="identifier">_1</span></code> is initialized
        with the initializer <code class="computeroutput"><span class="special">{{}}</span></code>. The
        outer braces are the initializer for the <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
        struct, and the inner braces are for the member <code class="computeroutput"><span class="identifier">_1</span><span class="special">.</span><span class="identifier">child0</span></code>
        which is of type <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code>.
        Note that we use braces to initialize <code class="computeroutput"><span class="identifier">_1</span><span class="special">.</span><span class="identifier">child0</span></code>
        because <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code> is also
        an aggregate.<br><code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> 结构没有定义构造函数，或其它任何东西，以防止被静态初始化。所有 <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> 对象都使用带花括号的 <span class="emphasis"><em>聚集初始化</em></span> 来初始化。在我们的例子中，<code class="computeroutput"><span class="identifier">_1</span></code> 用初始化器 <code class="computeroutput"><span class="special">{{}}</span></code> 来初始化。外面一层花括号是用于 <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
        结构的初始化器，里面一层花括号则是用于成员 <code class="computeroutput"><span class="identifier">_1</span><span class="special">.</span><span class="identifier">child0</span></code>，其类型为 <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code>。注意，我们使用花括号来初始化 <code class="computeroutput"><span class="identifier">_1</span><span class="special">.</span><span class="identifier">child0</span></code>，因为 <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code> 也是一个聚集。
      </p>
<a name="boost_proto.users_guide.intermediate_form.building_expression_trees"></a><h5>
<a name="id3489096"></a>
        <a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.building_expression_trees">Building
        Expression Trees 构建表达式树</a>
      </h5>
<p>
        The <code class="computeroutput"><span class="identifier">_1</span></code> node is an instantiation
        of <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>, and expressions containing
        <code class="computeroutput"><span class="identifier">_1</span></code> are also instantiations
        of <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>. To use Proto effectively,
        you won't have to bother yourself with the actual types that Proto generates.
        These are details, but you're likely to encounter these types in compiler
        error messages, so it's helpful to be familiar with them. The types look
        like this:<br>节点 <code class="computeroutput"><span class="identifier">_1</span></code> 是 <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> 的一个实例，包含
        <code class="computeroutput"><span class="identifier">_1</span></code> 的表达式也是 <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> 的实例。要有效地使用 Proto，你并不必操心 Proto 生成的实际类型。
       它们只是实现细节而已，不过你很可能会在编译器的错误信息中碰到这些类型，所以，熟悉一下它们也是很有用的。这些类型就象以下这样：
      </p>
<pre class="programlisting"><span class="comment">// The type of the expression -_1 表达式 -_1 的类型<br></span><span class="keyword">typedef</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">negate</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">list1</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;</span>
              <span class="special">,</span> <span class="number">0</span>
            <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="number">1</span>
    <span class="special">&gt;</span>
<span class="identifier">negate_placeholder_type</span><span class="special">;</span>

<span class="identifier">negate_placeholder_type</span> <span class="identifier">x</span> <span class="special">=</span> <span class="special">-</span><span class="identifier">_1</span><span class="special">;</span>

<span class="comment">// The type of the expression _1 + 42 表达式 _1 + 42 的类型<br></span><span class="keyword">typedef</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">list2</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;</span>
              <span class="special">,</span> <span class="number">0</span>
            <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="special">&gt;</span>
              <span class="special">,</span> <span class="number">0</span>
            <span class="special">&gt;</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="number">2</span>
    <span class="special">&gt;</span>
<span class="identifier">placeholder_plus_int_type</span><span class="special">;</span>

<span class="identifier">placeholder_plus_int_type</span> <span class="identifier">y</span> <span class="special">=</span> <span class="identifier">_1</span> <span class="special">+</span> <span class="number">42</span><span class="special">;</span>
</pre>
<p>
        There are a few things to note about these types:<br>对于这些类型，有几点要注意：
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Terminals have arity 0, unary expressions have arity 1 and binary expressions
          have arity 2.<br>终结符的arity为0，单参数表达式的arity为1，二元表达式的arity为2。
        </li>
<li>
          When one Proto expression is made a child node of another Proto expression,
          it is held by reference, <span class="emphasis"><em>even if it is a temporary object</em></span>.
          This last point becomes important later.<br>当一个 Proto 表达式作为另一个 Proto 表达式的子节点时，它是以引用方式被持有的，<span class="emphasis"><em>即使它是一个临时对象</em></span>。最后一点很重要。
        </li>
<li>
          Non-Proto expressions, such as the integer literal, are turned into Proto
          expressions by wrapping them in new <code class="computeroutput"><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code> terminal objects. These new wrappers
          are not themselves held by reference, but the object wrapped <span class="emphasis"><em>is</em></span>.
          Notice that the type of the Protofied <code class="computeroutput"><span class="number">42</span></code>
          literal is <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
          <span class="special">&amp;</span></code> -- held by reference.<br>非 Proto&nbsp;表达式，如整数字面值，通过把它们包入一个新的 <code class="computeroutput"><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code> 终结符对象变为 Proto 表达式。这些新的包装器本身不是以引用方式持有的，但被包装的对象<span style="font-style: italic;">是</span>。注意，Proto化的 <code class="computeroutput"><span class="number">42</span></code>
          字面值的类型是 <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
          <span class="special">&amp;</span></code> -- 是以引用方式持有的。
        </li>
</ol></div>
<p>
        The types make it clear: everything in a Proto expression tree is held by
        reference. That means that building an expression tree is exceptionally cheap.
        It involves no copying at all.<br>很显然：在一个 Proto 表达式树中的任何东西都是以引用方式持有的。这意味着构建一个表达式树代价非常低。它根本不进行复制。
      </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
          An astute reader will notice that the object <code class="computeroutput"><span class="identifier">y</span></code>
          defined above will be left holding a dangling reference to a temporary
          int. In the sorts of high-performance applications Proto addresses, it
          is typical to build and evaluate an expression tree before any temporary
          objects go out of scope, so this dangling reference situation often doesn't
          arise, but it is certainly something to be aware of. Proto provides utilities
          for deep-copying expression trees so they can be passed around as value
          types without concern for dangling references.<br>聪明的读者可能会注意到，上面所定义的对象 <code class="computeroutput"><span class="identifier">y</span></code>
会持有一个对临时 int 的悬空引用。在各种使用 Proto
的高性能应用程序中，典型的方法是在任何一个临时对象离开其范围之前，对一个表达式树构建并求值完成，所以这种悬空引用的情形通常不会发生，但这一点还是
必须要知道的。Proto 提供了对表达式树进行深复制的工具，所以表达式树可以作为值类型进行传递而无需担心悬空的引用。 </p></td></tr>
</tbody></table></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.intermediate_form.left_right_child"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child" title="Accessing Child Nodes">
        Accessing Child Nodes 访问子节点</a>
</h4></div></div></div>
<p>
          After assembling an expression into a tree, you'll naturally want to be
          able to do the reverse, and access a node's children. You may even want
          to be able to iterate over the children with algorithms from the Boost.Fusion
          library. This section shows how.<br>把一个表达式组装成一棵树之后，很自然你会想能够做相反的动作，访问某个子节点。甚至你可能会想能够用 Boost.Fusion
          库的算法来遍历子节点。本节将展示如何实现这一点。
        </p>
<a name="boost_proto.users_guide.intermediate_form.left_right_child._literal_tag_of_lt__gt___literal_"></a><h6>
<a name="id3489964"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child._literal_tag_of_lt__gt___literal_"><code class="literal">tag_of&lt;&gt;</code></a>
        </h6>
<p>
          A node in an expression tree is nothing more than a collection of child
          nodes and a tag type. You can access the tag type of any Proto expression
          type <code class="computeroutput"><span class="identifier">Expr</span></code> directly as
          <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_tag</span></code>,
          or you can use the <code class="computeroutput"><a class="link" href="../boost/proto/tag_of.html" title="Struct template tag_of">proto::tag_of&lt;&gt;</a></code>
          metafunction, as shown below:<br>在一个表达式树中的节点只不过是一些子节点和一个标签类型的组合。你可以直接访问任何 Proto 表达式类型 <code class="computeroutput"><span class="identifier">Expr</span></code> 的标签类型，用 <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_tag</span></code>，或者用 <code class="computeroutput"><a class="link" href="../boost/proto/tag_of.html" title="Struct template tag_of">proto::tag_of&lt;&gt;</a></code>
          元函数，如下所示：
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">tag_of</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">get_tag_of</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;)</span>
<span class="special">{</span>
    <span class="comment">// Tag types are required to be default-constructible 标签类型要求是可以缺省构造的<br></span>    <span class="keyword">return</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">tag_of</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">();</span>
<span class="special">}</span>

<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">{</span><span class="number">42</span><span class="special">};</span>

<span class="comment">// Addition nodes have the "plus" tag type: 加法节点具有"plus"标签类型：<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span> <span class="identifier">plus_tag</span> <span class="special">=</span> <span class="identifier">get_tag_of</span><span class="special">(</span> <span class="identifier">i</span> <span class="special">+</span> <span class="number">2</span> <span class="special">);</span>
</pre>
<a name="boost_proto.users_guide.intermediate_form.left_right_child._literal_child_c____literal_"></a><h6>
<a name="id3490361"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child._literal_child_c____literal_"><code class="literal">child_c()</code></a>
        </h6>
<p>
          Each node in an expression tree corresponds to an operator in an expression,
          and the children correspond to the operands, or arguments of the operator.
          To access them, you can use the <code class="computeroutput"><a class="link" href="../boost/proto/child_c_id3262754.html" title="Function child_c">proto::child_c()</a></code>
          function template, as demonstrated below:<br>表达式树中的每一个节点对应于表达式中的一个操作符，而子节点则对应于操作数或操作符的参数。要访问它们，你可以用 <code class="computeroutput"><a class="link" href="../boost/proto/child_c_id3262754.html" title="Function child_c">proto::child_c()</a></code>
          函数模板，示范如下：
        </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">{</span><span class="number">42</span><span class="special">};</span>

<span class="comment">// Get the 0-th operand of an addition operation: 取出加法操作的第0个操作数：<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&amp;</span><span class="identifier">ri</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span> <span class="identifier">i</span> <span class="special">+</span> <span class="number">2</span> <span class="special">);</span>

<span class="comment">// Assert that we got back what we put in: 断言我们取回了所放入的：<br></span><span class="identifier">assert</span><span class="special">(</span> <span class="special">&amp;</span><span class="identifier">i</span> <span class="special">==</span> <span class="special">&amp;</span><span class="identifier">ri</span> <span class="special">);</span>
</pre>
<p>
          You can use the <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;&gt;</span></code> metafunction to get the type of
          the Nth child of an expression node. Usually you don't care to know whether
          a child is stored by value or by reference, so when you ask for the type
          of the Nth child of an expression <code class="computeroutput"><span class="identifier">Expr</span></code>,
          you get the child's type after references and cv-qualifiers have been stripped
          from it.<br>你可以用 <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;&gt;</span></code> 元函数取出某个表达式节点的第N个子节点的类型。通常你不必关心一个子节点是以值方式还是以引用方式保存的，因此当你询问一个表达式 <code class="computeroutput"><span class="identifier">Expr</span></code> 的第N个子节点的类型时，你所得到的子节点类型是在引用和cv限定符被摘取之后的类型。
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">test_result_of_child_c</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="number">0</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span>

    <span class="comment">// ::type is a non-cv qualified, non-reference   ::type是一个非cv限定的，非引用的类型<br></span>    <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span><span class="identifier">is_same</span><span class="special">&lt;</span> <span class="identifier">type</span><span class="special">,</span> <span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;));</span>
<span class="special">}</span>

<span class="comment">// ...<br></span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">{</span><span class="number">42</span><span class="special">};</span>
<span class="identifier">test_result_of_child_c</span><span class="special">(</span> <span class="identifier">i</span> <span class="special">+</span> <span class="number">2</span> <span class="special">);</span>
</pre>
<p>
          However, if you ask for the type of the Nth child of <code class="computeroutput"><span class="identifier">Expr</span>
          <span class="special">&amp;</span></code> or <code class="computeroutput"><span class="identifier">Expr</span>
          <span class="keyword">const</span> <span class="special">&amp;</span></code>
          (note the reference), the result type will be a reference, regardless of
          whether the child is actually stored by reference or not. If you need to
          know exactly how the child is stored in the node, whether by reference
          or by value, you can use <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value_at</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">N</span><span class="special">&gt;::</span><span class="identifier">type</span></code>. The following table summarizes
          the behavior of the <code class="computeroutput"><span class="identifier">child_c</span><span class="special">&lt;&gt;</span></code> metafunction.<br>但是，如果你询问的是 <code class="computeroutput"><span class="identifier">Expr</span>
          <span class="special">&amp;</span></code> 或 <code class="computeroutput"><span class="identifier">Expr</span>
          <span class="keyword">const</span> <span class="special">&amp;</span></code>
          (留意其中的引用)的第N个子节点的类型，则结果类型将会是一个引用，无论这个子节点实际上是否以引用的方式保存。如果你需要精确地知道子节点是如何保存的，是值方式还是引用方式，你可以用 <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value_at</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">N</span><span class="special">&gt;::</span><span class="identifier">type</span></code>。下表总结了 <code class="computeroutput"><span class="identifier">child_c</span><span class="special">&lt;&gt;</span></code> 元函数的行为。
        </p>
<div class="table">
<a name="id3491080"></a><p class="title"><b>Table&nbsp;14.3.&nbsp;Accessing Child Types<br>表14.3. 访问子节点的类型</b></p>
<div class="table-contents"><table class="table" summary="Accessing Child Types">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
              <p>
                Metafunction Invocation 元函数调用
              </p>
              </th>
<th>
              <p>
                When the Child Is ... 子节点是...
              </p>
              </th>
<th>
              <p>
                The Result Is ... 结果是...
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span>
                <span class="identifier">N</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="identifier">Expr</span> <span class="special">&amp;,</span>
                <span class="identifier">N</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="identifier">Expr</span> <span class="keyword">const</span>
                <span class="special">&amp;,</span> <span class="identifier">N</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value_at</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span>
                <span class="identifier">N</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
<td>
              <p>
                T
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
<td>
              <p>
                T &amp;
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
<td>
              <p>
                T const &amp;
              </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><a name="boost_proto.users_guide.intermediate_form.left_right_child._literal_value____literal____literal_child____literal____literal_left____literal___and__literal_right____literal_"></a><h6>
<a name="id3491626"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child._literal_value____literal____literal_child____literal____literal_left____literal___and__literal_right____literal_"><code class="literal">value()</code>,
          <code class="literal">child()</code>, <code class="literal">left()</code>, and <code class="literal">right()</code></a>
        </h6>
<p>
          Most operators in C++ are unary or binary. For that reason, accessing the
          only operand, or the left and right operands, are very common operations.
          For this reason, Proto provides the <code class="computeroutput"><a class="link" href="../boost/proto/child_id3262509.html" title="Function child">proto::child()</a></code>,
          <code class="computeroutput"><a class="link" href="../boost/proto/left_id3263026.html" title="Function left">proto::left()</a></code>, and <code class="computeroutput"><a class="link" href="../boost/proto/right_id3263151.html" title="Function right">proto::right()</a></code>
          functions. <code class="computeroutput"><a class="link" href="../boost/proto/child_id3262509.html" title="Function child">proto::child()</a></code> and <code class="computeroutput"><a class="link" href="../boost/proto/left_id3263026.html" title="Function left">proto::left()</a></code>
          are synonymous with <code class="computeroutput"><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;()</span></code>,
          and <code class="computeroutput"><a class="link" href="../boost/proto/right_id3263151.html" title="Function right">proto::right()</a></code> is synonymous with <code class="computeroutput"><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;()</span></code>.<br>C++中的多数操作符都是单参数或双参数的。因此，访问唯一的操作数，或访问左、右操作数，是非常常见的操作。为此，Proto 提供了 <code class="computeroutput"><a class="link" href="../boost/proto/child_id3262509.html" title="Function child">proto::child()</a></code>,
          <code class="computeroutput"><a class="link" href="../boost/proto/left_id3263026.html" title="Function left">proto::left()</a></code>, 和 <code class="computeroutput"><a class="link" href="../boost/proto/right_id3263151.html" title="Function right">proto::right()</a></code>
          函数。<code class="computeroutput"><a class="link" href="../boost/proto/child_id3262509.html" title="Function child">proto::child()</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/proto/left_id3263026.html" title="Function left">proto::left()</a></code>
          相当于 <code class="computeroutput"><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;()</span></code>，而 <code class="computeroutput"><a class="link" href="../boost/proto/right_id3263151.html" title="Function right">proto::right()</a></code> 则相当于 <code class="computeroutput"><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;()</span></code>。
        </p>
<p>
          Another very common operation is accessing the value stored within a Proto
          terminal. You can use the <code class="computeroutput"><a class="link" href="../boost/proto/value_id3262918.html" title="Function value">proto::value()</a></code>
          function for that.<br>另一个很常见的操作是，访问保存在一个 Proto 终结符内的值。你可以使用 <code class="computeroutput"><a class="link" href="../boost/proto/value_id3262918.html" title="Function value">proto::value()</a></code>
          函数。
        </p>
<p>
          There are also <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child</span><span class="special">&lt;&gt;</span></code>, <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">left</span><span class="special">&lt;&gt;</span></code>, and <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">right</span><span class="special">&lt;&gt;</span></code> metafunctions that merely forward
          to their <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;&gt;</span></code>
          counterparts. Likewise, there is a <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;&gt;</span></code> metafunction that returns the type
          of the value stored in a terminal node.<br>还有，<code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child</span><span class="special">&lt;&gt;</span></code>, <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">left</span><span class="special">&lt;&gt;</span></code>, and <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">right</span><span class="special">&lt;&gt;</span></code> 元函数只是前转至相应的 <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;&gt;</span></code>。同样， <code class="computeroutput"><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;&gt;</span></code> 元函数则返回保存在一个终结符节点中的值的类型。
        </p>
<a name="boost_proto.users_guide.intermediate_form.left_right_child.expression_nodes_as_fusion_sequences"></a><h6>
<a name="id3491941"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child.expression_nodes_as_fusion_sequences">Expression
          Nodes as Fusion Sequences 作为Fusion序列的表达式节点</a>
        </h6>
<p>
          Proto expression nodes are valid Fusion random-access sequences of their
          child nodes. That means you can apply Fusion algorithms to them, transform
          them, apply Fusion filters and views to them, and access their elements
          using <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">at</span><span class="special">()</span></code>.
          The things Fusion can do to heterogeneous sequences are beyond the scope
          of this users' guide, but below is a simple example. It takes a lazy function
          invocation like <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">,</span><span class="number">3</span><span class="special">,</span><span class="number">4</span><span class="special">)</span></code> and uses
          Fusion to print the function arguments in order.<br>Proto 表达式节点是其子节点的有效 Fusion 随机访问序列。这意味着你可以对它们应用 Fusion 算法、转换它们，应用 Fusion 过滤器和查看它们，以及使用 <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">at</span><span class="special">()</span></code> 访问它们的元素。这些 Fusion 可以对异类型序列的事情已经超出本用户指南的讨论范围，下面给出一个简单的例子。该例子接受一个类似于 <code class="computeroutput"><span class="identifier">fun</span><span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">,</span><span class="number">3</span><span class="special">,</span><span class="number">4</span><span class="special">)</span></code> 的惰性函数调用，并使用
          Fusion 来按顺序打印函数的参数。
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">display</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">t</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">t</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">fun_t</span> <span class="special">{};</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">fun_t</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">fun</span> <span class="special">=</span> <span class="special">{{}};</span>

<span class="comment">// ...<br></span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
    <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span>
        <span class="comment">// pop_front() removes the "fun" child  pop_front()删除"fun"子节点<br></span>        <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">pop_front</span><span class="special">(</span><span class="identifier">fun</span><span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">,</span><span class="number">3</span><span class="special">,</span><span class="number">4</span><span class="special">))</span>
        <span class="comment">// Extract the ints from the terminal nodes 从终结符节点取出整数<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span>
    <span class="special">)</span>
  <span class="special">,</span> <span class="identifier">display</span><span class="special">()</span>
<span class="special">);</span>
</pre>
<p>
          Recall from the Introduction that types in the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span></code>
          namespace define function objects that correspond to Proto's free functions.
          So <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code>
          creates a function object that is equivalent to the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> function. The above invocation of <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">()</span></code>
          displays the following:<br>回想一下"简介"中的介绍，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span></code>
          名字空间中的类型定义了与 Proto 普通函数相对应的函数对象。因此 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code>
          创建一个等价于 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> 函数的函数对象。以上 <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">()</span></code>
          调用将显示以下内容：
        </p>
<pre class="programlisting">1<br>2<br>3<br>4<br></pre>
<a name="boost_proto.users_guide.intermediate_form.left_right_child.flattening_proto_expression_tress"></a><h6>
<a name="id3492571"></a>
          <a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child.flattening_proto_expression_tress">Flattening
          Proto Expression Tress 将 Proto 表达式树摊平</a>
        </h6>
<p>
          Imagine a slight variation of the above example where, instead of iterating
          over the arguments of a lazy function invocation, we would like to iterate
          over the terminals in an addition expression:<br>想象一下以上例子的轻微变化，不遍历惰性函数调用的参数，而是遍历另一个表达式中的终结符：
        </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{</span><span class="number">1</span><span class="special">};</span>

<span class="comment">// ERROR: this doesn't work! Why? 错误：不能这样做！为什么？<br></span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
    <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span>
        <span class="identifier">_1</span> <span class="special">+</span> <span class="number">2</span> <span class="special">+</span> <span class="number">3</span> <span class="special">+</span> <span class="number">4</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span>
    <span class="special">)</span>
  <span class="special">,</span> <span class="identifier">display</span><span class="special">()</span>
<span class="special">);</span>
</pre>
<p>
          The reason this doesn't work is because the expression <code class="computeroutput"><span class="identifier">_1</span>
          <span class="special">+</span> <span class="number">2</span> <span class="special">+</span> <span class="number">3</span> <span class="special">+</span>
          <span class="number">4</span></code> does not describe a flat sequence
          of terminals --- it describes a binary tree. We can treat it as a flat
          sequence of terminals, however, using Proto's <code class="computeroutput"><a class="link" href="../boost/proto/flatten_id3239270.html" title="Function template flatten">proto::flatten()</a></code>
          function. <code class="computeroutput"><a class="link" href="../boost/proto/flatten_id3239270.html" title="Function template flatten">proto::flatten()</a></code> returns a view which makes
          a tree appear as a flat Fusion sequence. If the top-most node has a tag
          type <code class="computeroutput"><span class="identifier">T</span></code>, then the elements
          of the flattened sequence are the child nodes that do <span class="emphasis"><em>not</em></span>
          have tag type <code class="computeroutput"><span class="identifier">T</span></code>. This process
          is evaluated recursively. So the above can correctly be written as:<br>不能这样做的原因是，因为表达式 <code class="computeroutput"><span class="identifier">_1</span>
          <span class="special">+</span> <span class="number">2</span> <span class="special">+</span> <span class="number">3</span> <span class="special">+</span>
          <span class="number">4</span></code> 并不表示为各个终结符的一个扁平序列 --- 它表示为一个二叉树。不过，我们可以通过用 Proto 的 <code class="computeroutput"><a class="link" href="../boost/proto/flatten_id3239270.html" title="Function template flatten">proto::flatten()</a></code>
          函数将它视为终结符的扁平序列。<code class="computeroutput"><a class="link" href="../boost/proto/flatten_id3239270.html" title="Function template flatten">proto::flatten()</a></code> 返回一个视图，使一棵树看起来象一个扁平的 Fusion 序列。如果最顶部的节点具有标签类型 <code class="computeroutput"><span class="identifier">T</span></code>，则扁平化序列的元素为那些不具有标签类型 <code class="computeroutput"><span class="identifier">T</span></code> 的子节点。这个过程是递归进行的。所以以上例子可以正确地写为：
        </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{</span><span class="number">1</span><span class="special">};</span>

<span class="comment">// OK, iterate over a flattened view  好的，遍历一个扁平视图<br></span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
    <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">flatten</span><span class="special">(</span><span class="identifier">_1</span> <span class="special">+</span> <span class="number">2</span> <span class="special">+</span> <span class="number">3</span> <span class="special">+</span> <span class="number">4</span><span class="special">)</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span>
    <span class="special">)</span>
  <span class="special">,</span> <span class="identifier">display</span><span class="special">()</span>
<span class="special">);</span>
</pre>
<p>
          The above invocation of <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">()</span></code> displays the following:<br>以上 <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">()</span></code> 调用将显示如下：
        </p>
<pre class="programlisting">1<br>2<br>3<br>4<br></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.intermediate_form.tags_and_metafunctions"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.tags_and_metafunctions" title="Operator Tags and Metafunctions">
        Operator Tags and Metafunctions 操作符标签和元函数</a>
</h4></div></div></div>
<p>
          The following table lists the overloadable C++ operators, the Proto tag
          types for each, and the name of the metafunctions for generating the corresponding
          Proto expression types. And as we'll see later, the metafunctions are also
          usable as grammars for matching such nodes, as well as pass-through transforms.<br>下表列出了可重载的C++操作符、各个 Proto 标签类型，以及生成相应的 Proto 表达式类型的元函数名字。我们稍后将看到，这些元函数也可用作匹配这些节点的语法，以及传递给变换操作。
        </p>
<div class="table">
<a name="id3493200"></a><p class="title"><b>Table&nbsp;14.4.&nbsp;Operators, Tags and Metafunctions<br>表 14.4. 操作符，标签和元函数</b></p>
<div class="table-contents"><table class="table" summary="Operators, Tags and Metafunctions">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
              <p>
                Operator 操作符</p>
              </th>
<th>
              <p>
                Proto Tag &nbsp;Proto标签
              </p>
              </th>
<th>
              <p>
                Proto Metafunction &nbsp;Proto元函数
              </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                unary <code class="computeroutput"><span class="special">+</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">unary_plus</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary <code class="computeroutput"><span class="special">-</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">negate</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">negate</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary <code class="computeroutput"><span class="special">*</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">dereference</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">dereference</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary <code class="computeroutput"><span class="special">~</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">complement</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">complement</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary <code class="computeroutput"><span class="special">&amp;</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">address_of</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary <code class="computeroutput"><span class="special">!</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">logical_not</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_not</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary prefix <code class="computeroutput"><span class="special">++</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">pre_inc</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pre_inc</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary prefix <code class="computeroutput"><span class="special">--</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">pre_dec</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pre_dec</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary postfix <code class="computeroutput"><span class="special">++</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">post_inc</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">post_inc</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                unary postfix <code class="computeroutput"><span class="special">--</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">post_dec</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">post_dec</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&lt;&lt;</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_left</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_right</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">*</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">multiplies</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">/</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">divides</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">%</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">modulus</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">+</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">-</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">minus</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&lt;</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">less</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&gt;</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">greater</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&lt;=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">less_equal</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">less_equal</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&gt;=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">greater_equal</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">greater_equal</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">==</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">equal_to</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">!=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">not_equal_to</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_equal_to</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">||</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">logical_or</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_or</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&amp;&amp;</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">logical_and</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_and</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&amp;</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_and</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_and</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">|</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_or</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_or</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">^</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_xor</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_xor</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">,</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">comma</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">comma</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">-&gt;*</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mem_ptr</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">mem_ptr</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&lt;&lt;=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_left_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&gt;&gt;=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_right_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">*=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">multiplies_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">/=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">divides_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">%=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">modulus_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">+=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">-=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">minus_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">&amp;=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_and_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_and_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">|=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_or_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_or_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary <code class="computeroutput"><span class="special">^=</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_xor_assign</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_xor_assign</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                binary subscript
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">subscript</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">subscript</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                ternary <code class="computeroutput"><span class="special">?:</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">if_else_</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">if_else_</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
<tr>
<td>
              <p>
                n-ary function call
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span></code>
              </p>
              </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>
              </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.intermediate_form.expression_introspection"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection" title="Expression Introspection: Defining a Grammar">
        Expression Introspection: Defining a Grammar 表达式的内部：定义一个语法</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.patterns">
          Finding Patterns in Expressions 发现表达式中的模式</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.fuzzy_and_exact_matches_of_terminals">Fuzzy
          and Exact Matches of Terminals 终结符的模糊匹配和精确匹配</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.if_and_not">
          <code class="literal">if_&lt;&gt;</code>, <code class="literal">and_&lt;&gt;</code>, and <code class="literal">not_&lt;&gt;</code></a></span></dt>
<dt><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch"><span class="section"></span></a><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch">
          Improving Compile Times With <code class="literal">switch_&lt;&gt;</code></a><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch">
          用</a></span><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch"><span class="section"></span></a><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch">&nbsp; <code class="literal">switch_&lt;&gt;</code></a><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch"> 改进编译时间<code class="literal"></code></a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.matching_vararg_expressions">Matching
          Vararg Expressions 匹配可变参数的表达式</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.defining_dsel_grammars">Defining
          DSEL Grammars 定义DSEL语法</a></span></dt>
</dl></div>
<p>
          Expression trees can have a very rich and complicated structure. Often,
          you need to know some things about an expression's structure before you
          can process it. This section describes the tools Proto provides for peering
          inside an expression tree and discovering its structure. And as you'll
          see in later sections, all the really interesting things you can do with
          Proto begin right here.<br>表达式树可以具有非常大而复杂的结构。通常，在你可以处理一个表达式结构之前，你需要了解关于它的一些事情。本节描述 Proto 所提供的一些工具，用于窥探表达式树的内部和发现其结构。在后面的章节中你将看到，你可以用
          Proto 所做的真正有趣的事情从这里才开始。
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.intermediate_form.expression_introspection.patterns"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.patterns" title="Finding Patterns in Expressions">
          Finding Patterns in Expressions 发现表达式中的模式</a>
</h5></div></div></div>
<p>
            Imagine your DSEL is a miniature I/O facility, with iostream operations
            that execute lazily. You might want expressions representing input operations
            to be processed by one function, and output operations to be processed
            by a different function. How would you do that?<br>想象你的DSEL是一个微型的I/O工具，可以延迟执行 iostream 操作。你可能想让表示输入操作的表达式可以被某个函数处理，而表示输出操作的则被另一个函数处理。你要怎样做呢？
          </p>
<p>
            The answer is to write patterns (a.k.a, <span class="emphasis"><em>grammars</em></span>)
            that match the structure of input and output expressions. Proto provides
            utilities for defining the grammars, and the <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code>
            template for checking whether a given expression type matches the grammar.<br>答案是编写匹配输入和输出表达式结构的模式(也称<span class="emphasis"><em>语法</em></span>)。Proto 提供了定义语法的工具，以及用于检查一个给定的表达式类型是否匹配该语法的 <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code>
            模板。
          </p>
<p>
            First, let's define some terminals we can use in our lazy I/O expressions:<br>首先，我们来定义一些要在我们的惰性I/O表达式中使用的终结符：
          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cin_</span> <span class="special">=</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cin</span> <span class="special">};</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">};</span>
</pre>
<p>
            Now, we can use <code class="computeroutput"><span class="identifier">cout_</span></code>
            instead of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code>, and get I/O expression trees
            that we can execute later. To define grammars that match input and output
            expressions of the form <code class="computeroutput"><span class="identifier">cin_</span>
            <span class="special">&gt;&gt;</span> <span class="identifier">i</span></code>
            and <code class="computeroutput"><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span>
            <span class="number">1</span></code> we do this:<br>现在，我们可以用 <code class="computeroutput"><span class="identifier">cout_</span></code>
            替代 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code>，并得到可以延迟执行的I/O表达式树。要定义匹配形如 <code class="computeroutput"><span class="identifier">cin_</span>
            <span class="special">&gt;&gt;</span> <span class="identifier">i</span></code> 和 <code class="computeroutput"><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span>
            <span class="number">1</span></code> 的输入输出表达式的语法，我们可以这样做：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Input</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span> <span class="special">&amp;</span> <span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Output</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            We've seen the template <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;&gt;</span></code> before, but here we're using
            it without accessing the nested <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>. When used like this, it is a
            very simple grammar, as are <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;&gt;</span></code>. The newcomer here is <code class="computeroutput"><span class="identifier">_</span></code> in the <code class="computeroutput"><span class="identifier">proto</span></code>
            namespace. It is a wildcard that matches anything. The <code class="computeroutput"><span class="identifier">Input</span></code> struct is a grammar that matches
            any right-shift expression that has a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code>
            terminal as its left operand.<br>之前我们已见过模板 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;&gt;</span></code>，但是我们在这里使用它并没有访问嵌套的 <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>。象这样使用时，语法非常简单，如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;&gt;</span></code>。这里新出现的是位于 <code class="computeroutput"><span class="identifier">proto</span></code> 名字空间中的 <code class="computeroutput"><span class="identifier">_</span></code>。它是一个可以匹配任何东西的通配符。结构 <code class="computeroutput"><span class="identifier">Input</span></code> 就是一个可以匹配任何以一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code>
            终结符作为左操作数的右移表达式的语法。
          </p>
<p>
            We can use these grammars together with the <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code>
            template to query at compile time whether a given I/O expression type
            is an input or output operation. Consider the following:<br>我们可以将这些语法和 <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code>
            模板一起使用，在编译期查询一个给定的I/O表达式类型是否为输入或输出操作。考虑以下代码：
          </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">input_output</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Input</span> <span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Input!\n"</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Output</span> <span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Output!\n"</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="identifier">input_output</span><span class="special">(</span> <span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="number">1</span> <span class="special">);</span>
    <span class="identifier">input_output</span><span class="special">(</span> <span class="identifier">cin_</span> <span class="special">&gt;&gt;</span> <span class="identifier">i</span> <span class="special">);</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
            This program prints the following:<br>该程序输出如下：
          </p>
<pre class="programlisting">Output!<br>Input!<br></pre>
<p>
            If we wanted to break the <code class="computeroutput"><span class="identifier">input_output</span><span class="special">()</span></code> function into two functions, one that
            handles input expressions and one for output expressions, we can use
            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;&gt;</span></code>,
            as follows:<br>如果我们想将 <code class="computeroutput"><span class="identifier">input_output</span><span class="special">()</span></code> 函数分开为两个函数，一个处理输入表达式，另一个处理输出表达式，我们可以用
            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;&gt;</span></code>，如下：
          </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Input</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">input_output</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Input!\n"</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Output</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">input_output</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Output!\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
            This works as the previous version did. However, the following does not
            compile at all:<br>这一个和前一个版本结果一样。不过，以下代码就不能通过编译：
          </p>
<pre class="programlisting"><span class="identifier">input_output</span><span class="special">(</span> <span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="number">1</span> <span class="special">&lt;&lt;</span> <span class="number">2</span> <span class="special">);</span> <span class="comment">// oops!<br></span></pre>
<p>
            What's wrong? The problem is that this expression does not match our
            grammar. The expression groups as if it were written like <code class="computeroutput"><span class="special">(</span><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="number">1</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="number">2</span></code>. It will not match the <code class="computeroutput"><span class="identifier">Output</span></code> grammar, which expects the left
            operand to be a terminal, not another left-shift operation. We need to
            fix the grammar.<br>有什么错吗？问题在于，这个表达式不能匹配我们的语法。这个表达式组和以下写法一样：<code class="computeroutput"><span class="special">(</span><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="number">1</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="number">2</span></code>。它不能匹配 <code class="computeroutput"><span class="identifier">Output</span></code> 语法，后者要求左操作数是一个终结符，而不是另一个左移操作。我们要修正这个语法。
          </p>
<p>
            We notice that in order to verify an expression as input or output, we'll
            need to recurse down to the bottom-left-most leaf and check that it is
            a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code> or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span></code>.
            When we get to the terminal, we must stop recursing. We can express this
            in our grammar using <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>.
            Here are the correct <code class="computeroutput"><span class="identifier">Input</span></code>
            and <code class="computeroutput"><span class="identifier">Output</span></code> grammars:<br>我们注意到，为了检验一个表达式是输入还是输出，我们需要向下递归至最左下方的叶子并检查它是 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span></code> 还是 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span></code>。当我们得到终结符时，我们必须停止递归。我们可以在我们的语法中用 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code> 来表示这一点。以下是正确的 <code class="computeroutput"><span class="identifier">Input</span></code> 和 <code class="computeroutput"><span class="identifier">Output</span></code> 语法：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Input</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istream</span> <span class="special">&amp;</span> <span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;</span> <span class="identifier">Input</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Output</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span> <span class="identifier">Output</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            This may look a little odd at first. We seem to be defining the <code class="computeroutput"><span class="identifier">Input</span></code> and <code class="computeroutput"><span class="identifier">Output</span></code>
            types in terms of themselves. This is perfectly OK, actually. At the
            point in the grammar that the <code class="computeroutput"><span class="identifier">Input</span></code>
            and <code class="computeroutput"><span class="identifier">Output</span></code> types are
            being used, they are <span class="emphasis"><em>incomplete</em></span>, but by the time
            we actually evaluate the grammar with <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code>,
            the types will be complete. These are recursive grammars, and rightly
            so because they must match a recursive data structure!<br>乍一看，这有点怪。看起来，我们是在用 <code class="computeroutput"><span class="identifier">Input</span></code> 和 <code class="computeroutput"><span class="identifier">Output</span></code>
            类型来定义它们本身。事实上这是完全可以的。在这个语法中，到使用 <code class="computeroutput"><span class="identifier">Input</span></code> 和 <code class="computeroutput"><span class="identifier">Output</span></code> 类型的地方为止，它们还是<span class="emphasis"><em>不完整的</em></span>，但是到我们使用 <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code> 对该语法进行求值时，这两个类型已经是完整的了。这是递归语法，也是正确的，因为它们必须匹配一个递归的数据结构！
          </p>
<p>
            When the <code class="computeroutput"><span class="identifier">Output</span></code> grammar
            is evaluated against an expression like <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span>
            <span class="special">&lt;&lt;</span> <span class="number">2</span></code>,
            the first alternate of the <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            is tried first. It will fail, because the expression <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span>
            <span class="special">&lt;&lt;</span> <span class="number">2</span></code>
            does not match the grammar <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span>
            <span class="special">&amp;</span> <span class="special">&gt;,</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code>.
            Then the second alternate is tried. We match the expression against
            <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span>
            <span class="identifier">Output</span><span class="special">,</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code>.
            The expression is a left-shift, so we try the operands. The right operand
            <code class="computeroutput"><span class="number">2</span></code> matches <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
            trivially. To see if the left operand <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span></code>
            matches <code class="computeroutput"><span class="identifier">Output</span></code>, we must
            recursively evaluate the <code class="computeroutput"><span class="identifier">Output</span></code>
            grammar. This time we succeed, because <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span></code>
            will match the first alternate of the <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>.
            We're done -- the grammar matches successfully.<br>当这个 <code class="computeroutput"><span class="identifier">Output</span></code> 语法针对一个形如 <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span>
            <span class="special">&lt;&lt;</span> <span class="number">2</span></code> 的表达式进行求值时，首先尝试 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            的第一个选择。这会失败，因为表达式 <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span>
            <span class="special">&lt;&lt;</span> <span class="number">2</span></code>&nbsp;不能匹配语法 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span>
            <span class="special">&amp;</span> <span class="special">&gt;,</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code>。然后尝试第二个选择。我们用
            <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span>
            <span class="identifier">Output</span><span class="special">,</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code> 来匹配这个表达式。这个表达式是一个左移操作，所以我们先尝试操作数。右操作数 <code class="computeroutput"><span class="number">2</span></code> 可以匹配 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>。现在看左操作数 <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span></code>
            是否能匹配 <code class="computeroutput"><span class="identifier">Output</span></code>，我们必须递归求值 <code class="computeroutput"><span class="identifier">Output</span></code>
            语法。这一次我们成功了，因为 <code class="computeroutput"><span class="identifier">cout_</span>
            <span class="special">&lt;&lt;</span> <span class="number">1</span></code>
            将匹配 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code> 的第一个选择。匹配完成 -- 这个语法可以成功地匹配。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.intermediate_form.expression_introspection.fuzzy_and_exact_matches_of_terminals"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.fuzzy_and_exact_matches_of_terminals" title="Fuzzy and Exact Matches of Terminals">Fuzzy
          and Exact Matches of Terminals 终结符的模糊匹配和精确匹配</a>
</h5></div></div></div>
<p>
            The terminals in an expression tree could be const or non-const references,
            or they might not be references at all. When writing grammars, you usually
            don't have to worry about it because <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code>
            gives you a little wiggle room when matching terminals. A grammar such
            as <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
            will match a terminal of type <code class="computeroutput"><span class="keyword">int</span></code>,
            <code class="computeroutput"><span class="keyword">int</span> <span class="special">&amp;</span></code>,
            or <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
            <span class="special">&amp;</span></code>.<br>一棵表达式树中的终结符可以是const的或非const的引用，或者根本不是引用。在编写语法时，你通常不需要担心这一点，因为 <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code>
            在匹配终结符时给了你一点宽松的空间。一个形如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
            的语法可以匹配类型为 <code class="computeroutput"><span class="keyword">int</span></code>,
            <code class="computeroutput"><span class="keyword">int</span> <span class="special">&amp;</span></code>, 或 <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
            <span class="special">&amp;</span></code> 的终结符。
          </p>
<p>
            You can explicitly specify that you want to match a reference type. If
            you do, the type must match exactly. For instance, a grammar such as
            <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">&amp;&gt;</span></code>
            will only match an <code class="computeroutput"><span class="keyword">int</span> <span class="special">&amp;</span></code>. It will not match an <code class="computeroutput"><span class="keyword">int</span></code> or an <code class="computeroutput"><span class="keyword">int</span>
            <span class="keyword">const</span> <span class="special">&amp;</span></code>.<br>你可以明确指定你要匹配的引用类型。如果你这样做了，类型将必须精确匹配。例如，一个形如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">&amp;&gt;</span></code>
            的语法只能匹配一个 <code class="computeroutput"><span class="keyword">int</span> <span class="special">&amp;</span></code>。它不能匹配 <code class="computeroutput"><span class="keyword">int</span></code> 或 <code class="computeroutput"><span class="keyword">int</span>
            <span class="keyword">const</span> <span class="special">&amp;</span></code>。
          </p>
<p>
            The table below shows how Proto matches terminals. The simple rule is:
            if you want to match only reference types, you must specify the reference
            in your grammar. Otherwise, leave it off and Proto will ignore const
            and references.<br>下表展示了 Proto 是如何匹配终结符的。简单的规则是：如果你想只匹配引用类型，你必须在你的语法中指定引用。否则，不用指定它，而 Proto 将忽略 const 和引用。
          </p>
<div class="table">
<a name="id3499478"></a><p class="title"><b>Table&nbsp;14.5.&nbsp;proto::matches&lt;&gt; and Reference / CV-Qualification
          of Terminals<br>Table&nbsp;14.5.&nbsp;proto::matches&lt;&gt; 和终结符的引用/CV限定</b></p>
<div class="table-contents"><table class="table" summary="proto::matches&lt;&gt; and Reference / CV-Qualification
          of Terminals">
<colgroup><col><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  Terminal 终结符
                </p>
                </th>
<th>
                <p>
                  Grammar 语法
                </p>
                </th>
<th>
                <p>
                  Matches? 是否匹配？
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  T
                </p>
                </td>
<td>
                <p>
                  T
                </p>
                </td>
<td>
                <p>
                  yes
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T &amp;
                </p>
                </td>
<td>
                <p>
                  T
                </p>
                </td>
<td>
                <p>
                  yes
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T const &amp;
                </p>
                </td>
<td>
                <p>
                  T
                </p>
                </td>
<td>
                <p>
                  yes
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T
                </p>
                </td>
<td>
                <p>
                  T &amp;
                </p>
                </td>
<td>
                <p>
                  no
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T &amp;
                </p>
                </td>
<td>
                <p>
                  T &amp;
                </p>
                </td>
<td>
                <p>
                  yes
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T const &amp;
                </p>
                </td>
<td>
                <p>
                  T &amp;
                </p>
                </td>
<td>
                <p>
                  no
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T
                </p>
                </td>
<td>
                <p>
                  T const &amp;
                </p>
                </td>
<td>
                <p>
                  no
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T &amp;
                </p>
                </td>
<td>
                <p>
                  T const &amp;
                </p>
                </td>
<td>
                <p>
                  no
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  T const &amp;
                </p>
                </td>
<td>
                <p>
                  T const &amp;
                </p>
                </td>
<td>
                <p>
                  yes
                </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
            This begs the question: What if you want to match an <code class="computeroutput"><span class="keyword">int</span></code>,
            but not an <code class="computeroutput"><span class="keyword">int</span> <span class="special">&amp;</span></code>
            or an <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
            <span class="special">&amp;</span></code>? For forcing exact matches,
            Proto provides the <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code>
            template. For instance, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">exact</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>
            would only match an <code class="computeroutput"><span class="keyword">int</span></code>
            held by value.<br>这里回避了一个问题：如果你想匹配一个 <code class="computeroutput"><span class="keyword">int</span></code>，而不匹配 <code class="computeroutput"><span class="keyword">int</span> <span class="special">&amp;</span></code> 或 <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
            <span class="special">&amp;</span></code>，该怎么办？为了强制精确的匹配，Proto 提供了 <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code>
            模板。例如，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">exact</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span></code> 将只匹配一个以值方式保存的 <code class="computeroutput"><span class="keyword">int</span></code>。
          </p>
<p>
            Proto gives you extra wiggle room when matching array types. Array types
            match themselves or the pointer types they decay to. This is especially
            useful with character arrays. The type returned by <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">(</span><span class="string">"hello"</span><span class="special">)</span></code> is <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span><span class="number">6</span><span class="special">]&gt;::</span><span class="identifier">type</span></code>. That's a terminal containing
            a 6-element character array. Naturally, you can match this terminal with
            the grammar <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span><span class="number">6</span><span class="special">]&gt;</span></code>,
            but the grammar <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*&gt;</span></code>
            will match it as well, as the following code fragment illustrates.<br>在匹配数组类型时，Proto 为你提供了更为宽松的空间。数组类型可以匹配它们本身或它们退化的指针类型。这对于字符数组尤其有用。由 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">(</span><span class="string">"hello"</span><span class="special">)</span></code> 所返回的类型为 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span><span class="number">6</span><span class="special">]&gt;::</span><span class="identifier">type</span></code>。这是一个包含6个元素的字符数组的终结符。自然，你可以用语法 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span><span class="number">6</span><span class="special">]&gt;</span></code> 来匹配这个终结符，不过语法 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*&gt;</span></code>
            也可以匹配它，如以下代码片断所示。
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">CharString</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span><span class="number">6</span><span class="special">]</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">char_array</span><span class="special">;</span>

<span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">char_array</span><span class="special">,</span> <span class="identifier">CharString</span> <span class="special">&gt;</span> <span class="special">));</span>
</pre>
<p>
            What if we only wanted <code class="computeroutput"><span class="identifier">CharString</span></code>
            to match terminals of exactly the type <code class="computeroutput"><span class="keyword">char</span>
            <span class="keyword">const</span> <span class="special">*</span></code>?
            You can use <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code> here to turn off
            the fuzzy matching of terminals, as follows:<br>如果我们想 <code class="computeroutput"><span class="identifier">CharString</span></code>
            只精确匹配类型为 <code class="computeroutput"><span class="keyword">char</span>
            <span class="keyword">const</span> <span class="special">*</span></code> 的终结符，该如何？你可以用 <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code> 来关闭对终结符的模糊匹配，如下：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">CharString</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">exact</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span><span class="number">6</span><span class="special">]&gt;::</span><span class="identifier">type</span> <span class="identifier">char_array</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*&gt;::</span><span class="identifier">type</span>  <span class="identifier">char_string</span><span class="special">;</span>

<span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">char_string</span><span class="special">,</span> <span class="identifier">CharString</span> <span class="special">&gt;</span> <span class="special">));</span>
<span class="identifier">BOOST_MPL_ASSERT_NOT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">char_array</span><span class="special">,</span> <span class="identifier">CharString</span> <span class="special">&gt;</span> <span class="special">));</span>
</pre>
<p>
            Now, <code class="computeroutput"><span class="identifier">CharString</span></code> does
            not match array types, only character string pointers.<br>现在，<code class="computeroutput"><span class="identifier">CharString</span></code> 将不能匹配数组类型，只能匹配字符串指针。
          </p>
<p>
            The inverse problem is a little trickier: what if you wanted to match
            all character arrays, but not character pointers? As mentioned above,
            the expression <code class="computeroutput"><span class="identifier">as_expr</span><span class="special">(</span><span class="string">"hello"</span><span class="special">)</span></code> has the type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span> <span class="number">6</span> <span class="special">]</span> <span class="special">&gt;::</span><span class="identifier">type</span></code>. If you wanted to match character
            arrays of arbitrary size, you could use <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">N</span></code>,
            which is an array-size wildcard. The following grammar would match any
            string literal: <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">N</span> <span class="special">]</span> <span class="special">&gt;</span></code>.<br>相反的问题则有点微妙：如果你想匹配所有字符数组而不想匹配字符指针呢？如上所述，表达式 <code class="computeroutput"><span class="identifier">as_expr</span><span class="special">(</span><span class="string">"hello"</span><span class="special">)</span></code> 具有 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span> <span class="number">6</span> <span class="special">]</span> <span class="special">&gt;::</span><span class="identifier">type</span></code> 的类型。如果你想匹配任意大小的字符数组，你可以用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">N</span></code>，它是一个数组大小通配符。以下语法将匹配任何字符串字面值：<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="keyword">const</span><span class="special">[</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">N</span> <span class="special">]</span> <span class="special">&gt;</span></code>。
          </p>
<p>
            Sometimes you need even more wiggle room when matching terminals. For
            example, maybe you're building a calculator DSEL and you want to allow
            any terminals that are convertible to <code class="computeroutput"><span class="keyword">double</span></code>.
            For that, Proto provides the <code class="computeroutput"><a class="link" href="../boost/proto/convertible_to.html" title="Struct template convertible_to">proto::convertible_to&lt;&gt;</a></code>
            template. You can use it as: <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">convertible_to</span><span class="special">&lt;</span> <span class="keyword">double</span>
            <span class="special">&gt;</span> <span class="special">&gt;</span></code>.<br>有时候，在匹配终结符时你需要更多的空间。例如，也许你正在构建一个计算器DSEL，你想允许任何可以转换为 <code class="computeroutput"><span class="keyword">double</span></code> 的终结符。为此，Proto 提供了 <code class="computeroutput"><a class="link" href="../boost/proto/convertible_to.html" title="Struct template convertible_to">proto::convertible_to&lt;&gt;</a></code>
            模板。你可以这样来使用它：<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">convertible_to</span><span class="special">&lt;</span> <span class="keyword">double</span>
            <span class="special">&gt;</span> <span class="special">&gt;</span></code>。
          </p>
<p>
            There is one more way you can perform a fuzzy match on terminals. Consider
            the problem of trying to match a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code> terminal. You can easily match
            a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;</span></code>
            or a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>,
            but how would you match any instantiation of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code>? You can use <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
            here to solve this problem. Here is the grammar to match any <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code>
            instantiation:<br>你还有一个方法可以对终结符执行模糊匹配。考虑这样一个问题，你尝试匹配一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code> 终结符。你可以很容易地匹配一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;</span></code> 或 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>，但是你如何匹配任意的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code>&nbsp;实例呢？你可以用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
            来解决这个问题。以下是匹配任意的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code> 实例：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">StdComplex</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            When given a grammar like this, Proto will deconstruct the grammar and
            the terminal it is being matched against and see if it can match all
            the constituents.<br>当给出这样一个语法时，Proto 将解构要匹配的语法和终结符，看看它是否可以匹配所有要素。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.intermediate_form.expression_introspection.if_and_not"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.if_and_not" title="if_&lt;&gt;, and_&lt;&gt;, and not_&lt;&gt;">
          <code class="literal">if_&lt;&gt;</code>, <code class="literal">and_&lt;&gt;</code>, and <code class="literal">not_&lt;&gt;</code></a>
</h5></div></div></div>
<p>
            We've already seen how to use expression generators like <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;&gt;</span></code>
            and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;&gt;</span></code>
            as grammars. We've also seen <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>,
            which we can use to express a set of alternate grammars. There are a
            few others of interest; in particular, <code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code>,
            <code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> and <code class="computeroutput"><a class="link" href="../boost/proto/not_.html" title="Struct template not_">proto::not_&lt;&gt;</a></code>.<br>我们已经看到如何把象 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;&gt;</span></code>
            这样的表达式生成器作为语法使用。我们也看到了 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>，我们可以用它来表达一组N选1的语法。还有另外几个有趣的模板：<code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code>,
            <code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/proto/not_.html" title="Struct template not_">proto::not_&lt;&gt;</a></code>。
          </p>
<p>
            The <code class="computeroutput"><a class="link" href="../boost/proto/not_.html" title="Struct template not_">proto::not_&lt;&gt;</a></code> template is the simplest.
            It takes a grammar as a template parameter and logically negates it;
            <code class="computeroutput"><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">Grammar</span><span class="special">&gt;</span></code>
            will match any expression that <code class="computeroutput"><span class="identifier">Grammar</span></code>
            does <span class="emphasis"><em>not</em></span> match.<br><code class="computeroutput"><a class="link" href="../boost/proto/not_.html" title="Struct template not_">proto::not_&lt;&gt;</a></code> 模板最为简单。它接受一个语法作为模板参数，并在逻辑上否定它；<code class="computeroutput"><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">Grammar</span><span class="special">&gt;</span></code> 将匹配 <code class="computeroutput"><span class="identifier">Grammar</span></code>
            不能匹配的任意表达式。
          </p>
<p>
            The <code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code> template is used
            together with a Proto transform that is evaluated against expression
            types to find matches. (Proto transforms will be described later.)<br><code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code> 模板与一个 Proto 变换一起使用，该变换对表达式类型进行求值以发现匹配(Proto 变换将在稍后讨论)。
          </p>
<p>
            The <code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> template is like
            <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>, except that each
            argument of the <code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> must match in order
            for the <code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> to match. As an example,
            consider the definition of <code class="computeroutput"><span class="identifier">CharString</span></code>
            above that uses <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code>. It could have been
            written without <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code> as follows:&nbsp;<br><code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> 模板类似于
            <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>，不过 <code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> 的每个参数必须都匹配，<code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code> 才能匹配。例如，考虑前面那个使用 <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code> 的 <code class="computeroutput"><span class="identifier">CharString</span></code>
            定义。它可以不用 <code class="computeroutput"><a class="link" href="../boost/proto/exact.html" title="Struct template exact">proto::exact&lt;&gt;</a></code>，改写为：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">CharString</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">and_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">if_</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span> <span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="special">&gt;()</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            This says that a <code class="computeroutput"><span class="identifier">CharString</span></code>
            must be a terminal, <span class="emphasis"><em>and</em></span> its value type must be the
            same as <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
            <span class="special">*</span></code>. Notice the template argument
            of <code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code>: <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span> <span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="special">&gt;()</span></code>. This is Proto transform that compares
            the value type of a terminal to <code class="computeroutput"><span class="keyword">char</span>
            <span class="keyword">const</span> <span class="special">*</span></code>.<br>这是说，一个 <code class="computeroutput"><span class="identifier">CharString</span></code>
            必须是一个终结符，<span style="font-style: italic;">且</span><span class="emphasis"><em></em></span>它的值类型必须与 <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
            <span class="special">*</span></code> 相同。注意，<code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code> 的模板参数：<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span> <span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="special">&gt;()</span></code>。这是一个 Proto 变换，它将一个终结符的值类型与 <code class="computeroutput"><span class="keyword">char</span>
            <span class="keyword">const</span> <span class="special">*</span></code> 进行比较。
          </p>
<p>
            The <code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code> template has a couple
            of variants. In addition to <code class="computeroutput"><span class="identifier">if_</span><span class="special">&lt;</span><span class="identifier">Condition</span><span class="special">&gt;</span></code> you can also say <code class="computeroutput"><span class="identifier">if_</span><span class="special">&lt;</span><span class="identifier">Condition</span><span class="special">,</span> <span class="identifier">ThenGrammar</span><span class="special">&gt;</span></code> and <code class="computeroutput"><span class="identifier">if_</span><span class="special">&lt;</span><span class="identifier">Condition</span><span class="special">,</span> <span class="identifier">ThenGrammar</span><span class="special">,</span> <span class="identifier">ElseGrammar</span><span class="special">&gt;</span></code>. These let you select one sub-grammar
            or another based on the <code class="computeroutput"><span class="identifier">Condition</span></code>.<br><code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code> 模板有几个变体。除了 <code class="computeroutput"><span class="identifier">if_</span><span class="special">&lt;</span><span class="identifier">Condition</span><span class="special">&gt;</span></code>，你还可以用 <code class="computeroutput"><span class="identifier">if_</span><span class="special">&lt;</span><span class="identifier">Condition</span><span class="special">,</span> <span class="identifier">ThenGrammar</span><span class="special">&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">if_</span><span class="special">&lt;</span><span class="identifier">Condition</span><span class="special">,</span> <span class="identifier">ThenGrammar</span><span class="special">,</span> <span class="identifier">ElseGrammar</span><span class="special">&gt;</span></code>。它们让你基于 <code class="computeroutput"><span class="identifier">Condition</span></code> 选择某个子语法或另一个子语法。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.intermediate_form.expression_introspection.switch"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch" title="Improving Compile Times With switch_&lt;&gt;"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.switch" title="Improving Compile Times With switch_&lt;&gt;">Improving Compile Times With <code class="literal">switch_&lt;&gt;</code> 用&nbsp;<code class="literal">switch_&lt;&gt;</code>&nbsp;改进编译时间<code class="literal"></code></a>
</h5></div></div></div>
<p>
            When your Proto grammar gets large, you'll start to run into some scalability
            problems with <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>, the construct you
            use to specify alternate sub-grammars. First, due to limitations in C++,
            <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code> can only accept up
            to a certain number of sub-grammars, controlled by the <code class="computeroutput"><span class="identifier">BOOST_PROTO_MAX_LOGICAL_ARITY</span></code> macro.
            This macro defaults to eight, and you can set it higher, but doing so
            will aggravate another scalability problem: long compile times. With
            <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>, alternate sub-grammars
            are tried in order -- like a series of cascading <code class="computeroutput"><span class="keyword">if</span></code>'s
            -- leading to lots of unnecessary template instantiations. What you would
            prefer instead is something like <code class="computeroutput"><span class="keyword">switch</span></code>
            that avoids the expense of cascading <code class="computeroutput"><span class="keyword">if</span></code>'s.
            That's the purpose of <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>;
            although less convenient than <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>,
            it improves compile times for larger grammars and does not have an arbitrary
            fixed limit on the number of sub-grammars.<br>当你的 Proto 语法变大时，你将会开始陷入到 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code> 所带来的一些可扩展性问题，它是你用于指定可选子语法的结构。首先，由于C++的限制，<code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code> 最多只能接受某个特定数量的子语法，这个数量由 <code class="computeroutput"><span class="identifier">BOOST_PROTO_MAX_LOGICAL_ARITY</span></code> 宏控制。这个宏缺省为8，你可以设高一点，但是这样做会加剧另一个可扩展性问题：更长的编译时间。使用
            <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code> 时，侯选的子语法是按顺序尝试的 -- 就象一系列层叠的 <code class="computeroutput"><span class="keyword">if</span></code>
            -- 导致了大量无用的模板实例化。你应该用一些类似于 <code class="computeroutput"><span class="keyword">switch</span></code>
            的东西来避免这些层叠 <code class="computeroutput"><span class="keyword">if</span></code> 的代价。这正是 <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code> 的目的；虽然它不如 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code> 方便，但是它在使用大量语法时改进了编译的时间，而且对于子语法的数量也没有一个固定的限制。
          </p>
<p>
            Let's illustrate how to use <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>
            by first writing a big grammar with <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            and then translating it to an equivalent grammar using <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>:<br>我们来示范一下如何使用 <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>，首先写用 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            写一个大语法，然后将它翻译为使用 <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code> 等价语法：
          </p>
<pre class="programlisting"><span class="comment">// Here is a big, inefficient grammar 以下是一个大的、低效的语法<br></span><span class="keyword">struct</span> <span class="identifier">ABigGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">negate</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">complement</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The above might be the grammar to a more elaborate calculator DSEL. Notice
            that since there are more than eight sub-grammars, we had to chain the
            sub-grammars with a nested <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            -- not very nice.<br>以上是为一个更为精细的计算器DSEL所编写的语法。注意，由于超过了8个子语法，所以我们必须用嵌套的 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            来串起这些子语法 -- 不够漂亮。
          </p>
<p>
            The idea behind <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>
            is to dispatch based on an expression's tag type to a sub-grammar that
            handles expressions of that type. To use <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>,
            you define a struct with a nested <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> template, specialized on tag
            types. The above grammar can be expressed using <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>
            as follows. It is described below.<br>在&nbsp;<code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>
            背后的想法是，基于一个表达式的标签类型来分派到处理该类型的表达式的子语法。要使用 <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>，你要定义一个结构，该结构要有一个以标签类型作为参数的嵌套 <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> 模板。上述语法可以用 <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code>
            表示如下。后面我们再讨论它。
          </p>
<pre class="programlisting"><span class="comment">// Redefine ABigGrammar more efficiently using proto::switch_&lt;&gt;<br>// 用 proto::switch_&lt;&gt; 重新定义一个更高效的 ABigGrammar<br></span><span class="keyword">struct</span> <span class="identifier">ABigGrammar</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span>
<span class="special">{</span>
    <span class="comment">// The primary template matches nothing: 主模板不匹配东西：<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">case_</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
    <span class="special">{};</span>
<span class="special">};</span>

<span class="comment">// Terminal expressions are handled here 终结符表达式在此处理<br></span><span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Non-terminals are handled similarly 非终结符类似地处理<br></span><span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">negate</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">negate</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">complement</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">complement</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">modulus</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus</span><span class="special">&lt;</span><span class="identifier">ABigGrammar</span><span class="special">,</span> <span class="identifier">ABigGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Define ABigGrammar in terms of ABigGrammarCases<br></span><span class="comment">// using proto::switch_&lt;&gt;<br>// 用 proto::switch_&lt;&gt; 根据 ABigGrammarCases 定义 ABigGrammar<br></span><span class="keyword">struct</span> <span class="identifier">ABigGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">switch_</span><span class="special">&lt;</span><span class="identifier">ABigGrammarCases</span><span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Matching an expression type <code class="computeroutput"><span class="identifier">E</span></code>
            against <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">switch_</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">&gt;</span></code>
            is equivalent to matching it against <code class="computeroutput"><span class="identifier">C</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">::</span><span class="identifier">proto_tag</span><span class="special">&gt;</span></code>. By dispatching on the expression's
            tag type, we can jump to the sub-grammar that handles expressions of
            that type, skipping over all the other sub-grammars that couldn't possibly
            match. If there is no specialization of <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> for a particular tag type, we
            select the primary template. In this case, the primary template inherits
            from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span></code>
            which matches no expressions.<br>用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">switch_</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">&gt;</span></code> 匹配某个表达式类型 <code class="computeroutput"><span class="identifier">E</span></code>，相当于用 <code class="computeroutput"><span class="identifier">C</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">::</span><span class="identifier">proto_tag</span><span class="special">&gt;</span></code> 来匹配它。通过按表达式的标签类型来分派，我们可以跳至处理该类型的表达式的子语法，跳过其它所有不可能匹配的子语法。如果某个特定标签类型没有相应的 <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> 特化，则我们选择主模板。在这个例子中，主模板派生自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span></code>，它不匹配任何表达式。
          </p>
<p>
            Notice the specialization that handles terminals:<br>留意处理终结符的特化：
          </p>
<pre class="programlisting"><span class="comment">// Terminal expressions are handled here 终结符表达式在此处理<br></span><span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span><span class="special">::</span><span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span></code> type by itself isn't enough
            to select an appropriate sub-grammar, so we use <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            to list the alternate sub-grammars that match terminals.&nbsp;<br>类型 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span></code> 本身不足以选择一个合适的子语法，所以我们用 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>
            来列出匹配终结符的候选子语法。
          </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top">

<p>
              You might be tempted to define your <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> specializations <span class="emphasis"><em>in
              situ</em></span> as follows:<br>你可能会象下面这样在原地定义你的 <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> 特化：</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">case_</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">{};</span>

    <span class="comment">// ERROR: not legal C++ 错误：不是合法的C++<br></span>    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;</span>
      <span class="comment">/* ... */</span>
<span class="special">};</span>
</pre>
<p>
            </p>

<p>
              Unfortunately, for arcane reasons, it is not legal to define an explicit
              nested specialization <span class="emphasis"><em>in situ</em></span> like this. It is,
              however, perfectly legal to define <span class="emphasis"><em>partial</em></span> specializations
              <span class="emphasis"><em>in situ</em></span>, so you can add a extra dummy template
              parameter that has a default, as follows:<br>不幸的是，由于某些原因，象这样在原地定义一个显式的嵌套特化是不合法的。但是，在原地定义偏特化则是合法的，所以你可以象下面这样增加一个有缺省值的哑模板参数：</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">ABigGrammarCases</span>
<span class="special">{</span>
    <span class="comment">// Note extra "Dummy" template parameter here: <br>    // 注意这里加了一个"哑"的模板参数：<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">Dummy</span> <span class="special">=</span> <span class="number">0</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">case_</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">{};</span>

    <span class="comment">// OK: "Dummy" makes this a partial specialization<br></span>    <span class="comment">// instead of an explicit specialization.<br>    // 可以："哑"参数使得这是一个偏特化而不是显式特化。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">Dummy</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">Dummy</span><span class="special">&gt;</span>
      <span class="comment">/* ... */</span>
<span class="special">};</span>
</pre>

<p>
            
              You might find this cleaner than defining explicit <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> specializations outside of
              their enclosing struct.<br>也许你会发现这种方法比在结构外部定义显式的 <code class="computeroutput"><span class="identifier">case_</span><span class="special">&lt;&gt;</span></code> 特化更为清晰。
            </p>
</td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.intermediate_form.expression_introspection.matching_vararg_expressions"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.matching_vararg_expressions" title="Matching Vararg Expressions">Matching
          Vararg Expressions 匹配可变参数的表达式</a>
</h5></div></div></div>
<p>
            Not all of C++'s overloadable operators are unary or binary. There is
            the oddball <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            -- the function call operator -- which can have any number of arguments.
            Likewise, with Proto you may define your own "operators" that
            could also take more that two arguments. As a result, there may be nodes
            in your Proto expression tree that have an arbitrary number of children
            (up to <code class="computeroutput"><span class="identifier">BOOST_PROTO_MAX_ARITY</span></code>,
            which is configurable). How do you write a grammar to match such a node?<br>并非所有的C++可重载操作符都是单参数或双参数的。有一个奇特的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            -- 函数调用操作符 -- 它可以带有任意数量的参数。同样，在 Proto 中你可以定义你自己的"操作符"来接受两个以上的参数。因此，在你的 Proto 表达式树中可能有某些节点带有任意数量的子节点(最多为 <code class="computeroutput"><span class="identifier">BOOST_PROTO_MAX_ARITY</span></code> 个，这是可配置的)。你如何编写一个可以匹配此类节点的语法呢？
          </p>
<p>
            For such cases, Proto provides the <code class="computeroutput"><a class="link" href="../boost/proto/vararg.html" title="Struct template vararg">proto::vararg&lt;&gt;</a></code>
            class template. Its template argument is a grammar, and the <code class="computeroutput"><a class="link" href="../boost/proto/vararg.html" title="Struct template vararg">proto::vararg&lt;&gt;</a></code> will match the grammar
            zero or more times. Consider a Proto lazy function called <code class="computeroutput"><span class="identifier">fun</span><span class="special">()</span></code>
            that can take zero or more characters as arguments, as follows:<br>对于这种情况，Proto 提供了 <code class="computeroutput"><a class="link" href="../boost/proto/vararg.html" title="Struct template vararg">proto::vararg&lt;&gt;</a></code>
            类模板。它的模板参数是一个语法，而且 <code class="computeroutput"><a class="link" href="../boost/proto/vararg.html" title="Struct template vararg">proto::vararg&lt;&gt;</a></code> 可以零次或多次匹配该语法。考虑一个名为 <code class="computeroutput"><span class="identifier">fun</span><span class="special">()</span></code> 的 Proto 惰性函数<code class="computeroutput"><span class="special"></span></code>，它可以接受零个或多个字符作为参数，如下：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">fun_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">FunTag</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">fun_tag</span> <span class="special">&gt;</span> <span class="special">{};</span>
<span class="identifier">FunTag</span><span class="special">::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">fun</span> <span class="special">=</span> <span class="special">{{}};</span>

<span class="comment">// example usage: 用例：<br></span><span class="identifier">fun</span><span class="special">();</span>
<span class="identifier">fun</span><span class="special">(</span><span class="char">'a'</span><span class="special">);</span>
<span class="identifier">fun</span><span class="special">(</span><span class="char">'a'</span><span class="special">,</span> <span class="char">'b'</span><span class="special">);</span>
<span class="special">...</span>
</pre>
<p>
            Below is the grammar that matches all the allowable invocations of <code class="computeroutput"><span class="identifier">fun</span><span class="special">()</span></code>:<br>以下是可以匹配所有可允许的 <code class="computeroutput"><span class="identifier">fun</span><span class="special">()</span></code> 调用的语法：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">FunCall</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span> <span class="identifier">FunTag</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">FunCall</span></code> grammar uses
            <code class="computeroutput"><a class="link" href="../boost/proto/vararg.html" title="Struct template vararg">proto::vararg&lt;&gt;</a></code> to match zero or
            more character literals as arguments of the <code class="computeroutput"><span class="identifier">fun</span><span class="special">()</span></code> function.<br>语法 <code class="computeroutput"><span class="identifier">FunCall</span></code> 使用 <code class="computeroutput"><a class="link" href="../boost/proto/vararg.html" title="Struct template vararg">proto::vararg&lt;&gt;</a></code> 来匹配零个或多个作为 <code class="computeroutput"><span class="identifier">fun</span><span class="special">()</span></code> 函数的参数的字符字面值。
          </p>
<p>
            As another example, can you guess what the following grammar matches?<br>作为另一个例子，你能猜出以下语法匹配什么吗？
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Foo</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span> <span class="identifier">Foo</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Here's a hint: the first template parameter to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;&gt;</span></code> represents the node type, and
            any additional template parameters represent child nodes. The answer
            is that this is a degenerate grammar that matches every possible expression
            tree, from root to leaves.<br>有一个提示：<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;&gt;</span></code> 的第一个模板参数表示节点的类型，其它参数则表示子节点。答案是，这是一个退化的语法，匹配任意一个可能的表达式树，从根到叶子。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.intermediate_form.expression_introspection.defining_dsel_grammars"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection.defining_dsel_grammars" title="Defining DSEL Grammars">Defining
          DSEL Grammars&nbsp;定义DSEL语法</a>
</h5></div></div></div>
<p>
            In this section we'll see how to use Proto to define a grammar for your
            DSEL and use it to validate expression templates, giving short, readable
            compile-time errors for invalid expressions.<br>在本节中，我们将看到如何使用 Proto 来为你的DSEL定义一个语法，并用它来验证表达式模板，为无效的表达式给出简短可读的编译期错误。
          </p>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top">
<p>
              You might think that this is a backwards way of doing things. “<span class="quote">If
              Proto let me select which operators to overload, my users wouldn't
              be able to create invalid expressions in the first place, and I wouldn't
              need a grammar at all!</span>” That may be true, but there are reasons
              for preferring to do things this way.<br>你可能会认为这是一个倒退的处理方式。“<span class="quote">如果
              Proto 让我选择哪个重载哪个操作符，那么我的用户一开始就不能创建无效的表达式，我也就根本不需要什么语法了！</span>” 这也许是对的，不过也有其它理由要这样做。
            </p>
<p>
              First, it lets you develop your DSEL rapidly -- all the operators are
              there for you already! -- and worry about invalid syntax later.<br>首先，它可以让你快速地开发你的DSEL -- 所有操作符都已经为你准备好了！ -- 只需要关心无效的语法就可以了。
            </p>
<p>
              Second, it might be the case that some operators are only allowed in
              certain contexts within your DSEL. This is easy to express with a grammar,
              and hard to do with straight operator overloading.<br>其次，有可能在你的DSEL中有些操作符只在特定的上下文中可用。这一点用语法可以很容易表达，而直接用操作符重载则很难。
            </p>
<p>
              Third, using a DSEL grammar to flag invalid expressions can often yield
              better errors than manually selecting the overloaded operators.<br>第三，用DSEL语法来标示无效表达式通常可以产生比手工选择操作符重载更好的错误提示。
            </p>
<p>
              Fourth, the grammar can be used for more than just validation. You
              can use your grammar to define <span class="emphasis"><em>tree transformations</em></span>
              that convert expression templates into other more useful objects.<br>第四，语法可以不仅用于验证。你可以用你的语法来定义<span class="emphasis"><em>树变换</em></span>，将表达式模板转换为更为有用的对象。
            </p>
<p>
              If none of the above convinces you, you actually <span class="emphasis"><em>can</em></span>
              use Proto to control which operators are overloaded within your domain.
              And to do it, you need to define a grammar!<br>如果以上理由都不能说服你，那么实际上你可以用 Proto 来控制在你的领域中重载哪些操作符。而要实现这一点，你需要定义一个语法！
            </p>
</td></tr>
</tbody></table></div>
<p>
            In a previous section, we used Proto to define a DSEL for a lazily evaluated
            calculator that allowed any combination of placeholders, floating-point
            literals, addition, subtraction, multiplication, division and grouping.
            If we were to write the grammar for this DSEL in <a href="http://en.wikipedia.org/wiki/Extended_Backus_Naur_Form" target="_top">EBNF</a>,
            it might look like this:<br>在上一节中，我们用 Proto 为一个惰性求值计算器下定义了一个DSEL，这个DSEL允许占位符、浮点字面值、加法、减法、乘法、除法和分组的任意组合。如果我们要用 <a href="http://en.wikipedia.org/wiki/Extended_Backus_Naur_Form" target="_top">EBNF</a> 为这个DSEL写一个语法，它看起来会是这样：
          </p>
<pre class="programlisting">group       ::= '(' expression ')'<br>factor      ::= double | '_1' | '_2' | group<br>term        ::= factor (('*' factor) | ('/' factor))*<br>expression  ::= term (('+' term) | ('-' term))*<br></pre>
<p>
            This captures the syntax, associativity and precedence rules of a calculator.
            Writing the grammar for our calculator DSEL using Proto is <span class="emphasis"><em>even
            simpler</em></span>. Since we are using C++ as the host language, we are
            bound to the associativity and precedence rules for the C++ operators.
            Our grammar can assume them. Also, in C++ grouping is already handled
            for us with the use of parenthesis, so we don't have to code that into
            our grammar.<br>这里包括了一个计算器的语法、结合律和优先级。用 Proto 编写我们的计算器DSEL语法<span style="font-style: italic;">更加简单</span>。因为我们以C++为宿主语言，所以我们绑定了C++操作符的结合律和优先级。我们的语法可以以此为前提。此外，在C++中，使用括号进行分组也已经为我们准备好了，因此我们不需要为这些在我们的语法中编写代码。
          </p>
<p>
            Let's begin our grammar for forward-declaring it:<br>我们从语法的前向声明开始：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">CalculatorGrammar</span><span class="special">;</span>
</pre>
<p>
            It's an incomplete type at this point, but we'll still be able to use
            it to define the rules of our grammar. Let's define grammar rules for
            the terminals:<br>此时，它是一个不完整的类型，不过我们还是可以用它来定义我们的语法规则。让我们来定义终结符的语法规则：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Double</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">convertible_to</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Placeholder1</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Placeholder2</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Terminal</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span> <span class="identifier">Double</span><span class="special">,</span> <span class="identifier">Placeholder1</span><span class="special">,</span> <span class="identifier">Placeholder2</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Now let's define the rules for addition, subtraction, multiplication
            and division. Here, we can ignore issues of associativity and precedence
            -- the C++ compiler will enforce that for us. We only must enforce that
            the arguments to the operators must themselves conform to the <code class="computeroutput"><span class="identifier">CalculatorGrammar</span></code> that we forward-declared
            above.<br>现在我们来定义加法、减法、乘法和除法的规则。这里，我们可以忽略结合律和优先级的问题 --&nbsp;C++编译器会为我们强制执行它。我们只需规定操作符的参数必须符合我们前面所声明的 <code class="computeroutput"><span class="identifier">CalculatorGrammar</span></code> 就可以了。
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Plus</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">CalculatorGrammar</span><span class="special">,</span> <span class="identifier">CalculatorGrammar</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Minus</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">CalculatorGrammar</span><span class="special">,</span> <span class="identifier">CalculatorGrammar</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Multiplies</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span> <span class="identifier">CalculatorGrammar</span><span class="special">,</span> <span class="identifier">CalculatorGrammar</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Divides</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span> <span class="identifier">CalculatorGrammar</span><span class="special">,</span> <span class="identifier">CalculatorGrammar</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Now that we've defined all the parts of the grammar, we can define <code class="computeroutput"><span class="identifier">CalculatorGrammar</span></code>:<br>现在我们已经定义了这个语法的全部，我们可以定义 <code class="computeroutput"><span class="identifier">CalculatorGrammar</span></code> 了：
          </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">CalculatorGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">Terminal</span>
      <span class="special">,</span> <span class="identifier">Plus</span>
      <span class="special">,</span> <span class="identifier">Minus</span>
      <span class="special">,</span> <span class="identifier">Multiplies</span>
      <span class="special">,</span> <span class="identifier">Divides</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            That's it! Now we can use <code class="computeroutput"><span class="identifier">CalculatorGrammar</span></code>
            to enforce that an expression template conforms to our grammar. We can
            use <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code> and <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code>
            to issue readable compile-time errors for invalid expressions, as below:<br>这就是它了！现在我们可以用 <code class="computeroutput"><span class="identifier">CalculatorGrammar</span></code>
            来强制某个表达式模板符合我们的语法。我们可以用 <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code> 和 <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code>
            来对无效表达式生成可读的编译期错误，如下：
          </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">CalculatorGrammar</span> <span class="special">&gt;</span> <span class="special">));</span>
    <span class="comment">// ...<br></span><span class="special">}</span>
</pre>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.back_end"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end" title="Back Ends: Making Expression Templates Do Useful Work"> Back Ends: Making
      Expression Templates Do Useful Work 后端：让表达式模板做有用的事情</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation">
        Expression Evaluation: Imparting Behaviors with a Context 表达式求值：用上下文来指定行为</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation">
        Expression Transformation: Semantic Actions 表达式变换：语义动作</a></span></dt>
</dl></div>
<p>
        Now that you've written the front end for your DSEL compiler, and you've
        learned a bit about the intermediate form it produces, it's time to think
        about what to <span class="emphasis"><em>do</em></span> with the intermediate form. This is
        where you put your domain-specific algorithms and optimizations. Proto gives
        you two ways to evaluate and manipulate expression templates: contexts and
        transforms.<br>现在你已经为你的DSEL编写了前端，也已经学习了一些关于它所生成的中间格式的知识，是时候考虑要对这个中间格式做些什么了。这就是你置入你的领域专用算法和优化的地方。Proto 为你提供了两种方法来对表达式模板进行求值和处理：上下文和变换。
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          A <span class="emphasis"><em>context</em></span> is like a function object that you pass
          along with an expression to the <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
          function. It associates behaviors with node types. <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
          walks the expression and invokes your context at each node.<br>
          <span class="emphasis"><em>上下文context</em></span> 类似于一个函数对象，你可以把它与某个表达式一起传递给 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
          函数。它将某些行为与节点类型关联起来。<code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
          对表达式进行遍历并在每个节点处调用你的上下文。
        </li>
<li>
          A <span class="emphasis"><em>transform</em></span> is a way to associate behaviors, not with
          node types in an expression, but with rules in a Proto grammar. In this
          way, they are like semantic actions in other compiler-construction toolkits.<br>
          <span class="emphasis"><em>变换transform</em></span> 是将某些行为与 Proto 语法中的规则而不是与表达式的节点类型相关联的方法。使用这种方法，类似于其它编译器构造工具中的语义动作。
        </li>
</ul></div>
<p>Two ways to evaluate expressions! How to choose? Since contexts are largely 
procedural, they are a bit simpler to understand and debug so they are a good 
place to start. But although transforms are more advanced, they are also more 
powerful; since they are associated with rules in your grammar, you can select 
the proper transform based on the entire <span class="emphasis"><em>structure</em></span> of a sub-expression rather than simply 
on the type of its top-most node.<br>有两种方法对表达式进行求值！如何选择？因为上下文基本上是过程性的，它们对于理解和调试来说更简单些，所以上下文是一个良好的开端。但是，变换更为高级，也更强大；因为它是与你的语法中的规则相关联的，你可以基于某个子表达式的整个<span style="font-style: italic;">结构</span>而不仅仅是顶层节点的类型来选择正确的变换。
      </p>
<p>
        Also, transforms have a concise and declarative syntax that can be confusing
        at first, but highly expressive and fungible once you become accustomed to
        it. And -- this is admittedly very subjective -- the author finds programming
        with Proto transforms to be an inordinate amount of <span class="emphasis"><em>fun!</em></span>
        Your mileage may vary.<br>另外，变换具有简明和声明性的语法，刚开始可能会有些混乱，但一旦你熟悉了它，就会发现它具有高度的表达力和可替代性。而且 -- 这一点公认是非常主观的 -- 作者发现，用 Proto 变换来编程具有更多的<span style="font-style: italic;">乐趣</span>！你的感觉可能会有所不同。
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.back_end.expression_evaluation"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation" title="Expression Evaluation: Imparting Behaviors with a Context">
        Expression Evaluation: Imparting Behaviors with a Context 表达式求值：用上下文指定行为</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.proto_eval"><span class="section"></span></a><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.proto_eval">
          Evaluating an Expression with <code class="literal">proto::eval()</code></a><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.proto_eval">
          用</a></span><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.proto_eval"><span class="section"></span></a><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.proto_eval"> <code class="literal">proto::eval()</code></a><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.proto_eval"> 求值一个表达式<code class="literal"></code></a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.contexts">
          Defining an Evaluation Context 定义一个求值上下文</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.canned_contexts">
          Proto's Built-In Contexts &nbsp; Proto的内建上下文</a></span></dt>
</dl></div>
<p>
          Once you have constructed a Proto expression tree, either by using Proto's
          operator overloads or with <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code>
          and friends, you probably want to actually <span class="emphasis"><em>do</em></span> something
          with it. The simplest option is to use <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>, a generic expression evaluator. To use
          <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>, you'll need to define
          a <span class="emphasis"><em>context</em></span> that tells <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
          how each node should be evaluated. This section goes through the nuts and
          bolts of using <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>, defining evaluation contexts,
          and using the contexts that Proto provides.<br>一旦你用 Proto 的操作符重载或是用 <code class="computeroutput"><a class="link" href="../boost/proto/make_expr_id3241566.html" title="Function make_expr">proto::make_expr()</a></code> 及其辅助物构造了一个 Proto 表达式树，你可能想要实实在在地用它来做些什么。最简单的方式是使用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>，它是一个泛型的表达式求值器。要使用
          <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>，你需要定义一个<span class="emphasis"><em>上下文</em></span>，告知 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
          如何对每个节点进行求值。本节将介绍使用 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>，定义求值上下文，以及使用 Proto 所提供的上下文等细节。
        </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
            <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
            is a less powerful but easier-to-use evaluation technique than Proto
            transforms, which are covered later. Although very powerful, transforms
            have a steep learning curve and can be more difficult to debug. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
            is a rather weak tree traversal algorithm. Dan Marsden has been working
            on a more general and powerful tree traversal library. When it is ready,
            I anticipate that it will eliminate the need for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>.<br><code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
            是比 Proto 变换稍弱但更易于使用的一种求值技术，稍后我们将会讨论到 Proto 变换。变换虽然很强大，但是却具有陡峭的学习曲线，而且很难调试。<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code> 则是一种相对较弱的树遍历算法。Dan Marsden 已经在开发一个更为通用和强大的树遍历程序库。当他完成时，我期望它可以完全替代 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>。
          </p></td></tr>
</tbody></table></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_evaluation.proto_eval"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.proto_eval" title="Evaluating an Expression with proto::eval()">
          Evaluating an Expression with <code class="literal">proto::eval()</code>&nbsp;用&nbsp;<code class="literal">proto::eval()</code>&nbsp;求值一个表达式</a></h5></div></div></div>
<div class="blockquote"><blockquote class="blockquote">
<p>
              </p>
<p>
                <span class="bold"><strong>Synopsis:&nbsp;<br>摘要：</strong></span>
              </p>
<p>
            </p>
</blockquote></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">proto</span>
<span class="special">{</span>
    <span class="keyword">namespace</span> <span class="identifier">result_of</span>
    <span class="special">{</span>
        <span class="comment">// A metafunction for calculating the return<br></span>        <span class="comment">// type of proto::eval() given certain Expr<br></span>        <span class="comment">// and Context types.<br>        // 用于计算给定了Expr和Context类型的proto::eval()的返回类型的元函数<br></span>        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
        <span class="keyword">struct</span> <span class="identifier">eval</span>
        <span class="special">{</span>
            <span class="keyword">typedef</span>
                <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">::</span><span class="keyword">template</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">result_type</span>
            <span class="identifier">type</span><span class="special">;</span>
        <span class="special">};</span>
    <span class="special">}</span>

    <span class="keyword">namespace</span> <span class="identifier">functional</span>
    <span class="special">{</span>
        <span class="comment">// A callable function object type for evaluating<br></span>        <span class="comment">// a Proto expression with a certain context.<br>        // 用于以特定上下文对一个Proto表达式进行求值的可调用函数对象<br></span>        <span class="keyword">struct</span> <span class="identifier">eval</span> <span class="special">:</span> <span class="identifier">callable</span>
        <span class="special">{</span>
            <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sig</span><span class="special">&gt;</span>
            <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

            <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
            <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Context</span><span class="special">&gt;::</span><span class="identifier">type</span>
            <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Context</span> <span class="special">&amp;</span><span class="identifier">context</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

            <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
            <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Context</span><span class="special">&gt;::</span><span class="identifier">type</span>
            <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">context</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="special">};</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Context</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">eval</span><span class="special">(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Context</span> <span class="special">&amp;</span><span class="identifier">context</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Context</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">eval</span><span class="special">(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">context</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Given an expression and an evaluation context, using <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
            is quite simple. Simply pass the expression and the context to <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> and it does the rest
            and returns the result. You can use the <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code> metafunction in the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span></code> namespace to compute the
            return type of <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>. The following demonstrates
            a use of <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>:<br>给定一个表达式和一个求值上下文，使用 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>
            是很简单的。只要将表达式和上下文传递给 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 就可以了，它会完成剩余的任务并返回结果。你可以用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span></code> 名字空间中的 <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code> 元函数来计算 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 的返回类型。以下示范了 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 的使用：
          </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">MyContext</span><span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">MyEvaluate</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Some user-defined context type 用户定义的上下文类型<br></span>    <span class="identifier">MyContext</span> <span class="identifier">ctx</span><span class="special">;</span>

    <span class="comment">// Evaluate an expression with the context 以该上下文对一个表达式求值<br></span>    <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            What <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> does is also very simple.
            It defers most of the work to the context itself. Here essentially is
            the implementation of <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code>:<br><code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 所做的也很简单。它将多数工作推给上下文本身。以下是 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 的实现：
          </p>
<pre class="programlisting"><span class="comment">// eval() dispatches to a nested "eval&lt;&gt;" function<br></span><span class="comment">// object within the Context:<br>// eval()分派至Context内嵌的一个"eval&lt;&gt;"函数对象：<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">::</span><span class="keyword">template</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">result_type</span>
<span class="identifier">eval</span><span class="special">(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Context</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">::</span><span class="keyword">template</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;</span> <span class="identifier">eval_fun</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">eval_fun</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Really, <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> is nothing more than
            a thin wrapper that dispatches to the appropriate handler within the
            context class. In the next section, we'll see how to implement a context
            class from scratch.<br>其实，<code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 只是一个很薄的包装器，将任务分派至上下文类中适当的处理者。在下一节中，我们将看到如何从零开始实现一个上下文类。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_evaluation.contexts"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.contexts" title="Defining an Evaluation Context">
          Defining an Evaluation Context 定义一个求值上下文</a>
</h5></div></div></div>
<p>
            As we saw in the previous section, there is really not much to the <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> function. Rather, all
            the interesting expression evaluation goes on within a context class.
            This section shows how to implement one from scratch.<br>正如我们在上一节中所看到的，对于 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 函数确实没有更多东西了。相反，表达式求值的所有有趣动作都是在上下文类的内部。本节将展示如何如何从零开始实现一个上下文。
          </p>
<p>
            All context classes have roughly the following form:<br>所有的上下文类都大概是以下形式：
          </p>
<pre class="programlisting"><span class="comment">// A prototypical user-defined context. 一个proto型的用户自定义上下文。<br></span><span class="keyword">struct</span> <span class="identifier">MyContext</span>
<span class="special">{</span>
    <span class="comment">// A nested eval&lt;&gt; class template 嵌套的eval&lt;&gt;类模板<br></span>    <span class="keyword">template</span><span class="special">&lt;</span>
        <span class="keyword">typename</span> <span class="identifier">Expr</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Tag</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag_of</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">;</span>

    <span class="comment">// Handle terminal nodes here... 在此处理终结符节点...<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="comment">// Must have a nested result_type typedef. 必须有一个嵌套的result_type typedef.<br></span>        <span class="keyword">typedef</span> <span class="special">...</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="comment">// Must have a function call operator that takes<br></span>        <span class="comment">// an expression and the context.<br>        // 必须有一个函数调用操作符，接受一个表达式及本上下文。<br></span>        <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">MyContext</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="special">...;</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="comment">// ... other specializations of struct eval&lt;&gt; ... ...其它的struct eval&lt;&gt;特化...<br></span><span class="special">};</span>
</pre>
<p>
            Context classes are nothing more than a collection of specializations
            of a nested <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code>
            class template. Each specialization handles a different expression type.<br>上下文类其实就是一组嵌套的 <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code>
            类型模板的特化。每一个特化处理一种不同的表达式类型。
          </p>
<p>
            In the <a class="link" href="../">Hello
            Calculator</a> section, we saw an example of a user-defined context
            class for evaluating calculator expressions. That context class was implemented
            with the help of Proto's <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>.
            If we were to implement it from scratch, it would look something like
            this:<br>在 <a class="link" href="../">Hello
            Calculator</a> 一节中，我们看过一个用户自定义上下文的例子，用于对计算器表达式进行求值。那个上下文类是在 Proto 的 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code> 的帮助下实现的。如果我们要从零开始实现它，它看起来会是象这样：
          </p>
<pre class="programlisting"><span class="comment">// The calculator_context from the "Hello Calculator" section,<br></span><span class="comment">// implemented from scratch.<br>// 从零开始实现"Hello Calculator"一节中的calculator_context。<br></span><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
<span class="special">{</span>
    <span class="comment">// The values with which we'll replace the placeholders<br>    // 我们准备用于替换占位符的值。<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">args</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span>
        <span class="keyword">typename</span> <span class="identifier">Expr</span>
        <span class="comment">// defaulted template parameters, so we can<br></span>        <span class="comment">// specialize on the expressions that need<br></span>        <span class="comment">// special handling.<br>        // 缺省的模板参数，这样我们就可以对需要特殊处理的表达式进行特化。<br></span>      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Tag</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag_of</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg0</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="number">0</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">;</span>

    <span class="comment">// Handle placeholder terminals here... 在此处理占位符终结符...<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;,</span> <span class="identifier">MyContext</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">I</span><span class="special">];</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="comment">// Handle other terminals here... 在此处理其它终结符...<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg0</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">Arg0</span><span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">MyContext</span> <span class="special">&amp;)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">child</span><span class="special">(</span><span class="identifier">expr</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="comment">// Handle addition here... 在此处理加法...<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg0</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span><span class="special">,</span> <span class="identifier">Arg0</span><span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">MyContext</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">left</span><span class="special">(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">ctx</span><span class="special">)</span>
                 <span class="special">+</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">right</span><span class="special">(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">ctx</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="comment">// ... other eval&lt;&gt; specializations for other node types ...<br>    // ...对于其它节点类型的eval&lt;&gt;特化...<br></span><span class="special">};</span>
</pre>
<p>
            Now we can use <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> with the context class
            above to evaluate calculator expressions as follows:<br>现在我们可以以这个上下文类来用 <code class="computeroutput"><a class="link" href="../boost/proto/eval_id3236349.html" title="Function eval">proto::eval()</a></code> 对计算器表达式进行求值，如下：
          </p>
<pre class="programlisting"><span class="comment">// Evaluate an expression with a calculator_context <br>// 用一个calculator_context对一个表达式进行求值<br></span><span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">5</span><span class="special">);</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">6</span><span class="special">);</span>
<span class="keyword">double</span> <span class="identifier">d</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">_1</span> <span class="special">+</span> <span class="identifier">_2</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="number">11</span> <span class="special">==</span> <span class="identifier">d</span><span class="special">);</span>
</pre>
<p>
            Defining a context from scratch this way is tedious and verbose, but
            it gives you complete control over how the expression is evaluated. The
            context class in the <a class="link" href="../">Hello
            Calculator</a> example was much simpler. In the next section we'll
            see the helper class Proto provides to ease the job of implementing context
            classes.<br>这种从零开始定义一个上下文的方法是沉闷而冗长的，但是它可以让你完成控制如何对表达式进行求值。在 <a class="link" href="../">Hello
            Calculator</a> 的例子中的上下文类更为简单。在下一节，我们将看到 Proto 所提供的辅助类，它们可以让实现上下文类的工作变得更为容易。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_evaluation.canned_contexts"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.canned_contexts" title="Proto's Built-In Contexts">
          Proto's Built-In Contexts &nbsp;Proto的内建上下文</a>
</h5></div></div></div>
<p>
            Proto provides some ready-made context classes that you can use as-is,
            or that you can use to help while implementing your own contexts. They
            are:<br>Proto 提供了一些可用的上下文类，你可以原样照用，或者用它们来帮助你实现自己的上下文。它们包括：
          </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"><a class="link" href="../"><code class="literal">default_context</code></a></span></dt>
<dd><p>
                An evaluation context that assigns the usual C++ meanings to all
                the operators. For example, addition nodes are handled by evaluating
                the left and right children and then adding the results. The <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>
                uses Boost.Typeof to deduce the types of the expressions it evaluates.<br>为所有操作符赋予通常的C++意义的求值上下文。例如，加法节点的处理方法是，对左、右子节点求值，然后将结果相加。<code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>
                使用了 Boost.Typeof 来推断所求值的表达式的类型。
              </p></dd>
<dt><span class="term"><a class="link" href="../"><code class="literal">null_context</code></a></span></dt>
<dd><p>
                A simple context that recursively evaluates children but does not
                combine the results in any way and returns void.<br>一个简单的上下文，递归地对子节点进行求值，但不以任何方式对结果进行组合，返回 void。
              </p></dd>
<dt><span class="term"><a class="link" href="../"><code class="literal">callable_context&lt;&gt;</code></a></span></dt>
<dd><p>
                A helper that simplifies the job of writing context classes. Rather
                than writing template specializations, with <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
                you write a function object with an overloaded function call operator.
                Any expressions not handled by an overload are automatically dispatched
                to a default evaluation context that you can specify.<br>帮助简化编写上下文类的工作的助手。使用 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>，不再需要编写模板特化，而是以重载的函数调用操作符编写一个函数对象。任何没有被重载进行处理的表达式将自动分派至你指定的某个缺省求值上下文。
              </p></dd>
</dl>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h6 class="title">
<a name="boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.default_context"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.default_context" title="default_context">
            <code class="literal">default_context</code></a>
</h6></div></div></div>
<p>
              The <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code> is an
              evaluation context that assigns the usual C++ meanings to all the operators.
              For example, addition nodes are handled by evaluating the left and
              right children and then adding the results. The <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code> uses
              Boost.Typeof to deduce the types of the expressions it evaluates.<br><code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code> 是一个为所有操作符赋予普通的C++意义的求值上下文。例如，加法节点的处理方法是，对左、右子节点求值，然后将结果相加。<code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>
                使用了 Boost.Typeof 来推断所求值的表达式的类型。
            </p>
<p>
              For example, consider the following "Hello World" example:<br>例如，考虑以下 "Hello World" 示例：
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">ostream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>

<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Evaluate the expression with default_context,<br></span>    <span class="comment">// to give the operators their C++ meanings:<br>    // 以default_context对表达式求值，给予操作符本身的C++意义：<br></span>    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_context</span> <span class="identifier">ctx</span><span class="special">;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="string">"hello"</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="string">" world"</span> <span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              This program outputs the following:<br>该程序的输出如下：
            </p>
<pre class="programlisting">hello, world<br></pre>
<p>
              <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code> is trivially
              defined in terms of a <code class="computeroutput"><span class="identifier">default_eval</span><span class="special">&lt;&gt;</span></code> template, as follows:<br><code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code> 是很简单地根据一个 <code class="computeroutput"><span class="identifier">default_eval</span><span class="special">&lt;&gt;</span></code> 模板来定义的，如下：
            </p>
<pre class="programlisting"><span class="comment">// Definition of default_context  default_context的定义<br></span><span class="keyword">struct</span> <span class="identifier">default_context</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">default_eval</span><span class="special">&lt;</span>
            <span class="identifier">Expr</span>
          <span class="special">,</span> <span class="identifier">default_context</span> <span class="keyword">const</span>
          <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">tag_of</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span>
        <span class="special">&gt;</span>
    <span class="special">{};</span>
<span class="special">};</span>
</pre>
<p>
              There are a bunch of <code class="computeroutput"><span class="identifier">default_eval</span><span class="special">&lt;&gt;</span></code> specializations, each of which
              handles a different C++ operator. Here, for instance, is the specialization
              for binary addition:<br>有一组 <code class="computeroutput"><span class="identifier">default_eval</span><span class="special">&lt;&gt;</span></code> 特化，每一个特化处理一个C++操作符。例如，以下是对二元加法的特化：
            </p>
<pre class="programlisting"><span class="comment">// A default expression evaluator for binary addition 对二元加法的缺省表达式求值器<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">default_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Context</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">static</span> <span class="identifier">Expr</span>    <span class="special">&amp;</span> <span class="identifier">s_expr</span><span class="special">;</span>
    <span class="keyword">static</span> <span class="identifier">Context</span> <span class="special">&amp;</span> <span class="identifier">s_ctx</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span>
        <span class="identifier">decltype</span><span class="special">(</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">s_expr</span><span class="special">),</span> <span class="identifier">s_ctx</span><span class="special">)</span>
          <span class="special">+</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">s_expr</span><span class="special">),</span> <span class="identifier">s_ctx</span><span class="special">)</span>
        <span class="special">)</span>
    <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Context</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">ctx</span><span class="special">)</span>
             <span class="special">+</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
              The above code uses <code class="computeroutput"><span class="identifier">decltype</span></code>
              to calculate the return type of the function call operator. <code class="computeroutput"><span class="identifier">decltype</span></code> is a new keyword in the
              next version of C++ that gets the type of any expression. Most compilers
              do not yet support <code class="computeroutput"><span class="identifier">decltype</span></code>
              directly, so <code class="computeroutput"><span class="identifier">default_eval</span><span class="special">&lt;&gt;</span></code> uses the Boost.Typeof library
              to emulate it. On some compilers, that may mean that <code class="computeroutput"><span class="identifier">default_context</span></code> either doesn't work
              or that it requires you to register your types with the Boost.Typeof
              library. Check the documentation for Boost.Typeof to see.<br>以上代码使用了 <code class="computeroutput"><span class="identifier">decltype</span></code>
              来计算函数调用操作符的返回类型。<code class="computeroutput"><span class="identifier">decltype</span></code> 是下一个C++版本中的新关键字，它取出任一表达式的类型。多数编译器尚未直接支持 <code class="computeroutput"><span class="identifier">decltype</span></code>，所以 <code class="computeroutput"><span class="identifier">default_eval</span><span class="special">&lt;&gt;</span></code> 使用 Boost.Typeof 库来模拟它。在某些编译器上，这可能意味着 <code class="computeroutput"><span class="identifier">default_context</span></code> 不能工作，或是要求你要将你的类型注册到 Boost.Typeof
              库。请查阅 Boost.Typeof 相关文档。
            </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h6 class="title">
<a name="boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.null_context"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.null_context" title="null_context">
            <code class="literal">null_context</code></a>
</h6></div></div></div>
<p>
              The <code class="computeroutput"><a class="link" href="../boost/proto/context/null_context.html" title="Struct null_context">proto::null_context&lt;&gt;</a></code>
              is a simple context that recursively evaluates children but does not
              combine the results in any way and returns void. It is useful in conjunction
              with <code class="computeroutput"><span class="identifier">callable_context</span><span class="special">&lt;&gt;</span></code>, or when defining your own
              contexts which mutate an expression tree in-place rather than accumulate
              a result, as we'll see below.<br><code class="computeroutput"><a class="link" href="../boost/proto/context/null_context.html" title="Struct null_context">proto::null_context&lt;&gt;</a></code> 是一个简单的上下文，递归地对子节点进行求值，但不以任何方式对结果进行组合，返回 void。它可以与 <code class="computeroutput"><span class="identifier">callable_context</span><span class="special">&lt;&gt;</span></code> 一起使用，或是在定义那些要就地修改表达式树而不是要计算结果的上下文时使用，稍后我们将看到相关示例。
            </p>
<p>
              <code class="computeroutput"><a class="link" href="../boost/proto/context/null_context.html" title="Struct null_context">proto::null_context&lt;&gt;</a></code>
              is trivially implemented in terms of <code class="computeroutput"><span class="identifier">null_eval</span><span class="special">&lt;&gt;</span></code> as follows:<br><code class="computeroutput"><a class="link" href="../boost/proto/context/null_context.html" title="Struct null_context">proto::null_context&lt;&gt;</a></code>
              是很简单地根据 <code class="computeroutput"><span class="identifier">null_eval</span><span class="special">&lt;&gt;</span></code> 来实现的，如下：
            </p>
<pre class="programlisting"><span class="comment">// Definition of null_context  null_context的定义<br></span><span class="keyword">struct</span> <span class="identifier">null_context</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">null_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">null_context</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_arity</span><span class="special">::</span><span class="identifier">value</span><span class="special">&gt;</span>
    <span class="special">{};</span>
<span class="special">};</span>
</pre>
<p>
              And <code class="computeroutput"><span class="identifier">null_eval</span><span class="special">&lt;&gt;</span></code>
              is also trivially implemented. Here, for instance is a binary <code class="computeroutput"><span class="identifier">null_eval</span><span class="special">&lt;&gt;</span></code>:<br><code class="computeroutput"><span class="identifier">null_eval</span><span class="special">&lt;&gt;</span></code>
              的实现也很简单。例如，以上是一个二元的 <code class="computeroutput"><span class="identifier">null_eval</span><span class="special">&lt;&gt;</span></code>：
            </p>
<pre class="programlisting"><span class="comment">// Binary null_eval&lt;&gt;  二元null_eval&lt;&gt;<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">null_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">Context</span><span class="special">,</span> <span class="number">2</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Context</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">ctx</span><span class="special">);</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
              When would such classes be useful? Imagine you have an expression tree
              with integer terminals, and you would like to increment each integer
              in-place. You might define an evaluation context as follows:<br>这样的类在什么时候有用呢？想象一下，你有一个带整数终结符的表达式树，你想就地将每个整数加一。你可以如下定义一个求值上下文：
            </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">increment_ints</span>
<span class="special">{</span>
    <span class="comment">// By default, just evaluate all children by delegating<br></span>    <span class="comment">// to the null_eval&lt;&gt;<br>    // 缺省时，委派至null_eval&lt;&gt;时只对子节点求值<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">null_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">increment_ints</span> <span class="keyword">const</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="comment">// Increment integer terminals 将整数终结符加一<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">increment_ints</span> <span class="keyword">const</span> <span class="special">&amp;)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="special">++</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">child</span><span class="special">(</span><span class="identifier">expr</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
              In the next section on <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>,
              we'll see an even simpler way to achieve the same thing.<br>在下一节的 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code> 中，我们将看到一个完成相同任务的更为简单的方法。
            </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h6 class="title">
<a name="boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.callable_context"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_evaluation.canned_contexts.callable_context" title="callable_context&lt;&gt;">
            <code class="literal">callable_context&lt;&gt;</code></a>
</h6></div></div></div>
<p>
              The <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              is a helper that simplifies the job of writing context classes. Rather
              than writing template specializations, with <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              you write a function object with an overloaded function call operator.
              Any expressions not handled by an overload are automatically dispatched
              to a default evaluation context that you can specify.<br><code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              是一个帮助简化编写上下文类的工作的助手。使用 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>，不再需要编写模板特化，而是以重载的函数调用操作符编写一个函数对象。任何没有被重载进行处理的表达式将自动分派至你指定的某个缺省求值上下文。
            </p>
<p>
              Rather than an evaluation context in its own right, <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              is more properly thought of as a context adaptor. To use it, you must
              define your own context that inherits from <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>.<br>与其说它是一个求值上下文，不如说 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              是一个上下文适配器更为恰当。要使用它，你必须从 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code> 派生你自己的上下文。
            </p>
<p>
              In the <a class="link" href="../"><code class="literal">null_context</code></a>
              section, we saw how to implement an evaluation context that increments
              all the integers within an expression tree. Here is how to do the same
              thing with the <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>:<br>在 <a class="link" href="../"><code class="literal">null_context</code></a>
              一节中，我们看到了如何实现一个对表达式树中所有整数进行加一运算的求值上下文。以下是如何用 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code> 完成相同任务的方法：
            </p>
<pre class="programlisting"><span class="comment">// An evaluation context that increments all<br></span><span class="comment">// integer terminals in-place.<br>// 将所有整数终结符就地加一的求值上下文<br></span><span class="keyword">struct</span> <span class="identifier">increment_ints</span>
  <span class="special">:</span> <span class="identifier">callable_context</span><span class="special">&lt;</span>
        <span class="identifier">increment_ints</span> <span class="keyword">const</span> <span class="comment">// derived context 派生的上下文<br></span>      <span class="special">,</span> <span class="identifier">null_context</span> <span class="keyword">const</span>  <span class="comment">// fall-back context 后传的上下文<br></span>    <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Handle int terminals here: 在此处理终结符<br></span>    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">&amp;</span><span class="identifier">i</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="special">++</span><span class="identifier">i</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
              With such a context, we can do the following:<br>用这个上下文，我们可以做：
            </p>
<pre class="programlisting"><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">j</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="identifier">i</span> <span class="special">-</span> <span class="identifier">j</span> <span class="special">*</span> <span class="number">3.14</span><span class="special">,</span> <span class="identifier">increment_ints</span><span class="special">()</span> <span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"i = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"j = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">j</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
              This program outputs the following, which shows that the integers
              <code class="computeroutput"><span class="identifier">i</span></code> and <code class="computeroutput"><span class="identifier">j</span></code> have been incremented by <code class="computeroutput"><span class="number">1</span></code>:<br>该程序输出如下，其中显示整数
              <code class="computeroutput"><span class="identifier">i</span></code> 和 <code class="computeroutput"><span class="identifier">j</span></code> 都加了 <code class="computeroutput"><span class="number">1</span></code>:
            </p>
<pre class="programlisting">i = 1<br>j = 11<br></pre>
<p>
              In the <code class="computeroutput"><span class="identifier">increment_ints</span></code>
              context, we didn't have to define any nested <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code> templates. That's because
              <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              implements them for us. <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              takes two template parameters: the derived context and a fall-back
              context. For each node in the expression tree being evaluated, <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code> checks to see if
              there is an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> in the derived context that accepts
              it. Given some expression <code class="computeroutput"><span class="identifier">expr</span></code>
              of type <code class="computeroutput"><span class="identifier">Expr</span></code>, and a
              context <code class="computeroutput"><span class="identifier">ctx</span></code>, it attempts
              to call:<br>在&nbsp;<code class="computeroutput"><span class="identifier">increment_ints</span></code>
              上下文中，我们不需要定义嵌套的 <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code> 模板。这是因为
              <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              已经为我们实现了它们。<code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code> 带有两个模板参数：派生的上下文和后传的上下文。对于被求值表达式树中的每个节点，<code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code> 检查在派生上下文中是否有一个重载的 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 接受它。给定类型为 <code class="computeroutput"><span class="identifier">Expr</span></code> 的表达式 <code class="computeroutput"><span class="identifier">expr</span></code>，以及一个上下文 <code class="computeroutput"><span class="identifier">ctx</span></code>，它尝试调用：
            </p>
<pre class="programlisting"><span class="identifier">ctx</span><span class="special">(</span>
    <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_tag</span><span class="special">()</span>
  <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">)</span>
  <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">...</span>
<span class="special">);</span>
</pre>
<p>
              Using function overloading and metaprogramming tricks, <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              can detect at compile-time whether such a function exists or not. If
              so, that function is called. If not, the current expression is passed
              to the fall-back evaluation context to be processed.<br>通过使用函数重载和元编程技巧，<code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              可以在编译期检测出是否有一个这样的函数存在。如果有，则调用该函数。如果没有，则将当前表达式传递给后传上下文来处理。
            </p>
<p>
              We saw another example of the <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              when we looked at the simple calculator expression evaluator. There,
              we wanted to customize the evaluation of placeholder terminals, and
              delegate the handling of all other nodes to the <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>. We did
              that as follows:<br>我们来看 <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              的另一个例子，我们看一个简单的计算器表达式求值器。我们想定制对占位符终结符的求值，并将所有其它节点的处理委派给 <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>。我们可以这样做：
            </p>
<pre class="programlisting"><span class="comment">// An evaluation context for calculator expressions that<br></span><span class="comment">// explicitly handles placeholder terminals, but defers the<br></span><span class="comment">// processing of all other nodes to the default_context.<br>// 一个计算器表达式的求值上下文，显式地处理占位符终结符，而将所有其它节点的处理交给 default_context.<br></span><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">args</span><span class="special">;</span>

    <span class="comment">// Define the result type of the calculator. 定义计算器的返回类型。<br></span>    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Handle the placeholders: 处理占位符：<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">I</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
              In this case, we didn't specify a fall-back context. In that case,
              <code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              uses the <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>. With
              the above <code class="computeroutput"><span class="identifier">calculator_context</span></code>
              and a couple of appropriately defined placeholder terminals, we can
              evaluate calculator expressions, as demonstrated below:<br>在这个例子中，我们没有指定后传上下文。为此，<code class="computeroutput"><a class="link" href="../boost/proto/context/callable_context.html" title="Struct template callable_context">proto::callable_context&lt;&gt;</a></code>
              使用了 <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>。使用以上 <code class="computeroutput"><span class="identifier">calculator_context</span></code> 以及一些适当定义的占位符终结符，我们可以对计算器表达式求值，示范如下：
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder</span>
<span class="special">{};</span>

<span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="comment">// ...<br></span>
<span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">4</span><span class="special">);</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">5</span><span class="special">);</span>

<span class="keyword">double</span> <span class="identifier">j</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">,</span> <span class="identifier">ctx</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"j = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">j</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
              The above code displays the following:<br>以上代码输出如下：
            </p>
<pre class="programlisting">j = 20<br></pre>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation" title="Expression Transformation: Semantic Actions">
        Expression Transformation: Semantic Actions 表达式变换：语义动作</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.__activating__your_grammars">“<span class="quote">Activating</span>”
          Your Grammars "激活"你的语法</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.handling_alternation_and_recursion">Handling
          Alternation and Recursion 处理多选和递归</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.callable_transforms">Callable
          Transforms 可调用变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.object_transforms">Object
          Transforms 对象变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.example__calculator_arity">Example:
          Calculator Arity 示例：计算器arity</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.state">
          Transforms With State Accumulation 带状态累计的变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.data">
          Passing Auxiliary Data to Transforms 传递辅助数据给变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms">
          Proto's Built-In Transforms &nbsp;Proto的内建变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.primitives">
          Building Custom Primitive Transforms 构建定制的基本变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.is_callable">
          Making Your Transform Callable 让你的变换可调用</a></span></dt>
</dl></div>
<p>
          If you have ever built a parser with the help of a tool like Antlr, yacc
          or Boost.Spirit, you might be familiar with <span class="emphasis"><em>semantic actions</em></span>.
          In addition to allowing you to define the grammar of the language recognized
          by the parser, these tools let you embed code within your grammar that
          executes when parts of the grammar participate in a parse. Proto has the
          equivalent of semantic actions. They are called <span class="emphasis"><em>transforms</em></span>.
          This section describes how to embed transforms within your Proto grammars,
          turning your grammars into function objects that can manipulate or evaluate
          expressions in powerful ways.<br>如果你曾经在某个工具，如 Antlr, yacc 或 Boost.Spirit，的帮助下构建过一个词法分析器，你可能会知道<span class="emphasis"><em>语义动作</em></span>。除了可以让你定义词法分析器所识别的语言的语法之外，这些工具还可以让你将一些代码嵌入到你的语法中，当这部分语法在分析时可以执行这些代码。Proto 也有与语义动作相当的东西。它们被称为<span class="emphasis"><em>变换</em></span>。本节将描述如何将变换嵌入到你的 Proto 语法中，将你的语法变为函数对象，以更强大的方式来操纵表达式和进行求值。
        </p>
<p>
          Proto transforms are an advanced topic. We'll take it slow, using examples
          to illustrate the key concepts, starting simple.<br>Proto 变换是一个高级议题。我们会慢慢讲，用一些例子来示范其中的关键概念，先从简单的开始。
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.__activating__your_grammars"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.__activating__your_grammars" title="“Activating” Your Grammars">“<span class="quote">Activating</span>”
          Your Grammars "激活"你的语法</a>
</h5></div></div></div>
<p>
            The Proto grammars we've seen so far are static. You can check at compile-time
            to see if an expression type matches a grammar, but that's it. Things
            get more interesting when you give them runtime behaviors. A grammar
            with embedded transforms is more than just a static grammar. It is a
            function object that accepts expressions that match the grammar and does
            <span class="emphasis"><em>something</em></span> with them.&nbsp;<br>到
目前为止，我们见到的 Proto
语法都是静态的。你可以在编译期检查某个表达式类型是否与语法匹配，仅此而已。如果你给予它们运行期行为，则事情会更有趣。嵌入了变换的语法不再仅仅是一
个静态语法而已。它是一个函数对象，接受与此语法匹配的表达式，并会对它们做些事情。
          </p>
<p>
            Below is a very simple grammar. It matches terminal expressions.<br>以下是一个更深简单的语法。它匹配终结符表达式。
          </p>
<pre class="programlisting"><span class="comment">// A simple Proto grammar that matches all terminals<br>// 一个匹配所有终结符的简单的 Proto 语法<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">_</span> <span class="special">&gt;</span>
</pre>
<p>
            Here is the same grammar with a transform that extracts the value from
            the terminal:<br>以下是一个相同的语法，带有一个从终结符取出值的变换：
          </p>
<pre class="programlisting"><span class="comment">// A simple Proto grammar that matches all terminals<br></span><span class="comment">// *and* a function object that extracts the value from<br></span><span class="comment">// the terminal<br>// 一个匹配所有终结符的简单的Proto语法，以及一个从终结符取出值的函数对象<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">_</span> <span class="special">&gt;</span>
  <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span>          <span class="comment">// &lt;-- Look, a transform! 看，这是一个变换！<br></span><span class="special">&gt;</span>
</pre>
<p>
            You can read this as follows: when you match a terminal expression, extract
            the value. The type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>
            is a so-called transform. Later we'll see what makes it a transform,
            but for now just think of it as a kind of function object. Note the use
            of <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code>: the first template
            parameter is the grammar to match and the second is the transform to
            execute. The result is both a grammar that matches terminal expressions
            and a function object that accepts terminal expressions and extracts
            their values.<br>你可以之样来读它：当你匹配了一个终结符表达式，取出它的值。类型 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>
            是一个所谓的变换。稍后我们将看到是什么使得它成为一个变换，不过现在我们只把它想象为一种函数对象。留意 <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> 的用法：第一个模板参数是要匹配的语法，第二个是要执行的变换。其结果既是一个匹配终结符表达式的语法，也是一个接受终结符表达式并返回其值的函数对象。
          </p>
<p>
            As with ordinary grammars, we can define an empty struct that inherits
            from a grammar+transform to give us an easy way to refer back to the
            thing we're defining, as follows:<br>和普通的语法一样，我们可以定义一个空的结构，派生自一个语法+变换，这样可以很容易地引用回我们定义的东西，如下：
          </p>
<pre class="programlisting"><span class="comment">// A grammar and a function object, as before<br>// 一个语法和一个函数对象，如前<br></span><span class="keyword">struct</span> <span class="identifier">Value</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">_</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// "Value" is a grammar that matches terminal expressions<br>// ”Value"是一个匹配终结符表达式的语法<br></span><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Value</span> <span class="special">&gt;</span> <span class="special">));</span>

<span class="comment">// "Value" also defines a function object that accepts terminals<br></span><span class="comment">// and extracts their value.<br>// "Value"也定义了一个接受一个终结符并取出其值的函数对象。<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">answer</span> <span class="special">=</span> <span class="special">{</span><span class="number">42</span><span class="special">};</span>
<span class="identifier">Value</span> <span class="identifier">get_value</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">get_value</span><span class="special">(</span> <span class="identifier">answer</span> <span class="special">);</span>
</pre>
<p>
            As already mentioned, <code class="computeroutput"><span class="identifier">Value</span></code>
            is a grammar that matches terminal expressions and a function object
            that operates on terminal expressions. It would be an error to pass a
            non-terminal expression to the <code class="computeroutput"><span class="identifier">Value</span></code>
            function object. This is a general property of grammars with transforms;
            when using them as function objects, expressions passed to them must
            match the grammar.<br>前面已经提过，<code class="computeroutput"><span class="identifier">Value</span></code>
            是一个匹配终结符表达式的语法，也是一个操作于终结符表达式之上的函数对象。传递一个非终结符表达式给 <code class="computeroutput"><span class="identifier">Value</span></code>
            函数对象是错误的。这是带有变换的语法的基本特性；把它们当作函数对象使用时，传递给它们的表达式必须符合相应的语法。
          </p>
<p>
            Proto grammars are valid TR1-style function objects. That means you can
            use <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;&gt;</span></code>
            to ask a grammar what its return type will be, given a particular expression
            type. For instance, we can access the <code class="computeroutput"><span class="identifier">Value</span></code>
            grammar's return type as follows:<br>Proto 语法是有效的TR1风格的函数对象。这意味着你可以用 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;&gt;</span></code>
            来询问某个语法，给定一个特定的表达式类型，它的返回类型是什么。例如，我们可以如下获得 <code class="computeroutput"><span class="identifier">Value</span></code>
            语法的返回类型：
          </p>
<pre class="programlisting"><span class="comment">// We can use boost::result_of&lt;&gt; to get the return type<br></span><span class="comment">// of a Proto grammar.<br>// 我们可以用 boost::result_of&lt;&gt; 来获得一个 Proto 语法的返回类型<br></span><span class="keyword">typedef</span>
    <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">Value</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">)&gt;::</span><span class="identifier">type</span>
<span class="identifier">result_type</span><span class="special">;</span>

<span class="comment">// Check that we got the type we expected<br>// 检查我们获得的类型是否所期望的<br></span><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">result_type</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="special">));</span>
</pre>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
              A grammar with embedded transforms is both a grammar and a function
              object. Calling these things "grammars with transforms" would
              get tedious. We could call them something like "active grammars",
              but as we'll see <span class="emphasis"><em>every</em></span> grammar that you can define
              with Proto is "active"; that is, every grammar has some behavior
              when used as a function object. So we'll continue calling these things
              plain "grammars". The term "transform" is reserved
              for the thing that is used as the second parameter to the <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> template.<br>一个带有内嵌变换的语法既是一个语法，也是一个函数对象。把它称为"带变换的语法"太过麻烦。我们可以称之为"主动语法"，不过，就象我们即将看到的那样，你用 Proto 定义的<span style="font-style: italic;">每一个</span>语法都是"主动"的；即，每一个语法被作为函数对象使用时都会有一些行为。所以，我们继续把它们称为"语法"就算了。术语"变换"保留作为对 <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> 模板的第二个参数的称呼。
            </p></td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.handling_alternation_and_recursion"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.handling_alternation_and_recursion" title="Handling Alternation and Recursion">Handling
          Alternation and Recursion 处理多选与递归</a>
</h5></div></div></div>
<p>
            Most grammars are a little more complicated than the one in the preceding
            section. For the sake of illustration, let's define a rather nonsensical
            grammar that matches any expression and recurses to the leftmost terminal
            and returns its value. It will demonstrate how two key concepts of Proto
            grammars -- alternation and recursion -- interact with transforms. The
            grammar is described below.<br>多数语法要比上一节中的复杂一点。为了示范之用，我们来定义一个荒谬的语法，它匹配任意的表达式，递归至最左侧的终结符并返回其值。它将示范 Proto 语法的两个关键概念 -- 多选与递归 -- 是如何与变换相结合的。该语法表示如下。
          </p>
<pre class="programlisting"><span class="comment">// A grammar that matches any expression, and a function object<br></span><span class="comment">// that returns the value of the leftmost terminal.<br>// 一个匹配任意表达式的语法，以及一个返回最左侧终结符的值的函数对象。<br></span><span class="keyword">struct</span> <span class="identifier">LeftmostLeaf</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="comment">// If the expression is a terminal, return its value<br>        // 如果该表达式是一个终结符，则返回它的值<br></span>        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">_</span> <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span>
        <span class="special">&gt;</span>
        <span class="comment">// Otherwise, it is a non-terminal. Return the result<br></span>        <span class="comment">// of invoking LeftmostLeaf on the 0th (leftmost) child.<br>        // 否则，它不是一个终结符。返回对第0个(最左边的)子节点调用LeftmostLeaf的结果。<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">_</span>
          <span class="special">,</span> <span class="identifier">LeftmostLeaf</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span> <span class="special">)</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// A Proto terminal wrapping std::cout 包装了std::cout的Proto终结符<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">};</span>

<span class="comment">// Create an expression and use LeftmostLeaf to extract the<br></span><span class="comment">// value of the leftmost terminal, which will be std::cout.<br>// 创建一个表达式并用LeftmostLeaf来取出最左侧终结符的值，即std::cout。<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="identifier">sout</span> <span class="special">=</span> <span class="identifier">LeftmostLeaf</span><span class="special">()(</span> <span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="string">"the answer: "</span> <span class="special">&lt;&lt;</span> <span class="number">42</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span> <span class="special">);</span>
</pre>
<p>
            We've seen <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code>
            before. Here it is serving two roles. First, it is a grammar that matches
            any of its alternate sub-grammars; in this case, either a terminal or
            a non-terminal. Second, it is also a function object that accepts an
            expression, finds the alternate sub-grammar that matches the expression,
            and applies its transform. And since <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>
            inherits from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code>,
            <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code> is also
            both a grammar and a function object.<br>前面我们已经见过 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code>
            了。在这里它扮演两个角色。首先，它是一个匹配其任一子语法的语法；在这个例子中，即为终结符或非终结符。其次，它也是一个函数对象，接受一个表达式，找出与该表达式相匹配的子语法，并对它应用变换。由于 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>
            继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code>，所以 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code> 既是一个语法，也是一个函数对象。
          </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
              The second alternate uses <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
              as its grammar. Recall that <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
              is the wildcard grammar that matches any expression. Since alternates
              in <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code>
              are tried in order, and since the first alternate handles all terminals,
              the second alternate handles all (and only) non-terminals. Often enough,
              <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
              <span class="identifier">_</span><span class="special">,</span>
              <em class="replaceable"><code>
                some-transform
              </code></em>
              <span class="special">&gt;</span></code> is the last alternate in
              a grammar, so for improved readability, you could use the equivalent
              <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">otherwise</span><span class="special">&lt;</span>
              <em class="replaceable"><code>
                some-transform
              </code></em>
              <span class="special">&gt;</span></code>.<br>第二个选择以 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
              作为其语法。回想一下，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
              是匹配任意表达式的通配语法。由于在 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code>
              中的候选项是按顺序尝试的，而且第一个候选项对应所有终结符，所以第二个候选项代表所有(也仅仅是)非终结符。通常来说，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
              <span class="identifier">_</span><span class="special">,</span>
              <em class="replaceable"><code>
                some-transform
              </code></em>
              <span class="special">&gt;</span></code> 作为语法中的最后一个候选项就足够了，如果要提高可读性，你可以用等价的
              <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">otherwise</span><span class="special">&lt;</span>
              <em class="replaceable"><code>
                some-transform
              </code></em>
              <span class="special">&gt;</span></code>.
            </p></td></tr>
</tbody></table></div>
<p>
            The next section describes this grammar further.<br>下一节将进一步讨论这个语法。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.callable_transforms"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.callable_transforms" title="Callable Transforms">Callable
          Transforms 可调用变换</a>
</h5></div></div></div>
<p>
            In the grammar defined in the preceding section, the transform associated
            with non-terminals is a little strange-looking:<br>在前一节中定义的语法中，与非终结符相关联的变换看起来有些奇怪：
          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
    <span class="identifier">_</span>
  <span class="special">,</span> <span class="bold"><strong>LeftmostLeaf( proto::_child0 )</strong></span>   <span class="comment">// &lt;-- a "callable" transform 一个"可调用"变换<br></span><span class="special">&gt;</span>
</pre>

<p>
            It has the effect of accepting non-terminal expressions, taking the 0th
            (leftmost) child and recursively invoking the <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>
            function on it. But <code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span>
            <span class="special">)</span></code> is actually a <span class="emphasis"><em>function
            type</em></span>. Literally, it is the type of a function that accepts
            an object of type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code>
            and returns an object of type <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>.
            So how do we make sense of this transform? Clearly, there is no function
            that actually has this signature, nor would such a function be useful.
            The key is in understanding how <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;&gt;</span></code> <span class="emphasis"><em>interprets</em></span>
            its second template parameter.<br>其中含有对于非终结符表达式的动作，取出第0个(最左边)子节点并对其递归调用 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>
            函数。但是 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span>
            <span class="special">)</span></code> 是一个实实在在的<span class="emphasis"><em>函数类型</em></span>啊。从字面上看，它是一个函数的类型，该函数接受一个类型为 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code>
            的对象并返回一个类型为 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code> 的对象。那么我们要如何弄清楚这个变换的意思呢？无疑，并没有一个函数真的具有这个签名，这样的函数也没有用。关键在于要弄明白 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;&gt;</span></code> 如何<span class="emphasis"><em>解释</em></span>它的第二个模板参数。
          </p>
<p>
            When the second template parameter to <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code>
            is a function type, <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code>
            interprets the function type as a transform. In this case, <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code> is treated as the type
            of a function object to invoke, and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code>
            is treated as a transform. First, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code>
            is applied to the current expression (the non-terminal that matched this
            alternate sub-grammar), and the result (the 0th child) is passed as an
            argument to <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>.<br>如果传递给 <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code>
            的第二个模板参数是一个函数类型，则 <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> 将该函数类型解释为一个变换。在这个例子中，<code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code> 被视为要调用的函数对象的类型，而 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code>
            则被视为一个变换。首先，将 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code>
            应用至当前表达式(匹配该被选子语法的非终结符)，然后将结果(第0个子节点)作为参数传递给 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>。
          </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Transforms are a Domain-Specific Language&nbsp;<br>变换是一种领域专用语言</strong></span>
            </p>
<p>
              <code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span>
              <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span> <span class="special">)</span></code>
              <span class="emphasis"><em>looks</em></span> like an invocation of the <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code> function object, but
              it's not, but then it actually is! Why this confusing subterfuge? Function
              types give us a natural and concise syntax for composing more complicated
              transforms from simpler ones. The fact that the syntax is suggestive
              of a function invocation is on purpose. It is a domain-specific embedded
              language for defining expression transformations. If the subterfuge
              worked, it may have fooled you into thinking the transform is doing
              exactly what it actually does! And that's the point.<br><code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span>
              <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span> <span class="special">)</span></code>
              <span class="emphasis"><em>看起来</em></span>就象对 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span></code>
函数对象的一次调用，但它不是，然后实际上它就是！为什么说的如此混乱？函数类型给了我们一个自然且简洁的语法来从简单的变换组合出复杂的变换。事实上，
这个语法只是某个函数的提示，调用才是目的。它是一种用于定义表达式变换的领域专用语言。如果这种托词可以成功，它可能会蒙蔽你，使你以为变换在做的其实
就是它实际上要做的！这就是重点。 </p>
</td></tr>
</tbody></table></div>
<p>
            The type <code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span>
            <span class="special">)</span></code> is an example of a <span class="emphasis"><em>callable
            transform</em></span>. It is a function type that represents a function
            object to call and its arguments. The types <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code>
            and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code> are <span class="emphasis"><em>primitive transforms</em></span>.
            They are plain structs, not unlike function objects, from which callable
            transforms can be composed. There is one other type of transform, <span class="emphasis"><em>object
            transforms</em></span>, that we'll encounter next.<br>类型 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span>
            <span class="special">)</span></code> 是 <span class="emphasis"><em>可调用变换</em></span> 的一个例子。它是一个函数类型，表示一个要调用的函数对象及其参数。类型 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span></code> 和 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code> 则是 <span class="emphasis"><em>基本变换</em></span>。它们是普通的结构，不象函数对象，可以由它们组合出可调用变换。另外还有一种变换类型，<span class="emphasis"><em>对象变换</em></span>，后面我们将要提到。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.object_transforms"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.object_transforms" title="Object Transforms">Object
          Transforms 对象变换</a>
</h5></div></div></div>
<p>
            The very first transform we looked at simply extracted the value of terminals.
            Let's do the same thing, but this time we'll promote all ints to longs
            first. (Please forgive the contrived-ness of the examples so far; they
            get more interesting later.) Here's the grammar:<br>我们最早见到的一个变换只是取出终结符的值。下面我们再来做同样的事情，不过这次我们先要将所有 int 提升为 long。(请忘记到目前为止的这些例子的做作性；稍后它们会更有趣些)。以下是相应语法：
          </p>
<pre class="programlisting"><span class="comment">// A simple Proto grammar that matches all terminals,<br></span><span class="comment">// and a function object that extracts the value from<br></span><span class="comment">// the terminal, promoting ints to longs:<br>// 一个简单的Proto语法，匹配所有终结符，以及一个从终结符取出值的函数对象，将int提升为long:<br></span><span class="keyword">struct</span> <span class="identifier">ValueWithPomote</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span>
          <span class="special">,</span> <span class="keyword">long</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span>     <span class="comment">// &lt;-- an "object" transform 一个"对象"变换<br></span>        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">_</span> <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            You can read the above grammar as follows: when you match an int terminal,
            extract the value from the terminal and use it to initialize a long;
            otherwise, when you match another kind of terminal, just extract the
            value. The type <code class="computeroutput"><span class="keyword">long</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span></code>
            is a so-called <span class="emphasis"><em>object</em></span> transform. It looks like the
            creation of a temporary long, but it's really a function type. Just as
            a callable transform is a function type that represents a function to
            call and its arguments, an object transforms is a function type that
            represents an object to construct and the arguments to its constructor.<br>你可这样来读以上语法：如果你匹配到一个int终结符，就从终结符中取出它的值，并用它来初始化一个long；否则，如果你匹配到其它类型的终结符，则只是取出它的值。类型 <code class="computeroutput"><span class="keyword">long</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span></code>
            是一个所谓的 <span class="emphasis"><em>对象变换</em></span>。它看起来象是创建一个临时的long，其实它是一个函数类型。和可调用变换是一个表示了要调用的函数及其参数的函数类型一样，对象变换是一个表示了要构造的对象及其构造函数的参数的函数类型。
          </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Object Transforms vs. Callable Transforms&nbsp;<br>对象变换 vs. 可调用变换</strong></span>
            </p>

<p>
              When using function types as Proto transforms, they can either represent
              an object to construct or a function to call. It is similar to "normal"
              C++ where the syntax <code class="computeroutput"><span class="identifier">foo</span><span class="special">(</span><span class="string">"arg"</span><span class="special">)</span></code> can either be interpreted as an object
              to construct or a function to call, depending on whether <code class="computeroutput"><span class="identifier">foo</span></code> is a type or a function. But
              consider two of the transforms we've seen so far:<br>把函数类型用作 Proto 变换时，它们可以表示一个要构造的对象，或者表示一个要调用的函数。这类似于"普通"的C++，语法 <code class="computeroutput"><span class="identifier">foo</span><span class="special">(</span><span class="string">"arg"</span><span class="special">)</span></code> 可以解释为一个要构造的对象，或者是一个要调用的函数，这取决于 <code class="computeroutput"><span class="identifier">foo</span></code> 是一个类型还是一个函数。不过，考虑一下我们已见到的两个变换：</p>
<pre class="programlisting"><span class="identifier">LeftmostLeaf</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span><span class="special">)</span>  <span class="comment">// &lt;-- a callable transform<br></span><span class="keyword">long</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span>           <span class="comment">// &lt;-- an object transform<br></span></pre>

<p>
            
              Proto can't know in general which is which, so it uses a trait, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code>,
              to differentiate. <code class="computeroutput"><span class="identifier">is_callable</span><span class="special">&lt;</span> <span class="keyword">long</span>
              <span class="special">&gt;::</span><span class="identifier">value</span></code>
              is false so <code class="computeroutput"><span class="keyword">long</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span></code>
              is an object to construct, but <code class="computeroutput"><span class="identifier">is_callable</span><span class="special">&lt;</span> <span class="identifier">LeftmostLeaf</span>
              <span class="special">&gt;::</span><span class="identifier">value</span></code>
              is true so <code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span><span class="special">)</span></code> is a function to call. Later on, we'll
              see how Proto recognizes a type as "callable".<br>Proto 通常并不知道哪个是哪个，所以它使用了 trait，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code>，来区分。<code class="computeroutput"><span class="identifier">is_callable</span><span class="special">&lt;</span> <span class="keyword">long</span>
              <span class="special">&gt;::</span><span class="identifier">value</span></code>
              为false，所以 <code class="computeroutput"><span class="keyword">long</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span></code>
              是一个要构造的对象，而 <code class="computeroutput"><span class="identifier">is_callable</span><span class="special">&lt;</span> <span class="identifier">LeftmostLeaf</span>
              <span class="special">&gt;::</span><span class="identifier">value</span></code>
              为true，所以 <code class="computeroutput"><span class="identifier">LeftmostLeaf</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span><span class="special">)</span></code> 是一个要调用的函数。接着，我们将会看到 Proto 是如何把一个类型识别为"可调用"的。
            </p>
</td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.example__calculator_arity"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.example__calculator_arity" title="Example: Calculator Arity">Example:
          Calculator Arity 示例：计算器Arity</a>
</h5></div></div></div>
<p>
            Now that we have the basics of Proto transforms down, let's consider
            a slightly more realistic example. We can use transforms to improve the
            type-safety of the <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">calculator
            DSEL</a>. If you recall, it lets you write infix arithmetic expressions
            involving argument placeholders like <code class="computeroutput"><span class="identifier">_1</span></code>
            and <code class="computeroutput"><span class="identifier">_2</span></code> and pass them
            to STL algorithms as function objects, as follows:<br>现在我们已经有了 Proto 变换的基础，让我们来考虑一下更现实一些例子。我们可以用变换来改进 <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">计算器
            DSEL</a> 的类型安全性。如果你还记得，它可以让你编写含有参数占位符，如 <code class="computeroutput"><span class="identifier">_1</span></code> 和 <code class="computeroutput"><span class="identifier">_2</span></code>，的中缀算术表达式，并将表达式作为函数对象传递给STL算法，如下：
          </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">a1</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">56</span><span class="special">,</span> <span class="number">84</span><span class="special">,</span> <span class="number">37</span><span class="special">,</span> <span class="number">69</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a2</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">65</span><span class="special">,</span> <span class="number">120</span><span class="special">,</span> <span class="number">60</span><span class="special">,</span> <span class="number">70</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a3</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">0</span> <span class="special">};</span>

<span class="comment">// Use std::transform() and a calculator expression<br></span><span class="comment">// to calculate percentages given two input sequences:<br>// 用std::transform()和一个计算器表达式对给定的两个输入序列计算百分比：<br></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">a1</span><span class="special">,</span> <span class="identifier">a1</span><span class="special">+</span><span class="number">4</span><span class="special">,</span> <span class="identifier">a2</span><span class="special">,</span> <span class="identifier">a3</span><span class="special">,</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">);</span>
</pre>
<p>
            This works because we gave calculator expressions an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> that evaluates the expression, replacing
            the placeholders with the arguments to <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>. The overloaded <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">()</span></code> looked like this:<br>这可以是因为我们给了计算器表达式一个 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 来对表达式进行求值并以传给 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 的参数替换相应的占位符。重载的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">()</span></code> 看起来如下：
          </p>
<pre class="programlisting"><span class="comment">// Overload operator() to invoke proto::eval() with<br></span><span class="comment">// our calculator_context.<br>// 重载operator()，以我们的calculator_context调用proto::eval()。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">double</span>
<span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span>
<span class="special">{</span>
    <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
    <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a1</span><span class="special">);</span>
    <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a2</span><span class="special">);</span>
    
    <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Although this works, it's not ideal because it doesn't warn users if
            they supply too many or too few arguments to a calculator expression.
            Consider the following mistakes:<br>虽然这样做可以，但是它还不是完美的，因为如果向计算器表达式提供了过多或过少的参数，它不会给出警告。考虑以下错误：
          </p>
<pre class="programlisting"><span class="special">(</span><span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_1</span><span class="special">)(</span><span class="number">4</span><span class="special">,</span> <span class="number">2</span><span class="special">);</span>  <span class="comment">// Oops, too many arguments! 喔，太多参数了！<br></span><span class="special">(</span><span class="identifier">_2</span> <span class="special">*</span> <span class="identifier">_2</span><span class="special">)(</span><span class="number">42</span><span class="special">);</span>    <span class="comment">// Oops, too few arguments! 喔，太少参数了！<br></span></pre>
<p>
            The expression <code class="computeroutput"><span class="identifier">_1</span> <span class="special">*</span>
            <span class="identifier">_1</span></code> defines a unary calculator
            expression; it takes one argument and squares it. If we pass more than
            one argument, the extra arguments will be silently ignored, which might
            be surprising to users. The next expression, <code class="computeroutput"><span class="identifier">_2</span>
            <span class="special">*</span> <span class="identifier">_2</span></code>
            defines a binary calculator expression; it takes two arguments, ignores
            the first and squares the second. If we only pass one argument, the code
            silently fills in <code class="computeroutput"><span class="number">0.0</span></code> for
            the second argument, which is also probably not what users expect. What
            can be done?<br>表达式 <code class="computeroutput"><span class="identifier">_1</span> <span class="special">*</span>
            <span class="identifier">_1</span></code> 定义了一个单参数的计算器表达式；它接受一个参数并对它求平方。如果我们传入一个以上的参数，则额外的参数会被悄悄地忽略掉，这可能会令用户惊讶。第二个表达式，<code class="computeroutput"><span class="identifier">_2</span>
            <span class="special">*</span> <span class="identifier">_2</span></code>
            定义了一个二元计算器表达式；它接受两个参数，忽略其中第一个而对第二个求平方。如果我们只传入一个参数，代码会悄悄地将 <code class="computeroutput"><span class="number">0.0</span></code> 填入第二个参数，这同样可能不是用户想要的。那么可以怎么做呢？
          </p>
<p>
            We can say that the <span class="emphasis"><em>arity</em></span> of a calculator expression
            is the number of arguments it expects, and it is equal to the largest
            placeholder in the expression. So, the arity of <code class="computeroutput"><span class="identifier">_1</span>
            <span class="special">*</span> <span class="identifier">_1</span></code>
            is one, and the arity of <code class="computeroutput"><span class="identifier">_2</span>
            <span class="special">*</span> <span class="identifier">_2</span></code>
            is two. We can increase the type-safety of our calculator DSEL by making
            sure the arity of an expression equals the actual number of arguments
            supplied. Computing the arity of an expression is simple with the help
            of Proto transforms.<br>我们可以说，一个计算器表达式的 <span class="emphasis"><em>arity</em></span> 是它所期望的参数数量，它等于表达式中最大的占位符。因此，<code class="computeroutput"><span class="identifier">_1</span>
            <span class="special">*</span> <span class="identifier">_1</span></code>
            的arity为1，而 <code class="computeroutput"><span class="identifier">_2</span>
            <span class="special">*</span> <span class="identifier">_2</span></code>
            的arity为2。我们可以通过确认一个表达式的arity是否等于实际提供的参数数量来提高我们的计算器DSEL的类型安全性。有了 Proto 变换的帮助，计算一个表达式的arity很简单。
          </p>
<p>
            It's straightforward to describe in words how the arity of an expression
            should be calculated. Consider that calculator expressions can be made
            of <code class="computeroutput"><span class="identifier">_1</span></code>, <code class="computeroutput"><span class="identifier">_2</span></code>, literals, unary expressions and
            binary expressions. The following table shows the arities for each of
            these 5 constituents.<br>用语言来表达如何计算一个表达式的arity非常简单。考虑到计算器表达式可以由 <code class="computeroutput"><span class="identifier">_1</span></code>, <code class="computeroutput"><span class="identifier">_2</span></code>, 字面值，单参数表达式和二元表达式组成。下表展示了这5种情况的arity。
          </p>
<div class="table">
<a name="id3518001"></a><p class="title"><b>Table&nbsp;14.6.&nbsp;Calculator Sub-Expression Arities<br>表&nbsp;14.6. 计算器子表达式的arity</b></p>
<div class="table-contents"><table class="table" summary="Calculator Sub-Expression Arities">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  Sub-Expression 子表达式
                </p>
                </th>
<th>
                <p>
                  Arity
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  Placeholder 1 占位符1
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="number">1</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  Placeholder 2 占位符2
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="number">2</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  Literal 字面值
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="number">0</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  Unary Expression 单参数表达式
                </p>
                </td>
<td>
                <p>
                  <span class="emphasis"><em>arity of the operand 操作数的arity</em></span>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  Binary Expression 二元表达式
                </p>
                </td>
<td>
                <p>
                  <span class="emphasis"><em>max arity of the two operands 两个操作数的arity的最大值</em></span>
                </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">

<p>
            Using this information, we can write the grammar for calculator expressions
            and attach transforms for computing the arity of each constituent. The
            code below computes the expression arity as a compile-time integer, using
            integral wrappers and metafunctions from the Boost MPL Library. The grammar
            is described below.<br>使用这些信息，我们可以写出计算器表达式的语法并附上计算每种情形的arity的变换。以下代码将表达式的arity计算为一个编译期整数，使用来自Boost MPL库的整数包装器和元函数。语法描述如下。</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">CalcArity</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
            <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;()</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
            <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;()</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span>
            <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;()</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">CalcArity</span><span class="special">&gt;,</span>
            <span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child</span><span class="special">)</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">binary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">CalcArity</span><span class="special">,</span> <span class="identifier">CalcArity</span><span class="special">&gt;,</span>
            <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;</span><span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">),</span>
                     <span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">)&gt;()</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>


<p>
            
            When we find a placeholder terminal or a literal, we use an <span class="emphasis"><em>object
            transform</em></span> such as <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;()</span></code>
            to create a (default-constructed) compile-time integer representing the
            arity of that terminal.<br>当我们找到一个占位符终结符或一个字面值时，我们使用一个形如<span class="emphasis"><em></em></span> <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;()</span></code> 的<span class="emphasis"><em>对象变换</em></span><code class="computeroutput"><span class="special"></span></code>
            来创建一个(缺省构造的)编译期整数，表示这个终结符的arity。
          </p>
<p>
            For unary expressions, we use <code class="computeroutput"><span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child</span><span class="special">)</span></code> which is a <span class="emphasis"><em>callable transform</em></span>
            that computes the arity of the expression's child.<br>对于单参数表达式，我们使用 <code class="computeroutput"><span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child</span><span class="special">)</span></code>，它是一个计算该表达式的子节点的arity的<span class="emphasis"><em>可调用变换</em></span>。
          </p>
<p>
            The transform for binary expressions has a few new tricks. Let's look
            more closely:<br>二元表达式的变换有点诀窍。我们靠近一点来看：
          </p>
<pre class="programlisting"><span class="comment">// Compute the left and right arities and<br></span><span class="comment">// take the larger of the two.<br>// 计算左、右节点的arity，并取出两者中的较大值。<br></span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;</span><span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">),</span>
         <span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">)&gt;()</span>
</pre>
<p>
            This is an object transform; it default-constructs ... what exactly?
            The <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;&gt;</span></code>
            template is an MPL metafunction that accepts two compile-time integers.
            It has a nested <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>
            typedef (not shown) that is the maximum of the two. But here, we appear
            to be passing it two things that are <span class="emphasis"><em>not</em></span> compile-time
            integers; they're Proto callable transforms. Proto is smart enough to
            recognize that fact. It first evaluates the two nested callable transforms,
            computing the arities of the left and right child expressions. Then it
            puts the resulting integers into <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;&gt;</span></code> and evaluates the metafunction
            by asking for the nested <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>. That is the type of the object
            that gets default-constructed and returned.<br>这是一个对象变换；它缺省构造了 ...&nbsp;什么呢？模板 <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;&gt;</span></code>
            是一个MPL元函数，它接受两个编译期整数。它有一个嵌套的 <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>
            typedef (未示出)表示这两个整数中的最大者。不过在这里，我们看到的是，传给它的是两个<span style="font-style: italic;">不是</span>编译期整数的东西；传入的是 Proto 可调用变换。Proto 是很聪明的，它可以识别出这个事实。它首先对两个嵌套的可调用变换进行求值，分别计算左、右节点的arity。然后将结果整数放入 <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;&gt;</span></code> 并通过询问嵌套的 <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code> 来对元函数求值。结果就是获得缺省构造并返回的对象类型。
          </p>
<p>
            More generally, when evaluating object transforms, Proto looks at the
            object type and checks whether it is a template specialization, like
            <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;&gt;</span></code>.
            If it is, Proto looks for nested transforms that it can evaluate. After
            any nested transforms have been evaluated and substituted back into the
            template, the new template specialization is the result type, unless
            that type has a nested <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>, in which case that becomes the
            result.&nbsp;<br>更一般地说，在对对象变换进行求值时，Proto 会查看对象的类型并检查它是否为一个模板特化，如
            <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;&gt;</span></code>。如果是，则 Proto 寻找它可以求值的嵌套变换。在所有嵌套变换都求值后，将结果替换回模板中，新的模板特化就是结果类型，除非该类型带有一个嵌套的 <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>，这种情况下它才是结果。
          </p>
<p>
            Now that we can calculate the arity of a calculator expression, let's
            redefine the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> expression wrapper we wrote in
            the Getting Started guide to use the <code class="computeroutput"><span class="identifier">CalcArity</span></code>
            grammar and some macros from Boost.MPL to issue compile-time errors when
            users specify too many or too few arguments.<br>现在，我们可以计算一个计算器表达式的arity了，让我们用&nbsp;<code class="computeroutput"><span class="identifier">CalcArity</span></code>
 语法和来自Boost.MPL的一些宏来对我们在"入门"一节中写过的 <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> 表达式包装器进行重新定义，以便当用户指定了过多或过少参数时给出编译期错误。
          </p>
<pre class="programlisting"><span class="comment">// The calculator expression wrapper, as defined in the Hello<br></span><span class="comment">// Calculator example in the Getting Started guide. It behaves<br></span><span class="comment">// just like the expression it wraps, but with extra operator()<br></span><span class="comment">// member functions that evaluate the expression.<br></span><span class="comment">//   NEW: Use the CalcArity grammar to ensure that the correct<br></span><span class="comment">//   number of arguments are supplied.<br>// 计算器表达式包装器，类似于在"入门"一节的 Hello Calculator 例子中的定义。<br>// 其行为类似于所包装的表达式，但带有额外的operator()成员函数来对表达式求值。<br>//   新增：使用CalcArity语法来确保给出的参数数量是正确的。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">calculator</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">())</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Use CalcArity to compute the arity of Expr: <br>    // 用CalcArity来计算Expr的arity：<br></span>    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">arity</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">CalcArity</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">)&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>

    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_MPL_ASSERT_RELATION</span><span class="special">(</span><span class="number">0</span><span class="special">,</span> <span class="special">==,</span> <span class="identifier">arity</span><span class="special">);</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_MPL_ASSERT_RELATION</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="special">==,</span> <span class="identifier">arity</span><span class="special">);</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a1</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_MPL_ASSERT_RELATION</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="special">==,</span> <span class="identifier">arity</span><span class="special">);</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a1</span><span class="special">);</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a2</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Note the use of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;&gt;</span></code> to access the return type of
            the <code class="computeroutput"><span class="identifier">CalcArity</span></code> function
            object. Since we used compile-time integers in our transforms, the arity
            of the expression is encoded in the return type of the <code class="computeroutput"><span class="identifier">CalcArity</span></code> function object. Proto grammars
            are valid TR1-style function objects, so you can use <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;&gt;</span></code> to figure out their return types.<br>注意，其中使用了 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;&gt;</span></code> 来获得 <code class="computeroutput"><span class="identifier">CalcArity</span></code> 函数对象的返回类型。由于我们在变换中使用了编译期整数，所以表达式的arity是被编码在 <code class="computeroutput"><span class="identifier">CalcArity</span></code> 函数对象的返回类型中的。Proto 语法是有效的TR1风格的函数对象，所以你可以用 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;&gt;</span></code> 来取出它的返回类型。
          </p>
<p>
            With our compile-time assertions in place, when users provide too many
            or too few arguments to a calculator expression, as in:<br>有了我们的编译期断言后，当用户提供过多或过少参数给计算器表达式时，如下：
          </p>
<pre class="programlisting"><span class="special">(</span><span class="identifier">_2</span> <span class="special">*</span> <span class="identifier">_2</span><span class="special">)(</span><span class="number">42</span><span class="special">);</span> <span class="comment">// Oops, too few arguments! 喔，太少参数了！<br></span></pre>
<p>
            ... they will get a compile-time error message on the line with the assertion
            that reads something like this
            <sup>[<a name="id3520189" href="users_guide.html#ftn.id3520189" class="footnote">3</a>]</sup>
            :<br>... 他们将得到一个编译期的错误信息，指向断言所在的行，提示类似于
            <sup>[<a name="id3520189" href="#ftn.id3520189" class="footnote">3</a>]</sup> ：</p>
<pre class="programlisting">c:\boost\org\trunk\libs\proto\scratch\main.cpp(97) : error C2664: 'boost::mpl::asse<br>rtion_failed' : cannot convert parameter 1 from 'boost::mpl::failed ************boo<br>st::mpl::assert_relation&lt;x,y,__formal&gt;::************' to 'boost::mpl::assert&lt;false&gt;<br>::type'<br>   with<br>   [<br>       x=1,<br>       y=2,<br>       __formal=bool boost::mpl::operator==(boost::mpl::failed,boost::mpl::failed)<br>   ]<br></pre>
<p>
            The point of this exercise was to show that we can write a fairly simple
            Proto grammar with embedded transforms that is declarative and readable
            and can compute interesting properties of arbitrarily complicated expressions.
            But transforms can do more than that. Boost.Xpressive uses transforms
            to turn expressions into finite state automata for matching regular expressions,
            and Boost.Spirit uses transforms to build recursive descent parser generators.
            Proto comes with a collection of built-in transforms that you can use
            to perform very sophisticated expression manipulations like these. In
            the next few sections we'll see some of them in action.<br>这
个练习所展示的观点是，我们可以编写一个很简单的、带有嵌入变换的、具有描述性和可读性的 Proto
语法，它可以计算一个任意复杂的表达式的某些你感兴趣的属性。但是变换可以做得更多。Boost.Xpressive
使用变换来将表达式转为有限状态机以匹配正则表达式，而 Boost.Spirit 则使用变换来构建递归下降分析器的生成器。Proto
配备了一组内建变换，你可以用它们来执行象这样的一些非常复杂的表达式处理。在下面几节中，我们将看到其中的一些。 </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.state"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.state" title="Transforms With State Accumulation">
          Transforms With State Accumulation 带状态累计的变换</a>
</h5></div></div></div>
<p>
            So far, we've only seen examples of grammars with transforms that accept
            one argument: the expression to transform. But consider for a moment
            how, in ordinary procedural code, you would turn a binary tree into a
            linked list. You would start with an empty list. Then, you would recursively
            convert the right branch to a list, and use the result as the initial
            state while converting the left branch to a list. That is, you would
            need a function that takes two parameters: the current node and the list
            so far. These sorts of <span class="emphasis"><em>accumulation</em></span> problems are
            quite common when processing trees. The linked list is an example of
            an accumulation variable or <span class="emphasis"><em>state</em></span>. Each iteration
            of the algorithm takes the current element and state, applies some binary
            function to the two and creates a new state. In the STL, this algorithm
            is called <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">accumulate</span><span class="special">()</span></code>.
            In many other languages, it is called <span class="emphasis"><em>fold</em></span>. Let's
            see how to implement a fold algorithm with Proto transforms.<br>到
目前为止，我们看到的语法例子中的变换都只是接受一个参数：即进行变换的表达式。但是考虑一下，在普通的程序代码中，你会如何将一个二叉树转换为一个链
表。你会从一个空链表开始。然后递归地将右分支转换为一个链表，并以此结果作为初始状态，同时将左分支也转换为一个链表。也就是说，你需要一个接受两个参
数的函数，这两个参数分别是：当前节点以及到目前为止的链表。在处理树结构时，这一类<span class="emphasis"><em>累计</em></span>问题是很常见的。这个链表是累计变量或<span class="emphasis"><em>状态</em></span>的一个例子。该算法的每一次迭代都接受当前元素和状态，对这两者应用某些二元函数并创建一个新的状态。在STL中，这个算法称为 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">accumulate</span><span class="special">()</span></code>。而在许多其它的语言中，它被称为<span class="emphasis"><em>折叠fold</em></span>。我们来看看如何用Proto变换来实现一个折叠算法。
          </p>
<p>
            All Proto grammars can optionally accept a state parameter in addition
            to the expression to transform. If you want to fold a tree to a list,
            you'll need to make use of the state parameter to pass around the list
            you've built so far. As for the list, the Boost.Fusion library provides
            a <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">cons</span><span class="special">&lt;&gt;</span></code>
            type from which you can build heterogeneous lists. The type <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">nil</span></code> represents an empty list.<br>所有的Proto语法除了变换的表达式之外，都接受一个可选的状态参数。如果你想将一棵树折叠为一个链表，你需要利用这个状态参数来传递迄今你所建立的链表。至于这个链表，Boost.Fusion 库提供了一个 <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">cons</span><span class="special">&lt;&gt;</span></code>
            类型，从中你可以建立一个异构的链表。类型 <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">nil</span></code> 则表示一个空的链表。
          </p>
<p>
            Below is a grammar that recognizes output expressions like <code class="computeroutput"><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span>
            <span class="number">42</span> <span class="special">&lt;&lt;</span>
            <span class="char">'\n'</span></code> and puts the arguments into
            a Fusion list. It is explained below.<br>以下是一个语法，它识别形如 <code class="computeroutput"><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span>
            <span class="number">42</span> <span class="special">&lt;&lt;</span>
            <span class="char">'\n'</span></code> 的输出表达式并将参数放入一个 Fusion 链表。解释如下。
          </p>
<pre class="programlisting"><span class="comment">// Fold the terminals in output statements like<br></span><span class="comment">// "cout_ &lt;&lt; 42 &lt;&lt; '\n'" into a Fusion cons-list.<br>// 将形如"cout_ &lt;&lt; 42 &lt;&lt; '\n'"这样的输出语句中的终结符折叠到一个Fusion cons-链表中。<br></span><span class="keyword">struct</span> <span class="identifier">FoldToList</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="comment">// Don't add the ostream terminal to the list<br>        // 不要将ostream终结符加到链表中<br></span>        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span>
        <span class="special">&gt;</span>
        <span class="comment">// Put all other terminals at the head of the<br></span>        <span class="comment">// list that we're building in the "state" parameter<br>        // 将其它所有终结符放在我们正在"state"参数中构建的链表的头部<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">cons</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">&gt;(</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span>
            <span class="special">)</span>
        <span class="special">&gt;</span>
        <span class="comment">// For left-shift operations, first fold the right<br></span>        <span class="comment">// child to a list using the current state. Use<br></span>        <span class="comment">// the result as the state parameter when folding<br></span>        <span class="comment">// the left child to a list.<br>        // 对于左移操作，首先将右子节点与当前state折叠到一个链表中。<br>        // 然后在将左子节点折叠至链表时，把该结果作为state参数。<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;</span><span class="identifier">FoldToList</span><span class="special">,</span> <span class="identifier">FoldToList</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">FoldToList</span><span class="special">(</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span>
              <span class="special">,</span> <span class="identifier">FoldToList</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">)</span>
            <span class="special">)</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Before reading on, see if you can apply what you know already about object,
            callable and primitive transforms to figure out how this grammar works.<br>在继续往下之前，看看你是否可以用你已知的关于对象变换、可调用变换和基本变换的知识来找出这个语法是如何工作的。
          </p>
<p>
            When you use the <code class="computeroutput"><span class="identifier">FoldToList</span></code>
            function, you'll need to pass two arguments: the expression to fold,
            and the initial state: an empty list. Those two arguments get passed
            around to each transform. We learned previously that <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>
            is a primitive transform that accepts a terminal expression and extracts
            its value. What we didn't know until now was that it also accepts the
            current state <span class="emphasis"><em>and ignores it</em></span>. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span></code>
            is also a primitive transform. It accepts the current expression, which
            it ignores, and the current state, which it returns.<br>当你使用 <code class="computeroutput"><span class="identifier">FoldToList</span></code>
            函数时，你需要传入两个参数：进行折叠的表达式，以及初始状态：一个空的链表。这两个参数被传递给每一个变换。前面我们已经学过 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>
            是一个基本变换，接受一个终结符表达式并了取出其值。我们还不知道的是，它也可以接受当前的状态<span class="emphasis"><em>并忽略它</em></span>。<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span></code>
            也是一个基本变换。它接受当前的表达式和当前状态，但忽略前者而返回后者。
          </p>
<p>
            When we find a terminal, we stick it at the head of the cons list, using
            the current state as the tail of the list. (The first alternate causes
            the <code class="computeroutput"><span class="identifier">ostream</span></code> to be skipped.
            We don't want <code class="computeroutput"><span class="identifier">cout</span></code> in
            the list.) When we find a shift-left node, we apply the following transform:<br>当我们找到一个终结符时，我们把它放在cons链表的头部，并以当前状态作为链表的尾部。(第一个候选项导致 <code class="computeroutput"><span class="identifier">ostream</span></code> 被跳过。我们不想让 <code class="computeroutput"><span class="identifier">cout</span></code> 出现在链表中)。当我们找到一个左移节点时，我们使用以下变换：
          </p>
<pre class="programlisting"><span class="comment">// Fold the right child and use the result as<br></span><span class="comment">// state while folding the right.<br>// 折叠右子节点并将结果用作折叠左子节点时的状态。<br></span><span class="identifier">FoldToList</span><span class="special">(</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span>
  <span class="special">,</span> <span class="identifier">FoldToList</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">)</span>
<span class="special">)</span>
</pre>
<p>
            You can read this transform as follows: using the current state, fold
            the right child to a list. Use the new list as the state while folding
            the left child to a list.<br>你可以这样来解读这个变换：使用当前状态，将右子节点折叠至一个链表。把这个新链表用作状态参数，将左子节点折叠至一个链表。
          </p>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top">

<p>
              If your compiler is Microsoft Visual C++, you'll find that the above
              transform does not compile. The compiler has bugs with its handling
              of nested function types. You can work around the bug by wrapping the
              inner transform in <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;&gt;</span></code> as follows:<br>如果你的编译器是 Microsoft Visual C++，你会发现以上变换不能通过编译。该编译器对于嵌套函数类型的处理存在缺陷。你可以象下面这样通过将内层的变换包装在 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;&gt;</span></code> 中来绕过这一缺陷：</p>
<pre class="programlisting"><span class="identifier">FoldToList</span><span class="special">(</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span>
  <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span><span class="identifier">FoldToList</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">)&gt;</span>
<span class="special">)</span>
</pre>

<p>
            <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;&gt;</span></code>
              turns a callable transform into a primitive transform, but more on
              that later.<br><code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;&gt;</span></code> 将一个可调用变换变为一个基本变换，稍后会更多用到。
            </p>
</td></tr>
</tbody></table></div>
<p>
            Now that we have defined the <code class="computeroutput"><span class="identifier">FoldToList</span></code>
            function object, we can use it to turn output expressions into lists
            as follows:<br>现在，我们已经定义了 <code class="computeroutput"><span class="identifier">FoldToList</span></code>
            函数对象，我们可以用它来把输出表达式转换为链表，如下：







          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">};</span>

<span class="comment">// This is the type of the list we build below<br>// 这是我们后面要构建的链表的类型<br></span><span class="keyword">typedef</span>
    <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">cons</span><span class="special">&lt;</span>
        <span class="keyword">int</span>
      <span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">cons</span><span class="special">&lt;</span>
            <span class="keyword">double</span>
          <span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">cons</span><span class="special">&lt;</span>
                <span class="keyword">char</span>
              <span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">nil</span>
            <span class="special">&gt;</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="identifier">result_type</span><span class="special">;</span>

<span class="comment">// Fold an output expression into a Fusion list, using<br></span><span class="comment">// fusion::nil as the initial state of the transformation.<br>// 将一个输出表达式折叠至一个Fusion链表，以fusion::nil作为变换的初始状态。<br></span><span class="identifier">FoldToList</span> <span class="identifier">to_list</span><span class="special">;</span>
<span class="identifier">result_type</span> <span class="identifier">args</span> <span class="special">=</span> <span class="identifier">to_list</span><span class="special">(</span><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="number">1</span> <span class="special">&lt;&lt;</span> <span class="number">3.14</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">nil</span><span class="special">());</span>

<span class="comment">// Now "args" is the list: {1, 3.14, '\n'}<br>// 现在"args"为链表：{1, 3.14, '\n'}<br></span></pre>
<p>
            When writing transforms, "fold" is such a basic operation that
            Proto provides a number of built-in fold transforms. We'll get to them
            later. For now, rest assured that you won't always have to stretch your
            brain so far to do such basic things.<br>在编写变换时，"折叠"是一个非常基本的操作，所以Proto提供了一些内建的折叠变换。我们稍后将会提及它们。现在你可以放心了，你不需要总是花费脑筋去做这些基本的东西。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.data"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.data" title="Passing Auxiliary Data to Transforms">
          Passing Auxiliary Data to Transforms 传递辅助数据给变换</a>
</h5></div></div></div>
<p>
            In the last section, we saw that we can pass a second parameter to grammars
            with transforms: an accumulation variable or <span class="emphasis"><em>state</em></span>
            that gets updated as your transform executes. There are times when your
            transforms will need to access auxiliary data that does <span class="emphasis"><em>not</em></span>
            accumulate, so bundling it with the state parameter is impractical. Instead,
            you can pass auxiliary data as a third parameter, known as the <span class="emphasis"><em>data</em></span>
            parameter. Below we show an example involving string processing where
            the data parameter is essential.<br>在上一节，我们看到了，我们可以传递第二个参数给带有变换的语法：一个累计变量或<span class="emphasis"><em>状态</em></span>，它会在你的变换执行中被更新。有时，你的变换会需要访问一些<span style="font-style: italic;">并非</span>累计的辅助数据，所以以 state 参数来绑定它是不合适的。这时，你可以将这些辅助数据作为第三个参数来传递，即 <span class="emphasis"><em>data</em></span>
            参数。下面我们将示范一个字符串处理的例子，其中将用到 data 参数。
          </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
              All Proto grammars are function objects that take one, two or three
              arguments: the expression, the state, and the data. There are no additional
              arguments to know about, we promise. In Haskell, there is set of tree
              traversal technologies known collectively as <a class="link" href="users_guide.html#boost_proto.users_guide.resources.SYB">“<span class="quote">Scrap
              Your Boilerplate</span>”</a>. In that framework, there are also
              three parameters: the term, the accumulator, and the context. These
              are Proto's expression, state and data parameters under different names.<br>所有Proto语法都是函数对象，它可能带一个、两个或三个参数：表达式、状态和数据。我们承诺，没有其它参数了。在Haskell中，有成套的树遍历技术，它们被统称为 <a class="link" href="users_guide.html#boost_proto.users_guide.resources.SYB">“<span class="quote">Scrap
              Your Boilerplate</span>”</a>。在那个框架中，也有三个参数：术语、累计器和上下文。它们就是不同名字下的Proto表达式、状态和数据参数。
            </p></td></tr>
</tbody></table></div>
<p>
            Expression templates are often used as an optimization to eliminate temporary
            objects. Consider the problem of string concatenation: a series of concatenations
            would result in the needless creation of temporary strings. We can use
            Proto to make string concatenation very efficient. To make the problem
            more interesting, we can apply a locale-sensitive transformation to each
            character during the concatenation. The locale information will be passed
            as the data parameter.<br>表
达式模板通常被用作一种优化手段，以消除临时对象。考虑一个字符串串接的问题：一系列的串接会导致不必要的临时字符串的创建。我们可以用Proto来使得
字符串串接更为高效。为了让这个问题更加有趣，我们可以在串接的过程中对每个字符施加一个locale敏感的变换。locale信息将作为data参数传
递。 </p>
<p>
            Consider the following expression template:<br>考虑以下表达式模板：
          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">lit</span><span class="special">(</span><span class="string">"hello"</span><span class="special">)</span> <span class="special">+</span> <span class="string">" "</span> <span class="special">+</span> <span class="string">"world"</span><span class="special">;</span>
</pre>
<p>
            We would like to concatenate this string into a statically allocated
            wide character buffer, widening each character in turn using the specified
            locale. The first step is to write a grammar that describes this expression,
            with transforms that calculate the total string length. Here it is:<br>我们希望将这个字符串串接到一个静态分配的宽字符缓冲区中，使用指定的locale对字符逐个扩宽。第一步是编写一个语法来描述该表达式，并带有计算字符串总长度的变换。如下：
          </p>
<pre class="programlisting"><span class="comment">// A grammar that matches string concatenation expressions, and<br></span><span class="comment">// a transform that calculates the total string length.<br>// 一个匹配字符串串接表达式的语法，以及一个计算字符串总长度的变换。<br></span><span class="keyword">struct</span> <span class="identifier">StringLength</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="comment">// When you find a character array ... 当你找到一个字符串数组...<br></span>            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">[</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">N</span><span class="special">]&gt;</span>
            <span class="comment">// ... the length is the size of the array minus 1. 数组长度减1。<br></span>          <span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">prior</span><span class="special">&lt;</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">sizeof_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">&gt;</span> <span class="special">&gt;()</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="comment">// The length of a concatenated string is ... 串接的字符串长度为...<br></span>            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">StringLength</span><span class="special">,</span> <span class="identifier">StringLength</span><span class="special">&gt;</span>
            <span class="comment">// ... the sum of the lengths of each sub-string. 各个子串长度之和。<br></span>          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span>
                <span class="identifier">_</span>
              <span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;()</span>
              <span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">StringLength</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">&gt;()</span>
            <span class="special">&gt;</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Notice the use of <code class="computeroutput"><a class="link" href="../boost/proto/fold.html" title="Struct template fold">proto::fold&lt;&gt;</a></code>. It is a primitive
            transform that takes a sequence, a state, and function, just like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">accumulate</span><span class="special">()</span></code>.
            The three template parameters are transforms. The first yields the sequence
            of expressions over which to fold, the second yields the initial state
            of the fold, and the third is the function to apply at each iteration.
            The use of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code> as the first parameter might have
            you confused. In addition to being Proto's wildcard, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
            is also a primitive transform that returns the current expression, which
            (if it is a non-terminal) is a sequence of its child expressions.<br>注意其中对 <code class="computeroutput"><a class="link" href="../boost/proto/fold.html" title="Struct template fold">proto::fold&lt;&gt;</a></code> 的使用。它是一个基本变换，接受一个序列、一个状态和一个函数，就象 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">accumulate</span><span class="special">()</span></code> 那样。这三个模板参数都是变换。第一个参数产生要进行折叠的表达式序列，第二个参数产生折叠的初始状态，第三个参数则是应用于每次迭代的函数。以 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code> 作为第一个参数可能会使你感到困惑。除了作为Proto的通配符以外，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
            还是一个返回当前表达式的基本变换，即(如果它是一个非终结符)一个由各子表达式组成的序列。
          </p>
<p>
            Next, we need a function object that accepts a narrow string, a wide
            character buffer, and a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;&gt;</span></code> facet for doing the locale-specific
            stuff. It's fairly straightforward.<br>接着，我们需要一个函数对象，它接受一个窄字符串、一个宽字符缓冲区和一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;&gt;</span></code> facet 来进行特定locale的填充。它非常简单。
          </p>
<pre class="programlisting"><span class="comment">// A function object that writes a narrow string<br></span><span class="comment">// into a wide buffer.<br>// 一个函数对象，将一个窄字符串写入到宽字符缓冲区。<br></span><span class="keyword">struct</span> <span class="identifier">WidenCopy</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">wchar_t</span> <span class="special">*</span><span class="identifier">result_type</span><span class="special">;</span>

    <span class="keyword">wchar_t</span> <span class="special">*</span>
    <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span><span class="identifier">str</span><span class="special">,</span> <span class="keyword">wchar_t</span> <span class="special">*</span><span class="identifier">buf</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">ct</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">for</span><span class="special">(;</span> <span class="special">*</span><span class="identifier">str</span><span class="special">;</span> <span class="special">++</span><span class="identifier">str</span><span class="special">,</span> <span class="special">++</span><span class="identifier">buf</span><span class="special">)</span>
            <span class="special">*</span><span class="identifier">buf</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">.</span><span class="identifier">widen</span><span class="special">(*</span><span class="identifier">str</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">buf</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Finally, we need some transforms that actually walk the concatenated
            string expression, widens the characters and writes them to a buffer.
            We will pass a <code class="computeroutput"><span class="keyword">wchar_t</span><span class="special">*</span></code>
            as the state parameter and update it as we go. We'll also pass the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;&gt;</span></code>
            facet as the data parameter. It looks like this:<br>最后，我们需要一些变换来实际遍历要串接的字符串表达式，对字符进行扩宽，并将它们写入至缓冲区。我们将传入一个 <code class="computeroutput"><span class="keyword">wchar_t</span><span class="special">*</span></code>
            作为 state 参数，并随着我们的进度更新它。我们还会传入 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;&gt;</span></code>
            facet 作为 data 参数。它看起来象这样：
          </p>
<pre class="programlisting"><span class="comment">// Write concatenated strings into a buffer, widening<br></span><span class="comment">// them as we go.<br>// 将串接的字符串写入到缓冲区，并扩宽它们。<br></span><span class="keyword">struct</span> <span class="identifier">StringCopy</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">[</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">N</span><span class="special">]&gt;</span>
          <span class="special">,</span> <span class="identifier">WidenCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">StringCopy</span><span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">(</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span>
              <span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span>
            <span class="special">)</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Let's look more closely at the transform associated with non-terminals:<br>我们来仔细地看一下与非终结符相关联的变换：
          </p>
<pre class="programlisting"><span class="identifier">StringCopy</span><span class="special">(</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span>
  <span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)</span>
  <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span>
<span class="special">)</span>
</pre>
<p>
            This bears a resemblance to the transform in the previous section that
            folded an expression tree into a list. First we recurse on the left child,
            writing its strings into the <code class="computeroutput"><span class="keyword">wchar_t</span><span class="special">*</span></code> passed in as the state parameter. That
            returns the new value of the <code class="computeroutput"><span class="keyword">wchar_t</span><span class="special">*</span></code>, which is passed as state while transforming
            the right child. Both invocations receive the same <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;&gt;</span></code>, which is passed in as the data
            parameter.<br>这与上一节中将表达式树折叠为链表的那个变换非常相似。首先我们对左子节点进行递归，将它的字符串写入到作为 state 参数传入的 <code class="computeroutput"><span class="keyword">wchar_t</span><span class="special">*</span></code> 中。返回的 <code class="computeroutput"><span class="keyword">wchar_t</span><span class="special">*</span></code> 新值，在转换右子节点时作为 state 传入。两个调用均接受同一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;&gt;</span></code>，它被作为 data
            参数传递。
          </p>
<p>
            With these pieces in our pocket, we can implement our concatenate-and-widen
            function as follows:<br>通过我们口袋中的这些零件，我们可以实现我们的串接并扩宽，如下：
          </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">widen</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Make sure the expression conforms to our grammar 确保表达式符合我们的语法<br></span>    <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">StringLength</span><span class="special">&gt;</span> <span class="special">));</span>

    <span class="comment">// Calculate the length of the string and allocate a buffer statically<br>    // 计算字符串的总长度并静态分配一个缓冲区<br></span>    <span class="keyword">static</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">const</span> <span class="identifier">length</span> <span class="special">=</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">StringLength</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">)&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>
    <span class="keyword">wchar_t</span> <span class="identifier">buffer</span><span class="special">[</span> <span class="identifier">length</span> <span class="special">+</span> <span class="number">1</span> <span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="identifier">L</span><span class="char">'\0'</span><span class="special">};</span>

    <span class="comment">// Get the current ctype facet 取得当前的ctype facet<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">loc</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">ct</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">use_facet</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ctype</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="identifier">loc</span><span class="special">));</span>

    <span class="comment">// Concatenate and widen the string expression 串接并扩宽这个字符串表达式<br></span>    <span class="identifier">StringCopy</span><span class="special">()(</span><span class="identifier">expr</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">buffer</span><span class="special">[</span><span class="number">0</span><span class="special">],</span> <span class="identifier">ct</span><span class="special">);</span>

    <span class="comment">// Write out the buffer. 输出该缓冲区。<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">wcout</span> <span class="special">&lt;&lt;</span> <span class="identifier">buffer</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">widen</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">lit</span><span class="special">(</span><span class="string">"hello"</span><span class="special">)</span> <span class="special">+</span> <span class="string">" "</span> <span class="special">+</span> <span class="string">"world"</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            The above code displays:<br>以上代码将显示：
          </p>
<pre class="programlisting">hello world<br></pre>
<p>
            This is a rather round-about way of demonstrating that you can pass extra
            data to a transform as a third parameter. There are no restrictions on
            what this parameter can be, and (unlike the state parameter) Proto will
            never mess with it.<br>这是一个相当绕的示范方式，示范了你可以将额外的数据作为第三个参数进行传递。对于该参数可以是什么，并没有限制，而且(与 state 参数不同) Proto 绝对不会干预它。
          </p>
<a name="boost_proto.users_guide.back_end.expression_transformation.data.implicit_parameters_to_primitive_transforms"></a><h6>
<a name="id3524013"></a>
            <a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.data.implicit_parameters_to_primitive_transforms">Implicit
            Parameters to Primitive Transforms 给基本变换的隐式参数</a>
          </h6>
<p>
            Let's use the above example to illustrate some other niceties of Proto
            transforms. We've seen that grammars, when used as function objects,
            can accept up to 3 parameters, and that when using these grammars in
            callable transforms, you can also specify up to 3 parameters. Let's take
            another look at the transform associated with non-terminals above:<br>让我们以上述例子为例，说明一下Proto变换的其它一些细节。我们已经看到，语法被作为函数对象使用时，可以接受多达3个参数，而且，把这些语法在可调用变换中使用时，你也可以指定最多3个参数。让我们再看看上述例子中与非终结符相关联的变换：
          </p>
<pre class="programlisting"><span class="identifier">StringCopy</span><span class="special">(</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span>
  <span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)</span>
  <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span>
<span class="special">)</span>
</pre>
<p>
            Here we specify all three parameters to both invocations of the <code class="computeroutput"><span class="identifier">StringCopy</span></code> grammar. But we don't have
            to specify all three. If we don't specify a third parameter, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span></code> is assumed. Likewise for the
            second parameter and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span></code>.
            So the above transform could have been written more simply as:<br>在此，我们对两次 <code class="computeroutput"><span class="identifier">StringCopy</span></code> 语法的调用都指定了所有三个参数。但是其实我们并不需要指定全部三个参数。如果我们不指定第三个参数，将会假定为 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span></code>。同样，第二个参数会假定为 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span></code>。所以，以上变换可以简化为：
          </p>
<pre class="programlisting"><span class="identifier">StringCopy</span><span class="special">(</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span>
  <span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">)</span>
<span class="special">)</span>
</pre>
<p>
            The same is true for any primitive transform. The following are all equivalent:<br>对于任意的基本变换，也是如此。以下写法都是等价的：
          </p>
<div class="table">
<a name="id3524296"></a><p class="title"><b>Table&nbsp;14.7.&nbsp;Implicit Parameters to Primitive Transforms<br>表&nbsp;14.7. 基本变换的隐式参数</b></p>
<div class="table-contents"><table class="table" summary="Implicit Parameters to Primitive Transforms">
<colgroup><col></colgroup>
<thead><tr><th>
                <p>
                  Equivalent Transforms 相互等价的变换
                </p>
                </th></tr></thead>
<tbody>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span>
                  <span class="identifier">StringCopy</span><span class="special">&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span>
                  <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">_</span><span class="special">)&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span>
                  <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">_</span><span class="special">,</span>
                  <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">)&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span>
                  <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">_</span><span class="special">,</span>
                  <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span>
                  <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)&gt;</span></code>
                </p>
                </td></tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Grammars Are Primitive Transforms Are Function
              Objects 语法是基本变换，也是函数对象</strong></span>
            </p>
<p>
              So far, we've said that all Proto grammars are function objects. But
              it's more accurate to say that Proto grammars are primitive transforms
              -- a special kind of function object that takes between 1 and 3 arguments,
              and that Proto knows to treat specially when used in a callable transform,
              as in the table above.<br>到目前为止，我们曾经说过，所有Proto语法都是函数对象。但是更准确的说法是，Proto语法是基本变换 -- 一种特定类型的函数对象，它接受1至3个参数，且Proto知道当语法被用在一个可调用变换中时，对其特殊看待，如上表所示。
            </p>
</td></tr>
</tbody></table></div>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Not All Function Objects Are Primitive Transforms 不是所有函数对象都是基本变换</strong></span>
            </p>
<p>
              You might be tempted now to drop the <code class="computeroutput"><span class="identifier">_state</span></code>
              and <code class="computeroutput"><span class="identifier">_data</span></code> parameters
              to <code class="computeroutput"><span class="identifier">WidenCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span>
              <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span>
              <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)</span></code>.
              That would be an error. <code class="computeroutput"><span class="identifier">WidenCopy</span></code>
              is just a plain function object, not a primitive transform, so you
              must specify all its arguments. We'll see later how to write your own
              primitive transforms.<br>也许现在你会想把 <code class="computeroutput"><span class="identifier">_state</span></code> 和 <code class="computeroutput"><span class="identifier">_data</span></code> 参数从 <code class="computeroutput"><span class="identifier">WidenCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">,</span>
              <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span>
              <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)</span></code> 中去掉。这样做是错误的。<code class="computeroutput"><span class="identifier">WidenCopy</span></code>
              只是一个普通的函数对象，而不是一个基本变换，所以你必须指定所有参数。稍后我们将看到如何编写你自己的基本变换。
            </p>
</td></tr>
</tbody></table></div>
<p>
            Once you know that primitive transforms will always receive all three
            parameters -- expression, state, and data -- it makes things possible
            that wouldn't be otherwise. For instance, consider that for binary expressions,
            these two transforms are equivalent. Can you see why?<br>一旦你知道了基本变换总是接受所有三个参数 -- 表达式、状态和数据 -- 这会让某些意外的事情成为可能。例如，对于二元表达式，以下两个变换是等价的。你能看出为什么吗？
          </p>
<div class="table">
<a name="id3524770"></a><p class="title"><b>Table&nbsp;14.8.&nbsp;Two Equivalent Transforms<br>表&nbsp;14.8. 两个等价的变换</b></p>
<div class="table-contents"><table class="table" summary="Two Equivalent Transforms">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  Without <code class="literal">proto::fold&lt;&gt;</code>
                </p>
                </th>
<th>
                <p>
                  With <code class="literal">proto::fold&lt;&gt;</code>
                </p>
                </th>
</tr></thead>
<tbody><tr>
<td>
                <p>
                  
</p>
<pre class="programlisting"><span class="identifier">StringCopy</span><span class="special">(</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span>
  <span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span><span class="special">)</span>
  <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span>
<span class="special">)</span></pre>
<p>
                </p>
                </td>
<td>
                <p>
                  
</p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">,</span> <span class="identifier">StringCopy</span><span class="special">&gt;</span></pre>
<p>
                </p>
                </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms" title="Proto's Built-In Transforms">
          Proto's Built-In Transforms &nbsp;Proto的内建变换</a>
</h5></div></div></div>
<p>
            Primitive transforms are the building blocks for more interesting composite
            transforms. Proto defines a bunch of generally useful primitive transforms.
            They are summarized below.<br>基本变换是有趣的复杂变换的构建块。Proto定义了一组常用的基本变换。概述如下。
          </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/_value.html" title="Struct _value">proto::_value</a></code></span></dt>
<dd><p>
                Given a terminal expression, return the value of the terminal.<br>给定一个终结符表达式，返回该终结符的值。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/_child_c.html" title="Struct template _child_c">proto::_child_c&lt;&gt;</a></code></span></dt>
<dd><p>
                Given a non-terminal expression, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  N
                </code></em>
                <span class="special">&gt;</span></code> returns the
                <em class="replaceable"><code>
                  N
                </code></em>
                -th child.<br>给定一个非终结符表达式，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  N
                </code></em>
                <span class="special">&gt;</span></code> 返回第<em class="replaceable"><code>N</code></em>个子节点。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="reference.html#boost.proto._child">proto::_child</a></code></span></dt>
<dd><p>
                A synonym for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code>.<br><code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code> 的同义词。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="reference.html#boost.proto._left">proto::_left</a></code></span></dt>
<dd><p>
                A synonym for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code>.<br><code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code> 的同义词。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="reference.html#boost.proto._right">proto::_right</a></code></span></dt>
<dd><p>
                A synonym for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span></code>.<br><code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span></code> 的同义词。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/_expr.html" title="Struct _expr">proto::_expr</a></code></span></dt>
<dd><p>
                Returns the current expression unmodified.<br>原样返回当前表达式。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/_state.html" title="Struct _state">proto::_state</a></code></span></dt>
<dd><p>
                Returns the current state unmodified.<br>原样返回当前状态。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/_data.html" title="Struct _data">proto::_data</a></code></span></dt>
<dd><p>
                Returns the current data unmodified.<br>原样返回当前数据。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/call.html" title="Struct template call">proto::call&lt;&gt;</a></code></span></dt>
<dd><p>
                For a given callable transform <code class="computeroutput">
                <em class="replaceable"><code>
                  CT
                </code></em>
                </code>, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  CT
                </code></em>
                <span class="special">&gt;</span></code> turns the callable transform
                into a primitive transform. This is useful for disambiguating callable
                transforms from object transforms, and also for working around compiler
                bugs with nested function types.<br>对于给定的可调用变换 <code class="computeroutput">
                <em class="replaceable"><code>
                  CT</code></em></code>，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  CT
                </code></em>
                <span class="special">&gt;</span></code> 将该可调用变换转为基本变换。这对于消除可调用变换与对象变换间的歧义非常有用，也可以绕过编译器中关于嵌套函数类型的缺陷。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/make.html" title="Struct template make">proto::make&lt;&gt;</a></code></span></dt>
<dd><p>
                For a given object transform <code class="computeroutput">
                <em class="replaceable"><code>
                  OT
                </code></em>
                </code>, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">make</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  OT
                </code></em>
                <span class="special">&gt;</span></code> turns the object transform
                into a primitive transform. This is useful for disambiguating object
                transforms from callable transforms, and also for working around
                compiler bugs with nested function types.<br>对于给定的对象变换 <code class="computeroutput">
                <em class="replaceable"><code>
                  OT</code></em></code>，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">make</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  OT
                </code></em>
                <span class="special">&gt;</span></code> 将该对象变换转为基本变换。这对于消除对象变换与可调用变换间的歧义非常有用，也可以绕过编译器中关于嵌套函数类型的缺陷。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/_default.html" title="Struct template _default">proto::_default&lt;&gt;</a></code></span></dt>
<dd><p>
                Given a grammar
                <em class="replaceable"><code>
                  G
                </code></em>
                , <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_default</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  G
                </code></em>
                <span class="special">&gt;</span></code> evaluates the current
                node according to the standard C++ meaning of the operation the node
                represents. For instance, if the current node is a binary plus node,
                the two children will both be evaluated according to <code class="computeroutput">
                <em class="replaceable"><code>
                  G
                </code></em>
                </code> and the results will be added and returned. The return type
                is deduced with the help of the Boost.Typeof library.<br>给定一个语法
                <em class="replaceable"><code>
                  G</code></em>，<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_default</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  G
                </code></em>
                <span class="special">&gt;</span></code> 根据该节点所代表的操作的标准C++意义对当前节点进行求值。例如，如果当前节点为二元加法节点，则根据 <code class="computeroutput">
                <em class="replaceable"><code>
                  G
                </code></em>
                </code> 对两个子节点进行求值，然后将结果相加并返回。返回类型用 Boost.Typeof 库来帮助推导。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/fold.html" title="Struct template fold">proto::fold&lt;&gt;</a></code></span></dt>
<dd><p>
                Given three transforms <code class="computeroutput">
                <em class="replaceable"><code>
                  ET
                </code></em>
                </code>, <code class="computeroutput">
                <em class="replaceable"><code>
                  ST
                </code></em>
                </code>, and <code class="computeroutput">
                <em class="replaceable"><code>
                  FT
                </code></em>
                </code>, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  ET
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  ST
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  FT
                </code></em>
                <span class="special">&gt;</span></code> first evaluates <code class="computeroutput">
                <em class="replaceable"><code>
                  ET
                </code></em>
                </code> to obtain a Fusion sequence and <code class="computeroutput">
                <em class="replaceable"><code>
                  ST
                </code></em>
                </code> to obtain an initial state for the fold, and then evaluates
                <code class="computeroutput">
                <em class="replaceable"><code>
                  FT
                </code></em>
                </code> for each element in the sequence to generate the next state
                from the previous.<br>给定三个变换 <code class="computeroutput">
                <em class="replaceable"><code>
                  ET
                </code></em>
                </code>, <code class="computeroutput">
                <em class="replaceable"><code>
                  ST
                </code></em>
                </code>, 和 <code class="computeroutput">
                <em class="replaceable"><code>
                  FT
                </code></em>
                </code>, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  ET
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  ST
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  FT
                </code></em>
                <span class="special">&gt;</span></code> 首先对 <code class="computeroutput">
                <em class="replaceable"><code>
                  ET
                </code></em>
                </code> 求值得到一个Fusion序列，然后对 <code class="computeroutput">
                <em class="replaceable"><code>
                  ST
                </code></em>
                </code> 求值得到一个用于折叠的初始状态，最后对
                <code class="computeroutput">
                <em class="replaceable"><code>
                  FT
                </code></em>
                </code> 求值，对于序列中的每个元素，由上一个状态生成下一个状态。<br>
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/reverse_fold.html" title="Struct template reverse_fold">proto::reverse_fold&lt;&gt;</a></code></span></dt>
<dd><p>
                Like <code class="computeroutput"><a class="link" href="../boost/proto/fold.html" title="Struct template fold">proto::fold&lt;&gt;</a></code>, except the elements
                in the Fusion sequence are iterated in reverse order.<br>与 <code class="computeroutput"><a class="link" href="../boost/proto/fold.html" title="Struct template fold">proto::fold&lt;&gt;</a></code> 类似，但是以相反顺序遍历Fusion序列中的元素。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/fold_tree.html" title="Struct template fold_tree">proto::fold_tree&lt;&gt;</a></code></span></dt>
<dd><p>
                Like <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  ET
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  ST
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  FT
                </code></em>
                <span class="special">&gt;</span></code>, except that the result
                of the <code class="computeroutput">
                <em class="replaceable"><code>
                  ET
                </code></em>
                </code> transform is treated as an expression tree that is <span class="emphasis"><em>flattened</em></span>
                to generate the sequence to be folded. Flattening an expression tree
                causes child nodes with the same tag type as the parent to be put
                into sequence. For instance, <code class="computeroutput"><span class="identifier">a</span>
                <span class="special">&gt;&gt;</span> <span class="identifier">b</span>
                <span class="special">&gt;&gt;</span> <span class="identifier">c</span></code>
                would be flattened to the sequence [<code class="computeroutput"><span class="identifier">a</span></code>,
                <code class="computeroutput"><span class="identifier">b</span></code>, <code class="computeroutput"><span class="identifier">c</span></code>], and this is the sequence that
                would be folded.<br>类似于 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  ET
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  ST
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  FT
                </code></em>
                <span class="special">&gt;</span></code>，但是 <code class="computeroutput">
                <em class="replaceable"><code>
                  ET
                </code></em>
                </code> 变换的结果被视为一棵表达式树，该树被压平后生成要折叠的序列。压平一棵表达式树将使得具有与父节点相同标签类型的子节点被放入序列中。例如，<code class="computeroutput"><span class="identifier">a</span>
                <span class="special">&gt;&gt;</span> <span class="identifier">b</span>
                <span class="special">&gt;&gt;</span> <span class="identifier">c</span></code>
                会被压平为序列 [<code class="computeroutput"><span class="identifier">a</span></code>,
                <code class="computeroutput"><span class="identifier">b</span></code>, <code class="computeroutput"><span class="identifier">c</span></code>]，该序列将被折叠。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/reverse_fold_tree.html" title="Struct template reverse_fold_tree">proto::reverse_fold_tree&lt;&gt;</a></code></span></dt>
<dd><p>
                Like <code class="computeroutput"><a class="link" href="../boost/proto/fold_tree.html" title="Struct template fold_tree">proto::fold_tree&lt;&gt;</a></code>, except that
                the flattened sequence is iterated in reverse order.<br>类似于 <code class="computeroutput"><a class="link" href="../boost/proto/fold_tree.html" title="Struct template fold_tree">proto::fold_tree&lt;&gt;</a></code>，不过是以相反顺序遍历压平的序列。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/lazy.html" title="Struct template lazy">proto::lazy&lt;&gt;</a></code></span></dt>
<dd><p>
                A combination of <code class="computeroutput"><a class="link" href="../boost/proto/make.html" title="Struct template make">proto::make&lt;&gt;</a></code>
                and <code class="computeroutput"><a class="link" href="../boost/proto/call.html" title="Struct template call">proto::call&lt;&gt;</a></code> that is useful
                when the nature of the transform depends on the expression, state
                and/or data parameters. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">lazy</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">...</span><span class="identifier">An</span><span class="special">)&gt;</span></code> first evaluates <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">make</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">()&gt;</span></code>
                to compute a callable type <code class="computeroutput"><span class="identifier">R2</span></code>.
                Then, it evaluates <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span><span class="identifier">R2</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">...</span><span class="identifier">An</span><span class="special">)&gt;</span></code>.<br><code class="computeroutput"><a class="link" href="../boost/proto/make.html" title="Struct template make">proto::make&lt;&gt;</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/proto/call.html" title="Struct template call">proto::call&lt;&gt;</a></code> 的组合，当变换的本性是依赖于表达式、状态和/或数据参数时使用。<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">lazy</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">...</span><span class="identifier">An</span><span class="special">)&gt;</span></code> 首先对 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">make</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">()&gt;</span></code>
                求值以计算一个可调用类型 <code class="computeroutput"><span class="identifier">R2</span></code>。然后对 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span><span class="identifier">R2</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">...</span><span class="identifier">An</span><span class="special">)&gt;</span></code> 求值。
              </p></dd>
</dl>
</div>
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.all_grammars_are_primitive_transforms"></a><h6>
<a name="id3526169"></a>
            <a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms.all_grammars_are_primitive_transforms">All
            Grammars Are Primitive Transforms 所有语法都是基本变换</a>
          </h6>
<p>
            In addition to the above primitive transforms, all of Proto's grammar
            elements are also primitive transforms. Their behaviors are described
            below.<br>除了以上的基本变换外，所有的Proto语法元素也都是基本变换。它们的行为描述如下。
          </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/_.html" title="Struct _">proto::_</a></code></span></dt>
<dd><p>
                Return the current expression unmodified.<br>原样返回当前表达式。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code></span></dt>
<dd><p>
                For the specified set of alternate sub-grammars, find the one that
                matches the given expression and apply its associated transform.<br>对于指定的候选子语法集，找出与给定表达式相匹配的候选项，并应用其相关联的变换。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code></span></dt>
<dd><p>
                For the given set of sub-grammars, take the <span class="emphasis"><em>last</em></span>
                sub-grammar and apply its associated transform.<br>对于给定的子语法集，取<span style="font-style: italic;">最后一个</span>子语法，并应用其相关联的变换。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/not_.html" title="Struct template not_">proto::not_&lt;&gt;</a></code></span></dt>
<dd><p>
                Return the current expression unmodified.<br>原样返回当前表达式。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code></span></dt>
<dd><p>
                Given three transforms, evaluate the first and treat the result as
                a compile-time Boolean value. If it is true, evaluate the second
                transform. Otherwise, evaluate the third.<br>给定三个变换，对第一个进行求值，将结果视为一个编译期布尔值。如果该值为真，对第二个变换求值。否则对第三个变换求值。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code></span></dt>
<dd><p>
                As with <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>, find the sub-grammar
                that matches the given expression and apply its associated transform.<br>类似于 <code class="computeroutput"><a class="link" href="../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>，找出与给定表达式相匹配的子语法，并应其相关联的变换。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code></span></dt>
<dd><p>
                Return the current terminal expression unmodified.<br>原样返回当前的终结符表达式。
              </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code>,
            <code class="computeroutput"><a class="link" href="../boost/proto/nary_expr.html" title="Struct template nary_expr">proto::nary_expr&lt;&gt;</a></code>, et. al.</span></dt>
<dd><p>
                A Proto grammar that matches a non-terminal such as <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  G0
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  G1
                </code></em>
                <span class="special">&gt;</span></code>, when used as a primitive
                transform, creates a new plus node where the left child is transformed
                according to <code class="computeroutput">
                <em class="replaceable"><code>
                  G0
                </code></em>
                </code> and the right child with <code class="computeroutput">
                <em class="replaceable"><code>
                  G1
                </code></em>
                </code>.<br>匹配一个形如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span>
                <em class="replaceable"><code>
                  G0
                </code></em>
                <span class="special">,</span>
                <em class="replaceable"><code>
                  G1
                </code></em>
                <span class="special">&gt;</span></code> 的非终结符的Proto语法，当被用作为一个基本变换时，创建一个新的加法节点，其中左子节点依据 <code class="computeroutput">
                <em class="replaceable"><code>
                  G0
                </code></em>
                </code> 进行变换，而右子节点依据 <code class="computeroutput">
                <em class="replaceable"><code>
                  G1&nbsp;</code></em></code>进行变换。
              </p></dd>
</dl>
</div>
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_pass_through_transform"></a><h6>
<a name="id3526488"></a>
            <a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_pass_through_transform">The
            Pass-Through Transform 直通变换</a>
          </h6>
<p>
            Note the primitive transform associated with grammar elements such as
            <code class="computeroutput"><a class="link" href="../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code> described above.
            They possess a so-called <span class="emphasis"><em>pass-through</em></span> transform.
            The pass-through transform accepts an expression of a certain tag type
            (say, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span></code>) and creates a new expression
            of the same tag type, where each child expression is transformed according
            to the corresponding child grammar of the pass-through transform. So
            for instance this grammar ...<br>留意一下前面所介绍的与
            <code class="computeroutput"><a class="link" href="../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code> 这样的语法元素相对应原基本变换。它们持有一个所谓的<span class="emphasis"><em>直通</em></span>变换。直通变换接受某个标签类型(如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span></code>)的表达式，并创建一个相同标签类型的新表达式，其中的各个子表达式是由依照直通变换的相应子语法变换而来的。例如以下语法 ...
          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span> <span class="identifier">X</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span> <span class="special">&gt;</span>
</pre>
<p>
            ... matches function expressions where the first child matches the <code class="computeroutput"><span class="identifier">X</span></code> grammar and the rest match the <code class="computeroutput"><span class="identifier">Y</span></code> grammar. When used as a transform,
            the above grammar will create a new function expression where the first
            child is transformed according to <code class="computeroutput"><span class="identifier">X</span></code>
            and the rest are transformed according to <code class="computeroutput"><span class="identifier">Y</span></code>.&nbsp;<br>... 它匹配那些第一个子节点与 <code class="computeroutput"><span class="identifier">X</span></code> 语法相匹配而其余部分与 <code class="computeroutput"><span class="identifier">Y</span></code> 语法相匹配的函数表达式。当上述语法被用作一个变换时，它将创建一个新的函数表达式，其第一个子节点是依照 <code class="computeroutput"><span class="identifier">X</span></code>
            变换而来的，剩余部分则依照 <code class="computeroutput"><span class="identifier">Y</span></code> 变换而来。
          </p>
<p>
            The following class templates in Proto can be used as grammars with pass-through
            transforms:<br>Proto中的以下类模板可以用作带直通变换的语法：
          </p>
<div class="table">
<a name="id3526675"></a><p class="title"><b>Table&nbsp;14.9.&nbsp;Class Templates With Pass-Through Transforms<br>表&nbsp;14.9. 带直通变换的类模板</b></p>
<div class="table-contents"><table class="table" summary="Class Templates With Pass-Through Transforms">
<colgroup><col></colgroup>
<thead><tr><th>
                <p>
                  Templates with Pass-Through Transforms 带直通变换的模板
                </p>
                </th></tr></thead>
<tbody>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">negate</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">dereference</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">complement</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_not</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pre_inc</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pre_dec</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">post_inc</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">post_dec</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">less_equal</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">greater_equal</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_equal_to</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_or</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_and</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_and</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_or</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_xor</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">comma</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">mem_ptr</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_and_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_or_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_xor_assign</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">subscript</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">if_else_</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_expr</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">binary_expr</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
<tr><td>
                <p>
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;&gt;</span></code>
                </p>
                </td></tr>
</tbody>
</table></div>
</div>
<br class="table-break"><a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_many_roles_of_proto_operator_metafunctions"></a><h6>
<a name="id3528238"></a>
            <a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_many_roles_of_proto_operator_metafunctions">The
            Many Roles of Proto Operator Metafunctions &nbsp;Proto操作符元函数的多重角色</a>
          </h6>
<p>
            We've seen templates such as <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>,
            <code class="computeroutput"><a class="link" href="../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code> and <code class="computeroutput"><a class="link" href="../boost/proto/nary_expr.html" title="Struct template nary_expr">proto::nary_expr&lt;&gt;</a></code>
            fill many roles. They are metafunction that generate expression types.
            They are grammars that match expression types. And they are primitive
            transforms. The following code samples show examples of each.<br>我们已经看到，象 <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>,
            <code class="computeroutput"><a class="link" href="../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/proto/nary_expr.html" title="Struct template nary_expr">proto::nary_expr&lt;&gt;</a></code>
            这些模板充当了多重角色。它们是生成表达式类型的元函数。它们是匹配表达式类型的语法。它们也是基本变换。以下代码展现了它们的各种例子。
          </p>
<p>
            <span class="bold"><strong>As Metafunctions ... 作为元函数...</strong></span>
          </p>
<pre class="programlisting"><span class="comment">// proto::terminal&lt;&gt; and proto::plus&lt;&gt; are metafunctions<br></span><span class="comment">// that generate expression types:<br>// proto::terminal&lt;&gt;和proto::plus&lt;&gt;是生成表达式类型的元函数：<br></span><span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">int_</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">int_</span><span class="special">,</span> <span class="identifier">int_</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">plus_</span><span class="special">;</span>

<span class="identifier">int_</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">{</span><span class="number">42</span><span class="special">},</span> <span class="identifier">j</span> <span class="special">=</span> <span class="special">{</span><span class="number">24</span><span class="special">};</span>
<span class="identifier">plus_</span> <span class="identifier">p</span> <span class="special">=</span> <span class="special">{</span><span class="identifier">i</span><span class="special">,</span> <span class="identifier">j</span><span class="special">};</span>
</pre>
<p>
            <span class="bold"><strong>As Grammars ... 作为语法...</strong></span>
          </p>
<pre class="programlisting"><span class="comment">// proto::terminal&lt;&gt; and proto::plus&lt;&gt; are grammars that<br></span><span class="comment">// match expression types<br>// proto::terminal&lt;&gt;和proto::plus&lt;&gt;是匹配表达式类型的语法<br></span><span class="keyword">struct</span> <span class="identifier">Int</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Plus</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Int</span><span class="special">,</span> <span class="identifier">Int</span><span class="special">&gt;</span> <span class="special">{};</span>

<span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">int_</span><span class="special">,</span> <span class="identifier">Int</span> <span class="special">&gt;</span> <span class="special">));</span>
<span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">plus_</span><span class="special">,</span> <span class="identifier">Plus</span> <span class="special">&gt;</span> <span class="special">));</span>
</pre>
<p>
            <span class="bold"><strong>As Primitive Transforms ... 作为基本变换...</strong></span>
          </p>
<pre class="programlisting"><span class="comment">// A transform that removes all unary_plus nodes in an expression<br>// 一个将表达式中的所有unary_plus节点移除的变换<br></span><span class="keyword">struct</span> <span class="identifier">RemoveUnaryPlus</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&lt;</span><span class="identifier">RemoveUnaryPlus</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">RemoveUnaryPlus</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child</span><span class="special">)</span>
        <span class="special">&gt;</span>
        <span class="comment">// Use proto::terminal&lt;&gt; and proto::nary_expr&lt;&gt;<br></span>        <span class="comment">// both as grammars and as primitive transforms.<br>        // 把proto::terminal&lt;&gt;和proto::nary_expr&lt;&gt;同时用作语法和基本变换。<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">RemoveUnaryPlus</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>

    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">display_expr</span><span class="special">(</span> <br>        <span class="special">+</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+(</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">);</span>

    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">display_expr</span><span class="special">(</span> <br>        <span class="identifier">RemoveUnaryPlus</span><span class="special">()(</span> <span class="special">+</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+(</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+</span><span class="identifier">i</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            The above code displays the following, which shows that unary plus nodes
            have been stripped from the expression:<br>以上代码输出如下，可以看到单参数加法已经从表达式中去掉了：
          </p>
<pre class="programlisting">minus(<br>    unary_plus(<br>        terminal(0)<br>    )<br>  , unary_plus(<br>        minus(<br>            terminal(0)<br>          , unary_plus(<br>                terminal(0)<br>            )<br>        )<br>    )<br>)<br>minus(<br>    terminal(0)<br>  , minus(<br>        terminal(0)<br>      , terminal(0)<br>    )<br>)<br></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.primitives"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.primitives" title="Building Custom Primitive Transforms">
          Building Custom Primitive Transforms 构建定制的基本变换</a>
</h5></div></div></div>
<p>
            In previous sections, we've seen how to compose larger transforms out
            of smaller transforms using function types. The smaller transforms from
            which larger transforms are composed are <span class="emphasis"><em>primitive transforms</em></span>,
            and Proto provides a bunch of common ones such as <code class="computeroutput"><span class="identifier">_child0</span></code>
            and <code class="computeroutput"><span class="identifier">_value</span></code>. In this section
            we'll see how to author your own primitive transforms.<br>在上一节中，我们看到了用函数类型从较小的变换组合出较大的变换。组成较大变换的较小变换是<span class="emphasis"><em>基本变换</em></span>，Proto提供了一组常用的基本变换，如 <code class="computeroutput"><span class="identifier">_child0</span></code> 和 <code class="computeroutput"><span class="identifier">_value</span></code>。在本节中，我们将看看如何创作你自己的基本变换。
          </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
              There are a few reasons why you might want to write your own primitive
              transforms. For instance, your transform may be complicated, and composing
              it out of primitives becomes unwieldy. You might also need to work
              around compiler bugs on legacy compilers that make composing transforms
              using function types problematic. Finally, you might also decide to
              define your own primitive transforms to improve compile times. Since
              Proto can simply invoke a primitive transform directly without having
              to process arguments or differentiate callable transforms from object
              transforms, primitive transforms are more efficient.</p><p>为
什么你可能会想编写自己的基本变换呢？这有几个原因。例如，你的变换可能很复杂，由基本变换组合出来会很笨重。你也可能需要绕过一些旧编译器中的缺陷，如
用函数类型来组合变换时存在问题。最后，你还可能决定定义你自己的基本变换来改进编译时间。由于Proto可以直接调用一个基本变换，而无须处理参数或区
分可调用变换与对象变换，所以基本变换会更为高效。
            </p></td></tr>
</tbody></table></div>
<p>
            Primitive transforms inherit from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform</span><span class="special">&lt;&gt;</span></code> and have a nested <code class="computeroutput"><span class="identifier">impl</span><span class="special">&lt;&gt;</span></code>
            template that inherits from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform_impl</span><span class="special">&lt;&gt;</span></code>. For example, this is how Proto
            defines the <code class="computeroutput"><span class="identifier">_child_c</span><span class="special">&lt;</span>
            <em class="replaceable"><code>
              N
            </code></em>
            <span class="special">&gt;</span></code> transform, which returns
            the
            <em class="replaceable"><code>
              N
            </code></em>
            -th child of the current expression:<br>基本变换继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform</span><span class="special">&lt;&gt;</span></code> 且带有一个嵌套的 <code class="computeroutput"><span class="identifier">impl</span><span class="special">&lt;&gt;</span></code>
            模板，该模板继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform_impl</span><span class="special">&lt;&gt;</span></code>。例如，以下是Proto定义 <code class="computeroutput"><span class="identifier">_child_c</span><span class="special">&lt;</span>
            <em class="replaceable"><code>
              N
            </code></em>
            <span class="special">&gt;</span></code> 变换的方法，该变换返回当前表达式的第<em class="replaceable"><code>N</code></em>个子节点。
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">proto</span>
<span class="special">{</span>
    <span class="comment">// A primitive transform that returns N-th child<br></span>    <span class="comment">// of the current expression.<br>    // 返回当前表达式的第N个子节点的基本变换。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">N</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">_child_c</span> <span class="special">:</span> <span class="identifier">transform</span><span class="special">&lt;</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">State</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Data</span><span class="special">&gt;</span>
        <span class="keyword">struct</span> <span class="identifier">impl</span> <span class="special">:</span> <span class="identifier">transform_impl</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">State</span><span class="special">,</span> <span class="identifier">Data</span><span class="special">&gt;</span>
        <span class="special">{</span>
            <span class="keyword">typedef</span>
                <span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">N</span><span class="special">&gt;::</span><span class="identifier">type</span>
            <span class="identifier">result_type</span><span class="special">;</span>

            <span class="identifier">result_type</span> <span class="keyword">operator</span> <span class="special">()(</span>
                <span class="keyword">typename</span> <span class="identifier">impl</span><span class="special">::</span><span class="identifier">expr_param</span> <span class="identifier">expr</span>
              <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">impl</span><span class="special">::</span><span class="identifier">state_param</span> <span class="identifier">state</span>
              <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">impl</span><span class="special">::</span><span class="identifier">data_param</span> <span class="identifier">data</span>
            <span class="special">)</span> <span class="keyword">const</span>
            <span class="special">{</span>
                <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">child_c</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">);</span>
            <span class="special">}</span>
        <span class="special">};</span>
    <span class="special">};</span>

    <span class="comment">// Note that _child_c&lt;N&gt; is callable, so that<br></span>    <span class="comment">// it can be used in callable transforms, as:<br></span>    <span class="comment">//   _child_c&lt;0&gt;(_child_c&lt;1&gt;)<br>    // 注意，_child_c&lt;N&gt;是可调用的，这样它就可以在可调用<br>    // 变换中使用，如：_child_c&lt;0&gt;(_child_c&lt;1&gt;)<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">N</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span> <span class="special">&gt;</span>
      <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span>
    <span class="special">{};</span>
<span class="special">}}</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform</span><span class="special">&lt;&gt;</span></code>
            base class provides the <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> overloads and the nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            template that make your transform a valid function object. These are
            implemented in terms of the nested <code class="computeroutput"><span class="identifier">impl</span><span class="special">&lt;&gt;</span></code> template you define.<br>基类 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform</span><span class="special">&lt;&gt;</span></code>
            提供了 <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> 重载和嵌套的 <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            模板，使你的变换成为一个有效的函数对象。它们是依据你定义的嵌套 <code class="computeroutput"><span class="identifier">impl</span><span class="special">&lt;&gt;</span></code> 模板来实现的。
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform_impl</span><span class="special">&lt;&gt;</span></code>
            base class is a convenience. It provides some nested typedefs that are
            generally useful. They are specified in the table below:<br>基类 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">transform_impl</span><span class="special">&lt;&gt;</span></code>
            是一个便利的工具。它提供了一些常用的嵌套typedef。在下表中列出：
          </p>
<div class="table">
<a name="id3530194"></a><p class="title"><b>Table&nbsp;14.10.&nbsp;proto::transform_impl&lt;Expr, State, Data&gt;
          typedefs<br>表&nbsp;14.10.&nbsp;proto::transform_impl&lt;Expr, State, Data&gt; 的
          typedefs</b></p>
<div class="table-contents"><table class="table" summary="proto::transform_impl&lt;Expr, State, Data&gt;
          typedefs">
<colgroup><col><col></colgroup>
<thead><tr>
<th>
                <p>
                  typedef
                </p>
                </th>
<th>
                <p>
                  Equivalent To 等价于
                </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">expr</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">state</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">State</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">data</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Data</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">expr_param</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">add_reference</span><span class="special">&lt;</span><span class="keyword">typename</span>
                  <span class="identifier">add_const</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">state_param</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">add_reference</span><span class="special">&lt;</span><span class="keyword">typename</span>
                  <span class="identifier">add_const</span><span class="special">&lt;</span><span class="identifier">State</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
                </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">data_param</span></code>
                </p>
                </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">add_reference</span><span class="special">&lt;</span><span class="keyword">typename</span>
                  <span class="identifier">add_const</span><span class="special">&lt;</span><span class="identifier">Data</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
            You'll notice that <code class="computeroutput"><span class="identifier">_child_c</span><span class="special">::</span><span class="identifier">impl</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> takes arguments of types <code class="computeroutput"><span class="identifier">expr_param</span></code>, <code class="computeroutput"><span class="identifier">state_param</span></code>,
            and <code class="computeroutput"><span class="identifier">data_param</span></code>. The typedefs
            make it easy to accept arguments by reference or const reference accordingly.<br>你应该会留意到 <code class="computeroutput"><span class="identifier">_child_c</span><span class="special">::</span><span class="identifier">impl</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> 所接受的参数类型分别是 <code class="computeroutput"><span class="identifier">expr_param</span></code>, <code class="computeroutput"><span class="identifier">state_param</span></code>, 和 <code class="computeroutput"><span class="identifier">data_param</span></code>。这些 typedef 使得我们可以很容易地通过引用或常量引用来接受参数。
          </p>
<p>
            The only other interesting bit is the <code class="computeroutput"><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code> specialization, which will be
            described in the <a class="link" href="../">next
            section</a>.<br>现在，有趣的部分只剩下 <code class="computeroutput"><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code> 的特化了，它将在<a class="link" href="../">下一节</a>中介绍。
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.is_callable"></a><a class="link" href="users_guide.html#boost_proto.users_guide.back_end.expression_transformation.is_callable" title="Making Your Transform Callable">
          Making Your Transform Callable 让你的变换可调用</a>
</h5></div></div></div>
<p>
            Transforms are typically of the form <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">Something</span><span class="special">,</span> <span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">,...)</span> <span class="special">&gt;</span></code>.
            The question is whether <code class="computeroutput"><span class="identifier">R</span></code>
            represents a function to call or an object to construct, and the answer
            determines how <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> evaluates the transform.
            <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> uses the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code>
            trait to disambiguate between the two. Proto does its best to guess whether
            a type is callable or not, but it doesn't always get it right. It's best
            to know the rules Proto uses, so that you know when you need to be more
            explicit.<br>变换典型地具有形如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">Something</span><span class="special">,</span> <span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">,...)</span> <span class="special">&gt;</span></code> 的格式。问题是，<code class="computeroutput"><span class="identifier">R</span></code> 代表的是一个要调用的函数，抑或是一个要构造的对象，其答案取决于 <code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> 如何对该变换进行求值。<code class="computeroutput"><a class="link" href="../boost/proto/when.html" title="Struct template when">proto::when&lt;&gt;</a></code> 使用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code>
            trait 来区分这两者。Proto尽最大努力去猜测一个类型是否可调用，但是它不会总是猜对的。最好还是知道一下Proto所使用的规则，这样你就知道何时需要做得更清楚些。
          </p>
<p>
            For most types <code class="computeroutput"><span class="identifier">R</span></code>, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span></code>
            checks for inheritance from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>.
            However, if the type <code class="computeroutput"><span class="identifier">R</span></code>
            is a template specialization, Proto assumes that it is <span class="emphasis"><em>not</em></span>
            callable <span class="emphasis"><em>even if the template inherits from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code></em></span>.
            We'll see why in a minute. Consider the following erroneous callable
            object:<br>对于大多数类型 <code class="computeroutput"><span class="identifier">R</span></code>, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span></code>
            检查它是否继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>。不过，如果类型 <code class="computeroutput"><span class="identifier">R</span></code>
            是一个模板特化，Proto将会假定它<span style="font-style: italic;">不是</span>可调用的，<span class="emphasis"><em>即使该模板继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code></em></span>。等会我们将看到为什么会这样。考虑以下这个错误的可调用对象：
          </p>
<pre class="programlisting"><span class="comment">// Proto can't tell this defines something callable!<br>// Proto不能将这个定义认作为可调用的！<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">times2</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="identifier">i</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">i</span> <span class="special">*</span> <span class="number">2</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// ERROR! This is not going to multiply the int by 2:<br>// 错误！这不会把int乘以2：<br></span><span class="keyword">struct</span> <span class="identifier">IntTimes2</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The problem is that Proto doesn't know that <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> is callable, so rather that invoking
            the <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
            function object, Proto will try to construct a <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> object and initialize it will an
            <code class="computeroutput"><span class="keyword">int</span></code>. That will not compile.<br>问题在于，Proto不知道 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> 是可调用的，所以不会调用 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
            函数对象，Proto会尝试构造一个 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> 对象并将它初始化为
            <code class="computeroutput"><span class="keyword">int</span></code>。这样将不能编译。
          </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 备注</th>
</tr>
<tr><td align="left" valign="top"><p>
              Why can't Proto tell that <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> is callable? After all, it inherits
              from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>, and that is detectable,
              right? The problem is that merely asking whether some type <code class="computeroutput"><span class="identifier">X</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span></code>
              inherits from <code class="computeroutput"><span class="identifier">callable</span></code>
              will cause the template <code class="computeroutput"><span class="identifier">X</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span></code> to be instantiated. That's a problem
              for a type like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">_value</span><span class="special">(</span><span class="identifier">_child1</span><span class="special">)&gt;</span></code>. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code> will not suffer to be instantiated
              with <code class="computeroutput"><span class="identifier">_value</span><span class="special">(</span><span class="identifier">_child1</span><span class="special">)</span></code>
              as a template parameter. Since merely asking the question will sometimes
              result in a hard error, Proto can't ask; it has to assume that <code class="computeroutput"><span class="identifier">X</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span></code>
              represents an object to construct and not a function to call.<br>为什么Proto不能认为 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> 是可调用的呢？毕竟，它是继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code> 的，而且这是可以被检测到的，不是吗？问题是，哪怕只是询问一下 type <code class="computeroutput"><span class="identifier">X</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span></code>
              是否继承自 <code class="computeroutput"><span class="identifier">callable</span></code>，也会引起模板 <code class="computeroutput"><span class="identifier">X</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span></code> 的实例化。这对于象 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">_value</span><span class="special">(</span><span class="identifier">_child1</span><span class="special">)&gt;</span></code> 这样的类型来说就是一个问题。<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code> 不能忍受以 <code class="computeroutput"><span class="identifier">_value</span><span class="special">(</span><span class="identifier">_child1</span><span class="special">)</span></code>
              作为模板参数进行实例化。因为仅仅是询问一下这个问题，有时都会导致一个硬错误，所以Proto不能问；它必须假定 <code class="computeroutput"><span class="identifier">X</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span></code>
              代表的是一个要构造的对象，而不是一个要调用的函数。
            </p></td></tr>
</tbody></table></div>
<p>
            There are a couple of solutions to the <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> problem. One solution is to wrap
            the transform in <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;&gt;</span></code>. This forces Proto to treat
            <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
            as callable:<br>有几种方法来解决这个 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> 的问题。一种方法是，把这个变换包装在 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;&gt;</span></code> 中。这将强迫Proto把 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
            视为可调用的：
          </p>
<pre class="programlisting"><span class="comment">// OK, calls times2&lt;int&gt;  好的，可以调用times2&lt;int&gt;<br></span><span class="keyword">struct</span> <span class="identifier">IntTimes2</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            This can be a bit of a pain, because we need to wrap every use of <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>,
            which can be tedious and error prone, and makes our grammar cluttered
            and harder to read.<br>这可能有一点麻烦，因为我们需要对 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> 的每一次使用都进行包装，这是很乏味且易错的，也使得我们的语法显得混乱而更难阅读。
          </p>
<p>
            Another solution is to specialize <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code> on our <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code> template:<br>另一个方法是，针对我们的 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code> 模板特化 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;&gt;</span></code>：
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">proto</span>
<span class="special">{</span>
    <span class="comment">// Tell Proto that times2&lt;&gt; is callable 告诉Proto，times2&lt;&gt;是可调用的<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">times2</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span>
      <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span>
    <span class="special">{};</span>
<span class="special">}}</span>

<span class="comment">// OK, times2&lt;&gt; is callable  好的，times2&lt;&gt;是可调用的<br></span><span class="keyword">struct</span> <span class="identifier">IntTimes2</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            This is better, but still a pain because of the need to open Proto's
            namespace.<br>这个方法更好些，但还是有点麻烦，因为需要打开Proto的名字空间。
          </p>
<p>
            You could simply make sure that the callable type is not a template specialization.
            Consider the following:<br>你可以只需确保可调用类型不是一个模板特化。如下：
          </p>
<pre class="programlisting"><span class="comment">// No longer a template specialization!  不再是一个模板特化！<br></span><span class="keyword">struct</span> <span class="identifier">times2int</span> <span class="special">:</span> <span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">{};</span>

<span class="comment">// OK, times2int is callable  好的，times2int是可调用的<br></span><span class="keyword">struct</span> <span class="identifier">IntTimes2</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">times2int</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            This works because now Proto can tell that <code class="computeroutput"><span class="identifier">times2int</span></code>
            inherits (indirectly) from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>.
            Any non-template types can be safely checked for inheritance because,
            as they are not templates, there is no worry about instantiation errors.<br>这样可以用了，因为现在Proto可以认出 <code class="computeroutput"><span class="identifier">times2int</span></code>&nbsp;(间接地)继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>。任何非模板类型都可以安全地检查继承关系，因为它们不是模板，不需要担心实例化的错误。
          </p>
<p>
            There is one last way to tell Proto that <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code> is callable. You could add an
            extra dummy template parameter that defaults to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>:<br>以下是最后一种告知Proto <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code> 可调用的方法。你可以增加一个额外的哑模板参数，该参数的缺省值为 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>：
          </p>
<pre class="programlisting"><span class="comment">// Proto will recognize this as callable  Proto将此模板识别为可调用的<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Callable</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">times2</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="identifier">i</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">i</span> <span class="special">*</span> <span class="number">2</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// OK, this works!  好的，可以工作！<br></span><span class="keyword">struct</span> <span class="identifier">IntTimes2</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">times2</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            Note that in addition to the extra template parameter, <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code>
            still inherits from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>.
            That's not necessary in this example but it is good style because any
            types derived from <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code> (as <code class="computeroutput"><span class="identifier">times2int</span></code>
            defined above) will still be considered callable.<br>注意，增加了这个额外的模板参数后，<code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code>
            依然继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span></code>。在这个例子中，这是不必要的，但这是一个好的习惯，因为派生自 <code class="computeroutput"><span class="identifier">times2</span><span class="special">&lt;&gt;</span></code> 的任意类型(如前面的 <code class="computeroutput"><span class="identifier">times2int</span></code>)也还会被认为是可调用的。
          </p>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.examples"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples" title="Examples">Examples 示例</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.hello_world"> Hello
        World: Building an Expression Template and Evaluating It 构建一个表达式模板并对它求值</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.calc1"> Calc1: Defining
        an Evaluation Context 定义一个求值上下文</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.calc2"> Calc2: Adding
        Members Using <code class="literal">proto::extends&lt;&gt;</code></a></span><a href="users_guide.html#boost_proto.users_guide.examples.calc2"><span class="section"></span></a><a href="users_guide.html#boost_proto.users_guide.examples.calc2"> 用<span class="section"></span></a><a href="users_guide.html#boost_proto.users_guide.examples.calc2"><code class="literal">proto::extends&lt;&gt;</code></a><a href="users_guide.html#boost_proto.users_guide.examples.calc2">增加成员</a><a href="users_guide.html#boost_proto.users_guide.examples.calc2"><span class="section"></span></a></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.calc3"> Calc3: Defining
        a Simple Transform 定义一个简单的变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.lazy_vector"> Lazy
        Vector: Controlling Operator Overloads 控制操作符重载</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.rgb"> RGB: Type Manipulations
        with Proto Transforms 以Proto变换进行类型操作</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.tarray"> TArray: A
        Simple Linear Algebra Library 一个简单的线性代数库</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.vec3"> Vec3: Computing
        With Transforms and Contexts 用变换和上下文进行计算</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.vector"> Vector: Adapting
        a Non-Proto Terminal Type 适配一个非Proto的终结符类型</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.mixed"> Mixed: Adapting
        Several Non-Proto Terminal Types 适配多个非Proto的终结符类型</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.map_assign"> Map Assign:
        An Intermediate Transform 一个中间变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.future_group"> Future
        Group: A More Advanced Transform 更高级的变换</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples.lambda"> Lambda: A
        Simple Lambda Library with Proto 一个使用的Proto的简单Lambda库</a></span></dt>
</dl></div>
<p>
        A code example is worth a thousand words ...<br>一个代码示例抵得上千言万语...
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.hello_world"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.hello_world" title="Hello World: Building an Expression Template and Evaluating It"> Hello
        World: Building an Expression Template and Evaluating It 构建一个表达式模板并对它求值</a>
</h4></div></div></div>


<p>
          A trivial example which builds and expression template and evaluates it.<br>一个简单的例子，构建一个表达式模板并对它进行求值。</p>
<pre class="programlisting"><span class="comment">////////////////////////////////////////////////////////////////////<br></span><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">ostream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>

<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_context</span> <span class="identifier">ctx</span><span class="special">;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="string">"hello"</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="string">" world"</span> <span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.calc1"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.calc1" title="Calc1: Defining an Evaluation Context"> Calc1: Defining
        an Evaluation Context 定义一个求值上下文</a>
</h4></div></div></div>


<p>
          A simple example that builds a miniature domain-specific embedded language
          for lazy arithmetic expressions, with TR1 bind-style argument placeholders.<br>一个简单的例子，构建一个用于惰性算术表达式的微型领域专用嵌入式语言，使用TR1 bind风格的参数占位符。</p>
<pre class="programlisting"><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This is a simple example of how to build an arithmetic expression<br></span><span class="comment">// evaluator with placeholders.<br>// 这是一个简单的例子，关于如何构建一个带占位符的算术表达式求值器。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">placeholder</span> <span class="special">{};</span>

<span class="comment">// Define some placeholders<br></span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span> <span class="number">1</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span> <span class="number">2</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{}};</span>

<span class="comment">// Define a calculator context, for evaluating arithmetic expressions<br>// 定义一个计算器上下文，用于对算术表达式进行求值<br></span><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// The values bound to the placeholders 绑定至占位符的值<br></span>    <span class="keyword">double</span> <span class="identifier">d</span><span class="special">[</span><span class="number">2</span><span class="special">];</span>

    <span class="comment">// The result of evaluating arithmetic expressions 算术表达式的求值结果<br></span>    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">calculator_context</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">d</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">d1</span><span class="special">;</span>
        <span class="identifier">d</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">d2</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Handle the evaluation of the placeholder terminals 处理对占位符终结符的求值<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">d</span><span class="special">[</span> <span class="identifier">I</span> <span class="special">-</span> <span class="number">1</span> <span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">double</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Create a calculator context with d1 and d2 substituted for _1 and _2<br>    // 创建一个计算器上下文，以d1和d2替代_1和_2<br></span>    <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">d1</span><span class="special">,</span> <span class="identifier">d2</span><span class="special">);</span>

    <span class="comment">// Evaluate the calculator expression with the calculator_context<br>    // 以calculator_context对计算器表达式进行求值<br></span>    <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// Displays "5"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">_1</span> <span class="special">+</span> <span class="number">2.0</span><span class="special">,</span> <span class="number">3.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Displays "6"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_2</span><span class="special">,</span> <span class="number">3.0</span><span class="special">,</span> <span class="number">2.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Displays "0.5"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="special">(</span><span class="identifier">_1</span> <span class="special">-</span> <span class="identifier">_2</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span><span class="special">,</span> <span class="number">3.0</span><span class="special">,</span> <span class="number">2.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.calc2"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.calc2" title="Calc2: Adding Members Using proto::extends&lt;&gt;"> Calc2: Adding
        Members Using <code class="literal">proto::extends&lt;&gt;</code>&nbsp;用 <code class="literal">proto::extends&lt;&gt;</code>&nbsp;增加成员<code class="literal"></code></a></h4></div></div></div>



<p>
          An extension of the Calc1 example that uses <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
          to make calculator expressions valid function objects that can be used
          with STL algorithms.<br>对Calc1例子的扩展，使用 <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
          来让计算器表达式的有效函数对象可以用于STL算法。</p>
<pre class="programlisting"><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This example enhances the simple arithmetic expression evaluator<br></span><span class="comment">// in calc1.cpp by using proto::extends to make arithmetic<br></span><span class="comment">// expressions immediately evaluable with operator (), a-la a<br></span><span class="comment">// function object<br>// 这个例子增强了在calc1.cpp中的简单算术表达式计算器，通过使用proto::extends<br>// 来让算术表达式可以按函数对象的方式用operator()进行立即求值<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="comment">// Will be used to define the placeholders _1 and _2 用于定义占位符_1和_2<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">placeholder</span> <span class="special">{};</span>

<span class="comment">// For expressions in the calculator domain, operator ()<br></span><span class="comment">// will be special; it will evaluate the expression.<br>// 对于计算器领域中的表达式，operator()将被特殊化；它会对表达式进行求值。<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span><span class="special">;</span>

<span class="comment">// Define a calculator context, for evaluating arithmetic expressions<br></span><span class="comment">// (This is as before, in calc1.cpp)<br>// 定义一个计算器上下文，用于对算术表达式进行求值(和前面calc1.cpp一样)<br></span><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// The values bound to the placeholders 绑定到占位符的值<br></span>    <span class="keyword">double</span> <span class="identifier">d</span><span class="special">[</span><span class="number">2</span><span class="special">];</span>

    <span class="comment">// The result of evaluating arithmetic expressions 算术表达式的求值结果<br></span>    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">calculator_context</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">d</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">d1</span><span class="special">;</span>
        <span class="identifier">d</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">d2</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Handle the evaluation of the placeholder terminals 处理占位符终结符的求值<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">d</span><span class="special">[</span> <span class="identifier">I</span> <span class="special">-</span> <span class="number">1</span> <span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Wrap all calculator expressions in this type, which defines<br></span><span class="comment">// operator () to evaluate the expression.<br>// 将所有计算器表达式包入此类型中，它定义了operator()来对表达式进行求值。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator_expression</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">calculator_expression</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">())</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">using</span> <span class="identifier">base_type</span><span class="special">::</span><span class="keyword">operator</span> <span class="special">=;</span>

    <span class="comment">// Override operator () to evaluate the expression<br>    // 重载operator()来对表达式求值<br></span>    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="keyword">double</span> <span class="identifier">d1</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">d1</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="keyword">double</span> <span class="identifier">d1</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">d1</span><span class="special">,</span> <span class="identifier">d2</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Tell proto how to generate expressions in the calculator_domain<br>// 告知proto如何生成calculator_domain中的表达式<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator_expression</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Define some placeholders (notice they're wrapped in calculator_expression&lt;&gt;)<br>// 定义一些占位符(注意，它们被包在calculator_expression&lt;&gt;中)<br></span><span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span> <span class="number">1</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span> <span class="number">2</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>

<span class="comment">// Now, our arithmetic expressions are immediately executable function objects:<br>// 现在，我们的算术表达式变成了可以立即执行的函数对象：<br></span><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// Displays "5"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">_1</span> <span class="special">+</span> <span class="number">2.0</span><span class="special">)(</span> <span class="number">3.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Displays "6"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">(</span> <span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_2</span> <span class="special">)(</span> <span class="number">3.0</span><span class="special">,</span> <span class="number">2.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Displays "0.5"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">_1</span> <span class="special">-</span> <span class="identifier">_2</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">)(</span> <span class="number">3.0</span><span class="special">,</span> <span class="number">2.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.calc3"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.calc3" title="Calc3: Defining a Simple Transform"> Calc3: Defining
        a Simple Transform 定义一个简单的变换</a>
</h4></div></div></div>


<p>
          An extension of the Calc2 example that uses a Proto transform to calculate
          the arity of a calculator expression and statically assert that the correct
          number of arguments are passed.<br>Calc2例子的一个扩展，使用一个Proto变换来计算一个计算器表达式的arity，并静态地对传入的参数数量进行断言。</p>
<pre class="programlisting"><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This example enhances the arithmetic expression evaluator<br></span><span class="comment">// in calc2.cpp by using a proto transform to calculate the<br></span><span class="comment">// number of arguments an expression requires and using a<br></span><span class="comment">// compile-time assert to guarantee that the right number of<br></span><span class="comment">// arguments are actually specified.<br>// 这个例子增强了calc2.cpp中的算术表达式求值器，通过使用一个proto变换来计算一个<br>// 表达式所要求的参数数量，并使用一个编译期断言来保证实际给定的参数数量是正确的。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">min_max</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">transform</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="comment">// Will be used to define the placeholders _1 and _2 用于定义占位符_1和_2<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">I</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">placeholder</span> <span class="special">:</span> <span class="identifier">I</span> <span class="special">{};</span>

<span class="comment">// This grammar basically says that a calculator expression is one of:<br></span><span class="comment">//   - A placeholder terminal<br></span><span class="comment">//   - Some other terminal<br></span><span class="comment">//   - Some non-terminal whose children are calculator expressions<br></span><span class="comment">// In addition, it has transforms that say how to calculate the<br></span><span class="comment">// expression arity for each of the three cases.<br>// 这个语法基本上是说，一个计算器表达式应为以下之一：<br>//   - 一个占位符终结符<br>//   - 其它终结符<br>//   - 非终结符，其子节点为计算器表达式<br>// 另外，它带有一些变换，分别说明了在这三种情况下如何计算表达式的arity。<br></span><span class="keyword">struct</span> <span class="identifier">CalculatorGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>

        <span class="comment">// placeholders have a non-zero arity ... 占位符具有非0的arity...<br></span>        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span> <span class="special">&gt;</span>

        <span class="comment">// Any other terminals have arity 0 ... 其它终结符的arity为0<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;()</span> <span class="special">&gt;</span>

        <span class="comment">// For any non-terminals, find the arity of the children and<br></span>        <span class="comment">// take the maximum. This is recursive.<br>        // 对于任意的非终结符，找出各个子节点的arity并计算其中的最大值。这是递归的。<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span>
             <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(),</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;</span><span class="identifier">CalculatorGrammar</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">&gt;()</span> <span class="special">&gt;</span> <span class="special">&gt;</span>

    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Simple wrapper for calculating a calculator expression's arity.<br></span><span class="comment">// It specifies mpl::int_&lt;0&gt; as the initial state. The data, which<br></span><span class="comment">// is not used, is mpl::void_.<br>// 一个简单的包装器，用于计算一个计算器表达式的arity。它指定mpl::int_&lt;0&gt;为<br>// 初始状态。数据参数未使用，为mpl::void_。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator_arity</span>
  <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">CalculatorGrammar</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">void_</span><span class="special">)&gt;</span>
<span class="special">{};</span>

<span class="comment">// For expressions in the calculator domain, operator ()<br></span><span class="comment">// will be special; it will evaluate the expression.<br>// 对于计算器领域中的表达式，operator()被特殊化；它将对表达式进行求值。<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span><span class="special">;</span>

<span class="comment">// Define a calculator context, for evaluating arithmetic expressions<br></span><span class="comment">// (This is as before, in calc1.cpp and calc2.cpp)<br>// 定义一个计算器上下文，用于对算术表达式求值(与calc1.cpp和calc2.cpp中的一样)<br></span><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// The values bound to the placeholders 绑定至占位符的值<br></span>    <span class="keyword">double</span> <span class="identifier">d</span><span class="special">[</span><span class="number">2</span><span class="special">];</span>

    <span class="comment">// The result of evaluating arithmetic expressions 算术表达式的求值结果<br></span>    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">calculator_context</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">d</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">d1</span><span class="special">;</span>
        <span class="identifier">d</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">d2</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Handle the evaluation of the placeholder terminals 处理对占位符终结符的求值<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">d</span><span class="special">[</span> <span class="identifier">I</span><span class="special">()</span> <span class="special">-</span> <span class="number">1</span> <span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Wrap all calculator expressions in this type, which defines<br></span><span class="comment">// operator () to evaluate the expression.<br>// 将所有计算器表达式包入此类型，它定义了operator()来对表达式进行求值<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator_expression</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">calculator_expression</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">())</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">using</span> <span class="identifier">base_type</span><span class="special">::</span><span class="keyword">operator</span> <span class="special">=;</span>

    <span class="comment">// Override operator () to evaluate the expression<br>    // 重载operator()来对表达式进行求值<br></span>    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// Assert that the expression has arity 0<br></span>        <span class="identifier">BOOST_MPL_ASSERT_RELATION</span><span class="special">(</span><span class="number">0</span><span class="special">,</span> <span class="special">==,</span> <span class="identifier">calculator_arity</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">);</span>
        <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="keyword">double</span> <span class="identifier">d1</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// Assert that the expression has arity 1 断言该表达式的arity为1<br></span>        <span class="identifier">BOOST_MPL_ASSERT_RELATION</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="special">==,</span> <span class="identifier">calculator_arity</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">);</span>
        <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">d1</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">double</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="keyword">double</span> <span class="identifier">d1</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// Assert that the expression has arity 2 断言该表达式的arity为2<br></span>        <span class="identifier">BOOST_MPL_ASSERT_RELATION</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="special">==,</span> <span class="identifier">calculator_arity</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">);</span>
        <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">d1</span><span class="special">,</span> <span class="identifier">d2</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Tell proto how to generate expressions in the calculator_domain<br>// 告知proto如何生成calculator_domain中的表达式<br></span><span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator_expression</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Define some placeholders (notice they're wrapped in calculator_expression&lt;&gt;)<br>// 定义一些占位符(注意，它们被包装在calculator_expression&lt;&gt;中)<br></span><span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator_expression</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>

<span class="comment">// Now, our arithmetic expressions are immediately executable function objects:<br>// 现在，我们的算术表达式变成了可以立即执行的函数对象：<br></span><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// Displays "5"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">_1</span> <span class="special">+</span> <span class="number">2.0</span><span class="special">)(</span> <span class="number">3.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Displays "6"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">(</span> <span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_2</span> <span class="special">)(</span> <span class="number">3.0</span><span class="special">,</span> <span class="number">2.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Displays "0.5"<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">_1</span> <span class="special">-</span> <span class="identifier">_2</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">)(</span> <span class="number">3.0</span><span class="special">,</span> <span class="number">2.0</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// This won't compile because the arity of the<br></span>    <span class="comment">// expression doesn't match the number of arguments<br>    // 以下不能编译，因为该表达式的arity与参数数量不匹配<br></span>    <span class="comment">// ( (_1 - _2) / _2 )( 3.0 );<br></span>    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.lazy_vector"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.lazy_vector" title="Lazy Vector: Controlling Operator Overloads"> Lazy
        Vector: Controlling Operator Overloads 控制操作符重载</a>
</h4></div></div></div>
<p>
          This example constructs a mini-library for linear algebra, using expression
          templates to eliminate the need for temporaries when adding vectors of
          numbers.<br>这个例子构建一个线性代数的小型库，使用了表达式模板来消除数字向量相加时的临时对象。
        </p>


<p>
          This example uses a domain with a grammar to prune the set of overloaded
          operators. Only those operators that produce valid lazy vector expressions
          are allowed.<br>这个例子使用了一个带语法的领域来减少操作符的重载。只有那些可以生成有效的惰性向量表达式的操作符被允许。</p>
<pre class="programlisting"><span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This example constructs a mini-library for linear algebra, using<br></span><span class="comment">// expression templates to eliminate the need for temporaries when<br></span><span class="comment">// adding vectors of numbers.<br>// 这个例子构建一个线性代数的小型库，使用了表达式模板来消除数字向量相加时的临时对象。<br></span><span class="comment">//<br></span><span class="comment">// This example uses a domain with a grammar to prune the set<br></span><span class="comment">// of overloaded operators. Only those operators that produce<br></span><span class="comment">// valid lazy vector expressions are allowed.<br>// 这个例子使用了一个带语法的领域来减少操作符的重载。只有那些可以生成有<br>// 有效的惰性向量表达式的操作符被允许。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="comment">// This grammar describes which lazy vector expressions<br></span><span class="comment">// are allowed; namely, vector terminals and addition<br></span><span class="comment">// and subtraction of lazy vector expressions.<br>// 这个语法描述了哪些惰性向量表达式可以使用；即只允许向量终结符<br>// 以及惰性向量表达式的加法和减法。<br></span><span class="keyword">struct</span> <span class="identifier">LazyVectorGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">LazyVectorGrammar</span><span class="special">,</span> <span class="identifier">LazyVectorGrammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">LazyVectorGrammar</span><span class="special">,</span> <span class="identifier">LazyVectorGrammar</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Expressions in the lazy vector domain must conform<br></span><span class="comment">// to the lazy vector grammar<br>// 在惰性向量领域中的表达式必须符合惰性向量语法<br></span><span class="keyword">struct</span> <span class="identifier">lazy_vector_domain</span><span class="special">;</span>

<span class="comment">// Here is an evaluation context that indexes into a lazy vector<br></span><span class="comment">// expression, and combines the result.<br>// 这是一个求值上下文，对惰性向量表达式进行索引并组合出结果。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Size</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lazy_subscript_context</span>
<span class="special">{</span>
    <span class="identifier">lazy_subscript_context</span><span class="special">(</span><span class="identifier">Size</span> <span class="identifier">subscript</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">subscript_</span><span class="special">(</span><span class="identifier">subscript</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Use default_eval for all the operations ...<br>    // 对所有操作使用default_eval ...<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Tag</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_tag</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">lazy_subscript_context</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="comment">// ... except for terminals, which we index with our subscript<br>    // ... 除了终结符，对于终结符我们用下标进行索引<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">value_type</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span> <span class="special">()(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">,</span> <span class="identifier">lazy_subscript_context</span> <span class="special">&amp;</span> <span class="identifier">ctx</span> <span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(</span> <span class="identifier">expr</span> <span class="special">)[</span> <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">subscript_</span> <span class="special">];</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="identifier">Size</span> <span class="identifier">subscript_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// Here is the domain-specific expression wrapper, which overrides<br></span><span class="comment">// operator [] to evaluate the expression using the lazy_subscript_context.<br>// 这是领域专用表达式的包装器，它重载了operator[]，使用lazy_subscript_context来对表达式求值。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lazy_vector_expr</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">lazy_vector_expr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">lazy_vector_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">lazy_vector_expr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">lazy_vector_domain</span><span class="special">&gt;</span> <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">lazy_vector_expr</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">()</span> <span class="special">)</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span> <span class="identifier">expr</span> <span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Use the lazy_subscript_context&lt;&gt; to implement subscripting<br></span>    <span class="comment">// of a lazy vector expression tree.<br>    // 使用lazy_subscript_context&lt;&gt;来实现一个惰性向量表达式树的下标操作。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Size</span> <span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">lazy_subscript_context</span><span class="special">&lt;</span><span class="identifier">Size</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span> <span class="special">[](</span> <span class="identifier">Size</span> <span class="identifier">subscript</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">lazy_subscript_context</span><span class="special">&lt;</span><span class="identifier">Size</span><span class="special">&gt;</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">subscript</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Here is our lazy_vector terminal, implemented in terms of lazy_vector_expr<br>// 这是我们的lazy_vector终结符，依照lazy_vector_expr实现<br></span><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lazy_vector</span>
  <span class="special">:</span> <span class="identifier">lazy_vector_expr</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">expr_type</span><span class="special">;</span>

    <span class="identifier">lazy_vector</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">value</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">()</span> <span class="special">)</span>
      <span class="special">:</span> <span class="identifier">lazy_vector_expr</span><span class="special">&lt;</span><span class="identifier">expr_type</span><span class="special">&gt;(</span> <span class="identifier">expr_type</span><span class="special">::</span><span class="identifier">make</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span> <span class="identifier">size</span><span class="special">,</span> <span class="identifier">value</span> <span class="special">)</span> <span class="special">)</span> <span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Here we define a += operator for lazy vector terminals that<br></span>    <span class="comment">// takes a lazy vector expression and indexes it. expr[i] here<br></span>    <span class="comment">// uses lazy_subscript_context&lt;&gt; under the covers.<br>    // 这里我们为惰性向量终结符定义一个+=操作符，接受一个惰性向量表达式并对之<br>    // 进行索引。这里的expr[i]在其内部使用了lazy_subscript_context&lt;&gt;。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
    <span class="identifier">lazy_vector</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">+=</span> <span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(*</span><span class="keyword">this</span><span class="special">).</span><span class="identifier">size</span><span class="special">();</span>
        <span class="keyword">for</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">size</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">+=</span> <span class="identifier">expr</span><span class="special">[</span><span class="identifier">i</span><span class="special">];</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Tell proto that in the lazy_vector_domain, all<br></span><span class="comment">// expressions should be wrapped in lazy_vector_expr&lt;&gt;<br>// 告知proto，在lazy_vector_domain中，所有表达式都应包入lazy_vector_expr&lt;&gt;<br></span><span class="keyword">struct</span> <span class="identifier">lazy_vector_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">lazy_vector_expr</span><span class="special">&gt;,</span> <span class="identifier">LazyVectorGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// lazy_vectors with 4 elements each. 各带4个元素的lazy_vector<br></span>    <span class="identifier">lazy_vector</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="identifier">v1</span><span class="special">(</span> <span class="number">4</span><span class="special">,</span> <span class="number">1.0</span> <span class="special">),</span> <span class="identifier">v2</span><span class="special">(</span> <span class="number">4</span><span class="special">,</span> <span class="number">2.0</span> <span class="special">),</span> <span class="identifier">v3</span><span class="special">(</span> <span class="number">4</span><span class="special">,</span> <span class="number">3.0</span> <span class="special">);</span>

    <span class="comment">// Add two vectors lazily and get the 2nd element. <br>    // 将两个向量惰性相加并取出第2个元素。<br></span>    <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="special">(</span> <span class="identifier">v2</span> <span class="special">+</span> <span class="identifier">v3</span> <span class="special">)[</span> <span class="number">2</span> <span class="special">];</span>   <span class="comment">// Look ma, no temporaries! 看，没有临时对象！<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">d1</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Subtract two vectors and add the result to a third vector.<br>    // 将两个向量相减并将结果加到第三个向量上。<br></span>    <span class="identifier">v1</span> <span class="special">+=</span> <span class="identifier">v2</span> <span class="special">-</span> <span class="identifier">v3</span><span class="special">;</span>                  <span class="comment">// Still no temporaries! 依然没有临时对象！<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'{'</span> <span class="special">&lt;&lt;</span> <span class="identifier">v1</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="identifier">v1</span><span class="special">[</span><span class="number">1</span><span class="special">]</span>
              <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="identifier">v1</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="identifier">v1</span><span class="special">[</span><span class="number">3</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'}'</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// This expression is disallowed because it does not conform<br></span>    <span class="comment">// to the LazyVectorGrammar<br>    // 这个表达式是不允许的，因为它不符合LazyVectorGrammar<br></span>    <span class="comment">//(v2 + v3) += v1;<br></span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.rgb"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.rgb" title="RGB: Type Manipulations with Proto Transforms"> RGB: Type Manipulations
        with Proto Transforms 以Proto变换进行类型操作</a>
</h4></div></div></div>


<p>
          This is a simple example of doing arbitrary type manipulations with Proto
          transforms. It takes some expression involving primary colors and combines
          the colors according to arbitrary rules. It is a port of the RGB example
          from <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a>.<br>这是一个简单的例子，以Proto变换进行任意的类型操作。它接受带有三原色的表达式，并根据任意规则组合成颜色。它是对 <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a> 中的RGB例子的一个移植。</p>
<pre class="programlisting"><span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This is a simple example of doing arbitrary type manipulations with proto<br></span><span class="comment">// transforms. It takes some expression involving primary colors and combines<br></span><span class="comment">// the colors according to arbitrary rules. It is a port of the RGB example<br></span><span class="comment">// from PETE (http://www.codesourcery.com/pooma/download.html).<br>// 这是一个简单的例子，以Proto变换进行任意的类型操作。它接受带有三原色的表达式，并根据任意规则进行<br>// 颜色组合。这是对PETE(http://www.codesourcery.com/pooma/download.html)中的RGB例子的移植。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">transform</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">RedTag</span>
<span class="special">{</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">&lt;&lt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="identifier">sout</span><span class="special">,</span> <span class="identifier">RedTag</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">sout</span> <span class="special">&lt;&lt;</span> <span class="string">"This expression is red."</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">BlueTag</span>
<span class="special">{</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">&lt;&lt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="identifier">sout</span><span class="special">,</span> <span class="identifier">BlueTag</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">sout</span> <span class="special">&lt;&lt;</span> <span class="string">"This expression is blue."</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">GreenTag</span>
<span class="special">{</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">&lt;&lt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="identifier">sout</span><span class="special">,</span> <span class="identifier">GreenTag</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">sout</span> <span class="special">&lt;&lt;</span> <span class="string">"This expression is green."</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">RedTag</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">RedT</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">BlueTag</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">BlueT</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">GreenTag</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">GreenT</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">Red</span><span class="special">;</span>
<span class="keyword">struct</span> <span class="identifier">Blue</span><span class="special">;</span>
<span class="keyword">struct</span> <span class="identifier">Green</span><span class="special">;</span>

<span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">// A transform that produces new colors according to some arbitrary rules:<br></span><span class="comment">// red &amp; green give blue, red &amp; blue give green, blue and green give red.<br>// 一个根据某些任意规则生成新颜色的变换：红和绿生成蓝，红和蓝生成绿，蓝和绿生成红。<br></span><span class="keyword">struct</span> <span class="identifier">Red</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Green</span><span class="special">,</span> <span class="identifier">Blue</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Blue</span><span class="special">,</span> <span class="identifier">Green</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Red</span><span class="special">,</span> <span class="identifier">Red</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">RedTag</span><span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Green</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Red</span><span class="special">,</span> <span class="identifier">Blue</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Blue</span><span class="special">,</span> <span class="identifier">Red</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Green</span><span class="special">,</span> <span class="identifier">Green</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">GreenTag</span><span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">Blue</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Red</span><span class="special">,</span> <span class="identifier">Green</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Green</span><span class="special">,</span> <span class="identifier">Red</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Blue</span><span class="special">,</span> <span class="identifier">Blue</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">BlueTag</span><span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">RGB</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">Red</span><span class="special">,</span> <span class="identifier">RedTag</span><span class="special">()</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">Blue</span><span class="special">,</span> <span class="identifier">BlueTag</span><span class="special">()</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">Green</span><span class="special">,</span> <span class="identifier">GreenTag</span><span class="special">()</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">printColor</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="comment">// dummy state and data parameter, not used 状态和数据参数的哑元，不使用<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">RGB</span><span class="special">()(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">i</span><span class="special">,</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">printColor</span><span class="special">(</span><span class="identifier">RedT</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">GreenT</span><span class="special">());</span>
    <span class="identifier">printColor</span><span class="special">(</span><span class="identifier">RedT</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">GreenT</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">BlueT</span><span class="special">());</span>
    <span class="identifier">printColor</span><span class="special">(</span><span class="identifier">RedT</span><span class="special">()</span> <span class="special">+</span> <span class="special">(</span><span class="identifier">GreenT</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">BlueT</span><span class="special">()));</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.tarray"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.tarray" title="TArray: A Simple Linear Algebra Library"> TArray: A
        Simple Linear Algebra Library 一个简单的线性代数库</a>
</h4></div></div></div>


<p>
          This example constructs a mini-library for linear algebra, using expression
          templates to eliminate the need for temporaries when adding arrays of numbers.
          It duplicates the TArray example from <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a>.<br>这个例子构造了一个线性代数的小型库，使用表达式模板来消除进行数值数组加法时所需的临时对象。它复制了 <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a> 中的TArray例子。</p>
<pre class="programlisting"><span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This example constructs a mini-library for linear algebra, using<br></span><span class="comment">// expression templates to eliminate the need for temporaries when<br></span><span class="comment">// adding arrays of numbers. It duplicates the TArray example from<br></span><span class="comment">// PETE (http://www.codesourcery.com/pooma/download.html)<br>// 这个例子构造了一个线性代数的小型库，使用表达式模板来消除进行数值数组加法时所需的临时对象。<br>// 它复制了PETE(http://www.codesourcery.com/pooma/download.html)中的TArray例子。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="comment">// This grammar describes which TArray expressions<br></span><span class="comment">// are allowed; namely, int and array terminals<br></span><span class="comment">// plus, minus, multiplies and divides of TArray expressions.<br>// 这个语法描述了哪些TArray表达式是允许的；即，int和数组终结符，<br>// 以及TArray表达式的加、减、乘、除。<br></span><span class="keyword">struct</span> <span class="identifier">TArrayGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">[</span><span class="number">3</span><span class="special">]</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">TArrayGrammar</span><span class="special">,</span> <span class="identifier">TArrayGrammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">TArrayGrammar</span><span class="special">,</span> <span class="identifier">TArrayGrammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span> <span class="identifier">TArrayGrammar</span><span class="special">,</span> <span class="identifier">TArrayGrammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span> <span class="identifier">TArrayGrammar</span><span class="special">,</span> <span class="identifier">TArrayGrammar</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">TArrayExpr</span><span class="special">;</span>

<span class="comment">// Tell proto that in the TArrayDomain, all<br></span><span class="comment">// expressions should be wrapped in TArrayExpr&lt;&gt; and<br></span><span class="comment">// must conform to the TArrayGrammar<br>// 告诉proto，在TArrayDomain中，所有表达式都应被包装在TArrayExap&lt;&gt;中，<br>// 且必须符合TArrayGrammar。<br></span><span class="keyword">struct</span> <span class="identifier">TArrayDomain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">TArrayExpr</span><span class="special">&gt;,</span> <span class="identifier">TArrayGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Here is an evaluation context that indexes into a TArray<br></span><span class="comment">// expression, and combines the result.<br>// 以下是一个求值上下文，对一个TArray表达式进行索引操作并组合出结果。<br></span><span class="keyword">struct</span> <span class="identifier">TArraySubscriptCtx</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">TArraySubscriptCtx</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">TArraySubscriptCtx</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span> <span class="identifier">i</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">i_</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Index array terminals with our subscript. Everything<br></span>    <span class="comment">// else will be handled by the default evaluation context.<br>    // 用我们的下标操作符对数组终结符取索引。其它所有操作以缺省的求值上下文来处理。<br></span>    <span class="keyword">int</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">(&amp;</span><span class="identifier">data</span><span class="special">)[</span><span class="number">3</span><span class="special">])</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">data</span><span class="special">[</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">i_</span><span class="special">];</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span> <span class="identifier">i_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// Here is an evaluation context that prints a TArray expression.<br>// 以下是一个求值上下文，打印一个TArray表达式。<br></span><span class="keyword">struct</span> <span class="identifier">TArrayPrintCtx</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">TArrayPrintCtx</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">TArrayPrintCtx</span><span class="special">()</span> <span class="special">{}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">(&amp;</span><span class="identifier">arr</span><span class="special">)[</span><span class="number">3</span><span class="special">])</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'{'</span> <span class="special">&lt;&lt;</span> <span class="identifier">arr</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">arr</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">arr</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'}'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span><span class="special">,</span> <span class="identifier">L</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">l</span><span class="special">,</span> <span class="identifier">R</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">r</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'('</span> <span class="special">&lt;&lt;</span> <span class="identifier">l</span> <span class="special">&lt;&lt;</span> <span class="string">" + "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="char">')'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">minus</span><span class="special">,</span> <span class="identifier">L</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">l</span><span class="special">,</span> <span class="identifier">R</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">r</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'('</span> <span class="special">&lt;&lt;</span> <span class="identifier">l</span> <span class="special">&lt;&lt;</span> <span class="string">" - "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="char">')'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">,</span> <span class="identifier">L</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">l</span><span class="special">,</span> <span class="identifier">R</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">r</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">l</span> <span class="special">&lt;&lt;</span> <span class="string">" * "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">divides</span><span class="special">,</span> <span class="identifier">L</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">l</span><span class="special">,</span> <span class="identifier">R</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">r</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">l</span> <span class="special">&lt;&lt;</span> <span class="string">" / "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Here is the domain-specific expression wrapper, which overrides<br></span><span class="comment">// operator [] to evaluate the expression using the TArraySubscriptCtx.<br>// 以下是领域专用表达式的包装器，它重载了operator[]，以TArraySubscriptCtx来对表达式求值。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">TArrayExpr</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">TArrayExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">TArrayDomain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">TArrayExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">TArrayDomain</span><span class="special">&gt;</span> <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">TArrayExpr</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">()</span> <span class="special">)</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span> <span class="identifier">expr</span> <span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Use the TArraySubscriptCtx to implement subscripting<br></span>    <span class="comment">// of a TArray expression tree.<br>    // 使用TArraySubscriptCtx来实现一棵TArray表达式树的下标操作。<br></span>    <span class="keyword">int</span> <span class="keyword">operator</span> <span class="special">[](</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span> <span class="identifier">i</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">TArraySubscriptCtx</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Use the TArrayPrintCtx to display a TArray expression tree.<br>    // 使用TArrayPrintCtx来打印一棵TArray表达式树。<br></span>    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">&lt;&lt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span><span class="identifier">sout</span><span class="special">,</span> <span class="identifier">TArrayExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">TArrayPrintCtx</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Here is our TArray terminal, implemented in terms of TArrayExpr<br></span><span class="comment">// It is basically just an array of 3 integers.<br>// 这是我们的TArray终结符，依照TArrayExpr来实现。它只是一个三个整数的数组。<br></span><span class="keyword">struct</span> <span class="identifier">TArray</span>
  <span class="special">:</span> <span class="identifier">TArrayExpr</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">[</span><span class="number">3</span><span class="special">]</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">explicit</span> <span class="identifier">TArray</span><span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">j</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">k</span> <span class="special">=</span> <span class="number">0</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">i</span><span class="special">;</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">j</span><span class="special">;</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">k</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Here we override operator [] to give read/write access to<br></span>    <span class="comment">// the elements of the array. (We could use the TArrayExpr<br></span>    <span class="comment">// operator [] if we made the subscript context smarter about<br></span>    <span class="comment">// returning non-const reference when appropriate.)<br>    // 这里我们重载了operator[]，提供对数组元素的读写访问。(如果我们让下标操作上下文<br>    // 更聪明些，在适当的时候返回非常量引用的话，就可以使用TArrayExpr的operator[])<br></span>    <span class="keyword">int</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">[](</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span> <span class="identifier">i</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
    <span class="special">}</span>

    <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">[](</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span> <span class="identifier">i</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
    <span class="special">}</span>

    <span class="comment">// Here we define a operator = for TArray terminals that<br></span>    <span class="comment">// takes a TArray expression.<br>    // 这里我们为TArray终结符定义一个operator=，接受一个TArray表达式。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
    <span class="identifier">TArray</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">=(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// proto::as_expr&lt;TArrayDomain&gt;(expr) is the same as<br></span>        <span class="comment">// expr unless expr is an integer, in which case it<br></span>        <span class="comment">// is made into a TArrayExpr terminal first.<br>        // proto::as_expr&lt;TArrayDomain&gt;(expr)和expr是一样的，除非<br>        // expr是一个整数，这种情况下它首先被制成一个TArrayExpr终结符。<br></span>        <span class="keyword">return</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">TArrayDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">));</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
    <span class="identifier">TArray</span> <span class="special">&amp;</span><span class="identifier">printAssign</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="special">*</span><span class="keyword">this</span> <span class="special">=</span> <span class="identifier">expr</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="keyword">this</span> <span class="special">&lt;&lt;</span> <span class="string">" = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">expr</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
    <span class="identifier">TArray</span> <span class="special">&amp;</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// expr[i] here uses TArraySubscriptCtx under the covers.<br>        // 这里的expr[i]在底层使用了TArraySubscriptCtx。<br></span>        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">expr</span><span class="special">[</span><span class="number">0</span><span class="special">];</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">expr</span><span class="special">[</span><span class="number">1</span><span class="special">];</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">expr</span><span class="special">[</span><span class="number">2</span><span class="special">];</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">TArray</span> <span class="identifier">a</span><span class="special">(</span><span class="number">3</span><span class="special">,</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">);</span>

    <span class="identifier">TArray</span> <span class="identifier">b</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">a</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">b</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="identifier">b</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="number">7</span><span class="special">;</span> <span class="identifier">b</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="number">33</span><span class="special">;</span> <span class="identifier">b</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="special">-</span><span class="number">99</span><span class="special">;</span>

    <span class="identifier">TArray</span> <span class="identifier">c</span><span class="special">(</span><span class="identifier">a</span><span class="special">);</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">c</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="identifier">a</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">a</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">b</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">c</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="identifier">a</span> <span class="special">=</span> <span class="identifier">b</span> <span class="special">+</span> <span class="identifier">c</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">a</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="identifier">a</span><span class="special">.</span><span class="identifier">printAssign</span><span class="special">(</span><span class="identifier">b</span><span class="special">+</span><span class="identifier">c</span><span class="special">*(</span><span class="identifier">b</span> <span class="special">+</span> <span class="number">3</span><span class="special">*</span><span class="identifier">c</span><span class="special">));</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.vec3"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.vec3" title="Vec3: Computing With Transforms and Contexts"> Vec3: Computing
        With Transforms and Contexts 用变换和上下文进行计算</a>
</h4></div></div></div>


<p>
          This is a simple example using <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code> to extend a terminal type with
          additional behaviors, and using custom contexts and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code> for evaluating expressions. It is a port
          of the Vec3 example from <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a>.<br>这是一个简单的例子，使用 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code> 来扩展一个终结符类型以增加行为，并使用定制的上下文和 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code> 来对表达式求值。它是修改自 <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a> 中的Vec3例子。</p>
<pre class="programlisting"><span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This is a simple example using proto::extends to extend a terminal type with<br></span><span class="comment">// additional behaviors, and using custom contexts and proto::eval for<br></span><span class="comment">// evaluating expressions. It is a port of the Vec3 example<br></span><span class="comment">// from PETE (http://www.codesourcery.com/pooma/download.html).<br>// 这是一个简单的例子，使用proto::extends来扩展一个终结符类型，增加其行为，并使用定制的上下文和proto::eval<br>// 来对表达式求值。它是修改自PETE(http://www.codesourcery.com/pooma/download.html)的Vec3例子。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto_typeof</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">transform</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="comment">// Here is an evaluation context that indexes into a Vec3<br></span><span class="comment">// expression, and combines the result.<br>// 以下是一个求值上下文，对Vec3表达式进行索引操作，并组合成结果。<br></span><span class="keyword">struct</span> <span class="identifier">Vec3SubscriptCtx</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">Vec3SubscriptCtx</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">Vec3SubscriptCtx</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">i_</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Index array terminals with our subscript. Everything<br></span>    <span class="comment">// else will be handled by the default evaluation context.<br>    // 用我们的下标操作对数组终结符求索引。其它所有操作用缺省求值上下文来处理。<br></span>    <span class="keyword">int</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">(&amp;</span><span class="identifier">arr</span><span class="special">)[</span><span class="number">3</span><span class="special">])</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">[</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">i_</span><span class="special">];</span>
    <span class="special">}</span>

    <span class="keyword">int</span> <span class="identifier">i_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// Here is an evaluation context that counts the number<br></span><span class="comment">// of Vec3 terminals in an expression.<br>// 以下是一个求值上下文，计算一个表达式中的Vec3终结符数量。<br></span><span class="keyword">struct</span> <span class="identifier">CountLeavesCtx</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">CountLeavesCtx</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">null_context</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">CountLeavesCtx</span><span class="special">()</span>
      <span class="special">:</span> <span class="identifier">count</span><span class="special">(</span><span class="number">0</span><span class="special">)</span>
      <span class="special">{}</span>

      <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">result_type</span><span class="special">;</span>

      <span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="keyword">int</span> <span class="keyword">const</span><span class="special">(&amp;)[</span><span class="number">3</span><span class="special">])</span>
      <span class="special">{</span>
          <span class="special">++</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">count</span><span class="special">;</span>
      <span class="special">}</span>

      <span class="keyword">int</span> <span class="identifier">count</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">iplus</span> <span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span> <span class="special">{};</span>

<span class="comment">// Here is a transform that does the same thing as the above context.<br></span><span class="comment">// It demonstrates the use of the std::plus&lt;&gt; function object<br></span><span class="comment">// with the fold transform. With minor modifications, this<br></span><span class="comment">// transform could be used to calculate the leaf count at compile<br></span><span class="comment">// time, rather than at runtime.<br>// 以下是一个变换，完成与前述上下文相同的工作。它示范了把std::plus&lt;&gt;函数对象用于fold变换。<br>// 通过少许修改，这个变换可以用于在编译期计算叶子数量，而不是在运行期。<br></span><span class="keyword">struct</span> <span class="identifier">CountLeaves</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="comment">// match a Vec3 terminal, return 1 匹配一个Vec3终结符，返回1<br></span>        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">[</span><span class="number">3</span><span class="special">]&gt;,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;()</span> <span class="special">&gt;</span>
        <span class="comment">// match a terminal, return int() (which is 0) 匹配一个终结符，返回int()(为0)<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span> <span class="keyword">int</span><span class="special">()</span> <span class="special">&gt;</span>
        <span class="comment">// fold everything else, using std::plus&lt;&gt; to add<br></span>        <span class="comment">// the leaf count of each child to the accumulated state.<br>        // 折叠其它所有东西，使用std::plus&lt;&gt;将所有子节点的叶子数量累加到累计状态中。<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">otherwise</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="keyword">int</span><span class="special">(),</span> <span class="identifier">iplus</span><span class="special">(</span><span class="identifier">CountLeaves</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">)</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Here is the Vec3 struct, which is a vector of 3 integers.<br>// 以下是Vec3的结构，它是一个带3个整数的向量。<br></span><span class="keyword">struct</span> <span class="identifier">Vec3</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">[</span><span class="number">3</span><span class="special">]&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Vec3</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">explicit</span> <span class="identifier">Vec3</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">j</span><span class="special">=</span><span class="number">0</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">k</span><span class="special">=</span><span class="number">0</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">i</span><span class="special">;</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">j</span><span class="special">;</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">k</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">int</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">[](</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
    <span class="special">}</span>

    <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">[](</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
    <span class="special">}</span>

    <span class="comment">// Here we define a operator = for Vec3 terminals that<br></span>    <span class="comment">// takes a Vec3 expression.<br>    // 这里我们为Vec3终结符定义一个operator=，接受一个Vec3表达式。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
    <span class="identifier">Vec3</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">=(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">Vec3SubscriptCtx</span> <span class="keyword">const</span> <span class="identifier">CVec3SubscriptCtx</span><span class="special">;</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">CVec3SubscriptCtx</span><span class="special">(</span><span class="number">0</span><span class="special">));</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">CVec3SubscriptCtx</span><span class="special">(</span><span class="number">1</span><span class="special">));</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">CVec3SubscriptCtx</span><span class="special">(</span><span class="number">2</span><span class="special">));</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">print</span><span class="special">()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'{'</span> <span class="special">&lt;&lt;</span> <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">0</span><span class="special">]</span>
                  <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">1</span><span class="special">]</span>
                  <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="special">(*</span><span class="keyword">this</span><span class="special">)[</span><span class="number">2</span><span class="special">]</span>
                  <span class="special">&lt;&lt;</span> <span class="char">'}'</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// The count_leaves() function uses the CountLeaves transform and<br></span><span class="comment">// to count the number of leaves in an expression.<br>// 函数count_leaves()使用CountLeaves变换来计算一个表达式中的叶子数量。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">count_leaves</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Count the number of Vec3 terminals using the<br></span>    <span class="comment">// CountLeavesCtx evaluation context.<br>    // 使用CountLeavesCtx求值上下文计算Vec3终结符的数量。<br></span>    <span class="identifier">CountLeavesCtx</span> <span class="identifier">ctx</span><span class="special">;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>

    <span class="comment">// This is another way to count the leaves using a transform.<br>    // 这是使用变换来计算叶子数量的另一个方法。<br></span>    <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">CountLeaves</span><span class="special">()(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">i</span><span class="special">,</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">count</span> <span class="special">);</span>

    <span class="keyword">return</span> <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">count</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">Vec3</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">,</span> <span class="identifier">c</span><span class="special">;</span>

    <span class="identifier">c</span> <span class="special">=</span> <span class="number">4</span><span class="special">;</span>

    <span class="identifier">b</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="special">-</span><span class="number">1</span><span class="special">;</span>
    <span class="identifier">b</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="special">-</span><span class="number">2</span><span class="special">;</span>
    <span class="identifier">b</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="special">-</span><span class="number">3</span><span class="special">;</span>

    <span class="identifier">a</span> <span class="special">=</span> <span class="identifier">b</span> <span class="special">+</span> <span class="identifier">c</span><span class="special">;</span>

    <span class="identifier">a</span><span class="special">.</span><span class="identifier">print</span><span class="special">();</span>

    <span class="identifier">Vec3</span> <span class="identifier">d</span><span class="special">;</span>
    <span class="identifier">BOOST_PROTO_AUTO</span><span class="special">(</span><span class="identifier">expr1</span><span class="special">,</span> <span class="identifier">b</span> <span class="special">+</span> <span class="identifier">c</span><span class="special">);</span>
    <span class="identifier">d</span> <span class="special">=</span> <span class="identifier">expr1</span><span class="special">;</span>
    <span class="identifier">d</span><span class="special">.</span><span class="identifier">print</span><span class="special">();</span>

    <span class="keyword">int</span> <span class="identifier">num</span> <span class="special">=</span> <span class="identifier">count_leaves</span><span class="special">(</span><span class="identifier">expr1</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">num</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="identifier">BOOST_PROTO_AUTO</span><span class="special">(</span><span class="identifier">expr2</span><span class="special">,</span> <span class="identifier">b</span> <span class="special">+</span> <span class="number">3</span> <span class="special">*</span> <span class="identifier">c</span><span class="special">);</span>
    <span class="identifier">num</span> <span class="special">=</span> <span class="identifier">count_leaves</span><span class="special">(</span><span class="identifier">expr2</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">num</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="identifier">BOOST_PROTO_AUTO</span><span class="special">(</span><span class="identifier">expr3</span><span class="special">,</span> <span class="identifier">b</span> <span class="special">+</span> <span class="identifier">c</span> <span class="special">*</span> <span class="identifier">d</span><span class="special">);</span>
    <span class="identifier">num</span> <span class="special">=</span> <span class="identifier">count_leaves</span><span class="special">(</span><span class="identifier">expr3</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">num</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.vector"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.vector" title="Vector: Adapting a Non-Proto Terminal Type"> Vector: Adapting
        a Non-Proto Terminal Type 适配一个非Proto的终结符类型</a>
</h4></div></div></div>


<p>
          This is an example of using <code class="computeroutput"><span class="identifier">BOOST_PROTO_DEFINE_OPERATORS</span><span class="special">()</span></code> to Protofy expressions using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code>,
          a non-Proto type. It is a port of the Vector example from <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a>.<br>这个例子使用 <code class="computeroutput"><span class="identifier">BOOST_PROTO_DEFINE_OPERATORS</span><span class="special">()</span></code> 来Proto化使用了一个非Proto类型 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code> 的表达式。它修改自 <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a> 的Vector例子。</p>
<pre class="programlisting"><span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This is an example of using BOOST_PROTO_DEFINE_OPERATORS to Protofy<br></span><span class="comment">// expressions using std::vector&lt;&gt;, a non-proto type. It is a port of the<br></span><span class="comment">// Vector example from PETE (http://www.codesourcery.com/pooma/download.html).<br>// 这个例子使用BOOST_PROTO_DEFINE_OPERATORS()来Proto化使用了一个非Proto类型std::vector&lt;&gt;<br>// 的表达式。它修改自PETE(http://www.codesourcery.com/pooma/download.html)的Vector例子。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">stdexcept</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">bool</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">debug</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">enable_if</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">VectorExpr</span><span class="special">;</span>

<span class="comment">// Here is an evaluation context that indexes into a std::vector<br></span><span class="comment">// expression and combines the result.<br>// 以下是一个求值上下文，对一个std::vector表达式求索引并组合出结果。<br></span><span class="keyword">struct</span> <span class="identifier">VectorSubscriptCtx</span>
<span class="special">{</span>
    <span class="identifier">VectorSubscriptCtx</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">i_</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Unless this is a vector terminal, use the<br></span>    <span class="comment">// default evaluation context<br>    // 除非是vector终结符，否则使用缺省求值上下文<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">EnableIf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">VectorSubscriptCtx</span> <span class="keyword">const</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="comment">// Index vector terminals with our subscript. <br>    // 用我们的下标操作对vector终结符求索引。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span>
        <span class="identifier">Expr</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">value_type</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">VectorSubscriptCtx</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)[</span><span class="identifier">ctx</span><span class="special">.</span><span class="identifier">i_</span><span class="special">];</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// Here is an evaluation context that verifies that all the<br></span><span class="comment">// vectors in an expression have the same size.<br>// 以下是一个求值上下文，验证表达式中的所有向量具有相同的大小。<br></span><span class="keyword">struct</span> <span class="identifier">VectorSizeCtx</span>
<span class="special">{</span>
    <span class="identifier">VectorSizeCtx</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">size_</span><span class="special">(</span><span class="identifier">size</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Unless this is a vector terminal, use the<br></span>    <span class="comment">// null evaluation context<br>    // 除非是vector终结符，否则使用空求值上下文<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">EnableIf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">null_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">VectorSizeCtx</span> <span class="keyword">const</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="comment">// Index array terminals with our subscript. Everything<br></span>    <span class="comment">// else will be handled by the default evaluation context.<br>    // 用我们的下标操作对数组终结符求索引。其它所有东西由缺省求值上下文处理。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span>
        <span class="identifier">Expr</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">VectorSizeCtx</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">if</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">.</span><span class="identifier">size_</span> <span class="special">!=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(</span><span class="identifier">expr</span><span class="special">).</span><span class="identifier">size</span><span class="special">())</span>
            <span class="special">{</span>
                <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"LHS and RHS are not compatible"</span><span class="special">);</span>
            <span class="special">}</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// A grammar which matches all the assignment operators,<br></span><span class="comment">// so we can easily disable them.<br>// 匹配所有赋值操作符的语法，我们可以很容易地禁用它们。<br></span><span class="keyword">struct</span> <span class="identifier">AssignOps</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">switch_</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">AssignOpsCases</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Here are the cases used by the switch_ above.<br>// 以下是上述switch_要使用的情形。<br></span><span class="keyword">struct</span> <span class="identifier">AssignOpsCases</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">D</span> <span class="special">=</span> <span class="number">0</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span>  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>         <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">minus_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>        <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">multiplies_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>   <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">divides_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>      <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">modulus_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>      <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_left_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>   <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_right_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>  <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_and_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>  <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_or_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>   <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_xor_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>  <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
<span class="special">};</span>

<span class="comment">// A vector grammar is a terminal or some op that is not an<br></span><span class="comment">// assignment op. (Assignment will be handled specially.)<br>// 一个vector语法是一个终结符，或某个不是赋值操作的操作。(赋值操作要特殊处理)<br></span><span class="keyword">struct</span> <span class="identifier">VectorGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">and_</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">VectorGrammar</span><span class="special">&gt;</span> <span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">AssignOps</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Expressions in the vector domain will be wrapped in VectorExpr&lt;&gt;<br></span><span class="comment">// and must conform to the VectorGrammar<br>// vector领域中的表达式要包装在VectorExpr&lt;&gt;中，并且必须符合VectorGrammar<br></span><span class="keyword">struct</span> <span class="identifier">VectorDomain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">VectorExpr</span><span class="special">&gt;,</span> <span class="identifier">VectorGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Here is VectorExpr, which extends a proto expr type by<br></span><span class="comment">// giving it an operator [] which uses the VectorSubscriptCtx<br></span><span class="comment">// to evaluate an expression with a given index.<br>// 以下是VectorExpr，它扩展了一个proto expr类型，增加了一个operator[]，<br>// 使用VectorSubscriptCtx以给定的索引值对一个表达式求值。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">VectorExpr</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">VectorExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">VectorDomain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">explicit</span> <span class="identifier">VectorExpr</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">VectorExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">VectorDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// Use the VectorSubscriptCtx to implement subscripting<br></span>    <span class="comment">// of a Vector expression tree.<br>    // 使用VectorSubscriptCtx来实现Vector表达式树的下标操作。<br></span>    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">Expr</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">VectorSubscriptCtx</span> <span class="keyword">const</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span> <span class="special">[](</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">VectorSubscriptCtx</span> <span class="keyword">const</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Define a trait type for detecting vector terminals, to<br></span><span class="comment">// be used by the BOOST_PROTO_DEFINE_OPERATORS macro below.<br>// 定义一个trait类型，检测vector终结符，用于后面的BOOST_PROTO_DEFINE_OPERATORS宏。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">IsVector</span>
  <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">IsVector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span>
<span class="special">{};</span>

<span class="keyword">namespace</span> <span class="identifier">VectorOps</span>
<span class="special">{</span>
    <span class="comment">// This defines all the overloads to make expressions involving<br></span>    <span class="comment">// std::vector to build expression templates.<br>    // 这里定义从一个含有std::vector的表达式构建出表达式模板所需的所有重载。<br></span>    <span class="identifier">BOOST_PROTO_DEFINE_OPERATORS</span><span class="special">(</span><span class="identifier">IsVector</span><span class="special">,</span> <span class="identifier">VectorDomain</span><span class="special">)</span>

    <span class="keyword">typedef</span> <span class="identifier">VectorSubscriptCtx</span> <span class="keyword">const</span> <span class="identifier">CVectorSubscriptCtx</span><span class="special">;</span>

    <span class="comment">// Assign to a vector from some expression.<br>    // 从某个表达式赋值到一个vector中。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">VectorSizeCtx</span> <span class="keyword">const</span> <span class="identifier">size</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">size</span><span class="special">());</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">VectorDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">size</span><span class="special">);</span> <span class="comment">// will throw if the sizes don't match 如果大小不匹配则抛出<br></span>        <span class="keyword">for</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">arr</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">VectorDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Add-assign to a vector from some expression.<br>    // 从某个表达式加赋值至一个vector。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">+=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">VectorSizeCtx</span> <span class="keyword">const</span> <span class="identifier">size</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">size</span><span class="special">());</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">VectorDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">size</span><span class="special">);</span> <span class="comment">// will throw if the sizes don't match 如果大小不匹配则抛出<br></span>        <span class="keyword">for</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">arr</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">+=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">VectorDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">VectorOps</span><span class="special">;</span>

    <span class="keyword">int</span> <span class="identifier">i</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">a</span><span class="special">,</span><span class="identifier">b</span><span class="special">,</span><span class="identifier">c</span><span class="special">,</span><span class="identifier">d</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">e</span><span class="special">(</span><span class="identifier">n</span><span class="special">);</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">a</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
        <span class="identifier">b</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">i</span><span class="special">);</span>
        <span class="identifier">c</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">3</span><span class="special">*</span><span class="identifier">i</span><span class="special">);</span>
        <span class="identifier">d</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">VectorOps</span><span class="special">::</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">b</span><span class="special">,</span> <span class="number">2</span><span class="special">);</span>
    <span class="identifier">VectorOps</span><span class="special">::</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">d</span><span class="special">,</span> <span class="identifier">a</span> <span class="special">+</span> <span class="identifier">b</span> <span class="special">*</span> <span class="identifier">c</span><span class="special">);</span>
    <span class="identifier">a</span> <span class="special">+=</span> <span class="identifier">if_else</span><span class="special">(</span><span class="identifier">d</span> <span class="special">&lt;</span> <span class="number">30</span><span class="special">,</span> <span class="identifier">b</span><span class="special">,</span> <span class="identifier">c</span><span class="special">);</span>

    <span class="identifier">VectorOps</span><span class="special">::</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">e</span><span class="special">,</span> <span class="identifier">c</span><span class="special">);</span>
    <span class="identifier">e</span> <span class="special">+=</span> <span class="identifier">e</span> <span class="special">-</span> <span class="number">4</span> <span class="special">/</span> <span class="special">(</span><span class="identifier">c</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>

    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span>
            <span class="special">&lt;&lt;</span> <span class="string">" a("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">a</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" b("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">b</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" c("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">c</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" d("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">d</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" e("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.mixed"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.mixed" title="Mixed: Adapting Several Non-Proto Terminal Types"> Mixed: Adapting
        Several Non-Proto Terminal Types 适配多个非Proto的终结符类型</a>
</h4></div></div></div>


<p>
          This is an example of using <code class="computeroutput"><span class="identifier">BOOST_PROTO_DEFINE_OPERATORS</span><span class="special">()</span></code> to Protofy expressions using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code>
          and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;&gt;</span></code>,
          non-Proto types. It is a port of the Mixed example from <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a>.<br>这是一个使用 <code class="computeroutput"><span class="identifier">BOOST_PROTO_DEFINE_OPERATORS</span><span class="special">()</span></code> 来对使用了 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code> 和 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;&gt;</span></code> 这些非Proto类型的表达式进行Proto化的例子。它修改自 <a href="http://www.codesourcery.com/pooma/download.html" target="_top">PETE</a> 的Mixed例子。</p>
<pre class="programlisting"><span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This is an example of using BOOST_PROTO_DEFINE_OPERATORS to Protofy<br></span><span class="comment">// expressions using std::vector&lt;&gt; and std::list, non-proto types. It is a port<br></span><span class="comment">// of the Mixed example from PETE.<br></span><span class="comment">// 这是一个使用BOOST_PROTO_DEFINE_OPERATORS来对使用了std::vector&lt;&gt;和std::list这些<br>// </span><span class="comment">非Proto</span><span class="comment">类型的表达式进行Proto化的例子。它修改自PETE的Mixed例子。<br></span><span class="preprocessor"></span><span class="comment">// (http://www.codesourcery.com/pooma/download.html).<br><br></span><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">list</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cmath</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">complex</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">stdexcept</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">debug</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">transform</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">enable_if</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">list</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">vector</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">complex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_traits</span><span class="special">/</span><span class="identifier">remove_reference</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">MixedExpr</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iter</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">iterator_wrapper</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">Iter</span> <span class="identifier">iterator</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">iterator_wrapper</span><span class="special">(</span><span class="identifier">Iter</span> <span class="identifier">iter</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">iter</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">Iter</span> <span class="identifier">it</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">begin</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Sig</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">This</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Cont</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">This</span><span class="special">(</span><span class="identifier">Cont</span><span class="special">)&gt;</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span>
            <span class="identifier">iterator_wrapper</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Cont</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">const_iterator</span><span class="special">&gt;</span>
        <span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Cont</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">begin</span><span class="special">(</span><span class="identifier">Cont</span> <span class="keyword">const</span> <span class="special">&amp;)&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Cont</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">cont</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">iterator_wrapper</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Cont</span><span class="special">::</span><span class="identifier">const_iterator</span><span class="special">&gt;</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">cont</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">(</span><span class="identifier">it</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Here is a grammar that replaces vector and list terminals with their<br></span><span class="comment">// begin iterators<br>// 这是将vector和list替换为它们的begin迭代器的语法<br></span><span class="keyword">struct</span> <span class="identifier">Begin</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;,</span> <span class="identifier">begin</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;,</span> <span class="identifier">begin</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">Begin</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Here is an evaluation context that dereferences iterator<br></span><span class="comment">// terminals.<br>// 这是对迭代器终结符解引用的求值上下文。<br></span><span class="keyword">struct</span> <span class="identifier">DereferenceCtx</span>
<span class="special">{</span>
    <span class="comment">// Unless this is an iterator terminal, use the<br></span>    <span class="comment">// default evaluation context<br>    // 除非是一个迭代器终结符，否则使用缺省的求值上下文<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">EnableIf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">DereferenceCtx</span> <span class="keyword">const</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="comment">// Dereference iterator terminals. 对迭代器终结符解引用。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span>
        <span class="identifier">Expr</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">iterator_wrapper</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">IteratorWrapper</span><span class="special">;</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">IteratorWrapper</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">iterator</span><span class="special">;</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator_traits</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">&gt;::</span><span class="identifier">reference</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">DereferenceCtx</span> <span class="keyword">const</span> <span class="special">&amp;)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="special">*</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(</span><span class="identifier">expr</span><span class="special">).</span><span class="identifier">it</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">};</span>

<span class="comment">// Here is an evaluation context that increments iterator<br></span><span class="comment">// terminals.<br>// 这是递增迭代器终结符的求值上下文。<br></span><span class="keyword">struct</span> <span class="identifier">IncrementCtx</span>
<span class="special">{</span>
    <span class="comment">// Unless this is an iterator terminal, use the<br></span>    <span class="comment">// default evaluation context<br>    // 除非是迭代器终结符，否则使用缺省的求值上下文<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">EnableIf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">null_eval</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">IncrementCtx</span> <span class="keyword">const</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="comment">// advance iterator terminals. 步增迭代器终结符。<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">eval</span><span class="special">&lt;</span>
        <span class="identifier">Expr</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">enable_if</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">iterator_wrapper</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Expr</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">IncrementCtx</span> <span class="keyword">const</span> <span class="special">&amp;)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="special">++</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(</span><span class="identifier">expr</span><span class="special">).</span><span class="identifier">it</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">};</span>

<span class="comment">// A grammar which matches all the assignment operators,<br></span><span class="comment">// so we can easily disable them.<br>// 匹配所有赋值操作符的语法，这样我们就可以很方便地禁用它们。<br></span><span class="keyword">struct</span> <span class="identifier">AssignOps</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">switch_</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">AssignOpsCases</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Here are the cases used by the switch_ above.<br>// 这是上述switch_所使用的各种情况。<br></span><span class="keyword">struct</span> <span class="identifier">AssignOpsCases</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">D</span> <span class="special">=</span> <span class="number">0</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span>  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>         <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">minus_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>        <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">multiplies_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>   <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">divides_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>      <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">modulus_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>      <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_left_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>   <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">shift_right_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>  <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_and_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>  <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_or_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>   <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">D</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">case_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">bitwise_xor_assign</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">&gt;</span>  <span class="special">:</span> <span class="identifier">_</span> <span class="special">{};</span>
<span class="special">};</span>

<span class="comment">// A vector grammar is a terminal or some op that is not an<br></span><span class="comment">// assignment op. (Assignment will be handled specially.)<br>// vector语法，为一个终结符，或为赋值操作以外的某个操作。(赋值操作要特殊处理)<br></span><span class="keyword">struct</span> <span class="identifier">MixedGrammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">and_</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">MixedGrammar</span><span class="special">&gt;</span> <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span><span class="identifier">AssignOps</span><span class="special">&gt;</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Expressions in the vector domain will be wrapped in VectorExpr&lt;&gt;<br></span><span class="comment">// and must conform to the VectorGrammar<br>// 笔误，应改为：MixedDomain中的表达式要包装在MixedExpr&lt;&gt;中，且必须符合MixedGrammar<br></span><span class="keyword">struct</span> <span class="identifier">MixedDomain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">MixedExpr</span><span class="special">&gt;,</span> <span class="identifier">MixedGrammar</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Here is MixedExpr, a wrapper for expression types in the MixedDomain.<br>// 这是MixedExpr，MixeDomain中的表达式类型的包装器<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">MixedExpr</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">MixedExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">MixedDomain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">explicit</span> <span class="identifier">MixedExpr</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">MixedExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="comment">// hide this:<br></span>    <span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">MixedExpr</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">MixedDomain</span><span class="special">&gt;::</span><span class="keyword">operator</span> <span class="special">[];</span>
<span class="special">};</span>

<span class="comment">// Define a trait type for detecting vector and list terminals, to<br></span><span class="comment">// be used by the BOOST_PROTO_DEFINE_OPERATORS macro below.<br>// 定义一个trait类型，用于检测vector和list终结符，用于后述的BOOST_PROTO_DEFINE_OPERATORS宏。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">IsMixed</span>
  <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">IsMixed</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">IsMixed</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&gt;</span>
  <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span>
<span class="special">{};</span>

<span class="keyword">namespace</span> <span class="identifier">MixedOps</span>
<span class="special">{</span>
    <span class="comment">// This defines all the overloads to make expressions involving<br></span>    <span class="comment">// std::vector to build expression templates.<br>    // 这里定义了把含有std::vector的表达式构造成表达式模板的所有重载。<br></span>    <span class="identifier">BOOST_PROTO_DEFINE_OPERATORS</span><span class="special">(</span><span class="identifier">IsMixed</span><span class="special">,</span> <span class="identifier">MixedDomain</span><span class="special">)</span>

    <span class="keyword">struct</span> <span class="identifier">assign_op</span>
    <span class="special">{</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">T</span> <span class="special">&amp;</span><span class="identifier">t</span><span class="special">,</span> <span class="identifier">U</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">u</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="identifier">t</span> <span class="special">=</span> <span class="identifier">u</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="keyword">struct</span> <span class="identifier">plus_assign_op</span>
    <span class="special">{</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">T</span> <span class="special">&amp;</span><span class="identifier">t</span><span class="special">,</span> <span class="identifier">U</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">u</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="identifier">t</span> <span class="special">+=</span> <span class="identifier">u</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="keyword">struct</span> <span class="identifier">minus_assign_op</span>
    <span class="special">{</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">T</span> <span class="special">&amp;</span><span class="identifier">t</span><span class="special">,</span> <span class="identifier">U</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">u</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="identifier">t</span> <span class="special">-=</span> <span class="identifier">u</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="keyword">struct</span> <span class="identifier">sin_</span>
    <span class="special">{</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sig</span><span class="special">&gt;</span>
        <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">This</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
        <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">This</span><span class="special">(</span><span class="identifier">Arg</span><span class="special">)&gt;</span>
          <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">remove_const</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Arg</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
        <span class="special">{};</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
        <span class="identifier">Arg</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">(</span><span class="identifier">a</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span>
      <span class="special">,</span> <span class="identifier">MixedDomain</span>
      <span class="special">,</span> <span class="identifier">sin_</span> <span class="keyword">const</span>
      <span class="special">,</span> <span class="identifier">A</span> <span class="keyword">const</span> <span class="special">&amp;</span>
    <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">sin</span><span class="special">(</span><span class="identifier">A</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span><span class="special">,</span> <span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">sin_</span><span class="special">(),</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">a</span><span class="special">));</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">FwdIter</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Op</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">FwdIter</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">FwdIter</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">Op</span> <span class="identifier">op</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">IncrementCtx</span> <span class="keyword">const</span> <span class="identifier">inc</span> <span class="special">=</span> <span class="special">{};</span>
        <span class="identifier">DereferenceCtx</span> <span class="keyword">const</span> <span class="identifier">deref</span> <span class="special">=</span> <span class="special">{};</span>
        <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">Begin</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;)&gt;::</span><span class="identifier">type</span> <span class="identifier">expr2</span> <span class="special">=</span> <span class="identifier">Begin</span><span class="special">()(</span><span class="identifier">expr</span><span class="special">);</span>
        <span class="keyword">for</span><span class="special">(;</span> <span class="identifier">begin</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">begin</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">op</span><span class="special">(*</span><span class="identifier">begin</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr2</span><span class="special">,</span> <span class="identifier">deref</span><span class="special">));</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr2</span><span class="special">,</span> <span class="identifier">inc</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">}</span>

    <span class="comment">// Add-assign to a vector from some expression.<br>    // 从表达式到vector的赋值<br></span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">assign_op</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Add-assign to a list from some expression.<br></span><span class="comment">    // 从表达式到list的赋值</span><br>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">assign_op</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Add-assign to a vector from some expression.<br></span><span class="comment">    // 从表达式到vector的加赋值</span><br>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">+=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">plus_assign_op</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Add-assign to a list from some expression.<br></span><span class="comment">    // 从表达式到list的加赋值</span><br>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">+=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">plus_assign_op</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Minus-assign to a vector from some expression.<br></span><span class="comment">    // 从表达式到vector的减赋值</span><br>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">-=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">minus_assign_op</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Minus-assign to a list from some expression.<br></span><span class="comment">    // 从表达式到list的减赋值</span><br>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="keyword">operator</span> <span class="special">-=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">&amp;</span><span class="identifier">arr</span><span class="special">,</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">arr</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">arr</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span><span class="identifier">MixedDomain</span><span class="special">&gt;(</span><span class="identifier">expr</span><span class="special">),</span> <span class="identifier">minus_assign_op</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">arr</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">MixedOps</span><span class="special">;</span>

    <span class="keyword">int</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">a</span><span class="special">,</span><span class="identifier">b</span><span class="special">,</span><span class="identifier">c</span><span class="special">,</span><span class="identifier">d</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">e</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">f</span><span class="special">;</span>

    <span class="keyword">int</span> <span class="identifier">i</span><span class="special">;</span>
    <span class="keyword">for</span><span class="special">(</span><span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span><span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">a</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
        <span class="identifier">b</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">i</span><span class="special">);</span>
        <span class="identifier">c</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">3</span><span class="special">*</span><span class="identifier">i</span><span class="special">);</span>
        <span class="identifier">d</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
        <span class="identifier">e</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">0.0</span><span class="special">);</span>
        <span class="identifier">f</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;(</span><span class="number">1.0</span><span class="special">,</span> <span class="number">1.0</span><span class="special">));</span>
    <span class="special">}</span>

    <span class="identifier">MixedOps</span><span class="special">::</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">b</span><span class="special">,</span> <span class="number">2</span><span class="special">);</span>
    <span class="identifier">MixedOps</span><span class="special">::</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">d</span><span class="special">,</span> <span class="identifier">a</span> <span class="special">+</span> <span class="identifier">b</span> <span class="special">*</span> <span class="identifier">c</span><span class="special">);</span>
    <span class="identifier">a</span> <span class="special">+=</span> <span class="identifier">if_else</span><span class="special">(</span><span class="identifier">d</span> <span class="special">&lt;</span> <span class="number">30</span><span class="special">,</span> <span class="identifier">b</span><span class="special">,</span> <span class="identifier">c</span><span class="special">);</span>

    <span class="identifier">MixedOps</span><span class="special">::</span><span class="identifier">assign</span><span class="special">(</span><span class="identifier">e</span><span class="special">,</span> <span class="identifier">c</span><span class="special">);</span>
    <span class="identifier">e</span> <span class="special">+=</span> <span class="identifier">e</span> <span class="special">-</span> <span class="number">4</span> <span class="special">/</span> <span class="special">(</span><span class="identifier">c</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>

    <span class="identifier">f</span> <span class="special">-=</span> <span class="identifier">sin</span><span class="special">(</span><span class="number">0.1</span> <span class="special">*</span> <span class="identifier">e</span> <span class="special">*</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;(</span><span class="number">0.2</span><span class="special">,</span> <span class="number">1.2</span><span class="special">));</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">ei</span> <span class="special">=</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">fi</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span>
            <span class="special">&lt;&lt;</span> <span class="string">"a("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">a</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" b("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">b</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" c("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">c</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" d("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">d</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
            <span class="special">&lt;&lt;</span> <span class="string">" e("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">ei</span><span class="special">++</span>
            <span class="special">&lt;&lt;</span> <span class="string">" f("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">") = "</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">fi</span><span class="special">++</span>
            <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.map_assign"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.map_assign" title="Map Assign: An Intermediate Transform"> Map Assign:
        An Intermediate Transform 一个中间变换</a>
</h4></div></div></div>


<p>
          A demonstration of how to implement <code class="computeroutput"><span class="identifier">map_list_of</span><span class="special">()</span></code> from the Boost.Assign library using Proto.
          <code class="computeroutput"><span class="identifier">map_list_assign</span><span class="special">()</span></code>
          is used to conveniently initialize a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>. By using Proto, we can avoid any
          dynamic allocation while building the intermediate representation.<br>以下示范如何用Proto从Boost.Assign库实现 <code class="computeroutput"><span class="identifier">map_list_of</span><span class="special">()</span></code>。<code class="computeroutput"><span class="identifier">map_list_assign</span><span class="special">()</span></code>
          用于便利地初始化一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;&gt;</span></code>。通过使用Proto，我们可以在构建中间表示方式时避免动态内存分配。</p>
<pre class="programlisting"><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This is a port of map_list_of() from the Boost.Assign library.<br></span><span class="comment">// It has the advantage of being more efficient at runtime by not<br></span><span class="comment">// building any temporary container that requires dynamic allocation.<br>// 这是对Boost.Assign库中的map_list_of()的修改。其优点是运行期的效率更高，<br>// 因为它没有创建创造任何需要动态内存分配的临时容器。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">transform</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_traits</span><span class="special">/</span><span class="identifier">add_reference</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">map_list_of_tag</span>
<span class="special">{};</span>

<span class="comment">// A simple callable function object that inserts a<br></span><span class="comment">// (key,value) pair into a map.<br>// 一个简单的可调用函数对象，插入一个(key,value)对到map中。<br></span><span class="keyword">struct</span> <span class="identifier">insert</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sig</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">This</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Map</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">This</span><span class="special">(</span><span class="identifier">Map</span><span class="special">,</span> <span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Value</span><span class="special">)&gt;</span>
      <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">add_reference</span><span class="special">&lt;</span><span class="identifier">Map</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Map</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
    <span class="identifier">Map</span> <span class="special">&amp;</span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Map</span> <span class="special">&amp;</span><span class="identifier">map</span><span class="special">,</span> <span class="identifier">Key</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">Value</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">value</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">map</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">Map</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">value</span><span class="special">));</span>
        <span class="keyword">return</span> <span class="identifier">map</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// The grammar for valid map-list expressions, and a<br></span><span class="comment">// transform that populates the map.<br>// 有效map-list表达式的语法，以及组装该map的变换。<br></span><span class="keyword">struct</span> <span class="identifier">MapListOf</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">map_list_of_tag</span><span class="special">&gt;</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
            <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">insert</span><span class="special">(</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_data</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child1</span><span class="special">)</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child2</span><span class="special">)</span>
            <span class="special">)</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
                <span class="identifier">MapListOf</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
            <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">insert</span><span class="special">(</span>
                <span class="identifier">MapListOf</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child0</span><span class="special">)</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child1</span><span class="special">)</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child2</span><span class="special">)</span>
            <span class="special">)</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">map_list_of_expr</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">map_list_of_dom</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;</span><span class="identifier">map_list_of_expr</span><span class="special">&gt;,</span> <span class="identifier">MapListOf</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// An expression wrapper that provides a conversion to a<br></span><span class="comment">// map that uses the MapListOf<br>// 一个表达式包装器，提供到一个使用MapListOf的map的转换<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">map_list_of_expr</span>
<span class="special">{</span>
    <span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">map_list_of_expr</span><span class="special">,</span> <span class="identifier">map_list_of_dom</span><span class="special">)</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_FUNCTION</span><span class="special">()</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Key</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Cmp</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Al</span><span class="special">&gt;</span>
    <span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Value</span><span class="special">,</span> <span class="identifier">Cmp</span><span class="special">,</span> <span class="identifier">Al</span><span class="special">&gt;</span> <span class="special">()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">MapListOf</span><span class="special">&gt;));</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Value</span><span class="special">,</span> <span class="identifier">Cmp</span><span class="special">,</span> <span class="identifier">Al</span><span class="special">&gt;</span> <span class="identifier">map</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">MapListOf</span><span class="special">()(*</span><span class="keyword">this</span><span class="special">,</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">map</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="identifier">map_list_of_expr</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">map_list_of_tag</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">map_list_of</span> <span class="special">=</span> <span class="special">{{{}}};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// Initialize a map: 初始化一个map:<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">op</span> <span class="special">=</span>
        <span class="identifier">map_list_of</span>
            <span class="special">(</span><span class="string">"&lt;"</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"&lt;="</span><span class="special">,</span><span class="number">2</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"&gt;"</span><span class="special">,</span> <span class="number">3</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"&gt;="</span><span class="special">,</span><span class="number">4</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"="</span><span class="special">,</span> <span class="number">5</span><span class="special">)</span>
            <span class="special">(</span><span class="string">"&lt;&gt;"</span><span class="special">,</span><span class="number">6</span><span class="special">)</span>
        <span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\"&lt;\"  --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">op</span><span class="special">[</span><span class="string">"&lt;"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\"&lt;=\" --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">op</span><span class="special">[</span><span class="string">"&lt;="</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\"&gt;\"  --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">op</span><span class="special">[</span><span class="string">"&gt;"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\"&gt;=\" --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">op</span><span class="special">[</span><span class="string">"&gt;="</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\"=\"  --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">op</span><span class="special">[</span><span class="string">"="</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\"&lt;&gt;\" --&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">op</span><span class="special">[</span><span class="string">"&lt;&gt;"</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.future_group"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.future_group" title="Future Group: A More Advanced Transform"> Future
        Group: A More Advanced Transform 更高级的变换</a>
</h4></div></div></div>


<p>
          An advanced example of a Proto transform that implements Howard Hinnant's
          design for <span class="emphasis"><em>future groups</em></span> that block for all or some
          asynchronous operations to complete and returns their results in a tuple
          of the appropriate type.<br>一个Proto变换的进阶例子，它实现了Howard Hinnant对于<span class="emphasis"><em>future groups</em></span>的设计，阻塞至所有或部分异步操作完成，并以一个适当类型的tuple来返回操作的结果。</p>
<pre class="programlisting"><span class="comment">//  Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">//  Software License, Version 1.0. (See accompanying file<br></span><span class="comment">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This is an example of using Proto transforms to implement<br></span><span class="comment">// Howard Hinnant's future group proposal.<br>// 这是一个使用Proto变换的例子，实现了Howard Hinnant的future group提议。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fusion</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">vector</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fusion</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">as_vector</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fusion</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">joint_view</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fusion</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">single_view</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">transform</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">fusion</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fusion</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">L</span><span class="special">,</span><span class="keyword">class</span> <span class="identifier">R</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">pick_left</span>
<span class="special">{</span>
    <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">L</span><span class="special">,</span> <span class="identifier">R</span><span class="special">&gt;));</span>
    <span class="keyword">typedef</span> <span class="identifier">L</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// Define the grammar of future group expression, as well as a<br></span><span class="comment">// transform to turn them into a Fusion sequence of the correct<br></span><span class="comment">// type.<br>// 定义future group表达式的语法，以及一个将表达式转换为正确类型的Fusion序列的变换。<br></span><span class="keyword">struct</span> <span class="identifier">FutureGroup</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="comment">// terminals become a single-element Fusion sequence<br>        // 终结符变为单元素的Fusion序列<br></span>        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">single_view</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">&gt;(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">)</span>
        <span class="special">&gt;</span>
        <span class="comment">// (a &amp;&amp; b) becomes a concatenation of the sequence<br></span>        <span class="comment">// from 'a' and the one from 'b':<br>        // (a &amp;&amp; b)变为序列'a'和序列'b'的串接：<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_and</span><span class="special">&lt;</span><span class="identifier">FutureGroup</span><span class="special">,</span> <span class="identifier">FutureGroup</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">joint_view</span><span class="special">&lt;</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">add_const</span><span class="special">&lt;</span><span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">)&gt;</span>
              <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">add_const</span><span class="special">&lt;</span><span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">)&gt;</span>
            <span class="special">&gt;(</span><span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">),</span> <span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">))</span>
        <span class="special">&gt;</span>
        <span class="comment">// (a || b) becomes the sequence for 'a', so long<br></span>        <span class="comment">// as it is the same as the sequence for 'b'.<br>        // (a || b)变为序列'a'，只要它与序列'b'一样。<br></span>      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_or</span><span class="special">&lt;</span><span class="identifier">FutureGroup</span><span class="special">,</span> <span class="identifier">FutureGroup</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">pick_left</span><span class="special">&lt;</span>
                <span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">)</span>
              <span class="special">,</span> <span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_right</span><span class="special">)</span>
            <span class="special">&gt;(</span><span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_left</span><span class="special">))</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">E</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">future_expr</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">future_dom</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">future_expr</span><span class="special">&gt;,</span> <span class="identifier">FutureGroup</span><span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// Expressions in the future group domain have a .get()<br></span><span class="comment">// member function that (ostensibly) blocks for the futures<br></span><span class="comment">// to complete and returns the results in an appropriate<br></span><span class="comment">// tuple.<br>// future group领域中的表达式带有一个.get()成员函数，该函数(表面上)<br>// 为future阻塞至完成，并在一个合适的tuple中返回结果。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">E</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">future_expr</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">,</span> <span class="identifier">future_expr</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">&gt;,</span> <span class="identifier">future_dom</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">explicit</span> <span class="identifier">future_expr</span><span class="special">(</span><span class="identifier">E</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">e</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">,</span> <span class="identifier">future_expr</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">&gt;,</span> <span class="identifier">future_dom</span><span class="special">&gt;(</span><span class="identifier">e</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">typename</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_vector</span><span class="special">&lt;</span>
        <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">FutureGroup</span><span class="special">(</span><span class="identifier">E</span><span class="special">,</span><span class="keyword">int</span><span class="special">,</span><span class="keyword">int</span><span class="special">)&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">get</span><span class="special">()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">as_vector</span><span class="special">(</span><span class="identifier">FutureGroup</span><span class="special">()(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">i</span><span class="special">,</span> <span class="identifier">i</span><span class="special">));</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// The future&lt;&gt; type has an even simpler .get()<br></span><span class="comment">// member function.<br>// future&lt;&gt;类型带有一个更简单的.get()成员函数。<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">future</span>
  <span class="special">:</span> <span class="identifier">future_expr</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">future</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">t</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">())</span>
      <span class="special">:</span> <span class="identifier">future_expr</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;(</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">make</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span>
        <span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">T</span> <span class="identifier">get</span><span class="special">()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// TEST CASES 测试用例<br></span><span class="keyword">struct</span> <span class="identifier">A</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">B</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">C</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">vector</span><span class="special">;</span>
    <span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">&gt;</span> <span class="identifier">a</span><span class="special">;</span>
    <span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">B</span><span class="special">&gt;</span> <span class="identifier">b</span><span class="special">;</span>
    <span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">&gt;</span> <span class="identifier">c</span><span class="special">;</span>
    <span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">ab</span><span class="special">;</span>

    <span class="comment">// Verify that various future groups have the<br></span>    <span class="comment">// correct return types.<br>    // 检查不同的future group是否具有正确的返回类型。<br></span>    <span class="identifier">A</span>                       <span class="identifier">t0</span> <span class="special">=</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
    <span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;</span>         <span class="identifier">t1</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">a</span> <span class="special">&amp;&amp;</span> <span class="identifier">b</span> <span class="special">&amp;&amp;</span> <span class="identifier">c</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>
    <span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;</span>            <span class="identifier">t2</span> <span class="special">=</span> <span class="special">((</span><span class="identifier">a</span> <span class="special">||</span> <span class="identifier">a</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="identifier">c</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>
    <span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;</span>         <span class="identifier">t3</span> <span class="special">=</span> <span class="special">((</span><span class="identifier">a</span> <span class="special">&amp;&amp;</span> <span class="identifier">b</span> <span class="special">||</span> <span class="identifier">a</span> <span class="special">&amp;&amp;</span> <span class="identifier">b</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="identifier">c</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>
    <span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;,</span> <span class="identifier">C</span><span class="special">&gt;</span> <span class="identifier">t4</span> <span class="special">=</span> <span class="special">((</span><span class="identifier">ab</span> <span class="special">||</span> <span class="identifier">ab</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="identifier">c</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.examples.lambda"></a><a class="link" href="users_guide.html#boost_proto.users_guide.examples.lambda" title="Lambda: A Simple Lambda Library with Proto"> Lambda: A
        Simple Lambda Library with Proto 一个使用Proto的简单Lambda库</a>
</h4></div></div></div>


<p>
          This is an advanced example that shows how to implement a simple lambda
          DSEL with Proto, like the Boost.Lambda_library. It uses contexts, transforms
          and expression extension.<br>这是一个高级例子，示范如何用Proto实现一个简单的lambda DSEL，类似于Boost.Lambda库。它使用了上下文、变换和表达式扩展。</p>
<pre class="programlisting"><span class="comment">///////////////////////////////////////////////////////////////////////////////<br></span><span class="comment">// Copyright 2008 Eric Niebler. Distributed under the Boost<br></span><span class="comment">// Software License, Version 1.0. (See accompanying file<br></span><span class="comment">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)<br></span><span class="comment">//<br></span><span class="comment">// This example builds a simple but functional lambda library using Proto.<br>// 这个例子用Proto构建一个简单但可用的lambda库。<br></span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">algorithm</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="keyword">int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">min_max</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">eval_if</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">identity</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">next_prior</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fusion</span><span class="special">/</span><span class="identifier">tuple</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">ostream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">iostream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">context</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">transform</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">mpl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">fusion</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fusion</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">;</span>

<span class="comment">// Forward declaration of the lambda expression wrapper<br>// lambda表达式包装器的前向声明 <br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lambda</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">lambda_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;</span><span class="identifier">lambda</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">I</span> <span class="identifier">arity</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder_arity</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">::</span><span class="identifier">arity</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// The lambda grammar, with the transforms for calculating the max arity<br>// lambda语法，带有计算最大arity的变换<br></span><span class="keyword">struct</span> <span class="identifier">Lambda</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">next</span><span class="special">&lt;</span><span class="identifier">placeholder_arity</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span><span class="special">&gt;</span> <span class="special">&gt;()</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;()</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(),</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">max</span><span class="special">&lt;</span><span class="identifier">Lambda</span><span class="special">,</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_state</span><span class="special">&gt;()&gt;</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="comment">// simple wrapper for calculating a lambda expression's arity.<br>// 计算一个lambda表达式的arity的简单包装器<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lambda_arity</span>
  <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">Lambda</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">void_</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">void_</span><span class="special">)&gt;</span>
<span class="special">{};</span>

<span class="comment">// The lambda context is the same as the default context<br></span><span class="comment">// with the addition of special handling for lambda placeholders<br>// lambda上下文与缺省上下文一样，增加了对lambda占位符的特殊处理<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Tuple</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lambda_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span><span class="identifier">lambda_context</span><span class="special">&lt;</span><span class="identifier">Tuple</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">lambda_context</span><span class="special">(</span><span class="identifier">Tuple</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">args</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">args_</span><span class="special">(</span><span class="identifier">args</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sig</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">This</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">This</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;)&gt;</span>
      <span class="special">:</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">at</span><span class="special">&lt;</span><span class="identifier">Tuple</span><span class="special">,</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">at</span><span class="special">&lt;</span><span class="identifier">Tuple</span><span class="special">,</span> <span class="identifier">I</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">at</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;(</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">args_</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">Tuple</span> <span class="identifier">args_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// The lambda&lt;&gt; expression wrapper makes expressions polymorphic<br></span><span class="comment">// function objects<br>// lambda&lt;&gt;表达式包装器将表达式变为多态函数对象<br></span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lambda</span>
<span class="special">{</span>
    <span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">lambda</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">lambda_domain</span><span class="special">)</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span>

    <span class="comment">// Careful not to evaluate the return type of the nullary function<br></span>    <span class="comment">// unless we have a nullary lambda!<br>    // 小心不要对无参函数的返回类型进行求值，除非我们有一个无参lambda!<br></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">eval_if</span><span class="special">&lt;</span>
        <span class="keyword">typename</span> <span class="identifier">lambda_arity</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">identity</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">lambda_context</span><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">nullary_type</span><span class="special">;</span>

    <span class="comment">// Define our operator () that evaluates the lambda expression.<br>    // 定义我们的operator()，对lambda表达式进行求值。<br></span>    <span class="identifier">nullary_type</span> <span class="keyword">operator</span> <span class="special">()()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;&gt;</span> <span class="identifier">args</span><span class="special">;</span>
        <span class="identifier">lambda_context</span><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">args</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">lambda_context</span><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;&gt;</span> <span class="identifier">args</span><span class="special">(</span><span class="identifier">a0</span><span class="special">);</span>
        <span class="identifier">lambda_context</span><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;&gt;</span> <span class="special">&gt;</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">args</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A1</span><span class="special">&gt;</span>
    <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">eval</span><span class="special">&lt;</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">lambda_context</span><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;,</span> <span class="identifier">A1</span> <span class="keyword">const</span> <span class="special">&amp;&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a0</span><span class="special">,</span> <span class="identifier">A1</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a1</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;,</span> <span class="identifier">A1</span> <span class="keyword">const</span> <span class="special">&amp;&gt;</span> <span class="identifier">args</span><span class="special">(</span><span class="identifier">a0</span><span class="special">,</span> <span class="identifier">a1</span><span class="special">);</span>
        <span class="identifier">lambda_context</span><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;,</span> <span class="identifier">A1</span> <span class="keyword">const</span> <span class="special">&amp;&gt;</span> <span class="special">&gt;</span> <span class="identifier">ctx</span><span class="special">(</span><span class="identifier">args</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Define some lambda placeholders 定义一些lambda占位符<br></span><span class="identifier">lambda</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">lambda</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">int_</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{}};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">lambda</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">val</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">lambda</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">that</span> <span class="special">=</span> <span class="special">{{</span><span class="identifier">t</span><span class="special">}};</span>
    <span class="keyword">return</span> <span class="identifier">that</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">lambda</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">T</span> <span class="special">&amp;&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">var</span><span class="special">(</span><span class="identifier">T</span> <span class="special">&amp;</span><span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">lambda</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">T</span> <span class="special">&amp;&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">that</span> <span class="special">=</span> <span class="special">{{</span><span class="identifier">t</span><span class="special">}};</span>
    <span class="keyword">return</span> <span class="identifier">that</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">construct_helper</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">result_type</span><span class="special">;</span> <span class="comment">// for TR1 result_of<br></span>
    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">T</span><span class="special">();</span> <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">&gt;</span>
    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">T</span><span class="special">(</span><span class="identifier">a0</span><span class="special">);</span> <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A1</span><span class="special">&gt;</span>
    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a0</span><span class="special">,</span> <span class="identifier">A1</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a1</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">T</span><span class="special">(</span><span class="identifier">a0</span><span class="special">,</span> <span class="identifier">a1</span><span class="special">);</span> <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Generate BOOST_PROTO_MAX_ARITY-1 overloads of the<br></span><span class="comment">// construct function template like the one defined above.<br>// 生成BOOST_PROTO_MAX_ARITY-1个构造函数模板的重载，类似于前面所定义的。<br></span><span class="identifier">BOOST_PROTO_DEFINE_VARARG_FUNCTION_TEMPLATE</span><span class="special">(</span>            <span class="special">\</span>
    <span class="identifier">construct</span>                                           <span class="special">\</span>
  <span class="special">,</span> <span class="identifier">lambda_domain</span>                                       <span class="special">\</span>
  <span class="special">,</span> <span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span><span class="special">)</span>                              <span class="special">\</span>
  <span class="special">,</span> <span class="special">((</span><span class="identifier">construct_helper</span><span class="special">)(</span><span class="keyword">typename</span><span class="special">))</span>                      <span class="special">\</span>
<span class="special">)</span>

<span class="keyword">struct</span> <span class="identifier">S</span>
<span class="special">{</span>
    <span class="identifier">S</span><span class="special">()</span> <span class="special">{}</span>
    <span class="identifier">S</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">,</span> <span class="keyword">char</span> <span class="identifier">c</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"S("</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">","</span> <span class="special">&lt;&lt;</span> <span class="identifier">c</span> <span class="special">&lt;&lt;</span> <span class="string">")\n"</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// Create some lambda objects and immediately<br></span>    <span class="comment">// invoke them by applying their operator():<br>    // 创建一些lambda对象，并立即通过应用其operator()调用它们：<br></span>    <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">_1</span> <span class="special">+</span> <span class="number">2</span><span class="special">)</span> <span class="special">/</span> <span class="number">4</span> <span class="special">)(</span><span class="number">42</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints 11<br></span>
    <span class="keyword">int</span> <span class="identifier">j</span> <span class="special">=</span> <span class="special">(</span> <span class="special">(-(</span><span class="identifier">_1</span> <span class="special">+</span> <span class="number">2</span><span class="special">))</span> <span class="special">/</span> <span class="number">4</span> <span class="special">)(</span><span class="number">42</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">j</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints -11<br></span>
    <span class="keyword">double</span> <span class="identifier">d</span> <span class="special">=</span> <span class="special">(</span> <span class="special">(</span><span class="number">4</span> <span class="special">-</span> <span class="identifier">_2</span><span class="special">)</span> <span class="special">*</span> <span class="number">3</span> <span class="special">)(</span><span class="number">42</span><span class="special">,</span> <span class="number">3.14</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">d</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints 2.58<br></span>
    <span class="comment">// check non-const ref terminals 检查非常量引用终结符<br></span>    <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">_1</span> <span class="special">&lt;&lt;</span> <span class="string">" -- "</span> <span class="special">&lt;&lt;</span> <span class="identifier">_2</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">)(</span><span class="number">42</span><span class="special">,</span> <span class="string">"Life, the Universe and Everything!"</span><span class="special">);</span>
    <span class="comment">// prints "42 -- Life, the Universe and Everything!"<br></span>
    <span class="comment">// "Nullary" lambdas work too "无参"lambda也可以<br></span>    <span class="keyword">int</span> <span class="identifier">k</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">val</span><span class="special">(</span><span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">val</span><span class="special">(</span><span class="number">2</span><span class="special">))();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">k</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints 3<br></span>
    <span class="comment">// check array indexing for kicks 检查数组索引<br></span>    <span class="keyword">int</span> <span class="identifier">integers</span><span class="special">[</span><span class="number">5</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="number">0</span><span class="special">};</span>
    <span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">integers</span><span class="special">)[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="number">2</span><span class="special">)();</span>
    <span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">integers</span><span class="special">)[</span><span class="identifier">_1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">)(</span><span class="number">3</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">integers</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints 2<br></span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">integers</span><span class="special">[</span><span class="number">3</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints 3<br></span>
    <span class="comment">// Now use a lambda with an STL algorithm! 现在将lambda用于STL算法！<br></span>    <span class="keyword">int</span> <span class="identifier">rgi</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">,</span><span class="number">3</span><span class="special">,</span><span class="number">4</span><span class="special">};</span>
    <span class="keyword">char</span> <span class="identifier">rgc</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">,</span><span class="char">'d'</span><span class="special">};</span>
    <span class="identifier">S</span> <span class="identifier">rgs</span><span class="special">[</span><span class="number">4</span><span class="special">];</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">rgi</span><span class="special">,</span> <span class="identifier">rgi</span><span class="special">+</span><span class="number">4</span><span class="special">,</span> <span class="identifier">rgc</span><span class="special">,</span> <span class="identifier">rgs</span><span class="special">,</span> <span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">S</span><span class="special">&gt;(</span><span class="identifier">_1</span><span class="special">,</span> <span class="identifier">_2</span><span class="special">));</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.resources"></a><a class="link" href="users_guide.html#boost_proto.users_guide.resources" title="Background and Resources"> Background and Resources 背景和资源</a>
</h3></div></div></div>
<p>
        Proto was initially developed as part of <a href="../../../libs/xpressive/index.html" target="_top">Boost.Xpressive</a>
        to simplify the job of transforming an expression template into an executable
        finite state machine capable of matching a regular expression. Since then,
        Proto has found application in the redesigned and improved Spirit-2 and the
        related Karma library. As a result of these efforts, Proto evolved into a
        generic and abstract grammar and tree transformation framework applicable
        in a wide variety of DSEL scenarios.<br>起初，Proto是作为 <a href="../../../libs/xpressive/index.html" target="_top">Boost.Xpressive</a>
的一部分来开发的，目的是简化把一个表达式模板转换为一个与正则表达式能力相当的、可执行的有限状态机的工作。此后，我们发现Proto也可以在对
Spirit-2以及相关的Karma库的重新设计和改进中得以应用。由于这些努力，Proto进化为一个通用且抽象的语法及树变换框架，可以应用于广泛
的DSEL设计与开发中。 </p>
<p>
        The grammar and tree transformation framework is modeled on Spirit's grammar
        and semantic action framework. The expression tree data structure is similar
        to Fusion data structures in many respects, and is interoperable with Fusion's
        iterators and algorithms.<br>这个语法和树变换的框架模仿了Spirit的语法和语义动作框架。其中的表达式树结构在许多方面类似于Fusion数据结构，并且可以与Fusion的迭代器及算法相互操作。
      </p>
<p>
        The syntax for the grammar-matching features of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> is inspired by MPL's lambda expressions.<br>用于 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> 的语法匹配特性的语法，其灵感来自于MPL的lambda表达式。
      </p>
<p>
        The idea for using function types for Proto's composite transforms is inspired
        by Aleksey Gurtovoy's <a href="http://lists.boost.org/Archives/boost/2002/11/39718.php" target="_top">"round"
        lambda</a> notation.<br>用函数类型来进行Proto的变换组合这一思想，其灵感来自于Aleksey Gurtovoy的 <a href="http://lists.boost.org/Archives/boost/2002/11/39718.php" target="_top">"round"
        lambda</a> 记号。
      </p>
<a name="boost_proto.users_guide.resources.references"></a><h5>
<a name="id3583022"></a>
        <a class="link" href="users_guide.html#boost_proto.users_guide.resources.references">References 参考文献</a>
      </h5>
<a name="boost_proto.users_guide.resources.SYB"></a><div class="blockquote"><blockquote class="blockquote">
<p>
          </p>
<p>
            Ren, D. and Erwig, M. 2006. A generic recursion toolbox for Haskell or:
            scrap your boilerplate systematically. In <span class="emphasis"><em>Proceedings of the
            2006 ACM SIGPLAN Workshop on Haskell</em></span> (Portland, Oregon, USA,
            September 17 - 17, 2006). Haskell '06. ACM, New York, NY, 13-24. DOI=<a href="http://doi.acm.org/10.1145/1159842.1159845" target="_top">http://doi.acm.org/10.1145/1159842.1159845</a>
          </p>
<p>
        </p>
</blockquote></div>
<a name="boost_proto.users_guide.resources.further_reading"></a><h5>
<a name="id3583075"></a>
        <a class="link" href="users_guide.html#boost_proto.users_guide.resources.further_reading">Further
        Reading 更进一步的读物</a>
      </h5>
<p>
        A technical paper about an earlier version of Proto was accepted into the
        <a href="http://lcsd.cs.tamu.edu/2007/" target="_top">ACM SIGPLAN Symposium on Library-Centric
        Software Design LCSD'07</a>, and can be found at <a href="http://lcsd.cs.tamu.edu/2007/final/1/1_Paper.pdf" target="_top">http://lcsd.cs.tamu.edu/2007/final/1/1_Paper.pdf</a>.
        The tree transforms described in that paper differ from what exists today.<br>有关Proto早期版本的一篇技术论文被收录在
        <a href="http://lcsd.cs.tamu.edu/2007/" target="_top">ACM SIGPLAN Symposium on Library-Centric
        Software Design LCSD'07</a>，可以在 <a href="http://lcsd.cs.tamu.edu/2007/final/1/1_Paper.pdf" target="_top">http://lcsd.cs.tamu.edu/2007/final/1/1_Paper.pdf</a> 中找到。在该论文中所描述的树变换与现在的实现有所不同。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.glossary"></a><a class="link" href="users_guide.html#boost_proto.users_guide.glossary" title="Glossary">Glossary 术语</a>
</h3></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.callable_transform"></a> callable transform 可调用变换</span></dt>
<dd><p>
            A transform of the form <code class="computeroutput"><span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">,...)</span></code> (i.e., a function type) where <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">value</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
            <code class="computeroutput"><span class="identifier">R</span></code> is treated as a polymorphic
            function object and the arguments are treated as transforms that yield
            the arguments to the function object.<br>一种形如 <code class="computeroutput"><span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">,...)</span></code> (即一个函数类型)的变换，其中 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">value</span></code> 为 <code class="computeroutput"><span class="keyword">true</span></code>。<code class="computeroutput"><span class="identifier">R</span></code> 被视为一个多态函数对象，其它参数则被视为产生该函数对象各个实参的变换。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.context"></a> context 上下文</span></dt>
<dd><p>
            In Proto, the term <span class="emphasis"><em>context</em></span> refers to an object that
            can be passed, along with an expression to evaluate, to the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
            function. The context determines how the expression is evaluated. All
            context structs define a nested <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code> template that, when instantiated
            with a node tag type (e.g., <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span></code>),
            is a binary polymorphic function object that accepts an expression of
            that type and the context object. In this way, contexts associate behaviors
            with expression nodes.<br>在Proto中，术语<span class="emphasis"><em>上下文</em></span>是指这样一个对象，它可以和一个要求值的表达式一起，被传递给 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
            函数。上下文决定了表达式如何被求值。所有上下文结构都定义了一个嵌套的 <code class="computeroutput"><span class="identifier">eval</span><span class="special">&lt;&gt;</span></code> 模板，当用一个节点标签类型(如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span></code>)对该模板进行实例化时，它是一个二元多态函数对象。接受一个相关类型的表达式以及该上下文对象。上下文正是以此种方式将行为与表达式节点关联起来。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.domain"></a> domain 领域</span></dt>
<dd><p>
            In Proto, the term <span class="emphasis"><em>domain</em></span> refers to a type that
            associates expressions within that domain with a <span class="emphasis"><em>generator</em></span>
            for that domain and optionally a <span class="emphasis"><em>grammar</em></span> for the
            domain. Domains are used primarily to imbue expressions within that domain
            with additional members and to restrict Proto's operator overloads such
            that expressions not conforming to the domain's grammar are never created.
            Domains are empty structs that inherit from <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code>.<br>在Proto中，术语<span class="emphasis"><em>领域</em></span>是指这样一个类型，它以该领域的一个<span class="emphasis"><em>生成器</em></span>以及一个可选的该领域<span class="emphasis"><em>语法</em></span>，将表达式关联至该领域内。领域主要用于通过为表达式增加某些成员，以及限制某些Proto的操作符重载以令不符合该领域语法的表达式不可创建，来将表达式注入到领域中。领域是继承自 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> 的空结构。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.dsel"></a> domain-specific embedded language 领域专用嵌入式语言</span></dt>
<dd><p>
            A domain-specific language implemented as a library. The language in
            which the library is written is called the "host" language,
            and the language implemented by the library is called the "embedded"
            language.<br>一种领域专用语言被实现为一个库。编写该库的语言称为"宿主"语言，而该库所实现的语言则称为"嵌入"语言。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.dsl"></a> domain-specific language 领域专用语言</span></dt>
<dd><p>
            A programming language that targets a particular problem space by providing
            programming idioms, abstractions and constructs that match the constructs
            within that problem space.<br>针对特定问题空间的一种编程语言，提供编程惯用法、抽象和结构，与问题空间中的结构相匹配。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.expression"></a> expression 表达式</span></dt>
<dd><p>
            In Proto, an <span class="emphasis"><em>expression</em></span> is a heterogeneous tree
            where each node is either an instantiation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code> or some type that is an extension
            (via <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code>
            or <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code>) of such an instantiation.<br>在Proto中，一个<span class="emphasis"><em>表达式</em></span>是一棵异构树，其中每个节点，要么是 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code> 的一个实例，要么是此种实例的一个扩展类型(通过 <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code> 或 <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">()</span></code> 扩展)。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.expression_template"></a> expression template 表达式模板</span></dt>
<dd><p>
            A C++ technique using templates and operator overloading to cause expressions
            to build trees that represent the expression for lazy evaluation later,
            rather than evaluating the expression eagerly. Some C++ libraries use
            expression templates to build domain-specific embedded languages.<br>一种C++技巧，使用模板和操作符重载来使得表达式不会引起立即求值，而是构造出一棵代表了将该表达式延迟求值的树。有些C++库使用表达式模板来构建领域专用嵌入式语言。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.generator"></a> generator 生成器</span></dt>
<dd><p>
            In Proto, a <span class="emphasis"><em>generator</em></span> is a unary polymorphic function
            object that you specify when defining a <span class="emphasis"><em>domain</em></span>.
            After constructing a new expression, Proto passes the expression to your
            domain's generator for further processing. Often, the generator wraps
            the expression in an extension wrapper that adds additional members to
            it.<br>在Proto中，<span class="emphasis"><em>生成器</em></span>是一个你在定义<span class="emphasis"><em>领域</em></span>时要指定的单参多态函数对象。在构造出一个新的表达式后，Proto将该表达式传递给你的领域的生成器进行下一步处理。通常，生成器将表达式包装进一个扩展包装器，为它增加新的成员。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.grammar"></a> grammar 语法</span></dt>
<dd><p>
            In Proto, a <span class="emphasis"><em>grammar</em></span> is a type that describes a subset
            of Proto expression types. Expressions in a domain must conform to that
            domain's grammar. The <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> metafunction evaluates whether
            an expression type matches a grammar. Grammars are either primitives
            such as <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>, composites such as <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;&gt;</span></code>,
            control structures such as <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code>, or some type derived from a
            grammar.<br>在Proto中，<span class="emphasis"><em>语法</em></span>是一个类型，它描述了Proto表达式类型的一个子集。一个领域中的表达式必须符合该领域的语法。<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> 元函数用于评估一个表达式类型是否匹配某个语法。语法或者是一个象 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code> 这样的原词，或是象 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;&gt;</span></code> 这样的组合，或是象 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;&gt;</span></code> 这样的控制结构，或是派生自某个语法的其它类型。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.object_transform"></a> object transform 对象变换</span></dt>
<dd><p>
            A transform of the form <code class="computeroutput"><span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">,...)</span></code> (i.e., a function type) where <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">value</span></code> is <code class="computeroutput"><span class="keyword">false</span></code>.
            <code class="computeroutput"><span class="identifier">R</span></code> is treated as the type
            of an object to construct and the arguments are treated as transforms
            that yield the parameters to the constructor.<br>一个形如 <code class="computeroutput"><span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">,...)</span></code> (即一个函数类型)的变换，其中 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_callable</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">value</span></code> 为 <code class="computeroutput"><span class="keyword">false</span></code>。<code class="computeroutput"><span class="identifier">R</span></code> 被视为一个要构造的对象的类型，其它参数被视为生成该构造函数各个参数的变换。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.polymorphic_function_object"></a> polymorphic
        function object 多态函数对象</span></dt>
<dd><p>
            An instance of a class type with an overloaded function call operator
            and a nested <code class="computeroutput"><span class="identifier">result_type</span></code>
            typedef or <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            template for calculating the return type of the function call operator.<br>一个带有重载的函数调用操作符以及内嵌的 <code class="computeroutput"><span class="identifier">result_type</span></code>
            typedef 或用于计算该函数调用操作符的返回类型的 <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            模板的类类型的实例。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.primitive_transform"></a> primitive transform 基本变换</span></dt>
<dd><p>
            A type that defines a kind of polymorphic function object that takes
            three arguments: expression, state, and data. Primitive transforms can
            be used to compose callable transforms and object transforms.<br>一个类型，定义了一种多态函数对象，该函数对象接受三个参数：表达式、状态和数据。基本变换可以用于组成可调用变换和对象变换。
          </p></dd>
<dt><span class="term"> <a name="boost_proto.users_guide.glossary.transform"></a> transform 变换</span></dt>
<dd><p>
            Transforms are used to manipulate expression trees. They come in three
            flavors: primitive transforms, callable transforms, or object transforms.
            A transform <code class="computeroutput">
            <em class="replaceable"><code>
              T
            </code></em>
            </code> can be made into a ternary polymorphic function object with
            <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;&gt;</span></code>,
            as in <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">,</span>
            <em class="replaceable"><code>
              T
            </code></em>
            <span class="special">&gt;</span></code>. Such a function object accepts
            <span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>state</em></span>, and <span class="emphasis"><em>data</em></span>
            parameters, and computes a result from them.<br>变换用于操纵表达式树。它们有三种形式：基本变换、可调用变换或对象变换。变换 <code class="computeroutput">
            <em class="replaceable"><code>
              T
            </code></em>
            </code> 可以用&nbsp;<code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;&gt;</span></code> 制成一个三元多态函数对象，如 <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">,</span>
            <em class="replaceable"><code>
              T
            </code></em>
            <span class="special">&gt;</span></code>。这样一个函数对象接受 <span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>state</em></span>, 和 <span class="emphasis"><em>data</em></span>
            参数，并由它们计算出结果。
          </p></dd>
</dl>
</div>
</div>
<div class="footnotes">
<br><hr align="left" width="100">
<div class="footnote"><p><sup>[<a name="ftn.id3520189" href="#id3520189" class="para">3</a>] </sup>
                This error message was generated with Microsoft Visual C++ 9.0. Different
                compilers will emit different messages with varying degrees of readability.<br>这个错误信息是由 Microsoft Visual C++ 9.0 产生的。不同的编译器会给出可读性程度不同的信息。
              </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2008 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../proto.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../proto.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
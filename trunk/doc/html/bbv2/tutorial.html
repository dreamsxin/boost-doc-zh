<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Tutorial</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../bbv2.html" title="Chapter&nbsp;28.&nbsp;Boost.Build V2 User Manual">
<link rel="prev" href="installation.html" title="Installation">
<link rel="next" href="advanced.html" title="Overview"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="installation.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bbv2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="advanced.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="bbv2.tutorial"></a>Tutorial 教程</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.hello">Hello, world</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.properties">Properties 属性</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.hierarchy">Project Hierarchies 工程层次</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.libs">Dependent Targets 依赖目标</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.testing">Testing 测试</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.linkage">Static and shared libaries 静态库和共享库</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.conditions">Conditions and alternatives 条件和选择</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.prebuilt">Prebuilt targets 预构建目标</a></span></dt>
</dl></div>
<p>
    This section will guide you though the most basic features of Boost.Build
    V2. We will start with the “Hello, world” example, learn how
    to use libraries, and finish with testing and installing features.<br>本节将教给你一些 Boost.Build
    V2 中最基本的特性。我们将从 “Hello, world” 例子开始，学习如何使用库，并以测试和安装特性结束。
  </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.hello"></a>Hello, world</h3></div></div></div>
<p>
      The simplest project that Boost.Build can construct is stored in
      <code class="filename">example/hello/</code> directory. The project is described by
      a file called <code class="filename">Jamroot</code> that contains:<br>Boost.Build 可以构建的最简单工程保存在
      <code class="filename">example/hello/</code> 目录下。该工程由一个名为 <code class="filename">Jamroot</code> 的文件来描述，它包含：

</p>
<pre class="programlisting">exe hello : hello.cpp ;<br></pre>
<p>

      Even with this simple setup, you can do some interesting things. First of
      all, just invoking <span class="command"><strong>bjam</strong></span> will build the <code class="filename">hello
      </code> executable by compiling and linking <code class="filename">hello.cpp
      </code>. By default, debug variant is built. Now, to build the release
      variant of <code class="filename">hello</code>, invoke<br>即使只是这么简单的设置，你也可以做一些有趣的事情。首先，只需调用 <span class="command"><strong>bjam</strong></span> 就可以通过编译和链接 <code class="filename">hello.cpp</code> 来构建 <code class="filename">hello</code>&nbsp;的可执行文件。缺省情况是构建调试版本。要构 <code class="filename">hello</code> 的发布版本，请调用：

</p>
<pre class="screen">bjam release<br></pre>
<p>

      Note that debug and release variants are created in different directories,
      so you can switch between variants or even build multiple variants at
      once, without any unnecessary recompilation. Let us extend the example by
      adding another line to our project's <code class="filename">Jamroot</code>:<br>注意，调试版本和发布版本是在不同目录下构建的，所以你可以在两个版本间切换，或者一次构建多个版本，而不需要任何多余的重编译。让我们来扩展这个例子，增加一行到我们的工程的 <code class="filename">Jamroot</code> 中：

</p>
<pre class="programlisting">exe hello2 : hello.cpp ;<br></pre>
<p>

      Now let us build both the debug and release variants of our project again:<br>现在让我们再次构建这个工程的调试和发布版本：

</p>
<pre class="screen">bjam debug release<br></pre>
<p>

      Note that two variants of <code class="filename">hello2</code> are linked. Since we
      have already built both variants of <code class="filename">hello</code>, hello.cpp
      will not be recompiled; instead the existing object files will just be
      linked into the corresponding variants of <code class="filename">hello2</code>. Now
      let us remove all the built products:<br>注意，<code class="filename">hello2</code> 的两个版本都被链接了。因为我们已经构建过 <code class="filename">hello</code> 的两个版本，所以 hello.cpp
      无须重编译；而只须将已有的目标文件链接到 <code class="filename">hello2</code> 的相应版本中。现在我们来删掉所有已构建的成品：

</p>
<pre class="screen">bjam --clean debug release<br></pre>
<p>

      It is also possible to build or clean specific targets. The following two
      commands, respectively, build or clean only the debug version of
      <code class="filename">hello2</code>.<br>也可以只构建或清除指定的目标。以下两个命令分别构建和清除
      <code class="filename">hello2</code> 的调试版本。

</p>
<pre class="screen">bjam hello2<br>bjam --clean hello2<br></pre>
<p>
    </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.properties"></a>Properties 属性</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.properties.requirements">Build Requests and Target Requirements 构建请求与目标要求</a></span></dt>
<dt><span class="section"><a href="tutorial.html#bbv2.tutorial.properties.project_attributes">Project Attributes 工程属性</a></span></dt>
</dl></div>
<p>
      To portably represent aspects of target configuration such as
      debug and release variants, or single- and multi-threaded
      builds, Boost.Build uses <em class="firstterm">features</em> with
      associated <em class="firstterm">values</em>.  For
      example, the <code class="computeroutput">debug-symbols</code> feature can have a value of <code class="computeroutput">on</code> or
      <code class="computeroutput">off</code>.  A <em class="firstterm">property</em> is just a (feature,
      value) pair.  When a user initiates a build, Boost.Build
      automatically translates the requested properties into appropriate
      command-line flags for invoking toolset components like compilers
      and linkers.<br>为了可移植地表示目标配置的情况，如调试版本和发布版本、或者单线程和多线程，Boost.Build 使用了 <em class="firstterm">特性features</em>，它带有关联的 <em class="firstterm">值values</em>。例如，特性 <code class="computeroutput">debug-symbols</code> 可以具有&nbsp;<code class="computeroutput">on</code> 或
      <code class="computeroutput">off</code> 的值。<em class="firstterm">属性property</em> 是一对 (特性，值)。当用户初始化一个构建时，Boost.Build
      自动地将给定的属性翻译为适合的命令行选项，以调用象编译器和链接器这些工具集组件。
    </p>
<p>
      There are many built-in features that can be combined to
      produce arbitrary build configurations.  The following command
      builds the project's <code class="computeroutput">release</code> variant with inlining
      disabled and debug symbols enabled:<br>有多个内建的特性可以组合起来，生成不同的构建配置。以下命令行以禁止内联和打开调试符号的配置来构建工程的 <code class="computeroutput">release</code> 版本：
</p>
<pre class="screen">bjam release inlining=off debug-symbols=on<br></pre>

<p>
    
      Properties on the command-line are specified with the syntax:<br>命令行上的属性以这样的语法指定：

</p>
<pre class="screen"><em class="replaceable"><code>feature-name</code></em>=<em class="replaceable"><code>feature-value</code></em>
</pre>

<p>
    
      The <code class="option">release</code> and <code class="option">debug</code> that we have seen
      in <span class="command"><strong>bjam</strong></span> invocations are just a shorthand way to specify
      values of the <code class="varname">variant</code> feature.  For example, the
      command above could also have been written this way:<br>我们在&nbsp;<span class="command"><strong>bjam</strong></span> 调用中曾经见过的 <code class="option">release</code> 和 <code class="option">debug</code> 不过是一个指定 <code class="varname">variant</code> 特性的缩写。例如，上述命令也可以写成：

      </p>
<pre class="screen">bjam variant=release inlining=off debug-symbols=on<br>      </pre>

<p>
    <code class="varname">variant</code> is so commonly-used that it has been given
      special status as an <em class="firstterm">implicit</em> feature—
      Boost.Build will deduce the its identity just from the name of one of its
      values.<br><code class="varname">variant</code> 是如此常用，所以它被给予了作为隐式特性的特殊状态 —
      Boost.Build 仅从它的值名就可以推断出它的身份。
    </p>
<p>
      A complete description of features can be found in <a class="xref" href="reference.html#bbv2.reference.features" title="Features and properties">the section called “Features and properties”</a>.<br>有关"特性"的完整说明，请见 <a class="xref" href="reference.html#bbv2.reference.features" title="Features and properties">“特性与属性”一节</a>。
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="bbv2.tutorial.properties.requirements"></a>Build Requests and Target Requirements 构建请求与目标要求</h4></div></div></div>
<p>
        The set of properties specified on the command line constitute
        a <em class="firstterm">build request</em>—a description of
        the desired properties for building the requested targets (or,
        if no targets were explicitly requested, the project in the
        current directory). The <span class="emphasis"><em>actual</em></span>
        properties used for building targets are typically a
        combination of the build request and properties derived from
        the project's <code class="filename">Jamroot</code> (and its other
        Jamfiles, as described in <a class="xref" href="tutorial.html#bbv2.tutorial.hierarchy" title="Project Hierarchies">the section called “Project Hierarchies”</a>). For example, the
        locations of <code class="computeroutput">#include</code>d header files are normally
        not specified on the command-line, but described in
        Jamfiles as <em class="firstterm">target
        requirements</em> and automatically combined with the
        build request for those targets. Multithread-enabled
        compilation is another example of a typical target
        requirement. The Jamfile fragment below
        illustrates how these requirements might be specified.<br>在命令行中指定的一组属性组成了 <em class="firstterm">构建请求</em> — 用于构建目标(或者，如果没有显式给定目标，即当前目录中的工程)的应有属性的说明。用于构建目标的<span class="emphasis"><em>实际</em></span>
       属性是构建请求和从工程的 <code class="filename">Jamroot</code> (及其它
        Jamfiles，如 <a class="xref" href="tutorial.html#bbv2.tutorial.hierarchy" title="Project Hierarchies">“工程层次”一节</a> 中所说的)继承得到的属性的合并。例如，<code class="computeroutput">#include</code>d 头文件的位置一般不在命令行中指定，却会在
        Jamfiles 中以 <em class="firstterm">目标要求</em> 描述，它会被自动与目标的构建请求合并。多线程编译是目标要求的另一个典型例子。以下 Jamfile 片段示范了这些要求可以如何指定：
      </p>
<pre class="programlisting">exe hello<br>    : hello.cpp<br>    : &lt;include&gt;boost &lt;threading&gt;multi<br>    ;<br></pre>
<p>
        When <code class="filename">hello</code> is built, the two requirements specified
        above will always be present. If the build request given on the
        <span class="command"><strong>bjam</strong></span> command-line explictly contradicts a target's
        requirements, the target requirements usually override (or, in the case
        of “free”” features like
        <code class="varname">&lt;include&gt;</code>,
        <sup>[<a name="id3900772" href="tutorial.html#ftn.id3900772" class="footnote">6</a>]</sup>
        augments) the build request.<br>当 <code class="filename">hello</code> 被构建，以上指定的两个要求总是会被应用。如果在
        <span class="command"><strong>bjam</strong></span> 命令行上给出的构建请求与某个目标要求相矛盾，则目标要求通常会覆盖(或者加入到，象
        <code class="varname">&lt;include&gt;</code> 这样的"自由"特性<sup>[<a name="id3900772" href="#ftn.id3900772" class="footnote">6</a>]</sup>&nbsp;)构建请求。
      </p>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top"><p>
          The value of the <code class="varname">&lt;include&gt;</code> feature is
          relative to the location of <code class="filename">Jamroot</code> where it is
          used.</p><p><code class="varname">&lt;include&gt;</code> 特性的值是相对于所用的 <code class="filename">Jamroot</code> 文件的位置的。
        </p></td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="bbv2.tutorial.properties.project_attributes"></a>Project Attributes 工程属性</h4></div></div></div>
<p>
        If we want the same requirements for our other target, <code class="filename">hello2
        </code>, we could simply duplicate them. However, as projects grow,
        that approach leads to a great deal of repeated boilerplate in Jamfiles.

        Fortunately, there's a better way. Each project can specify a set of
        <em class="firstterm">attributes</em>, including requirements:<br>如果我们对于另一个目标 <code class="filename">hello2</code>&nbsp;也有相同的要求，我们只需要复制它们就可以了。不过，随着工程的发展，这一方法会导致在 Jamfiles 中出现大量重复。幸好，我们有更好的方法。每个工程都可以指定一组 <em class="firstterm">属性attributes</em>，包括目标要求：

</p>
<pre class="programlisting">project<br>    : requirements &lt;include&gt;/home/ghost/Work/boost &lt;threading&gt;multi<br>    ;<br><br>exe hello : hello.cpp ;<br>exe hello2 : hello.cpp ;</pre>
<p>

        The effect would be as if we specified the same requirement for both
        <code class="filename">hello</code> and <code class="filename">hello2</code>.<br>其作用就象我们为
        <code class="filename">hello</code> 和 <code class="filename">hello2</code> 指定相同的目标要求一样。
      </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.hierarchy"></a>Project Hierarchies 工程层次</h3></div></div></div>
<p>
      So far we have only considered examples with one project —a. with
      one user-written Boost.Jam file, <code class="filename">Jamroot</code>). A typical
      large codebase would be composed of many projects organized into a tree.
      The top of the tree is called the <em class="firstterm">project root</em>.
      Every subproject is defined by a file called <code class="filename">Jamfile</code>
      in a descendant directory of the project root. The parent project of a
      subproject is defined by the nearest <code class="filename">Jamfile</code> or
      <code class="filename">Jamroot</code> file in an ancestor directory. For example,
      in the following directory layout:<br>迄今为止，我们只讨论了带有一个工程的例子 — 只带有一个用户编写的 Boost.Jam 文件 <code class="filename">Jamroot</code>。一个典型的大型代码基将包含许多工程，它们组成一棵树。树的顶端被称为 <em class="firstterm">工程的根</em>。每一个子工程由工程根的一个子目录中的名为 <code class="filename">Jamfile</code>
      的文件来定义。一个子工程的父工程由其父目录中最接近的 <code class="filename">Jamfile</code> 或
      <code class="filename">Jamroot</code> 文件来定义。例如，在以下目录布局中：

</p>
<pre class="screen">top/<br>  |<br>  +-- Jamroot<br>  |<br>  +-- app/<br>  |    |<br>  |    +-- Jamfile<br>  |    `-- app.cpp<br>  |<br>  `-- util/<br>       |<br>       +-- foo/<br>       .    |<br>       .    +-- Jamfile<br>       .    `-- bar.cpp<br></pre>
<p>

      the project root is <code class="filename">top/</code>. The projects in
      <code class="filename">top/app/</code> and <code class="filename">top/util/foo/</code> are
      immediate children of the root project.<br>工程的根是 <code class="filename">top/</code>. 在
      <code class="filename">top/app/</code> 和 <code class="filename">top/util/foo/</code> 中的工程根工程的直接子工程。

      </p>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 说明</th>
</tr>
<tr><td align="left" valign="top"><p>
          When we refer to a “Jamfile,” set in normal
          type, we mean a file called either
          <code class="filename">Jamfile</code> or
          <code class="filename">Jamroot</code>.  When we need to be more
          specific, the filename will be set as
          “<code class="filename">Jamfile</code>” or
          “<code class="filename">Jamroot</code>.”</p><p>当我们以普通方式使用 “Jamfile” 时，是指某个名为
          <code class="filename">Jamfile</code> 或
          <code class="filename">Jamroot</code> 的文件。当我们需要更明确时，则将文件名写为 “<code class="filename">Jamfile</code>” 或
          “<code class="filename">Jamroot</code>.”
        </p></td></tr>
</tbody></table></div>
<p>
    </p>
<p>
      Projects inherit all attributes (such as requirements)
      from their parents.  Inherited requirements are combined with
      any requirements specified by the subproject.
      For example, if <code class="filename">top/Jamroot</code> has<br>工程从它们的父工程继承所有属性(如目标要求)。继承的要求与子工程指定的要求相合并。例如，如果 <code class="filename">top/Jamroot</code>&nbsp;在目标要求中有：

</p>
<pre class="programlisting">&lt;include&gt;/home/ghost/local<br></pre>
<p>

      in its requirements, then all of its subprojects will have it
      in their requirements, too.  Of course, any project can add
      include paths to those specified by its parents. <sup>[<a name="id3901001" href="tutorial.html#ftn.id3901001" class="footnote">7</a>]</sup>
    More details can be found in
      <a class="xref" href="advanced.html#bbv2.advanced.projects" title="Projects">the section called “Projects”</a>.<br>则它的所有子工程也都具有这一要求。当然，任一工程都可以在父工程的基础上增加头文件包含路径<sup>[<a name="id3901001" href="#ftn.id3901001" class="footnote">7</a>]</sup>。更多的细节请见
      <a class="xref" href="advanced.html#bbv2.advanced.projects" title="Projects">“工程”一节</a>。
    </p>
<p>
      Invoking <span class="command"><strong>bjam</strong></span> without explicitly specifying
      any targets on the command line builds the project rooted in the
      current directory.  Building a project does not automatically
      cause its subprojects to be built unless the parent project's
      Jamfile explicitly requests it. In our example,
      <code class="filename">top/Jamroot</code> might contain:<br>在命令行不指定任何目标地调用 <span class="command"><strong>bjam</strong></span>，将构建当前目录中的工程。构建一个工程不会自动引起其子工程的构建，除非父工程的
      Jamfile 中明确要求。在我们的例子中，<code class="filename">top/Jamroot</code> 可能包含有：

</p>
<pre class="programlisting">build-project app ;<br></pre>
<p>

      which would cause the project in <code class="filename">top/app/</code>
      to be built whenever the project in <code class="filename">top/</code> is
      built. However, targets in <code class="filename">top/util/foo/</code>
      will be built only if they are needed by targets in
      <code class="filename">top/</code> or <code class="filename">top/app/</code>.<br>这将导致在构建 <code class="filename">top/</code> 中的工程时，构建 <code class="filename">top/app/</code>
      中的工程。但是，在 <code class="filename">top/util/foo/</code>
      中的目标则仅当被
      <code class="filename">top/</code> 或 <code class="filename">top/app/</code> 中的目标所需要时才构建。
    </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.libs"></a>Dependent Targets 依赖目标</h3></div></div></div>
<p>
      When a building a target <code class="filename">X</code> depends on first
      building another target <code class="filename">Y</code> (such as a
      library that must be linked with <em class="firstterm">X</em>),
      <code class="filename">Y</code> is called a
      <em class="firstterm">dependency</em> of <code class="filename">X</code> and
      <code class="filename">X</code> is termed a
      <em class="firstterm">dependent</em> of <code class="filename">Y</code>.&nbsp;<br>如果目标 <code class="filename">X</code> 的构建依赖于另一个目标 <code class="filename">Y</code> 的首先构建(如一个必须与 <em class="firstterm">X</em> 链接的库)，则
      <code class="filename">Y</code> 被称为 <code class="filename">X</code> 的
      <em class="firstterm">依赖物</em><code class="filename"></code>，<code class="filename">X</code> 则被称为 <em class="firstterm">依赖于</em> <code class="filename">Y</code>。
    </p>
<p>To get a feeling of target dependencies, let's continue the
      above example and see how <code class="filename">top/app/Jamfile</code> can
      use libraries from <code class="filename">top/util/foo</code>.  If
      <code class="filename">top/util/foo/Jamfile</code> contains<br>为了获得对目标依赖关系的感觉，我们来继续前面的例子，看看 <code class="filename">top/app/Jamfile</code> 可以如何使用来自于 <code class="filename">top/util/foo</code> 的库。如果
      <code class="filename">top/util/foo/Jamfile</code> 包含有：

</p>
<pre class="programlisting">lib bar : bar.cpp ;<br></pre>
<p>

      then to use this library in <code class="filename">top/app/Jamfile</code>, we can
      write:<br>我们要使用这个库，我们可以在 <code class="filename">top/app/Jamfile</code> 中写：

</p>
<pre class="programlisting">exe app : app.cpp ../util/foo//bar ;<br></pre>
<p>

      While <code class="computeroutput">app.cpp</code> refers to a regular source file,
      <code class="computeroutput">../util/foo//bar</code> is a reference to another target:
      a library <code class="filename">bar</code> declared in the Jamfile at
      <code class="filename">../util/foo</code>.<br>其中 <code class="computeroutput">app.cpp</code> 表示一个普通的源文件，<code class="computeroutput">../util/foo//bar</code> 则表示另一个目标：在
      <code class="filename">../util/foo</code> 的 Jamfile 中声明的 <code class="filename">bar</code> 库。
    </p>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top"><p>Some other build system have special syntax for listing dependent
      libraries, for example <code class="varname">LIBS</code> variable. In Boost.Build,
      you just add the library to the list of sources.<br>其它一些构建系统有特殊的语法来列出依赖库，例如 <code class="varname">LIBS</code> 变量。在 Boost.Build 中，你只需要将库增加到源的列表中。
      </p></td></tr>
</tbody></table></div>
<p>Suppose we build <code class="filename">app</code> with:<br>假设我们要构建 <code class="filename">app</code>：
    </p>
<pre class="screen">bjam app optimization=full define=USE_ASM<br>    </pre>
<p>
    Which properties will be used to build <code class="computeroutput">foo</code>? The answer is
    that some features are
    <em class="firstterm">propagated</em>—Boost.Build attempts to use
    dependencies with the same value of propagated features. The
    <code class="varname">&lt;optimization&gt;</code> feature is propagated, so both
    <code class="filename">app</code> and <code class="filename">foo</code> will be compiled
    with full optimization. But <code class="varname">&lt;define&gt;</code> is not
    propagated: its value will be added as-is to the compiler flags for
    <code class="filename">a.cpp</code>, but won't affect <code class="filename">foo</code>.<br>哪些属性会用来构建 <code class="computeroutput">foo</code> 呢? 答案是，有些特性是
    <em class="firstterm">被传播的 </em>— Boost.Build 尝试以被传播特性的相同值使用依赖物。特性
    <code class="varname">&lt;optimization&gt;</code> 就是被传播的，所以
    <code class="filename">app</code> 和 <code class="filename">foo</code> 都会以全优化方式编译。而 <code class="varname">&lt;define&gt;</code> 不是被传播的：它的值会被作为
    <code class="filename">a.cpp</code> 的一个编译选项加入，但不会影响 <code class="filename">foo</code>.
    </p>
<p>
      Let's improve this project further. The library probably has some headers
      that must be used when compiling <code class="filename">app.cpp</code>. We could
      manually add the necessary <code class="computeroutput">#include</code> paths to <code class="filename">app
      </code>'s requirements as values of the <code class="varname">&lt;include&gt;
      </code> feature, but then this work will be repeated for all programs
      that use <code class="filename">foo</code>. A better solution is to modify
      <code class="filename">util/foo/Jamfile</code> in this way:<br>让我们来改进一下这个工程。这个库可能有一些头文件在编译 <code class="filename">app.cpp</code> 时要使用。我们可以手工将所需的 <code class="computeroutput">#include</code> 路径作为 <code class="varname">&lt;include&gt;
      </code> 特性的值加到 <code class="filename">app </code>的要求中，但是这个工作稍后可能要对所有用到 <code class="filename">foo</code> 的程序都重复一次。一个更好的解决方法是，按以下方法修改 <code class="filename">util/foo/Jamfile</code>：

      </p>
<pre class="programlisting">project<br>    : usage-requirements &lt;include&gt;.<br>    ;<br><br>lib foo : foo.cpp ;</pre>
<p>

      Usage requirements are applied not to the target being declared but to its
      dependants. In this case, <code class="literal">&lt;include&gt;.</code> will be
      applied to all targets that directly depend on <code class="filename">foo</code>.<br>"用法要求"不是应用到被声明的目标上，而是应用到依赖于它的目标上。在这个例子中，<code class="literal">&lt;include&gt;</code> 将被应用到所有直接依赖于 <code class="filename">foo</code> 的目标上。
    </p>
<p>
      Another improvement is using symbolic identifiers to refer to the library,
      as opposed to <code class="filename">Jamfile</code> location. In a large project, a
      library can be used by many targets, and if they all use <code class="filename">Jamfile
      </code> location, a change in directory organization entails much
      work. The solution is to use project ids—symbolic names not tied to
      directory layout. First, we need to assign a project id by adding this
      code to <code class="filename">Jamroot</code>:<br>另一个改进是，使用符号标识符来表示一个库，而不是用 <code class="filename">Jamfile</code> 的位置。在一个大型工程中，一个库可以被多个目标使用，如果它们总是使用 <code class="filename">Jamfile </code>位置来表示，那么对目录组织的修改将会带来大量工作。解决方法是，使用工程 ids—符号名而不是依靠目录布局。首先，我们需要往 <code class="filename">Jamroot</code> 增加以下代码来赋值一个工程 id：
    </p>
<pre class="programlisting">use-project /library-example/foo : util/foo ;</pre>
<p>
      Second, we modify <code class="filename">app/Jamfile</code> to use the project id:<br>然后，我们修改 <code class="filename">app/Jamfile</code> 以使用这个工程 id:
      </p>
<pre class="programlisting">exe app : app.cpp /library-example/foo//bar ;</pre>
<p>

      The <code class="filename">/library-example/foo//bar</code> syntax is used to refer
      to the target <code class="filename">bar</code> in the project with id <code class="filename">
      /library-example/foo</code>. We've achieved our goal—if the
      library is moved to a different directory, only <code class="filename">Jamroot
      </code> must be modified. Note that project ids are global—two
      Jamfiles are not allowed to assign the same project id to different
      directories.<br>语法 <code class="filename">/library-example/foo//bar</code> 是用于在工程中以 id <code class="filename">
      /library-example/foo</code>&nbsp;表示目标 <code class="filename">bar</code>。我们已经实现了我们的目标—如果库被移动到其它目录，只需要修改 <code class="filename">Jamroot</code>。注意，工程 ids 是全局的—不允许两个
      Jamfiles 将相同的工程 id 赋给不同的目录。
    </p>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top">
<p>If you want all applications in some project to link to a certain
        library, you can avoid having to specify it directly the sources of
        every target by using the <code class="varname">&lt;library&gt;</code> property.
        For example, if <code class="filename">/boost/filesystem//fs</code> should be
        linked to all applications in your project, you can add
        <code class="computeroutput">&lt;library&gt;/boost/filesystem//fs</code> to the project's
        requirements, like this:</p><p>如果你想让一些工程中的所有应用程序都链接到某个特定的库，你可以无须直接在每个目标中使用 <code class="varname">&lt;library&gt;</code> 特性来指定它。例如，如果 <code class="filename">/boost/filesystem//fs</code> 要被链接到你的工程中的所有应用程序，你可以将
        <code class="computeroutput">&lt;library&gt;/boost/filesystem//fs</code> 加到工程的要求中，如下：
      </p>
<pre class="programlisting">project<br>   : requirements &lt;source&gt;/boost/filesystem//fs<br>   ;</pre>
</td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.testing"></a>Testing 测试</h3></div></div></div></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.linkage"></a>Static and shared libaries 静态库和共享库</h3></div></div></div>
<p>
      Libraries can be either <span class="emphasis"><em>static</em></span>, which means they are
      included in executable files that use them, or <span class="emphasis"><em>shared</em></span>
      (a.k.a. <span class="emphasis"><em>dynamic</em></span>), which are only referred to from
      executables, and must be available at run time. Boost.Build can create and
      use both kinds.<br>库可以是 <span class="emphasis"><em>静态的</em></span>，即被包含在使用它们的可执行文件中，或者是 <span class="emphasis"><em>共享的</em></span>
      (又称为 <span class="emphasis"><em>动态的</em></span>)，即在可执行文件中只有引用，在运行期才必须可用。对于这两种类型，Boost.Build 可以创建和使用。
    </p>
<p>
      The kind of library produced from a <code class="computeroutput">lib</code> target is determined
      by the value of the <code class="varname">link</code> feature. Default value is
      <code class="literal">shared</code>, and to build a static library, the value should
      be <code class="literal">static</code>. You can request a static build either on the
      command line:<br>一个 <code class="computeroutput">lib</code> 目标所产生的库的类型由特性 <code class="varname">link</code> 的值决定。缺省值是
      <code class="literal">shared</code>, 要构建一个静态库，则其值应为 <code class="literal">static</code>。你可以有两种方法请求构建一个静态库，在命令行上：
      </p>
<pre class="programlisting">bjam link=static</pre>
<p>或者在库的要求中：
      </p>
<pre class="programlisting">lib l : l.cpp : &lt;link&gt;static ;</pre>

<p>
    
      We can also use the <code class="varname">&lt;link&gt;</code> property to express
      linking requirements on a per-target basis. For example, if a particular
      executable can be correctly built only with the static version of a
      library, we can qualify the executable's <a class="link" href="reference.html#bbv2.reference.targets.references">target reference</a> to the
      library as follows:<br>我们也可以使用特性 <code class="varname">&lt;link&gt;</code> 来表示每个目标的链接要求。例如，如果某个可执行文件只能用某个库的静态版本来构建，我们可以限定可执行文件的 <a class="link" href="reference.html#bbv2.reference.targets.references">目标引用</a> 到这个库，如下：



      </p>
<pre class="programlisting">exe important : main.cpp helpers/&lt;link&gt;static ;</pre>
<p>

      No matter what arguments are specified on the <span class="command"><strong>bjam</strong></span>
      command line, <code class="filename">important</code> will only be linked with the
      static version of <code class="filename">helpers</code>.<br>无论在 <span class="command"><strong>bjam</strong></span>
      命令行中指定什么参数，<code class="filename">important</code> 都只会与 <code class="filename">helpers</code> 的静态版本链接。
    </p>
<p>
      Specifying properties in target references is especially useful if you use
      a library defined in some other project (one you can't change) but you
      still want static (or dynamic) linking to that library in all cases. If
      that library is used by many targets, you <span class="emphasis"><em>could</em></span> use
      target references everywhere:<br>如果你使用了一个在其它工程(一个你不能修改的工程)中定义的库，而你还是想在任何情况下都进行静态(或动态)链接，那么在目标要求中指定特性就非常有用了。如果那个库被多个目标使用，你可以在任意地方使用目标引用：

      </p>
<pre class="programlisting">exe e1 : e1.cpp /other_project//bar/&lt;link&gt;static ;<br>exe e10 : e10.cpp /other_project//bar/&lt;link&gt;static ;</pre>
<p>

      but that's far from being convenient. A better approach is to introduce a
      level of indirection. Create a local <span class="type">alias</span> target that refers
      to the static (or dynamic) version of <code class="filename">foo</code>:<br>但这样很不方便。更好的方法是引用一个间接层。创建一个局部别名目标来表示 <code class="filename">foo</code> 的静态(或动态)版本：

      </p>
<pre class="programlisting">alias foo : /other_project//bar/&lt;link&gt;static ;<br>exe e1 : e1.cpp foo ;<br>exe e10 : e10.cpp foo ;</pre>
<p>

      The <a class="link" href="tasks.html#bbv2.tasks.alias" title="Alias"><code class="computeroutput">alias</code>
      </a> rule is specifically used to rename a reference to a target and
      possibly change the properties.<br>规则 <a class="link" href="tasks.html#bbv2.tasks.alias" title="Alias"><code class="computeroutput">alias</code> </a>特别适用于修改一个目标引用的名字，也可以修改特性。

      
    </p>
<div class="tip"><table summary="Tip" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../doc/html/images/tip.png"></td>
<th align="left">Tip 提示</th>
</tr>
<tr><td align="left" valign="top">
<p>
        When one library uses another, you put the second library in the source
        list of the first. For example:<br>当一个库使用另一个库时，你要将第二个库放在第一个库的源列表中。例如：
        </p>
<pre class="programlisting">lib utils : utils.cpp /boost/filesystem//fs ;<br>lib core : core.cpp utils ;<br>exe app : app.cpp core ;</pre>
<p>
        This works no matter what kind of linking is used. When <code class="filename">core
        </code> is built as a shared library, it is linked directly into
        <code class="filename">utils</code>. Static libraries can't link to other
        libraries, so when <code class="filename">core</code> is built as a static
        library, its dependency on <code class="filename">utils</code> is passed along to
        <code class="filename">core</code>'s dependents, causing <code class="filename">app</code>
        to be linked with both <code class="filename">core</code> and <code class="filename">utils
        </code>.<br>无论使用哪种链接，这都可以。当 <code class="filename">core
        </code> 被构建为一个共享库时，它被直接链入到
        <code class="filename">utils</code> 中。静态库不能链接到其它库，所以当 <code class="filename">core</code> 被构建为静态库时，它对 <code class="filename">utils</code> 的依赖关系被传递到依赖于
        <code class="filename">core</code> 的目标，这使得 <code class="filename">app</code>
        同时与 <code class="filename">core</code> 和 <code class="filename">utils&nbsp;</code>链接。
      </p>
</td></tr>
</tbody></table></div>
<div class="note"><table summary="Note" border="0">
<tbody><tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note 说明</th>
</tr>
<tr><td align="left" valign="top"><p>
        (Note for non-UNIX system). Typically, shared libraries must be
        installed to a directory in the dynamic linker's search path. Otherwise,
        applications that use shared libraries can't be started. On Windows, the
        dynamic linker's search path is given by the <code class="envar">PATH</code>
        environment variable. This restriction is lifted when you use
        Boost.Build testing facilities—the <code class="envar">PATH</code> variable
        will be automatically adjusted before running the executable.<br>(对非-UNIX 系统的说明)。通常，共享库必须安装在动态链接器的查找路径中的目录下。否则，使用共享库的应用程序将不能启动。在 Windows 上，动态链接器的查找路径由环境变量 <code class="envar">PATH</code>
        给出。这一限制在你使用 Boost.Build 测试工具时会消失—变量 <code class="envar">PATH</code> 会在运行可执行程序前被自动调整。
        
      </p></td></tr>
</tbody></table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.conditions"></a>Conditions and alternatives 条件与选择</h3></div></div></div>
<p>
      Sometimes, particular relationships need to be maintained among a target's
      build properties. For example, you might want to set specific <code class="computeroutput">
      #define</code> when a library is built as shared, or when a target's
      <code class="computeroutput">release</code> variant is built. This can be achieved using
      <em class="firstterm">conditional requirements</em>.<br>有时候，某些特殊关系需要根据目标的构建属性来维护。例如，你可能想在某个库被构建为共享库时，或者在构建一个目标的&nbsp;<code class="computeroutput">release</code> 版本时，设置特定的 <code class="computeroutput">
      #define</code>。这可以通过
      <em class="firstterm">条件要求</em> 来实现。

      </p>
<pre class="programlisting">lib network : network.cpp<br>    : <span class="bold"><strong>&lt;link&gt;shared:&lt;define&gt;NEWORK_LIB_SHARED</strong></span>
     &lt;variant&gt;release:&lt;define&gt;EXTRA_FAST
    ;</pre>
<p>

      In the example above, whenever <code class="filename">network</code> is built with
      <code class="computeroutput">&lt;link&gt;shared</code>, <code class="computeroutput">&lt;define&gt;NEWORK_LIB_SHARED
      </code> will be in its properties, too. Also, whenever its release variant
      is built, <code class="computeroutput">&lt;define&gt;EXTRA_FAST</code> will appear in its
      properties.<br>在上例中，当 <code class="filename">network</code> 以
      <code class="computeroutput">&lt;link&gt;shared</code> 构建时，<code class="computeroutput">&lt;define&gt;NEWORK_LIB_SHARED
      </code> 将会在它的属性中。同样，当构建它的发布版本时，<code class="computeroutput">&lt;define&gt;EXTRA_FAST</code> 将会出现在它的属性中。
    </p>
<p>
      Sometimes the ways a target is built are so different that describing them
      using conditional requirements would be hard. For example, imagine that a
      library actually uses different source files depending on the toolset used
      to build it. We can express this situation using <em class="firstterm">target
      alternatives</em>:<br>有时候一个目标的构建方法差异很大，很难用条件要求来描述。例如，想象一个根据构建工具集不同而使用不同源文件的库。我们可以用 <em class="firstterm">目标选择</em> 来表示这种情形：
      </p>
<pre class="programlisting">lib demangler : dummy_demangler.cpp ;                      # alternative 1<br>lib demangler : demangler_gcc.cpp : &lt;toolset&gt;gcc ;   # alternative 2<br>lib demangler : demangler_msvc.cpp : &lt;toolset&gt;msvc ; # alternative 3</pre>
<p>
      When building <code class="filename">demangler</code>, Boost.Build will compare
      requirements for each alternative with build properties to find the best
      match. For example, when building with <code class="computeroutput">&lt;toolset&gt;gcc</code>
      alternative 2, will be selected, and when building with
      <code class="computeroutput">&lt;toolset&gt;msvc</code> alternative 3 will be selected. In all
      other cases, the most generic alternative 1 will be built.<br>在构建 <code class="filename">demangler</code> 时，Boost.Build 将每种选择与构建属性进行比较，找出最佳匹配。例如，在使用 <code class="computeroutput">&lt;toolset&gt;gcc</code>
      进行构建时，选择 alternative 2，而在使用
      <code class="computeroutput">&lt;toolset&gt;msvc</code> 进行构建时，则选择 alternative 3。在其它情况下，最通用的 alternative 1 将被构建。
    </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="bbv2.tutorial.prebuilt"></a>Prebuilt targets 预构建目标</h3></div></div></div>
<p>
      To link to libraries whose build instructions aren't given in a Jamfile,
      you need to create <code class="computeroutput">lib</code> targets with an appropriate
      <code class="varname">file</code> property.  Target alternatives can be used to
      associate multiple library files with a single conceptual target. For
      example:<br>要链接到那些构建指令没有在 Jamfile 中给定的库时，你需要以一个适当的&nbsp;<code class="varname">file</code> 属性创建 <code class="computeroutput">lib</code> 目标。可以使用目标选择来将多个库文件关联至一个概念上的目标。例如：
      </p>
<pre class="programlisting"># util/lib2/Jamfile<br>lib lib2<br>    :<br>    : &lt;file&gt;lib2_release.a &lt;variant&gt;release<br>    ;<br><br>lib lib2<br>    :<br>    : &lt;file&gt;lib2_debug.a &lt;variant&gt;debug<br>    ;</pre>
<p>

      This example defines two alternatives for <code class="filename">lib2</code>, and
      for each one names a prebuilt file.  Naturally, there are no sources.
      Instead, the <code class="varname">&lt;file&gt;</code> feature is used to specify
      the file name.<br>这个例子为 <code class="filename">lib2</code> 定义了两个选择，为每个分别指定预构建文件。这里自然是没有源文件的。而是使用 <code class="varname">&lt;file&gt;</code> 特性来指定文件名。
    </p>
<p>
      Once a prebuilt target has been declared, it can be used just like any
      other target:<br>一旦声明了一个预构建目标，它就可以象其它任意目标一样使用：

      </p>
<pre class="programlisting">exe app : app.cpp ../util/lib2//lib2 ;</pre>
<p>

      As with any target, the alternative selected depends on the properties
      propagated from <code class="filename">lib2</code>'s dependants. If we build the
      release and debug versions of <code class="filename">app</code> will be linked
      with <code class="filename">lib2_release.a</code> and <code class="filename">lib2_debug.a
      </code>, respectively.<br>和其它目标一样，目标的选择是根据从依赖于 <code class="filename">lib2</code> 的目标所传播来的属性进行的。如果我们构建 <code class="filename">app</code> 的发布版本和调试版本，则它们分别与 <code class="filename">lib2_release.a</code> 和 <code class="filename">lib2_debug.a
      </code>链接。
    </p>
<p>
      System libraries—those that are automatically found by the toolset
      by searching through some set of predetermined paths—should be
      declared almost like regular ones:<br>系统库—它们由工具集在一组预定义的路径中自动查找—应该象普通的库一样声明：

      </p>
<pre class="programlisting">lib pythonlib : : &lt;name&gt;python22 ;</pre>
<p>

      We again don't specify any sources, but give a <code class="varname">name</code>
      that should be passed to the compiler. If the gcc toolset were used to
      link an executable target to <code class="filename">pythonlib</code>,
      <code class="option">-lpython22</code> would appear in the command line (other
      compilers may use different options).<br>我们不用指定任何源文件，但是要给定一个传递给编译器的 <code class="varname">name</code>。如果使用 gcc 工具集来链接一个可执行目标到 <code class="filename">pythonlib</code>，则 <code class="option">-lpython22</code> 将出现在命令行中(其它编译器可能使用不同的选项)。
    </p>
<p>
      We can also specify where the toolset should look for the library:<br>我们也可以指定工具在哪里查找该库：

      </p>
<pre class="programlisting">lib pythonlib : : &lt;name&gt;python22 &lt;search&gt;/opt/lib ;</pre>
<p>

      And, of course, target alternatives can be used in the usual way:<br>当然还有，目标选择可以按普通方法使用：

      </p>
<pre class="programlisting">lib pythonlib : : &lt;name&gt;python22 &lt;variant&gt;release ;<br>lib pythonlib : : &lt;name&gt;python22_d &lt;variant&gt;debug ;</pre>

<p>
    
      A more advanced use of prebuilt targets is described in <a class="xref" href="faq.html#bbv2.recipies.site-config" title="Targets in site-config.jam">the section called “Targets in site-config.jam”</a>.<br>有关预构建目标的更进一步使用，在 <a class="xref" href="faq.html#bbv2.recipies.site-config" title="Targets in site-config.jam">“site-config.jam 中的目标”一节</a> 中说明。
    </p>
</div>
<div class="footnotes">
<br><hr align="left" width="100">
<div class="footnote"><p><sup>[<a name="ftn.id3900772" href="#id3900772" class="para">6</a>] </sup>
             See <a class="xref" href="reference.html#bbv2.reference.features.attributes" title="Feature Attributes">the section called “Feature Attributes”</a>&nbsp;<br>参见 <a class="xref" href="reference.html#bbv2.reference.features.attributes" title="Feature Attributes">“特性属性”一节</a>
          </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id3901001" href="#id3901001" class="para">7</a>] </sup>Many
      features will be overridden,
      rather than added-to, in subprojects.  See <a class="xref" href="reference.html#bbv2.reference.features.attributes" title="Feature Attributes">the section called “Feature Attributes”</a> for more
      information<br>在子工程中的许多特性都是覆写的，而不是增加的。更多信息请见 <a class="xref" href="reference.html#bbv2.reference.features.attributes" title="Feature Attributes">“特性属性”一节</a>。</p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer"></div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="installation.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../bbv2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="advanced.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
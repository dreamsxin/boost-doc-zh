<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Implementation Rationale</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../unordered.html" title="Chapter&nbsp;23.&nbsp;Boost.Unordered">
<link rel="prev" href="comparison.html" title="Comparison with Associative Containers">
<link rel="next" href="changes.html" title="Change Log"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="comparison.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="changes.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="unordered.rationale"></a><a class="link" href="rationale.html" title="Implementation Rationale"> Implementation Rationale 实现原理</a>
</h2></div></div></div>
<p>
      The intent of this library is to implement the unordered containers in the
      draft standard, so the interface was fixed. But there are still some implementation
      decisions to make. The priorities are conformance to the standard and portability.<br>本库的目的是实现标准草案中的无序容器，所以库的接口是固定的。不过还是做一些实现上的决定。首先是与标准的一致性和可移植性。
    </p>
<p>
      The <a href="http://en.wikipedia.org/wiki/Hash_table" target="_top">wikipedia article
      on hash tables</a> has a good summary of the implementation issues for
      hash tables in general.<br><a href="http://en.wikipedia.org/wiki/Hash_table" target="_top">wikipedia article
      on hash tables</a> 上有关于通常的散列表实现问题的一个很好的总结。
    </p>
<a name="unordered.rationale.data_structure"></a><h3>
<a name="id3751867"></a>
      <a class="link" href="rationale.html#unordered.rationale.data_structure">Data Structure 数据结构</a>
    </h3>
<p>
      By specifying an interface for accessing the buckets of the container the standard
      pretty much requires that the hash table uses chained addressing.<br>通过指定一个接口用于访问容器中的桶，标准几乎就是要求散列表使用链接法。
    </p>
<p>
      It would be conceivable to write a hash table that uses another method. For
      example, it could use open addressing, and use the lookup chain to act as a
      bucket but there are a some serious problems with this:<br>可以想象编写使用其它方法的散列表。例如，它可以使用开放法，并使用查找链来作为桶，不过这样会存在一些严重的问题：
    </p>
<div class="itemizedlist"><ul type="disc">
<li>
        The draft standard requires that pointers to elements aren't invalidated,
        so the elements can't be stored in one array, but will need a layer of indirection
        instead - losing the efficiency and most of the memory gain, the main advantages
        of open addressing.
        <br>标准草案要求指向元素的指针不可失效，所以元素不可以被存放在一个数组中，而是需要一个间接层 - 失去了效率和获得的大部分内存，这正是开放地址的主要优势。
      </li>
<li>
        Local iterators would be very inefficient and may not be able to meet the
        complexity requirements.<br>局部迭代器将会非常低效，可能无法满足复杂度的要求。
      </li>
<li>
        There are also the restrictions on when iterators can be invalidated. Since
        open addressing degrades badly when there are a high number of collisions
        the restrictions could prevent a rehash when it's really needed. The maximum
        load factor could be set to a fairly low value to work around this - but
        the standard requires that it is initially set to 1.0.<br>在迭代器可以失效时也会有限制。由于在存在大量冲突时，开放法会严重退化，而该限制会在需要时阻止重散列。可以通过将最大负载因子设为一个相当低的值来解决这个问题 - 但标准要求最大负载因子在初始时设为 1.0。
      </li>
<li>
        And since the standard is written with a eye towards chained addressing,
        users will be surprised if the performance doesn't reflect that.<br>而且由于标准在编写时是着眼于链接法的，如果最终的性能不能反映这一点，用户将会非常惊讶。
      </li>
</ul></div>
<p>
      So chained addressing is used.<br>所以我们使用了链接法。
    </p>
<p>
      For containers with unique keys I store the buckets in a single-linked list.
      There are other possible data structures (such as a double-linked list) that
      allow for some operations to be faster (such as erasing and iteration) but
      the possible gain seems small compared to the extra memory needed. The most
      commonly used operations (insertion and lookup) would not be improved at all.<br>对于唯一键的容器，我将桶保存在一个单链表中。有一些其它的数据结构(如双链表)可以使得某些操作更快(如删除和迭代)，不过可能的收益似乎比所需的额外内存开销要小。毕竟最常用的操作(插入和查找)并没有得到提升。
    </p>
<p>
      But for containers with equivalent keys a single-linked list can degrade badly
      when a large number of elements with equivalent keys are inserted. I think
      it's reasonable to assume that users who choose to use <code class="computeroutput"><span class="identifier">unordered_multiset</span></code>
      or <code class="computeroutput"><span class="identifier">unordered_multimap</span></code> do so
      because they are likely to insert elements with equivalent keys. So I have
      used an alternative data structure that doesn't degrade, at the expense of
      an extra pointer per node.<br>但对于非唯一键的容器，使用单链表会在插入大量相同键值的元素时性能严重退化。我认为，假设选择使用 <code class="computeroutput"><span class="identifier">unordered_multiset</span></code> 或 <code class="computeroutput"><span class="identifier">unordered_multimap</span></code> 的用户将很可能会插入相等键值的元素，这是很合理的。所以我对此种容器使用了另一种性能不会退化的数据结构，其代价是每个节点多用一个指针。
    </p>
<p>
      This works by adding storing a circular linked list for each group of equivalent
      nodes in reverse order. This allows quick navigation to the end of a group
      (since the first element points to the last) and can be quickly updated when
      elements are inserted or erased. The main disadvantage of this approach is
      some hairy code for erasing elements.<br>这是通过为每组相等的节点在相反顺序上增加一个循环的链表来实现的。这样可以快速地定位到该组节点的末尾(因为第一个元素指向最后一个)，并且在插入或删除元素时也可以快速更新。这种方法的主要缺点是删除元素的代码有点不太好看。
    </p>
<a name="unordered.rationale.number_of_buckets"></a><h3>
<a name="id3751995"></a>
      <a class="link" href="rationale.html#unordered.rationale.number_of_buckets">Number of Buckets 桶的数量</a>
    </h3>
<p>
      There are two popular methods for choosing the number of buckets in a hash
      table. One is to have a prime number of buckets, another is to use a power
      of 2.<br>有两种常见的方法来选择在散列表中的桶的数量。一种是让桶的数量为素数，另一种是使用2的幂数。
    </p>
<p>
      Using a prime number of buckets, and choosing a bucket by using the modulus
      of the hash function's result will usually give a good result. The downside
      is that the required modulus operation is fairly expensive.<br>使用素数个桶，并且通过对散列函数的结果取模来选择桶通常有不错的结果。缺点是模操作的代价有点高。
    </p>
<p>
      Using a power of 2 allows for much quicker selection of the bucket to use,
      but at the expense of loosing the upper bits of the hash value. For some specially
      designed hash functions it is possible to do this and still get a good result
      but as the containers can take arbitrary hash functions this can't be relied
      on.<br>使用2的幂则可以更快地选择要用的桶，但是它的代价是损失了散列值的高位信息。对于一些特殊设计的散列函数，这样是可以的，并且结果也还不错，但是考虑到容器可能使用任意的散列函数，所以不能依赖于它。
    </p>
<p>
    
To avoid this a transformation could be applied to the hash function, for an
      example see <a href="http://www.concentric.net/%7ETtwang/tech/inthash.htm" target="_top">Thomas
      Wang's article on integer hash functions</a>. Unfortunately, a transformation
      like Wang's requires knowledge of the number of bits in the hash value, so
      it isn't portable enough. This leaves more expensive methods, such as Knuth's
      Multiplicative Method (mentioned in Wang's article). These don't tend to work
      as well as taking the modulus of a prime, and the extra computation required
      might negate efficiency advantage of power of 2 hash tables.<br>为了避免这个问题，可以对散列函数进行一个转换，有关例子请见 <a href="http://www.concentric.net/%7ETtwang/tech/inthash.htm" target="_top">Thomas
      Wang 关于整数散列函数的论文</a>。
不幸，象 Wang 所给出的转换方法要求知道散列值中的二进制位数，所以它的可移植性不够。还有一些更昂贵的方法，如 Knuth 的相乘法(在
Wang 的论文中提及)。它们和对素数取模一样不太好用，而且所需的额外计算可能还会消除2的幂的散列表所带来的性能优势。 </p>
<p>
      So, this implementation uses a prime number for the hash table size.<br>所以，我们实现使用素数作为散列表的大小。
    </p>
<a name="unordered.rationale.equality_operators"></a><h3>
<a name="id3752063"></a>
      <a class="link" href="rationale.html#unordered.rationale.equality_operators">Equality operators 相等操作符</a>
    </h3>
<p>
      <code class="computeroutput"><span class="keyword">operator</span><span class="special">==</span></code>
      and <code class="computeroutput"><span class="keyword">operator</span><span class="special">!=</span></code>
      are not included in the standard, but I've added them as I think they could
      be useful and can be efficiently implemented. They are specified differently
      to the standard associative containers, comparing keys using the equality predicate
      rather than <code class="computeroutput"><span class="keyword">operator</span><span class="special">==</span></code>.
      This is inconsistent with the other containers but it is probably closer to
      user's expectations.<br><code class="computeroutput"><span class="keyword">operator</span><span class="special">==</span></code> 和 <code class="computeroutput"><span class="keyword">operator</span><span class="special">!=</span></code>
      并没有包含在标准中，不过我把它们加了进来，因为我认为它们可能是有用的，也可以高效地实现。它们与标准关联式容器是非常不同的，对键值的比较是使用等同性谓词而不是 <code class="computeroutput"><span class="keyword">operator</span><span class="special">==</span></code> 的。这一点与其它容器是不一致的，但是它可能更接近于用户的期待。
    </p>
<a name="unordered.rationale.active_issues_and_proposals"></a><h3>
<a name="id3752135"></a>
      <a class="link" href="rationale.html#unordered.rationale.active_issues_and_proposals">Active Issues
      and Proposals 活跃的问题与建议</a>
    </h3>
<a name="unordered.rationale.removing_unused_allocator_functions"></a><h4>
<a name="id3752156"></a>
      <a class="link" href="rationale.html#unordered.rationale.removing_unused_allocator_functions">Removing
      unused allocator functions 删除无用的分配器函数</a>
    </h4>
<p>
      In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html" target="_top">N2257,
      removing unused allocator functions</a>, Matt Austern suggests removing
      the <code class="computeroutput"><span class="identifier">construct</span></code>, <code class="computeroutput"><span class="identifier">destroy</span></code> and <code class="computeroutput"><span class="identifier">address</span></code>
      member functions - all of which Boost.Unordered calls. Changing this will simplify
      the implementation, as well as make supporting <code class="computeroutput"><span class="identifier">emplace</span></code>
      easier, but means that the containers won't support allocators which require
      these methods to be called. Detlef Vollmann opposed this change in <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2339.htm" target="_top">N2339</a>.<br>在&nbsp;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html" target="_top">N2257,
      删除无用的分配器函数</a> 一文中，Matt Austern 建议删除 <code class="computeroutput"><span class="identifier">construct</span></code>, <code class="computeroutput"><span class="identifier">destroy</span></code> 和 <code class="computeroutput"><span class="identifier">address</span></code> 成员函数 - 它们都是 Boost.Unordered 调用的。这个修改将简化实现，并可以更容易地支持 <code class="computeroutput"><span class="identifier">emplace</span></code>，但是将意味着容器不支持分配器，因为分配器要调用这些方法。Detlef Vollmann 在 <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2339.htm" target="_top">N2339</a> 中反对了这个修改。
    </p>
<a name="unordered.rationale.swapping_containers_with_unequal_allocators"></a><h4>
<a name="id3752239"></a>
      <a class="link" href="rationale.html#unordered.rationale.swapping_containers_with_unequal_allocators">Swapping
      containers with unequal allocators 交换具有不同分配器的容器</a>
    </h4>
<p>
      It isn't clear how to swap containers when their allocators aren't equal. This
      is <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#431" target="_top">Issue
      431: Swapping containers with unequal allocators</a>.<br>如果交换具有不同分配器的容器，这一点还不清楚。这正是 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#431" target="_top">Issue
      431: 交换具有不同分配器的容器</a>。
    </p>
<p>
      Howard Hinnant wrote about this in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html" target="_top">N1599</a>
      and suggested swapping both the allocators and the containers' contents. But
      the committee have now decided that <code class="computeroutput"><span class="identifier">swap</span></code>
      should do a fast swap if the allocator is Swappable and a slow swap using copy
      construction otherwise. To make this distinction requires concepts.<br>Howard Hinnant 在 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1599.html" target="_top">N1599</a>
      中写到了这个问题，并建议同时交换分配器和容器中的内容。但是委员会当前的决定是，如果分配器是可交换的则 <code class="computeroutput"><span class="identifier">swap</span></code>
      应进行快速的交换，否则使用复制构造来进行慢速的交换。要实现这一区分需要用到概念。
    </p>
<p>
      In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2387.pdf" target="_top">N2387,
      Omnibus Allocator Fix-up Proposals</a>, Pablo Halpern suggests that there
      are actually two distinct allocator models, "Moves with Value" and
      "Scoped" which behave differently:<br>在 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2387.pdf" target="_top">N2387,
      多项分配器修正的建议书</a> 中，Pablo Halpern 建议区分两种分配器模型，"Moves with Value" 和
      "Scoped"，它们的行为有以下差异：
    </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
        </p>

<p>
          When allocators are allowed to have state, it is necessary to have a model
          for determining from where an object obtains its allocator. We’ve identified
          two such models: the “Moves with Value” allocator model and the “Scoped”
          allocator model.<br>如果分配器允许具有状态，则需要有一个模型来判断一个对象从何处得到它的分配器。我们已经确定两种此类模型：“Moves with Value” 分配器模型和 “Scoped”
          分配器模型。
        </p>

<p>
          In the “Moves with Value” allocator model, the copy constructor of
          an allocator-aware class will copy both the value and the allocator from
          its argument. This is the model specified in the C++03 standard. With this
          model, inserting an object into a container usually causes the new container
          item to copy the allocator from the object that was inserted. This model
          can be useful in special circumstances, e.g., if the items within a container
          use an allocator that is specially tuned to the item’s type.<br>在
“Moves with Value” 分配器模型中，一个带分配器的类的复制构造函数应从它的参数中同时复制对象的值和分配器。这是在 C++03
标准中指定的模型。使用此模型，插入一个对象到容器中通常会导致容器中的新元素从被插入对象中复制分配器。这种模型基特定环境下有用，例如，如果容器中的
元素使用了一个为该元素类型特定调整的分配器。</p>

<p>
          In the “Scoped” allocator model, the allocator used to construct an
          object is determined by the context of that object, much like a storage
          class. With this model, inserting an object into a container causes the
          new container item to use the same allocator as the container. To avoid
          allocators being used in the wrong context, the allocator is never copied
          during copy or move construction. Thus, it is possible using this model
          to use allocators based on short-lived resources without fear that an object
          will transfer its allocator to a copy that might outlive the (shared) allocator
          resource. This model is reasonably safe and generally useful on a large
          scale. There was strong support in the 2005 Tremblant meeting for pursuing
          an allocator model that propagates allocators from container to contained
          objects.<br>在
“Scoped”
分配器模型中，用于构造一个对象的分配器是由对象的上下文来决定的，很可能是一个存储类。使用此模型，手稿一个对象到容器中，将导致容器中的新元素使用与
容器相同的分配器。为避免分配器被用于错误的上下文中，分配器在复制或移动构造时从不进行复制。因此，可以将此模型用于在短期资源上的分配器，而不需要担
心一个对象会将它的分配器传给一个可能比(共享)分配器资源长命的拷贝。这种模型相当安全，通常用于较大的规模。在 2005 Tremblant
会议上，有人大力支持推行一种分配器模型，即由容器将分配器传播给所包含的对象。</p>
</blockquote></div>
<p>
      With these models the choice becomes clearer:<br>对于这些模型，选择变得更清晰了：
    </p>
<div class="blockquote"><blockquote class="blockquote">


<p>
        </p><p>
          I introduced the “Moves with Value” allocator model and the “Scoped”
          allocator model. In the former case, the allocator is copied when the container
          is copy-constructed. In the latter case it is not. Swapping the allocators
          is the right thing to do if the containers conform to the “Moves with
          Value” allocator model and absolutely the wrong thing to do if the containers
          conform to the “Scoped” allocator model. With the two allocator models
          well-defined, the desired behavior becomes clear.<br>我已经介绍了 “Moves with Value” 分配器模型玫 “Scoped”
          分配器模型。在前一种情况下，当容器被复制构造时，分配器会被复制。而在后一种情况下则不会。如果容器符合 “Moves with
          Value” 分配器模型，则正确的方式是交换分配器，但如果容器符合 “Scoped” 分配器模型，这样做就绝对是错误的。两种分配器模型具有良好的定义，想得到的行为也变得清楚了。
        </p><p>
      </p>
</blockquote></div>
<p>
      The proposal is that allocators are swapped if the allocator follows the "Moves
      with Value" model and the allocator is swappable. Otherwise a slow swap
      is used. Since containers currently only support the "Moves with Value"
      model this is consistent with the committee's current recommendation (although
      it suggests using a trait to detect if the allocator is swappable rather than
      a concept).<br>建议是，如果分配器符合 "Moves
      with Value" 模型且分配器是可交换的，则应交换分配器。否则使用慢交换。由于当前的容器只支持 "Moves with Value"
      模型，这就和委员会当前的推荐是一致的(虽然它建议使用 trait 而不是概念来检查分配器是否可交换)。
    </p>
<p>
      Since there is currently neither have a swappable trait or concept for allocators
      this implementation always performs a slow swap.<br>由于当前对于分配器还没有一个'可交换' trait 或概念，所以这个实现总是执行慢交换。
    </p>
<a name="unordered.rationale.are_insert_and_erase_stable_for_unordered_multiset_and_unordered_multimap_"></a><h4>
<a name="id3752423"></a>
      <a class="link" href="rationale.html#unordered.rationale.are_insert_and_erase_stable_for_unordered_multiset_and_unordered_multimap_">Are
      insert and erase stable for unordered_multiset and unordered_multimap?&nbsp;</a></h4><h4><a class="link" href="rationale.html#unordered.rationale.are_insert_and_erase_stable_for_unordered_multiset_and_unordered_multimap_">对于 unordered_multiset 和 unordered_multimap 来说，插入和删除是稳定的吗？</a>
    </h4>
<p>
      It is not specified if <code class="computeroutput"><span class="identifier">unordered_multiset</span></code>
      and <code class="computeroutput"><span class="identifier">unordered_multimap</span></code> preserve
      the order of elements with equivalent keys (i.e. if they're stable under <code class="computeroutput"><span class="identifier">insert</span></code> and <code class="computeroutput"><span class="identifier">erase</span></code>).
      This is <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#518" target="_top">issue
      581</a>. The current proposal is that insert, erase and rehash are stable
      - so they are here. (Update: during the release of this version, this requirement
      was added to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf" target="_top">the
      lastest working draft</a>).<br>没有规定 <code class="computeroutput"><span class="identifier">unordered_multiset</span></code> 和 <code class="computeroutput"><span class="identifier">unordered_multimap</span></code> 是否要保持相等键值元素的顺序(即在 <code class="computeroutput"><span class="identifier">insert</span></code> 和 <code class="computeroutput"><span class="identifier">erase</span></code> 时它们是否稳定)。这是 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#518" target="_top">issue
      581</a>。当前的建议是，插入、删除和重散列都应是稳定的
      - 所以它们就是这样的。(更新：在这个版本发布期间，这一要求被加入到 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf" target="_top">最后工作草案</a>)。
    </p>
<a name="unordered.rationale.const_local_iterator_cbegin__cend_missing_from_tr1"></a><h4>
<a name="id3752507"></a>
      <a class="link" href="rationale.html#unordered.rationale.const_local_iterator_cbegin__cend_missing_from_tr1">const_local_iterator
      cbegin, cend missing from TR1&nbsp;</a></h4><h4><a class="link" href="rationale.html#unordered.rationale.const_local_iterator_cbegin__cend_missing_from_tr1">TR1中缺少 const_local_iterator
      cbegin, cend</a></h4>
<p>
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2684.html#691" target="_top">Issue
      691</a> is that <code class="computeroutput"><span class="identifier">cbegin</span></code>
      and <code class="computeroutput"><span class="identifier">cend</span></code> are missing for local
      iterators. The current resolution is that they'll be added, so I've added them.<br><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2684.html#691" target="_top">Issue
      691</a> 是，对于局部迭代器缺少 <code class="computeroutput"><span class="identifier">cbegin</span></code> 和 <code class="computeroutput"><span class="identifier">cend</span></code>。当前的决定是要加入它们，所以我已经加了。
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2003, 2004 Jeremy B. Maitin-Shepard<br>Copyright © 2005-2008 Daniel
      James<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="comparison.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="changes.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Tutorial</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../signals2.html" title="Chapter 17. Boost.Signals2">
<link rel="prev" href="../signals2.html" title="Chapter 17. Boost.Signals2">
<link rel="next" href="examples.html" title="Example programs"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../signals2.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../signals2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="examples.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">

<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="signals2.tutorial"></a>Tutorial</h2></div></div></div>

<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="signals2.tutorial"></a>教程</h2></div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id3351397">How to Read this Tutorial</a></span></dt><dt><span class="section"><a href="tutorial.html#id3351478">Hello, World! (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3351586">Calling Multiple Slots</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3351941">Passing Values to and from Slots</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352571">Connection Management</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.document-view">Example: Document-View</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.extended-slot-type">Giving a Slot Access to its Connection (Advanced)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.signal-mutex-template-parameter">Changing the Mutex Type of a Signal (Advanced).</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3353969">Linking against the Signals2 library</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#terms20090605">术语表</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3351397">如何阅读本教程</a></span></dt><dt><span class="section"><a href="tutorial.html#id3351478">Hello, World! （初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3351586">调用多个插槽</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3351941">传值到插槽及回传</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352571">连接管理</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.document-view">例子：文档-视图</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.extended-slot-type">让插槽可以操作其连接（高级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.signal-mutex-template-parameter">改变信号的互斥体类型（高级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3353969">链接 Signals2 库</a></span></dt>
</dl></div>

<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="terms20090605"></a>术语表</h3>
</div></div></div>

<table border="1" cellpadding="2">
<tbody><tr><th>英文</th> <th>中文</th> <th>注释</th></tr>

<tr><td>block</td><td>阻塞</td><td>&nbsp;</td></tr>
<tr><td>combiner</td><td>合并器</td><td>&nbsp;</td></tr>
<tr><td>compatibility form</td><td>兼容形式</td><td>&nbsp;</td></tr>
<tr><td>concept</td><td>概念</td><td>&nbsp;</td></tr>
<tr><td>connect</td><td>连接</td><td>&nbsp;</td></tr>
<tr><td>connection</td><td>连接</td><td>&nbsp;</td></tr>
<tr><td>disconnect</td><td>断开</td><td>&nbsp;</td></tr>
<tr><td>metafunction</td><td>元函数</td><td>&nbsp;</td></tr>
<tr><td>mutex</td><td>互斥体</td><td>&nbsp;</td></tr>
<tr><td>mutex class</td><td>互斥类</td><td>&nbsp;</td></tr>
<tr><td>portable syntax</td><td>兼容句法</td><td>可移植句法</td></tr>
<tr><td>preferred form</td><td>首选形式</td><td>&nbsp;</td></tr>
<tr><td>preferred syntax</td><td>首选句法</td><td>&nbsp;</td></tr>
<tr><td>scoped</td><td>域内的</td><td>作用域内的</td></tr>
<tr><td>signal</td><td>信号</td><td>&nbsp;</td></tr>
<tr><td>slot</td><td>插槽</td><td>&nbsp;</td></tr>

</tbody></table>
</div>

<div class="section" lang="en">

<div class="titlepage"><div><div><h3 class="title">
<a name="id3351397"></a>How to Read this Tutorial</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="id3351397"></a>如何阅读本教程</h3></div></div></div>

<p>This tutorial is not meant to be read linearly. Its top-level
structure roughly separates different concepts in the library
(e.g., handling calling multiple slots, passing values to and from
slots) and in each of these concepts the basic ideas are presented
first and then more complex uses of the library are described
later. Each of the sections is marked <span class="emphasis"><em>Beginner</em></span>,
<span class="emphasis"><em>Intermediate</em></span>, or <span class="emphasis"><em>Advanced</em></span> to help guide the
reader. The <span class="emphasis"><em>Beginner</em></span> sections include information that all
library users should know; one can make good use of the Signals2
library after having read only the <span class="emphasis"><em>Beginner</em></span> sections. The
<span class="emphasis"><em>Intermediate</em></span> sections build on the <span class="emphasis"><em>Beginner</em></span>
sections with slightly more complex uses of the library. Finally,
the <span class="emphasis"><em>Advanced</em></span> sections detail very advanced uses of the
Signals2 library, that often require a solid working knowledge of
the <span class="emphasis"><em>Beginner</em></span> and <span class="emphasis"><em>Intermediate</em></span> topics; most users
will not need to read the <span class="emphasis"><em>Advanced</em></span> sections.</p>

<p>
本教程不是用来线性阅读的。

其顶层结构大致按库中不同的概念划分，（如处理多个插槽的调用、传值到插槽及回传），并且在每一个概念中，首先介绍其基本思想，然后说明库较复杂的使用。

每个部分都标注了<span class="emphasis"><em>初级</em></span>、
<span class="emphasis"><em>中级</em></span>，或<span class="emphasis"><em>高级</em></span>，以帮助指导读者。

<span class="emphasis"><em>初级</em></span>部分包括库的所有使用者都该了解的信息；只要阅读了<span class="emphasis"><em>初级</em></span>部分，就可以很好地使用 Signals2 库。

<span class="emphasis"><em>中级</em></span>部分建立在<span class="emphasis"><em>初级</em></span>
部分之上，是库的稍复杂的使用。

最后，<span class="emphasis"><em>高级</em></span>部分详述了 Signals2 库很高级的应用，这往往需要对<span class="emphasis"><em>初级</em></span>和<span class="emphasis"><em>中级</em></span>内容扎实的实践经验；
大多数用户无需阅读<span class="emphasis"><em>高级</em></span>部分。</p></div><div class="section" lang="en">

<div class="titlepage"><div><div><h3 class="title">
<a name="id3351478"></a>Hello, World! (Beginner)</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="id3351478"></a>Hello, World! （初级）</h3></div></div></div>

<p>The following example writes "Hello, World!" using signals and
slots. First, we create a signal <code class="computeroutput">sig</code>, a signal that
takes no arguments and has a void return value. Next, we connect
the <code class="computeroutput">hello</code> function object to the signal using the
<code class="computeroutput">connect</code> method. Finally, use the signal
<code class="computeroutput">sig</code> like a function to call the slots, which in turns
invokes <code class="computeroutput">HelloWorld::operator()</code> to print "Hello,
World!".</p>

<p>下例将使用信号和插槽写出“Hello, World!”。

首先，我们创建信号 <code class="computeroutput">sig</code>，该信号无参数并且返回值为空。

接着，我们使用 <code class="computeroutput">connect</code> 
方法将 <code class="computeroutput">hello</code>
函数对象连接到信号。

最后，像函数一样使用信号
<code class="computeroutput">sig</code>
来调用插槽，
它将转而调用 <code class="computeroutput">HelloWorld::operator()</code>
打印“Hello, World!”。
</p>

<pre class="programlisting"><code class="computeroutput">struct HelloWorld<br>{<br>  void operator()() const<br>  {<br>    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;<br>  }<br>};<br></code></pre>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><code class="computeroutput">  // Signal with no arguments and a void return value<br>  boost::signals2::signal&lt;void ()&gt; sig;<br><br>  // Connect a HelloWorld slot<br>  HelloWorld hello;<br>  sig.connect(hello);<br><br>  // Call all of the slots<br>  sig();<br></code></pre>
</td>

</tr></tbody>
</table></div>
</div>

<div class="section" lang="en">

<div class="titlepage"><div><div><h3 class="title">
<a name="id3351586"></a>Calling Multiple Slots</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="id3351586"></a>调用多个插槽</h3></div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id3351590">Connecting Multiple Slots (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3351728">Ordering Slot Call Groups (Intermediate)</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id3351590">连接多个插槽（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3351728">插槽调用组排序（中级）</a></span></dt>
</dl></div>

<div class="section" lang="en">

<div class="titlepage"><div><div><h4 class="title">
<a name="id3351590"></a>Connecting Multiple Slots (Beginner)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3351590"></a>连接多个插槽（初级）</h4></div></div></div>

<p>Calling a single slot from a signal isn't very interesting, so
we can make the Hello, World program more interesting by splitting
the work of printing "Hello, World!" into two completely separate
slots. The first slot will print "Hello" and may look like
this:</p>

<p>从信号调用单个插槽不是很有意思，
因此我们将打印“Hello, World!”的工作拆分到两个完全独立的插槽，
让 Hello, World 程序更有趣点。

第一个插槽将打印“Hello”，可能看起来像这样：</p>

<pre class="programlisting"><code class="computeroutput">struct Hello<br>{<br>  void operator()() const<br>  {<br>    std::cout &lt;&lt; "Hello";<br>  }<br>};<br></code></pre>

<p>The second slot will print ", World!" and a newline, to complete
the program. The second slot may look like this:</p>

<p>第二个插槽将打印“, World!”和换行，以完成该程序。
第二个插槽可能看起来像这样：</p>

<pre class="programlisting"><code class="computeroutput">struct World<br>{<br>  void operator()() const<br>  {<br>    std::cout &lt;&lt; ", World!" &lt;&lt; std::endl;<br>  }<br>};<br></code></pre>
<p>Like in our previous example, we can create a signal
<code class="computeroutput">sig</code> that takes no arguments and has a
<code class="computeroutput">void</code> return value. This time, we connect both a
<code class="computeroutput">hello</code> and a <code class="computeroutput">world</code> slot to the same
signal, and when we call the signal both slots will be called.</p>

<p>和上个例子一样，我们创建信号
<code class="computeroutput">sig</code>，
它没有参数并且返回值为
<code class="computeroutput">void</code>。

这次，我们将
<code class="computeroutput">hello</code>
和 <code class="computeroutput">world</code>
插槽都连接到同一个信号，
当我们调用该信号，两个插槽都将会被调用。
</p>

<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><code class="computeroutput">  boost::signals2::signal&lt;void ()&gt; sig;<br><br>  sig.connect(Hello());<br>  sig.connect(World());<br><br>  sig();<br></code></pre>
          </td>

</tr></tbody>
</table></div>
<p>By default, slots are pushed onto the back of the slot list,
so the output of this program will be as expected:</p>

<p>默认情况下，插槽会被加到插槽链表的尾部，
因此该程序的输出应该是：
</p>

<pre class="programlisting">Hello, World!<br></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3351728"></a>Ordering Slot Call Groups (Intermediate)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3351728"></a>插槽调用组排序（中级）</h4></div></div></div>

<p>Slots are free to have side effects, and that can mean that some
slots will have to be called before others even if they are not connected in that order. The Boost.Signals2
library allows slots to be placed into groups that are ordered in
some way. For our Hello, World program, we want "Hello" to be
printed before ", World!", so we put "Hello" into a group that must
be executed before the group that ", World!" is in. To do this, we
can supply an extra parameter at the beginning of the
<code class="computeroutput">connect</code> call that specifies the group. Group values
are, by default, <code class="computeroutput">int</code>s, and are ordered by the integer
&lt; relation. Here's how we construct Hello, World:</p>

<p>插槽可以有副作用，这意味着某些插槽必须在另一些之前调用，即使它们不是按那个次序连接的。

Boost.Signals2 库允许插槽进行分组，并按某种方式排序编组。

对于我们的 Hello, World 程序，我们要“Hello”在“, World!”之前打印，
所以我们将“Hello”放入一个组，该组将在“, World!”所在组之前执行。

为了做到这一点，我们可以在
<code class="computeroutput">connect</code>
调用的头部提供一个额外的参数，以指定编组。

编组值默认为
<code class="computeroutput">int</code>，
并按整型的 &lt; 关系排序。

我们这样构造 Hello, World：
</p>

<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><code class="computeroutput">  boost::signals2::signal&lt;void ()&gt; sig;<br><br>  sig.connect(1, World());  // connect with group 1<br>  sig.connect(0, Hello());  // connect with group 0<br></code></pre>
</td>

</tr></tbody>
</table></div>
<p>Invoking the signal will correctly print "Hello, World!", because the
<code class="computeroutput">Hello</code> object is in group 0, which precedes group 1 where
the <code class="computeroutput">World</code> object resides. The group
parameter is, in fact, optional. We omitted it in the first Hello,
World example because it was unnecessary when all of the slots are
independent. So what happens if we mix calls to connect that use the
group parameter and those that don't? The "unnamed" slots (i.e., those
that have been connected without specifying a group name) can be
placed at the front or back of the slot list (by passing
<code class="computeroutput">boost::signals2::at_front</code> or <code class="computeroutput">boost::signals2::at_back</code>
as the last parameter to <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1284885-bb">connect</a></code>, respectively),
and default to the end of the list. When
a group is specified, the final <code class="computeroutput">at_front</code> or <code class="computeroutput">at_back</code>
parameter describes where the slot
will be placed within the group ordering.  Ungrouped slots connected with
<code class="computeroutput">at_front</code> will always precede all grouped slots.  Ungrouped
slots connected with <code class="computeroutput">at_back</code> will always succeed all
grouped slots.
</p>

<p>调用该信号将正确打印出“Hello, World!”，因为
<code class="computeroutput">Hello</code> 对象在组 0，它在
<code class="computeroutput">World</code> 对象所在的组 1 之前。

编组参数实际上是可选的。
在第一个 Hello World 例子中我们省略了它，
因为当所有的插槽都独立时，编组是不必要的。

那么，如果我们混合调用使用和不使用编组参数的连接会怎样？
“未命名”插槽（即那些连接时未指定组名的插槽）可置于插槽链表的头部或尾部
（通过向
<code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1284885-bb">connect</a></code>
分别传入
<code class="computeroutput">boost::signals2::at_front</code> 或
<code class="computeroutput">boost::signals2::at_back</code>
作为最后的参数），
而默认为链表的结尾。

当指定了编组时，最后的参数
<code class="computeroutput">at_front</code> 或
<code class="computeroutput">at_back</code>
描述的是插槽在组内的次序。

以 <code class="computeroutput">at_front</code> 连接的未分组的插槽将总是在所有分组的插槽之前。
以 <code class="computeroutput">at_back</code> 连接的未分组的插槽将总是在所有分组的插槽之后。
</p>

<p>
  If we add a new slot to our example like this:
</p>

<p>
如果在我们的例子中添加新的插槽，如下：
</p>

<pre class="programlisting"><code class="computeroutput">struct GoodMorning<br>{<br>  void operator()() const<br>  {<br>    std::cout &lt;&lt; "... and good morning!" &lt;&lt; std::endl;<br>  }<br>};<br></code></pre>
<pre class="programlisting"><code class="computeroutput">  // by default slots are connected at the end of the slot list<br>  sig.connect(GoodMorning());<br><br>  // slots are invoked this order:<br>  // 1) ungrouped slots connected with boost::signals2::at_front<br>  // 2) grouped slots according to ordering of their groups<br>  // 3) ungrouped slots connected with boost::signals2::at_back<br>  sig();<br></code></pre>
<p>... we will get the result we wanted:</p>

<p>……我们会得到想要的结果：</p>

<pre class="programlisting">Hello, World!<br>... and good morning!<br></pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id3351941"></a>Passing Values to and from Slots</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="id3351941"></a>传值到插槽及回传</h3></div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id3351946">Slot Arguments (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352101">Signal Return Values (Advanced)</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id3351946">插槽的参数（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352101">信号的返回值（高级）</a></span></dt>
</dl></div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3351946"></a>Slot Arguments (Beginner)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3351946"></a>插槽的参数（初级）</h4></div></div></div>

<p>Signals can propagate arguments to each of the slots they call.
For instance, a signal that propagates mouse motion events might
want to pass along the new mouse coordinates and whether the mouse
buttons are pressed.</p>

<p>信号可以向它们调用的每个插槽传递参数。

例如，一个传递鼠标移动事件的信号可能要传入新的鼠标坐标以及是否按了鼠标键。
</p>

<p>As an example, we'll create a signal that passes two
<code class="computeroutput">float</code> arguments to its slots. Then we'll create a few
slots that print the results of various arithmetic operations on
these values.</p>

<p>例如，我们创建一个信号，它将传入两个
<code class="computeroutput">float</code> 参数到它的插槽。

然后我们再创建几个插槽，打印对这两个参数进行算术运算的各种结果。
</p>

<pre class="programlisting"><code class="computeroutput">void print_args(float x, float y)<br>{<br>  std::cout &lt;&lt; "The arguments are " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y &lt;&lt; std::endl;<br>}<br><br>void print_sum(float x, float y)<br>{<br>  std::cout &lt;&lt; "The sum is " &lt;&lt; x + y &lt;&lt; std::endl;<br>}<br><br>void print_product(float x, float y)<br>{<br>  std::cout &lt;&lt; "The product is " &lt;&lt; x * y &lt;&lt; std::endl;<br>}<br><br>void print_difference(float x, float y)<br>{<br>  std::cout &lt;&lt; "The difference is " &lt;&lt; x - y &lt;&lt; std::endl;<br>}<br><br>void print_quotient(float x, float y)<br>{<br>  std::cout &lt;&lt; "The quotient is " &lt;&lt; x / y &lt;&lt; std::endl;<br>}<br></code></pre>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><code class="computeroutput">  boost::signals2::signal&lt;void (float, float)&gt; sig;<br><br>  sig.connect(&amp;print_args);<br>  sig.connect(&amp;print_sum);<br>  sig.connect(&amp;print_product);<br>  sig.connect(&amp;print_difference);<br>  sig.connect(&amp;print_quotient);<br><br>  sig(5., 3.);<br></code></pre>
</td>

</tr></tbody>
</table></div>
<p>This program will print out the following:</p>

<p>该程序将打印输出如下：</p>

<pre class="programlisting">The arguments are 5 and 3<br>The sum is 8<br>The product is 15<br>The difference is 2<br>The quotient is 1.66667</pre>
<p>So any values that are given to <code class="computeroutput">sig</code> when it is
called like a function are passed to each of the slots. We have to
declare the types of these values up front when we create the
signal. The type <code class="computeroutput"><a class="link" href="../boost/signals2/signal.html" title="Class template signal">boost::signals2::signal</a>&lt;void (float,
float)&gt;</code> means that the signal has a <code class="computeroutput">void</code>
return value and takes two <code class="computeroutput">float</code> values. Any slot
connected to <code class="computeroutput">sig</code> must therefore be able to take two
<code class="computeroutput">float</code> values.</p>

<p>
当像函数一样调用 <code class="computeroutput">sig</code> 时，
输入它的任何值都传给了每一个插槽。

创建信号时，我们必须预先声明这些值的类型。

类型 <code class="computeroutput"><a class="link" href="../boost/signals2/signal.html" title="Class template signal">boost::signals2::signal</a>&lt;void (float,
float)&gt;</code> 表明信号具有 <code class="computeroutput">void</code>
返回值并接受两个 <code class="computeroutput">float</code> 值。

因此任何连接到
<code class="computeroutput">sig</code>
的插槽都必须能够接受两个
<code class="computeroutput">float</code> 值。
</p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3352101"></a>Signal Return Values (Advanced)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3352101"></a>信号返回值（高级）</h4></div></div></div>

<p>Just as slots can receive arguments, they can also return
values. These values can then be returned back to the caller of the
signal through a <em class="firstterm">combiner</em>. The combiner is a mechanism
that can take the results of calling slots (there many be no
results or a hundred; we don't know until the program runs) and
coalesces them into a single result to be returned to the caller.
The single result is often a simple function of the results of the
slot calls: the result of the last slot call, the maximum value
returned by any slot, or a container of all of the results are some
possibilities.</p>

<p>正如插槽可以接收参数，它们也可以返回值。

然后这些值可以通过
<em class="firstterm">合并器（combiner）</em>
返回给信号的调用者。

合并器是这样一种工具，它接收插槽调用的结果（可能没有结果，也可能有100个结果；程序运行时才知道），并且把它们合并成单一的结果返回给调用者。

该单一的结果往往是插槽调用结果的一个简单函数，可能是：最后的插槽调用的结果、所有插槽返回值的最大值，或包含所有结果的容器。
</p>

<p>We can modify our previous arithmetic operations example
slightly so that the slots all return the results of computing the
product, quotient, sum, or difference. Then the signal itself can
return a value based on these results to be printed:</p>

<p>
我们可以稍微修改前面的算术运算的例子，
使插槽分别返回加减乘除的计算结果。

然后信号本身就可以根据这些结果返回一个值，并打印出来。
</p>

<pre class="programlisting"><code class="computeroutput">float product(float x, float y) { return x * y; }<br>float quotient(float x, float y) { return x / y; }<br>float sum(float x, float y) { return x + y; }<br>float difference(float x, float y) { return x - y; }<br></code></pre>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">boost::signals2::signal&lt;float (float, float)&gt; sig;</pre>
</td>

</tr></tbody>
</table></div>
<pre class="programlisting"><code class="computeroutput">  sig.connect(&amp;product);<br>  sig.connect(&amp;quotient);<br>  sig.connect(&amp;sum);<br>  sig.connect(&amp;difference);<br><br>  // The default combiner returns a boost::optional containing the return<br>  // value of the last slot in the slot list, in this case the<br>  // difference function.<br>  std::cout &lt;&lt; *sig(5, 3) &lt;&lt; std::endl;<br></code></pre>
<p>This example program will output <code class="computeroutput">2</code>. This is because the
default behavior of a signal that has a return type
(<code class="computeroutput">float</code>, the first template argument given to the
<code class="computeroutput"><a class="link" href="../boost/signals2/signal.html" title="Class template signal">boost::signals2::signal</a></code> class template) is to call all slots and
then return a <code class="computeroutput">boost::optional</code> containing
the result returned by the last slot called. This
behavior is admittedly silly for this example, because slots have
no side effects and the result is the last slot connected.</p>

<p>该例程将输出 <code class="computeroutput">2</code>。
这是因为具有返回类型（<code class="computeroutput">float</code>，
即输入 <code class="computeroutput"><a class="link" href="../boost/signals2/signal.html" title="Class template signal">boost::signals2::signal</a></code>
类模板的第一个模板参数）的信号的默认行为是，
调用所有的插槽，然后返回最后一个被调用插槽的结果。

对本例来说，该行为确实有点傻，因为这些插槽没有副作用，所以结果就是最后连接的插槽。
</p>

<p>A more interesting signal result would be the maximum of the
values returned by any slot. To do this, we create a custom
combiner that looks like this:</p>

<p>求所有插槽返回值的最大值，这样的信号结果才有点意思。
为此，我们创建一个自定义合并器如下：
</p>

<pre class="programlisting"><code class="computeroutput">// combiner which returns the maximum value returned by all slots<br>template&lt;typename T&gt;<br>struct maximum<br>{<br>  typedef T result_type;<br><br>  template&lt;typename InputIterator&gt;<br>  T operator()(InputIterator first, InputIterator last) const<br>  {<br>    // If there are no slots to call, just return the<br>    // default-constructed value<br>    if(first == last ) return T();<br>    T max_value = *first++;<br>    while (first != last) {<br>      if (max_value &lt; *first)<br>        max_value = *first;<br>      ++first;<br>    }<br><br>    return max_value;<br>  }<br>};<br></code></pre>
<p>The <code class="computeroutput">maximum</code> class template acts as a function
object. Its result type is given by its template parameter, and
this is the type it expects to be computing the maximum based on
(e.g., <code class="computeroutput">maximum&lt;float&gt;</code> would find the maximum
<code class="computeroutput">float</code> in a sequence of <code class="computeroutput">float</code>s). When a
<code class="computeroutput">maximum</code> object is invoked, it is given an input
iterator sequence <code class="computeroutput">[first, last)</code> that includes the
results of calling all of the slots. <code class="computeroutput">maximum</code> uses this
input iterator sequence to calculate the maximum element, and
returns that maximum value.</p>

<p>
<code class="computeroutput">maximum</code> 类模板就像一个函数对象。

它的结果类型由其模板参数给出，
并且它正是基于该类型计算最大值
（例如，<code class="computeroutput">maximum&lt;float&gt;</code>
将在一系列 <code class="computeroutput">float</code>
中查找最大的 <code class="computeroutput">float</code>）。

当调用
<code class="computeroutput">maximum</code> 对象时，
将给出一个输入迭代器序列
<code class="computeroutput">[first, last)</code>，
其中包含了所有插槽调用的结果。

<code class="computeroutput">maximum</code>
利用该输入迭代器序列来计算最大元素，
并返回那个最大值。
</p>

<p>We actually use this new function object type by installing it
as a combiner for our signal. The combiner template argument
follows the signal's calling signature:</p>

<p>
我们要把这个新的函数对象作为合并器安装到我们的信号，才能实际使用它。
合并器模板参数跟在信号的调用签名式之后。
</p>

<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><code class="computeroutput"><a class="link" href="../boost/signals2/signal.html" title="Class template signal">boost::signals2::signal</a></code>&lt;float (float x, float y),<br>              maximum&lt;float&gt; &gt; sig;<br></pre>
</td>

</tr></tbody>
</table></div>
<p>Now we can connect slots that perform arithmetic functions and
use the signal:</p>

<p>现在我们可以连接执行算术功能的插槽并使用信号了：
</p>

<pre class="programlisting"><code class="computeroutput">  sig.connect(&amp;product);<br>  sig.connect(&amp;quotient);<br>  sig.connect(&amp;sum);<br>  sig.connect(&amp;difference);<br><br>  // Outputs the maximum value returned by the connected slots, in this case<br>  // 15 from the product function.<br>  std::cout &lt;&lt; "maximum: " &lt;&lt; sig(5, 3) &lt;&lt; std::endl;<br></code></pre>
<p>The output of this program will be <code class="computeroutput">15</code>, because
regardless of the order in which the slots are connected, the product
of 5 and 3 will be larger than the quotient, sum, or
difference.</p>

<p>该程序的输出为 <code class="computeroutput">15</code>，
因为不管插槽的连接次序如何，
5 和 3 的乘积将大于商、和，或差。
</p>

<p>In other cases we might want to return all of the values
computed by the slots together, in one large data structure. This
is easily done with a different combiner:</p>

<p>在其他情况下，我们可能需要同时返回插槽计算的所有值，
如保存在一个大型的数据结构中。
用一个不同的合并器就可以轻松做到：
</p>

<pre class="programlisting"><code class="computeroutput">// aggregate_values is a combiner which places all the values returned<br>// from slots into a container<br>template&lt;typename Container&gt;<br>struct aggregate_values<br>{<br>  typedef Container result_type;<br><br>  template&lt;typename InputIterator&gt;<br>  Container operator()(InputIterator first, InputIterator last) const<br>  {<br>    Container values;<br><br>    while(first != last) {<br>      values.push_back(*first);<br>      ++first;<br>    }<br>    return values;<br>  }<br>};<br></code></pre>
<p>
Again, we can create a signal with this new combiner:
</p>

<p>
我们再次用这个新的合并器创建信号：
</p>

<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><code class="computeroutput"><a class="link" href="../boost/signals2/signal.html" title="Class template signal">boost::signals2::signal</a></code>&lt;float (float, float),<br>    aggregate_values&lt;std::vector&lt;float&gt; &gt; &gt; sig;</pre>
</td>

</tr></tbody>
</table></div>
<pre class="programlisting"><code class="computeroutput">  sig.connect(&amp;quotient);<br>  sig.connect(&amp;product);<br>  sig.connect(&amp;sum);<br>  sig.connect(&amp;difference);<br><br>  std::vector&lt;float&gt; results = sig(5, 3);<br>  std::cout &lt;&lt; "aggregate values: ";<br>  std::copy(results.begin(), results.end(),<br>    std::ostream_iterator&lt;float&gt;(std::cout, " "));<br>  std::cout &lt;&lt; "\n";<br></code></pre>
<p>The output of this program will contain 15, 8, 1.6667, and 2. It
is interesting here that
the first template argument for the <code class="computeroutput">signal</code> class,
<code class="computeroutput">float</code>, is not actually the return type of the signal.
Instead, it is the return type used by the connected slots and will
also be the <code class="computeroutput">value_type</code> of the input iterators passed
to the combiner. The combiner itself is a function object and its
<code class="computeroutput">result_type</code> member type becomes the return type of the
signal.</p>

<p>该程序的输出将包含 15、8、1.6667，和 2。
有趣的是，
<code class="computeroutput">signal</code>
类的第一个模板参数，
<code class="computeroutput">float</code>，
竟然不是信号的返回类型。

相反，该参数是所连接插槽的返回类型，
并且它也是传入合并器的输入迭代器的
<code class="computeroutput">value_type</code>。

合并器本身是个函数对象，并且它的
<code class="computeroutput">result_type</code>
成员类型将成为信号的返回类型。
</p>

<p>The input iterators passed to the combiner transform dereference
operations into slot calls. Combiners therefore have the option to
invoke only some slots until some particular criterion is met. For
instance, in a distributed computing system, the combiner may ask
each remote system whether it will handle the request. Only one
remote system needs to handle a particular request, so after a
remote system accepts the work we do not want to ask any other
remote systems to perform the same task. Such a combiner need only
check the value returned when dereferencing the iterator, and
return when the value is acceptable. The following combiner returns
the first non-NULL pointer to a <code class="computeroutput">FulfilledRequest</code> data
structure, without asking any later slots to fulfill the
request:</p>

<p>
传给合并器的输入迭代器会将解引用操作转换为插槽调用。

因此合并器可选择仅调用某些符合特定条件的插槽。

例如，在分布计算系统中，合并器可能会询问每个远程系统能否处理请求。

对于一个特定请求，仅需一个远程系统进行处理，
因此当一个远程系统接受该工作后，
我们将不再要求任何其他远程系统来做同一个任务。

这样一个合并器只需检查迭代器解引用的返回值，
并当该值可以接受时就返回。

以下的合并器返回第一个指向
<code class="computeroutput">FulfilledRequest</code>
数据结构的非空指针，
而不必要求任何以后的插槽来完成请求：
</p>

<pre class="programlisting">struct DistributeRequest {<br>  typedef FulfilledRequest* result_type;<br><br>  template&lt;typename InputIterator&gt;<br>  result_type operator()(InputIterator first, InputIterator last) const<br>  {<br>    while (first != last) {<br>      if (result_type fulfilled = *first)<br>        return fulfilled;<br>      ++first;<br>    }<br>    return 0;<br>  }<br>};<br></pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id3352571"></a>Connection Management</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="id3352571"></a>连接管理</h3></div></div></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id3352576">Disconnecting Slots (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352660">Blocking Slots (Beginner)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352717">Scoped Connections (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352816">Disconnecting Equivalent Slots (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.connection-management">Automatic Connection Management (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.deconstruct">Postconstructors and Predestructors (Advanced)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3353362">When Can Disconnections Occur? (Intermediate)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3353436">Passing Slots (Intermediate)</a></span></dt>
</dl></div>

<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id3352576">断开插槽（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352660">阻塞插槽（初级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352717">域内连接（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3352816">断开等价的插槽（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.connection-management">自动连接管理（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#signals2.tutorial.deconstruct">Postconstructor 和 Predestructor （高级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3353362">何时断开？（中级）</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id3353436">传递插槽（中级）</a></span></dt>
</dl></div>

<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3352576"></a>Disconnecting Slots (Beginner)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3352576"></a>断开插槽（初级）</h4></div></div></div>

<p>Slots aren't expected to exist indefinitely after they are
connected. Often slots are only used to receive a few events and
are then disconnected, and the programmer needs control to decide
when a slot should no longer be connected.</p>

<p>插槽在连接之后不必无限期地存在。
插槽往往只是用来接收一些事件然后断开，
当插槽不再需要保持连接时，
程序员可以做出决定并控制。
</p>

<p>The entry point for managing connections explicitly is the
<code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">boost::signals2::connection</a></code> class. The
<code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code> class uniquely represents the connection
between a particular signal and a particular slot. The
<code class="computeroutput"><a class="link" href="../boost/signals2/connection.html#id1186298-bb">connected</a>()</code> method checks if the signal and slot are
still connected, and the <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html#id1278410-bb">disconnect()</a></code> method
disconnects the signal and slot if they are connected before it is
called. Each call to the signal's <code class="computeroutput">connect()</code> method
returns a connection object, which can be used to determine if the
connection still exists or to disconnect the signal and slot.</p>

<p>
显式管理连接的入口点是
<code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">boost::signals2::connection</a></code> 类。

<code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code> 
类唯一代表了特定信号与特定插槽之间的连接。

<code class="computeroutput"><a class="link" href="../boost/signals2/connection.html#id1186298-bb">connected</a>()</code> 
方法检查信号与插槽是否仍保持连接，

如果信号与插槽是连接着的，
<code class="computeroutput"><a class="link" href="../boost/signals2/connection.html#id1278410-bb">disconnect()</a></code> 
方法断开它们的连接。

每次调用信号的 <code class="computeroutput">connect()</code> 
方法，就返回一个连接对象，
该对象用于确定连接是否仍然存在，
或者用于断开信号和插槽。
</p>

<pre class="programlisting"><code class="computeroutput">  boost::signals2::connection c = sig.connect(HelloWorld());<br>  std::cout &lt;&lt; "c is connected\n";<br>  sig(); // Prints "Hello, World!"<br><br>  c.disconnect(); // Disconnect the HelloWorld object<br>  std::cout &lt;&lt; "c is disconnected\n";<br>  sig(); // Does nothing: there are no connected slots<br></code></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3352660"></a>Blocking Slots (Beginner)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3352660"></a>阻塞插槽（初级）</h4></div></div></div>

<p>Slots can be temporarily "blocked", meaning that they will be
ignored when the signal is invoked but have not been permanently disconnected.
This is typically used to prevent infinite recursion in cases where
otherwise running a slot would cause the signal it is connected to to be
invoked again.  A
<code class="computeroutput"><a class="link" href="../boost/signals2/shared_connection_block.html" title="Class shared_connection_block">boost::signals2::shared_connection_block</a></code> object will
temporarily block a slot.  The connection is unblocked by either
destroying or calling
<code class="computeroutput"><a class="link" href="../boost/signals2/shared_connection_block.html#id1183652-bb">unblock</a></code>
on all the
<code class="computeroutput">shared_connection_block</code> objects that reference the connection.
Here is an example of
blocking/unblocking slots:</p>

<p>
插槽可以被临时“阻塞”，即当信号被调用时，这些插槽将被忽略，但并没有被永久地断开。
这主要用于防止无限递归，
如有时，要没有阻塞，插槽运行时会再次调用它所连接的信号。

<code class="computeroutput"><a class="link" href="../boost/signals2/shared_connection_block.html" title="Class shared_connection_block">boost::signals2::shared_connection_block</a></code>
对象会临时阻塞插槽。

要解除阻塞，需要销毁所有引用该连接的
<code class="computeroutput">shared_connection_block</code>
对象，或者调用它们的
<code class="computeroutput"><a class="link" href="../boost/signals2/shared_connection_block.html#id1183652-bb">unblock</a></code>。

以下是阻塞插槽和解除的例子：</p>

<pre class="programlisting"><code class="computeroutput">  boost::signals2::connection c = sig.connect(HelloWorld());<br>  std::cout &lt;&lt; "c is not blocked.\n";<br>  sig(); // Prints "Hello, World!"<br><br>  {<br>    boost::signals2::shared_connection_block block(c); // block the slot<br>    std::cout &lt;&lt; "c is blocked.\n";<br>    sig(); // No output: the slot is blocked<br>  } // shared_connection_block going out of scope unblocks the slot<br>  std::cout &lt;&lt; "c is not blocked.\n";<br>  sig(); // Prints "Hello, World!"}<br></code></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3352717"></a>Scoped Connections (Intermediate)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3352717"></a>域内连接（中级）</h4></div></div></div>

<p>The <code class="computeroutput"><a class="link" href="../boost/signals2/scoped_connection.html" title="Class scoped_connection">boost::signals2::scoped_connection</a></code> class
references a signal/slot connection that will be disconnected when
the <code class="computeroutput">scoped_connection</code> class goes out of scope. This
ability is useful when a connection need only be temporary,
e.g.,</p>

<p>
<code class="computeroutput"><a class="link" href="../boost/signals2/scoped_connection.html" title="Class scoped_connection">boost::signals2::scoped_connection</a></code>
类引用了一个信号/插槽的连接，当
<code class="computeroutput">scoped_connection</code>
类出作用域时，该连接将会被断开。

当仅需临时连接时，该功能很有用，如：
</p>

<pre class="programlisting"><code class="computeroutput">  {<br>    boost::signals2::scoped_connection c(sig.connect(ShortLived()));<br>    sig(); // will call ShortLived function object<br>  } // scoped_connection goes out of scope and disconnects<br><br>  sig(); // ShortLived function object no longer connected to sig<br></code></pre>
<p>
  Note, attempts to initialize a scoped_connection with the assignment syntax
  will fail due to it being noncopyable.  Either the explicit initialization syntax
  or default construction followed by assignment from a <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code>
  will work:
</p>

<p>
  注意，试图用赋值语句初始化 scoped_connection
  会失败，因为它是不可拷贝的（noncopyable）。
  应该使用显式初始化，
  或者缺省构造然后用
  <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code>
  对它赋值：
</p>

<pre class="programlisting">// doesn't compile due to compiler attempting to copy a temporary scoped_connection object<br>// boost::signals2::scoped_connection c0 = sig.<code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1284885-bb">connect</a></code>(ShortLived());<br><br>// okay<br>boost::signals2::scoped_connection c1(sig.<code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1284885-bb">connect</a></code>(ShortLived()));<br><br>// also okay<br>boost::signals2::scoped_connection c2;<br>c2 = sig.<code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1284885-bb">connect</a></code>(ShortLived());<br></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3352816"></a>Disconnecting Equivalent Slots (Intermediate)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3352816"></a>断开等价的插槽（中级）</h4></div></div></div>

<p>One can disconnect slots that are equivalent to a given function
object using a form of the
<code class="computeroutput"><a class="link" href="../boost/signalN.html#id1242363-bb">signal::disconnect</a></code> method, so long as
the type of the function object has an accessible <code class="computeroutput">==</code>
operator. For instance:

</p>

<p>你可以使用
<code class="computeroutput"><a class="link" href="../boost/signalN.html#id1242363-bb">signal::disconnect</a></code>
方法断开与给定函数对象等价的多个插槽，
只要该函数对象的类型具有可访问的
<code class="computeroutput">==</code>
运算符。例如：
</p>

<pre class="programlisting"><code class="computeroutput">void foo() { std::cout &lt;&lt; "foo"; }<br>void bar() { std::cout &lt;&lt; "bar\n"; }<br></code></pre>
<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><code class="computeroutput"><a class="link" href="../boost/signals2/signal.html" title="Class template signal">boost::signals2::signal</a></code>&lt;void ()&gt; sig;</pre>
</td>

</tr></tbody>
</table></div>
</div>
<pre class="programlisting"><code class="computeroutput">  sig.connect(&amp;foo);<br>  sig.connect(&amp;bar);<br>  sig();<br><br>  // disconnects foo, but not bar<br>  sig.disconnect(&amp;foo);<br>  sig();<br></code></pre>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="signals2.tutorial.connection-management"></a>Automatic Connection Management (Intermediate)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="signals2.tutorial.connection-management"></a>自动连接管理（中级）</h4></div></div></div>

<p>Boost.Signals2 can automatically track the lifetime of objects
involved in signal/slot connections, including automatic
disconnection of slots when objects involved in the slot call are
destroyed. For instance, consider a simple news delivery service,
where clients connect to a news provider that then sends news to
all connected clients as information arrives. The news delivery
service may be constructed like this: </p>

<p>
Boost.Signals2 能自动跟踪信号/插槽连接中所涉及对象的生命期，
包括当插槽调用中涉及的对象销毁时自动断开插槽。

例如，考虑一个简单的新闻发送服务，
其中客户会连接到新闻提供者，
而新闻提供者一有信息到达，就发送新闻到所有连接的客户。
该新闻发送服务可能像这样构造：
</p>

<div class="informaltable"><table class="table">
<colgroup><col><col></colgroup>
<thead></thead>
<tbody><tr>
<td align="left">
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting">class NewsItem { /* ... */ };<br><br>typedef boost::signals2::signal&lt;void (const NewsItem&amp;)&gt; signal_type;<br>signal_type deliverNews;<br></pre>
</td>

</tr></tbody>
</table></div>
<p>Clients that wish to receive news updates need only connect a
function object that can receive news items to the
<code class="computeroutput">deliverNews</code> signal. For instance, we may have a
special message area in our application specifically for news,
e.g.,:</p>

<p>
希望接收新闻更新的客户只需连接一个函数对象，
该对象可以接收传给
<code class="computeroutput">deliverNews</code>
信号的新闻条目，例如：
</p>

<pre class="programlisting">struct NewsMessageArea : public MessageArea<br>{<br>public:<br>  // ...<br><br>  void displayNews(const NewsItem&amp; news) const<br>  {<br>    messageText = news.text();<br>    update();<br>  }<br>};<br><br>// ...<br>NewsMessageArea *newsMessageArea = new NewsMessageArea(/* ... */);<br>// ...<br>deliverNews.<code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1284885-bb">connect</a></code>(boost::bind(&amp;NewsMessageArea::displayNews,<br>  newsMessageArea, _1));<br></pre>
<p>However, what if the user closes the news message area,
destroying the <code class="computeroutput">newsMessageArea</code> object that
<code class="computeroutput">deliverNews</code> knows about? Most likely, a segmentation
fault will occur. However, with Boost.Signals2 one may track any object
which is managed by a shared_ptr, by using
<code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html#id1187184-bb">slot::track</a></code>.  A slot will automatically
disconnect when any of its tracked objects expire.  In
addition, Boost.Signals2 will ensure that no tracked object expires
while the slot it is associated with is in mid-execution.  It does so by creating
temporary shared_ptr copies of the slot's tracked objects before executing it.
To track <code class="computeroutput">NewsMessageArea</code>, we use a shared_ptr to manage
its lifetime, and pass the shared_ptr to the slot via its
<code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html#id1187184-bb">slot::track</a></code>
method before connecting it,
e.g.:</p>

<p>不过，如果用户关闭新闻讯息区，
销毁了 <code class="computeroutput">deliverNews</code>
所知的 <code class="computeroutput">newsMessageArea</code> 对象，
那会怎么样？

最有可能的是产生段错误。

然而，在Boost.Signals2中，使用
<code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html#id1187184-bb">slot::track</a></code>，
你可以跟踪由 shared_ptr 管理的任何对象，

当插槽的任一个被跟踪对象失效时，插槽会自动断开。

另外，当插槽正在执行时，
Boost.Signals2 会保证它所关联的被跟踪对象不会失效。

为此，插槽在执行前会创建被跟踪对象的临时 shared_ptr 副本。

为了跟踪 <code class="computeroutput">NewsMessageArea</code>，
我们用 shared_ptr 管理其生命期，
并在连接它之前，
通过其
<code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html#id1187184-bb">slot::track</a></code>
方法，
把 shared_ptr 传给插槽。

例如：
</p>

<pre class="programlisting">// ...<br>boost::shared_ptr&lt;NewsMessageArea&gt; newsMessageArea(new NewsMessageArea(/* ... */));<br>// ...<br>deliverNews.<code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1284885-bb">connect</a></code>(signal_type::slot_type(&amp;NewsMessageArea::displayNews,<br>  newsMessageArea.get(), _1).track(newsMessageArea));<br></pre>
<p>
  Note there is no explicit call to bind() needed in the above example.  If the
  <code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html" title="Class template slotN">slot</a></code> constructor is passed more than one
  argument, it will automatically pass all the arguments to <code class="computeroutput">bind</code> and use the
  returned function object.
</p>

<p>
  注意上例中不需要显式调用 bind()。
  如果
  <code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html" title="Class template slotN">slot</a></code>
  构造函数传入一个以上的参数，
  它会自动将所有参数传给
  <code class="computeroutput">bind</code>，
  并使用返回的函数对象。
</p>

<p>Also note, we pass an ordinary pointer as the
  second argument to the slot constructor, using <code class="computeroutput">newsMessageArea.get()</code>
  instead of passing the <code class="computeroutput">shared_ptr</code> itself.  If we had passed the
  <code class="computeroutput">newsMessageArea</code> itself, a copy of the <code class="computeroutput">shared_ptr</code> would
  have been bound into the slot function, preventing the <code class="computeroutput">shared_ptr</code>
  from expiring.  However, the use of
  <code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html#id1187184-bb">slot::track</a></code>
  implies we wish to allow the tracked object to expire, and automatically
  disconnect the connection when this occurs.
</p>

<p>还要注意插槽构造函数的第2个参数，
  我们使用 <code class="computeroutput">newsMessageArea.get()</code>，
  传入了一个普通指针，
  而不是 <code class="computeroutput">shared_ptr</code> 本身。
  
  如果传入 <code class="computeroutput">newsMessageArea</code> 本身，
  插槽函数将绑定一个 <code class="computeroutput">shared_ptr</code> 副本，
  从而妨碍了 <code class="computeroutput">shared_ptr</code> 的失效。
  
  然而，使用
  <code class="computeroutput"><a class="link" href="../boost/signals2/slotN.html#id1187184-bb">slot::track</a></code>
  意味着我们希望允许被跟踪对象失效，
  并且当它发生时自动断开连接。
</p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="signals2.tutorial.deconstruct"></a>Postconstructors and Predestructors (Advanced)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="signals2.tutorial.deconstruct"></a>Postconstructor 和 Predestructor （高级）</h4></div></div></div>

<p>One limitation of using <code class="computeroutput">shared_ptr</code> for tracking is that
      an object cannot setup tracking of itself in its constructor.  However, it is
      possible to set up tracking in a post-constructor which is called after the
      object has been created and passed to a <code class="computeroutput">shared_ptr</code>.
      The Boost.Signals2
      library provides support for post-constructors and pre-destructors
      via the <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code> factory function.
    </p>

<p>利用 <code class="computeroutput">shared_ptr</code> 跟踪有一个限制：
      对象不能在其构造函数中建立对自身的跟踪。

      然而，可以在 post-constructor 中建立跟踪，
      它会在对象创建并传给
      <code class="computeroutput">shared_ptr</code>
      之后被调用。
      
      Boost.Signals2 库通过
      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code>
      工厂方法，
      对 post-constructor 和 pre-destructor 提供了支持。
    </p>

<p>
      For most cases, the simplest and most robust way to setup postconstructors
      for a class is to define an associated <code class="computeroutput">adl_postconstruct</code> function
      which can be found by <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code>,
      make the class' constructors private, and give <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct</a></code>
      access to the private constructors by declaring <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct_access.html" title="Class deconstruct_access">deconstruct_access</a></code>
      a friend.  This will ensure that objects of the class may only be created
      through the <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code> function, and their
      associated <code class="computeroutput">adl_postconstruct()</code> function will always be called.
    </p>

<p>
      在多数情况下，
      为类建立 postconstructor 最简单最可靠的方法是：
      定义一个相关的
      <code class="computeroutput">adl_postconstruct</code> 函数，
      让它可以被
      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code>
      找到，
      让类的构造函数为私有的，
      并通过声明
      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct_access.html" title="Class deconstruct_access">deconstruct_access</a></code>
      为友元，
      让 <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct</a></code>
      可以访问私有的构造函数。

      这将保证类的对象只能通过
      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code>
      函数创建，
      而它们相关的
      <code class="computeroutput">adl_postconstruct()</code>
      函数总是会被调用。
    </p>

<p>The <a class="link" href="examples.html#signals2.examples.deconstruct" title="Postconstructors and Predestructors with deconstruct()">examples</a> section
      contains several examples of defining classes with postconstructors and
      predestructors, and creating objects of these classes using
      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code>
    </p>

<p><a class="link" href="examples.html#signals2.examples.deconstruct" title="Postconstructors and Predestructors with deconstruct()">例程</a>
	  一节中有几个例子，
	  它们用 postconstructor 和 predestructor 定义类，
      并用
      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct()</a></code>
      创建这些类的对象。
    </p>

<p>
      Be aware that the postconstructor/predestructor support in Boost.Signals2
      is in no way essential to the use of the library.  The use of
      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct</a></code>
      is purely optional.  One alternative is to
      define static factory functions for your classes.  The
      factory function can create an object, pass ownership of the object to
      a <code class="computeroutput">shared_ptr</code>, setup tracking for the object,
      then return the <code class="computeroutput">shared_ptr</code>.
    </p>

<p>
      注意，Boost.Signals2 中对 postconstructor/predestructor
      的支持对于库的使用并非是必须的。

      <code class="computeroutput"><a class="link" href="../boost/signals2/deconstruct.html" title="Function deconstruct">deconstruct</a></code>
      的使用完全是可选的。

      另一选择是为你的类定义静态工厂函数。

      该工厂函数可以创建对象，传递对象所有权到
      <code class="computeroutput">shared_ptr</code>，
      为对象建立跟踪，
      然后返回 <code class="computeroutput">shared_ptr</code>。
    </p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3353362"></a>When Can Disconnections Occur? (Intermediate)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3353362"></a>何时断开？（中级）</h4></div></div></div>

<p>Signal/slot disconnections occur when any of these conditions
occur:</p>

<p>
以下任一条件发生时，信号/插槽将断开：
</p>

<div class="itemizedlist"><ul type="disc">
<li><p>The connection is explicitly disconnected via the connection's
<code class="computeroutput">disconnect</code> method directly, or indirectly via the
signal's <code class="computeroutput">disconnect</code> method, or
<code class="computeroutput">scoped_connection</code>'s destructor.</p>

<p>连接被显式地断开：
直接通过连接的
<code class="computeroutput">disconnect</code> 方法， 
或间接地通过信号的
<code class="computeroutput">disconnect</code> 方法，
或
<code class="computeroutput">scoped_connection</code>
的析构函数。
</p>

</li>
<li><p>An object tracked by the slot is
destroyed.</p>

<p>插槽所跟踪的对象被销毁。</p>

</li>
<li><p>The signal is destroyed.</p>

<p>信号被销毁。</p>

</li>
</ul></div>
<p>These events can occur at any time without disrupting a signal's
calling sequence. If a signal/slot connection is disconnected at
any time during a signal's calling sequence, the calling sequence
will still continue but will not invoke the disconnected slot.
Additionally, a signal may be destroyed while it is in a calling
sequence, and which case it will complete its slot call sequence
but may not be accessed directly.</p>

<p>这些事件可以发生于任何时间，而不会破坏信号的调用序列。

如果信号/插槽的连接在信号调用序列的任意时刻被断开，
调用序列仍将继续，只是不会调用被断开的插槽。

此外，信号可以在调用序列中间被销毁，这时，它将完成其插槽调用序列，
只是不可以被直接访问。
</p>

<p>Signals may be invoked recursively (e.g., a signal A calls a
slot B that invokes signal A...). The disconnection behavior does
not change in the recursive case, except that the slot calling
sequence includes slot calls for all nested invocations of the
signal.</p>

<p>信号可以被递归调用（例如，信号A调用插槽B，而插槽B又调用信号A……）。

递归情况下，断开的行为不会改变，
只是插槽调用序列包括所有嵌套的信号调用。
</p>

<p>
  Note, even after a connection is disconnected, its's associated slot
  may still be in the process of executing.  In other words, disconnection
  does not block waiting for the connection's associated slot to complete execution.
  This situation may occur in a multi-threaded environment if the
  disconnection occurs concurrently with signal invocation,
  or in a single-threaded environment if a slot disconnects itself.
</p>

<p>
  注意，即使在连接断开后，
  其相关的插槽可能仍处于执行中。

  也就是说，断开连接不会停止等待连接相关的插槽完成执行。

  该情形可以发生在多线程环境下，
  如断开连接与信号调用并行发生，
  或者在单线程环境下，如插槽断开自身。
</p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3353436"></a>Passing Slots (Intermediate)</h4></div></div></div>

<div class="titlepage"><div><div><h4 class="title">
<a name="id3353436"></a>传递插槽（中级）</h4></div></div></div>

<p>Slots in the Boost.Signals2 library are created from arbitrary
function objects, and therefore have no fixed type. However, it is
commonplace to require that slots be passed through interfaces that
cannot be templates. Slots can be passed via the
<code class="computeroutput">slot_type</code> for each particular signal type and any
function object compatible with the signature of the signal can be
passed to a <code class="computeroutput">slot_type</code> parameter. For instance:</p>

<p>Boost.Signals2 库中的插槽可以从任意的函数对象创建，因此没有固定的类型。

不过通常要求通过不可模板化的接口传递插槽。

对于每个特定的信号类型，
都可以通过
<code class="computeroutput">slot_type</code>
传递插槽，

而与信号的签名式兼容的任意函数对象，
都可以传给 <code class="computeroutput">slot_type</code> 参数。

例如：
</p>

<pre class="programlisting"><code class="computeroutput">// a pretend GUI button<br>class Button<br>{<br>  typedef boost::signals2::signal&lt;void (int x, int y)&gt; OnClick;<br>public:<br>  typedef OnClick::slot_type OnClickSlotType;<br>  // forward slots through Button interface to its private signal<br>  boost::signals2::connection doOnClick(const OnClickSlotType &amp; slot);<br><br>  // simulate user clicking on GUI button at coordinates 52, 38<br>  void simulateClick();<br>private:<br>  OnClick onClick;<br>};<br><br>boost::signals2::connection Button::doOnClick(const OnClickSlotType &amp; slot)<br>{<br>  return onClick.connect(slot);<br>}<br><br>void Button::simulateClick()<br>{<br>  onClick(52, 38);<br>}<br><br>void printCoordinates(long x, long y)<br>{<br>  std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")\n";<br>}<br></code></pre>
<pre class="programlisting"><code class="computeroutput">  Button button;<br>  button.doOnClick(&amp;printCoordinates);<br>  button.simulateClick();<br></code></pre>
<p>The <code class="computeroutput">doOnClick</code> method is now functionally equivalent
to the <code class="computeroutput">connect</code> method of the <code class="computeroutput">onClick</code>
signal, but the details of the <code class="computeroutput">doOnClick</code> method can be
hidden in an implementation detail file.</p>

<p><code class="computeroutput">doOnClick</code> 方法现在功能上等效于
<code class="computeroutput">onClick</code> 信号的
<code class="computeroutput">connect</code> 方法，
但是 <code class="computeroutput">doOnClick</code> 
方法的细节可以隐藏于细节实现文件中。
</p>

</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="signals2.tutorial.document-view"></a>Example: Document-View</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="signals2.tutorial.document-view"></a>例子：文档-视图</h3></div></div></div>

<p>Signals can be used to implement flexible Document-View
  architectures. The document will contain a signal to which each of
  the views can connect. The following <code class="computeroutput">Document</code> class
  defines a simple text document that supports mulitple views. Note
  that it stores a single signal to which all of the views will be
  connected.</p>

<p>信号可用于实现灵活的文档-视图（Document-View）架构。
  
  文档包含一个信号，而每个视图连接该信号。
  
  下面的 <code class="computeroutput">Document</code> 
  类定义了一个简单的支持多视图的文本文档。
  
  注意它保存了一个单一的信号，所有视图都连接到该信号。
  </p>

<pre class="programlisting"><code class="computeroutput">class Document<br>{<br>public:<br>    typedef boost::signals2::signal&lt;void ()&gt;  signal_t;<br><br>public:<br>    Document()<br>    {}<br><br>    /* Connect a slot to the signal which will be emitted whenever<br>      text is appended to the document. */<br>    boost::signals2::connection connect(const signal_t::slot_type &amp;subscriber)<br>    {<br>        return m_sig.connect(subscriber);<br>    }<br><br>    void append(const char* s)<br>    {<br>        m_text += s;<br>        m_sig();<br>    }<br><br>    const std::string&amp; getText() const<br>    {<br>        return m_text;<br>    }<br><br>private:<br>    signal_t    m_sig;<br>    std::string m_text;<br>};<br></code></pre>
<p>
    Next, we can begin to define views. The
    following <code class="computeroutput">TextView</code> class provides a simple view of the
    document text.
  </p>

<p>
    接下来，我们可以开始定义视图。
    以下 <code class="computeroutput">TextView</code>
    类是对文档文本的一个简单视图。
  </p>

<pre class="programlisting"><code class="computeroutput">class TextView<br>{<br>public:<br>    TextView(Document&amp; doc): m_document(doc)<br>    {<br>        m_connection = m_document.connect(boost::bind(&amp;TextView::refresh, this));<br>    }<br><br>    ~TextView()<br>    {<br>        m_connection.disconnect();<br>    }<br><br>    void refresh() const<br>    {<br>        std::cout &lt;&lt; "TextView: " &lt;&lt; m_document.getText() &lt;&lt; std::endl;<br>    }<br>private:<br>    Document&amp;               m_document;<br>    boost::signals2::connection  m_connection;<br>};<br></code></pre>
<p>Alternatively, we can provide a view of the document
    translated into hex values using the <code class="computeroutput">HexView</code>
    view:</p>

<p>此外，我们可以提供文档翻译成16进制后的视图，
    如 <code class="computeroutput">HexView</code> 视图：
    </p>

<pre class="programlisting"><code class="computeroutput">class HexView<br>{<br>public:<br>    HexView(Document&amp; doc): m_document(doc)<br>    {<br>        m_connection = m_document.connect(boost::bind(&amp;HexView::refresh, this));<br>    }<br><br>    ~HexView()<br>    {<br>        m_connection.disconnect();<br>    }<br><br>    void refresh() const<br>    {<br>        const std::string&amp;  s = m_document.getText();<br><br>        std::cout &lt;&lt; "HexView:";<br><br>        for (std::string::const_iterator it = s.begin(); it != s.end(); ++it)<br>            std::cout &lt;&lt; ' ' &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(*it);<br><br>        std::cout &lt;&lt; std::endl;<br>    }<br>private:<br>    Document&amp;               m_document;<br>    boost::signals2::connection  m_connection;<br>};<br></code></pre>
<p>
    To tie the example together, here is a
    simple <code class="computeroutput">main</code> function that sets up two views and then
    modifies the document:
  </p>

<p>
    为了把例子串起来，
    有个简单的
    <code class="computeroutput">main</code>
    函数，它建立了两个视图，然后更改文档：
  </p>

<pre class="programlisting"><code class="computeroutput">int main(int argc, char* argv[])<br>{<br>    Document    doc;<br>    TextView    v1(doc);<br>    HexView     v2(doc);<br><br>    doc.append(argc == 2 ? argv[1] : "Hello world!");<br>    return 0;<br>}<br></code></pre>
<p>The complete example source, contributed by Keith MacDonald,
    is available in the <a class="link" href="examples.html#signals2.examples.document-view" title="Document-View">examples</a> section.
    We also provide variations on the program which employ automatic connection management
    to disconnect views on their destruction.
  </p>

<p>完整的例程源码，由 Keith MacDonald 提供，在
    <a class="link" href="examples.html#signals2.examples.document-view" title="Document-View">例程</a>一节中。

    同时我们提供了该程序的更改版，
    它们使用了自动连接管理，
    能在视图析构时断开视图。
  </p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="signals2.tutorial.extended-slot-type"></a>Giving a Slot Access to its Connection (Advanced)</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="signals2.tutorial.extended-slot-type"></a>让插槽可以操作其连接（高级）</h3></div></div></div>

<p>
      You may encounter situations where you wish to disconnect or block a slot's
      connection from within the slot itself.  For example, suppose you have a group
      of asynchronous tasks, each of which emits a signal when it completes.
      You wish to connect a slot to all the tasks to retrieve their results as
      each completes.  Once a
      given task completes and the slot is run, the slot no longer needs to be
      connected to the completed task.
      Therefore, you may wish to clean up old connections by having the slot
      disconnect its invoking connection when it runs.
    </p>

<p>
      可能有这样的情形：
      你希望在插槽中断开或阻塞插槽本身的连接。

      例如，有一组异步任务，当每个任务完成时会发出信号。
      你希望用一个插槽连接所有的任务，来接收它们完成时的结果。

      一旦某个任务完成并且插槽被运行，该插槽就不必再连接到这个已经完成的任务。
      因此，你可能希望让插槽运行时断开其连接，以清理旧连接。
    </p>

<p>
      For a slot to disconnect (or block) its invoking connection, it must have
      access to a <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code> object which references
      the invoking signal-slot connection.  The difficulty is,
      the <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code> object is returned by the
      <code class="computeroutput"><a class="link" href="../boost/signalN.html#id1215527-bb">signal::connect</a></code>
      method, and therefore is not available until after the slot is
      already connected to the signal.  This can be particularly troublesome
      in a multi-threaded environment where the signal may be invoked
      concurrently by a different thread while the slot is being connected.
    </p>

<p>
      为了让插槽断开（或阻塞）其连接，
      它必须能够操作
      <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code>
      对象，即调用的信号-插槽连接对象。

      难点是，
      <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code>
      对象是由
      <code class="computeroutput"><a class="link" href="../boost/signalN.html#id1215527-bb">signal::connect</a></code>
      方法返回的，
      因此只有在插槽连接信号之后才能用。

      在多线程环境下，这尤其麻烦，
      当插槽正在被连接时，信号可能被其他线程并发调用。
    </p>

<p>
      Therefore, the signal classes provide
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1208227-bb">signal::connect_extended</a></code>
      methods, which allow slots which take an extra argument to be connected to a signal.
      The extra argument is a <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code> object which refers
      to the signal-slot connection currently invoking the slot.
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1208227-bb">signal::connect_extended</a></code>
      uses slots of the type given by the
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#boost.signals2.signalN.extended_slot_type">signal::extended_slot_type</a></code>
      typedef.
    </p>

<p>
      因此，信号类提供了
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1208227-bb">signal::connect_extended</a></code>
      方法，它允许连接信号的插槽接受一个额外参数。

      该额外参数是个 <code class="computeroutput"><a class="link" href="../boost/signals2/connection.html" title="Class connection">connection</a></code>
      对象，它指向当前调用插槽的信号-插槽连接。
      
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1208227-bb">signal::connect_extended</a></code>
      使用的插槽类型由
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#boost.signals2.signalN.extended_slot_type">signal::extended_slot_type</a></code>
      定义。
      
    </p>

<p>
      The examples section includes an
      <a class="link" href="examples.html#signals2.examples.tutorial.extended_slot" title="extended_slot">extended_slot</a>
      program which demonstrates the syntax for using
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1208227-bb">signal::connect_extended</a></code>.
    </p>

<p>
      例程一节中有个
      <a class="link" href="examples.html#signals2.examples.tutorial.extended_slot" title="extended_slot">extended_slot</a>
      程序，它演示了
      <code class="computeroutput"><a class="link" href="../boost/signals2/signalN.html#id1208227-bb">signal::connect_extended</a></code>
      的用法。
    </p>

</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="signals2.tutorial.signal-mutex-template-parameter"></a>Changing the <code class="computeroutput">Mutex</code> Type of a Signal (Advanced).</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="signals2.tutorial.signal-mutex-template-parameter"></a>改变信号的互斥体类型（高级）</h3></div></div></div>

<p>
      For most cases the default type of <code class="computeroutput"><a class="link" href="../boost/signals2/mutex.html" title="Class mutex">boost::signals2::mutex</a></code> for
      a <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code>'s <code class="computeroutput">Mutex</code> template type parameter should
      be fine.  If you wish to use an alternate mutex type, it must be default-constructible
      and fulfill the <code class="computeroutput">Lockable</code> concept defined by the Boost.Thread library.
      That is, it must have <code class="computeroutput">lock()</code> and <code class="computeroutput">unlock()</code> methods
      (the <code class="computeroutput">Lockable</code> concept also includes a <code class="computeroutput">try_lock()</code> method
      but this library does not require try locking).
    </p>

<p>
      <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code>
      的模板类型参数
      <code class="computeroutput">Mutex</code>
      默认为
      <code class="computeroutput"><a class="link" href="../boost/signals2/mutex.html" title="Class mutex">boost::signals2::mutex</a></code>，
      多数情况下，这应该能行。

      如果你希望使用其他的互斥体（mutex）类型，那么它必须可缺省构造，
      并且满足由 Boost.Thread 库所定义的
      <code class="computeroutput">Lockable</code>
      概念（concept）。
      
      即，它必须具有
      <code class="computeroutput">lock()</code> 和 <code class="computeroutput">unlock()</code>
      方法（<code class="computeroutput">Lockable</code> 概念同时包含了
      <code class="computeroutput">try_lock()</code> 方法，
      但本库没用到）。
    </p>

<p>
      The Boost.Signals2 library provides one alternate mutex class for use with <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code>:
      <code class="computeroutput"><a class="link" href="../boost/signals2/dummy_mutex.html" title="Class dummy_mutex">boost::signals2::dummy_mutex</a></code>.  This is a fake mutex for
      use in single-threaded programs, where locking a real mutex would be useless
      overhead.  Other mutex types you could use with <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code> include
      <code class="computeroutput">boost::mutex</code> and the <code class="computeroutput">std::mutex</code> from
      C++0x.
    </p>

<p>
      Boost.Signals2 库提供了另外一个可用于
      <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code>
      的互斥类：
      <code class="computeroutput"><a class="link" href="../boost/signals2/dummy_mutex.html" title="Class dummy_mutex">boost::signals2::dummy_mutex</a></code>。
      这是个用于单线程的假互斥体，因为在单线程中，用真实的互斥体加锁是无谓的开销。

      其它可用于 <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code>
      的互斥体类型有：
      <code class="computeroutput">boost::mutex</code>
      和 C++0x 的 <code class="computeroutput">std::mutex</code>。
    </p>

<p>
      Changing a signal's <code class="computeroutput">Mutex</code> template type parameter can be tedious, due to
      the large number of template parameters which precede it.  The
      <code class="computeroutput"><a class="link" href="../boost/signals2/signal_type.html" title="Class template signal_type">signal_type</a></code> metafunction is particularly useful in this case,
      since it enables named template type parameters for the <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code>
      class.  For example, to declare a signal which takes an <code class="computeroutput">int</code> as
      an argument and uses a <code class="computeroutput"><a class="link" href="../boost/signals2/dummy_mutex.html" title="Class dummy_mutex">boost::signals2::dummy_mutex</a></code>
      for its <code class="computeroutput">Mutex</code> types, you could write:
    </p>

<p>
      更改信号的
      <code class="computeroutput">Mutex</code>
      模板类型参数很烦，
      因为在它之前有许多模板参数。

      这时，<code class="computeroutput"><a class="link" href="../boost/signals2/signal_type.html" title="Class template signal_type">signal_type</a></code>
      元函数（metafunction）就特别有用，
      它开启了
      <code class="computeroutput"><a class="link" href="../boost/signal.html" title="Class template signal">signal</a></code>
      类的命名模板类型参数。
      
      例如，声明一个信号，接收一个 <code class="computeroutput">int</code>
      参数，并使用
      <code class="computeroutput"><a class="link" href="../boost/signals2/dummy_mutex.html" title="Class dummy_mutex">boost::signals2::dummy_mutex</a></code>
      作为其 <code class="computeroutput">Mutex</code>
      类型，你可以这样写：
    </p>

<pre class="programlisting">namespace bs2 = boost::signals2;<br>using bs2::keywords;<br>bs2::signal_type&lt;void (int), mutex_type&lt;bs2::dummy_mutex&gt; &gt;::type sig;<br></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id3353969"></a>Linking against the Signals2 library</h3></div></div></div>

<div class="titlepage"><div><div><h3 class="title">
<a name="id3353969"></a>链接 Signals2 库</h3></div></div></div>

<p>与原 Boost.Signals 库不同，Boost.Signals2 现在是纯头文件的。
    </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"><p><small>Last revised: June 12, 2007 at 14:01:23 -0400</small></p></td>
<td align="right"><div class="copyright-footer">Copyright © 2001-2004 Douglas Gregor<br>Copyright © 2007-2009 Frank Mori Hess

      <p>翻译：<a href="http://blog.csdn.net/jq0123">金庆</a></p>
      <p>译文更新：2009.6.11</p>

    <p>Distributed under the Boost
    Software License, Version 1.0. (See accompanying file
    <code class="filename">LICENSE_1_0.txt</code> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)</p>

</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../signals2.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../signals2.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="examples.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
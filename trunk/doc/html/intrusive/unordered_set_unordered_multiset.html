<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Semi-Intrusive unordered associative containers: unordered_set, unordered_multiset</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../intrusive.html" title="Chapter&nbsp;10.&nbsp;Boost.Intrusive">
<link rel="prev" href="set_multiset.html" title="Intrusive associative containers: set, multiset, rbtree">
<link rel="next" href="splay_set_multiset.html" title="Intrusive splay tree based associative containers: splay_set, splay_multiset and , splay_tree"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="set_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="splay_set_multiset.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="intrusive.unordered_set_unordered_multiset"></a><a class="link" href="file:///E:/Translation/boost_doc/doc/html/intrusive/unordered_set_unordered_multiset.html" title="Semi-Intrusive unordered associative containers: unordered_set, unordered_multiset"> Semi-Intrusive
    unordered associative containers: unordered_set, unordered_multiset 介入式无序关联容器：unordered_set, unordered_multiset</a></h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_performance">
      unordered_set and unordered_multiset performance notes&nbsp;</a></span><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_performance"><span class="section"></span></a><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_performance">
      unordered_set 和 unordered_multiset 的性能说明</a></dt>
<dt><span class="section"><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_hooks">
      unordered_set and unordered_multiset hooks&nbsp;</a></span><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_hooks"><span class="section"></span></a><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_hooks">
      unordered_set 和 unordered_multiset 钩子</a></dt>
<dt><span class="section"><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_containers">
      unordered_set and unordered_multiset containers&nbsp;</a></span><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_containers"><span class="section"></span></a><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_containers">
      unordered_set 和 unordered_multiset 容器</a></dt>
<dt><span class="section"><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_example">
      Example 例子</a></span></dt>
<dt><span class="section"><a href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.custom_bucket_traits">
      Custom bucket traits 定制化桶 traits</a></span></dt>
</dl></div>
<p>
      <span class="bold"><strong>Boost.Intrusive</strong></span> also offers hashed containers
      that can be very useful to implement fast-lookup containers. These containers
      (<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>)
      are semi-intrusive containers: they need additional memory apart from the hook
      stored in the <code class="computeroutput"><span class="identifier">value_type</span></code>. This
      additional memory must be passed in the constructor of the container.<br><span class="bold"><strong>Boost.Intrusive</strong></span> 
也提供了散列容器，对于实现快速查找的容器非常有用。这些容器(<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>)
     是半介入式容器：它们需要除了内部钩子以外的内存。 
    </p>
<p>
      Unlike C++ TR1 unordered associative containers (which are also hashed containers),
      the contents of these semi-intrusive containers are not rehashed to maintain
      a load factor: that would require memory management and intrusive containers
      don't implement any memory management at all. However, the user can request
      an explicit rehashing passing a new bucket array. This also offers an additional
      guarantee over TR1 unordered associative containers: <span class="bold"><strong>iterators
      are not invalidated when inserting an element</strong></span> in the container.<br>和
C++ TR1
无序关联容器(它们也是散列容器)不同，这些半介入式容器中的内容是不能重散列以维护负载因子的：这样会需要内存管理，而介入式容器是不实现任何内存管理
的。不过，用户可以传入一个新的桶数组来请求一次明确的重散列。这种方式也比 TR1 无序关联容器多了一个保证：在容器中<span class="bold"><strong>插入元素时不会导致迭代器失效</strong></span>。
    </p>

<p>
      As with TR1 unordered associative containers, rehashing invalidates iterators,
      changes ordering between elements and changes which buckets elements appear
      in, but does not invalidate pointers or references to elements.<br>和 TR1 无序关联容器一样，重散列会使得迭代器失效，改变元素间的顺序，改变元素所在的桶，但不会导致元素的指针或引用失效。
    </p>
<p>
      Apart from expected hash and equality function objects, <span class="bold"><strong>Boost.Intrusive</strong></span>
      unordered associative containers' constructors take an argument specifying
      an auxiliary bucket vector to be used by the container.<br>除了所需的散列和相等性这两个函数对象以外，<span class="bold"><strong>Boost.Intrusive</strong></span>
      无序关联容器的构造函数还要接受一个参数，指定一个被容器使用的辅助桶 vector。
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_performance"></a><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_performance" title="unordered_set and unordered_multiset performance notes">
      unordered_set and unordered_multiset performance notes&nbsp;</a></h3><h3 class="title"><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_performance" title="unordered_set and unordered_multiset performance notes">unordered_set 和 unordered_multiset 的性能说明</a></h3></div></div></div>
<p>
        The size overhead for a hashed container is moderate: 1 pointer per value
        plus a bucket array per container. The size of an element of the bucket array
        is usually one pointer. To obtain a good performance hashed container, the
        bucket length is usually the same as the number of elements that the container
        contains, so a well-balanced hashed container (<code class="computeroutput"><span class="identifier">bucket_count</span><span class="special">()</span></code> is equal to <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> ) will have an equivalent overhead of two
        pointers per element.<br>散列容器的空间开销为中等：每个值1个指针，再加上每个容器一个桶数组。桶数组中每个元素的大小通常为1个指针。要提供一个优越性能的散列容器，桶的长度通常要和容器中的元素数量相等，因此一个正常的散列容器(<code class="computeroutput"><span class="identifier">bucket_count</span><span class="special">()</span></code> 等于 <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>)的空间开销相当于每个元素2个指针。
      </p>
<p>
        An empty, non constant-time size <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        or <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        has also the size of <code class="computeroutput"><span class="identifier">bucket_count</span><span class="special">()</span></code> pointers.<br>一个空的、不带常量时间 size 的 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 或 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code> 也具有 <code class="computeroutput"><span class="identifier">bucket_count</span><span class="special">()</span></code> 个指针的大小。
      </p>
<p>
        Insertions, erasures, and searches, have amortized constant-time complexity
        in hashed containers. However, some worst-case guarantees are linear. See
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        or <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        for complexity guarantees of each operation.<br>散列容器的插入、删除和查找操作具有分期常量时间复杂度。但是，有些最坏情况的保证为线性复杂度。各个操作的复杂度保证请见 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 或 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>。
      </p>
<p>
        <span class="bold"><strong>Be careful with non constant-time size hashed containers</strong></span>:
        some operations, like <code class="computeroutput"><span class="identifier">empty</span><span class="special">()</span></code>, have linear complexity, unlike other
        <span class="bold"><strong>Boost.Intrusive</strong></span> containers.<br><span class="bold"><strong>留意不带常量时间 size 的散列容器</strong></span>：有些操作，如 <code class="computeroutput"><span class="identifier">empty</span><span class="special">()</span></code>，具有线性复杂度，这与其它
        <span class="bold"><strong>Boost.Intrusive</strong></span> 容器不同。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_hooks"></a><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_hooks" title="unordered_set and unordered_multiset hooks">
      unordered_set and unordered_multiset hooks &nbsp;</a></h3><h3 class="title"><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_hooks" title="unordered_set and unordered_multiset hooks">unordered_set 和 unordered_multiset 钩子</a>
</h3></div></div></div>

<p>
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        share the same hooks. This is an advantage, because the same user type can
        be inserted first in a <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        and after that in <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        without changing the definition of the user class.<br><code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>&nbsp;共享相同的钩子。这是一个优点，因为同一个用户类型可以先被插入到 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code><code class="computeroutput"><a class="link" title="Class template multiset" href="../boost/intrusive/multiset.html"></a></code> 中，然后再插入到 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 中，而无需修改用户类的定义。</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="special">...</span><span class="identifier">Options</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unordered_set_base_hook</span><span class="special">;</span>
</pre>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook">unordered_set_base_hook</a></code>:
          the user class derives publicly from <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook">unordered_set_base_hook</a></code>
          to make it <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>-compatible.<br><code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook">unordered_set_base_hook</a></code>:
          用户类公有派生自 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook">unordered_set_base_hook</a></code>&nbsp;以兼容于&nbsp;<a class="link" title="Class template set" href="../boost/intrusive/set.html"><code class="computeroutput"></code></a><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a>/<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code> 
        </li></ul></div>
<p>
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="special">...</span><span class="identifier">Options</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unordered_set_member_hook</span><span class="special">;</span>
</pre>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_member_hook.html" title="Class template unordered_set_member_hook">unordered_set_member_hook</a></code>:
          the user class contains a public <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_member_hook.html" title="Class template unordered_set_member_hook">unordered_set_member_hook</a></code>
          to make it <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>-compatible.<br><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook"><code class="computeroutput"></code></a><a class="link" href="../boost/intrusive/unordered_set_member_hook.html" title="Class template unordered_set_member_hook">unordered_set_member_hook</a>:
          用户类包含一个公有的 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_member_hook.html" title="Class template unordered_set_member_hook">unordered_set_member_hook</a></code><code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook"></a></code>&nbsp;以兼容于 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>/<code class="computeroutput"></code><code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code><code class="computeroutput"></code>。
        </li></ul></div>
<p>
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook">unordered_set_base_hook</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_member_hook.html" title="Class template unordered_set_member_hook">unordered_set_member_hook</a></code>
        receive the same options explained in the section <a class="link" href="usage.html" title="How to use Boost.Intrusive">How
        to use Boost.Intrusive</a>:<br><code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_base_hook.html" title="Class template unordered_set_base_hook">unordered_set_base_hook</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set_member_hook.html" title="Class template unordered_set_member_hook">unordered_set_member_hook</a></code>&nbsp;接受在 <a class="link" title="How to use Boost.Intrusive" href="usage.html">如何使用 
Boost.Intrusive</a> 一节中说明的各种选项：&nbsp; 
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">tag</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Tag</span><span class="special">&gt;</span></code></strong></span>
          (for base hooks only): This argument serves as a tag, so you can derive
          from more than one base hook. Default: <code class="computeroutput"><span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">default_tag</span><span class="special">&gt;</span></code>.<br><span class="bold"><strong><code class="computeroutput"><span class="identifier">tag</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Tag</span><span class="special">&gt;</span></code></strong></span> (只用于基类钩子)：该参数作为一个标记，你可以派生自多个 
slist 钩子。缺省值：<code class="computeroutput"><span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">default_tag</span><span class="special">&gt;</span></code>. 
        </li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">link_mode</span><span class="special">&lt;</span><span class="identifier">link_mode_type</span>
          <span class="identifier">LinkMode</span><span class="special">&gt;</span></code></strong></span>:
          The linking policy. Default: <code class="computeroutput"><span class="identifier">link_mode</span><span class="special">&lt;</span><span class="identifier">safe_link</span><span class="special">&gt;</span></code>.<br><span class="bold"><strong><code class="computeroutput"><span class="identifier">link_mode</span><span class="special">&lt;</span><span class="identifier">link_mode_type</span> <span class="identifier">LinkMode</span><span class="special">&gt;</span></code></strong></span>: 链接策略。缺省值：<code class="computeroutput"><span class="identifier">link_mode</span><span class="special">&lt;</span><span class="identifier">safe_link</span><span class="special">&gt;</span></code>. 
        </li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">void_pointer</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">VoidPointer</span><span class="special">&gt;</span></code></strong></span>:
          The pointer type to be used internally in the hook and propagated to the
          container. Default: <code class="computeroutput"><span class="identifier">void_pointer</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">*&gt;</span></code>.<br><span class="bold"><strong><code class="computeroutput"><span class="identifier">void_pointer</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">VoidPointer</span><span class="special">&gt;</span></code></strong></span>: 在钩子内部使用并被传递给容器的指针类型。缺省值：<code class="computeroutput"><span class="identifier">void_pointer</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">*&gt;</span></code>. 
        </li>
</ul></div>
<p>
        Apart from them, these hooks offer additional options:<br>除此之外，这些钩子还提供了其它选项：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">store_hash</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          This option reserves additional space in the hook to store the hash value
          of the object once it's introduced in the container. When this option is
          used, the unordered container will store the calculated hash value in the
          hook and rehashing operations won't need to recalculate the hash of the
          value. This option will improve the perfomance of unordered containers
          when rehashing is frequent or hashing the value is a slow operation. Default:
          <code class="computeroutput"><span class="identifier">store_hash</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>.<br><span class="bold"><strong><code class="computeroutput"><span class="identifier">store_hash</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: 这一选项在钩子中保留额外的空间，在对象被加入到容器中时保存它的散列值。使用该选项时，无序容器将已经计算过的散列值保存在钩子中，这样在进行重散列时就无需重新计算散列值。如果重散列频繁或散列值的计算较慢，则这一选项可以提高无序容器的性能。缺省值：<code class="computeroutput"><span class="identifier">store_hash</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>.
        </li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">optimize_multikey</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          This option reserves additional space in the hook that will be used to
          group equal elements in unordered multisets, improving significantly the
          performance when many equal values are inserted in these containers. Default:
          <code class="computeroutput"><span class="identifier">optimize_multikey</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>.<br><span class="bold"><strong><code class="computeroutput"><span class="identifier">optimize_</span></code></strong></span><span class="bold"><strong><code class="computeroutput"><span class="identifier">multikey</span><span class="special"></span></code></strong></span><span class="bold"><strong><code class="computeroutput"><span class="identifier"></span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: 
这一选项在钩子中保留额外的空间，用于将无序 multiset 中的相等元素聚在一起，当向容器中插入大量相等元素时，该选项可以显著改进性能。缺省值：<code class="computeroutput"><span class="identifier">optimize_</span></code><code class="computeroutput"><span class="identifier">multikey</span><span class="special"></span></code><code class="computeroutput"><span class="identifier"></span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code><code class="computeroutput"><span class="special"></span></code>.&nbsp;<span class="bold"><strong><code class="computeroutput"><span class="identifier"></span></code></strong></span>
        </li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_containers"></a><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_containers" title="unordered_set and unordered_multiset containers">
      unordered_set and unordered_multiset containers &nbsp;</a></h3><h3 class="title"><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_containers" title="unordered_set and unordered_multiset containers">unordered_set 和 unordered_multiset 容器</a>
</h3></div></div></div>
<p>
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="special">...</span><span class="identifier">Options</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unordered_set</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="special">...</span><span class="identifier">Options</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unordered_multiset</span><span class="special">;</span>
</pre>

<p>
        As mentioned, unordered containers need an auxiliary array to work. <span class="bold"><strong>Boost.Intrusive</strong></span> unordered containers receive this
        auxiliary array packed in a type called <code class="computeroutput"><span class="identifier">bucket_traits</span></code>
        (which can be also customized by a container option). All unordered containers
        receive a <code class="computeroutput"><span class="identifier">bucket_traits</span></code> object
        in their constructors. The default <code class="computeroutput"><span class="identifier">bucket_traits</span></code>
        class is initialized with a pointer to an array of buckets and its size:<br>如上所述，无序容器需要一个辅助的数组来工作。<span class="bold"><strong>Boost.Intrusive</strong></span> 无序容器接受一个包装在 <code class="computeroutput"><span class="identifier">bucket_traits</span></code>
        (也可以由容器的选项来定制化)类型中的辅助数组。所有无序容器在它们的构造函数中接受一个 <code class="computeroutput"><span class="identifier">bucket_traits</span></code> 对象。缺省的 <code class="computeroutput"><span class="identifier">bucket_traits</span></code>
        类以一个桶数组指针及其大小来初始化：</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">MyClass</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">unordered_set_base_hook</span><span class="special">&lt;&gt;</span>
<span class="special">{};</span>

<span class="keyword">typedef</span> <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">bucket_type</span>     <span class="identifier">bucket_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">bucket_traits</span>   <span class="identifier">bucket_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
   <span class="identifier">bucket_type</span> <span class="identifier">buckets</span><span class="special">[</span><span class="number">100</span><span class="special">];</span>
   <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="identifier">uset</span><span class="special">(</span><span class="identifier">bucket_traits</span><span class="special">(</span><span class="identifier">buckets</span><span class="special">,</span> <span class="number">100</span><span class="special">));</span>
   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Each hashed container needs <span class="bold"><strong>its own bucket traits</strong></span>,
        that is, <span class="bold"><strong>its own bucket vector</strong></span>. Two hashed
        containers <span class="bold"><strong>can't</strong></span> share the same <code class="computeroutput"><span class="identifier">bucket_type</span></code> elements. The bucket array
        <span class="bold"><strong>must</strong></span> be destroyed <span class="bold"><strong>after</strong></span>
        the container using it is destroyed, otherwise, the result is undefined.<br>散列容器需要<span class="bold"><strong>它自己的桶 traits</strong></span>，即是<span class="bold"><strong>它自己的桶 vector</strong></span>。两个散列容器<span class="bold"><strong>不能</strong></span>共享同一个 <code class="computeroutput"><span class="identifier">bucket_type</span></code> 元素。桶数组<span class="bold"><strong>必须</strong></span>在使用它的容器被销毁<span class="bold"><strong>之后</strong></span>销毁，否则，结果将是未定义的。
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        receive the same options explained in the section <a class="link" href="usage.html" title="How to use Boost.Intrusive">How
        to use Boost.Intrusive</a>:<br><code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>&nbsp;接受在 <a class="link" title="How to use Boost.Intrusive" href="usage.html">如何使用 
Boost.Intrusive</a> 一节中说明的选项：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">base_hook</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Hook</span><span class="special">&gt;</span></code></strong></span>
          / <span class="bold"><strong><code class="computeroutput"><span class="identifier">member_hook</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span>
          <span class="identifier">Hook</span><span class="special">,</span>
          <span class="identifier">Hook</span> <span class="identifier">T</span><span class="special">::*</span> <span class="identifier">PtrToMember</span><span class="special">&gt;</span></code></strong></span> / <span class="bold"><strong><code class="computeroutput"><span class="identifier">value_traits</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ValueTraits</span><span class="special">&gt;</span></code></strong></span>: To specify the hook type
          or value traits used to configure the container. (To learn about value
          traits go to the section <a class="link" href="value_traits.html" title="Containers with custom ValueTraits">Containers
          with custom ValueTraits</a>.)<br><span class="bold"><strong><code class="computeroutput"><span class="identifier">base_hook</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Hook</span><span class="special">&gt;</span></code></strong></span> / <span class="bold"><strong><code class="computeroutput"><span class="identifier">member_hook</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Hook</span><span class="special">,</span> <span class="identifier">Hook</span> <span class="identifier">T</span><span class="special">::*</span> <span class="identifier">PtrToMember</span><span class="special">&gt;</span></code></strong></span> / <span class="bold"><strong><code class="computeroutput"><span class="identifier">value_traits</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ValueTraits</span><span class="special">&gt;</span></code></strong></span>: 指定用于配置容器的钩子类型或 value 
traits。(要学习有关 value traits 的知识，请见 <a class="link" title="Containers with custom ValueTraits" href="value_traits.html">带定制化 
ValueTraits 的容器</a>) 
        </li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">constant_time_size</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          To activate the constant-time <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> operation. Default: <code class="computeroutput"><span class="identifier">constant_time_size</span><span class="special">&lt;</span><span class="keyword">true</span><span class="special">&gt;</span></code><br><span class="bold"><strong><code class="computeroutput"><span class="identifier">constant_time_size</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: 激活常量时间的 <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> 操作。缺省值：<code class="computeroutput"><span class="identifier">constant_time_size</span><span class="special">&lt;</span><span class="keyword">true</span><span class="special">&gt;</span></code>
</li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">size_type</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          To specify the type that will be used to store the size of the container.
          Default: <code class="computeroutput"><span class="identifier">size_type</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;</span></code><br><span class="bold"><strong><code class="computeroutput"><span class="identifier">size_type</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: 指定用于保存容器大小的类型。缺省值：<code class="computeroutput"><span class="identifier">size_type</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;</span></code>. 
</li>
</ul></div>
<p>
        And they also can receive additional options:<br><code class="computeroutput"></code>它们还可以接受其它选项： 
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">equal</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Equal</span><span class="special">&gt;</span></code></strong></span>:
          Equality function for the objects to be inserted in containers. Default:
          <code class="computeroutput"><span class="identifier">equal</span><span class="special">&lt;</span>
          <span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span></code><br><code class="computeroutput"></code><span class="bold"><strong><code class="computeroutput"><span class="identifier">equal</span></code></strong></span><span class="bold"><strong><code class="computeroutput"><span class="identifier"></span><span class="special">&lt;</span><span class="keyword">class</span>&nbsp;</code></strong></span><span class="bold"><strong><code class="computeroutput"><span class="identifier">Equal</span><span class="special">&gt;</span></code></strong></span>: 
被插入到容器中的对象所用的相等性函数。缺省值：<code class="computeroutput"><span class="identifier">equal</span><span class="special">&lt;</span>
          <span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>
</li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">hash</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Hash</span><span class="special">&gt;</span></code></strong></span>:
          Hash function to be used in the container. Default: <code class="computeroutput"><span class="identifier">hash</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span></code><br><code class="computeroutput"></code><span class="bold"><strong><code class="computeroutput"><span class="identifier">hash</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Hash</span><span class="special">&gt;</span></code></strong></span>: 容器所用的散列函数。缺省值：<code class="computeroutput"><span class="identifier">hash</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>
</li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">bucket_traits</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BucketTraits</span><span class="special">&gt;</span></code></strong></span>:
          A type that wraps the bucket vector to be used by the unordered container.
          Default: a type initialized by the address and size of a bucket array and
          stores both variables internally.<br><code class="computeroutput"></code><span class="bold"><strong><code class="computeroutput"><span class="identifier">bucket_traits</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">BucketTraits</span><span class="special">&gt;</span></code></strong></span>:
          无序容器所用的某个包装了桶 vector 的类型。缺省值：一个由桶数组的地址及大小进行初始化并在内部保存这两个变量的类型。
        </li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">power_2_buckets</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          The user guarantees that only bucket arrays with power of two length will
          be used. The container will then use masks instead of modulo operations
          to obtain the bucket number from the hash value. Masks are faster than
          modulo operations and for some applications modulo operations can impose
          a considerable overhead. In debug mode an assertion will be raised if the
          user provides a bucket length that is not power of two. Default: <code class="computeroutput"><span class="identifier">power_2_buckets</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>.<br><code class="computeroutput"></code><span class="bold"><strong><code class="computeroutput"><span class="identifier">power_2_buckets</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          用户保证只使用长度为2的幂数的桶数组。容器将使用掩码操作代替模操作来从散列值获得桶的数字。掩码操作比模操作更快，对于某些应用来说，模操作会带来显著的开销。在调试模式下，如果用户提供的桶的长度不是2的幂数，将引起一个断言。缺省值：<code class="computeroutput"><span class="identifier">power_2_buckets</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>.
        </li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">cache_begin</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          <span class="bold"><strong>Note: this option is not compatible with <code class="computeroutput"><span class="identifier">auto_unlink</span></code> 
hooks</strong></span>. Due to its internal structure, finding the first element of an unordered
          container (<code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
          operation) is amortized constant-time. It's possible to speed up <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
          and other operations related to it (like <code class="computeroutput"><span class="identifier">clear</span><span class="special">()</span></code>) if the container caches internally the
          position of the first element. This imposes the overhead of one pointer
          to the size of the container. Default: <code class="computeroutput"><span class="identifier">cache_begin</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>.<br><code class="computeroutput"></code><span class="bold"><strong><code class="computeroutput"><span class="identifier">cache_begin</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: <span class="bold"><strong>注意：该选项与 <code class="computeroutput"><span class="identifier">auto_unlink</span></code> 
钩子相互不兼容。</strong></span>由于内部结构的原因，查找无序容器的第一个元素(<code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
          操作)是分期常量时间复杂度的。如果容器在内部对第一个元素的位置进行缓存，那么就可以提高 <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
          和其它相关操作(如 <code class="computeroutput"><span class="identifier">clear</span><span class="special">()</span></code>)的速度。这意味着容器的大小要增加1个指针的开销。缺省值：<code class="computeroutput"><span class="identifier">cache_begin</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>.
        </li>
<li>
<span class="bold"><strong><code class="computeroutput"><span class="identifier">compare_hash</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>:
          <span class="bold"><strong>Note: this option requires <code class="computeroutput"><span class="identifier">store_hash</span><span class="special">&lt;</span><span class="keyword">true</span><span class="special">&gt;</span></code> option in the hook</strong></span>. When
          the comparison function is expensive, (e.g. strings with a long common
          predicate) sometimes (specially when the load factor is high or we have
          many equivalent elements in an <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
          and no <code class="computeroutput"><span class="identifier">optimize_multikey</span><span class="special">&lt;&gt;</span></code> is activatedin the hook) the equality
          function is a performance problem. Two equal values must have equal hashes,
          so comparing the hash values of two elements before using the comparison
          functor can speed up some implementations.<br><code class="computeroutput"></code><span class="bold"><strong><code class="computeroutput"><span class="identifier">compare_hash</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: <span style="font-weight: bold;">注意：本选项要求钩子中使用</span><span class="bold"><strong> <code class="computeroutput"><span class="identifier">store_hash</span><span class="special">&lt;</span><span class="keyword">true</span><span class="special">&gt;</span></code> 选项</strong></span>。如果比较函数开销较大(如带有常见谓词的字符串)，有时(尤其是负载因子较高或在 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
          中有很多相等元素且钩子中没有激活 <code class="computeroutput"><span class="identifier">optimize_multikey</span><span class="special">&lt;&gt;</span></code> 的时候)相等性函数会存在性能的问题。两个相等的值必然具有相等的散列值，所以在使用比较函数对象之前先比较散列值可以加快某些实现的速度。</li><li><span class="bold"><strong><code class="computeroutput"><span class="identifier">incremental</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: Activates incremental hashing 
(also known as Linear Hashing). This option implies <code class="computeroutput"><span class="identifier">power_2_buckets</span><span class="special">&lt;</span><span class="keyword">true</span><span class="special">&gt;</span></code> and the container will require power of two 
buckets. For more information on incremental hashing, see <a href="http://en.wikipedia.org/wiki/Linear_hashing" target="_top"><code class="computeroutput"><span class="identifier">Linear</span> <span class="identifier">hash</span></code> on Wikipedia</a> Default: <code class="computeroutput"><span class="identifier">incremental</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>
        <br><code class="computeroutput"></code><span class="bold"><strong><code class="computeroutput"><span class="identifier">incremental</span><span class="special">&lt;</span><span class="keyword">bool</span> <span class="identifier">Enabled</span><span class="special">&gt;</span></code></strong></span>: 激活递增散列(又称线性散列)。该选项意味着 <code class="computeroutput"><span class="identifier">power_2_buckets</span><span class="special">&lt;</span><span class="keyword">true</span><span class="special">&gt;</span></code> 以及该容器将要求桶数量为2的幂数。有关递增散列的更多信息，请见 <a href="http://en.wikipedia.org/wiki/Linear_hashing" target="_top"><code class="computeroutput"><span class="identifier">Linear</span> <span class="identifier">hash</span></code> on Wikipedia</a>。缺省值：<code class="computeroutput"><span class="identifier">incremental</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span></code>
</li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_example"></a><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.unordered_set_unordered_multiset_example" title="Example">
      Example 例子</a>
</h3></div></div></div>


<p>
        Now let's see a small example using both hooks and both containers:<br>现在我们来看一个使用这些钩子和容器的小例子：</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">algorithm</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">functional</span><span class="special">/</span><span class="identifier">hash</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span>

<span class="keyword">class</span> <span class="identifier">MyClass</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">unordered_set_base_hook</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>               <span class="comment">//This is a derivation hook<br></span>   <span class="keyword">int</span> <span class="identifier">int_</span><span class="special">;</span>

   <span class="keyword">public</span><span class="special">:</span>
   <span class="identifier">unordered_set_member_hook</span><span class="special">&lt;&gt;</span> <span class="identifier">member_hook_</span><span class="special">;</span> <span class="comment">//This is a member hook<br></span>
   <span class="identifier">MyClass</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span>
      <span class="special">:</span>  <span class="identifier">int_</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span>
   <span class="special">{}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">int_</span> <span class="special">==</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">int_</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">hash_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">value</span><span class="special">)</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">(</span><span class="identifier">value</span><span class="special">.</span><span class="identifier">int_</span><span class="special">);</span> <span class="special">}</span>
<span class="special">};</span>

<span class="comment">//Define an unordered_set that will store MyClass objects using the base hook<br></span><span class="keyword">typedef</span> <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span>    <span class="identifier">BaseSet</span><span class="special">;</span>

<span class="comment">//Define an unordered_multiset that will store MyClass using the member hook<br></span><span class="keyword">typedef</span> <span class="identifier">member_hook</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">,</span> <span class="identifier">unordered_set_member_hook</span><span class="special">&lt;&gt;,</span> <span class="special">&amp;</span><span class="identifier">MyClass</span><span class="special">::</span><span class="identifier">member_hook_</span><span class="special">&gt;</span>
   <span class="identifier">MemberOption</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">unordered_multiset</span><span class="special">&lt;</span> <span class="identifier">MyClass</span><span class="special">,</span> <span class="identifier">MemberOption</span><span class="special">&gt;</span>  <span class="identifier">MemberMultiSet</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
   <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">VectIt</span><span class="special">;</span>
   <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">reverse_iterator</span> <span class="identifier">VectRit</span><span class="special">;</span>

   <span class="comment">//Create a vector with 100 different MyClass objects<br></span>   <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="identifier">values</span><span class="special">;</span>
   <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">100</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>  <span class="identifier">values</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">MyClass</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span>

   <span class="comment">//Create a copy of the vector<br></span>   <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="identifier">values2</span><span class="special">(</span><span class="identifier">values</span><span class="special">);</span>

   <span class="comment">//Create a bucket array for base_set<br></span>   <span class="identifier">BaseSet</span><span class="special">::</span><span class="identifier">bucket_type</span> <span class="identifier">base_buckets</span><span class="special">[</span><span class="number">100</span><span class="special">];</span>

   <span class="comment">//Create a bucket array for member_multi_set<br></span>   <span class="identifier">MemberMultiSet</span><span class="special">::</span><span class="identifier">bucket_type</span> <span class="identifier">member_buckets</span><span class="special">[</span><span class="number">200</span><span class="special">];</span>

   <span class="comment">//Create unordered containers taking buckets as arguments<br></span>   <span class="identifier">BaseSet</span> <span class="identifier">base_set</span><span class="special">(</span><span class="identifier">BaseSet</span><span class="special">::</span><span class="identifier">bucket_traits</span><span class="special">(</span><span class="identifier">base_buckets</span><span class="special">,</span> <span class="number">100</span><span class="special">));</span>
   <span class="identifier">MemberMultiSet</span> <span class="identifier">member_multi_set</span>
      <span class="special">(</span><span class="identifier">MemberMultiSet</span><span class="special">::</span><span class="identifier">bucket_traits</span><span class="special">(</span><span class="identifier">member_buckets</span><span class="special">,</span> <span class="number">200</span><span class="special">));</span>

   <span class="comment">//Now insert values's elements in the unordered_set<br></span>   <span class="keyword">for</span><span class="special">(</span><span class="identifier">VectIt</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span> <span class="identifier">itend</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">itend</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
      <span class="identifier">base_set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">it</span><span class="special">);</span>

   <span class="comment">//Now insert values's and values2's elements in the unordered_multiset<br></span>   <span class="keyword">for</span><span class="special">(</span><span class="identifier">VectIt</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span> <span class="identifier">itend</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">end</span><span class="special">()),</span>
             <span class="identifier">it2</span><span class="special">(</span><span class="identifier">values2</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span><span class="identifier">itend2</span><span class="special">(</span><span class="identifier">values2</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span>
      <span class="special">;</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">itend</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it</span><span class="special">,</span> <span class="special">++</span><span class="identifier">it2</span><span class="special">){</span>
      <span class="identifier">member_multi_set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">it</span><span class="special">);</span>
      <span class="identifier">member_multi_set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">it2</span><span class="special">);</span>
   <span class="special">}</span>

   <span class="comment">//Now find every element<br></span>   <span class="special">{</span>
      <span class="identifier">VectIt</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span> <span class="identifier">itend</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>

      <span class="keyword">for</span><span class="special">(;</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">itend</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it</span><span class="special">){</span>
         <span class="comment">//base_set should contain one element for each key<br></span>         <span class="keyword">if</span><span class="special">(</span><span class="identifier">base_set</span><span class="special">.</span><span class="identifier">count</span><span class="special">(*</span><span class="identifier">it</span><span class="special">)</span> <span class="special">!=</span> <span class="number">1</span><span class="special">)</span>           <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
         <span class="comment">//member_multi_set should contain two elements for each key<br></span>         <span class="keyword">if</span><span class="special">(</span><span class="identifier">member_multi_set</span><span class="special">.</span><span class="identifier">count</span><span class="special">(*</span><span class="identifier">it</span><span class="special">)</span> <span class="special">!=</span> <span class="number">2</span><span class="special">)</span>   <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
      <span class="special">}</span>
   <span class="special">}</span>
   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.unordered_set_unordered_multiset.custom_bucket_traits"></a><a class="link" href="unordered_set_unordered_multiset.html#intrusive.unordered_set_unordered_multiset.custom_bucket_traits" title="Custom bucket traits">
      Custom bucket traits 定制化桶 traits</a>
</h3></div></div></div>

<p>
        Instead of using the default <code class="computeroutput"><span class="identifier">bucket_traits</span></code>
        class to store the bucket array, a user can define his own class to store
        the bucket array using the <span class="bold"><strong><span class="emphasis"><em>bucket_traits&lt;&gt;</em></span></strong></span>
        option. A user-defined bucket-traits must fulfill the following interface:<br>除了使用缺省的 <code class="computeroutput"><span class="identifier">bucket_traits</span></code>
        类来保存桶数组以外，用户也可以使用 <span class="bold"><strong><span class="emphasis"><em>bucket_traits&lt;&gt;</em></span></strong></span>
        选项来定义自己的类，以保存桶数组。用户自定义的 bucket-traits 必须遵守以下接口：
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_bucket_traits</span>
<span class="special">{</span>
   <span class="identifier">bucket_ptr</span>        <span class="identifier">bucket_begin</span><span class="special">();</span>
   <span class="identifier">const_bucket_ptr</span>  <span class="identifier">bucket_begin</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bucket_count</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>


<p>
        The following bucket traits just stores a pointer to the bucket array but
        the size is a compile-time constant. Note the use of the auxiliary <code class="computeroutput">unordered_bucket</code> and
        <code class="computeroutput">unordered_bucket_ptr</code>
        utilities to obtain the type of the bucket and its pointer before defining
        the unordered container:<br>以下的桶 traits 只保存一个桶数组的指针，而桶数组的大小是一个编译期常数。注意，在定义无序容器之前，使用辅助的 <code class="computeroutput">unordered_bucket</code> 和
        <code class="computeroutput">unordered_bucket_ptr</code>
        工具可以得到桶的类型及其指针：</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">functional</span><span class="special">/</span><span class="identifier">hash</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span>

<span class="comment">//A class to be inserted in an unordered_set 插入到 unordered_set 中的一个类<br></span><span class="keyword">class</span> <span class="identifier">MyClass</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">unordered_set_base_hook</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>
   <span class="keyword">int</span> <span class="identifier">int_</span><span class="special">;</span>

   <span class="keyword">public</span><span class="special">:</span>
   <span class="identifier">MyClass</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">int_</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span>
   <span class="special">{}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">l</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">r</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">l</span><span class="special">.</span><span class="identifier">int_</span> <span class="special">==</span> <span class="identifier">r</span><span class="special">.</span><span class="identifier">int_</span><span class="special">;</span>   <span class="special">}</span>
   <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">hash_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">v</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash_value</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">int_</span><span class="special">);</span> <span class="special">}</span>
<span class="special">};</span>

<span class="comment">//Define the base hook option 定义基类钩子选项<br></span><span class="keyword">typedef</span> <span class="identifier">base_hook</span><span class="special">&lt;</span> <span class="identifier">unordered_set_base_hook</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span>     <span class="identifier">BaseHookOption</span><span class="special">;</span>

<span class="comment">//Obtain the types of the bucket and the bucket pointer 获得桶的类型和桶的指针<br></span><span class="keyword">typedef</span> <span class="identifier">unordered_bucket</span><span class="special">&lt;</span><span class="identifier">BaseHookOption</span><span class="special">&gt;::</span><span class="identifier">type</span>     <span class="identifier">BucketType</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">unordered_bucket_ptr</span><span class="special">&lt;</span><span class="identifier">BaseHookOption</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">BucketPtr</span><span class="special">;</span>

<span class="comment">//The custom bucket traits. 定制化的桶 traits<br></span><span class="keyword">class</span> <span class="identifier">custom_bucket_traits</span>
<span class="special">{</span>
   <span class="keyword">public</span><span class="special">:</span>
   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">NumBuckets</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>

   <span class="identifier">custom_bucket_traits</span><span class="special">(</span><span class="identifier">BucketPtr</span> <span class="identifier">buckets</span><span class="special">)</span>
      <span class="special">:</span>  <span class="identifier">buckets_</span><span class="special">(</span><span class="identifier">buckets</span><span class="special">)</span>
   <span class="special">{}</span>

   <span class="comment">//Functions to be implemented by custom bucket traits 由定制化的桶 traits 所实现的函数<br></span>   <span class="identifier">BucketPtr</span>   <span class="identifier">bucket_begin</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">buckets_</span><span class="special">;</span>  <span class="special">}</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bucket_count</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">NumBuckets</span><span class="special">;}</span>

   <span class="keyword">private</span><span class="special">:</span>
   <span class="identifier">BucketPtr</span> <span class="identifier">buckets_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">//Define the container using the custom bucket traits 使用定制化的桶 traits 定义容器<br></span><span class="keyword">typedef</span> <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">,</span> <span class="identifier">bucket_traits</span><span class="special">&lt;</span><span class="identifier">custom_bucket_traits</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">BucketTraitsUset</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
   <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">VectIt</span><span class="special">;</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="identifier">values</span><span class="special">;</span>

   <span class="comment">//Fill values 填充值<br></span>   <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">100</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>  <span class="identifier">values</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">MyClass</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span>

   <span class="comment">//Now create the bucket array and the custom bucket traits object 现在创建桶数组和定制化的桶 traits 对象<br></span>   <span class="identifier">BucketType</span> <span class="identifier">buckets</span><span class="special">[</span><span class="identifier">custom_bucket_traits</span><span class="special">::</span><span class="identifier">NumBuckets</span><span class="special">];</span>
   <span class="identifier">custom_bucket_traits</span> <span class="identifier">btraits</span><span class="special">(</span><span class="identifier">buckets</span><span class="special">);</span>

   <span class="comment">//Now create the unordered set 现在创建无序集合<br></span>   <span class="identifier">BucketTraitsUset</span> <span class="identifier">uset</span><span class="special">(</span><span class="identifier">btraits</span><span class="special">);</span>

   <span class="comment">//Insert the values in the unordered set 将值插入到无序集合中<br></span>   <span class="keyword">for</span><span class="special">(</span><span class="identifier">VectIt</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span> <span class="identifier">itend</span><span class="special">(</span><span class="identifier">values</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">itend</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
      <span class="identifier">uset</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">it</span><span class="special">);</span>

   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 Olaf Krzikalla, 2006-2007 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="set_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="splay_set_multiset.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Advanced lookup and insertion functions for associative containers</title><link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../intrusive.html" title="Chapter&nbsp;10.&nbsp;Boost.Intrusive">
<link rel="prev" href="sg_set_multiset.html" title="Intrusive scapegoat tree based associative containers: sg_set, sg_multiset and sgtree">
<link rel="next" href="erasing_and_disposing.html" title="Erasing and disposing values from Boost.Intrusive containers"></head>
<body alink="#0000ff" bgcolor="white" link="#0000ff" text="black" vlink="#840084">
<table cellpadding="2" width="100%"><tbody><tr>
<td valign="top"><img alt="Boost C++ Libraries" src="../../../boost.png" height="86" width="277"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sg_set_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="erasing_and_disposing.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="intrusive.advanced_lookups_insertions"></a><a class="link" href="advanced_lookups_insertions.html" title="Advanced lookup and insertion functions for associative containers"> Advanced lookup
    and insertion functions for associative containers 关联容器的高级查找和插入函数</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_lookups">
      Advanced lookups 高级查找</a></span></dt>
<dt><span class="section"><a href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_insertions">
      Advanced insertions 高级插入</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.advanced_lookups_insertions.advanced_lookups"></a><a class="link" href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_lookups" title="Advanced lookups">
      Advanced lookups 高级查找</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Intrusive</strong></span> associative containers offer
        the same interface as STL associative containers. However, STL and TR1 ordered
        and unordered simple associative containers (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code>,
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_multiset</span></code>) have some inefficiencies
        caused by the interface: the user can only operate with <code class="computeroutput"><span class="identifier">value_type</span></code>
        objects. When using these containers we must use <code class="computeroutput"><span class="identifier">iterator</span>
        <span class="identifier">find</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span>
        <span class="special">&amp;</span><span class="identifier">value</span><span class="special">)</span></code> to find a value. The same happens in other
        functions like <code class="computeroutput"><span class="identifier">equal_range</span></code>,
        <code class="computeroutput"><span class="identifier">lower_bound</span></code>, <code class="computeroutput"><span class="identifier">upper_bound</span></code>, etc.<br><span class="bold"><strong>Boost.Intrusive</strong></span> 关联容器提供了和 STL 关联容器一样的接口。但是，STL 和 TR1 的有序及无序简单关联容器(<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code>,
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code> 和 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_multiset</span></code>)因为其接口而显得有些低效：用户只能操作 <code class="computeroutput"><span class="identifier">value_type</span></code>
        对象。在使用这些容器时，我们必须用 <code class="computeroutput"><span class="identifier">iterator</span>
        <span class="identifier">find</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span>
        <span class="special">&amp;</span><span class="identifier">value</span><span class="special">)</span></code> 来查找一个值。对于其它函数也一样，如 <code class="computeroutput"><span class="identifier">equal_range</span></code>,
        <code class="computeroutput"><span class="identifier">lower_bound</span></code>, <code class="computeroutput"><span class="identifier">upper_bound</span></code>, 等等。
      </p>


<p>
        However, sometimes the object to be searched is quite expensive to construct:<br>但是有时候，被查找的对象的构造非常昂贵：</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cstring</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span>

<span class="comment">// Hash function for strings 字符串的散列函数<br></span><span class="keyword">struct</span> <span class="identifier">StrHasher</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <br>      <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">seed</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
      <span class="keyword">for</span><span class="special">(;</span> <span class="special">*</span><span class="identifier">str</span><span class="special">;</span> <span class="special">++</span><span class="identifier">str</span><span class="special">)</span>   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash_combine</span><span class="special">(</span><span class="identifier">seed</span><span class="special">,</span> <span class="special">*</span><span class="identifier">str</span><span class="special">);</span>
      <span class="keyword">return</span> <span class="identifier">seed</span><span class="special">;</span>
   <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">Expensive</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">set_base_hook</span><span class="special">&lt;&gt;,</span> <span class="keyword">public</span> <span class="identifier">unordered_set_base_hook</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">key_</span><span class="special">;</span>
   <span class="comment">// Other members... 其它成员<br></span>  <br>   <span class="keyword">public</span><span class="special">:</span>
   <span class="identifier">Expensive</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">key</span><span class="special">)</span>
      <span class="special">:</span>  <span class="identifier">key_</span><span class="special">(</span><span class="identifier">key</span><span class="special">)</span>
      <span class="special">{}</span>  <span class="comment">//other expensive initializations... 其它代价昂贵的初始化动作...<br></span>
   <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span> <span class="identifier">get_key</span><span class="special">()</span> <span class="keyword">const</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">key_</span><span class="special">;</span>   <span class="special">}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">&lt;</span>  <span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">key_</span> <span class="special">&lt;</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">key_</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">==</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">key_</span> <span class="special">==</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">key_</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">hash_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">object</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">StrHasher</span><span class="special">()(</span><span class="identifier">object</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">());</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// A set and unordered_set that store Expensive objects 保存 Expensive 对象的 set 和 unordered_set<br></span><span class="keyword">typedef</span> <span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">Expensive</span><span class="special">&gt;</span>           <span class="identifier">Set</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">Expensive</span><span class="special">&gt;</span> <span class="identifier">UnorderedSet</span><span class="special">;</span>

<span class="comment">// Search functions 查找函数<br></span><span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_set</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">));</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>     <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_uset</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">Expensive</span> <span class="special">(</span><span class="identifier">key</span><span class="special">));</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>
</pre>


<p>
      <code class="computeroutput"><span class="identifier">Expensive</span></code> is an expensive
        object to construct. If "key" c-string is quite long <code class="computeroutput"><span class="identifier">Expensive</span></code> has to construct a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        using heap memory. Like <code class="computeroutput"><span class="identifier">Expensive</span></code>,
        many times the only member taking part in ordering issues is just a small
        part of the class. For example, with <code class="computeroutput"><span class="identifier">Expensive</span></code>,
        only the internal <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> is needed to compare the object.<br><code class="computeroutput"><span class="identifier">Expensive</span></code> 是一个构造代价昂贵的对象。如果c字符串 "key" 非常长，则 <code class="computeroutput"><span class="identifier">Expensive</span></code> 必须使用堆内存来构造一个 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>。象 <code class="computeroutput"><span class="identifier">Expensive</span></code> 这样，很多时候参与排序的只是类的一小部分。例如，对于 <code class="computeroutput"><span class="identifier">Expensive</span></code>，比较对象时只需要其内部的 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>。
      </p>
<p>
        In both containers, if we call <code class="computeroutput"><span class="identifier">get_from_set</span><span class="special">/</span><span class="identifier">get_from_unordered_set</span></code>
        in a loop, we might get a performance penalty, because we are forced to create
        a whole <code class="computeroutput"><span class="identifier">Expensive</span></code> object
        to be able to find an equivalent one.<br>在这两个容器中，如果我们在一个循环中调用 <code class="computeroutput"><span class="identifier">get_from_set</span><span class="special">/</span><span class="identifier">get_from_unordered_set</span></code>，我们就有可能遇到性能的问题，因为我们被迫创建整个 <code class="computeroutput"><span class="identifier">Expensive</span></code> 对象才能查找相等的元素。
      </p>
<p>
        Sometimes this interface limitation is severe, because we <span class="bold"><strong>might
        not have enough information to construct the object</strong></span> but we might
        <span class="bold"><strong>have enough information to find the object</strong></span>.
        In this case, a name is enough to search <code class="computeroutput"><span class="identifier">Expensive</span></code>
        in the container but constructing an <code class="computeroutput"><span class="identifier">Expensive</span></code>
        might require more information that the user might not have.<br>有时候，这种接口的限制是严重的，因为我们<span class="bold"><strong>可能没有足够的信息来构造这个对象</strong></span>，不过我们可能<span class="bold"><strong>有足够的信息来找到这个对象</strong></span>。在这种情况下，有一个名字就足以在容器中查找 <code class="computeroutput"><span class="identifier">Expensive</span></code>，而构造一个 <code class="computeroutput"><span class="identifier">Expensive</span></code>
        则可能需要用户也许没有的信息。
      </p>


<p>
        To solve this, <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code> offer alternative functions,
        which take any type comparable with the value and a functor that should be
        compatible with the ordering function of the associative container. <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        offers functions that take any key type and compatible hash and equality
        functions. Now, let's see the optimized search function:<br>为了解决这一问题，<code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code> 提供了替代的函数，它接受可以与元素值相比较的任何类型，以及一个兼容于关联容器的排序函数的仿函数。<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code> 则提供了接受任何关键字类型的函数，以及兼容的散列函数和相等性函数。现在，我们来看一看优化后的查找函数：</p>
<pre class="programlisting"><span class="comment">// These compare Expensive and a c-string 将 Expensive 与一个c字符串进行比较<br></span><span class="keyword">struct</span> <span class="identifier">StrExpComp</span>
<span class="special">{</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">())</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">)</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">StrExpEqual</span>
<span class="special">{</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">())</span> <span class="special">==</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">)</span> <span class="special">==</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Optimized search functions 优化后的查找函数<br></span><span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_set_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrExpComp</span><span class="special">());</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_uset_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrHasher</span><span class="special">(),</span> <span class="identifier">StrExpEqual</span><span class="special">());</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>
</pre>


<p>
      
        This new arbitrary key overload is also available for other functions taking
        values as arguments:<br>这个新的任意键的重载对于其它以元素值作为参数的函数也可用：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          equal_range
        </li>
<li>
          lower_bound
        </li>
<li>
          upper_bound
        </li>
<li>
          count
        </li>
<li>
          find
        </li>
<li>
          erase
        </li>
</ul></div>
<p>
        Check <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>,
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        references to know more about those functions.<br>请查阅 <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>,
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code> 的参考手册，了解有关这些函数的更多信息。
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.advanced_lookups_insertions.advanced_insertions"></a><a class="link" href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_insertions" title="Advanced insertions">
      Advanced insertions 高级插入</a>
</h3></div></div></div>
<p>
        A similar issue happens with insertions in simple ordered and unordered associative
        containers with unique keys (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code> and
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code>).
        In these containers, if a value is already present, the value to be inserted
        is discarded. With expensive values, if the value is already present, we
        can suffer efficiency problems.<br>在往简单的具有唯一键的有序和无序关联容器(<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code> 和
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code>)中进行插入时也有类似问题。在这些容器中，如果一个值已经存在，则被插入的值将被丢弃。对于代价昂贵的值，如果值已经存在，则我们会经受效率的问题。
      </p>

<p>
        <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        have insertion functions to check efficiently, without constructing the value,
        if a value is present or not and if it's not present, a function to insert
        it immediately without any further lookup. For example, using the same <code class="computeroutput"><span class="identifier">Expensive</span></code> class, this function can be inefficient:<br><code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        具有无须构造插入值即可高效检查该值是否存在的插入函数，如果该值不存在，则另一个函数立即将它插入，不需要任何多余的查找。例如，使用相同的 <code class="computeroutput"><span class="identifier">Expensive</span></code> 类，以下函数是低效的：</p><pre class="programlisting"><span class="comment">// Insertion functions 插入函数<br></span><span class="keyword">bool</span> <span class="identifier">insert_to_set</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">pobject</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">pobject</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(!</span><span class="identifier">success</span><span class="special">)</span>   <span class="keyword">delete</span> <span class="identifier">pobject</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">insert_to_uset</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">pobject</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">pobject</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(!</span><span class="identifier">success</span><span class="special">)</span>   <span class="keyword">delete</span> <span class="identifier">pobject</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>
</pre>




<p>
      
        If the object is already present, we are constructing an <code class="computeroutput"><span class="identifier">Expensive</span></code>
        that will be discarded, and this is a waste of resources. Instead of that,
        let's use <code class="computeroutput"><span class="identifier">insert_check</span></code> and
        <code class="computeroutput"><span class="identifier">insert_commit</span></code> functions:<br>如果对象已存在，那么我们就构造了一个将被丢弃的 <code class="computeroutput"><span class="identifier">Expensive</span></code>，这是资源的浪费。相反，我们来使用 <code class="computeroutput"><span class="identifier">insert_check</span></code> 和
        <code class="computeroutput"><span class="identifier">insert_commit</span></code> 函数：</p>
<pre class="programlisting"><span class="comment">// Optimized insertion functions 优化的插入函数<br></span><span class="keyword">bool</span> <span class="identifier">insert_to_set_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">insert_commit_data</span> <span class="identifier">insert_data</span><span class="special">;</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert_check</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrExpComp</span><span class="special">(),</span> <span class="identifier">insert_data</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(</span><span class="identifier">success</span><span class="special">)</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert_commit</span><span class="special">(*</span><span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">),</span> <span class="identifier">insert_data</span><span class="special">);</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">insert_to_uset_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">insert_commit_data</span> <span class="identifier">insert_data</span><span class="special">;</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert_check</span>
      <span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrHasher</span><span class="special">(),</span> <span class="identifier">StrExpEqual</span><span class="special">(),</span> <span class="identifier">insert_data</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(</span><span class="identifier">success</span><span class="special">)</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert_commit</span><span class="special">(*</span><span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">),</span> <span class="identifier">insert_data</span><span class="special">);</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>
</pre>


<p>
        <code class="computeroutput"><span class="identifier">insert_check</span></code> is similar to
        a normal <code class="computeroutput"><span class="identifier">insert</span></code> but:<br><code class="computeroutput"><span class="identifier">insert_check</span></code> 类似于普通的 <code class="computeroutput"><span class="identifier">insert</span></code>，不过：
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="computeroutput"><span class="identifier">insert_check</span></code> can be used
          with arbitrary keys<br><code class="computeroutput"><span class="identifier">insert_check</span></code> 可以使用任意键
        </li>
<li>
          if the insertion is possible (there is no equivalent value) <code class="computeroutput"><span class="identifier">insert_check</span></code> collects all the needed
          information in an <code class="computeroutput"><span class="identifier">insert_commit_data</span></code>
          structure, so that <code class="computeroutput"><span class="identifier">insert_commit</span></code>:<br><code class="computeroutput"><span class="identifier"></span></code>如果插入是可以的(没有相同的值)，则 <code class="computeroutput"><span class="identifier">insert_check</span></code> 将所有需要的信息收集到一个 <code class="computeroutput"><span class="identifier">insert_commit_data</span></code>
          结构中，这样 <code class="computeroutput"><span class="identifier">insert_commit</span></code>:
          <div class="itemizedlist"><ul type="circle">
<li>
<span class="bold"><strong>does not execute</strong></span> further comparisons<br><span class="bold"><strong>不执行</strong></span>多余的比较。
            </li>
<li>
              can be executed with <span class="bold"><strong>constant-time complexity</strong></span><br><code class="computeroutput"><span class="identifier"></span></code>可以以<span class="bold"><strong>常数时间复杂度</strong></span>执行。
</li>
<li>
              has <span class="bold"><strong>no-throw guarantee</strong></span>.<br><code class="computeroutput"><span class="identifier"></span></code>具有<span class="bold"><strong>无抛出保证</strong></span>。
            </li>
</ul></div>
</li>
</ul></div>
<p>
        These functions must be used with care, since no other insertion or erasure
        must be executed between an <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and an <code class="computeroutput"><span class="identifier">insert_commit</span></code> pair.
        Otherwise, the behaviour is undefined. <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and <code class="computeroutput"><span class="identifier">insert_commit</span></code> will come
        in handy for developers programming efficient non-intrusive associative containers.
        See <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> reference
        for more information about <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and <code class="computeroutput"><span class="identifier">insert_commit</span></code>.<br>这些函数必须小心使用，因为在一对 <code class="computeroutput"><span class="identifier">insert_check</span></code> 和 <code class="computeroutput"><span class="identifier">insert_commit</span></code> 之间必须不能有其它插入或删除。否则，行为将是未定义的。<code class="computeroutput"><span class="identifier">insert_check</span></code> 和 <code class="computeroutput"><span class="identifier">insert_commit</span></code> 对于编写高效的非介入式关联容器也能派上用场。有关 <code class="computeroutput"><span class="identifier">insert_check</span></code> 和 <code class="computeroutput"><span class="identifier">insert_commit</span></code> 的更多信息，请见 <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 的参考手册。
      </p>
<p>
        With multiple ordered and unordered associative containers (<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>)
        there's no need for these advanced insertion functions, since insertions
        are always succesful.<br>对于非唯一的有序和无序关联容器(<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>)，不需要这些插入函数，因为插入操作总是成功的。
      </p>
</div>
<p>
      For more information about advanced lookup and insertion functions see <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>,
      <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
      references.<br>有关高级查找和插入函数的更多信息，请见 <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>,
      <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> 和 <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code> 的参考手册。
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 Olaf Krzikalla, 2006-2007 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sg_set_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="erasing_and_disposing.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body></html>
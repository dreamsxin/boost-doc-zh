<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Design Rationale</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../array.html" title="Chapter2.Boost.Array">
<link rel="prev" href="../boost/array.html" title="Class template array">
<link rel="next" href="more/info.html" title="For more information...">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../boost/array.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../array.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="more/info.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="array.rationale"></a>Design Rationale 基本设计原理</h2></div></div></div>
<p>有一个重要的关于构造函数的设计权衡：我们可以将 array 实现为一个“集合体”（参见 C++ 标准的 8.5.1, [dcl.init.aggr]）。这就意味着：</p>
<div class="itemizedlist"><ul type="disc"><li>
<p>一个数组能被一个大括号括起来的，逗号分隔的初始化列表初始化，初始化列表按照容器中各元素的下标递增的顺序排列：</p>
<pre class="programlisting"><code class="computeroutput"><a href="../boost/array.html" title="Class template array">boost::array</a></code>&lt;int,4&gt; a = { { 1, 2, 3 } };</pre>
<p>注意，如果初始化列表中的值少于元素的个数，则多余的元素会被默认初始化（这样，它就有了一个已定义的值）。</p>
</li></ul></div>
<p>然而，这种方法也有它的劣势：<span class="bold"><strong>不传递初始化列表意味着元素有一个不确定的初始值</strong></span>，因为规则规定集合体应该：</p>
<div class="itemizedlist"><ul type="disc">
<li>无用户声明的构造函数。</li>
<li>无私有的或保护的非静态数据成员。</li>
<li>无基类。</li>
<li>无虚拟函数。</li>
</ul></div>
<p>
  </p>
<p>无论如何，当前的实现使用了这个方法。</p>
<p>注意，对于兼容标准的编译器，可能会使用更少的大括号（根据标准的 8.5.1 (11)）。也就是说，你可以像这样初始化一个 array：</p>
<pre class="programlisting">
<code class="computeroutput"><a href="../boost/array.html" title="Class template array">boost::array</a></code>&lt;int,4&gt; a = { 1, 2, 3 };
</pre>
<p>我感激任何有建设性的反馈。<span class="bold"><strong>请注意：我没有时间阅读所有的 boost 邮件。因此，为了确保反馈能被我收到，请把关于这个类的每一封邮件发给我一份拷贝。</strong></span></p>
<p>The code is provided "as is" without expressed or implied warranty.</p>
</div>
<table width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright  2001-2004 Nicolai M. Josuttis</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../boost/array.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../array.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="more/info.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
